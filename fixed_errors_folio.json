{
    "gcd_llama-2-7b_3.5": [
        {
            "id": 2,
            "raw_prog": {
                "First-Order-Logic Rules": "∀x (Perform(x) → (Attend(x) ∧ Engaged(x))) ::: If people perform in school talent shows often, then they attend and are very engaged with school events.\n∀x ((Perform(x) ∨ (Inactive(x) ∧ Disinterested(x))) ::: People either perform in school talent shows often or are inactive and disinterested members of their community.\n∀x (Chaperone(x) → ¬Student(x)) ::: If people chaperone high school dances, then they are not students who attend the school.\n∀x ((Inactive(x) ∧ Disinterested(x)) → Chaperone(x)) ::: All people who are inactive and disinterested members of their community chaperone high school dances.\n∀x ((Young(x) ∨ Teenager(x)) ∧ Wish(x) → Student(x)) ::: All young children and teenagers who wish to further their academic careers and educational opportunities are students who attend the school.\n¬((Attend(Bonnie) ∧ Engaged(Bonnie)) ⊕ Student(Bonnie)) ::: Bonnie either both attends and is very engaged with school events and is a student who attends the school, or she neither attends and is very engaged with school events nor is a student who attends the school.\n",
                "First-Order-Logic Question": "((Chaperone(Bonnie) ∨ ¬Chaperone(Bonnie) ∧ Perform(Bonnie)) → ((Young(Bonnie) ∨ Teenager(Bonnie)) ∧ Wish(Bonnie) ∧ Inactive(Bonnie) ∧ Disinterested(Bonnie))) ::: If Bonnie either chaperones high school dances or, if she does not, she performs in school talent shows often, then Bonnie is both a young child or teenager who wishes to further her academic career and educational opportunities and an inactive and disinterested member of the community."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∀x (Perform(x) → (Attend(x) ∧ Engaged(x))) ::: If people perform in school talent shows often, then they attend and are very engaged with school events.\n∀x((Perform(x)∨Inactive(x))) ::: People either perform in school talent shows often or are inactive and disinterested members of their community.\n∀x (Chaperone(x) → ¬Student(x)) ::: If people chaperone high school dances, then they are not students who attend the school.\n∀x ((Inactive(x) ∧ Disinterested(x)) → Chaperone(x)) ::: All people who are inactive and disinterested members of their community chaperone high school dances.\n∀x ((Young(x) ∨ Teenager(x)) ∧ Wish(x) → Student(x)) ::: All young children and teenagers who wish to further their academic careers and educational opportunities are students who attend the school.\n¬((Attend(Bonnie) ∧ Engaged(Bonnie)) ⊕ Student(Bonnie)) ::: Bonnie either both attends and is very engaged with school events and is a student who attends the school, or she neither attends and is very engaged with school events nor is a student who attends the school.\n",
                "First-Order-Logic Question": "((Chaperone(Bonnie) ∨ ¬Chaperone(Bonnie) ∧ Perform(Bonnie)) → ((Young(Bonnie) ∨ Teenager(Bonnie)) ∧ Wish(Bonnie) ∧ Inactive(Bonnie) ∧ Disinterested(Bonnie))) ::: If Bonnie either chaperones high school dances or, if she does not, she performs in school talent shows often, then Bonnie is both a young child or teenager who wishes to further her academic career and educational opportunities and an inactive and disinterested member of the community."
            },
            "diff": [
                {
                    "raw": "∀x ((Perform(x) ∨ (Inactive(x) ∧ Disinterested(x))) ::: People either perform in school talent shows often or are inactive and disinterested members of their community.",
                    "gram": "∀x((Perform(x)∨Inactive(x))) ::: People either perform in school talent shows often or are inactive and disinterested members of their community."
                }
            ],
            "answer": "B",
            "error_type":"",
            "grammar_answer": "C"
        },
        {
            "id": 3,
            "raw_prog": {
                "First-Order-Logic Rules": "∀x∀y (Employee(x) ∧ ScheduleMeeting(x, y) → AppearInCompany(x)) ::: All employees who schedule a meeting with their customers will appear in the company today. \n∀x (HasLunchInCompany(x) → ScheduleMeeting(x, Customer(x))) ::: Everyone who has lunch in the company schedules meetings with their customers. \n∀x (HasLunchInCompany(x) ∨ HasLunchAtHome(x)) ::: Employees will either have lunch in the company or have lunch at home. \n∀x (HasLunchAtHome(x) → WorkRemotelyFromHome(x)) ::: If an employee has lunch at home, then he/she is working remotely from home. \n∀x (InOtherCountries(x) → WorkRemotelyFromHome(x)) ::: All employees who are in other countries work remotely from home. \n∀x (Manager(x) → ¬WorkRemotelyFromHome(x)) ::: No managers work remotely from home. \n(Employee(james) ∧ AppearInCompany(james)) ⊕ (¬Manager(james) ∧ ¬AppearInCompany(james)) ::: James is either a manager and appears in the company today or neither a manager nor appears in the company today.",
                "First-Order-Logic Question": "HasLunchInCompany(james) ::: James has lunch in the company."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∀x∀y (Employee(x) ∧ ScheduleMeeting(x, y) → AppearInCompany(x)) ::: All employees who schedule a meeting with their customers will appear in the company today. \n∀x(HasLunchInCompany(x)→ScheduleMeeting(x,y)) ::: Everyone who has lunch in the company schedules meetings with their customers. \n∀x (HasLunchInCompany(x) ∨ HasLunchAtHome(x)) ::: Employees will either have lunch in the company or have lunch at home. \n∀x (HasLunchAtHome(x) → WorkRemotelyFromHome(x)) ::: If an employee has lunch at home, then he/she is working remotely from home. \n∀x (InOtherCountries(x) → WorkRemotelyFromHome(x)) ::: All employees who are in other countries work remotely from home. \n∀x (Manager(x) → ¬WorkRemotelyFromHome(x)) ::: No managers work remotely from home. \n(Employee(james) ∧ AppearInCompany(james)) ⊕ (¬Manager(james) ∧ ¬AppearInCompany(james)) ::: James is either a manager and appears in the company today or neither a manager nor appears in the company today.",
                "First-Order-Logic Question": "HasLunchInCompany(james) ::: James has lunch in the company."
            },
            "diff": [
                {
                    "raw": "∀x (HasLunchInCompany(x) → ScheduleMeeting(x, Customer(x))) ::: Everyone who has lunch in the company schedules meetings with their customers. ",
                    "gram": "∀x(HasLunchInCompany(x)→ScheduleMeeting(x,y)) ::: Everyone who has lunch in the company schedules meetings with their customers. "
                }
            ],
            "answer": "C",
            "error_type":"",
            "grammar_answer": "C"
        },
        {
            "id": 4,
            "raw_prog": {
                "First-Order-Logic Rules": "∀x∀y (Schedule(x, y) → Appear(x)) ::: All employees who schedule a meeting with their customers will appear in the company today. \n∀x (Lunch(x) → ∃y (Schedule(x, y))) ::: Everyone who has lunch in the company schedules meetings with their customers. \n∀x (Lunch(x) ∨ Home(x)) ::: Employees will either have lunch in the company or have lunch at home. \n∀x (Home(x) → Remote(x)) ::: If an employee has lunch at home, then he/she is working remotely from home. \n∀x (Work(x, y) → Remote(x)) ::: All employees who are in other countries work remotely from home. \n∀x (Manager(x) → ¬Remote(x)) ::: No managers work remotely from home. \n(Manager(james) ∧ Appear(james)) ⊕ (¬Manager(james) ∧ ¬Appear(james)) ::: James is either a manager and appears in the company today or neither a manager nor appears in the company today.",
                "First-Order-Logic Question": "¬Lunch(james) ::: James does not have lunch in the company."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∀x∀y (Schedule(x, y) → Appear(x)) ::: All employees who schedule a meeting with their customers will appear in the company today. \n∀x (Lunch(x) → ∃y (Schedule(x, y))) ::: Everyone who has lunch in the company schedules meetings with their customers. \n∀x (Lunch(x) ∨ Home(x)) ::: Employees will either have lunch in the company or have lunch at home. \n∀x (Home(x) → Remote(x)) ::: If an employee has lunch at home, then he/she is working remotely from home. \n∀x (Work(x, y) → Remote(x)) ::: All employees who are in other countries work remotely from home. \n∀x (Manager(x) → ¬Remote(x)) ::: No managers work remotely from home. \n(Manager(james) ∧ Appear(james)) ⊕ (¬Manager(james) ∧ ¬Appear(james)) ::: James is either a manager and appears in the company today or neither a manager nor appears in the company today.",
                "First-Order-Logic Question": "¬Lunch(james) ::: James does not have lunch in the company."
            },
            "diff": [],
            "answer": "C",
            "error_type":"",
            "grammar_answer": "C"
        },
        {
            "id": 43,
            "raw_prog": {
                "First-Order-Logic Rules": "∀x (RankedHighly(x) → Active(x)) ::: If a player is ranked highly by the Women's Tennis Association, then they are among the most active players in major tennis. \n∀x (LostTo(x, IgaSwiatek) → RankedHighly(x)) ::: Everyone who lost to Iga Swiatek is ranked highly by the Women's Tennis Association. \n∀x (Female(x) ∧ At(x, RolandGarros) → LostTo(x, IgaSwiatek)) ::: All female tennis players at Roland Garros 2022 lost to Iga Swiatek. \n(Female(x) ∧ At(x, RolandGarros)) ∨ (Male(x) ∧ At(x, RolandGarros)) ::: Either female tennis players at Roland Garros 2022 or male tennis players at Roland Garros 2022. \n∀x (Male(x) ∧ At(x, RolandGarros) → LostToRafaelNadal(x)) ::: All male tennis players at Roland Garros 2022 lost to Rafael Nadal. \n(RankedHighly(CocoGauff) ∨ LostTo(CocoGauff, RafaelNadal)) → ¬(Male(CocoGauff) ∧ At(CocoGauff, RolandGarros)) ::: If Coco Gauff is a player who is ranked highly by the Women's Tennis Association or a player who lost to Rafael Nadal, then Coco Gauff is not a male tennis player at Roland Garros 2022. \n",
                "First-Order-Logic Question": "LostTo(CocoGauff, RafaelNadal) ::: Coco Gauff has lost to Rafael Nadal."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∀x (RankedHighly(x) → Active(x)) ::: If a player is ranked highly by the Women's Tennis Association, then they are among the most active players in major tennis. \n∀x (LostTo(x, IgaSwiatek) → RankedHighly(x)) ::: Everyone who lost to Iga Swiatek is ranked highly by the Women's Tennis Association. \n∀x (Female(x) ∧ At(x, RolandGarros) → LostTo(x, IgaSwiatek)) ::: All female tennis players at Roland Garros 2022 lost to Iga Swiatek. \n(Female(x) ∧ At(x, RolandGarros)) ∨ (Male(x) ∧ At(x, RolandGarros)) ::: Either female tennis players at Roland Garros 2022 or male tennis players at Roland Garros 2022. \n∀x (Male(x) ∧ At(x, RolandGarros) → LostToRafaelNadal(x)) ::: All male tennis players at Roland Garros 2022 lost to Rafael Nadal. \n(RankedHighly(CocoGauff) ∨ LostTo(CocoGauff, RafaelNadal)) → ¬(Male(CocoGauff) ∧ At(CocoGauff, RolandGarros)) ::: If Coco Gauff is a player who is ranked highly by the Women's Tennis Association or a player who lost to Rafael Nadal, then Coco Gauff is not a male tennis player at Roland Garros 2022. \n",
                "First-Order-Logic Question": "LostTo(CocoGauff, RafaelNadal) ::: Coco Gauff has lost to Rafael Nadal."
            },
            "diff": [],
            "answer": "C",
            "error_type":"",
            "grammar_answer": "C"
        },
        {
            "id": 48,
            "raw_prog": {
                "First-Order-Logic Rules": "Season(spring) ∧ Season(summer) ∧ Season(fall) ∧ Season(winter) ::: There are four seasons in a year: Spring, Summer, Fall, and Winter. \n∀x (Student(x) ∧ WantLongVacation(x) → Love(x, summer)) ::: All students who want to have a long vacation love summer the most. \nFavoriteSeason(emma, summer) ::: Emma's favorite season is summer. \n∀x (FavoriteSeason(mia, y) → ¬FavoriteSeason(emma, y)) ::: Mia's favorite season is not the same as Emma's. \nWantLongVacation(james) ::: James wants to have a long vacation.",
                "First-Order-Logic Question": "FavoriteSeason(mia, spring) ::: Mia's favorite season is spring."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "Season(spring) ∧ Season(summer) ∧ Season(fall) ∧ Season(winter) ::: There are four seasons in a year: Spring, Summer, Fall, and Winter. \n∀x (Student(x) ∧ WantLongVacation(x) → Love(x, summer)) ::: All students who want to have a long vacation love summer the most. \nFavoriteSeason(emma, summer) ::: Emma's favorite season is summer. \n∀x (FavoriteSeason(mia, y) → ¬FavoriteSeason(emma, y)) ::: Mia's favorite season is not the same as Emma's. \nWantLongVacation(james) ::: James wants to have a long vacation.",
                "First-Order-Logic Question": "FavoriteSeason(mia, spring) ::: Mia's favorite season is spring."
            },
            "diff": [],
            "answer": "C",
            "error_type":"",
            "grammar_answer": "C"
        },
        {
            "id": 52,
            "raw_prog": {
                "First-Order-Logic Rules": "∀x (Romance(x) → IndoEuropean(x)) ::: All Romance languages are Indo-European languages.\nLanguageFamily(romance) ::: The Romance languages are a language family.\n∀x ∀y (LanguageFamily(x) ∧ LanguageFamily(y) → Related(x, y)) ::: All languages within a language family are related to each other.\nRomance(french) ∧ Romance(spanish) ::: French and Spanish are both Romance languages.\nRelated(german, spanish) ::: German is related to Spanish.\nBasque ::: Basque is not related to any other language.",
                "First-Order-Logic Question": "Romance(basque) ::: Basque is a Romance language."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∀x (RomanceLanguage(x) → IndoEuropeanLanguage(x)) ::: All Romance languages are Indo-European languages.\nLanguageFamily(romance) ::: The Romance languages are a language family.\n∀x ∀y (LanguageFamily(x) ∧ LanguageFamily(y) → RelatedLanguages(x, y)) ::: All languages within a language family are related to each other.\nRomanceLanguage(french) ∧ RomanceLanguage(spanish) ::: French and Spanish are both Romance languages.\nRelatedLanguages(german, spanish) ::: German is related to Spanish.\nBasqueLanguage(x) → ¬RelatedLanguages(x,y) ::: Basque language is not related to any other language.",
                "First-Order-Logic Question": "RomanceLanguage(basque) ::: Basque language is a Romance language."
            },
            "diff": [
                {
                    "raw": "∀x (Romance(x) → IndoEuropean(x)) ::: All Romance languages are Indo-European languages.",
                    "gram": "∀x (RomanceLanguage(x) → IndoEuropeanLanguage(x)) ::: All Romance languages are Indo-European languages."
                },
                {
                    "raw": "Romance(french) ∧ Romance(spanish) ::: French and Spanish are both Romance languages.",
                    "gram": "RomanceLanguage(french) ∧ RomanceLanguage(spanish) ::: French and Spanish are both Romance languages."
                },
                {
                    "raw": "Related(german, spanish) ::: German is related to Spanish.",
                    "gram": "RelatedLanguages(german, spanish) ::: German is related to Spanish."
                },
                {
                    "raw": "Basque ::: Basque is not related to any other language.",
                    "gram": "BasqueLanguage(x) → ¬RelatedLanguages(x,y) ::: Basque language is not related to any other language."
                },
                {
                    "raw": "Romance(basque) ::: Basque is a Romance language.",
                    "gram": "RomanceLanguage(basque) ::: Basque language is a Romance language."
                }
            ],
            "answer": "B",
            "error_type":"",
            "grammar_answer": "C"
        },
        {
            "id": 57,
            "raw_prog": {
                "First-Order-Logic Rules": "Striker(robertlewandowski) ::: Robert Lewandowski is a striker.\n∀x (Striker(x) → SoccerPlayer(x)) ::: Strikers are soccer players.\nLeftTeam(robertlewandowski, bayernmunchen) ::: Robert Lewandowski left Bayern Munchen.\n∀x∀y (LeftTeam(x, y) → ¬PlayFor(x, y)) ::: If a player left a team they no longer play for that team.",
                "First-Order-Logic Question": "Star(robertlewandowski) ::: Robert Lewandowski is a star."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "Striker(robertlewandowski) ::: Robert Lewandowski is a striker.\n∀x (Striker(x) → SoccerPlayer(x)) ::: Strikers are soccer players.\nLeftTeam(robertlewandowski, bayernmunchen) ::: Robert Lewandowski left Bayern Munchen.\n∀x∀y (LeftTeam(x, y) → ¬PlayFor(x, y)) ::: If a player left a team they no longer play for that team.",
                "First-Order-Logic Question": "Star(robertlewandowski) ::: Robert Lewandowski is a star."
            },
            "diff": [],
            "answer": "C",
            "error_type":"",
            "grammar_answer": "C"
        },
        {
            "id": 58,
            "raw_prog": {
                "First-Order-Logic Rules": "City(billings) ∧ City(butte) ∧ City(helena) ∧ City(missoula) ∧ City(whiteSulphurSprings) ∧ City(pierre) ∧ State(montana) ∧ State(southDakota) ∧ State(x) ∧ In(billings, montana) ∧ In(butte, montana) ∧ In(helena, montana) ∧ In(missoula, montana) ∧ In(whiteSulphurSprings, montana) ∧ In(butte, x) ∧ ¬In(pierre, southDakota) ∧ ∀x (In(x, butte) → ¬In(x, pierre)) ::: Billings is a city in Montana. Montana includes the cities of Butte, Helena, and Missoula. White Sulphur Springs and Butte are cities in the same state. The city of Pierre is not in Montana. Any city in Butte is not in Pierre.",
                "First-Order-Logic Question": "SameState(butte, pierre) ::: Butte and Pierre are in the same state."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "City(x)→¬In(x,y)→¬In(y,z)→¬In(x,z) ::: Billings is a city in Montana. Montana includes the cities of Butte, Helena, and Missoula. White Sulphur Springs and Butte are cities in the same state. The city of Pierre is not in Montana. Any city in Butte is not in Pierre.",
                "First-Order-Logic Question": "SameState(butte, pierre) ::: Butte and Pierre are in the same state."
            },
            "diff": [
                {
                    "raw": "City(billings) ∧ City(butte) ∧ City(helena) ∧ City(missoula) ∧ City(whiteSulphurSprings) ∧ City(pierre) ∧ State(montana) ∧ State(southDakota) ∧ State(x) ∧ In(billings, montana) ∧ In(butte, montana) ∧ In(helena, montana) ∧ In(missoula, montana) ∧ In(whiteSulphurSprings, montana) ∧ In(butte, x) ∧ ¬In(pierre, southDakota) ∧ ∀x (In(x, butte) → ¬In(x, pierre)) ::: Billings is a city in Montana. Montana includes the cities of Butte, Helena, and Missoula. White Sulphur Springs and Butte are cities in the same state. The city of Pierre is not in Montana. Any city in Butte is not in Pierre.",
                    "gram": "City(x)→¬In(x,y)→¬In(y,z)→¬In(x,z) ::: Billings is a city in Montana. Montana includes the cities of Butte, Helena, and Missoula. White Sulphur Springs and Butte are cities in the same state. The city of Pierre is not in Montana. Any city in Butte is not in Pierre."
                }
            ],
            "answer": "B",
            "error_type":"",
            "grammar_answer": "C"
        },
        {
            "id": 59,
            "raw_prog": {
                "First-Order-Logic Rules": "City(billings) ∧ In(billings, montana) ::: Billings is a city in Montana.\nInclude(montana, butte) ∧ Include(montana, helena) ∧ Include(montana, missoula) ::: Montana includes the cities of Butte, Helena, and Missoula.\nCity(white_sulphur_springs) ∧ City(butte) ∧ SameState(white_sulphur_springs, butte) ::: White Sulphur Springs and Butte are cities in the same state.\n¬In(pierre, montana) ::: The city of Pierre is not in Montana.\n∀x (City(x) ∧ In(x, butte) → ¬In(x, pierre)) ::: Any city in Butte is not in Pierre.\n",
                "First-Order-Logic Question": "SameState(pierre, bismarck) ::: Pierre and Bismarck are in the same state."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "City(billings) ∧ In(billings, montana) ::: Billings is a city in Montana.\nInclude(montana, butte) ∧ Include(montana, helena) ∧ Include(montana, missoula) ::: Montana includes the cities of Butte, Helena, and Missoula.\nCity(white_sulphur_springs) ∧ City(butte) ∧ SameState(white_sulphur_springs, butte) ::: White Sulphur Springs and Butte are cities in the same state.\n¬In(pierre, montana) ::: The city of Pierre is not in Montana.\n∀x (City(x) ∧ In(x, butte) → ¬In(x, pierre)) ::: Any city in Butte is not in Pierre.\n",
                "First-Order-Logic Question": "SameState(pierre, bismarck) ::: Pierre and Bismarck are in the same state."
            },
            "diff": [],
            "answer": "C",
            "error_type":"",
            "grammar_answer": "C"
        },
        {
            "id": 61,
            "raw_prog": {
                "First-Order-Logic Rules": "∀x (InternationalStudent(x) ∧ InUS(x) → (HasVisa(x, F1Visa) ∨ HasVisa(x, J1Visa))) ::: International students in US have either an F1 visa or a J1 visa. \n∀x (InternationalStudent(x) ∧ InUS(x) ∧ HasVisa(x, F1Visa) ∧ WorkInUS(x) → NeedsToApplyFor(x, CPT)) ::: An international student in US with an F1 visa needs to apply for CPT or OPT if the student wants to work in the US. \nInternationalStudent(mike) ::: Mike is an international student. \nWorkInUS(mike) ∧ NeedsToApplyFor(mike, CPT) ::: Mike needs to apply for CPT if he wants to work in the US.",
                "First-Order-Logic Question": "HasVisa(mike, F1Visa) ::: Mike has an F1 visa."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∀x (InternationalStudent(x) ∧ InUS(x) → (HasVisa(x, F1Visa) ∨ HasVisa(x, J1Visa))) ::: International students in US have either an F1 visa or a J1 visa. \n∀x (InternationalStudent(x) ∧ InUS(x) ∧ HasVisa(x, F1Visa) ∧ WorkInUS(x) → NeedsToApplyFor(x, CPT)) ::: An international student in US with an F1 visa needs to apply for CPT or OPT if the student wants to work in the US. \nInternationalStudent(mike) ::: Mike is an international student. \nWorkInUS(mike) ∧ NeedsToApplyFor(mike, CPT) ::: Mike needs to apply for CPT if he wants to work in the US.",
                "First-Order-Logic Question": "HasVisa(mike, F1Visa) ::: Mike has an F1 visa."
            },
            "diff": [],
            "answer": "C",
            "error_type":"",
            "grammar_answer": "C"
        },
        {
            "id": 73,
            "raw_prog": {
                "First-Order-Logic Rules": "∀x (GrowthStock(x) → Volatile(x)) ::: All growth stocks of companies are volatile.\n∀x (Volatile(x) → ¬SuitableForRetirement(x)) ::: If the stock price is volatile, then it is not suitable for a retirement fund.\n∃x ∃y (GrowthStock(x) ∧ Company(y)) ::: Some stocks of some companies are growth stocks of companies.\n∀x (Stock(x) ∧ MatureCompany(x) → SuitableForRetirement(x)) ::: All stocks of mature companies are suitable for a retirement fund.\nKO(ko) ∧ Stock(ko) ∧ MatureCompany(ko) ::: KO is a stock of a mature company.\n",
                "First-Order-Logic Question": "(GrowthStock(ko) ∨ Volatile(ko)) → (¬Stock(ko) ∧ ¬Volatile(ko)) ::: If KO is a growth stock of a company or if its price is volatile, then KO is neither a stock of a company nor is its price volatile."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∀x (GrowthStock(x) → Volatile(x)) ::: All growth stocks of companies are volatile.\n∀x (Volatile(x) → ¬SuitableForRetirement(x)) ::: If the stock price is volatile, then it is not suitable for a retirement fund.\n∃x ∃y (GrowthStock(x) ∧ Company(y)) ::: Some stocks of some companies are growth stocks of companies.\n∀x (Stock(x) ∧ MatureCompany(x) → SuitableForRetirement(x)) ::: All stocks of mature companies are suitable for a retirement fund.\nKO(ko) ∧ Stock(ko) ∧ MatureCompany(ko) ::: KO is a stock of a mature company.\n",
                "First-Order-Logic Question": "(GrowthStock(ko) ∨ Volatile(ko)) → (¬Stock(ko) ∧ ¬Volatile(ko)) ::: If KO is a growth stock of a company or if its price is volatile, then KO is neither a stock of a company nor is its price volatile."
            },
            "diff": [],
            "answer": "A",
            "error_type":"",
            "grammar_answer": "A"
        },
        {
            "id": 93,
            "raw_prog": {
                "First-Order-Logic Rules": "∃x (Pet(x) ∧ AllowedIn(x, y)) ::: Pets are allowed in some managed buildings.\n∀x (RequireDeposit(x) → ∃y (RentApartment(z, y) ∧ SecurityDeposit(x) ∧ (Equal(SecurityDeposit(x), RentAmount(y)) ∨ MoreThan(SecurityDeposit(x), RentAmount(y))))) ::: A deposit is required to rent an apartment in a managed building. The security deposit can be either equal to one month's rent or more.\nCat(fluffy) ∧ Pet(fluffy) ∧ Owner(tom, fluffy) ::: Fluffy is Tom's cat.\nCat(x) → Pet(x) ::: Cats are pets.\nManagedBuilding(olivegarden) ::: The Olive Garden is a managed building.\nRentAmount(2000, olivegarden) ::: The monthly rent at the Olive Garden is $2000.\nRentApartment(tom, olivegarden) ↔ (AllowedIn(tom, olivegarden) ∧ SecurityDeposit(olivegarden) ∧ (Equal(SecurityDeposit(olivegarden), 1500) ∨ ¬MoreThan(SecurityDeposit(olivegarden), 1500))) ::: Tom will rent an apartment in a managed building if and only if he is allowed to move in with Fluffy, and the security deposit is no more than $1500.\nMoreThan(2000, 1500) ::: 2000$ is more than $1500.",
                "First-Order-Logic Question": "RentApartment(tom, olivegarden) ::: Tom will rent an apartment in The Olive Garden."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∃x (Pet(x) ∧ AllowedIn(x, y)) ::: Pets are allowed in some managed buildings.\nRequireDeposit(x)→¬(AllowedIn(x,y)∧ManagedBuilding(x)) ::: A deposit is required to rent an apartment in a managed building. The security deposit can be either equal to one month's rent or more.\nCat(fluffy) ∧ Pet(fluffy) ∧ Owner(tom, fluffy) ::: Fluffy is Tom's cat.\nCat(x) → Pet(x) ::: Cats are pets.\nManagedBuilding(olivegarden) ::: The Olive Garden is a managed building.\nRentAmount(2000, olivegarden) ::: The monthly rent at the Olive Garden is $2000.\nRentApartment(x,y)↔(AllowedIn(x,y)∧SecurityDeposit(y)) ::: Tom will rent an apartment in a managed building if and only if he is allowed to move in with Fluffy, and the security deposit is no more than $1500.\nMoreThan(2000, 1500) ::: 2000$ is more than $1500.",
                "First-Order-Logic Question": "RentApartment(tom, olivegarden) ::: Tom will rent an apartment in The Olive Garden."
            },
            "diff": [
                {
                    "raw": "∀x (RequireDeposit(x) → ∃y (RentApartment(z, y) ∧ SecurityDeposit(x) ∧ (Equal(SecurityDeposit(x), RentAmount(y)) ∨ MoreThan(SecurityDeposit(x), RentAmount(y))))) ::: A deposit is required to rent an apartment in a managed building. The security deposit can be either equal to one month's rent or more.",
                    "gram": "RequireDeposit(x)→¬(AllowedIn(x,y)∧ManagedBuilding(x)) ::: A deposit is required to rent an apartment in a managed building. The security deposit can be either equal to one month's rent or more."
                },
                {
                    "raw": "RentApartment(tom, olivegarden) ↔ (AllowedIn(tom, olivegarden) ∧ SecurityDeposit(olivegarden) ∧ (Equal(SecurityDeposit(olivegarden), 1500) ∨ ¬MoreThan(SecurityDeposit(olivegarden), 1500))) ::: Tom will rent an apartment in a managed building if and only if he is allowed to move in with Fluffy, and the security deposit is no more than $1500.",
                    "gram": "RentApartment(x,y)↔(AllowedIn(x,y)∧SecurityDeposit(y)) ::: Tom will rent an apartment in a managed building if and only if he is allowed to move in with Fluffy, and the security deposit is no more than $1500."
                }
            ],
            "answer": "B",
            "error_type":"",
            "grammar_answer": "C"
        },
        {
            "id": 94,
            "raw_prog": {
                "First-Order-Logic Rules": "∃x (Pet(x) ∧ ManagedBuilding(y) ∧ AllowedIn(x, y)) ::: Pets are allowed in some managed buildings.\n∀x (ManagedBuilding(x) → RequireDeposit(x)) ::: A deposit is required to rent an apartment in a managed building.\n∀x (SecurityDeposit(x) → (Equal(x, Rent) ∨ MoreThan(x, Rent))) ::: The security deposit can be either equal to one month's rent or more.\nCat(fluffy) ∧ Pet(fluffy) ∧ Owner(tom, fluffy) ::: Fluffy is Tom's cat.\n∀x (Cat(x) → Pet(x)) ::: Cats are pets.\nManagedBuilding(olivegarden) ::: The Olive Garden is a managed building.\nPrice(olivegarden, 2000) ::: The monthly rent at the Olive Garden is $2000.\nRentApartment(tom, olivegarden) ↔ (AllowedIn(tom, olivegarden) ∧ ¬MoreThan(SecurityDeposit(olivegarden), 1500)) ::: Tom will rent an apartment in a managed building if and only if he is allowed to move in with Fluffy, and the security deposit is no more than $1500.\nMoreThan(2000, 1500) ::: 2000$ is more than $1500.\n",
                "First-Order-Logic Question": "RentApartment(tom, olivegarden) ∧ MoveInWith(tom, fluffy) ::: Tom is allowed to move in an apartment in The Olive Garden with Fluffy."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∃x (Pet(x) ∧ ManagedBuilding(y) ∧ AllowedIn(x, y)) ::: Pets are allowed in some managed buildings.\n∀x (ManagedBuilding(x) → RequireDeposit(x)) ::: A deposit is required to rent an apartment in a managed building.\n∀x (SecurityDeposit(x) → (Equal(x, Rent) ∨ MoreThan(x, Rent))) ::: The security deposit can be either equal to one month's rent or more.\nCat(fluffy) ∧ Pet(fluffy) ∧ Owner(tom, fluffy) ::: Fluffy is Tom's cat.\n∀x (Cat(x) → Pet(x)) ::: Cats are pets.\nManagedBuilding(olivegarden) ::: The Olive Garden is a managed building.\nPrice(olivegarden, 2000) ::: The monthly rent at the Olive Garden is $2000.\nRentApartment(x,y)↔(AllowedIn(x,y)∧¬MoreThan(y,x)) ::: Tom will rent an apartment in a managed building if and only if he is allowed to move in with Fluffy, and the security deposit is no more than $1500.\nMoreThan(2000, 1500) ::: 2000$ is more than $1500.\n",
                "First-Order-Logic Question": "RentApartment(tom, olivegarden) ∧ MoveInWith(tom, fluffy) ::: Tom is allowed to move in an apartment in The Olive Garden with Fluffy."
            },
            "diff": [
                {
                    "raw": "RentApartment(tom, olivegarden) ↔ (AllowedIn(tom, olivegarden) ∧ ¬MoreThan(SecurityDeposit(olivegarden), 1500)) ::: Tom will rent an apartment in a managed building if and only if he is allowed to move in with Fluffy, and the security deposit is no more than $1500.",
                    "gram": "RentApartment(x,y)↔(AllowedIn(x,y)∧¬MoreThan(y,x)) ::: Tom will rent an apartment in a managed building if and only if he is allowed to move in with Fluffy, and the security deposit is no more than $1500."
                }
            ],
            "answer": "C",
            "error_type":"",
            "grammar_answer": "C"
        },
        {
            "id": 104,
            "raw_prog": {
                "First-Order-Logic Rules": "∀x (Twins(x) ∨ Triplets(x) → SpendTimeWith(x, x)) ::: If people are twins or triplets, then they spend a lot of time hanging out with and playing with their siblings.\n∀x (Siblings(x, y) → Twins(x) ∨ Triplets(x)) ::: If people have siblings who are the same age, then they are twins or triplets.\n∀x (Complain(x) → Siblings(x, y)) ::: If people complain often about annoying siblings, then they have siblings who are the same age.\n∀x (¬LiveAtHome(x) → ¬DevelopBonds(x, y)) ::: If people do not live at home regularly, then they do not develop strong bonds with their family members.\n∀x (SpendTimeWith(x, y) → ¬LiveAtHome(x)) ::: If people spend a lot of time hanging out with and playing with their siblings, then they often did not live at home regularly.\n(Twins(luke) ∧ DevelopBonds(luke, luke)) ⊕ (¬Twins(luke) ∧ ¬DevelopBonds(luke, luke)) ::: Luke is either both a twin or triplet and develops strong bonds with his family members, or he neither is a twin or triplet nor develops strong bonds with his family members.\n",
                "First-Order-Logic Question": "¬(Twins(luke) ∨ Triplets(luke) ∨ Complain(luke)) ::: Luke is neither a twin nor triplet nor complains often about annoying siblings."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∀x (Twins(x) ∨ Triplets(x) → SpendTimeWith(x, x)) ::: If people are twins or triplets, then they spend a lot of time hanging out with and playing with their siblings.\n∀x (Siblings(x, y) → Twins(x) ∨ Triplets(x)) ::: If people have siblings who are the same age, then they are twins or triplets.\n∀x (Complain(x) → Siblings(x, y)) ::: If people complain often about annoying siblings, then they have siblings who are the same age.\n∀x (¬LiveAtHome(x) → ¬DevelopBonds(x, y)) ::: If people do not live at home regularly, then they do not develop strong bonds with their family members.\n∀x (SpendTimeWith(x, y) → ¬LiveAtHome(x)) ::: If people spend a lot of time hanging out with and playing with their siblings, then they often did not live at home regularly.\n(Twins(luke) ∧ DevelopBonds(luke, luke)) ⊕ (¬Twins(luke) ∧ ¬DevelopBonds(luke, luke)) ::: Luke is either both a twin or triplet and develops strong bonds with his family members, or he neither is a twin or triplet nor develops strong bonds with his family members.\n",
                "First-Order-Logic Question": "¬(Twins(luke) ∨ Triplets(luke) ∨ Complain(luke)) ::: Luke is neither a twin nor triplet nor complains often about annoying siblings."
            },
            "diff": [],
            "answer": "A",
            "error_type":"",
            "grammar_answer": "C"
        },
        {
            "id": 116,
            "raw_prog": {
                "First-Order-Logic Rules": "∀x ∀y (Man(x) ∧ Man(y) ∧ Taller(x, y) → Block(x, y)) ::: If a man is taller than another man, the taller one can block the other's shooting.\nMan(michael) ∧ ∀x (Classmate(x, michael) ∧ x ≠ michael → Taller(michael, x)) ::: Michael is a man who is taller than everyone else in his class.\n∀x ∀y ∀z (Man(x) ∧ Man(y) ∧ Man(z) ∧ Taller(x, y) ∧ Taller(y, z) → Taller(x, z)) ::: If person x is taller than person y, and person y is taller than person z, than x is taller than z\nMan(peter) ∧ Man(michael) ∧ Taller(peter, michael) ::: Peter is a man who is taller than Michael.\n∀x (Shoot(x) ∧ ¬Jump(x) → Block(michael, x)) ::: Michael can block any shooting from a person as long as the person does not jump when shooting.\n¬Block(michael, windy) ::: Michael cannot block Windy's shooting.\n∀x (Jump(x) → GreatShooter(x)) ::: Every shooter who can jump when shooting is a great shooter.",
                "First-Order-Logic Question": "GreatShooter(windy) ::: Windy is a great shooter."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∀x ∀y (Man(x) ∧ Man(y) ∧ Taller(x, y) → Block(x, y)) ::: If a man is taller than another man, the taller one can block the other's shooting.\nMan(x)→Taller(x,y)∧Block(x,y)∧¬(Classmate(x,y))∧¬(Shoot(x)) ::: Michael is a man who is taller than everyone else in his class.\n∀x ∀y ∀z (Man(x) ∧ Man(y) ∧ Man(z) ∧ Taller(x, y) ∧ Taller(y, z) → Taller(x, z)) ::: If person x is taller than person y, and person y is taller than person z, than x is taller than z\nMan(peter) ∧ Man(michael) ∧ Taller(peter, michael) ::: Peter is a man who is taller than Michael.\n∀x (Shoot(x) ∧ ¬Jump(x) → Block(michael, x)) ::: Michael can block any shooting from a person as long as the person does not jump when shooting.\n¬Block(michael, windy) ::: Michael cannot block Windy's shooting.\n∀x (Jump(x) → GreatShooter(x)) ::: Every shooter who can jump when shooting is a great shooter.",
                "First-Order-Logic Question": "GreatShooter(windy) ::: Windy is a great shooter."
            },
            "diff": [
                {
                    "raw": "Man(michael) ∧ ∀x (Classmate(x, michael) ∧ x ≠ michael → Taller(michael, x)) ::: Michael is a man who is taller than everyone else in his class.",
                    "gram": "Man(x)→Taller(x,y)∧Block(x,y)∧¬(Classmate(x,y))∧¬(Shoot(x)) ::: Michael is a man who is taller than everyone else in his class."
                }
            ],
            "answer": "A",
            "error_type":"",
            "grammar_answer": "A"
        },
        {
            "id": 124,
            "raw_prog": {
                "First-Order-Logic Rules": "∀x (Transport(x) → ¬Empty(x)) ::: If something can transport multiple passengers, then they are not empty. \n∀x (Airline(x) → Transport(x)) ::: All airlines can transport multiple passengers. \n∀x (Plane(x) → Empty(x)) ::: All planes are empty. \n∀x (Boeing707(x) → Plane(x)) ::: All Boeing 707s are planes. \nAirline(Greyhound) → ¬∃x (Greyhound(x) ∧ Plane(x)) ::: If Greyhound is not an airline, then there are no Greyhound planes.\n",
                "First-Order-Logic Question": "¬(Greyhound(x) ∧ Boeing707(x)) ::: A Greyhound is not a Boeing 707."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∀x (Transport(x) → ¬Empty(x)) ::: If something can transport multiple passengers, then they are not empty. \n∀x (Airline(x) → Transport(x)) ::: All airlines can transport multiple passengers. \n∀x (Plane(x) → Empty(x)) ::: All planes are empty. \n∀x (Boeing707(x) → Plane(x)) ::: All Boeing 707s are planes. \nAirline(x)→¬(Greyhound(x)∧Plane(x)) ::: If Greyhound is not an airline, then there are no Greyhound planes.\n",
                "First-Order-Logic Question": "¬(Greyhound(x) ∧ Boeing707(x)) ::: A Greyhound is not a Boeing 707."
            },
            "diff": [
                {
                    "raw": "Airline(Greyhound) → ¬∃x (Greyhound(x) ∧ Plane(x)) ::: If Greyhound is not an airline, then there are no Greyhound planes.",
                    "gram": "Airline(x)→¬(Greyhound(x)∧Plane(x)) ::: If Greyhound is not an airline, then there are no Greyhound planes."
                }
            ],
            "answer": "A",
            "error_type":"",
            "grammar_answer": "C"
        },
        {
            "id": 128,
            "raw_prog": {
                "First-Order-Logic Rules": "∀x (HaveWedding(x) → HaveChild(x)) ::: All people who have a wedding are people who have at least one child.\n∀x (TravelToParis(x) → HaveWedding(x)) ::: All people who travel to Paris for their honeymoon are people who have a wedding.\n∀x (OccurIn(x, July) ∧ HaveWedding(x) → TravelToParis(x)) ::: All weddings that occur in July belong to people who travel to Paris for their honeymoon.\n∃x (OccurIn(x, July) ∧ WellAttended(x)) ::: Some weddings in July are well-attended.\nHaveChild(John) → (¬TravelToParis(John) ∧ ¬HaveWedding(John)) ::: If John has at least one child, then John does not travel to Paris for his honeymoon and does not have a wedding.\nHaveWedding(John) ∧ WellAttended(John) → (OccurIn(John, July) ∨ (¬OccurIn(John, July) → TravelToParis(John))) ::: If John has a wedding that is well-attended, then John has a wedding in July or, if not, then John travels to Paris for their honeymoon.",
                "First-Order-Logic Question": "WellAttended(John) ::: John has a wedding that is well-attended."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∀x (HaveWedding(x) → HaveChild(x)) ::: All people who have a wedding are people who have at least one child.\n∀x (TravelToParis(x) → HaveWedding(x)) ::: All people who travel to Paris for their honeymoon are people who have a wedding.\n∀x (OccurIn(x, July) ∧ HaveWedding(x) → TravelToParis(x)) ::: All weddings that occur in July belong to people who travel to Paris for their honeymoon.\n∃x (OccurIn(x, July) ∧ WellAttended(x)) ::: Some weddings in July are well-attended.\nHaveChild(John) → (¬TravelToParis(John) ∧ ¬HaveWedding(John)) ::: If John has at least one child, then John does not travel to Paris for his honeymoon and does not have a wedding.\nHaveWedding(John) ∧ WellAttended(John) → (OccurIn(John, July) ∨ (¬OccurIn(John, July) → TravelToParis(John))) ::: If John has a wedding that is well-attended, then John has a wedding in July or, if not, then John travels to Paris for their honeymoon.",
                "First-Order-Logic Question": "WellAttended(John) ::: John has a wedding that is well-attended."
            },
            "diff": [],
            "answer": "B",
            "error_type":"",
            "grammar_answer": "C"
        },
        {
            "id": 130,
            "raw_prog": {
                "First-Order-Logic Rules": "∀x (HaveWedding(x) → HaveChild(x)) ::: All people who have a wedding are people who have at least one child.\n∀x (TravelToParisForHoneymoon(x) → HaveWedding(x)) ::: All people who travel to Paris for their honeymoon are people who have a wedding.\n∀x (Weddings(x) ∧ July(x) → BelongTo(x, TravelToParisForHoneymoon(x))) ::: All weddings that occur in July belong to people who travel to Paris for their honeymoon.\n∃x (Weddings(x) ∧ July(x) ∧ WellAttended(x)) ::: Some weddings in July are well-attended.\nHaveChild(John) → (¬TravelToParisForHoneymoon(John) ∧ ¬HaveWedding(John)) ::: If John has at least one child, then John does not travel to Paris for his honeymoon and does not have a wedding.\n(WellAttended(John) → (Weddings(John) ∧ July(John))) ∨ (¬July(John) → TravelToParisForHoneymoon(John)) ::: If John has a wedding that is well-attended, then John has a wedding in July or, if not, then John travels to Paris for their honeymoon.",
                "First-Order-Logic Question": "HaveChild(John) ::: John has at least one child."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∀x (HaveWedding(x) → HaveChild(x)) ::: All people who have a wedding are people who have at least one child.\n∀x (TravelToParisForHoneymoon(x) → HaveWedding(x)) ::: All people who travel to Paris for their honeymoon are people who have a wedding.\n∀x(WellAttended(x)→BelongTo(x,x)) ::: All weddings that occur in July belong to people who travel to Paris for their honeymoon.\n∃x (Weddings(x) ∧ July(x) ∧ WellAttended(x)) ::: Some weddings in July are well-attended.\nHaveChild(John) → (¬TravelToParisForHoneymoon(John) ∧ ¬HaveWedding(John)) ::: If John has at least one child, then John does not travel to Paris for his honeymoon and does not have a wedding.\n(WellAttended(John) → (Weddings(John) ∧ July(John))) ∨ (¬July(John) → TravelToParisForHoneymoon(John)) ::: If John has a wedding that is well-attended, then John has a wedding in July or, if not, then John travels to Paris for their honeymoon.",
                "First-Order-Logic Question": "HaveChild(John) ::: John has at least one child."
            },
            "diff": [
                {
                    "raw": "∀x (Weddings(x) ∧ July(x) → BelongTo(x, TravelToParisForHoneymoon(x))) ::: All weddings that occur in July belong to people who travel to Paris for their honeymoon.",
                    "gram": "∀x(WellAttended(x)→BelongTo(x,x)) ::: All weddings that occur in July belong to people who travel to Paris for their honeymoon."
                }
            ],
            "answer": "C",
            "error_type":"",
            "grammar_answer": "C"
        },
        {
            "id": 138,
            "raw_prog": {
                "First-Order-Logic Rules": "∀x (Algorithm(x) → (SupervisedLearning(x) ∨ UnsupervisedLearning(x) ∨ ReinforcementLearning(x))) ::: Machine Learning algorithms can be categorized as supervised learning, unsupervised learning, and reinforcement learning.\n∀x (UnsupervisedLearning(x) → ¬RequireLabelledData(x)) ::: Unsupervised learning doesn't require labelled data.\nStateOfTheArtModel(model) ∧ Algorithm(algo) ∧ TrainedWith(model, algo) ::: The state-of-the-art text summarization model is trained with machine learning algorithms.\nReinforcementLearning(rl) → ¬TrainedWith(StateOfTheArtModel(model), rl) ::: Reinforcement learning is not used to train the state-of-the-art text summarization model.\n∀x (Algorithm(x) ∧ TrainedWith(StateOfTheArtModel(model), x) → RequireLabelledData(x)) ::: The Machine Learning algorithm for training text summarization model requires labelled data.\n",
                "First-Order-Logic Question": "SupervisedLearning(supervised) ∧ TrainedWith(StateOfTheArtModel(model), supervised) ::: Supervised learning is used to train the state-of-the-art text summarization model."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∀x (Algorithm(x) → (SupervisedLearning(x) ∨ UnsupervisedLearning(x) ∨ ReinforcementLearning(x))) ::: Machine Learning algorithms can be categorized as supervised learning, unsupervised learning, and reinforcement learning.\n∀x (UnsupervisedLearning(x) → ¬RequireLabelledData(x)) ::: Unsupervised learning doesn't require labelled data.\nStateOfTheArtModel(model) ∧ Algorithm(algo) ∧ TrainedWith(model, algo) ::: The state-of-the-art text summarization model is trained with machine learning algorithms.\nReinforcementLearning(x)→¬TrainedWith(x,y) ::: Reinforcement learning is not used to train the state-of-the-art text summarization model.\nAlgorithm(x)∧TrainedWith(x,y)→RequireLabelledData(x) ::: The Machine Learning algorithm for training text summarization model requires labelled data.\n",
                "First-Order-Logic Question": "SupervisedLearning(x)→TrainedWith(x,y) ::: Supervised learning is used to train the state-of-the-art text summarization model."
            },
            "diff": [
                {
                    "raw": "ReinforcementLearning(rl) → ¬TrainedWith(StateOfTheArtModel(model), rl) ::: Reinforcement learning is not used to train the state-of-the-art text summarization model.",
                    "gram": "ReinforcementLearning(x)→¬TrainedWith(x,y) ::: Reinforcement learning is not used to train the state-of-the-art text summarization model."
                },
                {
                    "raw": "∀x (Algorithm(x) ∧ TrainedWith(StateOfTheArtModel(model), x) → RequireLabelledData(x)) ::: The Machine Learning algorithm for training text summarization model requires labelled data.",
                    "gram": "Algorithm(x)∧TrainedWith(x,y)→RequireLabelledData(x) ::: The Machine Learning algorithm for training text summarization model requires labelled data."
                },
                {
                    "raw": "SupervisedLearning(supervised) ∧ TrainedWith(StateOfTheArtModel(model), supervised) ::: Supervised learning is used to train the state-of-the-art text summarization model.",
                    "gram": "SupervisedLearning(x)→TrainedWith(x,y) ::: Supervised learning is used to train the state-of-the-art text summarization model."
                }
            ],
            "answer": "A",
            "error_type":"",
            "grammar_answer": "C"
        },
        {
            "id": 153,
            "raw_prog": {
                "First-Order-Logic Rules": "∀x,y (Owns(x, y) → (WorkRegularlyAtHome(x) ∧ TidyOrganize(x))) ::: If people own a large desktop monitor at their home, then they work regularly and often at home.\n∀x (HasHomeOffice(x) → Owns(x, largeDesktopMonitor)) ::: All people who have a fully stocked and impressive home office are people who own a large desktop monitor at their home.\n∀x (WorkRegularlyAtHome(x) → TidyOrganize(x)) ::: All people who work regularly and often at home spend their free time tidying and organizing the spaces in their homes.\n∀x (WorkRegularlyAtHome(x) → VisitStore(x)) ::: All people who work regularly and often at home visit the office supply store regularly.\n∀x (TidyOrganize(x) → (¬GoToBedLate(x) ∧ WakeUpLate(x))) ::: If people spend their free time tidying and organizing the spaces in their home, then they do not go to bed late and wake up every day after noon.\n(TidyOrganize(remy) ∧ (GoToBedLate(remy) ∧ WakeUpLate(remy))) ⊕ (¬GoToBedLate(remy) ∧ ¬WakeUpLate(remy) ∧ ¬TidyOrganize(remy)) ::: Remy either both goes to bed late and wakes up every day after noon and spends their free time tidying and organizing the spaces in their home, or they do not go to bed late and wake up every day after noon nor spend their free time tidying and organizing the spaces in their home.\n",
                "First-Order-Logic Question": "VisitStore(remy) ::: Remy visits the office supply store regularly."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∀x(Owns(x,y)→(WorkRegularlyAtHome(x))) ::: If people own a large desktop monitor at their home, then they work regularly and often at home.\n∀x (HasHomeOffice(x) → Owns(x, largeDesktopMonitor)) ::: All people who have a fully stocked and impressive home office are people who own a large desktop monitor at their home.\n∀x (WorkRegularlyAtHome(x) → TidyOrganize(x)) ::: All people who work regularly and often at home spend their free time tidying and organizing the spaces in their homes.\n∀x (WorkRegularlyAtHome(x) → VisitStore(x)) ::: All people who work regularly and often at home visit the office supply store regularly.\n∀x (TidyOrganize(x) → (¬GoToBedLate(x) ∧ WakeUpLate(x))) ::: If people spend their free time tidying and organizing the spaces in their home, then they do not go to bed late and wake up every day after noon.\n(TidyOrganize(remy) ∧ (GoToBedLate(remy) ∧ WakeUpLate(remy))) ⊕ (¬GoToBedLate(remy) ∧ ¬WakeUpLate(remy) ∧ ¬TidyOrganize(remy)) ::: Remy either both goes to bed late and wakes up every day after noon and spends their free time tidying and organizing the spaces in their home, or they do not go to bed late and wake up every day after noon nor spend their free time tidying and organizing the spaces in their home.\n",
                "First-Order-Logic Question": "VisitStore(remy) ::: Remy visits the office supply store regularly."
            },
            "diff": [
                {
                    "raw": "∀x,y (Owns(x, y) → (WorkRegularlyAtHome(x) ∧ TidyOrganize(x))) ::: If people own a large desktop monitor at their home, then they work regularly and often at home.",
                    "gram": "∀x(Owns(x,y)→(WorkRegularlyAtHome(x))) ::: If people own a large desktop monitor at their home, then they work regularly and often at home."
                }
            ],
            "answer": "C",
            "error_type":"",
            "grammar_answer": "C"
        },
        {
            "id": 155,
            "raw_prog": {
                "First-Order-Logic Rules": "∀x,y (Owns(x, y) → (WorkRegularly(x) ∧ WorkOften(x))) ::: If people own a large desktop monitor at their home, then they work regularly and often at home.\n∀x (FullyStocked(x) → Owns(x, largeDesktopMonitor) ∧ Impressive(x)) ::: All people who have a fully stocked and impressive home office are people who own a large desktop monitor at their home.\n∀x (WorkRegularly(x) ∧ WorkOften(x) → Tidy(x)) ::: All people who work regularly and often at home spend their free time tidying and organizing the spaces in their homes.\n∀x (WorkRegularly(x) ∧ WorkOften(x) → VisitStore(x)) ::: All people who work regularly and often at home visit the office supply store regularly.\n∀x (Tidy(x) → (¬Late(x) ∧ ¬WakeLate(x))) ::: If people spend their free time tidying and organizing the spaces in their home, then they do not go to bed late and wake up every day after noon.\n(Tidy(remy) ∧ Late(remy) ∧ WakeLate(remy)) ⊕ (¬Late(remy) ∧ ¬WakeLate(remy) ∧ ¬Tidy(remy)) ::: Remy either both goes to bed late and wakes up every day after noon and spends their free time tidying and organizing the spaces in their home, or they do not go to bed late and wake up every day after noon nor spend their free time tidying and organizing the spaces in their home.\n",
                "First-Order-Logic Question": "((Late(remy) ∧ WakeLate(remy)) ∨ VisitStore(remy)) → (¬Tidy(remy) ∧ ¬FullyStocked(remy)) ::: If Remy either goes to bed late and wakes up every day after noon or visits the office supply store regularly, then Remy neither spends their free time tidying and organizing the spaces in their home nor has a fully stocked and impressive home office."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∀x(Owns(x,y)→(WorkRegularly(x))) ::: If people own a large desktop monitor at their home, then they work regularly and often at home.\n∀x (FullyStocked(x) → Owns(x, largeDesktopMonitor) ∧ Impressive(x)) ::: All people who have a fully stocked and impressive home office are people who own a large desktop monitor at their home.\n∀x (WorkRegularly(x) ∧ WorkOften(x) → Tidy(x)) ::: All people who work regularly and often at home spend their free time tidying and organizing the spaces in their homes.\n∀x (WorkRegularly(x) ∧ WorkOften(x) → VisitStore(x)) ::: All people who work regularly and often at home visit the office supply store regularly.\n∀x (Tidy(x) → (¬Late(x) ∧ ¬WakeLate(x))) ::: If people spend their free time tidying and organizing the spaces in their home, then they do not go to bed late and wake up every day after noon.\n(Tidy(remy) ∧ Late(remy) ∧ WakeLate(remy)) ⊕ (¬Late(remy) ∧ ¬WakeLate(remy) ∧ ¬Tidy(remy)) ::: Remy either both goes to bed late and wakes up every day after noon and spends their free time tidying and organizing the spaces in their home, or they do not go to bed late and wake up every day after noon nor spend their free time tidying and organizing the spaces in their home.\n",
                "First-Order-Logic Question": "((Late(remy) ∧ WakeLate(remy)) ∨ VisitStore(remy)) → (¬Tidy(remy) ∧ ¬FullyStocked(remy)) ::: If Remy either goes to bed late and wakes up every day after noon or visits the office supply store regularly, then Remy neither spends their free time tidying and organizing the spaces in their home nor has a fully stocked and impressive home office."
            },
            "diff": [
                {
                    "raw": "∀x,y (Owns(x, y) → (WorkRegularly(x) ∧ WorkOften(x))) ::: If people own a large desktop monitor at their home, then they work regularly and often at home.",
                    "gram": "∀x(Owns(x,y)→(WorkRegularly(x))) ::: If people own a large desktop monitor at their home, then they work regularly and often at home."
                }
            ],
            "answer": "A",
            "error_type":"",
            "grammar_answer": "C"
        },
        {
            "id": 164,
            "raw_prog": {
                "First-Order-Logic Rules": "∃x ∃y (Roses(x) ∧ MondayAt8pm(y) ∧ GivenOut(x, y)) ::: On some Mondays at 8 pm, roses are given out on TV.\n∀x (GivenOut(x, TVShow(TheBachelor)) → On(x, TheBachelor)) ::: Every rose given out on TV is on the Bachelor.\n∀x (On(TheBachelor, x) → Portray(x, RealPeople)) ::: Everything on the Bachelor portrays the lives of real people.\n∀x (Portray(x, RealPeople) → RealityTVShow(x)) ::: All shows portraying the lives of real people are reality TV shows.\n¬RealityTVShow(BreakingBad) ::: Breaking Bad is not a reality TV show.\n",
                "First-Order-Logic Question": "∃x (Roses(x) ∧ MondayAt8pm(x)) ::: Breaking Bad is on Monday at 8 pm."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∃x ∃y (Roses(x) ∧ MondayAt8pm(y) ∧ GivenOut(x, y)) ::: On some Mondays at 8 pm, roses are given out on TV.\n∀x(GivenOut(x,y)→On(x,y)) ::: Every rose given out on TV is on the Bachelor.\n∀x (On(TheBachelor, x) → Portray(x, RealPeople)) ::: Everything on the Bachelor portrays the lives of real people.\n∀x (Portray(x, RealPeople) → RealityTVShow(x)) ::: All shows portraying the lives of real people are reality TV shows.\n¬RealityTVShow(BreakingBad) ::: Breaking Bad is not a reality TV show.\n",
                "First-Order-Logic Question": "∃x (Roses(x) ∧ MondayAt8pm(x)) ::: Breaking Bad is on Monday at 8 pm."
            },
            "diff": [
                {
                    "raw": "∀x (GivenOut(x, TVShow(TheBachelor)) → On(x, TheBachelor)) ::: Every rose given out on TV is on the Bachelor.",
                    "gram": "∀x(GivenOut(x,y)→On(x,y)) ::: Every rose given out on TV is on the Bachelor."
                }
            ],
            "answer": "C",
            "error_type":"",
            "grammar_answer": "C"
        },
        {
            "id": 166,
            "raw_prog": {
                "First-Order-Logic Rules": "∃x ∃y (Monday(y) ∧ Time(y) ∧ Roses(x) ∧ GivenOut(x, y)) ::: On some Mondays at 8 pm, roses are given out on TV.\n∀x (Roses(x) → On(x, Bachelor)) ::: Every rose given out on TV is on the Bachelor.\n∀x (On(x, Bachelor) → Portray(x, RealPeople)) ::: Everything on the Bachelor portrays the lives of real people.\n∀x (Portray(x, RealPeople) → RealityTVShow(x)) ::: All shows portraying the lives of real people are reality TV shows.\n¬RealityTVShow(BreakingBad) ::: Breaking Bad is not a reality TV show.\n",
                "First-Order-Logic Question": "∀x (Roses(x) ∧ GivenOut(x, Monday(8pm))) → On(BreakingBad, Monday(8pm)) ::: If roses are given out during Breaking Bad, then it is on Monday at 8 pm."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∃x ∃y (Monday(y) ∧ Time(y) ∧ Roses(x) ∧ GivenOut(x, y)) ::: On some Mondays at 8 pm, roses are given out on TV.\n∀x (Roses(x) → On(x, Bachelor)) ::: Every rose given out on TV is on the Bachelor.\n∀x (On(x, Bachelor) → Portray(x, RealPeople)) ::: Everything on the Bachelor portrays the lives of real people.\n∀x (Portray(x, RealPeople) → RealityTVShow(x)) ::: All shows portraying the lives of real people are reality TV shows.\n¬RealityTVShow(BreakingBad) ::: Breaking Bad is not a reality TV show.\n",
                "First-Order-Logic Question": "∀x(Roses(x)∧GivenOut(x,y)→On(x,y)) ::: If roses are given out during Breaking Bad, then it is on Monday at 8 pm."
            },
            "diff": [
                {
                    "raw": "∀x (Roses(x) ∧ GivenOut(x, Monday(8pm))) → On(BreakingBad, Monday(8pm)) ::: If roses are given out during Breaking Bad, then it is on Monday at 8 pm.",
                    "gram": "∀x(Roses(x)∧GivenOut(x,y)→On(x,y)) ::: If roses are given out during Breaking Bad, then it is on Monday at 8 pm."
                }
            ],
            "answer": "A",
            "error_type":"",
            "grammar_answer": "C"
        },
        {
            "id": 178,
            "raw_prog": {
                "First-Order-Logic Rules": "SportingEvent(olympicGames) ::: The Olympic games is a sporting event.\nLastOlympicGames(tokyo) ::: The last Olympic games was in Tokyo.\nWonMostMedals(unitedStates, tokyo) ::: The United States won the most medals in Tokyo.\n",
                "First-Order-Logic Question": "WonMostMedals(unitedStates, tokyo) ::: The United States won the most medals in the last Olympic games."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "SportingEvent(olympicGames) ::: The Olympic games is a sporting event.\nLastOlympicGames(tokyo) ::: The last Olympic games was in Tokyo.\nWonMostMedals(unitedStates, tokyo) ::: The United States won the most medals in Tokyo.\n",
                "First-Order-Logic Question": "WonMostMedals(unitedStates, tokyo) ::: The United States won the most medals in the last Olympic games."
            },
            "diff": [],
            "answer": "A",
            "error_type":"",
            "grammar_answer": "A"
        },
        {
            "id": 181,
            "raw_prog": {
                "First-Order-Logic Rules": "Flies(susan, LGA) ::: Susan flies to LGA airport.\n∀x (Airport(x) ∧ Flies(john, x) ∧ ¬(DepartsFrom(john, x) ∧ ArrivesAt(john, x))) ::: The departure and arrival can not be the same airport.\n",
                "First-Order-Logic Question": "Flies(john, LGA) ::: John flies to LGA airport."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "Flies(susan, LGA) ::: Susan flies to LGA airport.\n∀x (Airport(x) ∧ Flies(john, x) ∧ ¬(DepartsFrom(john, x) ∧ ArrivesAt(john, x))) ::: The departure and arrival can not be the same airport.\n",
                "First-Order-Logic Question": "Flies(john, LGA) ::: John flies to LGA airport."
            },
            "diff": [],
            "answer": "B",
            "error_type":"",
            "grammar_answer": "A"
        },
        {
            "id": 1,
            "raw_prog": {
                "First-Order-Logic Rules": "∀x (Perform(x) → (Attend(x) ∧ Engaged(x))) ::: If people perform in school talent shows often, then they attend and are very engaged with school events.\n∀x ((Perform(x) ∨ (Inactive(x) ∧ Disinterested(x))) ::: People either perform in school talent shows often or are inactive and disinterested members of their community.\n∀x (Chaperone(x) → ¬Student(x)) ::: If people chaperone high school dances, then they are not students who attend the school.\n∀x ((Inactive(x) ∧ Disinterested(x)) → Chaperone(x)) ::: All people who are inactive and disinterested members of their community chaperone high school dances.\n∀x ((Young(x) ∨ Teenager(x)) ∧ Wish(x) → Student(x)) ::: All young children and teenagers who wish to further their academic careers and educational opportunities are students who attend the school.\n¬((Attend(Bonnie) ∧ Engaged(Bonnie)) ⊕ Student(Bonnie)) ::: Bonnie either both attends and is very engaged with school events and is a student who attends the school, or she neither attends and is very engaged with school events nor is a student who attends the school.",
                "First-Order-Logic Question": "((Young(Bonnie) ∨ Teenager(Bonnie)) ∧ Wish(Bonnie) ∧ Chaperone(Bonnie)) ∨ ¬((Young(Bonnie) ∨ Teenager(Bonnie)) ∧ ¬Wish(Bonnie)) → (Student(Bonnie) ∨ (Inactive(Bonnie) ∧ Disinterested(Bonnie)))"
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∀x (Perform(x) → (Attend(x) ∧ Engaged(x))) ::: If people perform in school talent shows often, then they attend and are very engaged with school events.\n∀x((Perform(x)∨Inactive(x))) ::: People either perform in school talent shows often or are inactive and disinterested members of their community.\n∀x (Chaperone(x) → ¬Student(x)) ::: If people chaperone high school dances, then they are not students who attend the school.\n∀x ((Inactive(x) ∧ Disinterested(x)) → Chaperone(x)) ::: All people who are inactive and disinterested members of their community chaperone high school dances.\n∀x ((Young(x) ∨ Teenager(x)) ∧ Wish(x) → Student(x)) ::: All young children and teenagers who wish to further their academic careers and educational opportunities are students who attend the school.\n¬((Attend(Bonnie) ∧ Engaged(Bonnie)) ⊕ Student(Bonnie)) ::: Bonnie either both attends and is very engaged with school events and is a student who attends the school, or she neither attends and is very engaged with school events nor is a student who attends the school.",
                "First-Order-Logic Question": "((Young(Bonnie) ∨ Teenager(Bonnie)) ∧ Wish(Bonnie) ∧ Chaperone(Bonnie)) ∨ ¬((Young(Bonnie) ∨ Teenager(Bonnie)) ∧ ¬Wish(Bonnie)) → (Student(Bonnie) ∨ (Inactive(Bonnie) ∧ Disinterested(Bonnie)))"
            },
            "diff": [
                {
                    "raw": "∀x ((Perform(x) ∨ (Inactive(x) ∧ Disinterested(x))) ::: People either perform in school talent shows often or are inactive and disinterested members of their community.",
                    "gram": "∀x((Perform(x)∨Inactive(x))) ::: People either perform in school talent shows often or are inactive and disinterested members of their community."
                }
            ],
            "answer": "A",
            "error_type":"",
            "grammar_answer": "C"
        },
        {
            "id": 13,
            "raw_prog": {
                "First-Order-Logic Rules": "Create(japaneseGameCompany, legendOfZelda) ::: A Japanese game company created the game the Legend of Zelda.\n∀x (Game(x) ∧ Sell(x, moreThanOneMillion) → Select(x, Top10(x))) ::: If a game sells more than one million copies, then it will be selected into the Top 10 list.\nSelect(legendOfZelda, Top10) ::: The Legend of Zelda sold more than one million copies and is selected into the Top 10 list.\n",
                "First-Order-Logic Question": "Create(japaneseVideoGameCompany, FIFA22) ::: FIFA 22 is made by a Japanese video game company."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "Create(japaneseGameCompany, legendOfZelda) ::: A Japanese game company created the game the Legend of Zelda.\n∀x(Game(x)→Select(x,y))∧¬(Create(x,y)→Sell(x,y)) ::: If a game sells more than one million copies, then it will be selected into the Top 10 list.\nSelect(legendOfZelda, Top10) ::: The Legend of Zelda sold more than one million copies and is selected into the Top 10 list.\n",
                "First-Order-Logic Question": "Create(japaneseVideoGameCompany, FIFA22) ::: FIFA 22 is made by a Japanese video game company."
            },
            "diff": [
                {
                    "raw": "∀x (Game(x) ∧ Sell(x, moreThanOneMillion) → Select(x, Top10(x))) ::: If a game sells more than one million copies, then it will be selected into the Top 10 list.",
                    "gram": "∀x(Game(x)→Select(x,y))∧¬(Create(x,y)→Sell(x,y)) ::: If a game sells more than one million copies, then it will be selected into the Top 10 list."
                }
            ],
            "answer": "C",
            "error_type":"",
            "grammar_answer": "A"
        },
        {
            "id": 46,
            "raw_prog": {
                "First-Order-Logic Rules": "∀x (Season(x) → (Spring(x) ∨ Summer(x) ∨ Fall(x) ∨ Winter(x))) ::: There are four seasons in a year: Spring, Summer, Fall, and Winter. \n∀x (Student(x) ∧ WantLongVacation(x) → Love(x, Summer)) ::: All students who want to have a long vacation love summer the most. \nFavoriteSeason(emma, Summer) ::: Emma's favorite season is summer. \n∀x (Student(mia) ∧ NotSame(FavoriteSeason(mia, emma), emma)) ::: Mia's favorite season is not the same as Emma's. \nWantLongVacation(james) ::: James wants to have a long vacation.",
                "First-Order-Logic Question": "FavoriteSeason(james, Summer) ::: James's favorite season is summer."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∀x (Season(x) → (Spring(x) ∨ SeasonSummer(x) ∨ Fall(x) ∨ Winter(x))) ::: There are four seasons in a year: Spring, Summer, Fall, and Winter. \n∀x (Student(x) ∧ WantLongVacation(x) → Love(x, SeasonSummer)) ::: All students who want to have a long vacation love summer the most. \nFavoriteSeason(emma, SeasonSummer) ::: Emma's favorite season is summer. \nStudent(x) ∧ NotSame(x,y) → FavoriteSeason(x,y) ::: Mia's favorite season is not the same as Emma's. \nWantLongVacation(james) ::: James wants to have a long vacation.",
                "First-Order-Logic Question": "FavoriteSeason(james, SeasonSummer) ::: James's favorite season is summer."
            },
            "diff": [
                {
                    "raw": "∀x (Student(mia) ∧ NotSame(FavoriteSeason(mia, emma), emma)) ::: Mia's favorite season is not the same as Emma's. ",
                    "gram": "Student(x) ∧ NotSame(x,y) → FavoriteSeason(x,y) ::: Mia's favorite season is not the same as Emma's. "
                }
            ],
            "answer": "A",
            "error_type":"",
            "grammar_answer": "C"
        },
        {
            "id": 68,
            "raw_prog": {
                "First-Order-Logic Rules": "PrivateUniversity(yaleuniversity) ∧ IvyLeagueUniversity(yaleuniversity) ∧ ResearchUniversity(yaleuniversity) ::: Yale University is a private Ivy League research university.\nMove(yaleuniversity, newhaven, 1716) ::: Yale University moved to New Haven in 1716.\nEndowment(yaleuniversity, 42.3billion) ::: Yale university's endowment was valued at $42.3 billion.\nOrganize(yaleuniversity, List([residentialcolleges, yalegraduate, professionalschools])) ∧ List(residentialcolleges, [benjaminfranklin, berkeley, branford, davenport, ezrastiles, gracehopper, jonathanedwards, morse, paulimurray, pierson, saybrook, silliman, timothydwight, trumbull]) ::: Yale University has been organized into 27 constituent colleges and schools: the residential colleges, the Yale Graduate School of Arts and Sciences, and twelve professional schools.\n",
                "First-Order-Logic Question": "ResidentialCollege(pierson) ∧ College(pierson) ∧ YaleUniversity ::: Pierson College is a residential college at Yale."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "PrivateUniversity(yaleuniversity) ∧ IvyLeagueUniversity(yaleuniversity) ∧ ResearchUniversity(yaleuniversity) ::: Yale University is a private Ivy League research university.\nMove(yaleuniversity, newhaven, 1716) ::: Yale University moved to New Haven in 1716.\nEndowment(yaleuniversity, billion42_3) ::: Yale university's endowment was valued at $42.3 billion.\nOrganize(y,y)→List(y,y) ::: Yale University has been organized into 27 constituent colleges and schools: the residential colleges, the Yale Graduate School of Arts and Sciences, and twelve professional schools.",
                "First-Order-Logic Question": "ResidentialCollege(x)→College(x)→YaleUniversity(x) ::: Pierson College is a residential college at Yale."
            },
            "diff": [],
            "answer": "A",
            "error_type":"",
            "grammar_answer": "C"
        },
        {
            "id": 74,
            "raw_prog": {
                "First-Order-Logic Rules": "∀x (Plate(x) → BeginWith(x, number34)) ::: All vehicle registration plates in Istanbul begin with the number 34.\n∀x (¬BeginWith(x, number34) → ¬InCity(x, istanbul)) ::: Plates that do not begin with the number 34 are not from Istanbul.\nInCity(joePlate, istanbul) ::: Joe's vehicle registration plate is from Istanbul.\nBeginWith(tomPlate, number35) ::: Tom's license plate begins with the number 35.\n∀x (BG(BeginWith(x, number35), ¬BeginWith(x, number34))) ::: If a license plate begins with the number 35, then it does not begin with the number 34.",
                "First-Order-Logic Question": "BeginWith(joePlate, number34) ::: Joe's license plate begins with the number 34."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∀x (Plate(x) → BeginWith(x, number34)) ::: All vehicle registration plates in Istanbul begin with the number 34.\n∀x (¬BeginWith(x, number34) → ¬InCity(x, istanbul)) ::: Plates that do not begin with the number 34 are not from Istanbul.\nInCity(joePlate, istanbul) ::: Joe's vehicle registration plate is from Istanbul.\nBeginWith(tomPlate, number35) ::: Tom's license plate begins with the number 35.\nBeginWith(x,y)→¬BeginWith(x,y) ::: If a license plate begins with the number 35, then it does not begin with the number 34.",
                "First-Order-Logic Question": "BeginWith(joePlate, number34) ::: Joe's license plate begins with the number 34."
            },
            "diff": [
                {
                    "raw": "∀x (BG(BeginWith(x, number35), ¬BeginWith(x, number34))) ::: If a license plate begins with the number 35, then it does not begin with the number 34.",
                    "gram": "BeginWith(x,y)→¬BeginWith(x,y) ::: If a license plate begins with the number 35, then it does not begin with the number 34."
                }
            ],
            "answer": "A",
            "error_type":"",
            "grammar_answer": "A"
        },
        {
            "id": 103,
            "raw_prog": {
                "First-Order-Logic Rules": "∀x (Twins(x) ∨ Triplets(x) → SpendTimeWith(x, Siblings(x))) ::: If people are twins or triplets, then they spend a lot of time hanging out with and playing with their siblings.\n∀x (Siblings(x, y) → Twins(x) ∨ Triplets(x)) ::: If people have siblings who are the same age, then they are twins or triplets.\n∀x (Complain(x) → Siblings(x, y)) ::: If people complain often about annoying siblings, then they have siblings who are the same age.\n∀x (¬LiveAtHomeRegularly(x) → ¬DevelopBonds(x, y)) ::: If people do not live at home regularly, then they do not develop strong bonds with their family members.\n∀x (SpendTimeWith(x, Siblings(x)) → ¬LiveAtHomeRegularly(x)) ::: If people spend a lot of time hanging out with and playing with their siblings, then they often did not live at home regularly.\n(Twins(luke) ∧ DevelopBonds(luke, FamilyMembers)) ∨ (¬Twins(luke) ∧ ¬DevelopBonds(luke, FamilyMembers)) ::: Luke is either both a twin or triplet and develops strong bonds with his family members, or he neither is a twin or triplet nor develops strong bonds with his family members.\n",
                "First-Order-Logic Question": "Complain(luke) ::: Luke complains often about annoying siblings."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∀x(Twins(x)∨Triplets(x))→SpendTimeWith(x,y)∧Siblings(x,y)∧Complain(x)∧LiveAtHomeRegularly(x) ::: If people are twins or triplets, then they spend a lot of time hanging out with and playing with their siblings.\n∀x (Siblings(x, y) → Twins(x) ∨ Triplets(x)) ::: If people have siblings who are the same age, then they are twins or triplets.\n∀x (Complain(x) → Siblings(x, y)) ::: If people complain often about annoying siblings, then they have siblings who are the same age.\n∀x (¬LiveAtHomeRegularly(x) → ¬DevelopBonds(x, y)) ::: If people do not live at home regularly, then they do not develop strong bonds with their family members.\n∀x(SpendTimeWith(x,y)→¬LiveAtHomeRegularly(x)) ::: If people spend a lot of time hanging out with and playing with their siblings, then they often did not live at home regularly.\n(Twins(luke) ∧ DevelopBonds(luke, FamilyMembers)) ∨ (¬Twins(luke) ∧ ¬DevelopBonds(luke, FamilyMembers)) ::: Luke is either both a twin or triplet and develops strong bonds with his family members, or he neither is a twin or triplet nor develops strong bonds with his family members.\n",
                "First-Order-Logic Question": "Complain(luke) ::: Luke complains often about annoying siblings."
            },
            "diff": [
                {
                    "raw": "∀x (Twins(x) ∨ Triplets(x) → SpendTimeWith(x, Siblings(x))) ::: If people are twins or triplets, then they spend a lot of time hanging out with and playing with their siblings.",
                    "gram": "∀x(Twins(x)∨Triplets(x))→SpendTimeWith(x,y)∧Siblings(x,y)∧Complain(x)∧LiveAtHomeRegularly(x) ::: If people are twins or triplets, then they spend a lot of time hanging out with and playing with their siblings."
                }
            ],
            "answer": "B",
            "error_type":"",
            "grammar_answer": "A"
        },
        {
            "id": 105,
            "raw_prog": {
                "First-Order-Logic Rules": "Cost(gre_test, 205) ::: It costs US $205 to take the GRE test.\n∀x ∀y (Prove(x, EconomicHardship(y)) → ProvideAid(ETS, y)) ::: ETS provides financial aid to those GRE applicants who prove economic hardship.\n∀x (EconomicHardship(x) ↔ (Difficulty(x, money) ∨ Difficulty(x, resources))) ::: Economic hardship refers to difficulty caused by having too little money or too few resources.\nSingleParent(tom) ::: Tom lives in a single-parent family.\nOutOfWork(tom_dad, more_than_1_year) ::: His dad has been out of work for more than a year.\n",
                "First-Order-Logic Question": "ApplyFor(tom, ETS, gre_test) ::: Tom can apply for financial aid from ETS to take the GRE test."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "Cost(gre_test, 205) ::: It costs US $205 to take the GRE test.\nProvideAid(x,y)→Prove(x,y)∧EconomicHardship(y) ::: ETS provides financial aid to those GRE applicants who prove economic hardship.\n∀x (EconomicHardship(x) ↔ (Difficulty(x, money) ∨ Difficulty(x, resources))) ::: Economic hardship refers to difficulty caused by having too little money or too few resources.\nSingleParent(tom) ::: Tom lives in a single-parent family.\nOutOfWork(tom_dad, more_than_1_year) ::: His dad has been out of work for more than a year.\n",
                "First-Order-Logic Question": "ApplyFor(tom, ETS, gre_test) ::: Tom can apply for financial aid from ETS to take the GRE test."
            },
            "diff": [
                {
                    "raw": "∀x ∀y (Prove(x, EconomicHardship(y)) → ProvideAid(ETS, y)) ::: ETS provides financial aid to those GRE applicants who prove economic hardship.",
                    "gram": "ProvideAid(x,y)→Prove(x,y)∧EconomicHardship(y) ::: ETS provides financial aid to those GRE applicants who prove economic hardship."
                }
            ],
            "answer": "A",
            "error_type":"",
            "grammar_answer": "C"
        },
        {
            "id": 108,
            "raw_prog": {
                "First-Order-Logic Rules": "∀x (SpillFood(x) → (¬TidySpaces(x) ∧ EnjoyCleaning(x))) ::: If people spill a lot of food on their clothing, then they do not tidy their spaces consistently and enjoy the process of cleaning.\n∀x (Foodie(x) → SpillFood(x)) ::: All foodies who go out frequently to find new food restaurants to try are people who spill a lot of food on their clothing.\n∀x (OnlyChild(x) → (TidySpaces(x) ∧ EnjoyCleaning(x))) ::: If people grew up as only children with no siblings, then they tidy their spaces consistently and enjoy the process of cleaning.\n∀x (BusyParents(x) → OnlyChild(x)) ::: If people have parents who are very busy with their regular jobs, then they grew up as only children with no siblings.\n∀x (HighIncomeHousehold(x) → BusyParents(Person(x))) ::: All households with a high net income have people who have parents who are very busy with their regular jobs.\n(SpillFood(Peter) ∧ OnlyChild(Peter)) ⊕ (¬SpillFood(Peter) ∧ ¬OnlyChild(Peter)) ::: Peter is either both a person who spills a lot of food on his clothing and grew up as an only child with no siblings, or he is neither a person who spills a lot of food on his clothing nor grew up as an only child with no siblings. ",
                "First-Order-Logic Question": "TidySpaces(Peter) ∧ EnjoyCleaning(Peter) ::: Peter tidies his space consistently and enjoys the process of cleaning."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∀x (SpillFood(x) → (¬TidySpaces(x) ∧ EnjoyCleaning(x))) ::: If people spill a lot of food on their clothing, then they do not tidy their spaces consistently and enjoy the process of cleaning.\n∀x (Foodie(x) → SpillFood(x)) ::: All foodies who go out frequently to find new food restaurants to try are people who spill a lot of food on their clothing.\n∀x (OnlyChild(x) → (TidySpaces(x) ∧ EnjoyCleaning(x))) ::: If people grew up as only children with no siblings, then they tidy their spaces consistently and enjoy the process of cleaning.\n∀x (BusyParents(x) → OnlyChild(x)) ::: If people have parents who are very busy with their regular jobs, then they grew up as only children with no siblings.\nBusyParents(x)→HighIncomeHousehold(x) ::: All households with a high net income have people who have parents who are very busy with their regular jobs.\n(SpillFood(Peter) ∧ OnlyChild(Peter)) ⊕ (¬SpillFood(Peter) ∧ ¬OnlyChild(Peter)) ::: Peter is either both a person who spills a lot of food on his clothing and grew up as an only child with no siblings, or he is neither a person who spills a lot of food on his clothing nor grew up as an only child with no siblings. ",
                "First-Order-Logic Question": "TidySpaces(Peter) ∧ EnjoyCleaning(Peter) ::: Peter tidies his space consistently and enjoys the process of cleaning."
            },
            "diff": [
                {
                    "raw": "∀x (HighIncomeHousehold(x) → BusyParents(Person(x))) ::: All households with a high net income have people who have parents who are very busy with their regular jobs.",
                    "gram": "BusyParents(x)→HighIncomeHousehold(x) ::: All households with a high net income have people who have parents who are very busy with their regular jobs."
                }
            ],
            "answer": "C",
            "error_type":"",
            "grammar_answer": "C"
        },
        {
            "id": 115,
            "raw_prog": {
                "First-Order-Logic Rules": "∀x ∀y (Man(x) ∧ Man(y) ∧ Taller(x, y) → Block(x, y)) ::: If a man is taller than another man, the taller one can block the other's shooting.\nMan(michael) ∧ ∀x (Man(x) ∧ x ≠ michael → Taller(michael, x)) ::: Michael is a man who is taller than everyone else in his class.\n∀x ∀y ∀z (Taller(x, y) ∧ Taller(y, z) → Taller(x, z)) ::: If person x is taller than person y, and person y is taller than person z, than x is taller than z\nMan(peter) ∧ Taller(peter, michael) ::: Peter is a man who is taller than Michael.\n∀x (Shooter(x) ∧ ¬Jump(x) → Block(michael, x)) ::: Michael can block any shooting from a person as long as the person does not jump when shooting.\n¬Block(michael, windy) ::: Michael cannot block Windy's shooting.\n∀x (Shooter(x) ∧ Jump(x) → GreatShooter(x)) ::: Every shooter who can jump when shooting is a great shooter.",
                "First-Order-Logic Question": "∃x (Man(x) ∧ Classmate(x, michael) ∧ Taller(x, peter)) ::: Peter is shorter than a man in Michael's class."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∀x ∀y (Man(x) ∧ Man(y) ∧ Taller(x, y) → Block(x, y)) ::: If a man is taller than another man, the taller one can block the other's shooting.\nMan(x)∧¬(Man(x)→Taller(x,y)) ::: Michael is a man who is taller than everyone else in his class.\n∀x ∀y ∀z (Taller(x, y) ∧ Taller(y, z) → Taller(x, z)) ::: If person x is taller than person y, and person y is taller than person z, than x is taller than z\nMan(peter) ∧ Taller(peter, michael) ::: Peter is a man who is taller than Michael.\n∀x (Shooter(x) ∧ ¬Jump(x) → Block(michael, x)) ::: Michael can block any shooting from a person as long as the person does not jump when shooting.\n¬Block(michael, windy) ::: Michael cannot block Windy's shooting.\n∀x (Shooter(x) ∧ Jump(x) → GreatShooter(x)) ::: Every shooter who can jump when shooting is a great shooter.",
                "First-Order-Logic Question": "∃x (Man(x) ∧ Classmate(x, michael) ∧ Taller(x, peter)) ::: Peter is shorter than a man in Michael's class."
            },
            "diff": [
                {
                    "raw": "Man(michael) ∧ ∀x (Man(x) ∧ x ≠ michael → Taller(michael, x)) ::: Michael is a man who is taller than everyone else in his class.",
                    "gram": "Man(x)∧¬(Man(x)→Taller(x,y)) ::: Michael is a man who is taller than everyone else in his class."
                }
            ],
            "answer": "B",
            "error_type":"",
            "grammar_answer": "A"
        },
        {
            "id": 117,
            "raw_prog": {
                "First-Order-Logic Rules": "∀x ∀y (Man(x) ∧ Man(y) ∧ Taller(x, y) → Block(x, y)) ::: If a man is taller than another man, the taller one can block the other's shooting.\nMan(michael) ∧ ∀x (Classmate(x, michael) ∧ x ≠ michael → Taller(michael, x)) ::: Michael is a man who is taller than everyone else in his class.\n∀x ∀y ∀z (Taller(x, y) ∧ Taller(y, z) → Taller(x, z)) ::: If person x is taller than person y, and person y is taller than person z, than x is taller than z\nMan(peter) ∧ Taller(peter, michael) ::: Peter is a man who is taller than Michael.\n∀x (Shoot(x) ∧ ¬Jump(x) → Block(michael, x)) ::: Michael can block any shooting from a person as long as the person does not jump when shooting.\n¬Block(michael, windy) ::: Michael cannot block Windy's shooting.\n∀x (Jump(x) → GreatShooter(x)) ::: Every shooter who can jump when shooting is a great shooter.",
                "First-Order-Logic Question": "Block(peter, windy) ::: Peter can block Windy's shooting."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∀x ∀y (Man(x) ∧ Man(y) ∧ Taller(x, y) → Block(x, y)) ::: If a man is taller than another man, the taller one can block the other's shooting.\nMan(x)→Taller(x,y)∧¬(Classmate(x,y))∧¬(Block(x,y))∧¬(Shoot(x)) ::: Michael is a man who is taller than everyone else in his class.\n∀x ∀y ∀z (Taller(x, y) ∧ Taller(y, z) → Taller(x, z)) ::: If person x is taller than person y, and person y is taller than person z, than x is taller than z\nMan(peter) ∧ Taller(peter, michael) ::: Peter is a man who is taller than Michael.\n∀x (Shoot(x) ∧ ¬Jump(x) → Block(michael, x)) ::: Michael can block any shooting from a person as long as the person does not jump when shooting.\n¬Block(michael, windy) ::: Michael cannot block Windy's shooting.\n∀x (Jump(x) → GreatShooter(x)) ::: Every shooter who can jump when shooting is a great shooter.",
                "First-Order-Logic Question": "Block(peter, windy) ::: Peter can block Windy's shooting."
            },
            "diff": [
                {
                    "raw": "Man(michael) ∧ ∀x (Classmate(x, michael) ∧ x ≠ michael → Taller(michael, x)) ::: Michael is a man who is taller than everyone else in his class.",
                    "gram": "Man(x)→Taller(x,y)∧¬(Classmate(x,y))∧¬(Block(x,y))∧¬(Shoot(x)) ::: Michael is a man who is taller than everyone else in his class."
                }
            ],
            "answer": "C",
            "error_type":"",
            "grammar_answer": "A"
        },
        {
            "id": 122,
            "raw_prog": {
                "First-Order-Logic Rules": "∀x (Transport(x) → ¬Empty(x)) ::: If something can transport multiple passengers, then they are not empty. \n∀x (Airline(x) → Transport(x)) ::: All airlines can transport multiple passengers. \n∀x (Plane(x) → Empty(x)) ::: All planes are empty. \n∀x (Boeing707(x) → Plane(x)) ::: All Boeing 707s are planes. \n¬Airline(Greyhound) → ¬∃x (Greyhound(x) ∧ Plane(x)) ::: If Greyhound is not an airline, then there are no Greyhound planes.",
                "First-Order-Logic Question": "Airline(Greyhound) ::: Greyhound is an airline."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∀x (Transport(x) → ¬Empty(x)) ::: If something can transport multiple passengers, then they are not empty. \n∀x (Airline(x) → Transport(x)) ::: All airlines can transport multiple passengers. \n∀x (Plane(x) → Empty(x)) ::: All planes are empty. \n∀x (Boeing707(x) → Plane(x)) ::: All Boeing 707s are planes. \n¬Airline(x)→¬Plane(x) ::: If Greyhound is not an airline, then there are no Greyhound planes.",
                "First-Order-Logic Question": "Airline(Greyhound) ::: Greyhound is an airline."
            },
            "diff": [
                {
                    "raw": "¬Airline(Greyhound) → ¬∃x (Greyhound(x) ∧ Plane(x)) ::: If Greyhound is not an airline, then there are no Greyhound planes.",
                    "gram": "¬Airline(x)→¬Plane(x) ::: If Greyhound is not an airline, then there are no Greyhound planes."
                }
            ],
            "answer": "C",
            "error_type":"",
            "grammar_answer": "C"
        },
        {
            "id": 123,
            "raw_prog": {
                "First-Order-Logic Rules": "∀x (Transport(x) → ¬Empty(x)) ::: If something can transport multiple passengers, then they are not empty. \n∀x (Airline(x) → Transport(x)) ::: All airlines can transport multiple passengers. \n∀x (Plane(x) → Empty(x)) ::: All planes are empty. \n∀x (Boeing707(x) → Plane(x)) ::: All Boeing 707s are planes. \n¬Airline(Greyhound) → ¬∃x (Greyhound(x) ∧ Plane(x)) ::: If Greyhound is not an airline, then there are no Greyhound planes.",
                "First-Order-Logic Question": "Boeing707(Greyhound) ::: A Greyhound is a Boeing 707."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∀x (Transport(x) → ¬Empty(x)) ::: If something can transport multiple passengers, then they are not empty. \n∀x (Airline(x) → Transport(x)) ::: All airlines can transport multiple passengers. \n∀x (Plane(x) → Empty(x)) ::: All planes are empty. \n∀x (Boeing707(x) → Plane(x)) ::: All Boeing 707s are planes. \n¬Airline(x)→¬Plane(x) ::: If Greyhound is not an airline, then there are no Greyhound planes.",
                "First-Order-Logic Question": "Boeing707(Greyhound) ::: A Greyhound is a Boeing 707."
            },
            "diff": [
                {
                    "raw": "¬Airline(Greyhound) → ¬∃x (Greyhound(x) ∧ Plane(x)) ::: If Greyhound is not an airline, then there are no Greyhound planes.",
                    "gram": "¬Airline(x)→¬Plane(x) ::: If Greyhound is not an airline, then there are no Greyhound planes."
                }
            ],
            "answer": "B",
            "error_type":"",
            "grammar_answer": "B"
        },
        {
            "id": 129,
            "raw_prog": {
                "First-Order-Logic Rules": "∀x (HaveWedding(x) → HaveChild(x)) ::: All people who have a wedding are people who have at least one child.\n∀x (TravelToParisForHoneymoon(x) → HaveWedding(x)) ::: All people who travel to Paris for their honeymoon are people who have a wedding.\n∀x (Weddings(x) ∧ July(x) → BelongTo(x, TravelToParisForHoneymoon(x))) ::: All weddings that occur in July belong to people who travel to Paris for their honeymoon.\n∃x (Weddings(x) ∧ July(x) ∧ WellAttended(x)) ::: Some weddings in July are well-attended.\nHaveChild(John) → (¬TravelToParisForHoneymoon(John) ∧ ¬HaveWedding(John)) ::: If John has at least one child, then John does not travel to Paris for his honeymoon and does not have a wedding.\nHaveWedding(John) ∧ WellAttended(John) → (July(John) ∨ (¬July(John) ∧ TravelToParisForHoneymoon(John))) ::: If John has a wedding that is well-attended, then John has a wedding in July or, if not, then John travels to Paris for their honeymoon.",
                "First-Order-Logic Question": "¬WellAttended(John) ::: John does not have a wedding that is well-attended."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∀x (HaveWedding(x) → HaveChild(x)) ::: All people who have a wedding are people who have at least one child.\n∀x (TravelToParisForHoneymoon(x) → HaveWedding(x)) ::: All people who travel to Paris for their honeymoon are people who have a wedding.\n∀x(WellAttended(x)→BelongTo(x,x)) ::: All weddings that occur in July belong to people who travel to Paris for their honeymoon.\n∃x (Weddings(x) ∧ July(x) ∧ WellAttended(x)) ::: Some weddings in July are well-attended.\nHaveChild(John) → (¬TravelToParisForHoneymoon(John) ∧ ¬HaveWedding(John)) ::: If John has at least one child, then John does not travel to Paris for his honeymoon and does not have a wedding.\nHaveWedding(John) ∧ WellAttended(John) → (July(John) ∨ (¬July(John) ∧ TravelToParisForHoneymoon(John))) ::: If John has a wedding that is well-attended, then John has a wedding in July or, if not, then John travels to Paris for their honeymoon.",
                "First-Order-Logic Question": "¬WellAttended(John) ::: John does not have a wedding that is well-attended."
            },
            "diff": [
                {
                    "raw": "∀x (Weddings(x) ∧ July(x) → BelongTo(x, TravelToParisForHoneymoon(x))) ::: All weddings that occur in July belong to people who travel to Paris for their honeymoon.",
                    "gram": "∀x(WellAttended(x)→BelongTo(x,x)) ::: All weddings that occur in July belong to people who travel to Paris for their honeymoon."
                }
            ],
            "answer": "A",
            "error_type":"",
            "grammar_answer": "C"
        },
        {
            "id": 131,
            "raw_prog": {
                "First-Order-Logic Rules": "∀x HaveWedding(x) → HaveChild(x) ::: All people who have a wedding are people who have at least one child.\n∀x (TravelToParisForHoneymoon(x) → HaveWedding(x)) ::: All people who travel to Paris for their honeymoon are people who have a wedding.\n∀x (Weddings(x) ∧ July(x) → BelongTo(x, TravelToParisForHoneymoon(x))) ::: All weddings that occur in July belong to people who travel to Paris for their honeymoon.\n∃x (Weddings(x) ∧ July(x) ∧ WellAttended(x)) ::: Some weddings in July are well-attended.\nHaveChild(John) → ¬(TravelToParisForHoneymoon(John) ∧ HaveWedding(John)) ::: If John has at least one child, then John does not travel to Paris for his honeymoon and does not have a wedding.\nHaveWedding(John) ∧ WellAttended(John) → (July(John) ∨ (¬July(John) ∧ TravelToParisForHoneymoon(John))) ::: If John has a wedding that is well-attended, then John has a wedding in July or, if not, then John travels to Paris for their honeymoon.",
                "First-Order-Logic Question": "¬(WellAttended(John) ∨ TravelToParisForHoneymoon(John)) ::: John has neither a wedding that is well-attended nor does he travel to Paris for his honeymoon."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∀x HaveWedding(x) → HaveChild(x) ::: All people who have a wedding are people who have at least one child.\n∀x (TravelToParisForHoneymoon(x) → HaveWedding(x)) ::: All people who travel to Paris for their honeymoon are people who have a wedding.\n∀x(WellAttended(x)→BelongTo(x,x)) ::: All weddings that occur in July belong to people who travel to Paris for their honeymoon.\n∃x (Weddings(x) ∧ July(x) ∧ WellAttended(x)) ::: Some weddings in July are well-attended.\nHaveChild(John) → ¬(TravelToParisForHoneymoon(John) ∧ HaveWedding(John)) ::: If John has at least one child, then John does not travel to Paris for his honeymoon and does not have a wedding.\nHaveWedding(John) ∧ WellAttended(John) → (July(John) ∨ (¬July(John) ∧ TravelToParisForHoneymoon(John))) ::: If John has a wedding that is well-attended, then John has a wedding in July or, if not, then John travels to Paris for their honeymoon.",
                "First-Order-Logic Question": "¬(WellAttended(John) ∨ TravelToParisForHoneymoon(John)) ::: John has neither a wedding that is well-attended nor does he travel to Paris for his honeymoon."
            },
            "diff": [
                {
                    "raw": "∀x (Weddings(x) ∧ July(x) → BelongTo(x, TravelToParisForHoneymoon(x))) ::: All weddings that occur in July belong to people who travel to Paris for their honeymoon.",
                    "gram": "∀x(WellAttended(x)→BelongTo(x,x)) ::: All weddings that occur in July belong to people who travel to Paris for their honeymoon."
                }
            ],
            "answer": "A",
            "error_type":"",
            "grammar_answer": "C"
        },
        {
            "id": 154,
            "raw_prog": {
                "First-Order-Logic Rules": "∀x,y (Owns(x, y) → (WorkRegularlyAtHome(x) ∧ TidyOrganize(x))) ::: If people own a large desktop monitor at their home, then they work regularly and often at home.\n∀x,y (FullyStockedImpressiveHomeOffice(x) → LargeDesktopMonitor(x, y)) ::: All people who have a fully stocked and impressive home office are people who own a large desktop monitor at their home.\n∀x (WorkRegularlyAtHome(x) → TidyOrganize(x)) ::: All people who work regularly and often at home spend their free time tidying and organizing the spaces in their homes.\n∀x (WorkRegularlyAtHome(x) → VisitOfficeStore(x)) ::: All people who work regularly and often at home visit the office supply store regularly.\n∀x (TidyOrganize(x) → (¬GoToBedLate(x) ∧ ¬WakeUpAfterNoon(x))) ::: If people spend their free time tidying and organizing the spaces in their home, then they do not go to bed late and wake up every day after noon.\n(TidyOrganize(remy) ∧ (GoToBedLate(remy) ∧ WakeUpAfterNoon(remy))) ⊕ (¬GoToBedLate(remy) ∧ ¬WakeUpAfterNoon(remy) ∧ ¬TidyOrganize(remy)) ::: Remy either both goes to bed late and wakes up every day after noon and spends their free time tidying and organizing the spaces in their home, or they do not go to bed late and wake up every day after noon nor spend their free time tidying and organizing the spaces in their home.\n",
                "First-Order-Logic Question": "FullyStockedImpressiveHomeOffice(remy) ∧ VisitOfficeStore(remy) ::: Remy has a fully stocked and impressive home office and also visits the office supply store regularly."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∀x(Owns(x,y)→(WorkRegularlyAtHome(x))) ::: If people own a large desktop monitor at their home, then they work regularly and often at home.\n∀x(Owns(x,y)→LargeDesktopMonitor(x,y)) ::: All people who have a fully stocked and impressive home office are people who own a large desktop monitor at their home.\n∀x (WorkRegularlyAtHome(x) → TidyOrganize(x)) ::: All people who work regularly and often at home spend their free time tidying and organizing the spaces in their homes.\n∀x (WorkRegularlyAtHome(x) → VisitOfficeStore(x)) ::: All people who work regularly and often at home visit the office supply store regularly.\n∀x (TidyOrganize(x) → (¬GoToBedLate(x) ∧ ¬WakeUpAfterNoon(x))) ::: If people spend their free time tidying and organizing the spaces in their home, then they do not go to bed late and wake up every day after noon.\n(TidyOrganize(remy) ∧ (GoToBedLate(remy) ∧ WakeUpAfterNoon(remy))) ⊕ (¬GoToBedLate(remy) ∧ ¬WakeUpAfterNoon(remy) ∧ ¬TidyOrganize(remy)) ::: Remy either both goes to bed late and wakes up every day after noon and spends their free time tidying and organizing the spaces in their home, or they do not go to bed late and wake up every day after noon nor spend their free time tidying and organizing the spaces in their home.\n",
                "First-Order-Logic Question": "FullyStockedImpressiveHomeOffice(remy) ∧ VisitOfficeStore(remy) ::: Remy has a fully stocked and impressive home office and also visits the office supply store regularly."
            },
            "diff": [
                {
                    "raw": "∀x,y (Owns(x, y) → (WorkRegularlyAtHome(x) ∧ TidyOrganize(x))) ::: If people own a large desktop monitor at their home, then they work regularly and often at home.",
                    "gram": "∀x(Owns(x,y)→(WorkRegularlyAtHome(x))) ::: If people own a large desktop monitor at their home, then they work regularly and often at home."
                },
                {
                    "raw": "∀x,y (FullyStockedImpressiveHomeOffice(x) → LargeDesktopMonitor(x, y)) ::: All people who have a fully stocked and impressive home office are people who own a large desktop monitor at their home.",
                    "gram": "∀x(Owns(x,y)→LargeDesktopMonitor(x,y)) ::: All people who have a fully stocked and impressive home office are people who own a large desktop monitor at their home."
                }
            ],
            "answer": "B",
            "error_type":"",
            "grammar_answer": "C"
        },
        {
            "id": 180,
            "raw_prog": {
                "First-Order-Logic Rules": "Flies(susan, lga) ::: Susan flies to LGA airport.\nDeparture(x, y) ∧ Arrival(x, y) ⊕ ¬(x = y) ::: The departure and arrival can not be the same airport.\nFrom(john, lga) ::: John flies from LGA airport.",
                "First-Order-Logic Question": "From(susan, lga) ::: Susan flies from LGA airport."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "Flies(susan, lga) ::: Susan flies to LGA airport.\nDeparture(x,y)∧¬(From(x,y))∨Arrival(x,y)⊕¬(From(x,y)) ::: The departure and arrival can not be the same airport.\nFrom(john, lga) ::: John flies from LGA airport.",
                "First-Order-Logic Question": "From(susan, lga) ::: Susan flies from LGA airport."
            },
            "diff": [
                {
                    "raw": "Departure(x, y) ∧ Arrival(x, y) ⊕ ¬(x = y) ::: The departure and arrival can not be the same airport.",
                    "gram": "Departure(x,y)∧¬(From(x,y))∨Arrival(x,y)⊕¬(From(x,y)) ::: The departure and arrival can not be the same airport."
                }
            ],
            "answer": "B",
            "error_type":"",
            "grammar_answer": "C"
        },
        {
            "id": 199,
            "raw_prog": {
                "First-Order-Logic Rules": "Person(ailtonSilva) ∧ Born(ailtonSilva, 1995) ∧ KnownAs(ailtonSilva, ailton) ∧ FootballPlayer(ailton) ∧ Loan(ailton, braga) ∧ Brazilian(ailtonSilva) ∧ PlaysFor(ailtonSilva, nautico) ∧ Club(nautico) ∧ Club(braga) ∧ Club(fluminense) ::: Ailton Silva, born in 1995, is commonly known as Ailton. Ailton is a football player who was loaned out to Braga. Ailton Silva is a Brazillian footballer who plays for Nautico. Nautico is a football club along with Braga. Fluminense is a football club.",
                "First-Order-Logic Question": "¬∃x (PlaysFor(x, nautico) ∧ Brazilian(x)) ::: No one playing for Nautico is Brazilian."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "Person(x)→KnownAs(x,x)→FootballPlayer(x)→Loan(x,y)→Club(y)→PlaysFor(x,y)→Brazilian(x) ::: Ailton Silva, born in 1995, is commonly known as Ailton. Ailton is a football player who was loaned out to Braga. Ailton Silva is a Brazillian footballer who plays for Nautico. Nautico is a football club along with Braga. Fluminense is a football club.",
                "First-Order-Logic Question": "¬∃x (PlaysFor(x, nautico) ∧ Brazilian(x)) ::: No one playing for Nautico is Brazilian."
            },
            "diff": [
                {
                    "raw": "Person(ailtonSilva) ∧ Born(ailtonSilva, 1995) ∧ KnownAs(ailtonSilva, ailton) ∧ FootballPlayer(ailton) ∧ Loan(ailton, braga) ∧ Brazilian(ailtonSilva) ∧ PlaysFor(ailtonSilva, nautico) ∧ Club(nautico) ∧ Club(braga) ∧ Club(fluminense) ::: Ailton Silva, born in 1995, is commonly known as Ailton. Ailton is a football player who was loaned out to Braga. Ailton Silva is a Brazillian footballer who plays for Nautico. Nautico is a football club along with Braga. Fluminense is a football club.",
                    "gram": "Person(x)→KnownAs(x,x)→FootballPlayer(x)→Loan(x,y)→Club(y)→PlaysFor(x,y)→Brazilian(x) ::: Ailton Silva, born in 1995, is commonly known as Ailton. Ailton is a football player who was loaned out to Braga. Ailton Silva is a Brazillian footballer who plays for Nautico. Nautico is a football club along with Braga. Fluminense is a football club."
                }
            ],
            "answer": "B",
            "error_type":"",
            "grammar_answer": "C"
        },
        {
            "id": 201,
            "raw_prog": {
                "First-Order-Logic Rules": "Person(ailtonSilva) ∧ Born(ailtonSilva, 1995) ∧ KnownAs(ailtonSilva, ailton) ::: Ailton Silva, born in 1995, is commonly known as Ailton.\nFootballPlayer(ailton) ∧ Loan(ailton, braga) ::: Ailton is a football player who was loaned out to Braga.\nBrazilian(ailtonSilva) ∧ FootballPlayer(ailtonSilva) ∧ PlaysFor(ailtonSilva, nautico) ::: Ailton Silva is a Brazillian footballer who plays for Nautico.\nClub(nautico) ∧ Club(braga) ∧ Team(nautico, braga) ::: Nautico is a football club along with Braga.\nClub(fluminense) ::: Fluminense is a football club.\n",
                "First-Order-Logic Question": "¬(∃x Loan(ailton, Club(x))) ::: Ailton was not loaned out to a football club."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "Person(ailtonSilva) ∧ Born(ailtonSilva, 1995) ∧ KnownAs(ailtonSilva, ailton) ::: Ailton Silva, born in 1995, is commonly known as Ailton.\nFootballPlayer(ailton) ∧ Loan(ailton, braga) ::: Ailton is a football player who was loaned out to Braga.\nBrazilian(ailtonSilva) ∧ FootballPlayer(ailtonSilva) ∧ PlaysFor(ailtonSilva, nautico) ::: Ailton Silva is a Brazillian footballer who plays for Nautico.\nClub(nautico) ∧ Club(braga) ∧ Team(nautico, braga) ::: Nautico is a football club along with Braga.\nClub(fluminense) ::: Fluminense is a football club.\n",
                "First-Order-Logic Question": "¬(Loan(x,y)) ::: Ailton was not loaned out to a football club."
            },
            "diff": [
                {
                    "raw": "¬(∃x Loan(ailton, Club(x))) ::: Ailton was not loaned out to a football club.",
                    "gram": "¬(Loan(x,y)) ::: Ailton was not loaned out to a football club."
                }
            ],
            "answer": "B",
            "error_type":"",
            "grammar_answer": "C"
        },
        {
            "id": 11,
            "raw_prog": {
                "First-Order-Logic Rules": "WildTurkey(tom) ::: Tom is a wild turkey.\n∀x (WildTurkey(x) → (x = EasternWildTurkey ∨ x = OsceolaWildTurkey ∨ x = GouldsWildTurkey ∨ x = MerriamsWildTurkey ∨ x = RioGrandeWildTurkey ∨ x = OcellatedWildTurkey)) ::: There are six types of wild turkeys: Eastern wild turkey, Osceola wild turkey, Gould’s wild turkey, Merriam’s wild turkey, Rio Grande wild turkey, and Ocellated wild turkey.\n¬EasternWildTurkey(tom) ∧ ¬OsceolaWildTurkey(tom) ∧ ¬GouldsWildTurkey(tom) ∧ ¬MerriamsWildTurkey(tom) ∧ ¬RioGrandeWildTurkey(tom) ::: Tom is not an Eastern wild turkey, Osceola wild turkey, Gould's wild turkey, Merriam's wild turkey, or Rio Grande wild turkey.\n",
                "First-Order-Logic Question": "WildTurkey(joey) ::: Joey is a wild turkey."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "WildTurkey(tom) ::: Tom is a wild turkey.\n∀x(WildTurkey(x)→(EasternWildTurkey(x))) ::: There are six types of wild turkeys: Eastern wild turkey, Osceola wild turkey, Gould’s wild turkey, Merriam’s wild turkey, Rio Grande wild turkey, and Ocellated wild turkey.\n¬EasternWildTurkey(tom) ∧ ¬OsceolaWildTurkey(tom) ∧ ¬GouldsWildTurkey(tom) ∧ ¬MerriamsWildTurkey(tom) ∧ ¬RioGrandeWildTurkey(tom) ::: Tom is not an Eastern wild turkey, Osceola wild turkey, Gould's wild turkey, Merriam's wild turkey, or Rio Grande wild turkey.\n",
                "First-Order-Logic Question": "WildTurkey(joey) ::: Joey is a wild turkey."
            },
            "diff": [
                {
                    "raw": "∀x (WildTurkey(x) → (x = EasternWildTurkey ∨ x = OsceolaWildTurkey ∨ x = GouldsWildTurkey ∨ x = MerriamsWildTurkey ∨ x = RioGrandeWildTurkey ∨ x = OcellatedWildTurkey)) ::: There are six types of wild turkeys: Eastern wild turkey, Osceola wild turkey, Gould’s wild turkey, Merriam’s wild turkey, Rio Grande wild turkey, and Ocellated wild turkey.",
                    "gram": "∀x(WildTurkey(x)→(EasternWildTurkey(x))) ::: There are six types of wild turkeys: Eastern wild turkey, Osceola wild turkey, Gould’s wild turkey, Merriam’s wild turkey, Rio Grande wild turkey, and Ocellated wild turkey."
                }
            ],
            "answer": "C",
            "error_type":"",
            "grammar_answer": "A"
        },
        {
            "id": 41,
            "raw_prog": {
                "First-Order-Logic Rules": "∀x (DesignStyle(x, ZahaHadid) → Timeless(x)) ::: All of Zaha Hadid's design styles are timeless.\n∀x (MassProductDesign(x) → ¬Timeless(x)) ::: No mass product design is timeless.\nDesignStyle(ZahaHadid, y) ∨ DesignStyle(KellyWearstler, y) ::: Either Zaha Hadid's design style or Kelly Wearstler's design style.\n∀x (DesignStyle(x, KellyWearstler) → Evocative(x)) ::: All of Kelly Wearstler's design styles are evocative.\n∀x (DesignStyle(x, KellyWearstler) → Dreamy(x)) ::: All of Kelly Wearstler's design styles are dreamy.\n∀x (Timeless(DesignBy(x, Max)) → (MassProductDesign(DesignBy(x, Max)) ∧ Evocative(DesignBy(x, Max)))) ::: If a design by Max is timeless, then a design by Max is a mass product design and evocative.\n",
                "First-Order-Logic Question": "Evocative(DesignBy(Max, Max)) ∨ Dreamy(DesignBy(Max, Max)) ::: A design by Max is either evocative or dreamy."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∀x (DesignStyle(x, ZahaHadid) → Timeless(x)) ::: All of Zaha Hadid's design styles are timeless.\n∀x (MassProductDesign(x) → ¬Timeless(x)) ::: No mass product design is timeless.\nDesignStyle(ZahaHadid, y) ∨ DesignStyle(KellyWearstler, y) ::: Either Zaha Hadid's design style or Kelly Wearstler's design style.\n∀x (DesignStyle(x, KellyWearstler) → Evocative(x)) ::: All of Kelly Wearstler's design styles are evocative.\n∀x (DesignStyle(x, KellyWearstler) → Dreamy(x)) ::: All of Kelly Wearstler's design styles are dreamy.\n∀x(Timeless(x)→(MassProductDesign(x))) ::: If a design by Max is timeless, then a design by Max is a mass product design and evocative.\n",
                "First-Order-Logic Question": "Evocative(x)∨Dreamy(x) ::: A design by Max is either evocative or dreamy."
            },
            "diff": [
                {
                    "raw": "∀x (Timeless(DesignBy(x, Max)) → (MassProductDesign(DesignBy(x, Max)) ∧ Evocative(DesignBy(x, Max)))) ::: If a design by Max is timeless, then a design by Max is a mass product design and evocative.",
                    "gram": "∀x(Timeless(x)→(MassProductDesign(x))) ::: If a design by Max is timeless, then a design by Max is a mass product design and evocative."
                },
                {
                    "raw": "Evocative(DesignBy(Max, Max)) ∨ Dreamy(DesignBy(Max, Max)) ::: A design by Max is either evocative or dreamy.",
                    "gram": "Evocative(x)∨Dreamy(x) ::: A design by Max is either evocative or dreamy."
                }
            ],
            "answer": "B",
            "error_type":"",
            "grammar_answer": "A"
        },
        {
            "id": 79,
            "raw_prog": {
                "First-Order-Logic Rules": "¬(∃x (Bakery(x) ∧ Spicy(x))) ::: No bakery is spicy.\n∀x (Cupcake(x) → Bakery(x)) ::: All cupcakes are bakeries.\n∀x (Hotpot(x) → Spicy(x)) ::: All hotpots are spicy.\n∀x (Product(BakedByMelissa(x), x) → Cupcake(x)) ::: All products of Baked by Melissa are cupcakes.\n(DriedThaiChilies(driedthaichilies) ∨ Bakery(driedthaichilies)) → (Hotpot(driedthaichilies) ∨ Spicy(driedthaichilies)) ::: If dried Thai chilies are spicy or a bakery, then dried Thai chilies are a hotpot or are spicy.\n",
                "First-Order-Logic Question": "Product(driedthaichilies, BakedByMelissa) ::: Dried Thai chilies are a product of Baked by Melissa."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "¬(∃x (Bakery(x) ∧ Spicy(x))) ::: No bakery is spicy.\n∀x (Cupcake(x) → Bakery(x)) ::: All cupcakes are bakeries.\n∀x (Hotpot(x) → Spicy(x)) ::: All hotpots are spicy.\n∀x(Product(x,y)→Cupcake(x)) ::: All products of Baked by Melissa are cupcakes.\n(DriedThaiChilies(driedthaichilies) ∨ Bakery(driedthaichilies)) → (Hotpot(driedthaichilies) ∨ Spicy(driedthaichilies)) ::: If dried Thai chilies are spicy or a bakery, then dried Thai chilies are a hotpot or are spicy.\n",
                "First-Order-Logic Question": "Product(driedthaichilies, BakedByMelissa) ::: Dried Thai chilies are a product of Baked by Melissa."
            },
            "diff": [
                {
                    "raw": "∀x (Product(BakedByMelissa(x), x) → Cupcake(x)) ::: All products of Baked by Melissa are cupcakes.",
                    "gram": "∀x(Product(x,y)→Cupcake(x)) ::: All products of Baked by Melissa are cupcakes."
                }
            ],
            "answer": "B",
            "error_type":"",
            "grammar_answer": "B"
        },
        {
            "id": 85,
            "raw_prog": {
                "First-Order-Logic Rules": "∀x (Listed(x) → ¬NotNegative(x)) ::: If the restaurant is listed in Yelp’s recommendations, then the restaurant does not receive many negative reviews.\n∀x (Rating(x, y) ∧ y > 9 → Listed(x)) ::: All restaurants with a rating greater than 9 are listed in Yelp’s recommendations.\n∃x (Restaurant(x) ∧ ¬Provide(x, takeout) → NotNegative(x)) ::: Some restaurants that do not provide take-out service receive many negative reviews.\n∀x (Popular(x) → Rating(x, y) ∧ y > 9) ::: All restaurants that are popular among local residents have ratings greater than 9.\nRating(subway, y) ∨ Popular(subway) ::: Subway has a rating greater than 9 or is popular among local residents.\n",
                "First-Order-Logic Question": "TakeOut(subway) ∧ ¬NotNegative(subway) ::: Subway provides take-out service and does not receive many negative reviews."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∀x (Listed(x) → ¬NotNegative(x)) ::: If the restaurant is listed in Yelp’s recommendations, then the restaurant does not receive many negative reviews.\n∀x(Rating(x,y)∧(NotNegative(x))) ::: All restaurants with a rating greater than 9 are listed in Yelp’s recommendations.\n∃x (Restaurant(x) ∧ ¬Provide(x, takeout) → NotNegative(x)) ::: Some restaurants that do not provide take-out service receive many negative reviews.\n∀x(Popular(x)→Rating(x,y)∧(Rating(x,y))) ::: All restaurants that are popular among local residents have ratings greater than 9.\nRating(subway, y) ∨ Popular(subway) ::: Subway has a rating greater than 9 or is popular among local residents.\n",
                "First-Order-Logic Question": "TakeOut(subway) ∧ ¬NotNegative(subway) ::: Subway provides take-out service and does not receive many negative reviews."
            },
            "diff": [
                {
                    "raw": "∀x (Rating(x, y) ∧ y > 9 → Listed(x)) ::: All restaurants with a rating greater than 9 are listed in Yelp’s recommendations.",
                    "gram": "∀x(Rating(x,y)∧(NotNegative(x))) ::: All restaurants with a rating greater than 9 are listed in Yelp’s recommendations."
                },
                {
                    "raw": "∀x (Popular(x) → Rating(x, y) ∧ y > 9) ::: All restaurants that are popular among local residents have ratings greater than 9.",
                    "gram": "∀x(Popular(x)→Rating(x,y)∧(Rating(x,y))) ::: All restaurants that are popular among local residents have ratings greater than 9."
                }
            ],
            "answer": "A",
            "error_type":"",
            "grammar_answer": "B"
        },
        {
            "id": 87,
            "raw_prog": {
                "First-Order-Logic Rules": "∀x (SuperheroMovie(x) → Win(GoodGuy(x))) ::: In superhero movies, the good guys always win.\nSuperheroMovie(sir_digby) ∧ NamedAfter(sir_digby, sir_digby) ::: The Surprising Adventures of Sir Digby Chicken Caesar is a superhero movie.\n∀x (GoodGuy(x) → Fight(x, BadGuy(x)) ∧ Fight(BadGuy(x), x)) ::: Good guys fight bad guys and vice versa.\nFight(sir_digby, nemesis) ::: Sir Digby fights his nemesis.\n∀x (SuperheroMovie(x) ∧ NamedAfter(x, character) → GoodGuy(character)) ::: If a superhero movie is named after a character, that character is a good guy.\nNamedAfter(sir_digby, sir_digby) ::: The Surprising Adventures of Sir Digby Chicken Caesar is named after Sir Digby.\n∀x ∀y (Win(x) → Lose(y)) ::: If somebody wins a fight, the person they are fighting loses.\n∀x ∀y (SuperheroMovie(x) ∧ NamedAfter(x, y) → AppearIn(y, x)) ::: If a superhero movie is named after a character, that character appears in the movie.\n",
                "First-Order-Logic Question": "Lose(nemesis) ::: Sir Digby’s nemesis loses."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∀x(SuperheroMovie(x)→Win(x)) ::: In superhero movies, the good guys always win.\nSuperheroMovie(sir_digby) ∧ NamedAfter(sir_digby, sir_digby) ::: The Surprising Adventures of Sir Digby Chicken Caesar is a superhero movie.\n∀x(GoodGuy(x)→Fight(x,y)∧Fight(y,x)) ::: Good guys fight bad guys and vice versa.\nFight(sir_digby, nemesis) ::: Sir Digby fights his nemesis.\n∀x (SuperheroMovie(x) ∧ NamedAfter(x, character) → GoodGuy(character)) ::: If a superhero movie is named after a character, that character is a good guy.\nNamedAfter(sir_digby, sir_digby) ::: The Surprising Adventures of Sir Digby Chicken Caesar is named after Sir Digby.\n∀x ∀y (Win(x) → Lose(y)) ::: If somebody wins a fight, the person they are fighting loses.\n∀x ∀y (SuperheroMovie(x) ∧ NamedAfter(x, y) → AppearIn(y, x)) ::: If a superhero movie is named after a character, that character appears in the movie.\n",
                "First-Order-Logic Question": "Lose(nemesis) ::: Sir Digby’s nemesis loses."
            },
            "diff": [
                {
                    "raw": "∀x (SuperheroMovie(x) → Win(GoodGuy(x))) ::: In superhero movies, the good guys always win.",
                    "gram": "∀x(SuperheroMovie(x)→Win(x)) ::: In superhero movies, the good guys always win."
                },
                {
                    "raw": "∀x (GoodGuy(x) → Fight(x, BadGuy(x)) ∧ Fight(BadGuy(x), x)) ::: Good guys fight bad guys and vice versa.",
                    "gram": "∀x(GoodGuy(x)→Fight(x,y)∧Fight(y,x)) ::: Good guys fight bad guys and vice versa."
                }
            ],
            "answer": "A",
            "error_type":"",
            "grammar_answer": "A"
        },
        {
            "id": 95,
            "raw_prog": {
                "First-Order-Logic Rules": "∃x (Pet(x) ∧ AllowedIn(x, y)) ::: Pets are allowed in some managed buildings.\n∀x (RequireDeposit(x) → (Equal(x, RentAmount(y, z)) ∨ MoreThan(x, RentAmount(y, z)))) ::: A deposit is required to rent an apartment in a managed building.\nCat(fluffy) ∧ Pet(fluffy) ∧ Owner(tom, fluffy) ::: Fluffy is Tom's cat.\nCat(x) → Pet(x) ::: Cats are pets.\nManaged(olivegarden) ∧ Building(olivegarden) ::: The Olive Garden is a managed building.\nRentAmount(olivegarden, 2000) ::: The monthly rent at the Olive Garden is $2000.\nRentApartment(tom, olivegarden) ↔ (MoveInWith(tom, fluffy) ∧ ¬MoreThan(deposit, 1500)) ::: Tom will rent an apartment in a managed building if and only if he is allowed to move in with Fluffy, and the security deposit is no more than $1500.\nMoreThan(2000, 1500) ::: 2000$ is more than $1500.\n",
                "First-Order-Logic Question": "Equal(deposit, 2000) ∨ MoreThan(deposit, 2000) ::: The security deposit at the Olive Garden is either $2000 or more."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∃x (Pet(x) ∧ AllowedIn(x, y)) ::: Pets are allowed in some managed buildings.\n∀x(RequireDeposit(x)→(Equal(x,y))) ::: A deposit is required to rent an apartment in a managed building.\nCat(fluffy) ∧ Pet(fluffy) ∧ Owner(tom, fluffy) ::: Fluffy is Tom's cat.\nCat(x) → Pet(x) ::: Cats are pets.\nManaged(olivegarden) ∧ Building(olivegarden) ::: The Olive Garden is a managed building.\nRentAmount(olivegarden, 2000) ::: The monthly rent at the Olive Garden is $2000.\nRentApartment(tom, olivegarden) ↔ (MoveInWith(tom, fluffy) ∧ ¬MoreThan(deposit, 1500)) ::: Tom will rent an apartment in a managed building if and only if he is allowed to move in with Fluffy, and the security deposit is no more than $1500.\nMoreThan(2000, 1500) ::: 2000$ is more than $1500.\n",
                "First-Order-Logic Question": "Equal(deposit, 2000) ∨ MoreThan(deposit, 2000) ::: The security deposit at the Olive Garden is either $2000 or more."
            },
            "diff": [
                {
                    "raw": "∀x (RequireDeposit(x) → (Equal(x, RentAmount(y, z)) ∨ MoreThan(x, RentAmount(y, z)))) ::: A deposit is required to rent an apartment in a managed building.",
                    "gram": "∀x(RequireDeposit(x)→(Equal(x,y))) ::: A deposit is required to rent an apartment in a managed building."
                }
            ],
            "answer": "A",
            "error_type":"",
            "grammar_answer": "C"
        },
        {
            "id": 106,
            "raw_prog": {
                "First-Order-Logic Rules": "Cost(gre, 205) ::: It costs US $205 to take the GRE test.\n∀x ∀y (TakeTest(x, gre) ∧ EconomicHardship(y) ∧ Difficulty(y, money) → ProvideAid(ets, x)) ::: ETS provides financial aid to those GRE applicants who prove economic hardship.\n∀x (EconomicHardship(x) ↔ (Difficulty(x, money) ∨ Difficulty(x, resources))) ::: Economic hardship refers to difficulty caused by having too little money or too few resources.\nSingleParentFamily(tom) ::: Tom lives in a single-parent family.\nOutOfWork(tom's dad, more than a year) ::: His dad has been out of work for more than a year.\n",
                "First-Order-Logic Question": "∃x (Cost(gre, x) ∧ x < 300) ::: It cost below US $300 to take the GRE test."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "Cost(gre, 205) ::: It costs US $205 to take the GRE test.\n∀x ∀y (TakeTest(x, gre) ∧ EconomicHardship(y) ∧ Difficulty(y, money) → ProvideAid(ets, x)) ::: ETS provides financial aid to those GRE applicants who prove economic hardship.\n∀x (EconomicHardship(x) ↔ (Difficulty(x, money) ∨ Difficulty(x, resources))) ::: Economic hardship refers to difficulty caused by having too little money or too few resources.\nSingleParentFamily(tom) ::: Tom lives in a single-parent family.\nHave(x,y)→ProvideAid(x,y) ::: His dad has been out of work for more than a year.\n",
                "First-Order-Logic Question": "∃x(Cost(x,y)∧(Cost(x,y))) ::: It cost below US $300 to take the GRE test."
            },
            "diff": [
                {
                    "raw": "OutOfWork(tom's dad, more than a year) ::: His dad has been out of work for more than a year.",
                    "gram": "Have(x,y)→ProvideAid(x,y) ::: His dad has been out of work for more than a year."
                },
                {
                    "raw": "∃x (Cost(gre, x) ∧ x < 300) ::: It cost below US $300 to take the GRE test.",
                    "gram": "∃x(Cost(x,y)∧(Cost(x,y))) ::: It cost below US $300 to take the GRE test."
                }
            ],
            "answer": "A",
            "error_type":"",
            "grammar_answer": "C"
        },
        {
            "id": 107,
            "raw_prog": {
                "First-Order-Logic Rules": "Costs(gre, 205) ::: It costs US $205 to take the GRE test.\n∀x ∀y (Prove(x, EconomicHardship(y)) → ProvidesAid(ETS, y)) ::: ETS provides financial aid to those GRE applicants who prove economic hardship.\n∀x (EconomicHardship(x) ↔ (TooLittleMoney(x) ∨ TooFewResources(x))) ::: Economic hardship refers to difficulty caused by having too little money or too few resources.\nSingleParent(tom) ::: Tom lives in a single-parent family.\nOutOfWork(dad, moreThanAYear) ::: His dad has been out of work for more than a year.\n",
                "First-Order-Logic Question": "¬∃x ∀y (Costs(gre, y) ∧ ProvidesAid(ETS, x)) ::: There is no financial aid available for the GRE test."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "Costs(gre, 205) ::: It costs US $205 to take the GRE test.\nProvidesAid(x,y)→Prove(x,y)∧EconomicHardship(y) ::: ETS provides financial aid to those GRE applicants who prove economic hardship.\n∀x (EconomicHardship(x) ↔ (TooLittleMoney(x) ∨ TooFewResources(x))) ::: Economic hardship refers to difficulty caused by having too little money or too few resources.\nSingleParent(tom) ::: Tom lives in a single-parent family.\nOutOfWork(dad, moreThanAYear) ::: His dad has been out of work for more than a year.\n",
                "First-Order-Logic Question": "¬∃x ∀y (Costs(gre, y) ∧ ProvidesAid(ETS, x)) ::: There is no financial aid available for the GRE test."
            },
            "diff": [
                {
                    "raw": "∀x ∀y (Prove(x, EconomicHardship(y)) → ProvidesAid(ETS, y)) ::: ETS provides financial aid to those GRE applicants who prove economic hardship.",
                    "gram": "ProvidesAid(x,y)→Prove(x,y)∧EconomicHardship(y) ::: ETS provides financial aid to those GRE applicants who prove economic hardship."
                }
            ],
            "answer": "B",
            "error_type":"",
            "grammar_answer": "C"
        },
        {
            "id": 114,
            "raw_prog": {
                "First-Order-Logic Rules": "MountainRange(picurismountains) ∨ MountainRange(picurismountains) ::: The Picuris Mountains are a mountain range in New Mexico or Texas.\nVisited(juandeonate, picurismountains) ::: Juan de Onate visited the Picuris Mountains.\nLocatedIn(hardingpegmatitemine, picurismountains) ∧ Donated(hardingpegmatitemine) ::: The Harding Pegmatite Mine, located in the Picuris Mountains, was donated.\n∀x (MountainRange(x) ∧ In(x, texas) → ¬∃y (Mine(y) ∧ Has(y, donated) ∧ LocatedIn(y, x))) ::: There are no mountain ranges in Texas that have mines which have been donated.\n",
                "First-Order-Logic Question": "NotLocatedIn(hardingpegmatitemine, newmexico) ::: The Harding Pegmatite Mine is not located in a mountain range in New Mexico."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "MountainRange(picurismountains) ∨ MountainRange(picurismountains) ::: The Picuris Mountains are a mountain range in New Mexico or Texas.\nVisited(juandeonate, picurismountains) ::: Juan de Onate visited the Picuris Mountains.\nLocatedIn(hardingpegmatitemine, picurismountains) ∧ Donated(hardingpegmatitemine) ::: The Harding Pegmatite Mine, located in the Picuris Mountains, was donated.\n¬∃y(Mine(y)∧Has(y,x)∧LocatedIn(y,x)) ::: There are no mountain ranges in Texas that have mines which have been donated.\n",
                "First-Order-Logic Question": "NotLocatedIn(hardingpegmatitemine, newmexico) ::: The Harding Pegmatite Mine is not located in a mountain range in New Mexico."
            },
            "diff": [
                {
                    "raw": "∀x (MountainRange(x) ∧ In(x, texas) → ¬∃y (Mine(y) ∧ Has(y, donated) ∧ LocatedIn(y, x))) ::: There are no mountain ranges in Texas that have mines which have been donated.",
                    "gram": "¬∃y(Mine(y)∧Has(y,x)∧LocatedIn(y,x)) ::: There are no mountain ranges in Texas that have mines which have been donated."
                }
            ],
            "answer": "B",
            "error_type":"",
            "grammar_answer": "C"
        },
        {
            "id": 151,
            "raw_prog": {
                "First-Order-Logic Rules": "PublishingHouse(newVesselPress) ∧ SpecializeIn(newVesselPress, foreignLiterature) ∧ Language(allBooks, english) ∧ Book(neapolitanChronicles) ∧ Publish(newVesselPress, neapolitanChronicles) ∧ Translate(neapolitanChronicles, italian, english) ∧ Book(palaceOfFlies) ∧ Publish(newVesselPress, palaceOfFlies) ::: New Vessel Press is a publishing house which specializes in translating foreign literature into English. All of New Vessel Press's published books are in English. Neapolitan Chronicles is a book published by New Vessel Press. Neapolitan Chronicles was translated from Italian. Palace of Flies is a book published by New Vessel Press.",
                "First-Order-Logic Question": "¬Publish(newVesselPress, harryPotter) ::: Harry Potter was published by New Vessel Press."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "PublishingHouse(x)∧SpecializeIn(x,y)∧Language(x,z)∧Book(x)∧PublishedIn(x,y)∧Translate(x,y,z) ::: New Vessel Press is a publishing house which specializes in translating foreign literature into English. All of New Vessel Press's published books are in English. Neapolitan Chronicles is a book published by New Vessel Press. Neapolitan Chronicles was translated from Italian. Palace of Flies is a book published by New Vessel Press.",
                "First-Order-Logic Question": "¬Publish(newVesselPress, harryPotter) ::: Harry Potter was published by New Vessel Press."
            },
            "diff": [
                {
                    "raw": "PublishingHouse(newVesselPress) ∧ SpecializeIn(newVesselPress, foreignLiterature) ∧ Language(allBooks, english) ∧ Book(neapolitanChronicles) ∧ Publish(newVesselPress, neapolitanChronicles) ∧ Translate(neapolitanChronicles, italian, english) ∧ Book(palaceOfFlies) ∧ Publish(newVesselPress, palaceOfFlies) ::: New Vessel Press is a publishing house which specializes in translating foreign literature into English. All of New Vessel Press's published books are in English. Neapolitan Chronicles is a book published by New Vessel Press. Neapolitan Chronicles was translated from Italian. Palace of Flies is a book published by New Vessel Press.",
                    "gram": "PublishingHouse(x)∧SpecializeIn(x,y)∧Language(x,z)∧Book(x)∧PublishedIn(x,y)∧Translate(x,y,z) ::: New Vessel Press is a publishing house which specializes in translating foreign literature into English. All of New Vessel Press's published books are in English. Neapolitan Chronicles is a book published by New Vessel Press. Neapolitan Chronicles was translated from Italian. Palace of Flies is a book published by New Vessel Press."
                }
            ],
            "answer": "C",
            "error_type":"",
            "grammar_answer": "C"
        }
    ],
    "gcd_llama-2-7b_4": [
        {
            "id": 41,
            "raw_prog": {
                "First-Order-Logic Rules": [
                    "∀x (ZahaHadid(x) → Timeless(x)) ::: All of Zaha Hadid's design styles are timeless.",
                    "∀x (MassProduct(x) → ¬Timeless(x)) ::: No mass product design is timeless.",
                    "∀x (ZahaHadid(x) ∨ KellyWearstler(x)) ::: Either Zaha Hadid's design style or Kelly Wearstler's design style.",
                    "∀x (KellyWearstler(x) → Evocative(x)) ::: All of Kelly Wearstler's design styles are evocative.",
                    "∀x (KellyWearstler(x) → Dreamy(x)) ::: All of Kelly Wearstler's design styles are dreamy.",
                    "∀x (Timeless(Max(x)) → (MassProduct(Max(x)) ∧ Evocative(Max(x)))) ::: If a design by Max is timeless, then a design by Max is a mass product design and evocative."
                ],
                "First-Order-Logic Question": [
                    "Evocative(Max(x)) ∨ Dreamy(Max(x)) ::: A design by Max is either evocative or dreamy."
                ]
            },
            "gram_prog": {
                "First-Order-Logic Rules": [
                    "∀x (ZahaHadid(x) → Timeless(x)) ::: All of Zaha Hadid's design styles are timeless.",
                    "∀x (MassProduct(x) → ¬Timeless(x)) ::: No mass product design is timeless.",
                    "∀x (ZahaHadid(x) ∨ KellyWearstler(x)) ::: Either Zaha Hadid's design style or Kelly Wearstler's design style.",
                    "∀x (KellyWearstler(x) → Evocative(x)) ::: All of Kelly Wearstler's design styles are evocative.",
                    "∀x (KellyWearstler(x) → Dreamy(x)) ::: All of Kelly Wearstler's design styles are dreamy.",
                    "∀x(Timeless(x)→(MassProduct(x))) ::: If a design by Max is timeless, then a design by Max is a mass product design and evocative."
                ],
                "First-Order-Logic Question": [
                    "Evocative(x)∨Dreamy(x) ::: A design by Max is either evocative or dreamy."
                ]
            },
            "diff": [
                {
                    "raw": "∀x (Timeless(Max(x)) → (MassProduct(Max(x)) ∧ Evocative(Max(x)))) ::: If a design by Max is timeless, then a design by Max is a mass product design and evocative.",
                    "gram": "∀x(Timeless(x)→(MassProduct(x))) ::: If a design by Max is timeless, then a design by Max is a mass product design and evocative."
                },
                {
                    "raw": "Evocative(Max(x)) ∨ Dreamy(Max(x)) ::: A design by Max is either evocative or dreamy.",
                    "gram": "Evocative(x)∨Dreamy(x) ::: A design by Max is either evocative or dreamy."
                }
            ],
            "answer": "B",
            "error_type":"",
            "grammar_answer": "A"
        },
        {
            "id": 70,
            "raw_prog": {
                "First-Order-Logic Rules": [
                    "British(badults) ∧ Sitcom(badults) ∧ ∀x (MemberOf(x, pappys) → Star(x, badults)) ::: Badults is a British Sitcom series, starring members of Pappy's.",
                    "Pilot(badults, 2013) ∧ Network(badults, bbcthree) ::: Badults piloted in July 2013 on BBC Three.",
                    "WorkingTitle(badults, thesecretdudesociety) ::: The Working title 'The Secret Dude Society' was used for Badults.",
                    "ScriptEditor(andrewcollins, badults) ::: Andrew Collins was the script editor for Badults."
                ],
                "First-Order-Logic Question": [
                    "∀x (MemberOf(x, pappys) → ¬∃y (Star(x, y) ∧ (Network(y, bbctwo) ∨ Network(y, bbcthree)))) ::: No members of Pappy's have starred for a show piloting on BBC Two or BBC Three."
                ]
            },
            "gram_prog": {
                "First-Order-Logic Rules": [
                    "British(badults) ∧ Sitcom(badults) ∧ ∀x (MemberOf(x, pappys) → Star(x, badults)) ::: Badults is a British Sitcom series, starring members of Pappy's.",
                    "Pilot(badults, 2013) ∧ Network(badults, bbcthree) ::: Badults piloted in July 2013 on BBC Three.",
                    "WorkingTitle(badults, thesecretdudesociety) ::: The Working title 'The Secret Dude Society' was used for Badults.",
                    "ScriptEditor(andrewcollins, badults) ::: Andrew Collins was the script editor for Badults."
                ],
                "First-Order-Logic Question": [
                    "∀x(MemberOf(x,y)→¬(Star(x,y))) ::: No members of Pappy's have starred for a show piloting on BBC Two or BBC Three."
                ]
            },
            "diff": [
                {
                    "raw": "∀x (MemberOf(x, pappys) → ¬∃y (Star(x, y) ∧ (Network(y, bbctwo) ∨ Network(y, bbcthree)))) ::: No members of Pappy's have starred for a show piloting on BBC Two or BBC Three.",
                    "gram": "∀x(MemberOf(x,y)→¬(Star(x,y))) ::: No members of Pappy's have starred for a show piloting on BBC Two or BBC Three."
                }
            ],
            "answer": "B",
            "error_type":"",
            "grammar_answer": "C"
        },
        {
            "id": 93,
            "raw_prog": {
                "First-Order-Logic Rules": [
                    "∃x (Pet(x) ∧ ManagedBuilding(y) ∧ AllowedIn(x, y)) ::: Pets are allowed in some managed buildings.",
                    "∀x (ManagedBuilding(x) → DepositRequired(x)) ::: A deposit is required to rent an apartment in a managed building.",
                    "∀x ∀y (SecurityDeposit(x, y) → EqualOrMore(y, MonthlyRent(x, 1))) ::: The security deposit can be either equal to one month's rent or more.",
                    "Cat(fluffy) ∧ Owner(tom, fluffy) ::: Fluffy is Tom's cat.",
                    "∀x (Cat(x) → Pet(x)) ::: Cats are pets.",
                    "ManagedBuilding(olivegarden) ::: The Olive Garden is a managed building.",
                    "MonthlyRent(olivegarden, 2000) ::: The monthly rent at the Olive Garden is $2000.",
                    "∀x ∀y (Owner(x, y) ∧ Pet(y) ∧ ManagedBuilding(z) ∧ AllowedIn(y, z) ∧ SecurityDeposit(z, d) ∧ d ≤ 1500 ↔ Rent(x, z)) ::: Tom will rent an apartment in a managed building if and only if he is allowed to move in with Fluffy, and the security deposit is no more than $1500.",
                    "EqualOrMore(2000, 1500) ::: 2000$ is more than $1500."
                ],
                "First-Order-Logic Question": [
                    "Rent(tom, olivegarden) ::: Tom will rent an apartment in The Olive Garden."
                ]
            },
            "gram_prog": {
                "First-Order-Logic Rules": [
                    "∃x (Pet(x) ∧ ManagedBuilding(y) ∧ AllowedIn(x, y)) ::: Pets are allowed in some managed buildings.",
                    "∀x (ManagedBuilding(x) → DepositRequired(x)) ::: A deposit is required to rent an apartment in a managed building.",
                    "DepositRequired(x)→SecurityDeposit(x,y)→EqualOrMore(y,x) ::: The security deposit can be either equal to one month's rent or more.",
                    "Cat(fluffy) ∧ Owner(tom, fluffy) ::: Fluffy is Tom's cat.",
                    "∀x (Cat(x) → Pet(x)) ::: Cats are pets.",
                    "ManagedBuilding(olivegarden) ::: The Olive Garden is a managed building.",
                    "MonthlyRent(olivegarden, 2000) ::: The monthly rent at the Olive Garden is $2000.",
                    "∀x∀y(Owner(x,y)∧Pet(y)∧ManagedBuilding(z)∧AllowedIn(y,z)) ::: Tom will rent an apartment in a managed building if and only if he is allowed to move in with Fluffy, and the security deposit is no more than $1500.",
                    "EqualOrMore(2000, 1500) ::: 2000$ is more than $1500."
                ],
                "First-Order-Logic Question": [
                    "Rent(tom, olivegarden) ::: Tom will rent an apartment in The Olive Garden."
                ]
            },
            "diff": [
                {
                    "raw": "∀x ∀y (SecurityDeposit(x, y) → EqualOrMore(y, MonthlyRent(x, 1))) ::: The security deposit can be either equal to one month's rent or more.",
                    "gram": "DepositRequired(x)→SecurityDeposit(x,y)→EqualOrMore(y,x) ::: The security deposit can be either equal to one month's rent or more."
                },
                {
                    "raw": "∀x ∀y (Owner(x, y) ∧ Pet(y) ∧ ManagedBuilding(z) ∧ AllowedIn(y, z) ∧ SecurityDeposit(z, d) ∧ d ≤ 1500 ↔ Rent(x, z)) ::: Tom will rent an apartment in a managed building if and only if he is allowed to move in with Fluffy, and the security deposit is no more than $1500.",
                    "gram": "∀x∀y(Owner(x,y)∧Pet(y)∧ManagedBuilding(z)∧AllowedIn(y,z)) ::: Tom will rent an apartment in a managed building if and only if he is allowed to move in with Fluffy, and the security deposit is no more than $1500."
                }
            ],
            "answer": "B",
            "error_type":"",
            "grammar_answer": "C"
        },
        {
            "id": 95,
            "raw_prog": {
                "First-Order-Logic Rules": [
                    "∃x (ManagedBuilding(x) ∧ Pet(y) ∧ AllowedIn(y, x)) ::: Pets are allowed in some managed buildings.",
                    "∀x (ManagedBuilding(x) → DepositRequired(x)) ::: A deposit is required to rent an apartment in a managed building.",
                    "∀x ∀y (SecurityDeposit(x, y) → (EqualOrMore(y, MonthlyRent(x, 1)) ∨ EqualOrMore(y, MonthlyRent(x, 2)))) ::: The security deposit can be either equal to one month's rent or more.",
                    "Cat(fluffy) ∧ Owner(tom, fluffy) ::: Fluffy is Tom's cat.",
                    "∀x (Cat(x) → Pet(x)) ::: Cats are pets.",
                    "ManagedBuilding(olivegarden) ::: The Olive Garden is a managed building.",
                    "MonthlyRent(olivegarden, 2000) ::: The monthly rent at the Olive Garden is $2000.",
                    "∀x ∀y (Owner(tom, fluffy) ∧ ManagedBuilding(x) ∧ (AllowedIn(fluffy, x) ∧ SecurityDeposit(x, y) ∧ EqualOrMore(1500, y)) ↔ Rent(tom, x)) ::: Tom will rent an apartment in a managed building if and only if he is allowed to move in with Fluffy, and the security deposit is no more than $1500.",
                    "EqualOrMore(2000, 1500) ::: 2000$ is more than $1500."
                ],
                "First-Order-Logic Question": [
                    "SecurityDeposit(olivegarden, 2000) ∨ ∃y (SecurityDeposit(olivegarden, y) ∧ EqualOrMore(y, 2000)) ::: The security deposit at the Olive Garden is either $2000 or more."
                ]
            },
            "gram_prog": {
                "First-Order-Logic Rules": [
                    "∃x (ManagedBuilding(x) ∧ Pet(y) ∧ AllowedIn(y, x)) ::: Pets are allowed in some managed buildings.",
                    "∀x (ManagedBuilding(x) → DepositRequired(x)) ::: A deposit is required to rent an apartment in a managed building.",
                    "∀x∀y(SecurityDeposit(x,y)→(EqualOrMore(y,x))) ::: The security deposit can be either equal to one month's rent or more.",
                    "Cat(fluffy) ∧ Owner(tom, fluffy) ::: Fluffy is Tom's cat.",
                    "∀x (Cat(x) → Pet(x)) ::: Cats are pets.",
                    "ManagedBuilding(olivegarden) ::: The Olive Garden is a managed building.",
                    "MonthlyRent(olivegarden, 2000) ::: The monthly rent at the Olive Garden is $2000.",
                    "∀x ∀y (Owner(tom, fluffy) ∧ ManagedBuilding(x) ∧ (AllowedIn(fluffy, x) ∧ SecurityDeposit(x, y) ∧ EqualOrMore(1500, y)) ↔ Rent(tom, x)) ::: Tom will rent an apartment in a managed building if and only if he is allowed to move in with Fluffy, and the security deposit is no more than $1500.",
                    "EqualOrMore(2000, 1500) ::: 2000$ is more than $1500."
                ],
                "First-Order-Logic Question": [
                    "SecurityDeposit(olivegarden, 2000) ∨ ∃y (SecurityDeposit(olivegarden, y) ∧ EqualOrMore(y, 2000)) ::: The security deposit at the Olive Garden is either $2000 or more."
                ]
            },
            "diff": [
                {
                    "raw": "∀x ∀y (SecurityDeposit(x, y) → (EqualOrMore(y, MonthlyRent(x, 1)) ∨ EqualOrMore(y, MonthlyRent(x, 2)))) ::: The security deposit can be either equal to one month's rent or more.",
                    "gram": "∀x∀y(SecurityDeposit(x,y)→(EqualOrMore(y,x))) ::: The security deposit can be either equal to one month's rent or more."
                }
            ],
            "answer": "A",
            "error_type":"",
            "grammar_answer": "C"
        },
        {
            "id": 113,
            "raw_prog": {
                "First-Order-Logic Rules": [
                    "MountainRange(picurismountains) ∧ (In(picurismountains, newmexico) ⊕ In(picurismountains, texas)) ::: The Picuris Mountains are a mountain range in New Mexico or Texas.",
                    "Visit(juandeonate, picurismountains) ::: Juan de Onate visited the Picuris Mountains.",
                    "Mine(hardingpegmatitemine) ∧ LocatedIn(hardingpegmatitemine, picurismountains) ∧ Donate(hardingpegmatitemine) ::: The Harding Pegmatite Mine, located in the Picuris Mountains, was donated.",
                    "∀x (MountainRange(x) ∧ In(x, texas) → ¬∃y (Mine(y) ∧ LocatedIn(y, x) ∧ Donate(y))) ::: There are no mountain ranges in Texas that have mines which have been donated."
                ],
                "First-Order-Logic Question": "∃x (MountainRange(x) ∧ In(x, texas) ∧ Visit(juandeonate, x)) ::: Juan de Onate visited a mountain range in Texas."
            },
            "gram_prog": {
                "First-Order-Logic Rules": [
                    "MountainRange(picurismountains) ∧ (In(picurismountains, newmexico) ⊕ In(picurismountains, texas)) ::: The Picuris Mountains are a mountain range in New Mexico or Texas.",
                    "Visit(juandeonate, picurismountains) ::: Juan de Onate visited the Picuris Mountains.",
                    "Mine(hardingpegmatitemine) ∧ LocatedIn(hardingpegmatitemine, picurismountains) ∧ Donate(hardingpegmatitemine) ::: The Harding Pegmatite Mine, located in the Picuris Mountains, was donated.",
                    "∀x(MountainRange(x)→¬(In(x,y))) ::: There are no mountain ranges in Texas that have mines which have been donated."
                ],
                "First-Order-Logic Question": "∃x (MountainRange(x) ∧ In(x, texas) ∧ Visit(juandeonate, x)) ::: Juan de Onate visited a mountain range in Texas."
            },
            "diff": [
                {
                    "raw": "∀x (MountainRange(x) ∧ In(x, texas) → ¬∃y (Mine(y) ∧ LocatedIn(y, x) ∧ Donate(y))) ::: There are no mountain ranges in Texas that have mines which have been donated.",
                    "gram": "∀x(MountainRange(x)→¬(In(x,y))) ::: There are no mountain ranges in Texas that have mines which have been donated."
                }
            ],
            "answer": "C",
            "error_type":"",
            "grammar_answer": "A"
        },
        {
            "id": 122,
            "raw_prog": {
                "First-Order-Logic Rules": "∀x (TransportMultiplePassengers(x) → ¬Empty(x)) ::: If something can transport multiple passengers, then they are not empty.\n∀x (Airline(x) → TransportMultiplePassengers(x)) ::: All airlines can transport multiple passengers.\n∀x (Plane(x) → Empty(x)) ::: All planes are empty.\n∀x (Boeing707(x) → Plane(x)) ::: All Boeing 707s are planes.\n¬Airline(greyhound) → ¬∃y (Plane(y) ∧ Greyhound(y)) ::: If Greyhound is not an airline, then there are no Greyhound planes.\n",
                "First-Order-Logic Question": "Airline(greyhound) ::: Greyhound is an airline."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∀x (TransportMultiplePassengers(x) → ¬Empty(x)) ::: If something can transport multiple passengers, then they are not empty.\n∀x (Airline(x) → TransportMultiplePassengers(x)) ::: All airlines can transport multiple passengers.\n∀x (Plane(x) → Empty(x)) ::: All planes are empty.\n∀x (Boeing707(x) → Plane(x)) ::: All Boeing 707s are planes.\n¬Airline(greyhound) → (¬Plane(y) ∧ IsGreyhound(y)) ::: If Greyhound is not an airline, then there are no Greyhound planes.\n",
                "First-Order-Logic Question": "Airline(greyhound) ::: Greyhound is an airline."
            },
            "diff": [],
            "answer": "C",
            "error_type":"",
            "grammar_answer": "C"
        },
        {
            "id": 123,
            "raw_prog": {
                "First-Order-Logic Rules": "∀x (TransportMultiplePassengers(x) → ¬Empty(x)) ::: If something can transport multiple passengers, then they are not empty.\n∀x (Airline(x) → TransportMultiplePassengers(x)) ::: All airlines can transport multiple passengers.\n∀x (Plane(x) → Empty(x)) ::: All planes are empty.\n∀x (Boeing707(x) → Plane(x)) ::: All Boeing 707s are planes.\n¬Airline(greyhound) → ¬∃y (Greyhound(y) ∧ Plane(y)) ::: If Greyhound is not an airline, then there are no Greyhound planes.\n",
                "First-Order-Logic Question": "Boeing707(greyhound) ::: A Greyhound is a Boeing 707."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∀x (TransportMultiplePassengers(x) → ¬Empty(x)) ::: If something can transport multiple passengers, then they are not empty.\n∀x (Airline(x) → TransportMultiplePassengers(x)) ::: All airlines can transport multiple passengers.\n∀x (Plane(x) → Empty(x)) ::: All planes are empty.\n∀x (Boeing707(x) → Plane(x)) ::: All Boeing 707s are planes.\n¬Airline(x)→¬Plane(x) ::: If Greyhound is not an airline, then there are no Greyhound planes.\n",
                "First-Order-Logic Question": "Boeing707(greyhound) ::: A Greyhound is a Boeing 707."
            },
            "diff": [
                {
                    "raw": "¬Airline(greyhound) → ¬∃y (Greyhound(y) ∧ Plane(y)) ::: If Greyhound is not an airline, then there are no Greyhound planes.",
                    "gram": "¬Airline(x)→¬Plane(x) ::: If Greyhound is not an airline, then there are no Greyhound planes."
                }
            ],
            "answer": "B",
            "error_type":"",
            "grammar_answer": "B"
        },
        {
            "id": 124,
            "raw_prog": {
                "First-Order-Logic Rules": "∀x (TransportMultiplePassengers(x) → ¬Empty(x)) ::: If something can transport multiple passengers, then they are not empty.\n∀x (Airline(x) → TransportMultiplePassengers(x)) ::: All airlines can transport multiple passengers.\n∀x (Plane(x) → Empty(x)) ::: All planes are empty.\n∀x (Boeing707(x) → Plane(x)) ::: All Boeing 707s are planes.\n¬Airline(greyhound) → ¬∃y (Greyhound(y) ∧ Plane(y)) ::: If Greyhound is not an airline, then there are no Greyhound planes.\n",
                "First-Order-Logic Question": "¬Greyhound(boeing707) ::: A Greyhound is not a Boeing 707."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∀x (TransportMultiplePassengers(x) → ¬Empty(x)) ::: If something can transport multiple passengers, then they are not empty.\n∀x (Airline(x) → TransportMultiplePassengers(x)) ::: All airlines can transport multiple passengers.\n∀x (Plane(x) → Empty(x)) ::: All planes are empty.\nPlane(boeing707) ::: Boeing 707 is a plane.\n¬Airline(greyhound) → ¬Plane(greyhound) ::: If Greyhound is not an airline, then there are no Greyhound planes.",
                "First-Order-Logic Question": "¬IsGreyhound(boeing707) ::: A Greyhound is not a Boeing 707."
            },
            "diff": [],
            "answer": "A",
            "error_type":"",
            "grammar_answer": "C"
        },
        {
            "id": 143,
            "raw_prog": {
                "First-Order-Logic Rules": "∀x (BreedingBack(x) → ArtificiallySelected(x)) ::: Breeding back is a form of artificial selection by the deliberate selective breeding of domestic animals.\nBredBack(heck_cattle, aurochs) ∧ Resemble(heck_cattle, aurochs) ::: Heck cattle were bred-back in the 1920s to resemble the aurochs.\nAnimal(heck_cattle) ::: Heck cattle are animals.\nAnimal(aurochs) ::: Aurochs are animals.\n∃x ∃y (Animal(x) ∧ Animal(y) ∧ BredBack(x, y) ∧ Resemble(x, y) ∧ Extinct(y)) ::: Some animals to be bred-back resemble animals that are extinct.\n",
                "First-Order-Logic Question": "∃x (Animal(x) ∧ ArtificiallySelected(x) ∧ x = heck_cattle) ::: Some Heck cattle are artificially selected."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∀x (BreedingBack(x) → ArtificiallySelected(x)) ::: Breeding back is a form of artificial selection by the deliberate selective breeding of domestic animals.\nBredBack(heck_cattle, aurochs) ∧ Resemble(heck_cattle, aurochs) ::: Heck cattle were bred-back in the 1920s to resemble the aurochs.\nAnimal(heck_cattle) ::: Heck cattle are animals.\nAnimal(aurochs) ::: Aurochs are animals.\n∃x ∃y (Animal(x) ∧ Animal(y) ∧ BredBack(x, y) ∧ Resemble(x, y) ∧ Extinct(y)) ::: Some animals to be bred-back resemble animals that are extinct.\n",
                "First-Order-Logic Question": "∃x(Animal(x)∧ArtificiallySelected(x)∧Resemble(x,x)) ::: Some Heck cattle are artificially selected."
            },
            "diff": [
                {
                    "raw": "∃x (Animal(x) ∧ ArtificiallySelected(x) ∧ x = heck_cattle) ::: Some Heck cattle are artificially selected.",
                    "gram": "∃x(Animal(x)∧ArtificiallySelected(x)∧Resemble(x,x)) ::: Some Heck cattle are artificially selected."
                }
            ],
            "answer": "A",
            "error_type":"",
            "grammar_answer": "C"
        },
        {
            "id": 10,
            "raw_prog": {
                "First-Order-Logic Rules": "∀x (WildTurkey(x) → (EasternWildTurkey(x) ∨ OsceolaWildTurkey(x) ∨ GouldsWildTurkey(x) ∨ MerriamsWildTurkey(x) ∨ RioGrandeWildTurkey(x) ∨ OcellatedWildTurkey(x))) ::: There are six types of wild turkeys: Eastern wild turkey, Osceola wild turkey, Gould’s wild turkey, Merriam’s wild turkey, Rio Grande wild turkey, and Ocellated wild turkey.\nNot(tom, EasternWildTurkey(tom)) ::: Tom is not an Eastern wild turkey.\nNot(tom, OsceolaWildTurkey(tom)) ::: Tom is not an Osceola wild turkey.\nNot(tom, GouldsWildTurkey(tom)) ∧ Not(tom, MerriamsWildTurkey(tom)) ∧ Not(tom, RioGrandeWildTurkey(tom)) ::: Tom is also not a Gould's wild turkey, or a Merriam's wild turkey, or a Rio Grande wild turkey.\nWildTurkey(tom) ::: Tom is a wild turkey.\n",
                "First-Order-Logic Question": "EasternWildTurkey(tom) ::: Tom is an Eastern wild turkey."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∀x (WildTurkey(x) → (EasternWildTurkey(x) ∨ OsceolaWildTurkey(x) ∨ GouldsWildTurkey(x) ∨ MerriamsWildTurkey(x) ∨ RioGrandeWildTurkey(x) ∨ OcellatedWildTurkey(x))) ::: There are six types of wild turkeys: Eastern wild turkey, Osceola wild turkey, Gould’s wild turkey, Merriam’s wild turkey, Rio Grande wild turkey, and Ocellated wild turkey.\nNot(x,y)→(EasternWildTurkey(x)→¬OsceolaWildTurkey(x)) ::: Tom is not an Eastern wild turkey.\nNot(x,y)→OsceolaWildTurkey(x) ::: Tom is not an Osceola wild turkey.\nNot(x,y)→(WildTurkey(x)∧¬EasternWildTurkey(x)) ::: Tom is also not a Gould's wild turkey, or a Merriam's wild turkey, or a Rio Grande wild turkey.\nWildTurkey(tom) ::: Tom is a wild turkey.\n",
                "First-Order-Logic Question": "EasternWildTurkey(tom) ::: Tom is an Eastern wild turkey."
            },
            "diff": [
                {
                    "raw": "Not(tom, EasternWildTurkey(tom)) ::: Tom is not an Eastern wild turkey.",
                    "gram": "Not(x,y)→(EasternWildTurkey(x)→¬OsceolaWildTurkey(x)) ::: Tom is not an Eastern wild turkey."
                },
                {
                    "raw": "Not(tom, OsceolaWildTurkey(tom)) ::: Tom is not an Osceola wild turkey.",
                    "gram": "Not(x,y)→OsceolaWildTurkey(x) ::: Tom is not an Osceola wild turkey."
                },
                {
                    "raw": "Not(tom, GouldsWildTurkey(tom)) ∧ Not(tom, MerriamsWildTurkey(tom)) ∧ Not(tom, RioGrandeWildTurkey(tom)) ::: Tom is also not a Gould's wild turkey, or a Merriam's wild turkey, or a Rio Grande wild turkey.",
                    "gram": "Not(x,y)→(WildTurkey(x)∧¬EasternWildTurkey(x)) ::: Tom is also not a Gould's wild turkey, or a Merriam's wild turkey, or a Rio Grande wild turkey."
                }
            ],
            "answer": "B",
            "error_type":"",
            "grammar_answer": "C"
        },
        {
            "id": 47,
            "raw_prog": {
                "First-Order-Logic Rules": [
                    "Season(spring) ∧ Season(summer) ∧ Season(fall) ∧ Season(winter) ::: There are four seasons in a year: Spring, Summer, Fall, and Winter.",
                    "∀x (Student(x) ∧ WantsLongVacation(x) → LovesMost(x, summer)) ::: All students who want to have a long vacation love summer the most.",
                    "FavoriteSeason(emma, summer) ::: Emma's favorite season is summer.",
                    "∀x (FavoriteSeason(mia, x) → x ≠ summer) ::: Mia's favorite season is not the same as Emma's.",
                    "WantsLongVacation(james) ::: James wants to have a long vacation."
                ],
                "First-Order-Logic Question": "FavoriteSeason(james, fall) ::: James's favorite season is fall."
            },
            "gram_prog": {
                "First-Order-Logic Rules": [
                    "Season(spring) ∧ Season(summer) ∧ Season(fall) ∧ Season(winter) ::: There are four seasons in a year: Spring, Summer, Fall, and Winter.",
                    "∀x (Student(x) ∧ WantsLongVacation(x) → LovesMost(x, summer)) ::: All students who want to have a long vacation love summer the most.",
                    "FavoriteSeason(emma, summer) ::: Emma's favorite season is summer.",
                    "∀x(FavoriteSeason(x,y)→¬(IsSummer(y))) ::: Mia's favorite season is not the same as Emma's.",
                    "WantsLongVacation(james) ::: James wants to have a long vacation."
                ],
                "First-Order-Logic Question": "FavoriteSeason(james, fall) ::: James's favorite season is fall."
            },
            "diff": [
                {
                    "raw": "∀x (FavoriteSeason(mia, x) → x ≠ summer) ::: Mia's favorite season is not the same as Emma's.",
                    "gram": "∀x(FavoriteSeason(x,y)→¬(IsSummer(y))) ::: Mia's favorite season is not the same as Emma's."
                }
            ],
            "answer": "C",
            "error_type":"",
            "grammar_answer": "C"
        },
        {
            "id": 53,
            "raw_prog": {
                "First-Order-Logic Rules": "∀x (RomanceLanguage(x) → IndoEuropeanLanguage(x)) ::: All Romance languages are Indo-European languages.\nLanguageFamily(romanceLanguages) ::: The Romance languages are a language family.\n∀x ∀y (LanguageFamily(f) ∧ RomanceLanguage(x) ∧ RomanceLanguage(y) → Related(x, y)) ::: All languages within a language family are related to each other.\nRomanceLanguage(french) ∧ RomanceLanguage(spanish) ::: French and Spanish are both Romance languages.\nRelated(german, spanish) ::: German is related to Spanish.\n∀x (Basque(x) → ¬∃y (Related(x, y))) ::: Basque is not related to any other language.\n",
                "First-Order-Logic Question": "RomanceLanguage(german) ::: German is a Romance language."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∀x (RomanceLanguage(x) → IndoEuropeanLanguage(x)) ::: All Romance languages are Indo-European languages.\nLanguageFamily(romanceLanguages) ::: The Romance languages are a language family.\n∀x ∀y (LanguageFamily(f) ∧ RomanceLanguage(x) ∧ RomanceLanguage(y) → Related(x, y)) ::: All languages within a language family are related to each other.\nRomanceLanguage(french) ∧ RomanceLanguage(spanish) ::: French and Spanish are both Romance languages.\nRelated(german, spanish) ::: German is related to Spanish.\n∀x(Basque(x)→¬(Related(x,y))) ::: Basque is not related to any other language.\n",
                "First-Order-Logic Question": "RomanceLanguage(german) ::: German is a Romance language."
            },
            "diff": [],
            "answer": "C",
            "error_type":"",
            "grammar_answer": "C"
        },
        {
            "id": 94,
            "raw_prog": {
                "First-Order-Logic Rules": [
                    "∃x (ManagedBuilding(x) ∧ Pet(y) ∧ MoveInAllowed(tom, x, y)) ::: Pets are allowed in some managed buildings.",
                    "∀x (ManagedBuilding(x) → DepositRequired(x)) ::: A deposit is required to rent an apartment in a managed building.",
                    "∀x ∀y (SecurityDeposit(x, y) → (y = Rent(x) ∨ y > Rent(x))) ::: The security deposit can be either equal to one month's rent or more.",
                    "Cat(fluffy) ∧ Owner(tom, fluffy) ::: Fluffy is Tom's cat.",
                    "∀x (Cat(x) → Pet(x)) ::: Cats are pets.",
                    "ManagedBuilding(olivegarden) ::: The Olive Garden is a managed building.",
                    "Rent(olivegarden, 2000) ::: The monthly rent at the Olive Garden is $2000.",
                    "∀x ∀y ∀z (RentApartment(x, y) ↔ (MoveInAllowed(x, y, z) ∧ SecurityDeposit(y, d) ∧ d ≤ 1500)) ::: Tom will rent an apartment in a managed building if and only if he is allowed to move in with Fluffy, and the security deposit is no more than $1500.",
                    "2000 > 1500 ::: 2000$ is more than $1500."
                ],
                "First-Order-Logic Question": [
                    "MoveInAllowed(tom, olivegarden, fluffy) ::: Tom is allowed to move in an apartment in The Olive Garden with Fluffy."
                ]
            },
            "gram_prog": {
                "First-Order-Logic Rules": [
                    "∃x (ManagedBuilding(x) ∧ Pet(y) ∧ MoveInAllowed(tom, x, y)) ::: Pets are allowed in some managed buildings.",
                    "∀x (ManagedBuilding(x) → DepositRequired(x)) ::: A deposit is required to rent an apartment in a managed building.",
                    "∀x∀y(SecurityDeposit(x,y)→(Rent(x,y))) ::: The security deposit can be either equal to one month's rent or more.",
                    "Cat(fluffy) ∧ Owner(tom, fluffy) ::: Fluffy is Tom's cat.",
                    "∀x (Cat(x) → Pet(x)) ::: Cats are pets.",
                    "ManagedBuilding(olivegarden) ::: The Olive Garden is a managed building.",
                    "Rent(olivegarden, 2000) ::: The monthly rent at the Olive Garden is $2000.",
                    "∀x∀y∀z(MoveInAllowed(x,y,z)→(SecurityDeposit(y,z))) ::: Tom will rent an apartment in a managed building if and only if he is allowed to move in with Fluffy, and the security deposit is no more than $1500.",
                    "DepositRequired(x)→SecurityDeposit(x,y) ::: 2000$ is more than $1500."
                ],
                "First-Order-Logic Question": [
                    "MoveInAllowed(tom, olivegarden, fluffy) ::: Tom is allowed to move in an apartment in The Olive Garden with Fluffy."
                ]
            },
            "diff": [
                {
                    "raw": "∀x ∀y (SecurityDeposit(x, y) → (y = Rent(x) ∨ y > Rent(x))) ::: The security deposit can be either equal to one month's rent or more.",
                    "gram": "∀x∀y(SecurityDeposit(x,y)→(Rent(x,y))) ::: The security deposit can be either equal to one month's rent or more."
                },
                {
                    "raw": "∀x ∀y ∀z (RentApartment(x, y) ↔ (MoveInAllowed(x, y, z) ∧ SecurityDeposit(y, d) ∧ d ≤ 1500)) ::: Tom will rent an apartment in a managed building if and only if he is allowed to move in with Fluffy, and the security deposit is no more than $1500.",
                    "gram": "∀x∀y∀z(MoveInAllowed(x,y,z)→(SecurityDeposit(y,z))) ::: Tom will rent an apartment in a managed building if and only if he is allowed to move in with Fluffy, and the security deposit is no more than $1500."
                },
                {
                    "raw": "2000 > 1500 ::: 2000$ is more than $1500.",
                    "gram": "DepositRequired(x)→SecurityDeposit(x,y) ::: 2000$ is more than $1500."
                }
            ],
            "answer": "C",
            "error_type":"",
            "grammar_answer": "C"
        },
        {
            "id": 114,
            "raw_prog": {
                "First-Order-Logic Rules": [
                    "MountainRange(picurismountains) ∧ (In(picurismountains, newmexico) ⊕ In(picurismountains, texas)) ::: The Picuris Mountains are a mountain range in New Mexico or Texas.",
                    "Visit(juandeonate, picurismountains) ::: Juan de Onate visited the Picuris Mountains.",
                    "Mine(hardingpegmatitemine) ∧ In(hardingpegmatitemine, picurismountains) ∧ Donate(hardingpegmatitemine) ::: The Harding Pegmatite Mine, located in the Picuris Mountains, was donated.",
                    "∀x (MountainRange(x) ∧ In(x, texas) → ¬∃y (Mine(y) ∧ In(y, x) ∧ Donate(y))) ::: There are no mountain ranges in Texas that have mines which have been donated."
                ],
                "First-Order-Logic Question": [
                    "¬In(hardingpegmatitemine, newmexico) ::: The Harding Pegmatite Mine is not located in a mountain range in New Mexico."
                ]
            },
            "gram_prog": {
                "First-Order-Logic Rules": [
                    "MountainRange(picurismountains) ∧ (In(picurismountains, newmexico) ⊕ In(picurismountains, texas)) ::: The Picuris Mountains are a mountain range in New Mexico or Texas.",
                    "Visit(juandeonate, picurismountains) ::: Juan de Onate visited the Picuris Mountains.",
                    "Mine(hardingpegmatitemine) ∧ In(hardingpegmatitemine, picurismountains) ∧ Donate(hardingpegmatitemine) ::: The Harding Pegmatite Mine, located in the Picuris Mountains, was donated.",
                    "∀x(MountainRange(x)→¬In(x,y))∧¬In(x,y)→Donate(x) ::: There are no mountain ranges in Texas that have mines which have been donated."
                ],
                "First-Order-Logic Question": [
                    "¬In(hardingpegmatitemine, newmexico) ::: The Harding Pegmatite Mine is not located in a mountain range in New Mexico."
                ]
            },
            "diff": [
                {
                    "raw": "∀x (MountainRange(x) ∧ In(x, texas) → ¬∃y (Mine(y) ∧ In(y, x) ∧ Donate(y))) ::: There are no mountain ranges in Texas that have mines which have been donated.",
                    "gram": "∀x(MountainRange(x)→¬In(x,y))∧¬In(x,y)→Donate(x) ::: There are no mountain ranges in Texas that have mines which have been donated."
                }
            ],
            "answer": "B",
            "error_type":"",
            "grammar_answer": "C"
        },
        {
            "id": 38,
            "raw_prog": {
                "First-Order-Logic Rules": [
                    "MusicPiece(symphonyNo9) ::: Symphony No. 9 is a music piece.",
                    "∀x (Composer(x) → ∃y (Write(x, y) ∧ MusicPiece(y))) ::: Composers write music pieces.",
                    "Write(beethoven, symphonyNo9) ∧ Composer(beethoven) ::: Beethoven wrote Symphony No. 9.",
                    "Premiere(viennaMusicSociety, symphonyNo9) ::: Vienna Music Society premiered Symphony No. 9.",
                    "Orchestra(viennaMusicSociety) ::: Vienna Music Society is an orchestra.",
                    "Lead(beethoven, viennaMusicSociety) ::: Beethoven leads the Vienna Music Society.",
                    "∀x (Orchestra(x) → ∃y (Lead(y, x) ∧ Conductor(y))) ::: Orchestras are led by conductors."
                ],
                "First-Order-Logic Question": "Not(Conductor(beethoven)) ::: Beethoven is not a conductor."
            },
            "gram_prog": {
                "First-Order-Logic Rules": [
                    "MusicPiece(symphonyNo9) ::: Symphony No. 9 is a music piece.",
                    "∀x (Composer(x) → ∃y (Write(x, y) ∧ MusicPiece(y))) ::: Composers write music pieces.",
                    "Write(beethoven, symphonyNo9) ∧ Composer(beethoven) ::: Beethoven wrote Symphony No. 9.",
                    "Premiere(viennaMusicSociety, symphonyNo9) ::: Vienna Music Society premiered Symphony No. 9.",
                    "Orchestra(viennaMusicSociety) ::: Vienna Music Society is an orchestra.",
                    "Lead(beethoven, viennaMusicSociety) ::: Beethoven leads the Vienna Music Society.",
                    "∀x (Orchestra(x) → ∃y (Lead(y, x) ∧ Conductor(y))) ::: Orchestras are led by conductors."
                ],
                "First-Order-Logic Question": "Not(x)→Composer(x)∨Write(x,y)∨Premiere(x,y)∨Orchestra(x)∨Lead(x,y)∨Conductor(x) ::: Beethoven is not a conductor."
            },
            "diff": [
                {
                    "raw": "Not(Conductor(beethoven)) ::: Beethoven is not a conductor.",
                    "gram": "Not(x)→Composer(x)∨Write(x,y)∨Premiere(x,y)∨Orchestra(x)∨Lead(x,y)∨Conductor(x) ::: Beethoven is not a conductor."
                }
            ],
            "answer": "B",
            "error_type":"",
            "grammar_answer": "C"
        },
        {
            "id": 40,
            "raw_prog": {
                "First-Order-Logic Rules": "∀x (ZahaHadid(x) → Timeless(x)) ::: All of Zaha Hadid's design styles are timeless.\n∀x (MassProduct(x) → ¬Timeless(x)) ::: No mass product design is timeless.\n∀x (ZahaHadid(x) ∨ KellyWearstler(x)) ::: Either Zaha Hadid's design style or Kelly Wearstler's design style.\n∀x (KellyWearstler(x) → Evocative(x)) ::: All of Kelly Wearstler's design styles are evocative.\n∀x (KellyWearstler(x) → Dreamy(x)) ::: All of Kelly Wearstler's design styles are dreamy.\n∀x (Timeless(Max(x)) → (MassProduct(Max(x)) ∧ Evocative(Max(x)))) ::: If a design by Max is timeless, then a design by Max is a mass product design and evocative.\n",
                "First-Order-Logic Question": "(Evocative(Max(x)) ∧ Dreamy(Max(x))) ::: A design by Max is evocative and dreamy."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∀x (ZahaHadid(x) → Timeless(x)) ::: All of Zaha Hadid's design styles are timeless.\n∀x (MassProduct(x) → ¬Timeless(x)) ::: No mass product design is timeless.\n∀x (ZahaHadid(x) ∨ KellyWearstler(x)) ::: Either Zaha Hadid's design style or Kelly Wearstler's design style.\n∀x (KellyWearstler(x) → Evocative(x)) ::: All of Kelly Wearstler's design styles are evocative.\n∀x (KellyWearstler(x) → Dreamy(x)) ::: All of Kelly Wearstler's design styles are dreamy.\n∀x(Timeless(x)→(MassProduct(x))) ::: If a design by Max is timeless, then a design by Max is a mass product design and evocative.\n",
                "First-Order-Logic Question": "DesignBy(x,y)→(Evocative(x)∧Dreamy(x)) ::: A design by Max is evocative and dreamy."
            },
            "diff": [
                {
                    "raw": "∀x (Timeless(Max(x)) → (MassProduct(Max(x)) ∧ Evocative(Max(x)))) ::: If a design by Max is timeless, then a design by Max is a mass product design and evocative.",
                    "gram": "∀x(Timeless(x)→(MassProduct(x))) ::: If a design by Max is timeless, then a design by Max is a mass product design and evocative."
                },
                {
                    "raw": "(Evocative(Max(x)) ∧ Dreamy(Max(x))) ::: A design by Max is evocative and dreamy.",
                    "gram": "DesignBy(x,y)→(Evocative(x)∧Dreamy(x)) ::: A design by Max is evocative and dreamy."
                }
            ],
            "answer": "A",
            "error_type":"",
            "grammar_answer": "A"
        },
        {
            "id": 49,
            "raw_prog": {
                "First-Order-Logic Rules": "∀x (Digital(x) → ¬Analog(x)) ::: No digital media are analog.\n∀x (PrintedText(x) → Analog(x)) ::: Every printed text is analog.\n∀x (StreamingService(x) → Digital(x)) ::: All streaming services are digital.\n∀x (HardcoverBook(x) → PrintedText(x)) ::: If an object is a hardcover book then it is printed text.\n∀x (StreamingService(x) ∧ Object1984(x) → HardcoverBook(x)) ::: If 1984 is a streaming service, then 1984 is a hardcover book.\n",
                "First-Order-Logic Question": "PrintedText(Object1984(x)) ::: 1984 is printed text."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∀x (Digital(x) → ¬Analog(x)) ::: No digital media are analog.\n∀x (PrintedText(x) → Analog(x)) ::: Every printed text is analog.\n∀x (StreamingService(x) → Digital(x)) ::: All streaming services are digital.\n∀x (HardcoverBook(x) → PrintedText(x)) ::: If an object is a hardcover book then it is printed text.\n∀x (StreamingService(x) ∧ Object1984(x) → HardcoverBook(x)) ::: If 1984 is a streaming service, then 1984 is a hardcover book.\n",
                "First-Order-Logic Question": "PrintedText(x) ::: 1984 is printed text."
            },
            "diff": [
                {
                    "raw": "PrintedText(Object1984(x)) ::: 1984 is printed text.",
                    "gram": "PrintedText(x) ::: 1984 is printed text."
                }
            ],
            "answer": "C",
            "error_type":"",
            "grammar_answer": "C"
        }
    ],
    "gcd_llama-2-13b_3.5": [
        {
            "id": 2,
            "raw_prog": {
                "First-Order-Logic Rules": "∀x (Perform(x) → (Attend(x) ∧ Engaged(x))) ::: If people perform in school talent shows often, then they attend and are very engaged with school events.\n∀x ((Perform(x) ∨ (Inactive(x) ∧ Disinterested(x))) ::: People either perform in school talent shows often or are inactive and disinterested members of their community.\n∀x (Chaperone(x) → ¬Student(x)) ::: If people chaperone high school dances, then they are not students who attend the school.\n∀x ((Inactive(x) ∧ Disinterested(x)) → Chaperone(x)) ::: All people who are inactive and disinterested members of their community chaperone high school dances.\n∀x ((Young(x) ∨ Teenager(x)) ∧ Wish(x) → Student(x)) ::: All young children and teenagers who wish to further their academic careers and educational opportunities are students who attend the school.\n¬((Attend(Bonnie) ∧ Engaged(Bonnie)) ⊕ Student(Bonnie)) ::: Bonnie either both attends and is very engaged with school events and is a student who attends the school, or she neither attends and is very engaged with school events nor is a student who attends the school.\n",
                "First-Order-Logic Question": "((Chaperone(Bonnie) ∨ ¬Chaperone(Bonnie) ∧ Perform(Bonnie)) → ((Young(Bonnie) ∨ Teenager(Bonnie)) ∧ Wish(Bonnie) ∧ Inactive(Bonnie) ∧ Disinterested(Bonnie))) ::: If Bonnie either chaperones high school dances or, if she does not, she performs in school talent shows often, then Bonnie is both a young child or teenager who wishes to further her academic career and educational opportunities and an inactive and disinterested member of the community."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∀x (Perform(x) → (Attend(x) ∧ Engaged(x))) ::: If people perform in school talent shows often, then they attend and are very engaged with school events.\n∀x((Perform(x)∨Inactive(x))) ::: People either perform in school talent shows often or are inactive and disinterested members of their community.\n∀x (Chaperone(x) → ¬Student(x)) ::: If people chaperone high school dances, then they are not students who attend the school.\n∀x ((Inactive(x) ∧ Disinterested(x)) → Chaperone(x)) ::: All people who are inactive and disinterested members of their community chaperone high school dances.\n∀x ((Young(x) ∨ Teenager(x)) ∧ Wish(x) → Student(x)) ::: All young children and teenagers who wish to further their academic careers and educational opportunities are students who attend the school.\n¬((Attend(Bonnie) ∧ Engaged(Bonnie)) ⊕ Student(Bonnie)) ::: Bonnie either both attends and is very engaged with school events and is a student who attends the school, or she neither attends and is very engaged with school events nor is a student who attends the school.\n",
                "First-Order-Logic Question": "((Chaperone(Bonnie) ∨ ¬Chaperone(Bonnie) ∧ Perform(Bonnie)) → ((Young(Bonnie) ∨ Teenager(Bonnie)) ∧ Wish(Bonnie) ∧ Inactive(Bonnie) ∧ Disinterested(Bonnie))) ::: If Bonnie either chaperones high school dances or, if she does not, she performs in school talent shows often, then Bonnie is both a young child or teenager who wishes to further her academic career and educational opportunities and an inactive and disinterested member of the community."
            },
            "diff": [
                {
                    "raw": "∀x ((Perform(x) ∨ (Inactive(x) ∧ Disinterested(x))) ::: People either perform in school talent shows often or are inactive and disinterested members of their community.",
                    "gram": "∀x((Perform(x)∨Inactive(x))) ::: People either perform in school talent shows often or are inactive and disinterested members of their community."
                }
            ],
            "answer": "B",
            "error_type":"",
            "grammar_answer": "C"
        },
        {
            "id": 3,
            "raw_prog": {
                "First-Order-Logic Rules": "∀x∀y (Employee(x) ∧ ScheduleMeeting(x, y) → AppearInCompany(x)) ::: All employees who schedule a meeting with their customers will appear in the company today. \n∀x (HasLunchInCompany(x) → ScheduleMeeting(x, Customer(x))) ::: Everyone who has lunch in the company schedules meetings with their customers. \n∀x (HasLunchInCompany(x) ∨ HasLunchAtHome(x)) ::: Employees will either have lunch in the company or have lunch at home. \n∀x (HasLunchAtHome(x) → WorkRemotelyFromHome(x)) ::: If an employee has lunch at home, then he/she is working remotely from home. \n∀x (InOtherCountries(x) → WorkRemotelyFromHome(x)) ::: All employees who are in other countries work remotely from home. \n∀x (Manager(x) → ¬WorkRemotelyFromHome(x)) ::: No managers work remotely from home. \n(Employee(james) ∧ AppearInCompany(james)) ⊕ (¬Manager(james) ∧ ¬AppearInCompany(james)) ::: James is either a manager and appears in the company today or neither a manager nor appears in the company today.",
                "First-Order-Logic Question": "HasLunchInCompany(james) ::: James has lunch in the company."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∀x∀y (Employee(x) ∧ ScheduleMeeting(x, y) → AppearInCompany(x)) ::: All employees who schedule a meeting with their customers will appear in the company today. \n∀x(AppearInCompany(x)→ScheduleMeeting(x,x)) ::: Everyone who has lunch in the company schedules meetings with their customers. \n∀x (HasLunchInCompany(x) ∨ HasLunchAtHome(x)) ::: Employees will either have lunch in the company or have lunch at home. \n∀x (HasLunchAtHome(x) → WorkRemotelyFromHome(x)) ::: If an employee has lunch at home, then he/she is working remotely from home. \n∀x (InOtherCountries(x) → WorkRemotelyFromHome(x)) ::: All employees who are in other countries work remotely from home. \n∀x (Manager(x) → ¬WorkRemotelyFromHome(x)) ::: No managers work remotely from home. \n(Employee(james) ∧ AppearInCompany(james)) ⊕ (¬Manager(james) ∧ ¬AppearInCompany(james)) ::: James is either a manager and appears in the company today or neither a manager nor appears in the company today.",
                "First-Order-Logic Question": "HasLunchInCompany(james) ::: James has lunch in the company."
            },
            "diff": [
                {
                    "raw": "∀x (HasLunchInCompany(x) → ScheduleMeeting(x, Customer(x))) ::: Everyone who has lunch in the company schedules meetings with their customers. ",
                    "gram": "∀x(AppearInCompany(x)→ScheduleMeeting(x,x)) ::: Everyone who has lunch in the company schedules meetings with their customers. "
                }
            ],
            "answer": "C",
            "error_type":"",
            "grammar_answer": "C"
        },
        {
            "id": 4,
            "raw_prog": {
                "First-Order-Logic Rules": "∀x∀y (Schedule(x, y) → Appear(x)) ::: All employees who schedule a meeting with their customers will appear in the company today. \n∀x (Lunch(x) → ∃y (Schedule(x, y))) ::: Everyone who has lunch in the company schedules meetings with their customers. \n∀x (Lunch(x) ∨ Home(x)) ::: Employees will either have lunch in the company or have lunch at home. \n∀x (Home(x) → Remote(x)) ::: If an employee has lunch at home, then he/she is working remotely from home. \n∀x (Work(x, y) → Remote(x)) ::: All employees who are in other countries work remotely from home. \n∀x (Manager(x) → ¬Remote(x)) ::: No managers work remotely from home. \n(Manager(james) ∧ Appear(james)) ⊕ (¬Manager(james) ∧ ¬Appear(james)) ::: James is either a manager and appears in the company today or neither a manager nor appears in the company today.",
                "First-Order-Logic Question": "¬Lunch(james) ::: James does not have lunch in the company."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∀x∀y (Schedule(x, y) → Appear(x)) ::: All employees who schedule a meeting with their customers will appear in the company today. \n∀x (Lunch(x) → ∃y (Schedule(x, y))) ::: Everyone who has lunch in the company schedules meetings with their customers. \n∀x (Lunch(x) ∨ Home(x)) ::: Employees will either have lunch in the company or have lunch at home. \n∀x (Home(x) → Remote(x)) ::: If an employee has lunch at home, then he/she is working remotely from home. \n∀x (Work(x, y) → Remote(x)) ::: All employees who are in other countries work remotely from home. \n∀x (Manager(x) → ¬Remote(x)) ::: No managers work remotely from home. \n(Manager(james) ∧ Appear(james)) ⊕ (¬Manager(james) ∧ ¬Appear(james)) ::: James is either a manager and appears in the company today or neither a manager nor appears in the company today.",
                "First-Order-Logic Question": "¬Lunch(james) ::: James does not have lunch in the company."
            },
            "diff": [],
            "answer": "C",
            "error_type":"",
            "grammar_answer": "C"
        },
        {
            "id": 43,
            "raw_prog": {
                "First-Order-Logic Rules": "∀x (RankedHighly(x) → Active(x)) ::: If a player is ranked highly by the Women's Tennis Association, then they are among the most active players in major tennis. \n∀x (LostTo(x, IgaSwiatek) → RankedHighly(x)) ::: Everyone who lost to Iga Swiatek is ranked highly by the Women's Tennis Association. \n∀x (Female(x) ∧ At(x, RolandGarros) → LostTo(x, IgaSwiatek)) ::: All female tennis players at Roland Garros 2022 lost to Iga Swiatek. \n(Female(x) ∧ At(x, RolandGarros)) ∨ (Male(x) ∧ At(x, RolandGarros)) ::: Either female tennis players at Roland Garros 2022 or male tennis players at Roland Garros 2022. \n∀x (Male(x) ∧ At(x, RolandGarros) → LostToRafaelNadal(x)) ::: All male tennis players at Roland Garros 2022 lost to Rafael Nadal. \n(RankedHighly(CocoGauff) ∨ LostTo(CocoGauff, RafaelNadal)) → ¬(Male(CocoGauff) ∧ At(CocoGauff, RolandGarros)) ::: If Coco Gauff is a player who is ranked highly by the Women's Tennis Association or a player who lost to Rafael Nadal, then Coco Gauff is not a male tennis player at Roland Garros 2022. \n",
                "First-Order-Logic Question": "LostTo(CocoGauff, RafaelNadal) ::: Coco Gauff has lost to Rafael Nadal."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∀x (RankedHighly(x) → Active(x)) ::: If a player is ranked highly by the Women's Tennis Association, then they are among the most active players in major tennis. \n∀x (LostTo(x, IgaSwiatek) → RankedHighly(x)) ::: Everyone who lost to Iga Swiatek is ranked highly by the Women's Tennis Association. \n∀x (Female(x) ∧ At(x, RolandGarros) → LostTo(x, IgaSwiatek)) ::: All female tennis players at Roland Garros 2022 lost to Iga Swiatek. \n(Female(x) ∧ At(x, RolandGarros)) ∨ (Male(x) ∧ At(x, RolandGarros)) ::: Either female tennis players at Roland Garros 2022 or male tennis players at Roland Garros 2022. \n∀x (Male(x) ∧ At(x, RolandGarros) → LostToRafaelNadal(x)) ::: All male tennis players at Roland Garros 2022 lost to Rafael Nadal. \n(RankedHighly(CocoGauff) ∨ LostTo(CocoGauff, RafaelNadal)) → ¬(Male(CocoGauff) ∧ At(CocoGauff, RolandGarros)) ::: If Coco Gauff is a player who is ranked highly by the Women's Tennis Association or a player who lost to Rafael Nadal, then Coco Gauff is not a male tennis player at Roland Garros 2022. \n",
                "First-Order-Logic Question": "LostTo(CocoGauff, RafaelNadal) ::: Coco Gauff has lost to Rafael Nadal."
            },
            "diff": [],
            "answer": "C",
            "error_type":"",
            "grammar_answer": "C"
        },
        {
            "id": 48,
            "raw_prog": {
                "First-Order-Logic Rules": "Season(spring) ∧ Season(summer) ∧ Season(fall) ∧ Season(winter) ::: There are four seasons in a year: Spring, Summer, Fall, and Winter. \n∀x (Student(x) ∧ WantLongVacation(x) → Love(x, summer)) ::: All students who want to have a long vacation love summer the most. \nFavoriteSeason(emma, summer) ::: Emma's favorite season is summer. \n∀x (FavoriteSeason(mia, y) → ¬FavoriteSeason(emma, y)) ::: Mia's favorite season is not the same as Emma's. \nWantLongVacation(james) ::: James wants to have a long vacation.",
                "First-Order-Logic Question": "FavoriteSeason(mia, spring) ::: Mia's favorite season is spring."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "Season(spring) ∧ Season(summer) ∧ Season(fall) ∧ Season(winter) ::: There are four seasons in a year: Spring, Summer, Fall, and Winter. \n∀x (Student(x) ∧ WantLongVacation(x) → Love(x, summer)) ::: All students who want to have a long vacation love summer the most. \nFavoriteSeason(emma, summer) ::: Emma's favorite season is summer. \n∀x (FavoriteSeason(mia, y) → ¬FavoriteSeason(emma, y)) ::: Mia's favorite season is not the same as Emma's. \nWantLongVacation(james) ::: James wants to have a long vacation.",
                "First-Order-Logic Question": "FavoriteSeason(mia, spring) ::: Mia's favorite season is spring."
            },
            "diff": [],
            "answer": "C",
            "error_type":"",
            "grammar_answer": "C"
        },
        {
            "id": 57,
            "raw_prog": {
                "First-Order-Logic Rules": "Striker(robertlewandowski) ::: Robert Lewandowski is a striker.\n∀x (Striker(x) → SoccerPlayer(x)) ::: Strikers are soccer players.\nLeftTeam(robertlewandowski, bayernmunchen) ::: Robert Lewandowski left Bayern Munchen.\n∀x∀y (LeftTeam(x, y) → ¬PlayFor(x, y)) ::: If a player left a team they no longer play for that team.",
                "First-Order-Logic Question": "Star(robertlewandowski) ::: Robert Lewandowski is a star."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "Striker(robertlewandowski) ::: Robert Lewandowski is a striker.\n∀x (Striker(x) → SoccerPlayer(x)) ::: Strikers are soccer players.\nLeftTeam(robertlewandowski, bayernmunchen) ::: Robert Lewandowski left Bayern Munchen.\n∀x∀y (LeftTeam(x, y) → ¬PlayFor(x, y)) ::: If a player left a team they no longer play for that team.",
                "First-Order-Logic Question": "Star(robertlewandowski) ::: Robert Lewandowski is a star."
            },
            "diff": [],
            "answer": "C",
            "error_type":"",
            "grammar_answer": "C"
        },
        {
            "id": 59,
            "raw_prog": {
                "First-Order-Logic Rules": "City(billings) ∧ In(billings, montana) ::: Billings is a city in Montana.\nInclude(montana, butte) ∧ Include(montana, helena) ∧ Include(montana, missoula) ::: Montana includes the cities of Butte, Helena, and Missoula.\nCity(white_sulphur_springs) ∧ City(butte) ∧ SameState(white_sulphur_springs, butte) ::: White Sulphur Springs and Butte are cities in the same state.\n¬In(pierre, montana) ::: The city of Pierre is not in Montana.\n∀x (City(x) ∧ In(x, butte) → ¬In(x, pierre)) ::: Any city in Butte is not in Pierre.\n",
                "First-Order-Logic Question": "SameState(pierre, bismarck) ::: Pierre and Bismarck are in the same state."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "City(billings) ∧ In(billings, montana) ::: Billings is a city in Montana.\nInclude(montana, butte) ∧ Include(montana, helena) ∧ Include(montana, missoula) ::: Montana includes the cities of Butte, Helena, and Missoula.\nCity(white_sulphur_springs) ∧ City(butte) ∧ SameState(white_sulphur_springs, butte) ::: White Sulphur Springs and Butte are cities in the same state.\n¬In(pierre, montana) ::: The city of Pierre is not in Montana.\n∀x (City(x) ∧ In(x, butte) → ¬In(x, pierre)) ::: Any city in Butte is not in Pierre.\n",
                "First-Order-Logic Question": "SameState(pierre, bismarck) ::: Pierre and Bismarck are in the same state."
            },
            "diff": [],
            "answer": "C",
            "error_type":"",
            "grammar_answer": "C"
        },
        {
            "id": 61,
            "raw_prog": {
                "First-Order-Logic Rules": "∀x (InternationalStudent(x) ∧ InUS(x) → (HasVisa(x, F1Visa) ∨ HasVisa(x, J1Visa))) ::: International students in US have either an F1 visa or a J1 visa. \n∀x (InternationalStudent(x) ∧ InUS(x) ∧ HasVisa(x, F1Visa) ∧ WorkInUS(x) → NeedsToApplyFor(x, CPT)) ::: An international student in US with an F1 visa needs to apply for CPT or OPT if the student wants to work in the US. \nInternationalStudent(mike) ::: Mike is an international student. \nWorkInUS(mike) ∧ NeedsToApplyFor(mike, CPT) ::: Mike needs to apply for CPT if he wants to work in the US.",
                "First-Order-Logic Question": "HasVisa(mike, F1Visa) ::: Mike has an F1 visa."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∀x (InternationalStudent(x) ∧ InUS(x) → (HasVisa(x, F1Visa) ∨ HasVisa(x, J1Visa))) ::: International students in US have either an F1 visa or a J1 visa. \n∀x (InternationalStudent(x) ∧ InUS(x) ∧ HasVisa(x, F1Visa) ∧ WorkInUS(x) → NeedsToApplyFor(x, CPT)) ::: An international student in US with an F1 visa needs to apply for CPT or OPT if the student wants to work in the US. \nInternationalStudent(mike) ::: Mike is an international student. \nWorkInUS(mike) ∧ NeedsToApplyFor(mike, CPT) ::: Mike needs to apply for CPT if he wants to work in the US.",
                "First-Order-Logic Question": "HasVisa(mike, F1Visa) ::: Mike has an F1 visa."
            },
            "diff": [],
            "answer": "C",
            "error_type":"",
            "grammar_answer": "C"
        },
        {
            "id": 73,
            "raw_prog": {
                "First-Order-Logic Rules": "∀x (GrowthStock(x) → Volatile(x)) ::: All growth stocks of companies are volatile.\n∀x (Volatile(x) → ¬SuitableForRetirement(x)) ::: If the stock price is volatile, then it is not suitable for a retirement fund.\n∃x ∃y (GrowthStock(x) ∧ Company(y)) ::: Some stocks of some companies are growth stocks of companies.\n∀x (Stock(x) ∧ MatureCompany(x) → SuitableForRetirement(x)) ::: All stocks of mature companies are suitable for a retirement fund.\nKO(ko) ∧ Stock(ko) ∧ MatureCompany(ko) ::: KO is a stock of a mature company.\n",
                "First-Order-Logic Question": "(GrowthStock(ko) ∨ Volatile(ko)) → (¬Stock(ko) ∧ ¬Volatile(ko)) ::: If KO is a growth stock of a company or if its price is volatile, then KO is neither a stock of a company nor is its price volatile."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∀x (GrowthStock(x) → Volatile(x)) ::: All growth stocks of companies are volatile.\n∀x (Volatile(x) → ¬SuitableForRetirement(x)) ::: If the stock price is volatile, then it is not suitable for a retirement fund.\n∃x ∃y (GrowthStock(x) ∧ Company(y)) ::: Some stocks of some companies are growth stocks of companies.\n∀x (Stock(x) ∧ MatureCompany(x) → SuitableForRetirement(x)) ::: All stocks of mature companies are suitable for a retirement fund.\nKO(ko) ∧ Stock(ko) ∧ MatureCompany(ko) ::: KO is a stock of a mature company.\n",
                "First-Order-Logic Question": "(GrowthStock(ko) ∨ Volatile(ko)) → (¬Stock(ko) ∧ ¬Volatile(ko)) ::: If KO is a growth stock of a company or if its price is volatile, then KO is neither a stock of a company nor is its price volatile."
            },
            "diff": [],
            "answer": "A",
            "error_type":"",
            "grammar_answer": "A"
        },
        {
            "id": 93,
            "raw_prog": {
                "First-Order-Logic Rules": "∃x (Pet(x) ∧ AllowedIn(x, y)) ::: Pets are allowed in some managed buildings.\n∀x (RequireDeposit(x) → ∃y (RentApartment(z, y) ∧ SecurityDeposit(x) ∧ (Equal(SecurityDeposit(x), RentAmount(y)) ∨ MoreThan(SecurityDeposit(x), RentAmount(y))))) ::: A deposit is required to rent an apartment in a managed building. The security deposit can be either equal to one month's rent or more.\nCat(fluffy) ∧ Pet(fluffy) ∧ Owner(tom, fluffy) ::: Fluffy is Tom's cat.\nCat(x) → Pet(x) ::: Cats are pets.\nManagedBuilding(olivegarden) ::: The Olive Garden is a managed building.\nRentAmount(2000, olivegarden) ::: The monthly rent at the Olive Garden is $2000.\nRentApartment(tom, olivegarden) ↔ (AllowedIn(tom, olivegarden) ∧ SecurityDeposit(olivegarden) ∧ (Equal(SecurityDeposit(olivegarden), 1500) ∨ ¬MoreThan(SecurityDeposit(olivegarden), 1500))) ::: Tom will rent an apartment in a managed building if and only if he is allowed to move in with Fluffy, and the security deposit is no more than $1500.\nMoreThan(2000, 1500) ::: 2000$ is more than $1500.",
                "First-Order-Logic Question": "RentApartment(tom, olivegarden) ::: Tom will rent an apartment in The Olive Garden."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∃x (Pet(x) ∧ AllowedIn(x, y)) ::: Pets are allowed in some managed buildings.\nRequireDeposit(x)→(RentApartment(z,y)∧SecurityDeposit(x)) ::: A deposit is required to rent an apartment in a managed building. The security deposit can be either equal to one month's rent or more.\nCat(fluffy) ∧ Pet(fluffy) ∧ Owner(tom, fluffy) ::: Fluffy is Tom's cat.\nCat(x) → Pet(x) ::: Cats are pets.\nManagedBuilding(olivegarden) ::: The Olive Garden is a managed building.\nRentAmount(2000, olivegarden) ::: The monthly rent at the Olive Garden is $2000.\nRentApartment(x,y)↔(AllowedIn(x,y)∧SecurityDeposit(y)) ::: Tom will rent an apartment in a managed building if and only if he is allowed to move in with Fluffy, and the security deposit is no more than $1500.\nMoreThan(2000, 1500) ::: 2000$ is more than $1500.",
                "First-Order-Logic Question": "RentApartment(tom, olivegarden) ::: Tom will rent an apartment in The Olive Garden."
            },
            "diff": [
                {
                    "raw": "∀x (RequireDeposit(x) → ∃y (RentApartment(z, y) ∧ SecurityDeposit(x) ∧ (Equal(SecurityDeposit(x), RentAmount(y)) ∨ MoreThan(SecurityDeposit(x), RentAmount(y))))) ::: A deposit is required to rent an apartment in a managed building. The security deposit can be either equal to one month's rent or more.",
                    "gram": "RequireDeposit(x)→(RentApartment(z,y)∧SecurityDeposit(x)) ::: A deposit is required to rent an apartment in a managed building. The security deposit can be either equal to one month's rent or more."
                },
                {
                    "raw": "RentApartment(tom, olivegarden) ↔ (AllowedIn(tom, olivegarden) ∧ SecurityDeposit(olivegarden) ∧ (Equal(SecurityDeposit(olivegarden), 1500) ∨ ¬MoreThan(SecurityDeposit(olivegarden), 1500))) ::: Tom will rent an apartment in a managed building if and only if he is allowed to move in with Fluffy, and the security deposit is no more than $1500.",
                    "gram": "RentApartment(x,y)↔(AllowedIn(x,y)∧SecurityDeposit(y)) ::: Tom will rent an apartment in a managed building if and only if he is allowed to move in with Fluffy, and the security deposit is no more than $1500."
                }
            ],
            "answer": "B",
            "error_type":"",
            "grammar_answer": "C"
        },
        {
            "id": 94,
            "raw_prog": {
                "First-Order-Logic Rules": "∃x (Pet(x) ∧ ManagedBuilding(y) ∧ AllowedIn(x, y)) ::: Pets are allowed in some managed buildings.\n∀x (ManagedBuilding(x) → RequireDeposit(x)) ::: A deposit is required to rent an apartment in a managed building.\n∀x (SecurityDeposit(x) → (Equal(x, Rent) ∨ MoreThan(x, Rent))) ::: The security deposit can be either equal to one month's rent or more.\nCat(fluffy) ∧ Pet(fluffy) ∧ Owner(tom, fluffy) ::: Fluffy is Tom's cat.\n∀x (Cat(x) → Pet(x)) ::: Cats are pets.\nManagedBuilding(olivegarden) ::: The Olive Garden is a managed building.\nPrice(olivegarden, 2000) ::: The monthly rent at the Olive Garden is $2000.\nRentApartment(tom, olivegarden) ↔ (AllowedIn(tom, olivegarden) ∧ ¬MoreThan(SecurityDeposit(olivegarden), 1500)) ::: Tom will rent an apartment in a managed building if and only if he is allowed to move in with Fluffy, and the security deposit is no more than $1500.\nMoreThan(2000, 1500) ::: 2000$ is more than $1500.\n",
                "First-Order-Logic Question": "RentApartment(tom, olivegarden) ∧ MoveInWith(tom, fluffy) ::: Tom is allowed to move in an apartment in The Olive Garden with Fluffy."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∃x (Pet(x) ∧ ManagedBuilding(y) ∧ AllowedIn(x, y)) ::: Pets are allowed in some managed buildings.\n∀x (ManagedBuilding(x) → RequireDeposit(x)) ::: A deposit is required to rent an apartment in a managed building.\n∀x (SecurityDeposit(x) → (Equal(x, Rent) ∨ MoreThan(x, Rent))) ::: The security deposit can be either equal to one month's rent or more.\nCat(fluffy) ∧ Pet(fluffy) ∧ Owner(tom, fluffy) ::: Fluffy is Tom's cat.\n∀x (Cat(x) → Pet(x)) ::: Cats are pets.\nManagedBuilding(olivegarden) ::: The Olive Garden is a managed building.\nPrice(olivegarden, 2000) ::: The monthly rent at the Olive Garden is $2000.\nRentApartment(x,y)↔(AllowedIn(x,y)∧¬MoreThan(x,y)) ::: Tom will rent an apartment in a managed building if and only if he is allowed to move in with Fluffy, and the security deposit is no more than $1500.\nMoreThan(2000, 1500) ::: 2000$ is more than $1500.\n",
                "First-Order-Logic Question": "RentApartment(tom, olivegarden) ∧ MoveInWith(tom, fluffy) ::: Tom is allowed to move in an apartment in The Olive Garden with Fluffy."
            },
            "diff": [
                {
                    "raw": "RentApartment(tom, olivegarden) ↔ (AllowedIn(tom, olivegarden) ∧ ¬MoreThan(SecurityDeposit(olivegarden), 1500)) ::: Tom will rent an apartment in a managed building if and only if he is allowed to move in with Fluffy, and the security deposit is no more than $1500.",
                    "gram": "RentApartment(x,y)↔(AllowedIn(x,y)∧¬MoreThan(x,y)) ::: Tom will rent an apartment in a managed building if and only if he is allowed to move in with Fluffy, and the security deposit is no more than $1500."
                }
            ],
            "answer": "C",
            "error_type":"",
            "grammar_answer": "C"
        },
        {
            "id": 104,
            "raw_prog": {
                "First-Order-Logic Rules": "∀x (Twins(x) ∨ Triplets(x) → SpendTimeWith(x, x)) ::: If people are twins or triplets, then they spend a lot of time hanging out with and playing with their siblings.\n∀x (Siblings(x, y) → Twins(x) ∨ Triplets(x)) ::: If people have siblings who are the same age, then they are twins or triplets.\n∀x (Complain(x) → Siblings(x, y)) ::: If people complain often about annoying siblings, then they have siblings who are the same age.\n∀x (¬LiveAtHome(x) → ¬DevelopBonds(x, y)) ::: If people do not live at home regularly, then they do not develop strong bonds with their family members.\n∀x (SpendTimeWith(x, y) → ¬LiveAtHome(x)) ::: If people spend a lot of time hanging out with and playing with their siblings, then they often did not live at home regularly.\n(Twins(luke) ∧ DevelopBonds(luke, luke)) ⊕ (¬Twins(luke) ∧ ¬DevelopBonds(luke, luke)) ::: Luke is either both a twin or triplet and develops strong bonds with his family members, or he neither is a twin or triplet nor develops strong bonds with his family members.\n",
                "First-Order-Logic Question": "¬(Twins(luke) ∨ Triplets(luke) ∨ Complain(luke)) ::: Luke is neither a twin nor triplet nor complains often about annoying siblings."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∀x (Twins(x) ∨ Triplets(x) → SpendTimeWith(x, x)) ::: If people are twins or triplets, then they spend a lot of time hanging out with and playing with their siblings.\n∀x (Siblings(x, y) → Twins(x) ∨ Triplets(x)) ::: If people have siblings who are the same age, then they are twins or triplets.\n∀x (Complain(x) → Siblings(x, y)) ::: If people complain often about annoying siblings, then they have siblings who are the same age.\n∀x (¬LiveAtHome(x) → ¬DevelopBonds(x, y)) ::: If people do not live at home regularly, then they do not develop strong bonds with their family members.\n∀x (SpendTimeWith(x, y) → ¬LiveAtHome(x)) ::: If people spend a lot of time hanging out with and playing with their siblings, then they often did not live at home regularly.\n(Twins(luke) ∧ DevelopBonds(luke, luke)) ⊕ (¬Twins(luke) ∧ ¬DevelopBonds(luke, luke)) ::: Luke is either both a twin or triplet and develops strong bonds with his family members, or he neither is a twin or triplet nor develops strong bonds with his family members.\n",
                "First-Order-Logic Question": "¬(Twins(luke) ∨ Triplets(luke) ∨ Complain(luke)) ::: Luke is neither a twin nor triplet nor complains often about annoying siblings."
            },
            "diff": [],
            "answer": "A",
            "error_type":"",
            "grammar_answer": "C"
        },
        {
            "id": 123,
            "raw_prog": {
                "First-Order-Logic Rules": "∀x (Transport(x) → ¬Empty(x)) ::: If something can transport multiple passengers, then they are not empty. \n∀x (Airline(x) → Transport(x)) ::: All airlines can transport multiple passengers. \n∀x (Plane(x) → Empty(x)) ::: All planes are empty. \n∀x (Boeing707(x) → Plane(x)) ::: All Boeing 707s are planes. \nAirline(Greyhound) → ¬∃x (Greyhound(x) ∧ Plane(x)) ::: If Greyhound is not an airline, then there are no Greyhound planes.\n",
                "First-Order-Logic Question": "Boeing707(Greyhound) ::: A Greyhound is a Boeing 707."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∀x (Transport(x) → ¬Empty(x)) ::: If something can transport multiple passengers, then they are not empty. \n∀x (Airline(x) → Transport(x)) ::: All airlines can transport multiple passengers. \n∀x (Plane(x) → Empty(x)) ::: All planes are empty. \n∀x (Boeing707(x) → Plane(x)) ::: All Boeing 707s are planes. \nAirline(x)→¬(Plane(x)) ::: If Greyhound is not an airline, then there are no Greyhound planes.\n",
                "First-Order-Logic Question": "Boeing707(Greyhound) ::: A Greyhound is a Boeing 707."
            },
            "diff": [
                {
                    "raw": "Airline(Greyhound) → ¬∃x (Greyhound(x) ∧ Plane(x)) ::: If Greyhound is not an airline, then there are no Greyhound planes.",
                    "gram": "Airline(x)→¬(Plane(x)) ::: If Greyhound is not an airline, then there are no Greyhound planes."
                }
            ],
            "answer": "B",
            "error_type":"",
            "grammar_answer": "C"
        },
        {
            "id": 124,
            "raw_prog": {
                "First-Order-Logic Rules": "∀x (Transport(x) → ¬Empty(x)) ::: If something can transport multiple passengers, then they are not empty. \n∀x (Airline(x) → Transport(x)) ::: All airlines can transport multiple passengers. \n∀x (Plane(x) → Empty(x)) ::: All planes are empty. \n∀x (Boeing707(x) → Plane(x)) ::: All Boeing 707s are planes. \nAirline(Greyhound) → ¬∃x (Greyhound(x) ∧ Plane(x)) ::: If Greyhound is not an airline, then there are no Greyhound planes.\n",
                "First-Order-Logic Question": "¬(Greyhound(x) ∧ Boeing707(x)) ::: A Greyhound is not a Boeing 707."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∀x (Transport(x) → ¬Empty(x)) ::: If something can transport multiple passengers, then they are not empty. \n∀x (Airline(x) → Transport(x)) ::: All airlines can transport multiple passengers. \n∀x (Plane(x) → Empty(x)) ::: All planes are empty. \n∀x (Boeing707(x) → Plane(x)) ::: All Boeing 707s are planes. \nAirline(x)→¬(Plane(x)) ::: If Greyhound is not an airline, then there are no Greyhound planes.\n",
                "First-Order-Logic Question": "¬(Greyhound(x) ∧ Boeing707(x)) ::: A Greyhound is not a Boeing 707."
            },
            "diff": [
                {
                    "raw": "Airline(Greyhound) → ¬∃x (Greyhound(x) ∧ Plane(x)) ::: If Greyhound is not an airline, then there are no Greyhound planes.",
                    "gram": "Airline(x)→¬(Plane(x)) ::: If Greyhound is not an airline, then there are no Greyhound planes."
                }
            ],
            "answer": "A",
            "error_type":"",
            "grammar_answer": "C"
        },
        {
            "id": 128,
            "raw_prog": {
                "First-Order-Logic Rules": "∀x (HaveWedding(x) → HaveChild(x)) ::: All people who have a wedding are people who have at least one child.\n∀x (TravelToParis(x) → HaveWedding(x)) ::: All people who travel to Paris for their honeymoon are people who have a wedding.\n∀x (OccurIn(x, July) ∧ HaveWedding(x) → TravelToParis(x)) ::: All weddings that occur in July belong to people who travel to Paris for their honeymoon.\n∃x (OccurIn(x, July) ∧ WellAttended(x)) ::: Some weddings in July are well-attended.\nHaveChild(John) → (¬TravelToParis(John) ∧ ¬HaveWedding(John)) ::: If John has at least one child, then John does not travel to Paris for his honeymoon and does not have a wedding.\nHaveWedding(John) ∧ WellAttended(John) → (OccurIn(John, July) ∨ (¬OccurIn(John, July) → TravelToParis(John))) ::: If John has a wedding that is well-attended, then John has a wedding in July or, if not, then John travels to Paris for their honeymoon.",
                "First-Order-Logic Question": "WellAttended(John) ::: John has a wedding that is well-attended."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∀x (HaveWedding(x) → HaveChild(x)) ::: All people who have a wedding are people who have at least one child.\n∀x (TravelToParis(x) → HaveWedding(x)) ::: All people who travel to Paris for their honeymoon are people who have a wedding.\n∀x (OccurIn(x, July) ∧ HaveWedding(x) → TravelToParis(x)) ::: All weddings that occur in July belong to people who travel to Paris for their honeymoon.\n∃x (OccurIn(x, July) ∧ WellAttended(x)) ::: Some weddings in July are well-attended.\nHaveChild(John) → (¬TravelToParis(John) ∧ ¬HaveWedding(John)) ::: If John has at least one child, then John does not travel to Paris for his honeymoon and does not have a wedding.\nHaveWedding(John) ∧ WellAttended(John) → (OccurIn(John, July) ∨ (¬OccurIn(John, July) → TravelToParis(John))) ::: If John has a wedding that is well-attended, then John has a wedding in July or, if not, then John travels to Paris for their honeymoon.",
                "First-Order-Logic Question": "WellAttended(John) ::: John has a wedding that is well-attended."
            },
            "diff": [],
            "answer": "B",
            "error_type":"",
            "grammar_answer": "C"
        },
        {
            "id": 130,
            "raw_prog": {
                "First-Order-Logic Rules": "∀x (HaveWedding(x) → HaveChild(x)) ::: All people who have a wedding are people who have at least one child.\n∀x (TravelToParisForHoneymoon(x) → HaveWedding(x)) ::: All people who travel to Paris for their honeymoon are people who have a wedding.\n∀x (Weddings(x) ∧ July(x) → BelongTo(x, TravelToParisForHoneymoon(x))) ::: All weddings that occur in July belong to people who travel to Paris for their honeymoon.\n∃x (Weddings(x) ∧ July(x) ∧ WellAttended(x)) ::: Some weddings in July are well-attended.\nHaveChild(John) → (¬TravelToParisForHoneymoon(John) ∧ ¬HaveWedding(John)) ::: If John has at least one child, then John does not travel to Paris for his honeymoon and does not have a wedding.\n(WellAttended(John) → (Weddings(John) ∧ July(John))) ∨ (¬July(John) → TravelToParisForHoneymoon(John)) ::: If John has a wedding that is well-attended, then John has a wedding in July or, if not, then John travels to Paris for their honeymoon.",
                "First-Order-Logic Question": "HaveChild(John) ::: John has at least one child."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∀x (HaveWedding(x) → HaveChild(x)) ::: All people who have a wedding are people who have at least one child.\n∀x (TravelToParisForHoneymoon(x) → HaveWedding(x)) ::: All people who travel to Paris for their honeymoon are people who have a wedding.\n∀x(WellAttended(x)→BelongTo(x,x)) ::: All weddings that occur in July belong to people who travel to Paris for their honeymoon.\n∃x (Weddings(x) ∧ July(x) ∧ WellAttended(x)) ::: Some weddings in July are well-attended.\nHaveChild(John) → (¬TravelToParisForHoneymoon(John) ∧ ¬HaveWedding(John)) ::: If John has at least one child, then John does not travel to Paris for his honeymoon and does not have a wedding.\n(WellAttended(John) → (Weddings(John) ∧ July(John))) ∨ (¬July(John) → TravelToParisForHoneymoon(John)) ::: If John has a wedding that is well-attended, then John has a wedding in July or, if not, then John travels to Paris for their honeymoon.",
                "First-Order-Logic Question": "HaveChild(John) ::: John has at least one child."
            },
            "diff": [
                {
                    "raw": "∀x (Weddings(x) ∧ July(x) → BelongTo(x, TravelToParisForHoneymoon(x))) ::: All weddings that occur in July belong to people who travel to Paris for their honeymoon.",
                    "gram": "∀x(WellAttended(x)→BelongTo(x,x)) ::: All weddings that occur in July belong to people who travel to Paris for their honeymoon."
                }
            ],
            "answer": "C",
            "error_type":"",
            "grammar_answer": "C"
        },
        {
            "id": 138,
            "raw_prog": {
                "First-Order-Logic Rules": "∀x (Algorithm(x) → (SupervisedLearning(x) ∨ UnsupervisedLearning(x) ∨ ReinforcementLearning(x))) ::: Machine Learning algorithms can be categorized as supervised learning, unsupervised learning, and reinforcement learning.\n∀x (UnsupervisedLearning(x) → ¬RequireLabelledData(x)) ::: Unsupervised learning doesn't require labelled data.\nStateOfTheArtModel(model) ∧ Algorithm(algo) ∧ TrainedWith(model, algo) ::: The state-of-the-art text summarization model is trained with machine learning algorithms.\nReinforcementLearning(rl) → ¬TrainedWith(StateOfTheArtModel(model), rl) ::: Reinforcement learning is not used to train the state-of-the-art text summarization model.\n∀x (Algorithm(x) ∧ TrainedWith(StateOfTheArtModel(model), x) → RequireLabelledData(x)) ::: The Machine Learning algorithm for training text summarization model requires labelled data.\n",
                "First-Order-Logic Question": "SupervisedLearning(supervised) ∧ TrainedWith(StateOfTheArtModel(model), supervised) ::: Supervised learning is used to train the state-of-the-art text summarization model."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∀x (Algorithm(x) → (SupervisedLearning(x) ∨ UnsupervisedLearning(x) ∨ ReinforcementLearning(x))) ::: Machine Learning algorithms can be categorized as supervised learning, unsupervised learning, and reinforcement learning.\n∀x (UnsupervisedLearning(x) → ¬RequireLabelledData(x)) ::: Unsupervised learning doesn't require labelled data.\nStateOfTheArtModel(model) ∧ Algorithm(algo) ∧ TrainedWith(model, algo) ::: The state-of-the-art text summarization model is trained with machine learning algorithms.\nReinforcementLearning(x)→¬TrainedWith(x,y) ::: Reinforcement learning is not used to train the state-of-the-art text summarization model.\n∀x(Algorithm(x)∧TrainedWith(x,y)→RequireLabelledData(x)) ::: The Machine Learning algorithm for training text summarization model requires labelled data.\n",
                "First-Order-Logic Question": "SupervisedLearning(x)∧TrainedWith(x,y) ::: Supervised learning is used to train the state-of-the-art text summarization model."
            },
            "diff": [
                {
                    "raw": "ReinforcementLearning(rl) → ¬TrainedWith(StateOfTheArtModel(model), rl) ::: Reinforcement learning is not used to train the state-of-the-art text summarization model.",
                    "gram": "ReinforcementLearning(x)→¬TrainedWith(x,y) ::: Reinforcement learning is not used to train the state-of-the-art text summarization model."
                },
                {
                    "raw": "∀x (Algorithm(x) ∧ TrainedWith(StateOfTheArtModel(model), x) → RequireLabelledData(x)) ::: The Machine Learning algorithm for training text summarization model requires labelled data.",
                    "gram": "∀x(Algorithm(x)∧TrainedWith(x,y)→RequireLabelledData(x)) ::: The Machine Learning algorithm for training text summarization model requires labelled data."
                },
                {
                    "raw": "SupervisedLearning(supervised) ∧ TrainedWith(StateOfTheArtModel(model), supervised) ::: Supervised learning is used to train the state-of-the-art text summarization model.",
                    "gram": "SupervisedLearning(x)∧TrainedWith(x,y) ::: Supervised learning is used to train the state-of-the-art text summarization model."
                }
            ],
            "answer": "A",
            "error_type":"",
            "grammar_answer": "C"
        },
        {
            "id": 139,
            "raw_prog": {
                "First-Order-Logic Rules": "∀x (SupervisedLearning(x) ∨ UnsupervisedLearning(x) ∨ ReinforcementLearning(x)) ::: Machine Learning algorithms can be categorized as supervised learning, unsupervised learning, and reinforcement learning.\nUnsupervisedLearning(x) → ¬RequireLabelledData(x) ::: Unsupervised learning doesn't require labelled data.\nTrainedWith(StateOfTheArtModel(textsummarization), MachineLearningAlgorithm(x)) ::: The state-of-the-art text summarization model is trained with machine learning algorithms.\nReinforcementLearning(x) → ¬TrainedWith(StateOfTheArtModel(textsummarization), x) ::: Reinforcement learning is not used to train the state-of-the-art text summarization model.\nRequireLabelledData(x) → MachineLearningAlgorithm(x) ::: The Machine Learning algorithm for training text summarization model requires labelled data.\n",
                "First-Order-Logic Question": "¬UsedToTrain(UnsupervisedLearning, StateOfTheArtModel(textsummarization)) ::: Unsupervised learning is used to train the state-of-the-art text summarization model."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∀x (SupervisedLearning(x) ∨ UnsupervisedLearning(x) ∨ ReinforcementLearning(x)) ::: Machine Learning algorithms can be categorized as supervised learning, unsupervised learning, and reinforcement learning.\nUnsupervisedLearning(x) → ¬RequireLabelledData(x) ::: Unsupervised learning doesn't require labelled data.\nTrainedWith(x,y) ::: The state-of-the-art text summarization model is trained with machine learning algorithms.\nReinforcementLearning(x)→¬TrainedWith(x,x) ::: Reinforcement learning is not used to train the state-of-the-art text summarization model.\nRequireLabelledData(x) → MachineLearningAlgorithm(x) ::: The Machine Learning algorithm for training text summarization model requires labelled data.\n",
                "First-Order-Logic Question": "¬UsedToTrain(x,y) ::: Unsupervised learning is used to train the state-of-the-art text summarization model."
            },
            "diff": [
                {
                    "raw": "TrainedWith(StateOfTheArtModel(textsummarization), MachineLearningAlgorithm(x)) ::: The state-of-the-art text summarization model is trained with machine learning algorithms.",
                    "gram": "TrainedWith(x,y) ::: The state-of-the-art text summarization model is trained with machine learning algorithms."
                },
                {
                    "raw": "ReinforcementLearning(x) → ¬TrainedWith(StateOfTheArtModel(textsummarization), x) ::: Reinforcement learning is not used to train the state-of-the-art text summarization model.",
                    "gram": "ReinforcementLearning(x)→¬TrainedWith(x,x) ::: Reinforcement learning is not used to train the state-of-the-art text summarization model."
                },
                {
                    "raw": "¬UsedToTrain(UnsupervisedLearning, StateOfTheArtModel(textsummarization)) ::: Unsupervised learning is used to train the state-of-the-art text summarization model.",
                    "gram": "¬UsedToTrain(x,y) ::: Unsupervised learning is used to train the state-of-the-art text summarization model."
                }
            ],
            "answer": "B",
            "error_type":"",
            "grammar_answer": "C"
        },
        {
            "id": 153,
            "raw_prog": {
                "First-Order-Logic Rules": "∀x,y (Owns(x, y) → (WorkRegularlyAtHome(x) ∧ TidyOrganize(x))) ::: If people own a large desktop monitor at their home, then they work regularly and often at home.\n∀x (HasHomeOffice(x) → Owns(x, largeDesktopMonitor)) ::: All people who have a fully stocked and impressive home office are people who own a large desktop monitor at their home.\n∀x (WorkRegularlyAtHome(x) → TidyOrganize(x)) ::: All people who work regularly and often at home spend their free time tidying and organizing the spaces in their homes.\n∀x (WorkRegularlyAtHome(x) → VisitStore(x)) ::: All people who work regularly and often at home visit the office supply store regularly.\n∀x (TidyOrganize(x) → (¬GoToBedLate(x) ∧ WakeUpLate(x))) ::: If people spend their free time tidying and organizing the spaces in their home, then they do not go to bed late and wake up every day after noon.\n(TidyOrganize(remy) ∧ (GoToBedLate(remy) ∧ WakeUpLate(remy))) ⊕ (¬GoToBedLate(remy) ∧ ¬WakeUpLate(remy) ∧ ¬TidyOrganize(remy)) ::: Remy either both goes to bed late and wakes up every day after noon and spends their free time tidying and organizing the spaces in their home, or they do not go to bed late and wake up every day after noon nor spend their free time tidying and organizing the spaces in their home.\n",
                "First-Order-Logic Question": "VisitStore(remy) ::: Remy visits the office supply store regularly."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "GoToBedLate(x)→WorkRegularlyAtHome(x)∧TidyOrganize(x) ::: If people own a large desktop monitor at their home, then they work regularly and often at home.\n∀x (HasHomeOffice(x) → Owns(x, largeDesktopMonitor)) ::: All people who have a fully stocked and impressive home office are people who own a large desktop monitor at their home.\n∀x (WorkRegularlyAtHome(x) → TidyOrganize(x)) ::: All people who work regularly and often at home spend their free time tidying and organizing the spaces in their homes.\n∀x (WorkRegularlyAtHome(x) → VisitStore(x)) ::: All people who work regularly and often at home visit the office supply store regularly.\n∀x (TidyOrganize(x) → (¬GoToBedLate(x) ∧ WakeUpLate(x))) ::: If people spend their free time tidying and organizing the spaces in their home, then they do not go to bed late and wake up every day after noon.\n(TidyOrganize(remy) ∧ (GoToBedLate(remy) ∧ WakeUpLate(remy))) ⊕ (¬GoToBedLate(remy) ∧ ¬WakeUpLate(remy) ∧ ¬TidyOrganize(remy)) ::: Remy either both goes to bed late and wakes up every day after noon and spends their free time tidying and organizing the spaces in their home, or they do not go to bed late and wake up every day after noon nor spend their free time tidying and organizing the spaces in their home.\n",
                "First-Order-Logic Question": "VisitStore(remy) ::: Remy visits the office supply store regularly."
            },
            "diff": [
                {
                    "raw": "∀x,y (Owns(x, y) → (WorkRegularlyAtHome(x) ∧ TidyOrganize(x))) ::: If people own a large desktop monitor at their home, then they work regularly and often at home.",
                    "gram": "GoToBedLate(x)→WorkRegularlyAtHome(x)∧TidyOrganize(x) ::: If people own a large desktop monitor at their home, then they work regularly and often at home."
                }
            ],
            "answer": "C",
            "error_type":"",
            "grammar_answer": "A"
        },
        {
            "id": 155,
            "raw_prog": {
                "First-Order-Logic Rules": "∀x,y (Owns(x, y) → (WorkRegularly(x) ∧ WorkOften(x))) ::: If people own a large desktop monitor at their home, then they work regularly and often at home.\n∀x (FullyStocked(x) → Owns(x, largeDesktopMonitor) ∧ Impressive(x)) ::: All people who have a fully stocked and impressive home office are people who own a large desktop monitor at their home.\n∀x (WorkRegularly(x) ∧ WorkOften(x) → Tidy(x)) ::: All people who work regularly and often at home spend their free time tidying and organizing the spaces in their homes.\n∀x (WorkRegularly(x) ∧ WorkOften(x) → VisitStore(x)) ::: All people who work regularly and often at home visit the office supply store regularly.\n∀x (Tidy(x) → (¬Late(x) ∧ ¬WakeLate(x))) ::: If people spend their free time tidying and organizing the spaces in their home, then they do not go to bed late and wake up every day after noon.\n(Tidy(remy) ∧ Late(remy) ∧ WakeLate(remy)) ⊕ (¬Late(remy) ∧ ¬WakeLate(remy) ∧ ¬Tidy(remy)) ::: Remy either both goes to bed late and wakes up every day after noon and spends their free time tidying and organizing the spaces in their home, or they do not go to bed late and wake up every day after noon nor spend their free time tidying and organizing the spaces in their home.\n",
                "First-Order-Logic Question": "((Late(remy) ∧ WakeLate(remy)) ∨ VisitStore(remy)) → (¬Tidy(remy) ∧ ¬FullyStocked(remy)) ::: If Remy either goes to bed late and wakes up every day after noon or visits the office supply store regularly, then Remy neither spends their free time tidying and organizing the spaces in their home nor has a fully stocked and impressive home office."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∀x(Owns(x,y)→(WorkRegularly(x))) ::: If people own a large desktop monitor at their home, then they work regularly and often at home.\n∀x (FullyStocked(x) → Owns(x, largeDesktopMonitor) ∧ Impressive(x)) ::: All people who have a fully stocked and impressive home office are people who own a large desktop monitor at their home.\n∀x (WorkRegularly(x) ∧ WorkOften(x) → Tidy(x)) ::: All people who work regularly and often at home spend their free time tidying and organizing the spaces in their homes.\n∀x (WorkRegularly(x) ∧ WorkOften(x) → VisitStore(x)) ::: All people who work regularly and often at home visit the office supply store regularly.\n∀x (Tidy(x) → (¬Late(x) ∧ ¬WakeLate(x))) ::: If people spend their free time tidying and organizing the spaces in their home, then they do not go to bed late and wake up every day after noon.\n(Tidy(remy) ∧ Late(remy) ∧ WakeLate(remy)) ⊕ (¬Late(remy) ∧ ¬WakeLate(remy) ∧ ¬Tidy(remy)) ::: Remy either both goes to bed late and wakes up every day after noon and spends their free time tidying and organizing the spaces in their home, or they do not go to bed late and wake up every day after noon nor spend their free time tidying and organizing the spaces in their home.\n",
                "First-Order-Logic Question": "((Late(remy) ∧ WakeLate(remy)) ∨ VisitStore(remy)) → (¬Tidy(remy) ∧ ¬FullyStocked(remy)) ::: If Remy either goes to bed late and wakes up every day after noon or visits the office supply store regularly, then Remy neither spends their free time tidying and organizing the spaces in their home nor has a fully stocked and impressive home office."
            },
            "diff": [
                {
                    "raw": "∀x,y (Owns(x, y) → (WorkRegularly(x) ∧ WorkOften(x))) ::: If people own a large desktop monitor at their home, then they work regularly and often at home.",
                    "gram": "∀x(Owns(x,y)→(WorkRegularly(x))) ::: If people own a large desktop monitor at their home, then they work regularly and often at home."
                }
            ],
            "answer": "A",
            "error_type":"",
            "grammar_answer": "C"
        },
        {
            "id": 164,
            "raw_prog": {
                "First-Order-Logic Rules": "∃x ∃y (Roses(x) ∧ MondayAt8pm(y) ∧ GivenOut(x, y)) ::: On some Mondays at 8 pm, roses are given out on TV.\n∀x (GivenOut(x, TVShow(TheBachelor)) → On(x, TheBachelor)) ::: Every rose given out on TV is on the Bachelor.\n∀x (On(TheBachelor, x) → Portray(x, RealPeople)) ::: Everything on the Bachelor portrays the lives of real people.\n∀x (Portray(x, RealPeople) → RealityTVShow(x)) ::: All shows portraying the lives of real people are reality TV shows.\n¬RealityTVShow(BreakingBad) ::: Breaking Bad is not a reality TV show.\n",
                "First-Order-Logic Question": "∃x (Roses(x) ∧ MondayAt8pm(x)) ::: Breaking Bad is on Monday at 8 pm."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∃x ∃y (Roses(x) ∧ MondayAt8pm(y) ∧ GivenOut(x, y)) ::: On some Mondays at 8 pm, roses are given out on TV.\nGivenOut(x,y)→On(x,y) ::: Every rose given out on TV is on the Bachelor.\n∀x (On(TheBachelor, x) → Portray(x, RealPeople)) ::: Everything on the Bachelor portrays the lives of real people.\n∀x (Portray(x, RealPeople) → RealityTVShow(x)) ::: All shows portraying the lives of real people are reality TV shows.\n¬RealityTVShow(BreakingBad) ::: Breaking Bad is not a reality TV show.\n",
                "First-Order-Logic Question": "∃x (Roses(x) ∧ MondayAt8pm(x)) ::: Breaking Bad is on Monday at 8 pm."
            },
            "diff": [
                {
                    "raw": "∀x (GivenOut(x, TVShow(TheBachelor)) → On(x, TheBachelor)) ::: Every rose given out on TV is on the Bachelor.",
                    "gram": "GivenOut(x,y)→On(x,y) ::: Every rose given out on TV is on the Bachelor."
                }
            ],
            "answer": "C",
            "error_type":"",
            "grammar_answer": "C"
        },
        {
            "id": 166,
            "raw_prog": {
                "First-Order-Logic Rules": "∃x ∃y (Monday(y) ∧ Time(y) ∧ Roses(x) ∧ GivenOut(x, y)) ::: On some Mondays at 8 pm, roses are given out on TV.\n∀x (Roses(x) → On(x, Bachelor)) ::: Every rose given out on TV is on the Bachelor.\n∀x (On(x, Bachelor) → Portray(x, RealPeople)) ::: Everything on the Bachelor portrays the lives of real people.\n∀x (Portray(x, RealPeople) → RealityTVShow(x)) ::: All shows portraying the lives of real people are reality TV shows.\n¬RealityTVShow(BreakingBad) ::: Breaking Bad is not a reality TV show.\n",
                "First-Order-Logic Question": "∀x (Roses(x) ∧ GivenOut(x, Monday(8pm))) → On(BreakingBad, Monday(8pm)) ::: If roses are given out during Breaking Bad, then it is on Monday at 8 pm."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∃x ∃y (Monday(y) ∧ Time(y) ∧ Roses(x) ∧ GivenOut(x, y)) ::: On some Mondays at 8 pm, roses are given out on TV.\n∀x (Roses(x) → On(x, Bachelor)) ::: Every rose given out on TV is on the Bachelor.\n∀x (On(x, Bachelor) → Portray(x, RealPeople)) ::: Everything on the Bachelor portrays the lives of real people.\n∀x (Portray(x, RealPeople) → RealityTVShow(x)) ::: All shows portraying the lives of real people are reality TV shows.\n¬RealityTVShow(BreakingBad) ::: Breaking Bad is not a reality TV show.\n",
                "First-Order-Logic Question": "GivenOut(x,y)→On(x,y) ::: If roses are given out during Breaking Bad, then it is on Monday at 8 pm."
            },
            "diff": [
                {
                    "raw": "∀x (Roses(x) ∧ GivenOut(x, Monday(8pm))) → On(BreakingBad, Monday(8pm)) ::: If roses are given out during Breaking Bad, then it is on Monday at 8 pm.",
                    "gram": "GivenOut(x,y)→On(x,y) ::: If roses are given out during Breaking Bad, then it is on Monday at 8 pm."
                }
            ],
            "answer": "A",
            "error_type":"",
            "grammar_answer": "C"
        },
        {
            "id": 178,
            "raw_prog": {
                "First-Order-Logic Rules": "SportingEvent(olympicGames) ::: The Olympic games is a sporting event.\nLastOlympicGames(tokyo) ::: The last Olympic games was in Tokyo.\nWonMostMedals(unitedStates, tokyo) ::: The United States won the most medals in Tokyo.\n",
                "First-Order-Logic Question": "WonMostMedals(unitedStates, tokyo) ::: The United States won the most medals in the last Olympic games."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "SportingEvent(olympicGames) ::: The Olympic games is a sporting event.\nLastOlympicGames(tokyo) ::: The last Olympic games was in Tokyo.\nWonMostMedals(unitedStates, tokyo) ::: The United States won the most medals in Tokyo.\n",
                "First-Order-Logic Question": "WonMostMedals(unitedStates, tokyo) ::: The United States won the most medals in the last Olympic games."
            },
            "diff": [],
            "answer": "A",
            "error_type":"",
            "grammar_answer": "A"
        },
        {
            "id": 181,
            "raw_prog": {
                "First-Order-Logic Rules": "Flies(susan, LGA) ::: Susan flies to LGA airport.\n∀x (Airport(x) ∧ Flies(john, x) ∧ ¬(DepartsFrom(john, x) ∧ ArrivesAt(john, x))) ::: The departure and arrival can not be the same airport.\n",
                "First-Order-Logic Question": "Flies(john, LGA) ::: John flies to LGA airport."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "Flies(susan, LGA) ::: Susan flies to LGA airport.\n∀x (Airport(x) ∧ Flies(john, x) ∧ ¬(DepartsFrom(john, x) ∧ ArrivesAt(john, x))) ::: The departure and arrival can not be the same airport.\n",
                "First-Order-Logic Question": "Flies(john, LGA) ::: John flies to LGA airport."
            },
            "diff": [],
            "answer": "B",
            "error_type":"",
            "grammar_answer": "A"
        },
        {
            "id": 1,
            "raw_prog": {
                "First-Order-Logic Rules": "∀x (Perform(x) → (Attend(x) ∧ Engaged(x))) ::: If people perform in school talent shows often, then they attend and are very engaged with school events.\n∀x ((Perform(x) ∨ (Inactive(x) ∧ Disinterested(x))) ::: People either perform in school talent shows often or are inactive and disinterested members of their community.\n∀x (Chaperone(x) → ¬Student(x)) ::: If people chaperone high school dances, then they are not students who attend the school.\n∀x ((Inactive(x) ∧ Disinterested(x)) → Chaperone(x)) ::: All people who are inactive and disinterested members of their community chaperone high school dances.\n∀x ((Young(x) ∨ Teenager(x)) ∧ Wish(x) → Student(x)) ::: All young children and teenagers who wish to further their academic careers and educational opportunities are students who attend the school.\n¬((Attend(Bonnie) ∧ Engaged(Bonnie)) ⊕ Student(Bonnie)) ::: Bonnie either both attends and is very engaged with school events and is a student who attends the school, or she neither attends and is very engaged with school events nor is a student who attends the school.",
                "First-Order-Logic Question": "((Young(Bonnie) ∨ Teenager(Bonnie)) ∧ Wish(Bonnie) ∧ Chaperone(Bonnie)) ∨ ¬((Young(Bonnie) ∨ Teenager(Bonnie)) ∧ ¬Wish(Bonnie)) → (Student(Bonnie) ∨ (Inactive(Bonnie) ∧ Disinterested(Bonnie)))"
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∀x (Perform(x) → (Attend(x) ∧ Engaged(x))) ::: If people perform in school talent shows often, then they attend and are very engaged with school events.\n∀x((Perform(x)∨Inactive(x))) ::: People either perform in school talent shows often or are inactive and disinterested members of their community.\n∀x (Chaperone(x) → ¬Student(x)) ::: If people chaperone high school dances, then they are not students who attend the school.\n∀x ((Inactive(x) ∧ Disinterested(x)) → Chaperone(x)) ::: All people who are inactive and disinterested members of their community chaperone high school dances.\n∀x ((Young(x) ∨ Teenager(x)) ∧ Wish(x) → Student(x)) ::: All young children and teenagers who wish to further their academic careers and educational opportunities are students who attend the school.\n¬((Attend(Bonnie) ∧ Engaged(Bonnie)) ⊕ Student(Bonnie)) ::: Bonnie either both attends and is very engaged with school events and is a student who attends the school, or she neither attends and is very engaged with school events nor is a student who attends the school.",
                "First-Order-Logic Question": "((Young(Bonnie) ∨ Teenager(Bonnie)) ∧ Wish(Bonnie) ∧ Chaperone(Bonnie)) ∨ ¬((Young(Bonnie) ∨ Teenager(Bonnie)) ∧ ¬Wish(Bonnie)) → (Student(Bonnie) ∨ (Inactive(Bonnie) ∧ Disinterested(Bonnie)))"
            },
            "diff": [
                {
                    "raw": "∀x ((Perform(x) ∨ (Inactive(x) ∧ Disinterested(x))) ::: People either perform in school talent shows often or are inactive and disinterested members of their community.",
                    "gram": "∀x((Perform(x)∨Inactive(x))) ::: People either perform in school talent shows often or are inactive and disinterested members of their community."
                }
            ],
            "answer": "A",
            "error_type":"",
            "grammar_answer": "C"
        },
        {
            "id": 13,
            "raw_prog": {
                "First-Order-Logic Rules": "Create(japaneseGameCompany, legendOfZelda) ::: A Japanese game company created the game the Legend of Zelda.\n∀x (Game(x) ∧ Sell(x, moreThanOneMillion) → Select(x, Top10(x))) ::: If a game sells more than one million copies, then it will be selected into the Top 10 list.\nSelect(legendOfZelda, Top10) ::: The Legend of Zelda sold more than one million copies and is selected into the Top 10 list.\n",
                "First-Order-Logic Question": "Create(japaneseVideoGameCompany, FIFA22) ::: FIFA 22 is made by a Japanese video game company."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "Create(japaneseGameCompany, legendOfZelda) ::: A Japanese game company created the game the Legend of Zelda.\nGame(x)∧Sell(x,y)→Select(x,y) ::: If a game sells more than one million copies, then it will be selected into the Top 10 list.\nSelect(legendOfZelda, Top10) ::: The Legend of Zelda sold more than one million copies and is selected into the Top 10 list.\n",
                "First-Order-Logic Question": "Create(japaneseVideoGameCompany, FIFA22) ::: FIFA 22 is made by a Japanese video game company."
            },
            "diff": [
                {
                    "raw": "∀x (Game(x) ∧ Sell(x, moreThanOneMillion) → Select(x, Top10(x))) ::: If a game sells more than one million copies, then it will be selected into the Top 10 list.",
                    "gram": "Game(x)∧Sell(x,y)→Select(x,y) ::: If a game sells more than one million copies, then it will be selected into the Top 10 list."
                }
            ],
            "answer": "C",
            "error_type":"",
            "grammar_answer": "C"
        },
        {
            "id": 74,
            "raw_prog": {
                "First-Order-Logic Rules": "∀x (Plate(x) → BeginWith(x, number34)) ::: All vehicle registration plates in Istanbul begin with the number 34.\n∀x (¬BeginWith(x, number34) → ¬InCity(x, istanbul)) ::: Plates that do not begin with the number 34 are not from Istanbul.\nInCity(joePlate, istanbul) ::: Joe's vehicle registration plate is from Istanbul.\nBeginWith(tomPlate, number35) ::: Tom's license plate begins with the number 35.\n∀x (BG(BeginWith(x, number35), ¬BeginWith(x, number34))) ::: If a license plate begins with the number 35, then it does not begin with the number 34.",
                "First-Order-Logic Question": "BeginWith(joePlate, number34) ::: Joe's license plate begins with the number 34."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∀x (Plate(x) → BeginWith(x, number34)) ::: All vehicle registration plates in Istanbul begin with the number 34.\n∀x (¬BeginWith(x, number34) → ¬InCity(x, istanbul)) ::: Plates that do not begin with the number 34 are not from Istanbul.\nInCity(joePlate, istanbul) ::: Joe's vehicle registration plate is from Istanbul.\nBeginWith(tomPlate, number35) ::: Tom's license plate begins with the number 35.\n∀x(BeginWith(x,y)→¬BeginWith(x,z)) ::: If a license plate begins with the number 35, then it does not begin with the number 34.",
                "First-Order-Logic Question": "BeginWith(joePlate, number34) ::: Joe's license plate begins with the number 34."
            },
            "diff": [
                {
                    "raw": "∀x (BG(BeginWith(x, number35), ¬BeginWith(x, number34))) ::: If a license plate begins with the number 35, then it does not begin with the number 34.",
                    "gram": "∀x(BeginWith(x,y)→¬BeginWith(x,z)) ::: If a license plate begins with the number 35, then it does not begin with the number 34."
                }
            ],
            "answer": "A",
            "error_type":"",
            "grammar_answer": "A"
        },
        {
            "id": 95,
            "raw_prog": {
                "First-Order-Logic Rules": "∃x ∃y (Pet(x) ∧ ManagedBuilding(y) ∧ AllowedIn(x, y)) ::: Pets are allowed in some managed buildings.\n∀x (RequireDeposit(x) → ∃y (RentApartment(y) ∧ Equal(SecurityDeposit(x), MonthlyRent(y, olivegarden)) ∨ MoreThan(SecurityDeposit(x), 1500))) ::: A deposit is required to rent an apartment in a managed building. The security deposit can be either equal to one month's rent or more.\nCat(fluffy) ∧ Pet(fluffy) ∧ Owner(tom, fluffy) ::: Fluffy is Tom's cat.\nCat(x) → Pet(x) ::: Cats are pets.\nManagedBuilding(olivegarden) ::: The Olive Garden is a managed building.\nMonthlyRent(2000, olivegarden) ::: The monthly rent at the Olive Garden is $2000.\nRentApartment(tom) ↔ (AllowedIn(tom, fluffy) ∧ ¬MoreThan(SecurityDeposit(olivegarden), 1500)) ::: Tom will rent an apartment in a managed building if and only if he is allowed to move in with Fluffy, and the security deposit is no more than $1500.\nMoreThan(2000, 1500) ::: 2000$ is more than $1500.",
                "First-Order-Logic Question": "Equal(SecurityDeposit(olivegarden), 2000) ∨ MoreThan(SecurityDeposit(olivegarden), 2000) ::: The security deposit at the Olive Garden is either $2000 or more."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∃x ∃y (Pet(x) ∧ ManagedBuilding(y) ∧ AllowedIn(x, y)) ::: Pets are allowed in some managed buildings.\n∀x(RequireDeposit(x)→(RentApartment(y))) ::: A deposit is required to rent an apartment in a managed building. The security deposit can be either equal to one month's rent or more.\nCat(fluffy) ∧ Pet(fluffy) ∧ Owner(tom, fluffy) ::: Fluffy is Tom's cat.\nCat(x) → Pet(x) ::: Cats are pets.\nManagedBuilding(olivegarden) ::: The Olive Garden is a managed building.\nMonthlyRent(2000, olivegarden) ::: The monthly rent at the Olive Garden is $2000.\nRentApartment(x)↔(AllowedIn(x,y)∧¬MoreThan(x,y)) ::: Tom will rent an apartment in a managed building if and only if he is allowed to move in with Fluffy, and the security deposit is no more than $1500.\nMoreThan(2000, 1500) ::: 2000$ is more than $1500.",
                "First-Order-Logic Question": "MoreThan(x,y)→Equal(x,y) ::: The security deposit at the Olive Garden is either $2000 or more."
            },
            "diff": [
                {
                    "raw": "∀x (RequireDeposit(x) → ∃y (RentApartment(y) ∧ Equal(SecurityDeposit(x), MonthlyRent(y, olivegarden)) ∨ MoreThan(SecurityDeposit(x), 1500))) ::: A deposit is required to rent an apartment in a managed building. The security deposit can be either equal to one month's rent or more.",
                    "gram": "∀x(RequireDeposit(x)→(RentApartment(y))) ::: A deposit is required to rent an apartment in a managed building. The security deposit can be either equal to one month's rent or more."
                },
                {
                    "raw": "RentApartment(tom) ↔ (AllowedIn(tom, fluffy) ∧ ¬MoreThan(SecurityDeposit(olivegarden), 1500)) ::: Tom will rent an apartment in a managed building if and only if he is allowed to move in with Fluffy, and the security deposit is no more than $1500.",
                    "gram": "RentApartment(x)↔(AllowedIn(x,y)∧¬MoreThan(x,y)) ::: Tom will rent an apartment in a managed building if and only if he is allowed to move in with Fluffy, and the security deposit is no more than $1500."
                },
                {
                    "raw": "Equal(SecurityDeposit(olivegarden), 2000) ∨ MoreThan(SecurityDeposit(olivegarden), 2000) ::: The security deposit at the Olive Garden is either $2000 or more.",
                    "gram": "MoreThan(x,y)→Equal(x,y) ::: The security deposit at the Olive Garden is either $2000 or more."
                }
            ],
            "answer": "A",
            "error_type":"",
            "grammar_answer": "C"
        },
        {
            "id": 103,
            "raw_prog": {
                "First-Order-Logic Rules": "∀x (Twins(x) ∨ Triplets(x) → SpendTimeWith(x, Siblings(x))) ::: If people are twins or triplets, then they spend a lot of time hanging out with and playing with their siblings.\n∀x (Siblings(x, y) → Twins(x) ∨ Triplets(x)) ::: If people have siblings who are the same age, then they are twins or triplets.\n∀x (Complain(x) → Siblings(x, y)) ::: If people complain often about annoying siblings, then they have siblings who are the same age.\n∀x (¬LiveAtHomeRegularly(x) → ¬DevelopBonds(x, y)) ::: If people do not live at home regularly, then they do not develop strong bonds with their family members.\n∀x (SpendTimeWith(x, Siblings(x)) → ¬LiveAtHomeRegularly(x)) ::: If people spend a lot of time hanging out with and playing with their siblings, then they often did not live at home regularly.\n(Twins(luke) ∧ DevelopBonds(luke, FamilyMembers)) ∨ (¬Twins(luke) ∧ ¬DevelopBonds(luke, FamilyMembers)) ::: Luke is either both a twin or triplet and develops strong bonds with his family members, or he neither is a twin or triplet nor develops strong bonds with his family members.\n",
                "First-Order-Logic Question": "Complain(luke) ::: Luke complains often about annoying siblings."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∀x(Twins(x)∨Triplets(x)→SpendTimeWith(x,x)) ::: If people are twins or triplets, then they spend a lot of time hanging out with and playing with their siblings.\n∀x (Siblings(x, y) → Twins(x) ∨ Triplets(x)) ::: If people have siblings who are the same age, then they are twins or triplets.\n∀x (Complain(x) → Siblings(x, y)) ::: If people complain often about annoying siblings, then they have siblings who are the same age.\n∀x (¬LiveAtHomeRegularly(x) → ¬DevelopBonds(x, y)) ::: If people do not live at home regularly, then they do not develop strong bonds with their family members.\n∀x(SpendTimeWith(x,y)→¬LiveAtHomeRegularly(x)) ::: If people spend a lot of time hanging out with and playing with their siblings, then they often did not live at home regularly.\n(Twins(luke) ∧ DevelopBonds(luke, FamilyMembers)) ∨ (¬Twins(luke) ∧ ¬DevelopBonds(luke, FamilyMembers)) ::: Luke is either both a twin or triplet and develops strong bonds with his family members, or he neither is a twin or triplet nor develops strong bonds with his family members.\n",
                "First-Order-Logic Question": "Complain(luke) ::: Luke complains often about annoying siblings."
            },
            "diff": [],
            "answer": "B",
            "error_type":"",
            "grammar_answer": "C"
        },
        {
            "id": 106,
            "raw_prog": {
                "First-Order-Logic Rules": "Cost(gre_test, 205) ::: It costs US $205 to take the GRE test.\n∀x (Take(gre_test, x) ∧ EconomicHardship(x) → Provide(ets, financial_aid, x)) ::: ETS provides financial aid to those GRE applicants who prove economic hardship.\n∀x (EconomicHardship(x) ↔ (Cause(Difficulty(x), TooLittleMoney) ∨ Cause(Difficulty(x), TooFewResources))) ::: Economic hardship refers to difficulty caused by having too little money or too few resources.\nSingleParent(tom) ::: Tom lives in a single-parent family.\nUnemployed(dad) ∧ ∃y (y > 1 ∧ Time(y, year) ∧ Cause(Difficulty(dad), Unemployed(dad))) ::: His dad has been out of work for more than a year.",
                "First-Order-Logic Question": "∃x (Cost(gre_test, x) ∧ x < 300) ::: It cost below US $300 to take the GRE test."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "Cost(gre_test, 205) ::: It costs US $205 to take the GRE test.\n∀x (Take(gre_test, x) ∧ EconomicHardship(x) → Provide(ets, financial_aid, x)) ::: ETS provides financial aid to those GRE applicants who prove economic hardship.\nEconomicHardship(x)↔((Cause(x,y))) ::: Economic hardship refers to difficulty caused by having too little money or too few resources.\nSingleParent(tom) ::: Tom lives in a single-parent family.\nUnemployed(x)∧(Cause(x,y)∧CostBelow(y,z)) ::: His dad has been out of work for more than a year.",
                "First-Order-Logic Question": "∃x(CostBelow(x,y)∧Take(x,y)) ::: It cost below US $300 to take the GRE test."
            },
            "diff": [
                {
                    "raw": "∀x (EconomicHardship(x) ↔ (Cause(Difficulty(x), TooLittleMoney) ∨ Cause(Difficulty(x), TooFewResources))) ::: Economic hardship refers to difficulty caused by having too little money or too few resources.",
                    "gram": "EconomicHardship(x)↔((Cause(x,y))) ::: Economic hardship refers to difficulty caused by having too little money or too few resources."
                },
                {
                    "raw": "Unemployed(dad) ∧ ∃y (y > 1 ∧ Time(y, year) ∧ Cause(Difficulty(dad), Unemployed(dad))) ::: His dad has been out of work for more than a year.",
                    "gram": "Unemployed(x)∧(Cause(x,y)∧CostBelow(y,z)) ::: His dad has been out of work for more than a year."
                },
                {
                    "raw": "∃x (Cost(gre_test, x) ∧ x < 300) ::: It cost below US $300 to take the GRE test.",
                    "gram": "∃x(CostBelow(x,y)∧Take(x,y)) ::: It cost below US $300 to take the GRE test."
                }
            ],
            "answer": "A",
            "error_type":"",
            "grammar_answer": "C"
        },
        {
            "id": 108,
            "raw_prog": {
                "First-Order-Logic Rules": "∀x (SpillFood(x) → (¬TidySpaces(x) ∧ EnjoyCleaning(x))) ::: If people spill a lot of food on their clothing, then they do not tidy their spaces consistently and enjoy the process of cleaning.\n∀x (Foodie(x) → SpillFood(x)) ::: All foodies who go out frequently to find new food restaurants to try are people who spill a lot of food on their clothing.\n∀x (OnlyChild(x) → (TidySpaces(x) ∧ EnjoyCleaning(x))) ::: If people grew up as only children with no siblings, then they tidy their spaces consistently and enjoy the process of cleaning.\n∀x (BusyParents(x) → OnlyChild(x)) ::: If people have parents who are very busy with their regular jobs, then they grew up as only children with no siblings.\n∀x (HighIncomeHousehold(x) → BusyParents(Person(x))) ::: All households with a high net income have people who have parents who are very busy with their regular jobs.\n(SpillFood(Peter) ∧ OnlyChild(Peter)) ⊕ (¬SpillFood(Peter) ∧ ¬OnlyChild(Peter)) ::: Peter is either both a person who spills a lot of food on his clothing and grew up as an only child with no siblings, or he is neither a person who spills a lot of food on his clothing nor grew up as an only child with no siblings. ",
                "First-Order-Logic Question": "TidySpaces(Peter) ∧ EnjoyCleaning(Peter) ::: Peter tidies his space consistently and enjoys the process of cleaning."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∀x (SpillFood(x) → (¬TidySpaces(x) ∧ EnjoyCleaning(x))) ::: If people spill a lot of food on their clothing, then they do not tidy their spaces consistently and enjoy the process of cleaning.\n∀x (Foodie(x) → SpillFood(x)) ::: All foodies who go out frequently to find new food restaurants to try are people who spill a lot of food on their clothing.\n∀x (OnlyChild(x) → (TidySpaces(x) ∧ EnjoyCleaning(x))) ::: If people grew up as only children with no siblings, then they tidy their spaces consistently and enjoy the process of cleaning.\n∀x (BusyParents(x) → OnlyChild(x)) ::: If people have parents who are very busy with their regular jobs, then they grew up as only children with no siblings.\nGoOut(x)→BusyParents(x) ::: All households with a high net income have people who have parents who are very busy with their regular jobs.\n(SpillFood(Peter) ∧ OnlyChild(Peter)) ⊕ (¬SpillFood(Peter) ∧ ¬OnlyChild(Peter)) ::: Peter is either both a person who spills a lot of food on his clothing and grew up as an only child with no siblings, or he is neither a person who spills a lot of food on his clothing nor grew up as an only child with no siblings. ",
                "First-Order-Logic Question": "TidySpaces(Peter) ∧ EnjoyCleaning(Peter) ::: Peter tidies his space consistently and enjoys the process of cleaning."
            },
            "diff": [
                {
                    "raw": "∀x (HighIncomeHousehold(x) → BusyParents(Person(x))) ::: All households with a high net income have people who have parents who are very busy with their regular jobs.",
                    "gram": "GoOut(x)→BusyParents(x) ::: All households with a high net income have people who have parents who are very busy with their regular jobs."
                }
            ],
            "answer": "C",
            "error_type":"",
            "grammar_answer": "C"
        },
        {
            "id": 117,
            "raw_prog": {
                "First-Order-Logic Rules": "∀x ∀y (Man(x) ∧ Man(y) ∧ Taller(x, y) → Block(x, y)) ::: If a man is taller than another man, the taller one can block the other's shooting.\nMan(michael) ∧ ∀x (Classmate(x, michael) ∧ x ≠ michael → Taller(michael, x)) ::: Michael is a man who is taller than everyone else in his class.\n∀x ∀y ∀z (Taller(x, y) ∧ Taller(y, z) → Taller(x, z)) ::: If person x is taller than person y, and person y is taller than person z, than x is taller than z\nMan(peter) ∧ Taller(peter, michael) ::: Peter is a man who is taller than Michael.\n∀x (Shoot(x) ∧ ¬Jump(x) → Block(michael, x)) ::: Michael can block any shooting from a person as long as the person does not jump when shooting.\n¬Block(michael, windy) ::: Michael cannot block Windy's shooting.\n∀x (Jump(x) → GreatShooter(x)) ::: Every shooter who can jump when shooting is a great shooter.",
                "First-Order-Logic Question": "Block(peter, windy) ::: Peter can block Windy's shooting."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∀x ∀y (Man(x) ∧ Man(y) ∧ Taller(x, y) → Block(x, y)) ::: If a man is taller than another man, the taller one can block the other's shooting.\nMan(x)∧Taller(x,y)→Block(x,y) ::: Michael is a man who is taller than everyone else in his class.\n∀x ∀y ∀z (Taller(x, y) ∧ Taller(y, z) → Taller(x, z)) ::: If person x is taller than person y, and person y is taller than person z, than x is taller than z\nMan(peter) ∧ Taller(peter, michael) ::: Peter is a man who is taller than Michael.\n∀x (Shoot(x) ∧ ¬Jump(x) → Block(michael, x)) ::: Michael can block any shooting from a person as long as the person does not jump when shooting.\n¬Block(michael, windy) ::: Michael cannot block Windy's shooting.\n∀x (Jump(x) → GreatShooter(x)) ::: Every shooter who can jump when shooting is a great shooter.",
                "First-Order-Logic Question": "Block(peter, windy) ::: Peter can block Windy's shooting."
            },
            "diff": [
                {
                    "raw": "Man(michael) ∧ ∀x (Classmate(x, michael) ∧ x ≠ michael → Taller(michael, x)) ::: Michael is a man who is taller than everyone else in his class.",
                    "gram": "Man(x)∧Taller(x,y)→Block(x,y) ::: Michael is a man who is taller than everyone else in his class."
                }
            ],
            "answer": "C",
            "error_type":"",
            "grammar_answer": "C"
        },
        {
            "id": 122,
            "raw_prog": {
                "First-Order-Logic Rules": "∀x (Transport(x) → ¬Empty(x)) ::: If something can transport multiple passengers, then they are not empty. \n∀x (Airline(x) → Transport(x)) ::: All airlines can transport multiple passengers. \n∀x (Plane(x) → Empty(x)) ::: All planes are empty. \n∀x (Boeing707(x) → Plane(x)) ::: All Boeing 707s are planes. \n¬Airline(Greyhound) → ¬∃x (Greyhound(x) ∧ Plane(x)) ::: If Greyhound is not an airline, then there are no Greyhound planes.",
                "First-Order-Logic Question": "Airline(Greyhound) ::: Greyhound is an airline."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∀x (Transport(x) → ¬Empty(x)) ::: If something can transport multiple passengers, then they are not empty. \n∀x (Airline(x) → Transport(x)) ::: All airlines can transport multiple passengers. \n∀x (Plane(x) → Empty(x)) ::: All planes are empty. \n∀x (Boeing707(x) → Plane(x)) ::: All Boeing 707s are planes. \n¬Airline(x)→¬(Plane(x)) ::: If Greyhound is not an airline, then there are no Greyhound planes.",
                "First-Order-Logic Question": "Airline(Greyhound) ::: Greyhound is an airline."
            },
            "diff": [
                {
                    "raw": "¬Airline(Greyhound) → ¬∃x (Greyhound(x) ∧ Plane(x)) ::: If Greyhound is not an airline, then there are no Greyhound planes.",
                    "gram": "¬Airline(x)→¬(Plane(x)) ::: If Greyhound is not an airline, then there are no Greyhound planes."
                }
            ],
            "answer": "C",
            "error_type":"",
            "grammar_answer": "C"
        },
        {
            "id": 129,
            "raw_prog": {
                "First-Order-Logic Rules": "∀x (HaveWedding(x) → HaveChild(x)) ::: All people who have a wedding are people who have at least one child.\n∀x (TravelToParisForHoneymoon(x) → HaveWedding(x)) ::: All people who travel to Paris for their honeymoon are people who have a wedding.\n∀x (Weddings(x) ∧ July(x) → BelongTo(x, TravelToParisForHoneymoon(x))) ::: All weddings that occur in July belong to people who travel to Paris for their honeymoon.\n∃x (Weddings(x) ∧ July(x) ∧ WellAttended(x)) ::: Some weddings in July are well-attended.\nHaveChild(John) → (¬TravelToParisForHoneymoon(John) ∧ ¬HaveWedding(John)) ::: If John has at least one child, then John does not travel to Paris for his honeymoon and does not have a wedding.\nHaveWedding(John) ∧ WellAttended(John) → (July(John) ∨ (¬July(John) ∧ TravelToParisForHoneymoon(John))) ::: If John has a wedding that is well-attended, then John has a wedding in July or, if not, then John travels to Paris for their honeymoon.",
                "First-Order-Logic Question": "¬WellAttended(John) ::: John does not have a wedding that is well-attended."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∀x (HaveWedding(x) → HaveChild(x)) ::: All people who have a wedding are people who have at least one child.\n∀x (TravelToParisForHoneymoon(x) → HaveWedding(x)) ::: All people who travel to Paris for their honeymoon are people who have a wedding.\n∀x(WellAttended(x)→BelongTo(x,x)) ::: All weddings that occur in July belong to people who travel to Paris for their honeymoon.\n∃x (Weddings(x) ∧ July(x) ∧ WellAttended(x)) ::: Some weddings in July are well-attended.\nHaveChild(John) → (¬TravelToParisForHoneymoon(John) ∧ ¬HaveWedding(John)) ::: If John has at least one child, then John does not travel to Paris for his honeymoon and does not have a wedding.\nHaveWedding(John) ∧ WellAttended(John) → (July(John) ∨ (¬July(John) ∧ TravelToParisForHoneymoon(John))) ::: If John has a wedding that is well-attended, then John has a wedding in July or, if not, then John travels to Paris for their honeymoon.",
                "First-Order-Logic Question": "¬WellAttended(John) ::: John does not have a wedding that is well-attended."
            },
            "diff": [
                {
                    "raw": "∀x (Weddings(x) ∧ July(x) → BelongTo(x, TravelToParisForHoneymoon(x))) ::: All weddings that occur in July belong to people who travel to Paris for their honeymoon.",
                    "gram": "∀x(WellAttended(x)→BelongTo(x,x)) ::: All weddings that occur in July belong to people who travel to Paris for their honeymoon."
                }
            ],
            "answer": "A",
            "error_type":"",
            "grammar_answer": "C"
        },
        {
            "id": 131,
            "raw_prog": {
                "First-Order-Logic Rules": "∀x HaveWedding(x) → HaveChild(x) ::: All people who have a wedding are people who have at least one child.\n∀x (TravelToParisForHoneymoon(x) → HaveWedding(x)) ::: All people who travel to Paris for their honeymoon are people who have a wedding.\n∀x (Weddings(x) ∧ July(x) → BelongTo(x, TravelToParisForHoneymoon(x))) ::: All weddings that occur in July belong to people who travel to Paris for their honeymoon.\n∃x (Weddings(x) ∧ July(x) ∧ WellAttended(x)) ::: Some weddings in July are well-attended.\nHaveChild(John) → ¬(TravelToParisForHoneymoon(John) ∧ HaveWedding(John)) ::: If John has at least one child, then John does not travel to Paris for his honeymoon and does not have a wedding.\nHaveWedding(John) ∧ WellAttended(John) → (July(John) ∨ (¬July(John) ∧ TravelToParisForHoneymoon(John))) ::: If John has a wedding that is well-attended, then John has a wedding in July or, if not, then John travels to Paris for their honeymoon.",
                "First-Order-Logic Question": "¬(WellAttended(John) ∨ TravelToParisForHoneymoon(John)) ::: John has neither a wedding that is well-attended nor does he travel to Paris for his honeymoon."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∀x HaveWedding(x) → HaveChild(x) ::: All people who have a wedding are people who have at least one child.\n∀x (TravelToParisForHoneymoon(x) → HaveWedding(x)) ::: All people who travel to Paris for their honeymoon are people who have a wedding.\n∀x(WellAttended(x)→BelongTo(x,x)) ::: All weddings that occur in July belong to people who travel to Paris for their honeymoon.\n∃x (Weddings(x) ∧ July(x) ∧ WellAttended(x)) ::: Some weddings in July are well-attended.\nHaveChild(John) → ¬(TravelToParisForHoneymoon(John) ∧ HaveWedding(John)) ::: If John has at least one child, then John does not travel to Paris for his honeymoon and does not have a wedding.\nHaveWedding(John) ∧ WellAttended(John) → (July(John) ∨ (¬July(John) ∧ TravelToParisForHoneymoon(John))) ::: If John has a wedding that is well-attended, then John has a wedding in July or, if not, then John travels to Paris for their honeymoon.",
                "First-Order-Logic Question": "¬(WellAttended(John) ∨ TravelToParisForHoneymoon(John)) ::: John has neither a wedding that is well-attended nor does he travel to Paris for his honeymoon."
            },
            "diff": [
                {
                    "raw": "∀x (Weddings(x) ∧ July(x) → BelongTo(x, TravelToParisForHoneymoon(x))) ::: All weddings that occur in July belong to people who travel to Paris for their honeymoon.",
                    "gram": "∀x(WellAttended(x)→BelongTo(x,x)) ::: All weddings that occur in July belong to people who travel to Paris for their honeymoon."
                }
            ],
            "answer": "A",
            "error_type":"",
            "grammar_answer": "C"
        },
        {
            "id": 154,
            "raw_prog": {
                "First-Order-Logic Rules": "∀x,y (Owns(x, y) → (WorkRegularlyAtHome(x) ∧ TidyOrganize(x))) ::: If people own a large desktop monitor at their home, then they work regularly and often at home.\n∀x,y (FullyStockedImpressiveHomeOffice(x) → LargeDesktopMonitor(x, y)) ::: All people who have a fully stocked and impressive home office are people who own a large desktop monitor at their home.\n∀x (WorkRegularlyAtHome(x) → TidyOrganize(x)) ::: All people who work regularly and often at home spend their free time tidying and organizing the spaces in their homes.\n∀x (WorkRegularlyAtHome(x) → VisitOfficeStore(x)) ::: All people who work regularly and often at home visit the office supply store regularly.\n∀x (TidyOrganize(x) → (¬GoToBedLate(x) ∧ ¬WakeUpAfterNoon(x))) ::: If people spend their free time tidying and organizing the spaces in their home, then they do not go to bed late and wake up every day after noon.\n(TidyOrganize(remy) ∧ (GoToBedLate(remy) ∧ WakeUpAfterNoon(remy))) ⊕ (¬GoToBedLate(remy) ∧ ¬WakeUpAfterNoon(remy) ∧ ¬TidyOrganize(remy)) ::: Remy either both goes to bed late and wakes up every day after noon and spends their free time tidying and organizing the spaces in their home, or they do not go to bed late and wake up every day after noon nor spend their free time tidying and organizing the spaces in their home.\n",
                "First-Order-Logic Question": "FullyStockedImpressiveHomeOffice(remy) ∧ VisitOfficeStore(remy) ::: Remy has a fully stocked and impressive home office and also visits the office supply store regularly."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "GoToBedLate(x)→WorkRegularlyAtHome(x)∧TidyOrganize(x) ::: If people own a large desktop monitor at their home, then they work regularly and often at home.\nGoToBedLate(x)→LargeDesktopMonitor(x,y) ::: All people who have a fully stocked and impressive home office are people who own a large desktop monitor at their home.\n∀x (WorkRegularlyAtHome(x) → TidyOrganize(x)) ::: All people who work regularly and often at home spend their free time tidying and organizing the spaces in their homes.\n∀x (WorkRegularlyAtHome(x) → VisitOfficeStore(x)) ::: All people who work regularly and often at home visit the office supply store regularly.\n∀x (TidyOrganize(x) → (¬GoToBedLate(x) ∧ ¬WakeUpAfterNoon(x))) ::: If people spend their free time tidying and organizing the spaces in their home, then they do not go to bed late and wake up every day after noon.\n(TidyOrganize(remy) ∧ (GoToBedLate(remy) ∧ WakeUpAfterNoon(remy))) ⊕ (¬GoToBedLate(remy) ∧ ¬WakeUpAfterNoon(remy) ∧ ¬TidyOrganize(remy)) ::: Remy either both goes to bed late and wakes up every day after noon and spends their free time tidying and organizing the spaces in their home, or they do not go to bed late and wake up every day after noon nor spend their free time tidying and organizing the spaces in their home.\n",
                "First-Order-Logic Question": "FullyStockedImpressiveHomeOffice(remy) ∧ VisitOfficeStore(remy) ::: Remy has a fully stocked and impressive home office and also visits the office supply store regularly."
            },
            "diff": [
                {
                    "raw": "∀x,y (Owns(x, y) → (WorkRegularlyAtHome(x) ∧ TidyOrganize(x))) ::: If people own a large desktop monitor at their home, then they work regularly and often at home.",
                    "gram": "GoToBedLate(x)→WorkRegularlyAtHome(x)∧TidyOrganize(x) ::: If people own a large desktop monitor at their home, then they work regularly and often at home."
                },
                {
                    "raw": "∀x,y (FullyStockedImpressiveHomeOffice(x) → LargeDesktopMonitor(x, y)) ::: All people who have a fully stocked and impressive home office are people who own a large desktop monitor at their home.",
                    "gram": "GoToBedLate(x)→LargeDesktopMonitor(x,y) ::: All people who have a fully stocked and impressive home office are people who own a large desktop monitor at their home."
                }
            ],
            "answer": "B",
            "error_type":"",
            "grammar_answer": "A"
        },
        {
            "id": 180,
            "raw_prog": {
                "First-Order-Logic Rules": "Flies(susan, lga) ::: Susan flies to LGA airport.\nDeparture(x, y) ∧ Arrival(x, y) ⊕ ¬(x = y) ::: The departure and arrival can not be the same airport.\nFrom(john, lga) ::: John flies from LGA airport.",
                "First-Order-Logic Question": "From(susan, lga) ::: Susan flies from LGA airport."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "Flies(susan, lga) ::: Susan flies to LGA airport.\nDeparture(x,y)∧Arrival(x,y)⊕¬(From(x,y)) ::: The departure and arrival can not be the same airport.\nFrom(john, lga) ::: John flies from LGA airport.",
                "First-Order-Logic Question": "From(susan, lga) ::: Susan flies from LGA airport."
            },
            "diff": [
                {
                    "raw": "Departure(x, y) ∧ Arrival(x, y) ⊕ ¬(x = y) ::: The departure and arrival can not be the same airport.",
                    "gram": "Departure(x,y)∧Arrival(x,y)⊕¬(From(x,y)) ::: The departure and arrival can not be the same airport."
                }
            ],
            "answer": "B",
            "error_type":"",
            "grammar_answer": "C"
        },
        {
            "id": 201,
            "raw_prog": {
                "First-Order-Logic Rules": "Person(ailtonSilva) ∧ Born(ailtonSilva, 1995) ∧ KnownAs(ailtonSilva, ailton) ::: Ailton Silva, born in 1995, is commonly known as Ailton.\nFootballPlayer(ailton) ∧ Loan(ailton, braga) ::: Ailton is a football player who was loaned out to Braga.\nBrazilian(ailtonSilva) ∧ FootballPlayer(ailtonSilva) ∧ PlaysFor(ailtonSilva, nautico) ::: Ailton Silva is a Brazillian footballer who plays for Nautico.\nClub(nautico) ∧ Club(braga) ∧ Team(nautico, braga) ::: Nautico is a football club along with Braga.\nClub(fluminense) ::: Fluminense is a football club.\n",
                "First-Order-Logic Question": "¬(∃x Loan(ailton, Club(x))) ::: Ailton was not loaned out to a football club."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "Person(ailtonSilva) ∧ Born(ailtonSilva, 1995) ∧ KnownAs(ailtonSilva, ailton) ::: Ailton Silva, born in 1995, is commonly known as Ailton.\nFootballPlayer(ailton) ∧ Loan(ailton, braga) ::: Ailton is a football player who was loaned out to Braga.\nBrazilian(ailtonSilva) ∧ FootballPlayer(ailtonSilva) ∧ PlaysFor(ailtonSilva, nautico) ::: Ailton Silva is a Brazillian footballer who plays for Nautico.\nClub(nautico) ∧ Club(braga) ∧ Team(nautico, braga) ::: Nautico is a football club along with Braga.\nClub(fluminense) ::: Fluminense is a football club.\n",
                "First-Order-Logic Question": "¬(Loan(x,y)) ::: Ailton was not loaned out to a football club."
            },
            "diff": [
                {
                    "raw": "¬(∃x Loan(ailton, Club(x))) ::: Ailton was not loaned out to a football club.",
                    "gram": "¬(Loan(x,y)) ::: Ailton was not loaned out to a football club."
                }
            ],
            "answer": "B",
            "error_type":"",
            "grammar_answer": "C"
        },
        {
            "id": 11,
            "raw_prog": {
                "First-Order-Logic Rules": "WildTurkey(tom) ::: Tom is a wild turkey.\n∀x (WildTurkey(x) → (x = EasternWildTurkey ∨ x = OsceolaWildTurkey ∨ x = GouldsWildTurkey ∨ x = MerriamsWildTurkey ∨ x = RioGrandeWildTurkey ∨ x = OcellatedWildTurkey)) ::: There are six types of wild turkeys: Eastern wild turkey, Osceola wild turkey, Gould’s wild turkey, Merriam’s wild turkey, Rio Grande wild turkey, and Ocellated wild turkey.\n¬EasternWildTurkey(tom) ∧ ¬OsceolaWildTurkey(tom) ∧ ¬GouldsWildTurkey(tom) ∧ ¬MerriamsWildTurkey(tom) ∧ ¬RioGrandeWildTurkey(tom) ::: Tom is not an Eastern wild turkey, Osceola wild turkey, Gould's wild turkey, Merriam's wild turkey, or Rio Grande wild turkey.\n",
                "First-Order-Logic Question": "WildTurkey(joey) ::: Joey is a wild turkey."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "WildTurkey(tom) ::: Tom is a wild turkey.\nGouldsWildTurkey(x)→(EasternWildTurkey(x)∨OsceolaWildTurkey(x)) ::: There are six types of wild turkeys: Eastern wild turkey, Osceola wild turkey, Gould’s wild turkey, Merriam’s wild turkey, Rio Grande wild turkey, and Ocellated wild turkey.\n¬EasternWildTurkey(tom) ∧ ¬OsceolaWildTurkey(tom) ∧ ¬GouldsWildTurkey(tom) ∧ ¬MerriamsWildTurkey(tom) ∧ ¬RioGrandeWildTurkey(tom) ::: Tom is not an Eastern wild turkey, Osceola wild turkey, Gould's wild turkey, Merriam's wild turkey, or Rio Grande wild turkey.\n",
                "First-Order-Logic Question": "WildTurkey(joey) ::: Joey is a wild turkey."
            },
            "diff": [
                {
                    "raw": "∀x (WildTurkey(x) → (x = EasternWildTurkey ∨ x = OsceolaWildTurkey ∨ x = GouldsWildTurkey ∨ x = MerriamsWildTurkey ∨ x = RioGrandeWildTurkey ∨ x = OcellatedWildTurkey)) ::: There are six types of wild turkeys: Eastern wild turkey, Osceola wild turkey, Gould’s wild turkey, Merriam’s wild turkey, Rio Grande wild turkey, and Ocellated wild turkey.",
                    "gram": "GouldsWildTurkey(x)→(EasternWildTurkey(x)∨OsceolaWildTurkey(x)) ::: There are six types of wild turkeys: Eastern wild turkey, Osceola wild turkey, Gould’s wild turkey, Merriam’s wild turkey, Rio Grande wild turkey, and Ocellated wild turkey."
                }
            ],
            "answer": "C",
            "error_type":"",
            "grammar_answer": "C"
        },
        {
            "id": 14,
            "raw_prog": {
                "First-Order-Logic Rules": "Create(japaneseGameCompany, legendOfZelda) ::: A Japanese game company created the game the Legend of Zelda.\n∀x (Game(x) ∧ MoreThanOneMillion(x) → Select(x, Top10(x))) ::: If a game sells more than one million copies, then it will be selected into the Top 10 list.\n∀x (Top10(x) → Japanese(Create(japanese, x))) ::: All games in the Top 10 list are made by Japanese game companies.\nMoreThanOneMillion(legendOfZelda) ::: The Legend of Zelda sold more than one million copies.",
                "First-Order-Logic Question": "¬Top10(legendOfZelda) ::: The Legend of Zelda is not in the Top 10 list."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "Create(japaneseGameCompany, legendOfZelda) ::: A Japanese game company created the game the Legend of Zelda.\nGame(x,y)∧Sell(x,z)∧MoreThanOneMillion(x)→Select(x,y) ::: If a game sells more than one million copies, then it will be selected into the Top 10 list.\n∀x(Top10(x)→Japanese(x)) ::: All games in the Top 10 list are made by Japanese game companies.\nMoreThanOneMillion(legendOfZelda) ::: The Legend of Zelda sold more than one million copies.",
                "First-Order-Logic Question": "¬Top10(legendOfZelda) ::: The Legend of Zelda is not in the Top 10 list."
            },
            "diff": [
                {
                    "raw": "∀x (Game(x) ∧ MoreThanOneMillion(x) → Select(x, Top10(x))) ::: If a game sells more than one million copies, then it will be selected into the Top 10 list.",
                    "gram": "Game(x,y)∧Sell(x,z)∧MoreThanOneMillion(x)→Select(x,y) ::: If a game sells more than one million copies, then it will be selected into the Top 10 list."
                },
                {
                    "raw": "∀x (Top10(x) → Japanese(Create(japanese, x))) ::: All games in the Top 10 list are made by Japanese game companies.",
                    "gram": "∀x(Top10(x)→Japanese(x)) ::: All games in the Top 10 list are made by Japanese game companies."
                }
            ],
            "answer": "B",
            "error_type":"",
            "grammar_answer": "C"
        },
        {
            "id": 39,
            "raw_prog": {
                "First-Order-Logic Rules": "∀x (DesignStyle(x, ZahaHadid) → Timeless(x)) ::: All of Zaha Hadid's design styles are timeless. \n∀x (MassProductDesign(x) → ¬Timeless(x)) ::: No mass product design is timeless. \n(DesignStyle(ZahaHadid, y) ∨ DesignStyle(KellyWearstler, y)) ::: Either Zaha Hadid's design style or Kelly Wearstler's design style. \n∀x (DesignStyle(x, KellyWearstler) → Evocative(x)) ::: All of Kelly Wearstler's design styles are evocative. \n∀x (DesignStyle(x, KellyWearstler) → Dreamy(x)) ::: All of Kelly Wearstler's design styles are dreamy. \n∀x (Timeless(DesignBy(x, Max)) → (MassProductDesign(DesignBy(x, Max)) ∧ Evocative(DesignBy(x, Max)))) ::: If a design by Max is timeless, then a design by Max is a mass product design and evocative.\n",
                "First-Order-Logic Question": "MassProductDesign(DesignBy(Max, Max)) ::: A design by Max is a mass product design."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∀x (DesignStyle(x, ZahaHadid) → Timeless(x)) ::: All of Zaha Hadid's design styles are timeless. \n∀x (MassProductDesign(x) → ¬Timeless(x)) ::: No mass product design is timeless. \n(DesignStyle(ZahaHadid, y) ∨ DesignStyle(KellyWearstler, y)) ::: Either Zaha Hadid's design style or Kelly Wearstler's design style. \n∀x (DesignStyle(x, KellyWearstler) → Evocative(x)) ::: All of Kelly Wearstler's design styles are evocative. \n∀x (DesignStyle(x, KellyWearstler) → Dreamy(x)) ::: All of Kelly Wearstler's design styles are dreamy. \n∀x(Timeless(x)→(MassProductDesign(x))) ::: If a design by Max is timeless, then a design by Max is a mass product design and evocative.\n",
                "First-Order-Logic Question": "MassProductDesign(x)→DesignBy(x,x) ::: A design by Max is a mass product design."
            },
            "diff": [
                {
                    "raw": "∀x (Timeless(DesignBy(x, Max)) → (MassProductDesign(DesignBy(x, Max)) ∧ Evocative(DesignBy(x, Max)))) ::: If a design by Max is timeless, then a design by Max is a mass product design and evocative.",
                    "gram": "∀x(Timeless(x)→(MassProductDesign(x))) ::: If a design by Max is timeless, then a design by Max is a mass product design and evocative."
                },
                {
                    "raw": "MassProductDesign(DesignBy(Max, Max)) ::: A design by Max is a mass product design.",
                    "gram": "MassProductDesign(x)→DesignBy(x,x) ::: A design by Max is a mass product design."
                }
            ],
            "answer": "C",
            "error_type":"",
            "grammar_answer": "A"
        },
        {
            "id": 41,
            "raw_prog": {
                "First-Order-Logic Rules": "∀x (DesignStyle(x, ZahaHadid) → Timeless(x)) ::: All of Zaha Hadid's design styles are timeless.\n∀x (MassProductDesign(x) → ¬Timeless(x)) ::: No mass product design is timeless.\nDesignStyle(ZahaHadid, y) ∨ DesignStyle(KellyWearstler, y) ::: Either Zaha Hadid's design style or Kelly Wearstler's design style.\n∀x (DesignStyle(x, KellyWearstler) → Evocative(x)) ::: All of Kelly Wearstler's design styles are evocative.\n∀x (DesignStyle(x, KellyWearstler) → Dreamy(x)) ::: All of Kelly Wearstler's design styles are dreamy.\n∀x (Timeless(DesignBy(x, Max)) → (MassProductDesign(DesignBy(x, Max)) ∧ Evocative(DesignBy(x, Max)))) ::: If a design by Max is timeless, then a design by Max is a mass product design and evocative.\n",
                "First-Order-Logic Question": "Evocative(DesignBy(Max, Max)) ∨ Dreamy(DesignBy(Max, Max)) ::: A design by Max is either evocative or dreamy."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∀x (DesignStyle(x, ZahaHadid) → Timeless(x)) ::: All of Zaha Hadid's design styles are timeless.\n∀x (MassProductDesign(x) → ¬Timeless(x)) ::: No mass product design is timeless.\nDesignStyle(ZahaHadid, y) ∨ DesignStyle(KellyWearstler, y) ::: Either Zaha Hadid's design style or Kelly Wearstler's design style.\n∀x (DesignStyle(x, KellyWearstler) → Evocative(x)) ::: All of Kelly Wearstler's design styles are evocative.\n∀x (DesignStyle(x, KellyWearstler) → Dreamy(x)) ::: All of Kelly Wearstler's design styles are dreamy.\n∀x(Timeless(x)→(MassProductDesign(x))) ::: If a design by Max is timeless, then a design by Max is a mass product design and evocative.\n",
                "First-Order-Logic Question": "Evocative(x)→DesignBy(x,x)∨Dreamy(x)→DesignBy(x,x) ::: A design by Max is either evocative or dreamy."
            },
            "diff": [
                {
                    "raw": "∀x (Timeless(DesignBy(x, Max)) → (MassProductDesign(DesignBy(x, Max)) ∧ Evocative(DesignBy(x, Max)))) ::: If a design by Max is timeless, then a design by Max is a mass product design and evocative.",
                    "gram": "∀x(Timeless(x)→(MassProductDesign(x))) ::: If a design by Max is timeless, then a design by Max is a mass product design and evocative."
                },
                {
                    "raw": "Evocative(DesignBy(Max, Max)) ∨ Dreamy(DesignBy(Max, Max)) ::: A design by Max is either evocative or dreamy.",
                    "gram": "Evocative(x)→DesignBy(x,x)∨Dreamy(x)→DesignBy(x,x) ::: A design by Max is either evocative or dreamy."
                }
            ],
            "answer": "B",
            "error_type":"",
            "grammar_answer": "A"
        },
        {
            "id": 79,
            "raw_prog": {
                "First-Order-Logic Rules": "¬(∃x (Bakery(x) ∧ Spicy(x))) ::: No bakery is spicy.\n∀x (Cupcake(x) → Bakery(x)) ::: All cupcakes are bakeries.\n∀x (Hotpot(x) → Spicy(x)) ::: All hotpots are spicy.\n∀x (Product(BakedByMelissa(x), x) → Cupcake(x)) ::: All products of Baked by Melissa are cupcakes.\n(DriedThaiChilies(driedthaichilies) ∨ Bakery(driedthaichilies)) → (Hotpot(driedthaichilies) ∨ Spicy(driedthaichilies)) ::: If dried Thai chilies are spicy or a bakery, then dried Thai chilies are a hotpot or are spicy.\n",
                "First-Order-Logic Question": "Product(driedthaichilies, BakedByMelissa) ::: Dried Thai chilies are a product of Baked by Melissa."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "¬(∃x (Bakery(x) ∧ Spicy(x))) ::: No bakery is spicy.\n∀x (Cupcake(x) → Bakery(x)) ::: All cupcakes are bakeries.\n∀x (Hotpot(x) → Spicy(x)) ::: All hotpots are spicy.\n∀x(Product(x,y)→Cupcake(x)) ::: All products of Baked by Melissa are cupcakes.\n(DriedThaiChilies(driedthaichilies) ∨ Bakery(driedthaichilies)) → (Hotpot(driedthaichilies) ∨ Spicy(driedthaichilies)) ::: If dried Thai chilies are spicy or a bakery, then dried Thai chilies are a hotpot or are spicy.\n",
                "First-Order-Logic Question": "Product(driedthaichilies, BakedByMelissa) ::: Dried Thai chilies are a product of Baked by Melissa."
            },
            "diff": [
                {
                    "raw": "∀x (Product(BakedByMelissa(x), x) → Cupcake(x)) ::: All products of Baked by Melissa are cupcakes.",
                    "gram": "∀x(Product(x,y)→Cupcake(x)) ::: All products of Baked by Melissa are cupcakes."
                }
            ],
            "answer": "B",
            "error_type":"",
            "grammar_answer": "B"
        },
        {
            "id": 85,
            "raw_prog": {
                "First-Order-Logic Rules": "∀x (Listed(x) → ¬NotNegative(x)) ::: If the restaurant is listed in Yelp’s recommendations, then the restaurant does not receive many negative reviews.\n∀x (Rating(x, y) ∧ y > 9 → Listed(x)) ::: All restaurants with a rating greater than 9 are listed in Yelp’s recommendations.\n∃x (Restaurant(x) ∧ ¬Provide(x, takeout) → NotNegative(x)) ::: Some restaurants that do not provide take-out service receive many negative reviews.\n∀x (Popular(x) → Rating(x, y) ∧ y > 9) ::: All restaurants that are popular among local residents have ratings greater than 9.\nRating(subway, y) ∨ Popular(subway) ::: Subway has a rating greater than 9 or is popular among local residents.\n",
                "First-Order-Logic Question": "TakeOut(subway) ∧ ¬NotNegative(subway) ::: Subway provides take-out service and does not receive many negative reviews."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∀x (Listed(x) → ¬NotNegative(x)) ::: If the restaurant is listed in Yelp’s recommendations, then the restaurant does not receive many negative reviews.\n∀x(Rating(x,y)∧(NotNegative(x))) ::: All restaurants with a rating greater than 9 are listed in Yelp’s recommendations.\n∃x (Restaurant(x) ∧ ¬Provide(x, takeout) → NotNegative(x)) ::: Some restaurants that do not provide take-out service receive many negative reviews.\n∀x(Popular(x)→Rating(x,y)∧(Rating(x,y))) ::: All restaurants that are popular among local residents have ratings greater than 9.\nRating(subway, y) ∨ Popular(subway) ::: Subway has a rating greater than 9 or is popular among local residents.\n",
                "First-Order-Logic Question": "TakeOut(subway) ∧ ¬NotNegative(subway) ::: Subway provides take-out service and does not receive many negative reviews."
            },
            "diff": [
                {
                    "raw": "∀x (Rating(x, y) ∧ y > 9 → Listed(x)) ::: All restaurants with a rating greater than 9 are listed in Yelp’s recommendations.",
                    "gram": "∀x(Rating(x,y)∧(NotNegative(x))) ::: All restaurants with a rating greater than 9 are listed in Yelp’s recommendations."
                },
                {
                    "raw": "∀x (Popular(x) → Rating(x, y) ∧ y > 9) ::: All restaurants that are popular among local residents have ratings greater than 9.",
                    "gram": "∀x(Popular(x)→Rating(x,y)∧(Rating(x,y))) ::: All restaurants that are popular among local residents have ratings greater than 9."
                }
            ],
            "answer": "A",
            "error_type":"",
            "grammar_answer": "B"
        },
        {
            "id": 87,
            "raw_prog": {
                "First-Order-Logic Rules": "∀x (SuperheroMovie(x) → Win(GoodGuy(x))) ::: In superhero movies, the good guys always win.\nSuperheroMovie(sir_digby) ∧ NamedAfter(sir_digby, sir_digby) ::: The Surprising Adventures of Sir Digby Chicken Caesar is a superhero movie.\n∀x (GoodGuy(x) → Fight(x, BadGuy(x)) ∧ Fight(BadGuy(x), x)) ::: Good guys fight bad guys and vice versa.\nFight(sir_digby, nemesis) ::: Sir Digby fights his nemesis.\n∀x (SuperheroMovie(x) ∧ NamedAfter(x, character) → GoodGuy(character)) ::: If a superhero movie is named after a character, that character is a good guy.\nNamedAfter(sir_digby, sir_digby) ::: The Surprising Adventures of Sir Digby Chicken Caesar is named after Sir Digby.\n∀x ∀y (Win(x) → Lose(y)) ::: If somebody wins a fight, the person they are fighting loses.\n∀x ∀y (SuperheroMovie(x) ∧ NamedAfter(x, y) → AppearIn(y, x)) ::: If a superhero movie is named after a character, that character appears in the movie.\n",
                "First-Order-Logic Question": "Lose(nemesis) ::: Sir Digby’s nemesis loses."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∀x(SuperheroMovie(x)→Win(x)) ::: In superhero movies, the good guys always win.\nSuperheroMovie(sir_digby) ∧ NamedAfter(sir_digby, sir_digby) ::: The Surprising Adventures of Sir Digby Chicken Caesar is a superhero movie.\n∀x(GoodGuy(x)→Fight(x,y)∧Fight(y,x)) ::: Good guys fight bad guys and vice versa.\nFight(sir_digby, nemesis) ::: Sir Digby fights his nemesis.\n∀x (SuperheroMovie(x) ∧ NamedAfter(x, character) → GoodGuy(character)) ::: If a superhero movie is named after a character, that character is a good guy.\nNamedAfter(sir_digby, sir_digby) ::: The Surprising Adventures of Sir Digby Chicken Caesar is named after Sir Digby.\n∀x ∀y (Win(x) → Lose(y)) ::: If somebody wins a fight, the person they are fighting loses.\n∀x ∀y (SuperheroMovie(x) ∧ NamedAfter(x, y) → AppearIn(y, x)) ::: If a superhero movie is named after a character, that character appears in the movie.\n",
                "First-Order-Logic Question": "Lose(nemesis) ::: Sir Digby’s nemesis loses."
            },
            "diff": [
                {
                    "raw": "∀x (SuperheroMovie(x) → Win(GoodGuy(x))) ::: In superhero movies, the good guys always win.",
                    "gram": "∀x(SuperheroMovie(x)→Win(x)) ::: In superhero movies, the good guys always win."
                },
                {
                    "raw": "∀x (GoodGuy(x) → Fight(x, BadGuy(x)) ∧ Fight(BadGuy(x), x)) ::: Good guys fight bad guys and vice versa.",
                    "gram": "∀x(GoodGuy(x)→Fight(x,y)∧Fight(y,x)) ::: Good guys fight bad guys and vice versa."
                }
            ],
            "answer": "A",
            "error_type":"",
            "grammar_answer": "A"
        },
        {
            "id": 114,
            "raw_prog": {
                "First-Order-Logic Rules": "MountainRange(picurismountains) ∨ MountainRange(picurismountains) ::: The Picuris Mountains are a mountain range in New Mexico or Texas.\nVisited(juandeonate, picurismountains) ::: Juan de Onate visited the Picuris Mountains.\nLocatedIn(hardingpegmatitemine, picurismountains) ∧ Donated(hardingpegmatitemine) ::: The Harding Pegmatite Mine, located in the Picuris Mountains, was donated.\n∀x (MountainRange(x) ∧ In(x, texas) → ¬∃y (Mine(y) ∧ Has(y, donated) ∧ LocatedIn(y, x))) ::: There are no mountain ranges in Texas that have mines which have been donated.\n",
                "First-Order-Logic Question": "NotLocatedIn(hardingpegmatitemine, newmexico) ::: The Harding Pegmatite Mine is not located in a mountain range in New Mexico."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "MountainRange(picurismountains) ∨ MountainRange(picurismountains) ::: The Picuris Mountains are a mountain range in New Mexico or Texas.\nVisited(juandeonate, picurismountains) ::: Juan de Onate visited the Picuris Mountains.\nLocatedIn(hardingpegmatitemine, picurismountains) ∧ Donated(hardingpegmatitemine) ::: The Harding Pegmatite Mine, located in the Picuris Mountains, was donated.\n∀x(MountainRange(x)∧In(x,y)→¬(Mine(y))) ::: There are no mountain ranges in Texas that have mines which have been donated.\n",
                "First-Order-Logic Question": "NotLocatedIn(hardingpegmatitemine, newmexico) ::: The Harding Pegmatite Mine is not located in a mountain range in New Mexico."
            },
            "diff": [
                {
                    "raw": "∀x (MountainRange(x) ∧ In(x, texas) → ¬∃y (Mine(y) ∧ Has(y, donated) ∧ LocatedIn(y, x))) ::: There are no mountain ranges in Texas that have mines which have been donated.",
                    "gram": "∀x(MountainRange(x)∧In(x,y)→¬(Mine(y))) ::: There are no mountain ranges in Texas that have mines which have been donated."
                }
            ],
            "answer": "B",
            "error_type":"",
            "grammar_answer": "C"
        }
    ],
    "gcd_llama-2-13b_4": [
        {
            "id": 41,
            "raw_prog": {
                "First-Order-Logic Rules": [
                    "∀x (ZahaHadid(x) → Timeless(x)) ::: All of Zaha Hadid's design styles are timeless.",
                    "∀x (MassProduct(x) → ¬Timeless(x)) ::: No mass product design is timeless.",
                    "∀x (ZahaHadid(x) ∨ KellyWearstler(x)) ::: Either Zaha Hadid's design style or Kelly Wearstler's design style.",
                    "∀x (KellyWearstler(x) → Evocative(x)) ::: All of Kelly Wearstler's design styles are evocative.",
                    "∀x (KellyWearstler(x) → Dreamy(x)) ::: All of Kelly Wearstler's design styles are dreamy.",
                    "∀x (Timeless(Max(x)) → (MassProduct(Max(x)) ∧ Evocative(Max(x)))) ::: If a design by Max is timeless, then a design by Max is a mass product design and evocative."
                ],
                "First-Order-Logic Question": [
                    "Evocative(Max(x)) ∨ Dreamy(Max(x)) ::: A design by Max is either evocative or dreamy."
                ]
            },
            "gram_prog": {
                "First-Order-Logic Rules": [
                    "∀x (ZahaHadid(x) → Timeless(x)) ::: All of Zaha Hadid's design styles are timeless.",
                    "∀x (MassProduct(x) → ¬Timeless(x)) ::: No mass product design is timeless.",
                    "∀x (ZahaHadid(x) ∨ KellyWearstler(x)) ::: Either Zaha Hadid's design style or Kelly Wearstler's design style.",
                    "∀x (KellyWearstler(x) → Evocative(x)) ::: All of Kelly Wearstler's design styles are evocative.",
                    "∀x (KellyWearstler(x) → Dreamy(x)) ::: All of Kelly Wearstler's design styles are dreamy.",
                    "∀x(Timeless(x)→(MassProduct(x))) ::: If a design by Max is timeless, then a design by Max is a mass product design and evocative."
                ],
                "First-Order-Logic Question": [
                    "Evocative(x)∨Dreamy(x) ::: A design by Max is either evocative or dreamy."
                ]
            },
            "diff": [
                {
                    "raw": "∀x (Timeless(Max(x)) → (MassProduct(Max(x)) ∧ Evocative(Max(x)))) ::: If a design by Max is timeless, then a design by Max is a mass product design and evocative.",
                    "gram": "∀x(Timeless(x)→(MassProduct(x))) ::: If a design by Max is timeless, then a design by Max is a mass product design and evocative."
                },
                {
                    "raw": "Evocative(Max(x)) ∨ Dreamy(Max(x)) ::: A design by Max is either evocative or dreamy.",
                    "gram": "Evocative(x)∨Dreamy(x) ::: A design by Max is either evocative or dreamy."
                }
            ],
            "answer": "B",
            "error_type":"",
            "grammar_answer": "A"
        },
        {
            "id": 46,
            "raw_prog": {
                "First-Order-Logic Rules": "∀x (Season(Spring(x)) ∧ Season(Summer(x)) ∧ Season(Fall(x)) ∧ Season(Winter(x))) ::: There are four seasons in a year: Spring, Summer, Fall, and Winter.\n∀x (WantLongVacation(x) → LoveMost(x, Summer)) ::: All students who want to have a long vacation love summer the most.\nFavoriteSeason(emma, Summer) ::: Emma's favorite season is summer.\n∀x (FavoriteSeason(mia, y) → ¬FavoriteSeason(mia, Summer)) ::: Mia's favorite season is not the same as Emma's.\nWantLongVacation(james) ::: James wants to have a long vacation.\n",
                "First-Order-Logic Question": "FavoriteSeason(james, Summer) ::: James's favorite season is summer."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∀x(Season(x)∧(Spring(x))) ::: There are four seasons in a year: Spring, Summer, Fall, and Winter.\n∀x (WantLongVacation(x) → LoveMost(x, Summer)) ::: All students who want to have a long vacation love summer the most.\nFavoriteSeason(emma, Summer) ::: Emma's favorite season is summer.\n∀x (FavoriteSeason(mia, y) → ¬FavoriteSeason(mia, Summer)) ::: Mia's favorite season is not the same as Emma's.\nWantLongVacation(james) ::: James wants to have a long vacation.\n",
                "First-Order-Logic Question": "FavoriteSeason(james, Summer) ::: James's favorite season is summer."
            },
            "diff": [
                {
                    "raw": "∀x (Season(Spring(x)) ∧ Season(Summer(x)) ∧ Season(Fall(x)) ∧ Season(Winter(x))) ::: There are four seasons in a year: Spring, Summer, Fall, and Winter.",
                    "gram": "∀x(Season(x)∧(Spring(x))) ::: There are four seasons in a year: Spring, Summer, Fall, and Winter."
                }
            ],
            "answer": "A",
            "error_type":"",
            "grammar_answer": "C"
        },
        {
            "id": 47,
            "raw_prog": {
                "First-Order-Logic Rules": "∀x (Season(Spring(x)) ∧ Season(Summer(x)) ∧ Season(Fall(x)) ∧ Season(Winter(x))) ::: There are four seasons in a year: Spring, Summer, Fall, and Winter. \n∀x (WantsLongVacation(x) → LovesMost(x, Summer)) ::: All students who want to have a long vacation love summer the most. \nFavoriteSeason(emma, Summer) ::: Emma's favorite season is summer. \n∀x (FavoriteSeason(mia, y) → ¬FavoriteSeason(mia, Summer)) ::: Mia's favorite season is not the same as Emma's. \nWantsLongVacation(james) ::: James wants to have a long vacation.\n",
                "First-Order-Logic Question": "FavoriteSeason(james, Fall) ::: James's favorite season is fall."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∀x(Season(x)∧(Spring(x))) ::: There are four seasons in a year: Spring, Summer, Fall, and Winter. \n∀x (WantsLongVacation(x) → LovesMost(x, Summer)) ::: All students who want to have a long vacation love summer the most. \nFavoriteSeason(emma, Summer) ::: Emma's favorite season is summer. \n∀x (FavoriteSeason(mia, y) → ¬FavoriteSeason(mia, Summer)) ::: Mia's favorite season is not the same as Emma's. \nWantsLongVacation(james) ::: James wants to have a long vacation.\n",
                "First-Order-Logic Question": "FavoriteSeason(james, Fall) ::: James's favorite season is fall."
            },
            "diff": [
                {
                    "raw": "∀x (Season(Spring(x)) ∧ Season(Summer(x)) ∧ Season(Fall(x)) ∧ Season(Winter(x))) ::: There are four seasons in a year: Spring, Summer, Fall, and Winter. ",
                    "gram": "∀x(Season(x)∧(Spring(x))) ::: There are four seasons in a year: Spring, Summer, Fall, and Winter. "
                }
            ],
            "answer": "C",
            "error_type":"",
            "grammar_answer": "C"
        },
        {
            "id": 70,
            "raw_prog": {
                "First-Order-Logic Rules": [
                    "British(badults) ∧ Sitcom(badults) ∧ ∀x (MemberOf(x, pappys) → Star(x, badults)) ::: Badults is a British Sitcom series, starring members of Pappy's.",
                    "Pilot(badults, 2013) ∧ Network(badults, bbcthree) ::: Badults piloted in July 2013 on BBC Three.",
                    "WorkingTitle(badults, thesecretdudesociety) ::: The Working title 'The Secret Dude Society' was used for Badults.",
                    "ScriptEditor(andrewcollins, badults) ::: Andrew Collins was the script editor for Badults."
                ],
                "First-Order-Logic Question": [
                    "∀x (MemberOf(x, pappys) → ¬∃y (Star(x, y) ∧ (Network(y, bbctwo) ∨ Network(y, bbcthree)))) ::: No members of Pappy's have starred for a show piloting on BBC Two or BBC Three."
                ]
            },
            "gram_prog": {
                "First-Order-Logic Rules": [
                    "British(badults) ∧ Sitcom(badults) ∧ ∀x (MemberOf(x, pappys) → Star(x, badults)) ::: Badults is a British Sitcom series, starring members of Pappy's.",
                    "Pilot(badults, 2013) ∧ Network(badults, bbcthree) ::: Badults piloted in July 2013 on BBC Three.",
                    "WorkingTitle(badults, thesecretdudesociety) ::: The Working title 'The Secret Dude Society' was used for Badults.",
                    "ScriptEditor(andrewcollins, badults) ::: Andrew Collins was the script editor for Badults."
                ],
                "First-Order-Logic Question": [
                    "∀x(MemberOf(x,y)→¬(Star(x,y))) ::: No members of Pappy's have starred for a show piloting on BBC Two or BBC Three."
                ]
            },
            "diff": [
                {
                    "raw": "∀x (MemberOf(x, pappys) → ¬∃y (Star(x, y) ∧ (Network(y, bbctwo) ∨ Network(y, bbcthree)))) ::: No members of Pappy's have starred for a show piloting on BBC Two or BBC Three.",
                    "gram": "∀x(MemberOf(x,y)→¬(Star(x,y))) ::: No members of Pappy's have starred for a show piloting on BBC Two or BBC Three."
                }
            ],
            "answer": "B",
            "error_type":"",
            "grammar_answer": "C"
        },
        {
            "id": 93,
            "raw_prog": {
                "First-Order-Logic Rules": [
                    "∃x (Pet(x) ∧ ManagedBuilding(y) ∧ AllowedIn(x, y)) ::: Pets are allowed in some managed buildings.",
                    "∀x (ManagedBuilding(x) → DepositRequired(x)) ::: A deposit is required to rent an apartment in a managed building.",
                    "∀x ∀y (SecurityDeposit(x, y) → EqualOrMore(y, MonthlyRent(x, 1))) ::: The security deposit can be either equal to one month's rent or more.",
                    "Cat(fluffy) ∧ Owner(tom, fluffy) ::: Fluffy is Tom's cat.",
                    "∀x (Cat(x) → Pet(x)) ::: Cats are pets.",
                    "ManagedBuilding(olivegarden) ::: The Olive Garden is a managed building.",
                    "MonthlyRent(olivegarden, 2000) ::: The monthly rent at the Olive Garden is $2000.",
                    "∀x ∀y (Owner(x, y) ∧ Pet(y) ∧ ManagedBuilding(z) ∧ AllowedIn(y, z) ∧ SecurityDeposit(z, d) ∧ d ≤ 1500 ↔ Rent(x, z)) ::: Tom will rent an apartment in a managed building if and only if he is allowed to move in with Fluffy, and the security deposit is no more than $1500.",
                    "EqualOrMore(2000, 1500) ::: 2000$ is more than $1500."
                ],
                "First-Order-Logic Question": [
                    "Rent(tom, olivegarden) ::: Tom will rent an apartment in The Olive Garden."
                ]
            },
            "gram_prog": {
                "First-Order-Logic Rules": [
                    "∃x (Pet(x) ∧ ManagedBuilding(y) ∧ AllowedIn(x, y)) ::: Pets are allowed in some managed buildings.",
                    "∀x (ManagedBuilding(x) → DepositRequired(x)) ::: A deposit is required to rent an apartment in a managed building.",
                    "∀x∀y(SecurityDeposit(x,y)→EqualOrMore(y,x)) ::: The security deposit can be either equal to one month's rent or more.",
                    "Cat(fluffy) ∧ Owner(tom, fluffy) ::: Fluffy is Tom's cat.",
                    "∀x (Cat(x) → Pet(x)) ::: Cats are pets.",
                    "ManagedBuilding(olivegarden) ::: The Olive Garden is a managed building.",
                    "MonthlyRent(olivegarden, 2000) ::: The monthly rent at the Olive Garden is $2000.",
                    "∀x∀y(Owner(x,y)∧Pet(y)∧ManagedBuilding(z)∧AllowedIn(y,z)) ::: Tom will rent an apartment in a managed building if and only if he is allowed to move in with Fluffy, and the security deposit is no more than $1500.",
                    "EqualOrMore(2000, 1500) ::: 2000$ is more than $1500."
                ],
                "First-Order-Logic Question": [
                    "Rent(tom, olivegarden) ::: Tom will rent an apartment in The Olive Garden."
                ]
            },
            "diff": [
                {
                    "raw": "∀x ∀y (SecurityDeposit(x, y) → EqualOrMore(y, MonthlyRent(x, 1))) ::: The security deposit can be either equal to one month's rent or more.",
                    "gram": "∀x∀y(SecurityDeposit(x,y)→EqualOrMore(y,x)) ::: The security deposit can be either equal to one month's rent or more."
                },
                {
                    "raw": "∀x ∀y (Owner(x, y) ∧ Pet(y) ∧ ManagedBuilding(z) ∧ AllowedIn(y, z) ∧ SecurityDeposit(z, d) ∧ d ≤ 1500 ↔ Rent(x, z)) ::: Tom will rent an apartment in a managed building if and only if he is allowed to move in with Fluffy, and the security deposit is no more than $1500.",
                    "gram": "∀x∀y(Owner(x,y)∧Pet(y)∧ManagedBuilding(z)∧AllowedIn(y,z)) ::: Tom will rent an apartment in a managed building if and only if he is allowed to move in with Fluffy, and the security deposit is no more than $1500."
                }
            ],
            "answer": "B",
            "error_type":"",
            "grammar_answer": "C"
        },
        {
            "id": 94,
            "raw_prog": {
                "First-Order-Logic Rules": [
                    "∃x (ManagedBuilding(x) ∧ Pet(y) ∧ AllowedIn(y, x)) ::: Pets are allowed in some managed buildings.",
                    "∀x (ManagedBuilding(x) → DepositRequired(x)) ::: A deposit is required to rent an apartment in a managed building.",
                    "∀x ∀y (SecurityDeposit(x, y) → EqualOrMore(y, MonthlyRent(x, 1))) ::: The security deposit can be either equal to one month's rent or more.",
                    "Cat(fluffy) ∧ Owner(tom, fluffy) ::: Fluffy is Tom's cat.",
                    "∀x (Cat(x) → Pet(x)) ::: Cats are pets.",
                    "ManagedBuilding(olivegarden) ::: The Olive Garden is a managed building.",
                    "MonthlyRent(olivegarden, 2000) ::: The monthly rent at the Olive Garden is $2000.",
                    "∀x ∀y ∀z (Owner(y, z) ∧ ManagedBuilding(x) ∧ AllowedIn(z, x) ∧ SecurityDeposit(x, w) ∧ w ≤ 1500 ↔ MoveInWith(y, z, x)) ::: Tom will rent an apartment in a managed building if and only if he is allowed to move in with Fluffy, and the security deposit is no more than $1500.",
                    "EqualOrMore(2000, 1500) ::: 2000$ is more than $1500."
                ],
                "First-Order-Logic Question": [
                    "MoveInWith(tom, fluffy, olivegarden) ::: Tom is allowed to move in an apartment in The Olive Garden with Fluffy."
                ]
            },
            "gram_prog": {
                "First-Order-Logic Rules": [
                    "∃x (ManagedBuilding(x) ∧ Pet(y) ∧ AllowedIn(y, x)) ::: Pets are allowed in some managed buildings.",
                    "∀x (ManagedBuilding(x) → DepositRequired(x)) ::: A deposit is required to rent an apartment in a managed building.",
                    "∀x∀y(SecurityDeposit(x,y)→EqualOrMore(y,x)) ::: The security deposit can be either equal to one month's rent or more.",
                    "Cat(fluffy) ∧ Owner(tom, fluffy) ::: Fluffy is Tom's cat.",
                    "∀x (Cat(x) → Pet(x)) ::: Cats are pets.",
                    "ManagedBuilding(olivegarden) ::: The Olive Garden is a managed building.",
                    "MonthlyRent(olivegarden, 2000) ::: The monthly rent at the Olive Garden is $2000.",
                    "∀x∀y∀z(Owner(y,z)∧ManagedBuilding(x)∧AllowedIn(z,x)∧SecurityDeposit(x,y)) ::: Tom will rent an apartment in a managed building if and only if he is allowed to move in with Fluffy, and the security deposit is no more than $1500.",
                    "EqualOrMore(2000, 1500) ::: 2000$ is more than $1500."
                ],
                "First-Order-Logic Question": [
                    "MoveInWith(tom, fluffy, olivegarden) ::: Tom is allowed to move in an apartment in The Olive Garden with Fluffy."
                ]
            },
            "diff": [
                {
                    "raw": "∀x ∀y (SecurityDeposit(x, y) → EqualOrMore(y, MonthlyRent(x, 1))) ::: The security deposit can be either equal to one month's rent or more.",
                    "gram": "∀x∀y(SecurityDeposit(x,y)→EqualOrMore(y,x)) ::: The security deposit can be either equal to one month's rent or more."
                },
                {
                    "raw": "∀x ∀y ∀z (Owner(y, z) ∧ ManagedBuilding(x) ∧ AllowedIn(z, x) ∧ SecurityDeposit(x, w) ∧ w ≤ 1500 ↔ MoveInWith(y, z, x)) ::: Tom will rent an apartment in a managed building if and only if he is allowed to move in with Fluffy, and the security deposit is no more than $1500.",
                    "gram": "∀x∀y∀z(Owner(y,z)∧ManagedBuilding(x)∧AllowedIn(z,x)∧SecurityDeposit(x,y)) ::: Tom will rent an apartment in a managed building if and only if he is allowed to move in with Fluffy, and the security deposit is no more than $1500."
                }
            ],
            "answer": "C",
            "error_type":"",
            "grammar_answer": "C"
        },
        {
            "id": 95,
            "raw_prog": {
                "First-Order-Logic Rules": [
                    "∃x (ManagedBuilding(x) ∧ Pet(y) ∧ AllowedIn(y, x)) ::: Pets are allowed in some managed buildings.",
                    "∀x (ManagedBuilding(x) → DepositRequired(x)) ::: A deposit is required to rent an apartment in a managed building.",
                    "∀x ∀y (SecurityDeposit(x, y) → (EqualOrMore(y, MonthlyRent(x, 1)) ∨ EqualOrMore(y, MonthlyRent(x, 2)))) ::: The security deposit can be either equal to one month's rent or more.",
                    "Cat(fluffy) ∧ Owner(tom, fluffy) ::: Fluffy is Tom's cat.",
                    "∀x (Cat(x) → Pet(x)) ::: Cats are pets.",
                    "ManagedBuilding(olivegarden) ::: The Olive Garden is a managed building.",
                    "MonthlyRent(olivegarden, 2000) ::: The monthly rent at the Olive Garden is $2000.",
                    "∀x ∀y (Owner(tom, fluffy) ∧ ManagedBuilding(x) ∧ (AllowedIn(fluffy, x) ∧ SecurityDeposit(x, y) ∧ EqualOrMore(1500, y)) ↔ Rent(tom, x)) ::: Tom will rent an apartment in a managed building if and only if he is allowed to move in with Fluffy, and the security deposit is no more than $1500.",
                    "EqualOrMore(2000, 1500) ::: 2000$ is more than $1500."
                ],
                "First-Order-Logic Question": [
                    "SecurityDeposit(olivegarden, 2000) ∨ ∃y (SecurityDeposit(olivegarden, y) ∧ EqualOrMore(y, 2000)) ::: The security deposit at the Olive Garden is either $2000 or more."
                ]
            },
            "gram_prog": {
                "First-Order-Logic Rules": [
                    "∃x (ManagedBuilding(x) ∧ Pet(y) ∧ AllowedIn(y, x)) ::: Pets are allowed in some managed buildings.",
                    "∀x (ManagedBuilding(x) → DepositRequired(x)) ::: A deposit is required to rent an apartment in a managed building.",
                    "∀x∀y(SecurityDeposit(x,y)→(EqualOrMore(y,x))) ::: The security deposit can be either equal to one month's rent or more.",
                    "Cat(fluffy) ∧ Owner(tom, fluffy) ::: Fluffy is Tom's cat.",
                    "∀x (Cat(x) → Pet(x)) ::: Cats are pets.",
                    "ManagedBuilding(olivegarden) ::: The Olive Garden is a managed building.",
                    "MonthlyRent(olivegarden, 2000) ::: The monthly rent at the Olive Garden is $2000.",
                    "∀x ∀y (Owner(tom, fluffy) ∧ ManagedBuilding(x) ∧ (AllowedIn(fluffy, x) ∧ SecurityDeposit(x, y) ∧ EqualOrMore(1500, y)) ↔ Rent(tom, x)) ::: Tom will rent an apartment in a managed building if and only if he is allowed to move in with Fluffy, and the security deposit is no more than $1500.",
                    "EqualOrMore(2000, 1500) ::: 2000$ is more than $1500."
                ],
                "First-Order-Logic Question": [
                    "SecurityDeposit(olivegarden, 2000) ∨ ∃y (SecurityDeposit(olivegarden, y) ∧ EqualOrMore(y, 2000)) ::: The security deposit at the Olive Garden is either $2000 or more."
                ]
            },
            "diff": [
                {
                    "raw": "∀x ∀y (SecurityDeposit(x, y) → (EqualOrMore(y, MonthlyRent(x, 1)) ∨ EqualOrMore(y, MonthlyRent(x, 2)))) ::: The security deposit can be either equal to one month's rent or more.",
                    "gram": "∀x∀y(SecurityDeposit(x,y)→(EqualOrMore(y,x))) ::: The security deposit can be either equal to one month's rent or more."
                }
            ],
            "answer": "A",
            "error_type":"",
            "grammar_answer": "C"
        },
        {
            "id": 113,
            "raw_prog": {
                "First-Order-Logic Rules": [
                    "MountainRange(picurismountains) ∧ (In(picurismountains, newmexico) ⊕ In(picurismountains, texas)) ::: The Picuris Mountains are a mountain range in New Mexico or Texas.",
                    "Visit(juandeonate, picurismountains) ::: Juan de Onate visited the Picuris Mountains.",
                    "Mine(hardingpegmatitemine) ∧ LocatedIn(hardingpegmatitemine, picurismountains) ∧ Donate(hardingpegmatitemine) ::: The Harding Pegmatite Mine, located in the Picuris Mountains, was donated.",
                    "∀x (MountainRange(x) ∧ In(x, texas) → ¬∃y (Mine(y) ∧ LocatedIn(y, x) ∧ Donate(y))) ::: There are no mountain ranges in Texas that have mines which have been donated."
                ],
                "First-Order-Logic Question": "∃x (MountainRange(x) ∧ In(x, texas) ∧ Visit(juandeonate, x)) ::: Juan de Onate visited a mountain range in Texas."
            },
            "gram_prog": {
                "First-Order-Logic Rules": [
                    "MountainRange(picurismountains) ∧ (In(picurismountains, newmexico) ⊕ In(picurismountains, texas)) ::: The Picuris Mountains are a mountain range in New Mexico or Texas.",
                    "Visit(juandeonate, picurismountains) ::: Juan de Onate visited the Picuris Mountains.",
                    "Mine(hardingpegmatitemine) ∧ LocatedIn(hardingpegmatitemine, picurismountains) ∧ Donate(hardingpegmatitemine) ::: The Harding Pegmatite Mine, located in the Picuris Mountains, was donated.",
                    "∀x(MountainRange(x)∧In(x,y)→¬(Mine(y))) ::: There are no mountain ranges in Texas that have mines which have been donated."
                ],
                "First-Order-Logic Question": "∃x (MountainRange(x) ∧ In(x, texas) ∧ Visit(juandeonate, x)) ::: Juan de Onate visited a mountain range in Texas."
            },
            "diff": [
                {
                    "raw": "∀x (MountainRange(x) ∧ In(x, texas) → ¬∃y (Mine(y) ∧ LocatedIn(y, x) ∧ Donate(y))) ::: There are no mountain ranges in Texas that have mines which have been donated.",
                    "gram": "∀x(MountainRange(x)∧In(x,y)→¬(Mine(y))) ::: There are no mountain ranges in Texas that have mines which have been donated."
                }
            ],
            "answer": "C",
            "error_type":"",
            "grammar_answer": "C"
        },
        {
            "id": 122,
            "raw_prog": {
                "First-Order-Logic Rules": "∀x (TransportMultiplePassengers(x) → ¬Empty(x)) ::: If something can transport multiple passengers, then they are not empty.\n∀x (Airline(x) → TransportMultiplePassengers(x)) ::: All airlines can transport multiple passengers.\n∀x (Plane(x) → Empty(x)) ::: All planes are empty.\n∀x (Boeing707(x) → Plane(x)) ::: All Boeing 707s are planes.\n¬Airline(greyhound) → ¬∃y (Plane(y) ∧ Greyhound(y)) ::: If Greyhound is not an airline, then there are no Greyhound planes.\n",
                "First-Order-Logic Question": "Airline(greyhound) ::: Greyhound is an airline."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∀x (TransportMultiplePassengers(x) → ¬Empty(x)) ::: If something can transport multiple passengers, then they are not empty.\n∀x (Airline(x) → TransportMultiplePassengers(x)) ::: All airlines can transport multiple passengers.\n∀x (Plane(x) → Empty(x)) ::: All planes are empty.\n∀x (Boeing707(x) → Plane(x)) ::: All Boeing 707s are planes.\n¬Airline(greyhound) → ¬(Plane(y) ∧ IsGreyhound(y)) ::: If Greyhound is not an airline, then there are no Greyhound planes.",
                "First-Order-Logic Question": "Airline(greyhound) ::: Greyhound is an airline."
            },
            "diff": [],
            "answer": "C",
            "error_type":"",
            "grammar_answer": "C"
        },
        {
            "id": 123,
            "raw_prog": {
                "First-Order-Logic Rules": "∀x (TransportMultiplePassengers(x) → ¬Empty(x)) ::: If something can transport multiple passengers, then they are not empty.\n∀x (Airline(x) → TransportMultiplePassengers(x)) ::: All airlines can transport multiple passengers.\n∀x (Plane(x) → Empty(x)) ::: All planes are empty.\n∀x (Boeing707(x) → Plane(x)) ::: All Boeing 707s are planes.\n¬Airline(greyhound) → ¬∃y (Greyhound(y) ∧ Plane(y)) ::: If Greyhound is not an airline, then there are no Greyhound planes.\n",
                "First-Order-Logic Question": "Boeing707(greyhound) ::: A Greyhound is a Boeing 707."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∀x (TransportMultiplePassengers(x) → ¬Empty(x)) ::: If something can transport multiple passengers, then they are not empty.\n∀x (Airline(x) → TransportMultiplePassengers(x)) ::: All airlines can transport multiple passengers.\n∀x (Plane(x) → Empty(x)) ::: All planes are empty.\n∀x (Boeing707(x) → Plane(x)) ::: All Boeing 707s are planes.\n¬Airline(greyhound) → ¬(Plane(y) ∧ GreyhoundPlane(y)) ::: If Greyhound is not an airline, then there are no Greyhound planes.",
                "First-Order-Logic Question": "Boeing707(greyhound) ::: A Greyhound is a Boeing 707."
            },
            "diff": [],
            "answer": "B",
            "error_type":"",
            "grammar_answer": "C"
        },
        {
            "id": 124,
            "raw_prog": {
                "First-Order-Logic Rules": "∀x (TransportMultiplePassengers(x) → ¬Empty(x)) ::: If something can transport multiple passengers, then they are not empty.\n∀x (Airline(x) → TransportMultiplePassengers(x)) ::: All airlines can transport multiple passengers.\n∀x (Plane(x) → Empty(x)) ::: All planes are empty.\n∀x (Boeing707(x) → Plane(x)) ::: All Boeing 707s are planes.\n¬Airline(greyhound) → ¬∃y (Greyhound(y) ∧ Plane(y)) ::: If Greyhound is not an airline, then there are no Greyhound planes.\n",
                "First-Order-Logic Question": "¬Greyhound(boeing707) ::: A Greyhound is not a Boeing 707."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∀x (TransportMultiplePassengers(x) → ¬Empty(x)) ::: If something can transport multiple passengers, then they are not empty.\n∀x (Airline(x) → TransportMultiplePassengers(x)) ::: All airlines can transport multiple passengers.\n∀x (Plane(x) → Empty(x)) ::: All planes are empty.\nPlane(boeing707) ::: Boeing 707 is a plane.\n¬Airline(x) → ¬(Plane(y) ∧ Greyhound(y)) ::: If Greyhound is not an airline, then there are no Greyhound planes.\n",
                "First-Order-Logic Question": "¬Greyhound(boeing707) ::: A Greyhound is not a Boeing 707."
            },
            "diff": [
                {
                    "raw": "∀x (Boeing707(x) → Plane(x)) ::: All Boeing 707s are planes.",
                    "gram": "Plane(boeing707) ::: Boeing 707 is a plane."
                },
                {
                    "raw": "¬Airline(greyhound) → ¬∃y (Greyhound(y) ∧ Plane(y)) ::: If Greyhound is not an airline, then there are no Greyhound planes.",
                    "gram": "¬Airline(x) → ¬(Plane(y) ∧ Greyhound(y)) ::: If Greyhound is not an airline, then there are no Greyhound planes."
                }
            ],
            "answer": "A",
            "error_type":"",
            "grammar_answer": "A"
        },
        {
            "id": 143,
            "raw_prog": {
                "First-Order-Logic Rules": "∀x (BreedingBack(x) → ArtificiallySelected(x)) ::: Breeding back is a form of artificial selection by the deliberate selective breeding of domestic animals.\nBredBack(heck_cattle, aurochs) ∧ Resemble(heck_cattle, aurochs) ::: Heck cattle were bred-back in the 1920s to resemble the aurochs.\nAnimal(heck_cattle) ::: Heck cattle are animals.\nAnimal(aurochs) ::: Aurochs are animals.\n∃x ∃y (Animal(x) ∧ Animal(y) ∧ BredBack(x, y) ∧ Resemble(x, y) ∧ Extinct(y)) ::: Some animals to be bred-back resemble animals that are extinct.\n",
                "First-Order-Logic Question": "∃x (Animal(x) ∧ ArtificiallySelected(x) ∧ x = heck_cattle) ::: Some Heck cattle are artificially selected."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∀x (BreedingBack(x) → ArtificiallySelected(x)) ::: Breeding back is a form of artificial selection by the deliberate selective breeding of domestic animals.\nBredBack(heck_cattle, aurochs) ∧ Resemble(heck_cattle, aurochs) ::: Heck cattle were bred-back in the 1920s to resemble the aurochs.\nAnimal(heck_cattle) ::: Heck cattle are animals.\nAnimal(aurochs) ::: Aurochs are animals.\n∃x ∃y (Animal(x) ∧ Animal(y) ∧ BredBack(x, y) ∧ Resemble(x, y) ∧ Extinct(y)) ::: Some animals to be bred-back resemble animals that are extinct.\n",
                "First-Order-Logic Question": "∃x(Animal(x)∧BreedingBack(x)∧Resemble(x,y)∧Extinct(y)) ::: Some Heck cattle are artificially selected."
            },
            "diff": [
                {
                    "raw": "∃x (Animal(x) ∧ ArtificiallySelected(x) ∧ x = heck_cattle) ::: Some Heck cattle are artificially selected.",
                    "gram": "∃x(Animal(x)∧BreedingBack(x)∧Resemble(x,y)∧Extinct(y)) ::: Some Heck cattle are artificially selected."
                }
            ],
            "answer": "A",
            "error_type":"",
            "grammar_answer": "C"
        },
        {
            "id": 10,
            "raw_prog": {
                "First-Order-Logic Rules": "∀x (WildTurkey(x) → (EasternWildTurkey(x) ∨ OsceolaWildTurkey(x) ∨ GouldsWildTurkey(x) ∨ MerriamsWildTurkey(x) ∨ RioGrandeWildTurkey(x) ∨ OcellatedWildTurkey(x))) ::: There are six types of wild turkeys: Eastern wild turkey, Osceola wild turkey, Gould’s wild turkey, Merriam’s wild turkey, Rio Grande wild turkey, and Ocellated wild turkey.\nNot(tom, EasternWildTurkey(tom)) ::: Tom is not an Eastern wild turkey.\nNot(tom, OsceolaWildTurkey(tom)) ::: Tom is not an Osceola wild turkey.\nNot(tom, GouldsWildTurkey(tom)) ∧ Not(tom, MerriamsWildTurkey(tom)) ∧ Not(tom, RioGrandeWildTurkey(tom)) ::: Tom is also not a Gould's wild turkey, or a Merriam's wild turkey, or a Rio Grande wild turkey.\nWildTurkey(tom) ::: Tom is a wild turkey.\n",
                "First-Order-Logic Question": "EasternWildTurkey(tom) ::: Tom is an Eastern wild turkey."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∀x (WildTurkey(x) → (EasternWildTurkey(x) ∨ OsceolaWildTurkey(x) ∨ GouldsWildTurkey(x) ∨ MerriamsWildTurkey(x) ∨ RioGrandeWildTurkey(x) ∨ OcellatedWildTurkey(x))) ::: There are six types of wild turkeys: Eastern wild turkey, Osceola wild turkey, Gould’s wild turkey, Merriam’s wild turkey, Rio Grande wild turkey, and Ocellated wild turkey.\nNot(x,y) ::: Tom is not an Eastern wild turkey.\nNot(x,y) ::: Tom is not an Osceola wild turkey.\nNot(x,y) ::: Tom is also not a Gould's wild turkey, or a Merriam's wild turkey, or a Rio Grande wild turkey.\nWildTurkey(tom) ::: Tom is a wild turkey.\n",
                "First-Order-Logic Question": "EasternWildTurkey(tom) ::: Tom is an Eastern wild turkey."
            },
            "diff": [
                {
                    "raw": "Not(tom, EasternWildTurkey(tom)) ::: Tom is not an Eastern wild turkey.",
                    "gram": "Not(x,y) ::: Tom is not an Eastern wild turkey."
                },
                {
                    "raw": "Not(tom, OsceolaWildTurkey(tom)) ::: Tom is not an Osceola wild turkey.",
                    "gram": "Not(x,y) ::: Tom is not an Osceola wild turkey."
                },
                {
                    "raw": "Not(tom, GouldsWildTurkey(tom)) ∧ Not(tom, MerriamsWildTurkey(tom)) ∧ Not(tom, RioGrandeWildTurkey(tom)) ::: Tom is also not a Gould's wild turkey, or a Merriam's wild turkey, or a Rio Grande wild turkey.",
                    "gram": "Not(x,y) ::: Tom is also not a Gould's wild turkey, or a Merriam's wild turkey, or a Rio Grande wild turkey."
                }
            ],
            "answer": "B",
            "error_type":"",
            "grammar_answer": "C"
        },
        {
            "id": 40,
            "raw_prog": {
                "First-Order-Logic Rules": [
                    "∀x (ZahaHadid(x) → Timeless(x)) ::: All of Zaha Hadid's design styles are timeless.",
                    "∀x (MassProduct(x) → ¬Timeless(x)) ::: No mass product design is timeless.",
                    "∀x (ZahaHadid(x) ∨ KellyWearstler(x)) ::: Either Zaha Hadid's design style or Kelly Wearstler's design style.",
                    "∀x (KellyWearstler(x) → Evocative(x)) ::: All of Kelly Wearstler's design styles are evocative.",
                    "∀x (KellyWearstler(x) → Dreamy(x)) ::: All of Kelly Wearstler's design styles are dreamy.",
                    "∀x (Timeless(Max(x)) → (MassProduct(Max(x)) ∧ Evocative(Max(x)))) ::: If a design by Max is timeless, then a design by Max is a mass product design and evocative."
                ],
                "First-Order-Logic Question": [
                    "Evocative(Max(x)) ∧ Dreamy(Max(x)) ::: A design by Max is evocative and dreamy."
                ]
            },
            "gram_prog": {
                "First-Order-Logic Rules": [
                    "∀x (ZahaHadid(x) → Timeless(x)) ::: All of Zaha Hadid's design styles are timeless.",
                    "∀x (MassProduct(x) → ¬Timeless(x)) ::: No mass product design is timeless.",
                    "∀x (ZahaHadid(x) ∨ KellyWearstler(x)) ::: Either Zaha Hadid's design style or Kelly Wearstler's design style.",
                    "∀x (KellyWearstler(x) → Evocative(x)) ::: All of Kelly Wearstler's design styles are evocative.",
                    "∀x (KellyWearstler(x) → Dreamy(x)) ::: All of Kelly Wearstler's design styles are dreamy.",
                    "∀x(Timeless(x)→(MassProduct(x))) ::: If a design by Max is timeless, then a design by Max is a mass product design and evocative."
                ],
                "First-Order-Logic Question": [
                    "Evocative(x)∧Dreamy(x) ::: A design by Max is evocative and dreamy."
                ]
            },
            "diff": [
                {
                    "raw": "∀x (Timeless(Max(x)) → (MassProduct(Max(x)) ∧ Evocative(Max(x)))) ::: If a design by Max is timeless, then a design by Max is a mass product design and evocative.",
                    "gram": "∀x(Timeless(x)→(MassProduct(x))) ::: If a design by Max is timeless, then a design by Max is a mass product design and evocative."
                },
                {
                    "raw": "Evocative(Max(x)) ∧ Dreamy(Max(x)) ::: A design by Max is evocative and dreamy.",
                    "gram": "Evocative(x)∧Dreamy(x) ::: A design by Max is evocative and dreamy."
                }
            ],
            "answer": "A",
            "error_type":"",
            "grammar_answer": "A"
        },
        {
            "id": 53,
            "raw_prog": {
                "First-Order-Logic Rules": "∀x (RomanceLanguage(x) → IndoEuropeanLanguage(x)) ::: All Romance languages are Indo-European languages.\nLanguageFamily(romanceLanguages) ::: The Romance languages are a language family.\n∀x ∀y (LanguageFamily(f) ∧ RomanceLanguage(x) ∧ RomanceLanguage(y) → Related(x, y)) ::: All languages within a language family are related to each other.\nRomanceLanguage(french) ∧ RomanceLanguage(spanish) ::: French and Spanish are both Romance languages.\nRelated(german, spanish) ::: German is related to Spanish.\n∀x (Basque(x) → ¬∃y (Related(x, y))) ::: Basque is not related to any other language.\n",
                "First-Order-Logic Question": "RomanceLanguage(german) ::: German is a Romance language."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∀x (RomanceLanguage(x) → IndoEuropeanLanguage(x)) ::: All Romance languages are Indo-European languages.\nLanguageFamily(romanceLanguages) ::: The Romance languages are a language family.\n∀x ∀y (LanguageFamily(f) ∧ RomanceLanguage(x) ∧ RomanceLanguage(y) → Related(x, y)) ::: All languages within a language family are related to each other.\nRomanceLanguage(french) ∧ RomanceLanguage(spanish) ::: French and Spanish are both Romance languages.\nRelated(german, spanish) ::: German is related to Spanish.\n∀x(Basque(x)→¬Related(x,y)) ::: Basque is not related to any other language.\n",
                "First-Order-Logic Question": "RomanceLanguage(german) ::: German is a Romance language."
            },
            "diff": [
                {
                    "raw": "∀x (Basque(x) → ¬∃y (Related(x, y))) ::: Basque is not related to any other language.",
                    "gram": "∀x(Basque(x)→¬Related(x,y)) ::: Basque is not related to any other language."
                }
            ],
            "answer": "C",
            "error_type":"",
            "grammar_answer": "C"
        },
        {
            "id": 105,
            "raw_prog": {
                "First-Order-Logic Rules": "Cost(gre, 205) ::: It costs US $205 to take the GRE test.\n∀x (Applicant(x) ∧ Prove(x, EconomicHardship(x)) → Provide(ets, FinancialAid, x)) ::: ETS provides financial aid to those GRE applicants who prove economic hardship.\n∀x (EconomicHardship(x) ↔ (Difficulty(x) ∧ (¬Money(x) ∨ ¬Resources(x)))) ::: Economic hardship refers to difficulty caused by having too little money or too few resources.\nLive(tom, singleparentfamily) ::: Tom lives in a single-parent family.\nOutOfWork(tom_dad) ∧ Year(1) ::: His dad has been out of work for more than a year.\n",
                "First-Order-Logic Question": "Apply(tom, FinancialAid) ::: Tom can apply for financial aid from ETS to take the GRE test."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "Cost(gre, 205) ::: It costs US $205 to take the GRE test.\nProvide(x,y,z)→Applicant(x)∧Prove(x,y)∧EconomicHardship(x) ::: ETS provides financial aid to those GRE applicants who prove economic hardship.\n∀x (EconomicHardship(x) ↔ (Difficulty(x) ∧ (¬Money(x) ∨ ¬Resources(x)))) ::: Economic hardship refers to difficulty caused by having too little money or too few resources.\nLive(tom, singleparentfamily) ::: Tom lives in a single-parent family.\nOutOfWork(tom_dad) ∧ Year(1) ::: His dad has been out of work for more than a year.\n",
                "First-Order-Logic Question": "Apply(tom, FinancialAid) ::: Tom can apply for financial aid from ETS to take the GRE test."
            },
            "diff": [
                {
                    "raw": "∀x (Applicant(x) ∧ Prove(x, EconomicHardship(x)) → Provide(ets, FinancialAid, x)) ::: ETS provides financial aid to those GRE applicants who prove economic hardship.",
                    "gram": "Provide(x,y,z)→Applicant(x)∧Prove(x,y)∧EconomicHardship(x) ::: ETS provides financial aid to those GRE applicants who prove economic hardship."
                }
            ],
            "answer": "A",
            "error_type":"",
            "grammar_answer": "C"
        },
        {
            "id": 114,
            "raw_prog": {
                "First-Order-Logic Rules": [
                    "MountainRange(picurismountains) ∧ (In(picurismountains, newmexico) ⊕ In(picurismountains, texas)) ::: The Picuris Mountains are a mountain range in New Mexico or Texas.",
                    "Visit(juandeonate, picurismountains) ::: Juan de Onate visited the Picuris Mountains.",
                    "Mine(hardingpegmatitemine) ∧ In(hardingpegmatitemine, picurismountains) ∧ Donate(hardingpegmatitemine) ::: The Harding Pegmatite Mine, located in the Picuris Mountains, was donated.",
                    "∀x (MountainRange(x) ∧ In(x, texas) → ¬∃y (Mine(y) ∧ In(y, x) ∧ Donate(y))) ::: There are no mountain ranges in Texas that have mines which have been donated."
                ],
                "First-Order-Logic Question": [
                    "¬In(hardingpegmatitemine, newmexico) ::: The Harding Pegmatite Mine is not located in a mountain range in New Mexico."
                ]
            },
            "gram_prog": {
                "First-Order-Logic Rules": [
                    "MountainRange(picurismountains) ∧ (In(picurismountains, newmexico) ⊕ In(picurismountains, texas)) ::: The Picuris Mountains are a mountain range in New Mexico or Texas.",
                    "Visit(juandeonate, picurismountains) ::: Juan de Onate visited the Picuris Mountains.",
                    "Mine(hardingpegmatitemine) ∧ In(hardingpegmatitemine, picurismountains) ∧ Donate(hardingpegmatitemine) ::: The Harding Pegmatite Mine, located in the Picuris Mountains, was donated.",
                    "∀x(MountainRange(x)∧In(x,y)→¬(HasMine(x,y))) ::: There are no mountain ranges in Texas that have mines which have been donated."
                ],
                "First-Order-Logic Question": [
                    "¬In(hardingpegmatitemine, newmexico) ::: The Harding Pegmatite Mine is not located in a mountain range in New Mexico."
                ]
            },
            "diff": [
                {
                    "raw": "∀x (MountainRange(x) ∧ In(x, texas) → ¬∃y (Mine(y) ∧ In(y, x) ∧ Donate(y))) ::: There are no mountain ranges in Texas that have mines which have been donated.",
                    "gram": "∀x(MountainRange(x)∧In(x,y)→¬(HasMine(x,y))) ::: There are no mountain ranges in Texas that have mines which have been donated."
                }
            ],
            "answer": "B",
            "error_type":"",
            "grammar_answer": "C"
        },
        {
            "id": 38,
            "raw_prog": {
                "First-Order-Logic Rules": [
                    "MusicPiece(symphonyNo9) ::: Symphony No. 9 is a music piece.",
                    "∀x (Composer(x) → ∃y (Write(x, y) ∧ MusicPiece(y))) ::: Composers write music pieces.",
                    "Write(beethoven, symphonyNo9) ∧ Composer(beethoven) ::: Beethoven wrote Symphony No. 9.",
                    "Premiere(viennaMusicSociety, symphonyNo9) ::: Vienna Music Society premiered Symphony No. 9.",
                    "Orchestra(viennaMusicSociety) ::: Vienna Music Society is an orchestra.",
                    "Lead(beethoven, viennaMusicSociety) ::: Beethoven leads the Vienna Music Society.",
                    "∀x (Orchestra(x) → ∃y (Lead(y, x) ∧ Conductor(y))) ::: Orchestras are led by conductors."
                ],
                "First-Order-Logic Question": "Not(Conductor(beethoven)) ::: Beethoven is not a conductor."
            },
            "gram_prog": {
                "First-Order-Logic Rules": [
                    "MusicPiece(symphonyNo9) ::: Symphony No. 9 is a music piece.",
                    "∀x (Composer(x) → ∃y (Write(x, y) ∧ MusicPiece(y))) ::: Composers write music pieces.",
                    "Write(beethoven, symphonyNo9) ∧ Composer(beethoven) ::: Beethoven wrote Symphony No. 9.",
                    "Premiere(viennaMusicSociety, symphonyNo9) ::: Vienna Music Society premiered Symphony No. 9.",
                    "Orchestra(viennaMusicSociety) ::: Vienna Music Society is an orchestra.",
                    "Lead(beethoven, viennaMusicSociety) ::: Beethoven leads the Vienna Music Society.",
                    "∀x (Orchestra(x) → ∃y (Lead(y, x) ∧ Conductor(y))) ::: Orchestras are led by conductors."
                ],
                "First-Order-Logic Question": "Not(x) ::: Beethoven is not a conductor."
            },
            "diff": [
                {
                    "raw": "Not(Conductor(beethoven)) ::: Beethoven is not a conductor.",
                    "gram": "Not(x) ::: Beethoven is not a conductor."
                }
            ],
            "answer": "B",
            "error_type":"",
            "grammar_answer": "C"
        },
        {
            "id": 49,
            "raw_prog": {
                "First-Order-Logic Rules": "∀x (Digital(x) → ¬Analog(x)) ::: No digital media are analog.\n∀x (PrintedText(x) → Analog(x)) ::: Every printed text is analog.\n∀x (StreamingService(x) → Digital(x)) ::: All streaming services are digital.\n∀x (HardcoverBook(x) → PrintedText(x)) ::: If an object is a hardcover book then it is printed text.\n∀x (StreamingService(x) ∧ Object1984(x) → HardcoverBook(x)) ::: If 1984 is a streaming service, then 1984 is a hardcover book.\n",
                "First-Order-Logic Question": "PrintedText(Object1984(x)) ::: 1984 is printed text."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∀x (Digital(x) → ¬Analog(x)) ::: No digital media are analog.\n∀x (PrintedText(x) → Analog(x)) ::: Every printed text is analog.\n∀x (StreamingService(x) → Digital(x)) ::: All streaming services are digital.\n∀x (HardcoverBook(x) → PrintedText(x)) ::: If an object is a hardcover book then it is printed text.\n∀x (StreamingService(x) ∧ Object1984(x) → HardcoverBook(x)) ::: If 1984 is a streaming service, then 1984 is a hardcover book.\n",
                "First-Order-Logic Question": "PrintedText(x) ::: 1984 is printed text."
            },
            "diff": [
                {
                    "raw": "PrintedText(Object1984(x)) ::: 1984 is printed text.",
                    "gram": "PrintedText(x) ::: 1984 is printed text."
                }
            ],
            "answer": "C",
            "error_type":"",
            "grammar_answer": "C"
        }
    ],
    "gcd_llama-3-8b_3.5": [
        {
            "id": 2,
            "raw_prog": {
                "First-Order-Logic Rules": "∀x (Perform(x) → (Attend(x) ∧ Engaged(x))) ::: If people perform in school talent shows often, then they attend and are very engaged with school events.\n∀x ((Perform(x) ∨ (Inactive(x) ∧ Disinterested(x))) ::: People either perform in school talent shows often or are inactive and disinterested members of their community.\n∀x (Chaperone(x) → ¬Student(x)) ::: If people chaperone high school dances, then they are not students who attend the school.\n∀x ((Inactive(x) ∧ Disinterested(x)) → Chaperone(x)) ::: All people who are inactive and disinterested members of their community chaperone high school dances.\n∀x ((Young(x) ∨ Teenager(x)) ∧ Wish(x) → Student(x)) ::: All young children and teenagers who wish to further their academic careers and educational opportunities are students who attend the school.\n¬((Attend(Bonnie) ∧ Engaged(Bonnie)) ⊕ Student(Bonnie)) ::: Bonnie either both attends and is very engaged with school events and is a student who attends the school, or she neither attends and is very engaged with school events nor is a student who attends the school.\n",
                "First-Order-Logic Question": "((Chaperone(Bonnie) ∨ ¬Chaperone(Bonnie) ∧ Perform(Bonnie)) → ((Young(Bonnie) ∨ Teenager(Bonnie)) ∧ Wish(Bonnie) ∧ Inactive(Bonnie) ∧ Disinterested(Bonnie))) ::: If Bonnie either chaperones high school dances or, if she does not, she performs in school talent shows often, then Bonnie is both a young child or teenager who wishes to further her academic career and educational opportunities and an inactive and disinterested member of the community."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∀x (Perform(x) → (Attend(x) ∧ Engaged(x))) ::: If people perform in school talent shows often, then they attend and are very engaged with school events.\nInactive(x)∧Disinterested(x)∨Perform(x) ::: People either perform in school talent shows often or are inactive and disinterested members of their community.\n∀x (Chaperone(x) → ¬Student(x)) ::: If people chaperone high school dances, then they are not students who attend the school.\n∀x ((Inactive(x) ∧ Disinterested(x)) → Chaperone(x)) ::: All people who are inactive and disinterested members of their community chaperone high school dances.\n∀x ((Young(x) ∨ Teenager(x)) ∧ Wish(x) → Student(x)) ::: All young children and teenagers who wish to further their academic careers and educational opportunities are students who attend the school.\n¬((Attend(Bonnie) ∧ Engaged(Bonnie)) ⊕ Student(Bonnie)) ::: Bonnie either both attends and is very engaged with school events and is a student who attends the school, or she neither attends and is very engaged with school events nor is a student who attends the school.\n",
                "First-Order-Logic Question": "((Chaperone(Bonnie) ∨ ¬Chaperone(Bonnie) ∧ Perform(Bonnie)) → ((Young(Bonnie) ∨ Teenager(Bonnie)) ∧ Wish(Bonnie) ∧ Inactive(Bonnie) ∧ Disinterested(Bonnie))) ::: If Bonnie either chaperones high school dances or, if she does not, she performs in school talent shows often, then Bonnie is both a young child or teenager who wishes to further her academic career and educational opportunities and an inactive and disinterested member of the community."
            },
            "diff": [
                {
                    "raw": "∀x ((Perform(x) ∨ (Inactive(x) ∧ Disinterested(x))) ::: People either perform in school talent shows often or are inactive and disinterested members of their community.",
                    "gram": "Inactive(x)∧Disinterested(x)∨Perform(x) ::: People either perform in school talent shows often or are inactive and disinterested members of their community."
                }
            ],
            "answer": "B",
            "error_type":"",
            "grammar_answer": "C"
        },
        {
            "id": 3,
            "raw_prog": {
                "First-Order-Logic Rules": "∀x∀y (Employee(x) ∧ ScheduleMeeting(x, y) → AppearInCompany(x)) ::: All employees who schedule a meeting with their customers will appear in the company today. \n∀x (HasLunchInCompany(x) → ScheduleMeeting(x, Customer(x))) ::: Everyone who has lunch in the company schedules meetings with their customers. \n∀x (HasLunchInCompany(x) ∨ HasLunchAtHome(x)) ::: Employees will either have lunch in the company or have lunch at home. \n∀x (HasLunchAtHome(x) → WorkRemotelyFromHome(x)) ::: If an employee has lunch at home, then he/she is working remotely from home. \n∀x (InOtherCountries(x) → WorkRemotelyFromHome(x)) ::: All employees who are in other countries work remotely from home. \n∀x (Manager(x) → ¬WorkRemotelyFromHome(x)) ::: No managers work remotely from home. \n(Employee(james) ∧ AppearInCompany(james)) ⊕ (¬Manager(james) ∧ ¬AppearInCompany(james)) ::: James is either a manager and appears in the company today or neither a manager nor appears in the company today.",
                "First-Order-Logic Question": "HasLunchInCompany(james) ::: James has lunch in the company."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∀x∀y (Employee(x) ∧ ScheduleMeeting(x, y) → AppearInCompany(x)) ::: All employees who schedule a meeting with their customers will appear in the company today. \nInOtherCountries(x) ::: Everyone who has lunch in the company schedules meetings with their customers. \n∀x (HasLunchInCompany(x) ∨ HasLunchAtHome(x)) ::: Employees will either have lunch in the company or have lunch at home. \n∀x (HasLunchAtHome(x) → WorkRemotelyFromHome(x)) ::: If an employee has lunch at home, then he/she is working remotely from home. \n∀x (InOtherCountries(x) → WorkRemotelyFromHome(x)) ::: All employees who are in other countries work remotely from home. \n∀x (Manager(x) → ¬WorkRemotelyFromHome(x)) ::: No managers work remotely from home. \n(Employee(james) ∧ AppearInCompany(james)) ⊕ (¬Manager(james) ∧ ¬AppearInCompany(james)) ::: James is either a manager and appears in the company today or neither a manager nor appears in the company today.",
                "First-Order-Logic Question": "HasLunchInCompany(james) ::: James has lunch in the company."
            },
            "diff": [
                {
                    "raw": "∀x (HasLunchInCompany(x) → ScheduleMeeting(x, Customer(x))) ::: Everyone who has lunch in the company schedules meetings with their customers. ",
                    "gram": "InOtherCountries(x) ::: Everyone who has lunch in the company schedules meetings with their customers. "
                }
            ],
            "answer": "C",
            "error_type":"",
            "grammar_answer": "C"
        },
        {
            "id": 4,
            "raw_prog": {
                "First-Order-Logic Rules": "∀x∀y (Schedule(x, y) → Appear(x)) ::: All employees who schedule a meeting with their customers will appear in the company today. \n∀x (Lunch(x) → ∃y (Schedule(x, y))) ::: Everyone who has lunch in the company schedules meetings with their customers. \n∀x (Lunch(x) ∨ Home(x)) ::: Employees will either have lunch in the company or have lunch at home. \n∀x (Home(x) → Remote(x)) ::: If an employee has lunch at home, then he/she is working remotely from home. \n∀x (Work(x, y) → Remote(x)) ::: All employees who are in other countries work remotely from home. \n∀x (Manager(x) → ¬Remote(x)) ::: No managers work remotely from home. \n(Manager(james) ∧ Appear(james)) ⊕ (¬Manager(james) ∧ ¬Appear(james)) ::: James is either a manager and appears in the company today or neither a manager nor appears in the company today.",
                "First-Order-Logic Question": "¬Lunch(james) ::: James does not have lunch in the company."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∀x∀y (Schedule(x, y) → Appear(x)) ::: All employees who schedule a meeting with their customers will appear in the company today. \n∀x (Lunch(x) → ∃y (Schedule(x, y))) ::: Everyone who has lunch in the company schedules meetings with their customers. \n∀x (Lunch(x) ∨ Home(x)) ::: Employees will either have lunch in the company or have lunch at home. \n∀x (Home(x) → Remote(x)) ::: If an employee has lunch at home, then he/she is working remotely from home. \n∀x (Work(x, y) → Remote(x)) ::: All employees who are in other countries work remotely from home. \n∀x (Manager(x) → ¬Remote(x)) ::: No managers work remotely from home. \n(Manager(james) ∧ Appear(james)) ⊕ (¬Manager(james) ∧ ¬Appear(james)) ::: James is either a manager and appears in the company today or neither a manager nor appears in the company today.",
                "First-Order-Logic Question": "¬Lunch(james) ::: James does not have lunch in the company."
            },
            "diff": [],
            "answer": "C",
            "error_type":"",
            "grammar_answer": "C"
        },
        {
            "id": 43,
            "raw_prog": {
                "First-Order-Logic Rules": "∀x (RankedHighly(x) → Active(x)) ::: If a player is ranked highly by the Women's Tennis Association, then they are among the most active players in major tennis. \n∀x (LostTo(x, IgaSwiatek) → RankedHighly(x)) ::: Everyone who lost to Iga Swiatek is ranked highly by the Women's Tennis Association. \n∀x (Female(x) ∧ At(x, RolandGarros) → LostTo(x, IgaSwiatek)) ::: All female tennis players at Roland Garros 2022 lost to Iga Swiatek. \n(Female(x) ∧ At(x, RolandGarros)) ∨ (Male(x) ∧ At(x, RolandGarros)) ::: Either female tennis players at Roland Garros 2022 or male tennis players at Roland Garros 2022. \n∀x (Male(x) ∧ At(x, RolandGarros) → LostToRafaelNadal(x)) ::: All male tennis players at Roland Garros 2022 lost to Rafael Nadal. \n(RankedHighly(CocoGauff) ∨ LostTo(CocoGauff, RafaelNadal)) → ¬(Male(CocoGauff) ∧ At(CocoGauff, RolandGarros)) ::: If Coco Gauff is a player who is ranked highly by the Women's Tennis Association or a player who lost to Rafael Nadal, then Coco Gauff is not a male tennis player at Roland Garros 2022. \n",
                "First-Order-Logic Question": "LostTo(CocoGauff, RafaelNadal) ::: Coco Gauff has lost to Rafael Nadal."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∀x (RankedHighly(x) → Active(x)) ::: If a player is ranked highly by the Women's Tennis Association, then they are among the most active players in major tennis. \n∀x (LostTo(x, IgaSwiatek) → RankedHighly(x)) ::: Everyone who lost to Iga Swiatek is ranked highly by the Women's Tennis Association. \n∀x (Female(x) ∧ At(x, RolandGarros) → LostTo(x, IgaSwiatek)) ::: All female tennis players at Roland Garros 2022 lost to Iga Swiatek. \n(Female(x) ∧ At(x, RolandGarros)) ∨ (Male(x) ∧ At(x, RolandGarros)) ::: Either female tennis players at Roland Garros 2022 or male tennis players at Roland Garros 2022. \n∀x (Male(x) ∧ At(x, RolandGarros) → LostToRafaelNadal(x)) ::: All male tennis players at Roland Garros 2022 lost to Rafael Nadal. \n(RankedHighly(CocoGauff) ∨ LostTo(CocoGauff, RafaelNadal)) → ¬(Male(CocoGauff) ∧ At(CocoGauff, RolandGarros)) ::: If Coco Gauff is a player who is ranked highly by the Women's Tennis Association or a player who lost to Rafael Nadal, then Coco Gauff is not a male tennis player at Roland Garros 2022. \n",
                "First-Order-Logic Question": "LostTo(CocoGauff, RafaelNadal) ::: Coco Gauff has lost to Rafael Nadal."
            },
            "diff": [],
            "answer": "C",
            "error_type":"",
            "grammar_answer": "C"
        },
        {
            "id": 48,
            "raw_prog": {
                "First-Order-Logic Rules": "Season(spring) ∧ Season(summer) ∧ Season(fall) ∧ Season(winter) ::: There are four seasons in a year: Spring, Summer, Fall, and Winter. \n∀x (Student(x) ∧ WantLongVacation(x) → Love(x, summer)) ::: All students who want to have a long vacation love summer the most. \nFavoriteSeason(emma, summer) ::: Emma's favorite season is summer. \n∀x (FavoriteSeason(mia, y) → ¬FavoriteSeason(emma, y)) ::: Mia's favorite season is not the same as Emma's. \nWantLongVacation(james) ::: James wants to have a long vacation.",
                "First-Order-Logic Question": "FavoriteSeason(mia, spring) ::: Mia's favorite season is spring."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "Season(spring) ∧ Season(summer) ∧ Season(fall) ∧ Season(winter) ::: There are four seasons in a year: Spring, Summer, Fall, and Winter. \n∀x (Student(x) ∧ WantLongVacation(x) → Love(x, summer)) ::: All students who want to have a long vacation love summer the most. \nFavoriteSeason(emma, summer) ::: Emma's favorite season is summer. \n∀x (FavoriteSeason(mia, y) → ¬FavoriteSeason(emma, y)) ::: Mia's favorite season is not the same as Emma's. \nWantLongVacation(james) ::: James wants to have a long vacation.",
                "First-Order-Logic Question": "FavoriteSeason(mia, spring) ::: Mia's favorite season is spring."
            },
            "diff": [],
            "answer": "C",
            "error_type":"",
            "grammar_answer": "C"
        },
        {
            "id": 52,
            "raw_prog": {
                "First-Order-Logic Rules": "∀x (Romance(x) → IndoEuropean(x)) ::: All Romance languages are Indo-European languages.\nLanguageFamily(romance) ::: The Romance languages are a language family.\n∀x ∀y (LanguageFamily(x) ∧ LanguageFamily(y) → Related(x, y)) ::: All languages within a language family are related to each other.\nRomance(french) ∧ Romance(spanish) ::: French and Spanish are both Romance languages.\nRelated(german, spanish) ::: German is related to Spanish.\nBasque ::: Basque is not related to any other language.",
                "First-Order-Logic Question": "Romance(basque) ::: Basque is a Romance language."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∀x (RomanceLanguage(x) → IndoEuropean(x)) ::: All Romance languages are Indo-European languages.\nLanguageFamily(romance) ::: The Romance languages are a language family.\n∀x ∀y (LanguageFamily(x) ∧ LanguageFamily(y) → Related(x, y)) ::: All languages within a language family are related to each other.\nIsRomance(french) ∧ IsRomance(spanish) ::: French and Spanish are both Romance languages.\nRelated(german, spanish) ::: German is related to Spanish.\nIndoEuropean(x)∧¬Related(x,y) ::: Indo-European languages not related to any other language.",
                "First-Order-Logic Question": "IsRomance(basque) ::: Basque is a Romance language."
            },
            "diff": [
                {
                    "raw": "Basque ::: Basque is not related to any other language.",
                    "gram": "IndoEuropean(x)∧¬Related(x,y) ::: Indo-European languages not related to any other language."
                }
            ],
            "answer": "B",
            "error_type":"",
            "grammar_answer": "A"
        },
        {
            "id": 57,
            "raw_prog": {
                "First-Order-Logic Rules": "Striker(robertlewandowski) ::: Robert Lewandowski is a striker.\n∀x (Striker(x) → SoccerPlayer(x)) ::: Strikers are soccer players.\nLeftTeam(robertlewandowski, bayernmunchen) ::: Robert Lewandowski left Bayern Munchen.\n∀x∀y (LeftTeam(x, y) → ¬PlayFor(x, y)) ::: If a player left a team they no longer play for that team.",
                "First-Order-Logic Question": "Star(robertlewandowski) ::: Robert Lewandowski is a star."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "Striker(robertlewandowski) ::: Robert Lewandowski is a striker.\n∀x (Striker(x) → SoccerPlayer(x)) ::: Strikers are soccer players.\nLeftTeam(robertlewandowski, bayernmunchen) ::: Robert Lewandowski left Bayern Munchen.\n∀x∀y (LeftTeam(x, y) → ¬PlayFor(x, y)) ::: If a player left a team they no longer play for that team.",
                "First-Order-Logic Question": "Star(robertlewandowski) ::: Robert Lewandowski is a star."
            },
            "diff": [],
            "answer": "C",
            "error_type":"",
            "grammar_answer": "C"
        },
        {
            "id": 58,
            "raw_prog": {
                "First-Order-Logic Rules": "City(billings) ∧ City(butte) ∧ City(helena) ∧ City(missoula) ∧ City(whiteSulphurSprings) ∧ City(pierre) ∧ State(montana) ∧ State(southDakota) ∧ State(x) ∧ In(billings, montana) ∧ In(butte, montana) ∧ In(helena, montana) ∧ In(missoula, montana) ∧ In(whiteSulphurSprings, montana) ∧ In(butte, x) ∧ ¬In(pierre, southDakota) ∧ ∀x (In(x, butte) → ¬In(x, pierre)) ::: Billings is a city in Montana. Montana includes the cities of Butte, Helena, and Missoula. White Sulphur Springs and Butte are cities in the same state. The city of Pierre is not in Montana. Any city in Butte is not in Pierre.",
                "First-Order-Logic Question": "SameState(butte, pierre) ::: Butte and Pierre are in the same state."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "In(x,y)∨(City(x)∧State(y)) ::: Billings is a city in Montana. Montana includes the cities of Butte, Helena, and Missoula. White Sulphur Springs and Butte are cities in the same state. The city of Pierre is not in Montana. Any city in Butte is not in Pierre.",
                "First-Order-Logic Question": "SameState(butte, pierre) ::: Butte and Pierre are in the same state."
            },
            "diff": [
                {
                    "raw": "City(billings) ∧ City(butte) ∧ City(helena) ∧ City(missoula) ∧ City(whiteSulphurSprings) ∧ City(pierre) ∧ State(montana) ∧ State(southDakota) ∧ State(x) ∧ In(billings, montana) ∧ In(butte, montana) ∧ In(helena, montana) ∧ In(missoula, montana) ∧ In(whiteSulphurSprings, montana) ∧ In(butte, x) ∧ ¬In(pierre, southDakota) ∧ ∀x (In(x, butte) → ¬In(x, pierre)) ::: Billings is a city in Montana. Montana includes the cities of Butte, Helena, and Missoula. White Sulphur Springs and Butte are cities in the same state. The city of Pierre is not in Montana. Any city in Butte is not in Pierre.",
                    "gram": "In(x,y)∨(City(x)∧State(y)) ::: Billings is a city in Montana. Montana includes the cities of Butte, Helena, and Missoula. White Sulphur Springs and Butte are cities in the same state. The city of Pierre is not in Montana. Any city in Butte is not in Pierre."
                }
            ],
            "answer": "B",
            "error_type":"",
            "grammar_answer": "C"
        },
        {
            "id": 59,
            "raw_prog": {
                "First-Order-Logic Rules": "City(billings) ∧ In(billings, montana) ::: Billings is a city in Montana.\nInclude(montana, butte) ∧ Include(montana, helena) ∧ Include(montana, missoula) ::: Montana includes the cities of Butte, Helena, and Missoula.\nCity(white_sulphur_springs) ∧ City(butte) ∧ SameState(white_sulphur_springs, butte) ::: White Sulphur Springs and Butte are cities in the same state.\n¬In(pierre, montana) ::: The city of Pierre is not in Montana.\n∀x (City(x) ∧ In(x, butte) → ¬In(x, pierre)) ::: Any city in Butte is not in Pierre.\n",
                "First-Order-Logic Question": "SameState(pierre, bismarck) ::: Pierre and Bismarck are in the same state."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "City(billings) ∧ In(billings, montana) ::: Billings is a city in Montana.\nInclude(montana, butte) ∧ Include(montana, helena) ∧ Include(montana, missoula) ::: Montana includes the cities of Butte, Helena, and Missoula.\nCity(white_sulphur_springs) ∧ City(butte) ∧ SameState(white_sulphur_springs, butte) ::: White Sulphur Springs and Butte are cities in the same state.\n¬In(pierre, montana) ::: The city of Pierre is not in Montana.\n∀x (City(x) ∧ In(x, butte) → ¬In(x, pierre)) ::: Any city in Butte is not in Pierre.\n",
                "First-Order-Logic Question": "SameState(pierre, bismarck) ::: Pierre and Bismarck are in the same state."
            },
            "diff": [],
            "answer": "C",
            "error_type":"",
            "grammar_answer": "C"
        },
        {
            "id": 61,
            "raw_prog": {
                "First-Order-Logic Rules": "∀x (InternationalStudent(x) ∧ InUS(x) → (HasVisa(x, F1Visa) ∨ HasVisa(x, J1Visa))) ::: International students in US have either an F1 visa or a J1 visa. \n∀x (InternationalStudent(x) ∧ InUS(x) ∧ HasVisa(x, F1Visa) ∧ WorkInUS(x) → NeedsToApplyFor(x, CPT)) ::: An international student in US with an F1 visa needs to apply for CPT or OPT if the student wants to work in the US. \nInternationalStudent(mike) ::: Mike is an international student. \nWorkInUS(mike) ∧ NeedsToApplyFor(mike, CPT) ::: Mike needs to apply for CPT if he wants to work in the US.",
                "First-Order-Logic Question": "HasVisa(mike, F1Visa) ::: Mike has an F1 visa."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∀x (InternationalStudent(x) ∧ InUS(x) → (HasVisa(x, F1Visa) ∨ HasVisa(x, J1Visa))) ::: International students in US have either an F1 visa or a J1 visa. \n∀x (InternationalStudent(x) ∧ InUS(x) ∧ HasVisa(x, F1Visa) ∧ WorkInUS(x) → NeedsToApplyFor(x, CPT)) ::: An international student in US with an F1 visa needs to apply for CPT or OPT if the student wants to work in the US. \nInternationalStudent(mike) ::: Mike is an international student. \nWorkInUS(mike) ∧ NeedsToApplyFor(mike, CPT) ::: Mike needs to apply for CPT if he wants to work in the US.",
                "First-Order-Logic Question": "HasVisa(mike, F1Visa) ::: Mike has an F1 visa."
            },
            "diff": [],
            "answer": "C",
            "error_type":"",
            "grammar_answer": "C"
        },
        {
            "id": 73,
            "raw_prog": {
                "First-Order-Logic Rules": "∀x (GrowthStock(x) → Volatile(x)) ::: All growth stocks of companies are volatile.\n∀x (Volatile(x) → ¬SuitableForRetirement(x)) ::: If the stock price is volatile, then it is not suitable for a retirement fund.\n∃x ∃y (GrowthStock(x) ∧ Company(y)) ::: Some stocks of some companies are growth stocks of companies.\n∀x (Stock(x) ∧ MatureCompany(x) → SuitableForRetirement(x)) ::: All stocks of mature companies are suitable for a retirement fund.\nKO(ko) ∧ Stock(ko) ∧ MatureCompany(ko) ::: KO is a stock of a mature company.\n",
                "First-Order-Logic Question": "(GrowthStock(ko) ∨ Volatile(ko)) → (¬Stock(ko) ∧ ¬Volatile(ko)) ::: If KO is a growth stock of a company or if its price is volatile, then KO is neither a stock of a company nor is its price volatile."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∀x (GrowthStock(x) → Volatile(x)) ::: All growth stocks of companies are volatile.\n∀x (Volatile(x) → ¬SuitableForRetirement(x)) ::: If the stock price is volatile, then it is not suitable for a retirement fund.\n∃x ∃y (GrowthStock(x) ∧ Company(y)) ::: Some stocks of some companies are growth stocks of companies.\n∀x (Stock(x) ∧ MatureCompany(x) → SuitableForRetirement(x)) ::: All stocks of mature companies are suitable for a retirement fund.\nKO(ko) ∧ Stock(ko) ∧ MatureCompany(ko) ::: KO is a stock of a mature company.\n",
                "First-Order-Logic Question": "(GrowthStock(ko) ∨ Volatile(ko)) → (¬Stock(ko) ∧ ¬Volatile(ko)) ::: If KO is a growth stock of a company or if its price is volatile, then KO is neither a stock of a company nor is its price volatile."
            },
            "diff": [],
            "answer": "A",
            "error_type":"",
            "grammar_answer": "A"
        },
        {
            "id": 93,
            "raw_prog": {
                "First-Order-Logic Rules": "∃x (Pet(x) ∧ AllowedIn(x, y)) ::: Pets are allowed in some managed buildings.\n∀x (RequireDeposit(x) → ∃y (RentApartment(z, y) ∧ SecurityDeposit(x) ∧ (Equal(SecurityDeposit(x), RentAmount(y)) ∨ MoreThan(SecurityDeposit(x), RentAmount(y))))) ::: A deposit is required to rent an apartment in a managed building. The security deposit can be either equal to one month's rent or more.\nCat(fluffy) ∧ Pet(fluffy) ∧ Owner(tom, fluffy) ::: Fluffy is Tom's cat.\nCat(x) → Pet(x) ::: Cats are pets.\nManagedBuilding(olivegarden) ::: The Olive Garden is a managed building.\nRentAmount(2000, olivegarden) ::: The monthly rent at the Olive Garden is $2000.\nRentApartment(tom, olivegarden) ↔ (AllowedIn(tom, olivegarden) ∧ SecurityDeposit(olivegarden) ∧ (Equal(SecurityDeposit(olivegarden), 1500) ∨ ¬MoreThan(SecurityDeposit(olivegarden), 1500))) ::: Tom will rent an apartment in a managed building if and only if he is allowed to move in with Fluffy, and the security deposit is no more than $1500.\nMoreThan(2000, 1500) ::: 2000$ is more than $1500.",
                "First-Order-Logic Question": "RentApartment(tom, olivegarden) ::: Tom will rent an apartment in The Olive Garden."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∃x (Pet(x) ∧ AllowedIn(x, y)) ::: Pets are allowed in some managed buildings.\nAllowedIn(x,y) ::: A deposit is required to rent an apartment in a managed building. The security deposit can be either equal to one month's rent or more.\nCat(fluffy) ∧ Pet(fluffy) ∧ Owner(tom, fluffy) ::: Fluffy is Tom's cat.\nCat(x) → Pet(x) ::: Cats are pets.\nManagedBuilding(olivegarden) ::: The Olive Garden is a managed building.\nRentAmount(2000, olivegarden) ::: The monthly rent at the Olive Garden is $2000.\nAllowedIn(x,y)∧SecurityDeposit(y)∧(Equal(y,x)∨¬MoreThan(y,x)) ::: Tom will rent an apartment in a managed building if and only if he is allowed to move in with Fluffy, and the security deposit is no more than $1500.\nMoreThan(2000, 1500) ::: 2000$ is more than $1500.",
                "First-Order-Logic Question": "RentApartment(tom, olivegarden) ::: Tom will rent an apartment in The Olive Garden."
            },
            "diff": [
                {
                    "raw": "∀x (RequireDeposit(x) → ∃y (RentApartment(z, y) ∧ SecurityDeposit(x) ∧ (Equal(SecurityDeposit(x), RentAmount(y)) ∨ MoreThan(SecurityDeposit(x), RentAmount(y))))) ::: A deposit is required to rent an apartment in a managed building. The security deposit can be either equal to one month's rent or more.",
                    "gram": "AllowedIn(x,y) ::: A deposit is required to rent an apartment in a managed building. The security deposit can be either equal to one month's rent or more."
                },
                {
                    "raw": "RentApartment(tom, olivegarden) ↔ (AllowedIn(tom, olivegarden) ∧ SecurityDeposit(olivegarden) ∧ (Equal(SecurityDeposit(olivegarden), 1500) ∨ ¬MoreThan(SecurityDeposit(olivegarden), 1500))) ::: Tom will rent an apartment in a managed building if and only if he is allowed to move in with Fluffy, and the security deposit is no more than $1500.",
                    "gram": "AllowedIn(x,y)∧SecurityDeposit(y)∧(Equal(y,x)∨¬MoreThan(y,x)) ::: Tom will rent an apartment in a managed building if and only if he is allowed to move in with Fluffy, and the security deposit is no more than $1500."
                }
            ],
            "answer": "B",
            "error_type":"",
            "grammar_answer": "C"
        },
        {
            "id": 94,
            "raw_prog": {
                "First-Order-Logic Rules": "∃x (Pet(x) ∧ ManagedBuilding(y) ∧ AllowedIn(x, y)) ::: Pets are allowed in some managed buildings.\n∀x (ManagedBuilding(x) → RequireDeposit(x)) ::: A deposit is required to rent an apartment in a managed building.\n∀x (SecurityDeposit(x) → (Equal(x, Rent) ∨ MoreThan(x, Rent))) ::: The security deposit can be either equal to one month's rent or more.\nCat(fluffy) ∧ Pet(fluffy) ∧ Owner(tom, fluffy) ::: Fluffy is Tom's cat.\n∀x (Cat(x) → Pet(x)) ::: Cats are pets.\nManagedBuilding(olivegarden) ::: The Olive Garden is a managed building.\nPrice(olivegarden, 2000) ::: The monthly rent at the Olive Garden is $2000.\nRentApartment(tom, olivegarden) ↔ (AllowedIn(tom, olivegarden) ∧ ¬MoreThan(SecurityDeposit(olivegarden), 1500)) ::: Tom will rent an apartment in a managed building if and only if he is allowed to move in with Fluffy, and the security deposit is no more than $1500.\nMoreThan(2000, 1500) ::: 2000$ is more than $1500.\n",
                "First-Order-Logic Question": "RentApartment(tom, olivegarden) ∧ MoveInWith(tom, fluffy) ::: Tom is allowed to move in an apartment in The Olive Garden with Fluffy."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∃x (Pet(x) ∧ ManagedBuilding(y) ∧ AllowedIn(x, y)) ::: Pets are allowed in some managed buildings.\n∀x (ManagedBuilding(x) → RequireDeposit(x)) ::: A deposit is required to rent an apartment in a managed building.\n∀x (SecurityDeposit(x) → (Equal(x, Rent) ∨ MoreThan(x, Rent))) ::: The security deposit can be either equal to one month's rent or more.\nCat(fluffy) ∧ Pet(fluffy) ∧ Owner(tom, fluffy) ::: Fluffy is Tom's cat.\n∀x (Cat(x) → Pet(x)) ::: Cats are pets.\nManagedBuilding(olivegarden) ::: The Olive Garden is a managed building.\nPrice(olivegarden, 2000) ::: The monthly rent at the Olive Garden is $2000.\nAllowedIn(x,y)∧¬MoreThan(y,z)→RentApartment(x,z) ::: Tom will rent an apartment in a managed building if and only if he is allowed to move in with Fluffy, and the security deposit is no more than $1500.\nMoreThan(2000, 1500) ::: 2000$ is more than $1500.\n",
                "First-Order-Logic Question": "RentApartment(tom, olivegarden) ∧ MoveInWith(tom, fluffy) ::: Tom is allowed to move in an apartment in The Olive Garden with Fluffy."
            },
            "diff": [
                {
                    "raw": "RentApartment(tom, olivegarden) ↔ (AllowedIn(tom, olivegarden) ∧ ¬MoreThan(SecurityDeposit(olivegarden), 1500)) ::: Tom will rent an apartment in a managed building if and only if he is allowed to move in with Fluffy, and the security deposit is no more than $1500.",
                    "gram": "AllowedIn(x,y)∧¬MoreThan(y,z)→RentApartment(x,z) ::: Tom will rent an apartment in a managed building if and only if he is allowed to move in with Fluffy, and the security deposit is no more than $1500."
                }
            ],
            "answer": "C",
            "error_type":"",
            "grammar_answer": "C"
        },
        {
            "id": 104,
            "raw_prog": {
                "First-Order-Logic Rules": "∀x (Twins(x) ∨ Triplets(x) → SpendTimeWith(x, x)) ::: If people are twins or triplets, then they spend a lot of time hanging out with and playing with their siblings.\n∀x (Siblings(x, y) → Twins(x) ∨ Triplets(x)) ::: If people have siblings who are the same age, then they are twins or triplets.\n∀x (Complain(x) → Siblings(x, y)) ::: If people complain often about annoying siblings, then they have siblings who are the same age.\n∀x (¬LiveAtHome(x) → ¬DevelopBonds(x, y)) ::: If people do not live at home regularly, then they do not develop strong bonds with their family members.\n∀x (SpendTimeWith(x, y) → ¬LiveAtHome(x)) ::: If people spend a lot of time hanging out with and playing with their siblings, then they often did not live at home regularly.\n(Twins(luke) ∧ DevelopBonds(luke, luke)) ⊕ (¬Twins(luke) ∧ ¬DevelopBonds(luke, luke)) ::: Luke is either both a twin or triplet and develops strong bonds with his family members, or he neither is a twin or triplet nor develops strong bonds with his family members.\n",
                "First-Order-Logic Question": "¬(Twins(luke) ∨ Triplets(luke) ∨ Complain(luke)) ::: Luke is neither a twin nor triplet nor complains often about annoying siblings."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∀x (Twins(x) ∨ Triplets(x) → SpendTimeWith(x, x)) ::: If people are twins or triplets, then they spend a lot of time hanging out with and playing with their siblings.\n∀x (Siblings(x, y) → Twins(x) ∨ Triplets(x)) ::: If people have siblings who are the same age, then they are twins or triplets.\n∀x (Complain(x) → Siblings(x, y)) ::: If people complain often about annoying siblings, then they have siblings who are the same age.\n∀x (¬LiveAtHome(x) → ¬DevelopBonds(x, y)) ::: If people do not live at home regularly, then they do not develop strong bonds with their family members.\n∀x (SpendTimeWith(x, y) → ¬LiveAtHome(x)) ::: If people spend a lot of time hanging out with and playing with their siblings, then they often did not live at home regularly.\n(Twins(luke) ∧ DevelopBonds(luke, luke)) ⊕ (¬Twins(luke) ∧ ¬DevelopBonds(luke, luke)) ::: Luke is either both a twin or triplet and develops strong bonds with his family members, or he neither is a twin or triplet nor develops strong bonds with his family members.\n",
                "First-Order-Logic Question": "¬(Twins(luke) ∨ Triplets(luke) ∨ Complain(luke)) ::: Luke is neither a twin nor triplet nor complains often about annoying siblings."
            },
            "diff": [],
            "answer": "A",
            "error_type":"",
            "grammar_answer": "C"
        },
        {
            "id": 116,
            "raw_prog": {
                "First-Order-Logic Rules": "∀x ∀y (Man(x) ∧ Man(y) ∧ Taller(x, y) → Block(x, y)) ::: If a man is taller than another man, the taller one can block the other's shooting.\nMan(michael) ∧ ∀x (Classmate(x, michael) ∧ x ≠ michael → Taller(michael, x)) ::: Michael is a man who is taller than everyone else in his class.\n∀x ∀y ∀z (Man(x) ∧ Man(y) ∧ Man(z) ∧ Taller(x, y) ∧ Taller(y, z) → Taller(x, z)) ::: If person x is taller than person y, and person y is taller than person z, than x is taller than z\nMan(peter) ∧ Man(michael) ∧ Taller(peter, michael) ::: Peter is a man who is taller than Michael.\n∀x (Shoot(x) ∧ ¬Jump(x) → Block(michael, x)) ::: Michael can block any shooting from a person as long as the person does not jump when shooting.\n¬Block(michael, windy) ::: Michael cannot block Windy's shooting.\n∀x (Jump(x) → GreatShooter(x)) ::: Every shooter who can jump when shooting is a great shooter.",
                "First-Order-Logic Question": "GreatShooter(windy) ::: Windy is a great shooter."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∀x ∀y (Man(x) ∧ Man(y) ∧ Taller(x, y) → Block(x, y)) ::: If a man is taller than another man, the taller one can block the other's shooting.\nGreatShooter(x) ::: Michael is a man who is taller than everyone else in his class.\n∀x ∀y ∀z (Man(x) ∧ Man(y) ∧ Man(z) ∧ Taller(x, y) ∧ Taller(y, z) → Taller(x, z)) ::: If person x is taller than person y, and person y is taller than person z, than x is taller than z\nMan(peter) ∧ Man(michael) ∧ Taller(peter, michael) ::: Peter is a man who is taller than Michael.\n∀x (Shoot(x) ∧ ¬Jump(x) → Block(michael, x)) ::: Michael can block any shooting from a person as long as the person does not jump when shooting.\n¬Block(michael, windy) ::: Michael cannot block Windy's shooting.\n∀x (Jump(x) → GreatShooter(x)) ::: Every shooter who can jump when shooting is a great shooter.",
                "First-Order-Logic Question": "GreatShooter(windy) ::: Windy is a great shooter."
            },
            "diff": [
                {
                    "raw": "Man(michael) ∧ ∀x (Classmate(x, michael) ∧ x ≠ michael → Taller(michael, x)) ::: Michael is a man who is taller than everyone else in his class.",
                    "gram": "GreatShooter(x) ::: Michael is a man who is taller than everyone else in his class."
                }
            ],
            "answer": "A",
            "error_type":"",
            "grammar_answer": "A"
        },
        {
            "id": 124,
            "raw_prog": {
                "First-Order-Logic Rules": "∀x (Transport(x) → ¬Empty(x)) ::: If something can transport multiple passengers, then they are not empty. \n∀x (Airline(x) → Transport(x)) ::: All airlines can transport multiple passengers. \n∀x (Plane(x) → Empty(x)) ::: All planes are empty. \n∀x (Boeing707(x) → Plane(x)) ::: All Boeing 707s are planes. \nAirline(Greyhound) → ¬∃x (Greyhound(x) ∧ Plane(x)) ::: If Greyhound is not an airline, then there are no Greyhound planes.\n",
                "First-Order-Logic Question": "¬(Greyhound(x) ∧ Boeing707(x)) ::: A Greyhound is not a Boeing 707."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∀x (Transport(x) → ¬Empty(x)) ::: If something can transport multiple passengers, then they are not empty. \n∀x (Airline(x) → Transport(x)) ::: All airlines can transport multiple passengers. \n∀x (Plane(x) → Empty(x)) ::: All planes are empty. \n∀x (Boeing707(x) → Plane(x)) ::: All Boeing 707s are planes. \nAirline(x)→¬(Greyhound(x)∧Plane(x)) ::: If Greyhound is not an airline, then there are no Greyhound planes.\n",
                "First-Order-Logic Question": "¬(Greyhound(x) ∧ Boeing707(x)) ::: A Greyhound is not a Boeing 707."
            },
            "diff": [
                {
                    "raw": "Airline(Greyhound) → ¬∃x (Greyhound(x) ∧ Plane(x)) ::: If Greyhound is not an airline, then there are no Greyhound planes.",
                    "gram": "Airline(x)→¬(Greyhound(x)∧Plane(x)) ::: If Greyhound is not an airline, then there are no Greyhound planes."
                }
            ],
            "answer": "A",
            "error_type":"",
            "grammar_answer": "C"
        },
        {
            "id": 128,
            "raw_prog": {
                "First-Order-Logic Rules": "∀x (HaveWedding(x) → HaveChild(x)) ::: All people who have a wedding are people who have at least one child.\n∀x (TravelToParis(x) → HaveWedding(x)) ::: All people who travel to Paris for their honeymoon are people who have a wedding.\n∀x (OccurIn(x, July) ∧ HaveWedding(x) → TravelToParis(x)) ::: All weddings that occur in July belong to people who travel to Paris for their honeymoon.\n∃x (OccurIn(x, July) ∧ WellAttended(x)) ::: Some weddings in July are well-attended.\nHaveChild(John) → (¬TravelToParis(John) ∧ ¬HaveWedding(John)) ::: If John has at least one child, then John does not travel to Paris for his honeymoon and does not have a wedding.\nHaveWedding(John) ∧ WellAttended(John) → (OccurIn(John, July) ∨ (¬OccurIn(John, July) → TravelToParis(John))) ::: If John has a wedding that is well-attended, then John has a wedding in July or, if not, then John travels to Paris for their honeymoon.",
                "First-Order-Logic Question": "WellAttended(John) ::: John has a wedding that is well-attended."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∀x (HaveWedding(x) → HaveChild(x)) ::: All people who have a wedding are people who have at least one child.\n∀x (TravelToParis(x) → HaveWedding(x)) ::: All people who travel to Paris for their honeymoon are people who have a wedding.\n∀x (OccurIn(x, July) ∧ HaveWedding(x) → TravelToParis(x)) ::: All weddings that occur in July belong to people who travel to Paris for their honeymoon.\n∃x (OccurIn(x, July) ∧ WellAttended(x)) ::: Some weddings in July are well-attended.\nHaveChild(John) → (¬TravelToParis(John) ∧ ¬HaveWedding(John)) ::: If John has at least one child, then John does not travel to Paris for his honeymoon and does not have a wedding.\nHaveWedding(John) ∧ WellAttended(John) → (OccurIn(John, July) ∨ (¬OccurIn(John, July) → TravelToParis(John))) ::: If John has a wedding that is well-attended, then John has a wedding in July or, if not, then John travels to Paris for their honeymoon.",
                "First-Order-Logic Question": "WellAttended(John) ::: John has a wedding that is well-attended."
            },
            "diff": [],
            "answer": "B",
            "error_type":"",
            "grammar_answer": "C"
        },
        {
            "id": 130,
            "raw_prog": {
                "First-Order-Logic Rules": "∀x (HaveWedding(x) → HaveChild(x)) ::: All people who have a wedding are people who have at least one child.\n∀x (TravelToParisForHoneymoon(x) → HaveWedding(x)) ::: All people who travel to Paris for their honeymoon are people who have a wedding.\n∀x (Weddings(x) ∧ July(x) → BelongTo(x, TravelToParisForHoneymoon(x))) ::: All weddings that occur in July belong to people who travel to Paris for their honeymoon.\n∃x (Weddings(x) ∧ July(x) ∧ WellAttended(x)) ::: Some weddings in July are well-attended.\nHaveChild(John) → (¬TravelToParisForHoneymoon(John) ∧ ¬HaveWedding(John)) ::: If John has at least one child, then John does not travel to Paris for his honeymoon and does not have a wedding.\n(WellAttended(John) → (Weddings(John) ∧ July(John))) ∨ (¬July(John) → TravelToParisForHoneymoon(John)) ::: If John has a wedding that is well-attended, then John has a wedding in July or, if not, then John travels to Paris for their honeymoon.",
                "First-Order-Logic Question": "HaveChild(John) ::: John has at least one child."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∀x (HaveWedding(x) → HaveChild(x)) ::: All people who have a wedding are people who have at least one child.\n∀x (TravelToParisForHoneymoon(x) → HaveWedding(x)) ::: All people who travel to Paris for their honeymoon are people who have a wedding.\nAttend(y)∧¬(July(y))→BelongTo(y,z) ::: All weddings that occur in July belong to people who travel to Paris for their honeymoon.\n∃x (Weddings(x) ∧ July(x) ∧ WellAttended(x)) ::: Some weddings in July are well-attended.\nHaveChild(John) → (¬TravelToParisForHoneymoon(John) ∧ ¬HaveWedding(John)) ::: If John has at least one child, then John does not travel to Paris for his honeymoon and does not have a wedding.\n(WellAttended(John) → (Weddings(John) ∧ July(John))) ∨ (¬July(John) → TravelToParisForHoneymoon(John)) ::: If John has a wedding that is well-attended, then John has a wedding in July or, if not, then John travels to Paris for their honeymoon.",
                "First-Order-Logic Question": "HaveChild(John) ::: John has at least one child."
            },
            "diff": [
                {
                    "raw": "∀x (Weddings(x) ∧ July(x) → BelongTo(x, TravelToParisForHoneymoon(x))) ::: All weddings that occur in July belong to people who travel to Paris for their honeymoon.",
                    "gram": "Attend(y)∧¬(July(y))→BelongTo(y,z) ::: All weddings that occur in July belong to people who travel to Paris for their honeymoon."
                }
            ],
            "answer": "C",
            "error_type":"",
            "grammar_answer": "C"
        },
        {
            "id": 138,
            "raw_prog": {
                "First-Order-Logic Rules": "∀x (Algorithm(x) → (SupervisedLearning(x) ∨ UnsupervisedLearning(x) ∨ ReinforcementLearning(x))) ::: Machine Learning algorithms can be categorized as supervised learning, unsupervised learning, and reinforcement learning.\n∀x (UnsupervisedLearning(x) → ¬RequireLabelledData(x)) ::: Unsupervised learning doesn't require labelled data.\nStateOfTheArtModel(model) ∧ Algorithm(algo) ∧ TrainedWith(model, algo) ::: The state-of-the-art text summarization model is trained with machine learning algorithms.\nReinforcementLearning(rl) → ¬TrainedWith(StateOfTheArtModel(model), rl) ::: Reinforcement learning is not used to train the state-of-the-art text summarization model.\n∀x (Algorithm(x) ∧ TrainedWith(StateOfTheArtModel(model), x) → RequireLabelledData(x)) ::: The Machine Learning algorithm for training text summarization model requires labelled data.\n",
                "First-Order-Logic Question": "SupervisedLearning(supervised) ∧ TrainedWith(StateOfTheArtModel(model), supervised) ::: Supervised learning is used to train the state-of-the-art text summarization model."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∀x (Algorithm(x) → (SupervisedLearning(x) ∨ UnsupervisedLearning(x) ∨ ReinforcementLearning(x))) ::: Machine Learning algorithms can be categorized as supervised learning, unsupervised learning, and reinforcement learning.\n∀x (UnsupervisedLearning(x) → ¬RequireLabelledData(x)) ::: Unsupervised learning doesn't require labelled data.\nStateOfTheArtModel(model) ∧ Algorithm(algo) ∧ TrainedWith(model, algo) ::: The state-of-the-art text summarization model is trained with machine learning algorithms.\nAlgorithm(y)→¬TrainedWith(y,x) ::: Reinforcement learning is not used to train the state-of-the-art text summarization model.\nAlgorithm(x)∧TrainedWith(y,x)→RequireLabelledData(x) ::: The Machine Learning algorithm for training text summarization model requires labelled data.\n",
                "First-Order-Logic Question": "Algorithm(y)∧RequireLabelledData(y)→SupervisedLearning(y) ::: Supervised learning is used to train the state-of-the-art text summarization model."
            },
            "diff": [
                {
                    "raw": "ReinforcementLearning(rl) → ¬TrainedWith(StateOfTheArtModel(model), rl) ::: Reinforcement learning is not used to train the state-of-the-art text summarization model.",
                    "gram": "Algorithm(y)→¬TrainedWith(y,x) ::: Reinforcement learning is not used to train the state-of-the-art text summarization model."
                },
                {
                    "raw": "∀x (Algorithm(x) ∧ TrainedWith(StateOfTheArtModel(model), x) → RequireLabelledData(x)) ::: The Machine Learning algorithm for training text summarization model requires labelled data.",
                    "gram": "Algorithm(x)∧TrainedWith(y,x)→RequireLabelledData(x) ::: The Machine Learning algorithm for training text summarization model requires labelled data."
                },
                {
                    "raw": "SupervisedLearning(supervised) ∧ TrainedWith(StateOfTheArtModel(model), supervised) ::: Supervised learning is used to train the state-of-the-art text summarization model.",
                    "gram": "Algorithm(y)∧RequireLabelledData(y)→SupervisedLearning(y) ::: Supervised learning is used to train the state-of-the-art text summarization model."
                }
            ],
            "answer": "A",
            "error_type":"",
            "grammar_answer": "C"
        },
        {
            "id": 139,
            "raw_prog": {
                "First-Order-Logic Rules": "∀x (SupervisedLearning(x) ∨ UnsupervisedLearning(x) ∨ ReinforcementLearning(x)) ::: Machine Learning algorithms can be categorized as supervised learning, unsupervised learning, and reinforcement learning.\nUnsupervisedLearning(x) → ¬RequireLabelledData(x) ::: Unsupervised learning doesn't require labelled data.\nTrainedWith(StateOfTheArtModel(textsummarization), MachineLearningAlgorithm(x)) ::: The state-of-the-art text summarization model is trained with machine learning algorithms.\nReinforcementLearning(x) → ¬TrainedWith(StateOfTheArtModel(textsummarization), x) ::: Reinforcement learning is not used to train the state-of-the-art text summarization model.\nRequireLabelledData(x) → MachineLearningAlgorithm(x) ::: The Machine Learning algorithm for training text summarization model requires labelled data.\n",
                "First-Order-Logic Question": "¬UsedToTrain(UnsupervisedLearning, StateOfTheArtModel(textsummarization)) ::: Unsupervised learning is used to train the state-of-the-art text summarization model."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∀x (SupervisedLearning(x) ∨ UnsupervisedLearning(x) ∨ ReinforcementLearning(x)) ::: Machine Learning algorithms can be categorized as supervised learning, unsupervised learning, and reinforcement learning.\nUnsupervisedLearning(x) → ¬RequireLabelledData(x) ::: Unsupervised learning doesn't require labelled data.\nUsedToTrain(y,x) ::: The state-of-the-art text summarization model is trained with machine learning algorithms.\nUsedToTrain(x,y)→¬ReinforcementLearning(y) ::: Reinforcement learning is not used to train the state-of-the-art text summarization model.\nRequireLabelledData(x) → MachineLearningAlgorithm(x) ::: The Machine Learning algorithm for training text summarization model requires labelled data.\n",
                "First-Order-Logic Question": "UsedToTrain(y,z)→¬UnsupervisedLearning(y) ::: Unsupervised learning is used to train the state-of-the-art text summarization model."
            },
            "diff": [
                {
                    "raw": "TrainedWith(StateOfTheArtModel(textsummarization), MachineLearningAlgorithm(x)) ::: The state-of-the-art text summarization model is trained with machine learning algorithms.",
                    "gram": "UsedToTrain(y,x) ::: The state-of-the-art text summarization model is trained with machine learning algorithms."
                },
                {
                    "raw": "ReinforcementLearning(x) → ¬TrainedWith(StateOfTheArtModel(textsummarization), x) ::: Reinforcement learning is not used to train the state-of-the-art text summarization model.",
                    "gram": "UsedToTrain(x,y)→¬ReinforcementLearning(y) ::: Reinforcement learning is not used to train the state-of-the-art text summarization model."
                },
                {
                    "raw": "¬UsedToTrain(UnsupervisedLearning, StateOfTheArtModel(textsummarization)) ::: Unsupervised learning is used to train the state-of-the-art text summarization model.",
                    "gram": "UsedToTrain(y,z)→¬UnsupervisedLearning(y) ::: Unsupervised learning is used to train the state-of-the-art text summarization model."
                }
            ],
            "answer": "B",
            "error_type":"",
            "grammar_answer": "C"
        },
        {
            "id": 153,
            "raw_prog": {
                "First-Order-Logic Rules": "∀x,y (Owns(x, y) → (WorkRegularlyAtHome(x) ∧ TidyOrganize(x))) ::: If people own a large desktop monitor at their home, then they work regularly and often at home.\n∀x (HasHomeOffice(x) → Owns(x, largeDesktopMonitor)) ::: All people who have a fully stocked and impressive home office are people who own a large desktop monitor at their home.\n∀x (WorkRegularlyAtHome(x) → TidyOrganize(x)) ::: All people who work regularly and often at home spend their free time tidying and organizing the spaces in their homes.\n∀x (WorkRegularlyAtHome(x) → VisitStore(x)) ::: All people who work regularly and often at home visit the office supply store regularly.\n∀x (TidyOrganize(x) → (¬GoToBedLate(x) ∧ WakeUpLate(x))) ::: If people spend their free time tidying and organizing the spaces in their home, then they do not go to bed late and wake up every day after noon.\n(TidyOrganize(remy) ∧ (GoToBedLate(remy) ∧ WakeUpLate(remy))) ⊕ (¬GoToBedLate(remy) ∧ ¬WakeUpLate(remy) ∧ ¬TidyOrganize(remy)) ::: Remy either both goes to bed late and wakes up every day after noon and spends their free time tidying and organizing the spaces in their home, or they do not go to bed late and wake up every day after noon nor spend their free time tidying and organizing the spaces in their home.\n",
                "First-Order-Logic Question": "VisitStore(remy) ::: Remy visits the office supply store regularly."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "GoToBedLate(x)→(Owns(x,y)→WorkRegularlyAtHome(x)) ::: If people own a large desktop monitor at their home, then they work regularly and often at home.\n∀x (HasHomeOffice(x) → Owns(x, largeDesktopMonitor)) ::: All people who have a fully stocked and impressive home office are people who own a large desktop monitor at their home.\n∀x (WorkRegularlyAtHome(x) → TidyOrganize(x)) ::: All people who work regularly and often at home spend their free time tidying and organizing the spaces in their homes.\n∀x (WorkRegularlyAtHome(x) → VisitStore(x)) ::: All people who work regularly and often at home visit the office supply store regularly.\n∀x (TidyOrganize(x) → (¬GoToBedLate(x) ∧ WakeUpLate(x))) ::: If people spend their free time tidying and organizing the spaces in their home, then they do not go to bed late and wake up every day after noon.\n(TidyOrganize(remy) ∧ (GoToBedLate(remy) ∧ WakeUpLate(remy))) ⊕ (¬GoToBedLate(remy) ∧ ¬WakeUpLate(remy) ∧ ¬TidyOrganize(remy)) ::: Remy either both goes to bed late and wakes up every day after noon and spends their free time tidying and organizing the spaces in their home, or they do not go to bed late and wake up every day after noon nor spend their free time tidying and organizing the spaces in their home.\n",
                "First-Order-Logic Question": "VisitStore(remy) ::: Remy visits the office supply store regularly."
            },
            "diff": [
                {
                    "raw": "∀x,y (Owns(x, y) → (WorkRegularlyAtHome(x) ∧ TidyOrganize(x))) ::: If people own a large desktop monitor at their home, then they work regularly and often at home.",
                    "gram": "GoToBedLate(x)→(Owns(x,y)→WorkRegularlyAtHome(x)) ::: If people own a large desktop monitor at their home, then they work regularly and often at home."
                }
            ],
            "answer": "C",
            "error_type":"",
            "grammar_answer": "C"
        },
        {
            "id": 155,
            "raw_prog": {
                "First-Order-Logic Rules": "∀x,y (Owns(x, y) → (WorkRegularly(x) ∧ WorkOften(x))) ::: If people own a large desktop monitor at their home, then they work regularly and often at home.\n∀x (FullyStocked(x) → Owns(x, largeDesktopMonitor) ∧ Impressive(x)) ::: All people who have a fully stocked and impressive home office are people who own a large desktop monitor at their home.\n∀x (WorkRegularly(x) ∧ WorkOften(x) → Tidy(x)) ::: All people who work regularly and often at home spend their free time tidying and organizing the spaces in their homes.\n∀x (WorkRegularly(x) ∧ WorkOften(x) → VisitStore(x)) ::: All people who work regularly and often at home visit the office supply store regularly.\n∀x (Tidy(x) → (¬Late(x) ∧ ¬WakeLate(x))) ::: If people spend their free time tidying and organizing the spaces in their home, then they do not go to bed late and wake up every day after noon.\n(Tidy(remy) ∧ Late(remy) ∧ WakeLate(remy)) ⊕ (¬Late(remy) ∧ ¬WakeLate(remy) ∧ ¬Tidy(remy)) ::: Remy either both goes to bed late and wakes up every day after noon and spends their free time tidying and organizing the spaces in their home, or they do not go to bed late and wake up every day after noon nor spend their free time tidying and organizing the spaces in their home.\n",
                "First-Order-Logic Question": "((Late(remy) ∧ WakeLate(remy)) ∨ VisitStore(remy)) → (¬Tidy(remy) ∧ ¬FullyStocked(remy)) ::: If Remy either goes to bed late and wakes up every day after noon or visits the office supply store regularly, then Remy neither spends their free time tidying and organizing the spaces in their home nor has a fully stocked and impressive home office."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "Impressive(x) ::: If people own a large desktop monitor at their home, then they work regularly and often at home.\n∀x (FullyStocked(x) → Owns(x, largeDesktopMonitor) ∧ Impressive(x)) ::: All people who have a fully stocked and impressive home office are people who own a large desktop monitor at their home.\n∀x (WorkRegularly(x) ∧ WorkOften(x) → Tidy(x)) ::: All people who work regularly and often at home spend their free time tidying and organizing the spaces in their homes.\n∀x (WorkRegularly(x) ∧ WorkOften(x) → VisitStore(x)) ::: All people who work regularly and often at home visit the office supply store regularly.\n∀x (Tidy(x) → (¬Late(x) ∧ ¬WakeLate(x))) ::: If people spend their free time tidying and organizing the spaces in their home, then they do not go to bed late and wake up every day after noon.\n(Tidy(remy) ∧ Late(remy) ∧ WakeLate(remy)) ⊕ (¬Late(remy) ∧ ¬WakeLate(remy) ∧ ¬Tidy(remy)) ::: Remy either both goes to bed late and wakes up every day after noon and spends their free time tidying and organizing the spaces in their home, or they do not go to bed late and wake up every day after noon nor spend their free time tidying and organizing the spaces in their home.\n",
                "First-Order-Logic Question": "((Late(remy) ∧ WakeLate(remy)) ∨ VisitStore(remy)) → (¬Tidy(remy) ∧ ¬FullyStocked(remy)) ::: If Remy either goes to bed late and wakes up every day after noon or visits the office supply store regularly, then Remy neither spends their free time tidying and organizing the spaces in their home nor has a fully stocked and impressive home office."
            },
            "diff": [
                {
                    "raw": "∀x,y (Owns(x, y) → (WorkRegularly(x) ∧ WorkOften(x))) ::: If people own a large desktop monitor at their home, then they work regularly and often at home.",
                    "gram": "Impressive(x) ::: If people own a large desktop monitor at their home, then they work regularly and often at home."
                }
            ],
            "answer": "A",
            "error_type":"",
            "grammar_answer": "C"
        },
        {
            "id": 164,
            "raw_prog": {
                "First-Order-Logic Rules": "∃x ∃y (Roses(x) ∧ MondayAt8pm(y) ∧ GivenOut(x, y)) ::: On some Mondays at 8 pm, roses are given out on TV.\n∀x (GivenOut(x, TVShow(TheBachelor)) → On(x, TheBachelor)) ::: Every rose given out on TV is on the Bachelor.\n∀x (On(TheBachelor, x) → Portray(x, RealPeople)) ::: Everything on the Bachelor portrays the lives of real people.\n∀x (Portray(x, RealPeople) → RealityTVShow(x)) ::: All shows portraying the lives of real people are reality TV shows.\n¬RealityTVShow(BreakingBad) ::: Breaking Bad is not a reality TV show.\n",
                "First-Order-Logic Question": "∃x (Roses(x) ∧ MondayAt8pm(x)) ::: Breaking Bad is on Monday at 8 pm."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∃x ∃y (Roses(x) ∧ MondayAt8pm(y) ∧ GivenOut(x, y)) ::: On some Mondays at 8 pm, roses are given out on TV.\nGivenOut(x,y)∧TVShow(y)→On(x,y) ::: Every rose given out on TV is on the Bachelor.\n∀x (On(TheBachelor, x) → Portray(x, RealPeople)) ::: Everything on the Bachelor portrays the lives of real people.\n∀x (Portray(x, RealPeople) → RealityTVShow(x)) ::: All shows portraying the lives of real people are reality TV shows.\n¬RealityTVShow(BreakingBad) ::: Breaking Bad is not a reality TV show.\n",
                "First-Order-Logic Question": "∃x (Roses(x) ∧ MondayAt8pm(x)) ::: Breaking Bad is on Monday at 8 pm."
            },
            "diff": [
                {
                    "raw": "∀x (GivenOut(x, TVShow(TheBachelor)) → On(x, TheBachelor)) ::: Every rose given out on TV is on the Bachelor.",
                    "gram": "GivenOut(x,y)∧TVShow(y)→On(x,y) ::: Every rose given out on TV is on the Bachelor."
                }
            ],
            "answer": "C",
            "error_type":"",
            "grammar_answer": "C"
        },
        {
            "id": 166,
            "raw_prog": {
                "First-Order-Logic Rules": "∃x ∃y (Monday(y) ∧ Time(y) ∧ Roses(x) ∧ GivenOut(x, y)) ::: On some Mondays at 8 pm, roses are given out on TV.\n∀x (Roses(x) → On(x, Bachelor)) ::: Every rose given out on TV is on the Bachelor.\n∀x (On(x, Bachelor) → Portray(x, RealPeople)) ::: Everything on the Bachelor portrays the lives of real people.\n∀x (Portray(x, RealPeople) → RealityTVShow(x)) ::: All shows portraying the lives of real people are reality TV shows.\n¬RealityTVShow(BreakingBad) ::: Breaking Bad is not a reality TV show.\n",
                "First-Order-Logic Question": "∀x (Roses(x) ∧ GivenOut(x, Monday(8pm))) → On(BreakingBad, Monday(8pm)) ::: If roses are given out during Breaking Bad, then it is on Monday at 8 pm."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∃x ∃y (Monday(y) ∧ Time(y) ∧ Roses(x) ∧ GivenOut(x, y)) ::: On some Mondays at 8 pm, roses are given out on TV.\n∀x (Roses(x) → On(x, Bachelor)) ::: Every rose given out on TV is on the Bachelor.\n∀x (On(x, Bachelor) → Portray(x, RealPeople)) ::: Everything on the Bachelor portrays the lives of real people.\n∀x (Portray(x, RealPeople) → RealityTVShow(x)) ::: All shows portraying the lives of real people are reality TV shows.\n¬RealityTVShow(BreakingBad) ::: Breaking Bad is not a reality TV show.\n",
                "First-Order-Logic Question": "GivenOut(x,y)∧On(y,y)→On(x,y) ::: If roses are given out during Breaking Bad, then it is on Monday at 8 pm."
            },
            "diff": [
                {
                    "raw": "∀x (Roses(x) ∧ GivenOut(x, Monday(8pm))) → On(BreakingBad, Monday(8pm)) ::: If roses are given out during Breaking Bad, then it is on Monday at 8 pm.",
                    "gram": "GivenOut(x,y)∧On(y,y)→On(x,y) ::: If roses are given out during Breaking Bad, then it is on Monday at 8 pm."
                }
            ],
            "answer": "A",
            "error_type":"",
            "grammar_answer": "C"
        },
        {
            "id": 178,
            "raw_prog": {
                "First-Order-Logic Rules": "SportingEvent(olympicGames) ::: The Olympic games is a sporting event.\nLastOlympicGames(tokyo) ::: The last Olympic games was in Tokyo.\nWonMostMedals(unitedStates, tokyo) ::: The United States won the most medals in Tokyo.\n",
                "First-Order-Logic Question": "WonMostMedals(unitedStates, tokyo) ::: The United States won the most medals in the last Olympic games."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "SportingEvent(olympicGames) ::: The Olympic games is a sporting event.\nLastOlympicGames(tokyo) ::: The last Olympic games was in Tokyo.\nWonMostMedals(unitedStates, tokyo) ::: The United States won the most medals in Tokyo.\n",
                "First-Order-Logic Question": "WonMostMedals(unitedStates, tokyo) ::: The United States won the most medals in the last Olympic games."
            },
            "diff": [],
            "answer": "A",
            "error_type":"",
            "grammar_answer": "A"
        },
        {
            "id": 181,
            "raw_prog": {
                "First-Order-Logic Rules": "Flies(susan, LGA) ::: Susan flies to LGA airport.\n∀x (Airport(x) ∧ Flies(john, x) ∧ ¬(DepartsFrom(john, x) ∧ ArrivesAt(john, x))) ::: The departure and arrival can not be the same airport.\n",
                "First-Order-Logic Question": "Flies(john, LGA) ::: John flies to LGA airport."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "Flies(susan, LGA) ::: Susan flies to LGA airport.\n∀x (Airport(x) ∧ Flies(john, x) ∧ ¬(DepartsFrom(john, x) ∧ ArrivesAt(john, x))) ::: The departure and arrival can not be the same airport.\n",
                "First-Order-Logic Question": "Flies(john, LGA) ::: John flies to LGA airport."
            },
            "diff": [],
            "answer": "B",
            "error_type":"",
            "grammar_answer": "A"
        },
        {
            "id": 1,
            "raw_prog": {
                "First-Order-Logic Rules": "∀x (Perform(x) → (Attend(x) ∧ Engaged(x))) ::: If people perform in school talent shows often, then they attend and are very engaged with school events.\n∀x ((Perform(x) ∨ (Inactive(x) ∧ Disinterested(x))) ::: People either perform in school talent shows often or are inactive and disinterested members of their community.\n∀x (Chaperone(x) → ¬Student(x)) ::: If people chaperone high school dances, then they are not students who attend the school.\n∀x ((Inactive(x) ∧ Disinterested(x)) → Chaperone(x)) ::: All people who are inactive and disinterested members of their community chaperone high school dances.\n∀x ((Young(x) ∨ Teenager(x)) ∧ Wish(x) → Student(x)) ::: All young children and teenagers who wish to further their academic careers and educational opportunities are students who attend the school.\n¬((Attend(Bonnie) ∧ Engaged(Bonnie)) ⊕ Student(Bonnie)) ::: Bonnie either both attends and is very engaged with school events and is a student who attends the school, or she neither attends and is very engaged with school events nor is a student who attends the school.",
                "First-Order-Logic Question": "((Young(Bonnie) ∨ Teenager(Bonnie)) ∧ Wish(Bonnie) ∧ Chaperone(Bonnie)) ∨ ¬((Young(Bonnie) ∨ Teenager(Bonnie)) ∧ ¬Wish(Bonnie)) → (Student(Bonnie) ∨ (Inactive(Bonnie) ∧ Disinterested(Bonnie)))"
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∀x (Perform(x) → (Attend(x) ∧ Engaged(x))) ::: If people perform in school talent shows often, then they attend and are very engaged with school events.\nInactive(x)∧Disinterested(x)∨Perform(x) ::: People either perform in school talent shows often or are inactive and disinterested members of their community.\n∀x (Chaperone(x) → ¬Student(x)) ::: If people chaperone high school dances, then they are not students who attend the school.\n∀x ((Inactive(x) ∧ Disinterested(x)) → Chaperone(x)) ::: All people who are inactive and disinterested members of their community chaperone high school dances.\n∀x ((Young(x) ∨ Teenager(x)) ∧ Wish(x) → Student(x)) ::: All young children and teenagers who wish to further their academic careers and educational opportunities are students who attend the school.\n¬((Attend(Bonnie) ∧ Engaged(Bonnie)) ⊕ Student(Bonnie)) ::: Bonnie either both attends and is very engaged with school events and is a student who attends the school, or she neither attends and is very engaged with school events nor is a student who attends the school.",
                "First-Order-Logic Question": "((Young(Bonnie) ∨ Teenager(Bonnie)) ∧ Wish(Bonnie) ∧ Chaperone(Bonnie)) ∨ ¬((Young(Bonnie) ∨ Teenager(Bonnie)) ∧ ¬Wish(Bonnie)) → (Student(Bonnie) ∨ (Inactive(Bonnie) ∧ Disinterested(Bonnie)))"
            },
            "diff": [
                {
                    "raw": "∀x ((Perform(x) ∨ (Inactive(x) ∧ Disinterested(x))) ::: People either perform in school talent shows often or are inactive and disinterested members of their community.",
                    "gram": "Inactive(x)∧Disinterested(x)∨Perform(x) ::: People either perform in school talent shows often or are inactive and disinterested members of their community."
                }
            ],
            "answer": "A",
            "error_type":"",
            "grammar_answer": "A"
        },
        {
            "id": 74,
            "raw_prog": {
                "First-Order-Logic Rules": "∀x (Plate(x) → BeginWith(x, number34)) ::: All vehicle registration plates in Istanbul begin with the number 34.\n∀x (¬BeginWith(x, number34) → ¬InCity(x, istanbul)) ::: Plates that do not begin with the number 34 are not from Istanbul.\nInCity(joePlate, istanbul) ::: Joe's vehicle registration plate is from Istanbul.\nBeginWith(tomPlate, number35) ::: Tom's license plate begins with the number 35.\n∀x (BG(BeginWith(x, number35), ¬BeginWith(x, number34))) ::: If a license plate begins with the number 35, then it does not begin with the number 34.",
                "First-Order-Logic Question": "BeginWith(joePlate, number34) ::: Joe's license plate begins with the number 34."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∀x (Plate(x) → BeginWith(x, number34)) ::: All vehicle registration plates in Istanbul begin with the number 34.\n∀x (¬BeginWith(x, number34) → ¬InCity(x, istanbul)) ::: Plates that do not begin with the number 34 are not from Istanbul.\nInCity(joePlate, istanbul) ::: Joe's vehicle registration plate is from Istanbul.\nBeginWith(tomPlate, number35) ::: Tom's license plate begins with the number 35.\nInCity(x,y) ::: If a license plate begins with the number 35, then it does not begin with the number 34.",
                "First-Order-Logic Question": "BeginWith(joePlate, number34) ::: Joe's license plate begins with the number 34."
            },
            "diff": [
                {
                    "raw": "∀x (BG(BeginWith(x, number35), ¬BeginWith(x, number34))) ::: If a license plate begins with the number 35, then it does not begin with the number 34.",
                    "gram": "InCity(x,y) ::: If a license plate begins with the number 35, then it does not begin with the number 34."
                }
            ],
            "answer": "A",
            "error_type":"",
            "grammar_answer": "A"
        },
        {
            "id": 95,
            "raw_prog": {
                "First-Order-Logic Rules": "∃x ∃y (Pet(x) ∧ ManagedBuilding(y) ∧ AllowedIn(x, y)) ::: Pets are allowed in some managed buildings.\n∀x (RequireDeposit(x) → ∃y (RentApartment(y) ∧ Equal(SecurityDeposit(x), MonthlyRent(y, olivegarden)) ∨ MoreThan(SecurityDeposit(x), 1500))) ::: A deposit is required to rent an apartment in a managed building. The security deposit can be either equal to one month's rent or more.\nCat(fluffy) ∧ Pet(fluffy) ∧ Owner(tom, fluffy) ::: Fluffy is Tom's cat.\nCat(x) → Pet(x) ::: Cats are pets.\nManagedBuilding(olivegarden) ::: The Olive Garden is a managed building.\nMonthlyRent(2000, olivegarden) ::: The monthly rent at the Olive Garden is $2000.\nRentApartment(tom) ↔ (AllowedIn(tom, fluffy) ∧ ¬MoreThan(SecurityDeposit(olivegarden), 1500)) ::: Tom will rent an apartment in a managed building if and only if he is allowed to move in with Fluffy, and the security deposit is no more than $1500.\nMoreThan(2000, 1500) ::: 2000$ is more than $1500.",
                "First-Order-Logic Question": "Equal(SecurityDeposit(olivegarden), 2000) ∨ MoreThan(SecurityDeposit(olivegarden), 2000) ::: The security deposit at the Olive Garden is either $2000 or more."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∃x ∃y (Pet(x) ∧ ManagedBuilding(y) ∧ AllowedIn(x, y)) ::: Pets are allowed in some managed buildings.\nAllowedIn(x,y) ::: A deposit is required to rent an apartment in a managed building. The security deposit can be either equal to one month's rent or more.\nCat(fluffy) ∧ Pet(fluffy) ∧ Owner(tom, fluffy) ::: Fluffy is Tom's cat.\nCat(x) → Pet(x) ::: Cats are pets.\nManagedBuilding(olivegarden) ::: The Olive Garden is a managed building.\nMonthlyRent(2000, olivegarden) ::: The monthly rent at the Olive Garden is $2000.\nAllowedIn(y,z)∧¬MoreThan(y,z)→RentApartment(z) ::: Tom will rent an apartment in a managed building if and only if he is allowed to move in with Fluffy, and the security deposit is no more than $1500.\nMoreThan(2000, 1500) ::: 2000$ is more than $1500.",
                "First-Order-Logic Question": "AllowedIn(x,y) ::: The security deposit at the Olive Garden is either $2000 or more."
            },
            "diff": [
                {
                    "raw": "∀x (RequireDeposit(x) → ∃y (RentApartment(y) ∧ Equal(SecurityDeposit(x), MonthlyRent(y, olivegarden)) ∨ MoreThan(SecurityDeposit(x), 1500))) ::: A deposit is required to rent an apartment in a managed building. The security deposit can be either equal to one month's rent or more.",
                    "gram": "AllowedIn(x,y) ::: A deposit is required to rent an apartment in a managed building. The security deposit can be either equal to one month's rent or more."
                },
                {
                    "raw": "RentApartment(tom) ↔ (AllowedIn(tom, fluffy) ∧ ¬MoreThan(SecurityDeposit(olivegarden), 1500)) ::: Tom will rent an apartment in a managed building if and only if he is allowed to move in with Fluffy, and the security deposit is no more than $1500.",
                    "gram": "AllowedIn(y,z)∧¬MoreThan(y,z)→RentApartment(z) ::: Tom will rent an apartment in a managed building if and only if he is allowed to move in with Fluffy, and the security deposit is no more than $1500."
                },
                {
                    "raw": "Equal(SecurityDeposit(olivegarden), 2000) ∨ MoreThan(SecurityDeposit(olivegarden), 2000) ::: The security deposit at the Olive Garden is either $2000 or more.",
                    "gram": "AllowedIn(x,y) ::: The security deposit at the Olive Garden is either $2000 or more."
                }
            ],
            "answer": "A",
            "error_type":"",
            "grammar_answer": "A"
        },
        {
            "id": 103,
            "raw_prog": {
                "First-Order-Logic Rules": "∀x (Twins(x) ∨ Triplets(x) → SpendTimeWith(x, Siblings(x))) ::: If people are twins or triplets, then they spend a lot of time hanging out with and playing with their siblings.\n∀x (Siblings(x, y) → Twins(x) ∨ Triplets(x)) ::: If people have siblings who are the same age, then they are twins or triplets.\n∀x (Complain(x) → Siblings(x, y)) ::: If people complain often about annoying siblings, then they have siblings who are the same age.\n∀x (¬LiveAtHomeRegularly(x) → ¬DevelopBonds(x, y)) ::: If people do not live at home regularly, then they do not develop strong bonds with their family members.\n∀x (SpendTimeWith(x, Siblings(x)) → ¬LiveAtHomeRegularly(x)) ::: If people spend a lot of time hanging out with and playing with their siblings, then they often did not live at home regularly.\n(Twins(luke) ∧ DevelopBonds(luke, FamilyMembers)) ∨ (¬Twins(luke) ∧ ¬DevelopBonds(luke, FamilyMembers)) ::: Luke is either both a twin or triplet and develops strong bonds with his family members, or he neither is a twin or triplet nor develops strong bonds with his family members.\n",
                "First-Order-Logic Question": "Complain(luke) ::: Luke complains often about annoying siblings."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "LiveAtHomeRegularly(x)→(Twins(x)∨Triplets(x)) ::: If people are twins or triplets, then they spend a lot of time hanging out with and playing with their siblings.\n∀x (Siblings(x, y) → Twins(x) ∨ Triplets(x)) ::: If people have siblings who are the same age, then they are twins or triplets.\n∀x (Complain(x) → Siblings(x, y)) ::: If people complain often about annoying siblings, then they have siblings who are the same age.\n∀x (¬LiveAtHomeRegularly(x) → ¬DevelopBonds(x, y)) ::: If people do not live at home regularly, then they do not develop strong bonds with their family members.\nLiveAtHomeRegularly(x)→¬SpendTimeWith(x,y) ::: If people spend a lot of time hanging out with and playing with their siblings, then they often did not live at home regularly.\n(Twins(luke) ∧ DevelopBonds(luke, FamilyMembers)) ∨ (¬Twins(luke) ∧ ¬DevelopBonds(luke, FamilyMembers)) ::: Luke is either both a twin or triplet and develops strong bonds with his family members, or he neither is a twin or triplet nor develops strong bonds with his family members.\n",
                "First-Order-Logic Question": "Complain(luke) ::: Luke complains often about annoying siblings."
            },
            "diff": [
                {
                    "raw": "∀x (Twins(x) ∨ Triplets(x) → SpendTimeWith(x, Siblings(x))) ::: If people are twins or triplets, then they spend a lot of time hanging out with and playing with their siblings.",
                    "gram": "LiveAtHomeRegularly(x)→(Twins(x)∨Triplets(x)) ::: If people are twins or triplets, then they spend a lot of time hanging out with and playing with their siblings."
                },
                {
                    "raw": "∀x (SpendTimeWith(x, Siblings(x)) → ¬LiveAtHomeRegularly(x)) ::: If people spend a lot of time hanging out with and playing with their siblings, then they often did not live at home regularly.",
                    "gram": "LiveAtHomeRegularly(x)→¬SpendTimeWith(x,y) ::: If people spend a lot of time hanging out with and playing with their siblings, then they often did not live at home regularly."
                }
            ],
            "answer": "B",
            "error_type":"",
            "grammar_answer": "C"
        },
        {
            "id": 105,
            "raw_prog": {
                "First-Order-Logic Rules": "Cost(gre_test, 205) ::: It costs US $205 to take the GRE test.\n∀x ∀y (Prove(x, EconomicHardship(y)) → ProvideAid(ETS, y)) ::: ETS provides financial aid to those GRE applicants who prove economic hardship.\n∀x (EconomicHardship(x) ↔ (Difficulty(x, money) ∨ Difficulty(x, resources))) ::: Economic hardship refers to difficulty caused by having too little money or too few resources.\nSingleParent(tom) ::: Tom lives in a single-parent family.\nOutOfWork(tom_dad, more_than_1_year) ::: His dad has been out of work for more than a year.\n",
                "First-Order-Logic Question": "ApplyFor(tom, ETS, gre_test) ::: Tom can apply for financial aid from ETS to take the GRE test."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "Cost(gre_test, 205) ::: It costs US $205 to take the GRE test.\nApplyFor(x,y,z)∧Prove(x,z)→ProvideAid(y,z) ::: ETS provides financial aid to those GRE applicants who prove economic hardship.\n∀x (EconomicHardship(x) ↔ (Difficulty(x, money) ∨ Difficulty(x, resources))) ::: Economic hardship refers to difficulty caused by having too little money or too few resources.\nSingleParent(tom) ::: Tom lives in a single-parent family.\nOutOfWork(tom_dad, more_than_1_year) ::: His dad has been out of work for more than a year.\n",
                "First-Order-Logic Question": "ApplyFor(tom, ETS, gre_test) ::: Tom can apply for financial aid from ETS to take the GRE test."
            },
            "diff": [
                {
                    "raw": "∀x ∀y (Prove(x, EconomicHardship(y)) → ProvideAid(ETS, y)) ::: ETS provides financial aid to those GRE applicants who prove economic hardship.",
                    "gram": "ApplyFor(x,y,z)∧Prove(x,z)→ProvideAid(y,z) ::: ETS provides financial aid to those GRE applicants who prove economic hardship."
                }
            ],
            "answer": "A",
            "error_type":"",
            "grammar_answer": "C"
        },
        {
            "id": 108,
            "raw_prog": {
                "First-Order-Logic Rules": "∀x (SpillFood(x) → (¬TidySpaces(x) ∧ EnjoyCleaning(x))) ::: If people spill a lot of food on their clothing, then they do not tidy their spaces consistently and enjoy the process of cleaning.\n∀x (Foodie(x) → SpillFood(x)) ::: All foodies who go out frequently to find new food restaurants to try are people who spill a lot of food on their clothing.\n∀x (OnlyChild(x) → (TidySpaces(x) ∧ EnjoyCleaning(x))) ::: If people grew up as only children with no siblings, then they tidy their spaces consistently and enjoy the process of cleaning.\n∀x (BusyParents(x) → OnlyChild(x)) ::: If people have parents who are very busy with their regular jobs, then they grew up as only children with no siblings.\n∀x (HighIncomeHousehold(x) → BusyParents(Person(x))) ::: All households with a high net income have people who have parents who are very busy with their regular jobs.\n(SpillFood(Peter) ∧ OnlyChild(Peter)) ⊕ (¬SpillFood(Peter) ∧ ¬OnlyChild(Peter)) ::: Peter is either both a person who spills a lot of food on his clothing and grew up as an only child with no siblings, or he is neither a person who spills a lot of food on his clothing nor grew up as an only child with no siblings. ",
                "First-Order-Logic Question": "TidySpaces(Peter) ∧ EnjoyCleaning(Peter) ::: Peter tidies his space consistently and enjoys the process of cleaning."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∀x (SpillFood(x) → (¬TidySpaces(x) ∧ EnjoyCleaning(x))) ::: If people spill a lot of food on their clothing, then they do not tidy their spaces consistently and enjoy the process of cleaning.\n∀x (Foodie(x) → SpillFood(x)) ::: All foodies who go out frequently to find new food restaurants to try are people who spill a lot of food on their clothing.\n∀x (OnlyChild(x) → (TidySpaces(x) ∧ EnjoyCleaning(x))) ::: If people grew up as only children with no siblings, then they tidy their spaces consistently and enjoy the process of cleaning.\n∀x (BusyParents(x) → OnlyChild(x)) ::: If people have parents who are very busy with their regular jobs, then they grew up as only children with no siblings.\nGoOut(x) ::: All households with a high net income have people who have parents who are very busy with their regular jobs.\n(SpillFood(Peter) ∧ OnlyChild(Peter)) ⊕ (¬SpillFood(Peter) ∧ ¬OnlyChild(Peter)) ::: Peter is either both a person who spills a lot of food on his clothing and grew up as an only child with no siblings, or he is neither a person who spills a lot of food on his clothing nor grew up as an only child with no siblings. ",
                "First-Order-Logic Question": "TidySpaces(Peter) ∧ EnjoyCleaning(Peter) ::: Peter tidies his space consistently and enjoys the process of cleaning."
            },
            "diff": [
                {
                    "raw": "∀x (HighIncomeHousehold(x) → BusyParents(Person(x))) ::: All households with a high net income have people who have parents who are very busy with their regular jobs.",
                    "gram": "GoOut(x) ::: All households with a high net income have people who have parents who are very busy with their regular jobs."
                }
            ],
            "answer": "C",
            "error_type":"",
            "grammar_answer": "C"
        },
        {
            "id": 117,
            "raw_prog": {
                "First-Order-Logic Rules": "∀x ∀y (Man(x) ∧ Man(y) ∧ Taller(x, y) → Block(x, y)) ::: If a man is taller than another man, the taller one can block the other's shooting.\nMan(michael) ∧ ∀x (Classmate(x, michael) ∧ x ≠ michael → Taller(michael, x)) ::: Michael is a man who is taller than everyone else in his class.\n∀x ∀y ∀z (Taller(x, y) ∧ Taller(y, z) → Taller(x, z)) ::: If person x is taller than person y, and person y is taller than person z, than x is taller than z\nMan(peter) ∧ Taller(peter, michael) ::: Peter is a man who is taller than Michael.\n∀x (Shoot(x) ∧ ¬Jump(x) → Block(michael, x)) ::: Michael can block any shooting from a person as long as the person does not jump when shooting.\n¬Block(michael, windy) ::: Michael cannot block Windy's shooting.\n∀x (Jump(x) → GreatShooter(x)) ::: Every shooter who can jump when shooting is a great shooter.",
                "First-Order-Logic Question": "Block(peter, windy) ::: Peter can block Windy's shooting."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∀x ∀y (Man(x) ∧ Man(y) ∧ Taller(x, y) → Block(x, y)) ::: If a man is taller than another man, the taller one can block the other's shooting.\nGreatShooter(x) ::: Michael is a man who is taller than everyone else in his class.\n∀x ∀y ∀z (Taller(x, y) ∧ Taller(y, z) → Taller(x, z)) ::: If person x is taller than person y, and person y is taller than person z, than x is taller than z\nMan(peter) ∧ Taller(peter, michael) ::: Peter is a man who is taller than Michael.\n∀x (Shoot(x) ∧ ¬Jump(x) → Block(michael, x)) ::: Michael can block any shooting from a person as long as the person does not jump when shooting.\n¬Block(michael, windy) ::: Michael cannot block Windy's shooting.\n∀x (Jump(x) → GreatShooter(x)) ::: Every shooter who can jump when shooting is a great shooter.",
                "First-Order-Logic Question": "Block(peter, windy) ::: Peter can block Windy's shooting."
            },
            "diff": [
                {
                    "raw": "Man(michael) ∧ ∀x (Classmate(x, michael) ∧ x ≠ michael → Taller(michael, x)) ::: Michael is a man who is taller than everyone else in his class.",
                    "gram": "GreatShooter(x) ::: Michael is a man who is taller than everyone else in his class."
                }
            ],
            "answer": "C",
            "error_type":"",
            "grammar_answer": "C"
        },
        {
            "id": 129,
            "raw_prog": {
                "First-Order-Logic Rules": "∀x (HaveWedding(x) → HaveChild(x)) ::: All people who have a wedding are people who have at least one child.\n∀x (TravelToParisForHoneymoon(x) → HaveWedding(x)) ::: All people who travel to Paris for their honeymoon are people who have a wedding.\n∀x (Weddings(x) ∧ July(x) → BelongTo(x, TravelToParisForHoneymoon(x))) ::: All weddings that occur in July belong to people who travel to Paris for their honeymoon.\n∃x (Weddings(x) ∧ July(x) ∧ WellAttended(x)) ::: Some weddings in July are well-attended.\nHaveChild(John) → (¬TravelToParisForHoneymoon(John) ∧ ¬HaveWedding(John)) ::: If John has at least one child, then John does not travel to Paris for his honeymoon and does not have a wedding.\nHaveWedding(John) ∧ WellAttended(John) → (July(John) ∨ (¬July(John) ∧ TravelToParisForHoneymoon(John))) ::: If John has a wedding that is well-attended, then John has a wedding in July or, if not, then John travels to Paris for their honeymoon.",
                "First-Order-Logic Question": "¬WellAttended(John) ::: John does not have a wedding that is well-attended."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∀x (HaveWedding(x) → HaveChild(x)) ::: All people who have a wedding are people who have at least one child.\n∀x (TravelToParisForHoneymoon(x) → HaveWedding(x)) ::: All people who travel to Paris for their honeymoon are people who have a wedding.\nWellAttended(x)∧¬(July(x))→BelongTo(x,y) ::: All weddings that occur in July belong to people who travel to Paris for their honeymoon.\n∃x (Weddings(x) ∧ July(x) ∧ WellAttended(x)) ::: Some weddings in July are well-attended.\nHaveChild(John) → (¬TravelToParisForHoneymoon(John) ∧ ¬HaveWedding(John)) ::: If John has at least one child, then John does not travel to Paris for his honeymoon and does not have a wedding.\nHaveWedding(John) ∧ WellAttended(John) → (July(John) ∨ (¬July(John) ∧ TravelToParisForHoneymoon(John))) ::: If John has a wedding that is well-attended, then John has a wedding in July or, if not, then John travels to Paris for their honeymoon.",
                "First-Order-Logic Question": "¬WellAttended(John) ::: John does not have a wedding that is well-attended."
            },
            "diff": [
                {
                    "raw": "∀x (Weddings(x) ∧ July(x) → BelongTo(x, TravelToParisForHoneymoon(x))) ::: All weddings that occur in July belong to people who travel to Paris for their honeymoon.",
                    "gram": "WellAttended(x)∧¬(July(x))→BelongTo(x,y) ::: All weddings that occur in July belong to people who travel to Paris for their honeymoon."
                }
            ],
            "answer": "A",
            "error_type":"",
            "grammar_answer": "C"
        },
        {
            "id": 131,
            "raw_prog": {
                "First-Order-Logic Rules": "∀x HaveWedding(x) → HaveChild(x) ::: All people who have a wedding are people who have at least one child.\n∀x (TravelToParisForHoneymoon(x) → HaveWedding(x)) ::: All people who travel to Paris for their honeymoon are people who have a wedding.\n∀x (Weddings(x) ∧ July(x) → BelongTo(x, TravelToParisForHoneymoon(x))) ::: All weddings that occur in July belong to people who travel to Paris for their honeymoon.\n∃x (Weddings(x) ∧ July(x) ∧ WellAttended(x)) ::: Some weddings in July are well-attended.\nHaveChild(John) → ¬(TravelToParisForHoneymoon(John) ∧ HaveWedding(John)) ::: If John has at least one child, then John does not travel to Paris for his honeymoon and does not have a wedding.\nHaveWedding(John) ∧ WellAttended(John) → (July(John) ∨ (¬July(John) ∧ TravelToParisForHoneymoon(John))) ::: If John has a wedding that is well-attended, then John has a wedding in July or, if not, then John travels to Paris for their honeymoon.",
                "First-Order-Logic Question": "¬(WellAttended(John) ∨ TravelToParisForHoneymoon(John)) ::: John has neither a wedding that is well-attended nor does he travel to Paris for his honeymoon."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∀x HaveWedding(x) → HaveChild(x) ::: All people who have a wedding are people who have at least one child.\n∀x (TravelToParisForHoneymoon(x) → HaveWedding(x)) ::: All people who travel to Paris for their honeymoon are people who have a wedding.\nAttend(y)∧(July(y)→BelongTo(y,z)) ::: All weddings that occur in July belong to people who travel to Paris for their honeymoon.\n∃x (Weddings(x) ∧ July(x) ∧ WellAttended(x)) ::: Some weddings in July are well-attended.\nHaveChild(John) → ¬(TravelToParisForHoneymoon(John) ∧ HaveWedding(John)) ::: If John has at least one child, then John does not travel to Paris for his honeymoon and does not have a wedding.\nHaveWedding(John) ∧ WellAttended(John) → (July(John) ∨ (¬July(John) ∧ TravelToParisForHoneymoon(John))) ::: If John has a wedding that is well-attended, then John has a wedding in July or, if not, then John travels to Paris for their honeymoon.",
                "First-Order-Logic Question": "¬(WellAttended(John) ∨ TravelToParisForHoneymoon(John)) ::: John has neither a wedding that is well-attended nor does he travel to Paris for his honeymoon."
            },
            "diff": [
                {
                    "raw": "∀x (Weddings(x) ∧ July(x) → BelongTo(x, TravelToParisForHoneymoon(x))) ::: All weddings that occur in July belong to people who travel to Paris for their honeymoon.",
                    "gram": "Attend(y)∧(July(y)→BelongTo(y,z)) ::: All weddings that occur in July belong to people who travel to Paris for their honeymoon."
                }
            ],
            "answer": "A",
            "error_type":"",
            "grammar_answer": "C"
        },
        {
            "id": 154,
            "raw_prog": {
                "First-Order-Logic Rules": "∀x,y (Owns(x, y) → (WorkRegularlyAtHome(x) ∧ TidyOrganize(x))) ::: If people own a large desktop monitor at their home, then they work regularly and often at home.\n∀x,y (FullyStockedImpressiveHomeOffice(x) → LargeDesktopMonitor(x, y)) ::: All people who have a fully stocked and impressive home office are people who own a large desktop monitor at their home.\n∀x (WorkRegularlyAtHome(x) → TidyOrganize(x)) ::: All people who work regularly and often at home spend their free time tidying and organizing the spaces in their homes.\n∀x (WorkRegularlyAtHome(x) → VisitOfficeStore(x)) ::: All people who work regularly and often at home visit the office supply store regularly.\n∀x (TidyOrganize(x) → (¬GoToBedLate(x) ∧ ¬WakeUpAfterNoon(x))) ::: If people spend their free time tidying and organizing the spaces in their home, then they do not go to bed late and wake up every day after noon.\n(TidyOrganize(remy) ∧ (GoToBedLate(remy) ∧ WakeUpAfterNoon(remy))) ⊕ (¬GoToBedLate(remy) ∧ ¬WakeUpAfterNoon(remy) ∧ ¬TidyOrganize(remy)) ::: Remy either both goes to bed late and wakes up every day after noon and spends their free time tidying and organizing the spaces in their home, or they do not go to bed late and wake up every day after noon nor spend their free time tidying and organizing the spaces in their home.\n",
                "First-Order-Logic Question": "FullyStockedImpressiveHomeOffice(remy) ∧ VisitOfficeStore(remy) ::: Remy has a fully stocked and impressive home office and also visits the office supply store regularly."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "FullyStockedImpressiveHomeOffice(x)→(WorkRegularlyAtHome(x)∧TidyOrganize(x)) ::: If people own a large desktop monitor at their home, then they work regularly and often at home.\nFullyStockedImpressiveHomeOffice(x)→LargeDesktopMonitor(x,y) ::: All people who have a fully stocked and impressive home office are people who own a large desktop monitor at their home.\n∀x (WorkRegularlyAtHome(x) → TidyOrganize(x)) ::: All people who work regularly and often at home spend their free time tidying and organizing the spaces in their homes.\n∀x (WorkRegularlyAtHome(x) → VisitOfficeStore(x)) ::: All people who work regularly and often at home visit the office supply store regularly.\n∀x (TidyOrganize(x) → (¬GoToBedLate(x) ∧ ¬WakeUpAfterNoon(x))) ::: If people spend their free time tidying and organizing the spaces in their home, then they do not go to bed late and wake up every day after noon.\n(TidyOrganize(remy) ∧ (GoToBedLate(remy) ∧ WakeUpAfterNoon(remy))) ⊕ (¬GoToBedLate(remy) ∧ ¬WakeUpAfterNoon(remy) ∧ ¬TidyOrganize(remy)) ::: Remy either both goes to bed late and wakes up every day after noon and spends their free time tidying and organizing the spaces in their home, or they do not go to bed late and wake up every day after noon nor spend their free time tidying and organizing the spaces in their home.\n",
                "First-Order-Logic Question": "FullyStockedImpressiveHomeOffice(remy) ∧ VisitOfficeStore(remy) ::: Remy has a fully stocked and impressive home office and also visits the office supply store regularly."
            },
            "diff": [
                {
                    "raw": "∀x,y (Owns(x, y) → (WorkRegularlyAtHome(x) ∧ TidyOrganize(x))) ::: If people own a large desktop monitor at their home, then they work regularly and often at home.",
                    "gram": "FullyStockedImpressiveHomeOffice(x)→(WorkRegularlyAtHome(x)∧TidyOrganize(x)) ::: If people own a large desktop monitor at their home, then they work regularly and often at home."
                }
            ],
            "answer": "B",
            "error_type":"",
            "grammar_answer": "B"
        },
        {
            "id": 165,
            "raw_prog": {
                "First-Order-Logic Rules": "∃x ∃y (Roses(x) ∧ GivenOut(x, y) ∧ y = 8pm ∧ y = Monday) ::: On some Mondays at 8 pm, roses are given out on TV.\n∀x (Roses(x) → On(x, Bachelor)) ::: Every rose given out on TV is on the Bachelor.\n∀x (On(x, Bachelor) → Portray(x, RealPeople)) ::: Everything on the Bachelor portrays the lives of real people.\n∀x (Portray(x, RealPeople) → RealityTVShow(x)) ::: All shows portraying the lives of real people are reality TV shows.\n¬RealityTVShow(BreakingBad) ::: Breaking Bad is not a reality TV show.\n",
                "First-Order-Logic Question": "BreakingBad(x) ∧ ∃y (Roses(y) ∧ GivenOut(y, 8pm) ∧ y = Monday) ::: Breaking Bad is a TV show in which roses are given out on Monday at 8 pm."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "GivenOut(x,y)∧On(y,y)∧TVShow(y) ::: On some Mondays at 8 pm, roses are given out on TV.\n∀x (Roses(x) → On(x, Bachelor)) ::: Every rose given out on TV is on the Bachelor.\n∀x (On(x, Bachelor) → Portray(x, RealPeople)) ::: Everything on the Bachelor portrays the lives of real people.\n∀x (Portray(x, RealPeople) → RealityTVShow(x)) ::: All shows portraying the lives of real people are reality TV shows.\n¬RealityTVShow(BreakingBad) ::: Breaking Bad is not a reality TV show.\n",
                "First-Order-Logic Question": "GivenOut(y,y)∧On(y,y)→TVShow(y) ::: Breaking Bad is a TV show in which roses are given out on Monday at 8 pm."
            },
            "diff": [
                {
                    "raw": "∃x ∃y (Roses(x) ∧ GivenOut(x, y) ∧ y = 8pm ∧ y = Monday) ::: On some Mondays at 8 pm, roses are given out on TV.",
                    "gram": "GivenOut(x,y)∧On(y,y)∧TVShow(y) ::: On some Mondays at 8 pm, roses are given out on TV."
                },
                {
                    "raw": "BreakingBad(x) ∧ ∃y (Roses(y) ∧ GivenOut(y, 8pm) ∧ y = Monday) ::: Breaking Bad is a TV show in which roses are given out on Monday at 8 pm.",
                    "gram": "GivenOut(y,y)∧On(y,y)→TVShow(y) ::: Breaking Bad is a TV show in which roses are given out on Monday at 8 pm."
                }
            ],
            "answer": "B",
            "error_type":"",
            "grammar_answer": "A"
        },
        {
            "id": 180,
            "raw_prog": {
                "First-Order-Logic Rules": "Flies(susan, lga) ::: Susan flies to LGA airport.\nDeparture(x, y) ∧ Arrival(x, y) ⊕ ¬(x = y) ::: The departure and arrival can not be the same airport.\nFrom(john, lga) ::: John flies from LGA airport.",
                "First-Order-Logic Question": "From(susan, lga) ::: Susan flies from LGA airport."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "Flies(susan, lga) ::: Susan flies to LGA airport.\nAirport(x)∧Departure(x,y)∧Arrival(x,y)⊕¬(Departure(x,y)∧Arrival(x,y)) ::: The departure and arrival can not be the same airport.\nFrom(john, lga) ::: John flies from LGA airport.",
                "First-Order-Logic Question": "From(susan, lga) ::: Susan flies from LGA airport."
            },
            "diff": [
                {
                    "raw": "Departure(x, y) ∧ Arrival(x, y) ⊕ ¬(x = y) ::: The departure and arrival can not be the same airport.",
                    "gram": "Airport(x)∧Departure(x,y)∧Arrival(x,y)⊕¬(Departure(x,y)∧Arrival(x,y)) ::: The departure and arrival can not be the same airport."
                }
            ],
            "answer": "B",
            "error_type":"",
            "grammar_answer": "C"
        },
        {
            "id": 199,
            "raw_prog": {
                "First-Order-Logic Rules": "Person(ailtonSilva) ∧ Born(ailtonSilva, 1995) ∧ KnownAs(ailtonSilva, ailton) ∧ FootballPlayer(ailton) ∧ Loan(ailton, braga) ∧ Brazilian(ailtonSilva) ∧ PlaysFor(ailtonSilva, nautico) ∧ Club(nautico) ∧ Club(braga) ∧ Club(fluminense) ::: Ailton Silva, born in 1995, is commonly known as Ailton. Ailton is a football player who was loaned out to Braga. Ailton Silva is a Brazillian footballer who plays for Nautico. Nautico is a football club along with Braga. Fluminense is a football club.",
                "First-Order-Logic Question": "¬∃x (PlaysFor(x, nautico) ∧ Brazilian(x)) ::: No one playing for Nautico is Brazilian."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "FootballPlayer(x)∧Loan(x,y)→KnownAs(y,x) ::: Ailton Silva, born in 1995, is commonly known as Ailton. Ailton is a football player who was loaned out to Braga. Ailton Silva is a Brazillian footballer who plays for Nautico. Nautico is a football club along with Braga. Fluminense is a football club.",
                "First-Order-Logic Question": "¬∃x (PlaysFor(x, nautico) ∧ Brazilian(x)) ::: No one playing for Nautico is Brazilian."
            },
            "diff": [
                {
                    "raw": "Person(ailtonSilva) ∧ Born(ailtonSilva, 1995) ∧ KnownAs(ailtonSilva, ailton) ∧ FootballPlayer(ailton) ∧ Loan(ailton, braga) ∧ Brazilian(ailtonSilva) ∧ PlaysFor(ailtonSilva, nautico) ∧ Club(nautico) ∧ Club(braga) ∧ Club(fluminense) ::: Ailton Silva, born in 1995, is commonly known as Ailton. Ailton is a football player who was loaned out to Braga. Ailton Silva is a Brazillian footballer who plays for Nautico. Nautico is a football club along with Braga. Fluminense is a football club.",
                    "gram": "FootballPlayer(x)∧Loan(x,y)→KnownAs(y,x) ::: Ailton Silva, born in 1995, is commonly known as Ailton. Ailton is a football player who was loaned out to Braga. Ailton Silva is a Brazillian footballer who plays for Nautico. Nautico is a football club along with Braga. Fluminense is a football club."
                }
            ],
            "answer": "B",
            "error_type":"",
            "grammar_answer": "C"
        },
        {
            "id": 201,
            "raw_prog": {
                "First-Order-Logic Rules": "Person(ailtonSilva) ∧ Born(ailtonSilva, 1995) ∧ KnownAs(ailtonSilva, ailton) ::: Ailton Silva, born in 1995, is commonly known as Ailton.\nFootballPlayer(ailton) ∧ Loan(ailton, braga) ::: Ailton is a football player who was loaned out to Braga.\nBrazilian(ailtonSilva) ∧ FootballPlayer(ailtonSilva) ∧ PlaysFor(ailtonSilva, nautico) ::: Ailton Silva is a Brazillian footballer who plays for Nautico.\nClub(nautico) ∧ Club(braga) ∧ Team(nautico, braga) ::: Nautico is a football club along with Braga.\nClub(fluminense) ::: Fluminense is a football club.\n",
                "First-Order-Logic Question": "¬(∃x Loan(ailton, Club(x))) ::: Ailton was not loaned out to a football club."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "Person(ailtonSilva) ∧ Born(ailtonSilva, 1995) ∧ KnownAs(ailtonSilva, ailton) ::: Ailton Silva, born in 1995, is commonly known as Ailton.\nFootballPlayer(ailton) ∧ Loan(ailton, braga) ::: Ailton is a football player who was loaned out to Braga.\nBrazilian(ailtonSilva) ∧ FootballPlayer(ailtonSilva) ∧ PlaysFor(ailtonSilva, nautico) ::: Ailton Silva is a Brazillian footballer who plays for Nautico.\nClub(nautico) ∧ Club(braga) ∧ Team(nautico, braga) ::: Nautico is a football club along with Braga.\nClub(fluminense) ::: Fluminense is a football club.\n",
                "First-Order-Logic Question": "FootballPlayer(x)→¬Loan(x,y) ::: Ailton was not loaned out to a football club."
            },
            "diff": [
                {
                    "raw": "¬(∃x Loan(ailton, Club(x))) ::: Ailton was not loaned out to a football club.",
                    "gram": "FootballPlayer(x)→¬Loan(x,y) ::: Ailton was not loaned out to a football club."
                }
            ],
            "answer": "B",
            "error_type":"",
            "grammar_answer": "C"
        },
        {
            "id": 11,
            "raw_prog": {
                "First-Order-Logic Rules": "WildTurkey(tom) ::: Tom is a wild turkey.\n∀x (WildTurkey(x) → (x = EasternWildTurkey ∨ x = OsceolaWildTurkey ∨ x = GouldsWildTurkey ∨ x = MerriamsWildTurkey ∨ x = RioGrandeWildTurkey ∨ x = OcellatedWildTurkey)) ::: There are six types of wild turkeys: Eastern wild turkey, Osceola wild turkey, Gould’s wild turkey, Merriam’s wild turkey, Rio Grande wild turkey, and Ocellated wild turkey.\n¬EasternWildTurkey(tom) ∧ ¬OsceolaWildTurkey(tom) ∧ ¬GouldsWildTurkey(tom) ∧ ¬MerriamsWildTurkey(tom) ∧ ¬RioGrandeWildTurkey(tom) ::: Tom is not an Eastern wild turkey, Osceola wild turkey, Gould's wild turkey, Merriam's wild turkey, or Rio Grande wild turkey.\n",
                "First-Order-Logic Question": "WildTurkey(joey) ::: Joey is a wild turkey."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "WildTurkey(tom) ::: Tom is a wild turkey.\nTomWildTurkey(x)∨WildTurkey(x)→(EasternWildTurkey(x)∨OsceolaWildTurkey(x)) ::: There are six types of wild turkeys: Eastern wild turkey, Osceola wild turkey, Gould’s wild turkey, Merriam’s wild turkey, Rio Grande wild turkey, and Ocellated wild turkey.\n¬EasternWildTurkey(tom)∧¬OsceolaWildTurkey(tom)∧¬GouldsWildTurkey(tom)∧¬MerriamsWildTurkey(tom)∧¬RioGrandeWildTurkey(tom) ::: Tom is not an Eastern wild turkey, Osceola wild turkey, Gould's wild turkey, Merriam's wild turkey, or Rio Grande wild turkey.",
                "First-Order-Logic Question": "WildTurkey(joey) ::: Joey is a wild turkey."
            },
            "diff": [],
            "answer": "C",
            "error_type":"",
            "grammar_answer": "A"
        },
        {
            "id": 14,
            "raw_prog": {
                "First-Order-Logic Rules": "Create(japaneseGameCompany, legendOfZelda) ::: A Japanese game company created the game the Legend of Zelda.\n∀x (Game(x) ∧ MoreThanOneMillion(x) → Select(x, Top10(x))) ::: If a game sells more than one million copies, then it will be selected into the Top 10 list.\n∀x (Top10(x) → Japanese(Create(japanese, x))) ::: All games in the Top 10 list are made by Japanese game companies.\nMoreThanOneMillion(legendOfZelda) ::: The Legend of Zelda sold more than one million copies.",
                "First-Order-Logic Question": "¬Top10(legendOfZelda) ::: The Legend of Zelda is not in the Top 10 list."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "Create(japaneseGameCompany, legendOfZelda) ::: A Japanese game company created the game the Legend of Zelda.\nTop10(x)∧(Game(x)∧MoreThanOneMillion(x)) ::: If a game sells more than one million copies, then it will be selected into the Top 10 list.\nTop10(x)→Japanese(y,x) ::: All games in the Top 10 list are made by Japanese game companies.\nMoreThanOneMillion(legendOfZelda) ::: The Legend of Zelda sold more than one million copies.",
                "First-Order-Logic Question": "¬Top10(legendOfZelda) ::: The Legend of Zelda is not in the Top 10 list."
            },
            "diff": [
                {
                    "raw": "∀x (Game(x) ∧ MoreThanOneMillion(x) → Select(x, Top10(x))) ::: If a game sells more than one million copies, then it will be selected into the Top 10 list.",
                    "gram": "Top10(x)∧(Game(x)∧MoreThanOneMillion(x)) ::: If a game sells more than one million copies, then it will be selected into the Top 10 list."
                },
                {
                    "raw": "∀x (Top10(x) → Japanese(Create(japanese, x))) ::: All games in the Top 10 list are made by Japanese game companies.",
                    "gram": "Top10(x)→Japanese(y,x) ::: All games in the Top 10 list are made by Japanese game companies."
                }
            ],
            "answer": "B",
            "error_type":"",
            "grammar_answer": "B"
        },
        {
            "id": 39,
            "raw_prog": {
                "First-Order-Logic Rules": "∀x (DesignStyle(x, ZahaHadid) → Timeless(x)) ::: All of Zaha Hadid's design styles are timeless. \n∀x (MassProductDesign(x) → ¬Timeless(x)) ::: No mass product design is timeless. \n(DesignStyle(ZahaHadid, y) ∨ DesignStyle(KellyWearstler, y)) ::: Either Zaha Hadid's design style or Kelly Wearstler's design style. \n∀x (DesignStyle(x, KellyWearstler) → Evocative(x)) ::: All of Kelly Wearstler's design styles are evocative. \n∀x (DesignStyle(x, KellyWearstler) → Dreamy(x)) ::: All of Kelly Wearstler's design styles are dreamy. \n∀x (Timeless(DesignBy(x, Max)) → (MassProductDesign(DesignBy(x, Max)) ∧ Evocative(DesignBy(x, Max)))) ::: If a design by Max is timeless, then a design by Max is a mass product design and evocative.\n",
                "First-Order-Logic Question": "MassProductDesign(DesignBy(Max, Max)) ::: A design by Max is a mass product design."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∀x (DesignStyle(x, ZahaHadid) → Timeless(x)) ::: All of Zaha Hadid's design styles are timeless. \n∀x (MassProductDesign(x) → ¬Timeless(x)) ::: No mass product design is timeless. \n(DesignStyle(ZahaHadid, y) ∨ DesignStyle(KellyWearstler, y)) ::: Either Zaha Hadid's design style or Kelly Wearstler's design style. \n∀x (DesignStyle(x, KellyWearstler) → Evocative(x)) ::: All of Kelly Wearstler's design styles are evocative. \n∀x (DesignStyle(x, KellyWearstler) → Dreamy(x)) ::: All of Kelly Wearstler's design styles are dreamy. \nDreamy(x)→(MassProductDesign(y)∧Evocative(y)) ::: If a design by Max is timeless, then a design by Max is a mass product design and evocative.\n",
                "First-Order-Logic Question": "DesignBy(y,z)∧MassProductDesign(z)→MassProductDesign(y) ::: A design by Max is a mass product design."
            },
            "diff": [
                {
                    "raw": "∀x (Timeless(DesignBy(x, Max)) → (MassProductDesign(DesignBy(x, Max)) ∧ Evocative(DesignBy(x, Max)))) ::: If a design by Max is timeless, then a design by Max is a mass product design and evocative.",
                    "gram": "Dreamy(x)→(MassProductDesign(y)∧Evocative(y)) ::: If a design by Max is timeless, then a design by Max is a mass product design and evocative."
                },
                {
                    "raw": "MassProductDesign(DesignBy(Max, Max)) ::: A design by Max is a mass product design.",
                    "gram": "DesignBy(y,z)∧MassProductDesign(z)→MassProductDesign(y) ::: A design by Max is a mass product design."
                }
            ],
            "answer": "C",
            "error_type":"",
            "grammar_answer": "A"
        },
        {
            "id": 41,
            "raw_prog": {
                "First-Order-Logic Rules": "∀x (DesignStyle(x, ZahaHadid) → Timeless(x)) ::: All of Zaha Hadid's design styles are timeless.\n∀x (MassProductDesign(x) → ¬Timeless(x)) ::: No mass product design is timeless.\nDesignStyle(ZahaHadid, y) ∨ DesignStyle(KellyWearstler, y) ::: Either Zaha Hadid's design style or Kelly Wearstler's design style.\n∀x (DesignStyle(x, KellyWearstler) → Evocative(x)) ::: All of Kelly Wearstler's design styles are evocative.\n∀x (DesignStyle(x, KellyWearstler) → Dreamy(x)) ::: All of Kelly Wearstler's design styles are dreamy.\n∀x (Timeless(DesignBy(x, Max)) → (MassProductDesign(DesignBy(x, Max)) ∧ Evocative(DesignBy(x, Max)))) ::: If a design by Max is timeless, then a design by Max is a mass product design and evocative.\n",
                "First-Order-Logic Question": "Evocative(DesignBy(Max, Max)) ∨ Dreamy(DesignBy(Max, Max)) ::: A design by Max is either evocative or dreamy."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∀x (DesignStyle(x, ZahaHadid) → Timeless(x)) ::: All of Zaha Hadid's design styles are timeless.\n∀x (MassProductDesign(x) → ¬Timeless(x)) ::: No mass product design is timeless.\nDesignStyle(ZahaHadid, y) ∨ DesignStyle(KellyWearstler, y) ::: Either Zaha Hadid's design style or Kelly Wearstler's design style.\n∀x (DesignStyle(x, KellyWearstler) → Evocative(x)) ::: All of Kelly Wearstler's design styles are evocative.\n∀x (DesignStyle(x, KellyWearstler) → Dreamy(x)) ::: All of Kelly Wearstler's design styles are dreamy.\nDreamy(x)→(MassProductDesign(y)∧Evocative(y)) ::: If a design by Max is timeless, then a design by Max is a mass product design and evocative.\n",
                "First-Order-Logic Question": "DesignBy(y,z)∧Evocative(z)∨DesignBy(y,z)∧Dreamy(z) ::: A design by Max is either evocative or dreamy."
            },
            "diff": [
                {
                    "raw": "∀x (Timeless(DesignBy(x, Max)) → (MassProductDesign(DesignBy(x, Max)) ∧ Evocative(DesignBy(x, Max)))) ::: If a design by Max is timeless, then a design by Max is a mass product design and evocative.",
                    "gram": "Dreamy(x)→(MassProductDesign(y)∧Evocative(y)) ::: If a design by Max is timeless, then a design by Max is a mass product design and evocative."
                },
                {
                    "raw": "Evocative(DesignBy(Max, Max)) ∨ Dreamy(DesignBy(Max, Max)) ::: A design by Max is either evocative or dreamy.",
                    "gram": "DesignBy(y,z)∧Evocative(z)∨DesignBy(y,z)∧Dreamy(z) ::: A design by Max is either evocative or dreamy."
                }
            ],
            "answer": "B",
            "error_type":"",
            "grammar_answer": "A"
        },
        {
            "id": 85,
            "raw_prog": {
                "First-Order-Logic Rules": "∀x (Listed(x) → ¬NotNegative(x)) ::: If the restaurant is listed in Yelp’s recommendations, then the restaurant does not receive many negative reviews.\n∀x (Rating(x, y) ∧ y > 9 → Listed(x)) ::: All restaurants with a rating greater than 9 are listed in Yelp’s recommendations.\n∃x (Restaurant(x) ∧ ¬Provide(x, takeout) → NotNegative(x)) ::: Some restaurants that do not provide take-out service receive many negative reviews.\n∀x (Popular(x) → Rating(x, y) ∧ y > 9) ::: All restaurants that are popular among local residents have ratings greater than 9.\nRating(subway, y) ∨ Popular(subway) ::: Subway has a rating greater than 9 or is popular among local residents.\n",
                "First-Order-Logic Question": "TakeOut(subway) ∧ ¬NotNegative(subway) ::: Subway provides take-out service and does not receive many negative reviews."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∀x (Listed(x) → ¬NotNegative(x)) ::: If the restaurant is listed in Yelp’s recommendations, then the restaurant does not receive many negative reviews.\nProvide(x,y)∧NotNegative(x)∧Rating(x,y)∧Popular(x)∧TakeOut(x)∧Restaurant(x)∧¬(SubwayRestaurant(x)) ::: All restaurants with a rating greater than 9 are listed in Yelp’s recommendations.\n∃x (Restaurant(x) ∧ ¬Provide(x, takeout) → NotNegative(x)) ::: Some restaurants that do not provide take-out service receive many negative reviews.\nProvide(x,y)→Rating(x,y)∧(NotNegative(x)) ::: All restaurants that are popular among local residents have ratings greater than 9.\nRating(subway, y) ∨ Popular(subway) ::: Subway has a rating greater than 9 or is popular among local residents.",
                "First-Order-Logic Question": "TakeOut(subway) ∧ ¬NotNegative(subway) ::: Subway provides take-out service and does not receive many negative reviews."
            },
            "diff": [],
            "answer": "A",
            "error_type":"",
            "grammar_answer": "B"
        },
        {
            "id": 87,
            "raw_prog": {
                "First-Order-Logic Rules": "∀x (SuperheroMovie(x) → Win(GoodGuy(x))) ::: In superhero movies, the good guys always win.\nSuperheroMovie(sir_digby) ∧ NamedAfter(sir_digby, sir_digby) ::: The Surprising Adventures of Sir Digby Chicken Caesar is a superhero movie.\n∀x (GoodGuy(x) → Fight(x, BadGuy(x)) ∧ Fight(BadGuy(x), x)) ::: Good guys fight bad guys and vice versa.\nFight(sir_digby, nemesis) ::: Sir Digby fights his nemesis.\n∀x (SuperheroMovie(x) ∧ NamedAfter(x, character) → GoodGuy(character)) ::: If a superhero movie is named after a character, that character is a good guy.\nNamedAfter(sir_digby, sir_digby) ::: The Surprising Adventures of Sir Digby Chicken Caesar is named after Sir Digby.\n∀x ∀y (Win(x) → Lose(y)) ::: If somebody wins a fight, the person they are fighting loses.\n∀x ∀y (SuperheroMovie(x) ∧ NamedAfter(x, y) → AppearIn(y, x)) ::: If a superhero movie is named after a character, that character appears in the movie.\n",
                "First-Order-Logic Question": "Lose(nemesis) ::: Sir Digby’s nemesis loses."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "AppearIn(x,y)∧SuperheroMovie(y)→Win(x) ::: In superhero movies, the good guys always win.\nSuperheroMovie(sir_digby) ∧ NamedAfter(sir_digby, sir_digby) ::: The Surprising Adventures of Sir Digby Chicken Caesar is a superhero movie.\nAppearIn(x,y)∧GoodGuy(x)→Fight(x,y) ::: Good guys fight bad guys and vice versa.\nFight(sir_digby, nemesis) ::: Sir Digby fights his nemesis.\n∀x (SuperheroMovie(x) ∧ NamedAfter(x, character) → GoodGuy(character)) ::: If a superhero movie is named after a character, that character is a good guy.\nNamedAfter(sir_digby, sir_digby) ::: The Surprising Adventures of Sir Digby Chicken Caesar is named after Sir Digby.\n∀x ∀y (Win(x) → Lose(y)) ::: If somebody wins a fight, the person they are fighting loses.\n∀x ∀y (SuperheroMovie(x) ∧ NamedAfter(x, y) → AppearIn(y, x)) ::: If a superhero movie is named after a character, that character appears in the movie.\n",
                "First-Order-Logic Question": "Lose(nemesis) ::: Sir Digby’s nemesis loses."
            },
            "diff": [
                {
                    "raw": "∀x (SuperheroMovie(x) → Win(GoodGuy(x))) ::: In superhero movies, the good guys always win.",
                    "gram": "AppearIn(x,y)∧SuperheroMovie(y)→Win(x) ::: In superhero movies, the good guys always win."
                },
                {
                    "raw": "∀x (GoodGuy(x) → Fight(x, BadGuy(x)) ∧ Fight(BadGuy(x), x)) ::: Good guys fight bad guys and vice versa.",
                    "gram": "AppearIn(x,y)∧GoodGuy(x)→Fight(x,y) ::: Good guys fight bad guys and vice versa."
                }
            ],
            "answer": "A",
            "error_type":"",
            "grammar_answer": "A"
        },
        {
            "id": 106,
            "raw_prog": {
                "First-Order-Logic Rules": "Cost(gre, 205) ::: It costs US $205 to take the GRE test.\n∀x ∀y (TakeTest(x, gre) ∧ EconomicHardship(y) ∧ Difficulty(y, money) → ProvideAid(ets, x)) ::: ETS provides financial aid to those GRE applicants who prove economic hardship.\n∀x (EconomicHardship(x) ↔ (Difficulty(x, money) ∨ Difficulty(x, resources))) ::: Economic hardship refers to difficulty caused by having too little money or too few resources.\nSingleParentFamily(tom) ::: Tom lives in a single-parent family.\nOutOfWork(tom's dad, more than a year) ::: His dad has been out of work for more than a year.\n",
                "First-Order-Logic Question": "∃x (Cost(gre, x) ∧ x < 300) ::: It cost below US $300 to take the GRE test."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "Cost(gre, 205) ::: It costs US $205 to take the GRE test.\n∀x ∀y (TakeTest(x, gre) ∧ EconomicHardship(y) ∧ Difficulty(y, money) → ProvideAid(ets, x)) ::: ETS provides financial aid to those GRE applicants who prove economic hardship.\n∀x (EconomicHardship(x) ↔ (Difficulty(x, money) ∨ Difficulty(x, resources))) ::: Economic hardship refers to difficulty caused by having too little money or too few resources.\nSingleParentFamily(tom) ::: Tom lives in a single-parent family.\nProvideAid(x,y) ::: His dad has been out of work for more than a year.\n",
                "First-Order-Logic Question": "ProvideAid(y,x)∧Cost(y,x)→Cost(y,x) ::: It cost below US $300 to take the GRE test."
            },
            "diff": [
                {
                    "raw": "OutOfWork(tom's dad, more than a year) ::: His dad has been out of work for more than a year.",
                    "gram": "ProvideAid(x,y) ::: His dad has been out of work for more than a year."
                },
                {
                    "raw": "∃x (Cost(gre, x) ∧ x < 300) ::: It cost below US $300 to take the GRE test.",
                    "gram": "ProvideAid(y,x)∧Cost(y,x)→Cost(y,x) ::: It cost below US $300 to take the GRE test."
                }
            ],
            "answer": "A",
            "error_type":"",
            "grammar_answer": "A"
        },
        {
            "id": 107,
            "raw_prog": {
                "First-Order-Logic Rules": "Costs(gre, 205) ::: It costs US $205 to take the GRE test.\n∀x ∀y (Prove(x, EconomicHardship(y)) → ProvidesAid(ETS, y)) ::: ETS provides financial aid to those GRE applicants who prove economic hardship.\n∀x (EconomicHardship(x) ↔ (TooLittleMoney(x) ∨ TooFewResources(x))) ::: Economic hardship refers to difficulty caused by having too little money or too few resources.\nSingleParent(tom) ::: Tom lives in a single-parent family.\nOutOfWork(dad, moreThanAYear) ::: His dad has been out of work for more than a year.\n",
                "First-Order-Logic Question": "¬∃x ∀y (Costs(gre, y) ∧ ProvidesAid(ETS, x)) ::: There is no financial aid available for the GRE test."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "Costs(gre, 205) ::: It costs US $205 to take the GRE test.\nAvailable(y)∧¬EconomicHardship(y)→ProvidesAid(y,x) ::: ETS provides financial aid to those GRE applicants who prove economic hardship.\n∀x (EconomicHardship(x) ↔ (TooLittleMoney(x) ∨ TooFewResources(x))) ::: Economic hardship refers to difficulty caused by having too little money or too few resources.\nSingleParent(tom) ::: Tom lives in a single-parent family.\nOutOfWork(dad, moreThanAYear) ::: His dad has been out of work for more than a year.\n",
                "First-Order-Logic Question": "¬∃x ∀y (Costs(gre, y) ∧ ProvidesAid(ETS, x)) ::: There is no financial aid available for the GRE test."
            },
            "diff": [
                {
                    "raw": "∀x ∀y (Prove(x, EconomicHardship(y)) → ProvidesAid(ETS, y)) ::: ETS provides financial aid to those GRE applicants who prove economic hardship.",
                    "gram": "Available(y)∧¬EconomicHardship(y)→ProvidesAid(y,x) ::: ETS provides financial aid to those GRE applicants who prove economic hardship."
                }
            ],
            "answer": "B",
            "error_type":"",
            "grammar_answer": "C"
        },
        {
            "id": 114,
            "raw_prog": {
                "First-Order-Logic Rules": "MountainRange(picurismountains) ∨ MountainRange(picurismountains) ::: The Picuris Mountains are a mountain range in New Mexico or Texas.\nVisited(juandeonate, picurismountains) ::: Juan de Onate visited the Picuris Mountains.\nLocatedIn(hardingpegmatitemine, picurismountains) ∧ Donated(hardingpegmatitemine) ::: The Harding Pegmatite Mine, located in the Picuris Mountains, was donated.\n∀x (MountainRange(x) ∧ In(x, texas) → ¬∃y (Mine(y) ∧ Has(y, donated) ∧ LocatedIn(y, x))) ::: There are no mountain ranges in Texas that have mines which have been donated.\n",
                "First-Order-Logic Question": "NotLocatedIn(hardingpegmatitemine, newmexico) ::: The Harding Pegmatite Mine is not located in a mountain range in New Mexico."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "MountainRange(picurismountains) ∨ MountainRange(picurismountains) ::: The Picuris Mountains are a mountain range in New Mexico or Texas.\nVisited(juandeonate, picurismountains) ::: Juan de Onate visited the Picuris Mountains.\nLocatedIn(hardingpegmatitemine, picurismountains) ∧ Donated(hardingpegmatitemine) ::: The Harding Pegmatite Mine, located in the Picuris Mountains, was donated.\nIn(x,y)→¬(Mine(y)∧Has(y,x)) ::: There are no mountain ranges in Texas that have mines which have been donated.\n",
                "First-Order-Logic Question": "NotLocatedIn(hardingpegmatitemine, newmexico) ::: The Harding Pegmatite Mine is not located in a mountain range in New Mexico."
            },
            "diff": [
                {
                    "raw": "∀x (MountainRange(x) ∧ In(x, texas) → ¬∃y (Mine(y) ∧ Has(y, donated) ∧ LocatedIn(y, x))) ::: There are no mountain ranges in Texas that have mines which have been donated.",
                    "gram": "In(x,y)→¬(Mine(y)∧Has(y,x)) ::: There are no mountain ranges in Texas that have mines which have been donated."
                }
            ],
            "answer": "B",
            "error_type":"",
            "grammar_answer": "C"
        },
        {
            "id": 151,
            "raw_prog": {
                "First-Order-Logic Rules": "PublishingHouse(newVesselPress) ∧ SpecializeIn(newVesselPress, foreignLiterature) ∧ Language(allBooks, english) ∧ Book(neapolitanChronicles) ∧ Publish(newVesselPress, neapolitanChronicles) ∧ Translate(neapolitanChronicles, italian, english) ∧ Book(palaceOfFlies) ∧ Publish(newVesselPress, palaceOfFlies) ::: New Vessel Press is a publishing house which specializes in translating foreign literature into English. All of New Vessel Press's published books are in English. Neapolitan Chronicles is a book published by New Vessel Press. Neapolitan Chronicles was translated from Italian. Palace of Flies is a book published by New Vessel Press.",
                "First-Order-Logic Question": "¬Publish(newVesselPress, harryPotter) ::: Harry Potter was published by New Vessel Press."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "Language(x,y)∧PublishingHouse(z)∧SpecializeIn(z,y)→Book(x)∧PublishedIn(x,y) ::: New Vessel Press is a publishing house which specializes in translating foreign literature into English. All of New Vessel Press's published books are in English. Neapolitan Chronicles is a book published by New Vessel Press. Neapolitan Chronicles was translated from Italian. Palace of Flies is a book published by New Vessel Press.",
                "First-Order-Logic Question": "¬Publish(newVesselPress, harryPotter) ::: Harry Potter was published by New Vessel Press."
            },
            "diff": [
                {
                    "raw": "PublishingHouse(newVesselPress) ∧ SpecializeIn(newVesselPress, foreignLiterature) ∧ Language(allBooks, english) ∧ Book(neapolitanChronicles) ∧ Publish(newVesselPress, neapolitanChronicles) ∧ Translate(neapolitanChronicles, italian, english) ∧ Book(palaceOfFlies) ∧ Publish(newVesselPress, palaceOfFlies) ::: New Vessel Press is a publishing house which specializes in translating foreign literature into English. All of New Vessel Press's published books are in English. Neapolitan Chronicles is a book published by New Vessel Press. Neapolitan Chronicles was translated from Italian. Palace of Flies is a book published by New Vessel Press.",
                    "gram": "Language(x,y)∧PublishingHouse(z)∧SpecializeIn(z,y)→Book(x)∧PublishedIn(x,y) ::: New Vessel Press is a publishing house which specializes in translating foreign literature into English. All of New Vessel Press's published books are in English. Neapolitan Chronicles is a book published by New Vessel Press. Neapolitan Chronicles was translated from Italian. Palace of Flies is a book published by New Vessel Press."
                }
            ],
            "answer": "C",
            "error_type":"",
            "grammar_answer": "C"
        }
    ],
    "gcd_llama-3-8b_4": [
        {
            "id": 39,
            "raw_prog": {
                "First-Order-Logic Rules": [
                    "∀x (ZahaHadid(x) → Timeless(x)) ::: All of Zaha Hadid's design styles are timeless.",
                    "∀x (MassProduct(x) → ¬Timeless(x)) ::: No mass product design is timeless.",
                    "ZahaHadid(x) ⊕ KellyWearstler(x) ::: Either Zaha Hadid's design style or Kelly Wearstler's design style.",
                    "∀x (KellyWearstler(x) → Evocative(x)) ::: All of Kelly Wearstler's design styles are evocative.",
                    "∀x (KellyWearstler(x) → Dreamy(x)) ::: All of Kelly Wearstler's design styles are dreamy.",
                    "∀x (Timeless(Max(x)) → (MassProduct(Max(x)) ∧ Evocative(Max(x)))) ::: If a design by Max is timeless, then a design by Max is a mass product design and evocative."
                ],
                "First-Order-Logic Question": [
                    "MassProduct(Max(x)) ::: A design by Max is a mass product design."
                ]
            },
            "gram_prog": {
                "First-Order-Logic Rules": [
                    "∀x (ZahaHadid(x) → Timeless(x)) ::: All of Zaha Hadid's design styles are timeless.",
                    "∀x (MassProduct(x) → ¬Timeless(x)) ::: No mass product design is timeless.",
                    "ZahaHadid(x) ⊕ KellyWearstler(x) ::: Either Zaha Hadid's design style or Kelly Wearstler's design style.",
                    "∀x (KellyWearstler(x) → Evocative(x)) ::: All of Kelly Wearstler's design styles are evocative.",
                    "∀x (KellyWearstler(x) → Dreamy(x)) ::: All of Kelly Wearstler's design styles are dreamy.",
                    "DesignBy(x,z)∧Timeless(z)→(MassProduct(z)∧Evocative(z)) ::: If a design by Max is timeless, then a design by Max is a mass product design and evocative."
                ],
                "First-Order-Logic Question": [
                    "DesignBy(x,z)∧MassProduct(z) ::: A design by Max is a mass product design."
                ]
            },
            "diff": [
                {
                    "raw": "∀x (Timeless(Max(x)) → (MassProduct(Max(x)) ∧ Evocative(Max(x)))) ::: If a design by Max is timeless, then a design by Max is a mass product design and evocative.",
                    "gram": "DesignBy(x,z)∧Timeless(z)→(MassProduct(z)∧Evocative(z)) ::: If a design by Max is timeless, then a design by Max is a mass product design and evocative."
                },
                {
                    "raw": "MassProduct(Max(x)) ::: A design by Max is a mass product design.",
                    "gram": "DesignBy(x,z)∧MassProduct(z) ::: A design by Max is a mass product design."
                }
            ],
            "answer": "C",
            "error_type":"",
            "grammar_answer": "C"
        },
        {
            "id": 41,
            "raw_prog": {
                "First-Order-Logic Rules": [
                    "∀x (ZahaHadid(x) → Timeless(x)) ::: All of Zaha Hadid's design styles are timeless.",
                    "∀x (MassProduct(x) → ¬Timeless(x)) ::: No mass product design is timeless.",
                    "∀x (ZahaHadid(x) ∨ KellyWearstler(x)) ::: Either Zaha Hadid's design style or Kelly Wearstler's design style.",
                    "∀x (KellyWearstler(x) → Evocative(x)) ::: All of Kelly Wearstler's design styles are evocative.",
                    "∀x (KellyWearstler(x) → Dreamy(x)) ::: All of Kelly Wearstler's design styles are dreamy.",
                    "∀x (Timeless(Max(x)) → (MassProduct(Max(x)) ∧ Evocative(Max(x)))) ::: If a design by Max is timeless, then a design by Max is a mass product design and evocative."
                ],
                "First-Order-Logic Question": [
                    "Evocative(Max(x)) ∨ Dreamy(Max(x)) ::: A design by Max is either evocative or dreamy."
                ]
            },
            "gram_prog": {
                "First-Order-Logic Rules": [
                    "∀x (ZahaHadid(x) → Timeless(x)) ::: All of Zaha Hadid's design styles are timeless.",
                    "∀x (MassProduct(x) → ¬Timeless(x)) ::: No mass product design is timeless.",
                    "∀x (ZahaHadid(x) ∨ KellyWearstler(x)) ::: Either Zaha Hadid's design style or Kelly Wearstler's design style.",
                    "∀x (KellyWearstler(x) → Evocative(x)) ::: All of Kelly Wearstler's design styles are evocative.",
                    "∀x (KellyWearstler(x) → Dreamy(x)) ::: All of Kelly Wearstler's design styles are dreamy.",
                    "DesignBy(x,y)∧Timeless(y)→(MassProduct(y)∧Evocative(y)) ::: If a design by Max is timeless, then a design by Max is a mass product design and evocative."
                ],
                "First-Order-Logic Question": [
                    "DesignBy(x,z)∧(Evocative(z)∨Dreamy(z)) ::: A design by Max is either evocative or dreamy."
                ]
            },
            "diff": [
                {
                    "raw": "∀x (Timeless(Max(x)) → (MassProduct(Max(x)) ∧ Evocative(Max(x)))) ::: If a design by Max is timeless, then a design by Max is a mass product design and evocative.",
                    "gram": "DesignBy(x,y)∧Timeless(y)→(MassProduct(y)∧Evocative(y)) ::: If a design by Max is timeless, then a design by Max is a mass product design and evocative."
                },
                {
                    "raw": "Evocative(Max(x)) ∨ Dreamy(Max(x)) ::: A design by Max is either evocative or dreamy.",
                    "gram": "DesignBy(x,z)∧(Evocative(z)∨Dreamy(z)) ::: A design by Max is either evocative or dreamy."
                }
            ],
            "answer": "B",
            "error_type":"",
            "grammar_answer": "C"
        },
        {
            "id": 52,
            "raw_prog": {
                "First-Order-Logic Rules": "∀x (RomanceLanguage(x) → IndoEuropeanLanguage(x)) ::: All Romance languages are Indo-European languages.\nLanguageFamily(romanceLanguages) ::: The Romance languages are a language family.\n∀x ∀y (LanguageFamily(f) ∧ RomanceLanguage(x) ∧ RomanceLanguage(y) → Related(x, y)) ::: All languages within a language family are related to each other.\nRomanceLanguage(french) ∧ RomanceLanguage(spanish) ::: French and Spanish are both Romance languages.\nRelated(german, spanish) ::: German is related to Spanish.\n∀x (Basque(x) → ¬∃y (Related(x, y))) ::: Basque is not related to any other language.\n",
                "First-Order-Logic Question": "RomanceLanguage(basque) ::: Basque is a Romance language."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∀x (RomanceLanguage(x) → IndoEuropeanLanguage(x)) ::: All Romance languages are Indo-European languages.\nLanguageFamily(romanceLanguages) ::: The Romance languages are a language family.\n∀x ∀y (LanguageFamily(f) ∧ RomanceLanguage(x) ∧ RomanceLanguage(y) → Related(x, y)) ::: All languages within a language family are related to each other.\nRomanceLanguage(french) ∧ RomanceLanguage(spanish) ::: French and Spanish are both Romance languages.\nRelated(german, spanish) ::: German is related to Spanish.\nIndoEuropeanLanguage(x)∧¬Related(x,y) ::: Basque is not related to any other language.\n",
                "First-Order-Logic Question": "RomanceLanguage(basque) ::: Basque is a Romance language."
            },
            "diff": [
                {
                    "raw": "∀x (Basque(x) → ¬∃y (Related(x, y))) ::: Basque is not related to any other language.",
                    "gram": "IndoEuropeanLanguage(x)∧¬Related(x,y) ::: Basque is not related to any other language."
                }
            ],
            "answer": "B",
            "error_type":"",
            "grammar_answer": "A"
        },
        {
            "id": 67,
            "raw_prog": {
                "First-Order-Logic Rules": "University(yale_university) ∧ Private(yale_university) ∧ IvyLeague(yale_university) ∧ Research(yale_university) ::: Yale University is a private Ivy League research university.\nMoveTo(yale_university, new_haven, 1716) ::: Yale University moved to New Haven in 1716.\nEndowmentValue(yale_university, 42.3_billion) ::: Yale university's endowment was valued at $42.3 billion.\nOrganizedInto(yale_university, 27_constituent_colleges_and_schools) ::: Yale University has been organized into 27 constituent colleges and schools.\nConstituentCollegeOrSchool(residential_colleges) ∧ ConstituentCollegeOrSchool(yale_graduate_school_of_arts_and_sciences) ∧ ConstituentCollegeOrSchool(twelve_professional_schools) ::: The residential colleges, the Yale Graduate School of Arts and Sciences, and twelve professional schools are constituent colleges and schools.\nResidentialCollege(benjamin_franklin_college) ∧ ResidentialCollege(berkeley_college) ∧ ResidentialCollege(branford_college) ∧ ResidentialCollege(davenport_college) ∧ ResidentialCollege(ezra_stiles_college) ∧ ResidentialCollege(grace_hopper_college) ∧ ResidentialCollege(jonathan_edwards_college) ∧ ResidentialCollege(morse_college) ∧ ResidentialCollege(pauli_murray_college) ∧ ResidentialCollege(pierson_college) ∧ ResidentialCollege(saybrook_college) ∧ ResidentialCollege(silliman_college) ∧ ResidentialCollege(timothy_dwight_college) ∧ ResidentialCollege(trumbull_college) ::: A list of residential colleges at Yale.\n",
                "First-Order-Logic Question": "LargestEndowment(yale_university) ::: Yale University has the largest university endowment of any educational institution."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "University(yale_university) ∧ Private(yale_university) ∧ IvyLeague(yale_university) ∧ Research(yale_university) ::: Yale University is a private Ivy League research university.\nMoveTo(yale_university, new_haven, 1716) ::: Yale University moved to New Haven in 1716.\nEndowmentValue(yale_university, forty_two_point_three_billion) ::: Yale university's endowment was valued at $42.3 billion.\nOrganizedInto(yale_university, twenty_seven_constituent_colleges_and_schools) ::: Yale University has been organized into 27 constituent colleges and schools.\nConstituentCollegeOrSchool(residential_colleges) ∧ ConstituentCollegeOrSchool(yale_graduate_school_of_arts_and_sciences) ∧ ConstituentCollegeOrSchool(twelve_professional_schools) ::: The residential colleges, the Yale Graduate School of Arts and Sciences, and twelve professional schools are constituent colleges and schools.\nIvyLeague(y) ∧ University(y) → ResidentialCollege(x) ::: A list of residential colleges at Yale.",
                "First-Order-Logic Question": "LargestEndowment(yale_university) ::: Yale University has the largest university endowment of any educational institution."
            },
            "diff": [],
            "answer": "C",
            "error_type":"",
            "grammar_answer": "C"
        },
        {
            "id": 70,
            "raw_prog": {
                "First-Order-Logic Rules": [
                    "British(badults) ∧ Sitcom(badults) ∧ ∀x (MemberOf(x, pappys) → Star(x, badults)) ::: Badults is a British Sitcom series, starring members of Pappy's.",
                    "Pilot(badults, 2013) ∧ Network(badults, bbcthree) ::: Badults piloted in July 2013 on BBC Three.",
                    "WorkingTitle(badults, thesecretdudesociety) ::: The Working title 'The Secret Dude Society' was used for Badults.",
                    "ScriptEditor(andrewcollins, badults) ::: Andrew Collins was the script editor for Badults."
                ],
                "First-Order-Logic Question": [
                    "∀x (MemberOf(x, pappys) → ¬∃y (Star(x, y) ∧ (Network(y, bbctwo) ∨ Network(y, bbcthree)))) ::: No members of Pappy's have starred for a show piloting on BBC Two or BBC Three."
                ]
            },
            "gram_prog": {
                "First-Order-Logic Rules": [
                    "British(badults) ∧ Sitcom(badults) ∧ ∀x (MemberOf(x, pappys) → Star(x, badults)) ::: Badults is a British Sitcom series, starring members of Pappy's.",
                    "Pilot(badults, 2013) ∧ Network(badults, bbcthree) ::: Badults piloted in July 2013 on BBC Three.",
                    "WorkingTitle(badults, thesecretdudesociety) ::: The Working title 'The Secret Dude Society' was used for Badults.",
                    "ScriptEditor(andrewcollins, badults) ::: Andrew Collins was the script editor for Badults."
                ],
                "First-Order-Logic Question": [
                    "Pilot(x,y)→¬(Star(x,y)∧Network(y,z)) ::: No members of Pappy's have starred for a show piloting on BBC Two or BBC Three."
                ]
            },
            "diff": [
                {
                    "raw": "∀x (MemberOf(x, pappys) → ¬∃y (Star(x, y) ∧ (Network(y, bbctwo) ∨ Network(y, bbcthree)))) ::: No members of Pappy's have starred for a show piloting on BBC Two or BBC Three.",
                    "gram": "Pilot(x,y)→¬(Star(x,y)∧Network(y,z)) ::: No members of Pappy's have starred for a show piloting on BBC Two or BBC Three."
                }
            ],
            "answer": "B",
            "error_type":"",
            "grammar_answer": "C"
        },
        {
            "id": 93,
            "raw_prog": {
                "First-Order-Logic Rules": [
                    "∃x (Pet(x) ∧ ManagedBuilding(y) ∧ AllowedIn(x, y)) ::: Pets are allowed in some managed buildings.",
                    "∀x (ManagedBuilding(x) → DepositRequired(x)) ::: A deposit is required to rent an apartment in a managed building.",
                    "∀x ∀y (SecurityDeposit(x, y) → EqualOrMore(y, MonthlyRent(x, 1))) ::: The security deposit can be either equal to one month's rent or more.",
                    "Cat(fluffy) ∧ Owner(tom, fluffy) ::: Fluffy is Tom's cat.",
                    "∀x (Cat(x) → Pet(x)) ::: Cats are pets.",
                    "ManagedBuilding(olivegarden) ::: The Olive Garden is a managed building.",
                    "MonthlyRent(olivegarden, 2000) ::: The monthly rent at the Olive Garden is $2000.",
                    "∀x ∀y (Owner(x, y) ∧ Pet(y) ∧ ManagedBuilding(z) ∧ AllowedIn(y, z) ∧ SecurityDeposit(z, d) ∧ d ≤ 1500 ↔ Rent(x, z)) ::: Tom will rent an apartment in a managed building if and only if he is allowed to move in with Fluffy, and the security deposit is no more than $1500.",
                    "EqualOrMore(2000, 1500) ::: 2000$ is more than $1500."
                ],
                "First-Order-Logic Question": [
                    "Rent(tom, olivegarden) ::: Tom will rent an apartment in The Olive Garden."
                ]
            },
            "gram_prog": {
                "First-Order-Logic Rules": [
                    "∃x (Pet(x) ∧ ManagedBuilding(y) ∧ AllowedIn(x, y)) ::: Pets are allowed in some managed buildings.",
                    "∀x (ManagedBuilding(x) → DepositRequired(x)) ::: A deposit is required to rent an apartment in a managed building.",
                    "AllowedIn(x,y) ::: The security deposit can be either equal to one month's rent or more.",
                    "Cat(fluffy) ∧ Owner(tom, fluffy) ::: Fluffy is Tom's cat.",
                    "∀x (Cat(x) → Pet(x)) ::: Cats are pets.",
                    "ManagedBuilding(olivegarden) ::: The Olive Garden is a managed building.",
                    "MonthlyRent(olivegarden, 2000) ::: The monthly rent at the Olive Garden is $2000.",
                    "AllowedIn(y,z)∧ManagedBuilding(z)∧SecurityDeposit(z,y)∧(¬Pet(y)∨EqualOrMore(y,z)) ::: Tom will rent an apartment in a managed building if and only if he is allowed to move in with Fluffy, and the security deposit is no more than $1500.",
                    "EqualOrMore(2000, 1500) ::: 2000$ is more than $1500."
                ],
                "First-Order-Logic Question": [
                    "Rent(tom, olivegarden) ::: Tom will rent an apartment in The Olive Garden."
                ]
            },
            "diff": [
                {
                    "raw": "∀x ∀y (SecurityDeposit(x, y) → EqualOrMore(y, MonthlyRent(x, 1))) ::: The security deposit can be either equal to one month's rent or more.",
                    "gram": "AllowedIn(x,y) ::: The security deposit can be either equal to one month's rent or more."
                },
                {
                    "raw": "∀x ∀y (Owner(x, y) ∧ Pet(y) ∧ ManagedBuilding(z) ∧ AllowedIn(y, z) ∧ SecurityDeposit(z, d) ∧ d ≤ 1500 ↔ Rent(x, z)) ::: Tom will rent an apartment in a managed building if and only if he is allowed to move in with Fluffy, and the security deposit is no more than $1500.",
                    "gram": "AllowedIn(y,z)∧ManagedBuilding(z)∧SecurityDeposit(z,y)∧(¬Pet(y)∨EqualOrMore(y,z)) ::: Tom will rent an apartment in a managed building if and only if he is allowed to move in with Fluffy, and the security deposit is no more than $1500."
                }
            ],
            "answer": "B",
            "error_type":"",
            "grammar_answer": "C"
        },
        {
            "id": 94,
            "raw_prog": {
                "First-Order-Logic Rules": [
                    "∃x (ManagedBuilding(x) ∧ Pet(y) ∧ AllowedIn(y, x)) ::: Pets are allowed in some managed buildings.",
                    "∀x (ManagedBuilding(x) → DepositRequired(x)) ::: A deposit is required to rent an apartment in a managed building.",
                    "∀x ∀y (SecurityDeposit(x, y) → EqualOrMore(y, MonthlyRent(x, 1))) ::: The security deposit can be either equal to one month's rent or more.",
                    "Cat(fluffy) ∧ Owner(tom, fluffy) ::: Fluffy is Tom's cat.",
                    "∀x (Cat(x) → Pet(x)) ::: Cats are pets.",
                    "ManagedBuilding(olivegarden) ::: The Olive Garden is a managed building.",
                    "MonthlyRent(olivegarden, 2000) ::: The monthly rent at the Olive Garden is $2000.",
                    "∀x ∀y ∀z (Owner(y, z) ∧ ManagedBuilding(x) ∧ AllowedIn(z, x) ∧ SecurityDeposit(x, w) ∧ w ≤ 1500 ↔ MoveInWith(y, z, x)) ::: Tom will rent an apartment in a managed building if and only if he is allowed to move in with Fluffy, and the security deposit is no more than $1500.",
                    "EqualOrMore(2000, 1500) ::: 2000$ is more than $1500."
                ],
                "First-Order-Logic Question": [
                    "MoveInWith(tom, fluffy, olivegarden) ::: Tom is allowed to move in an apartment in The Olive Garden with Fluffy."
                ]
            },
            "gram_prog": {
                "First-Order-Logic Rules": [
                    "∃x (ManagedBuilding(x) ∧ Pet(y) ∧ AllowedIn(y, x)) ::: Pets are allowed in some managed buildings.",
                    "∀x (ManagedBuilding(x) → DepositRequired(x)) ::: A deposit is required to rent an apartment in a managed building.",
                    "AllowedIn(x,y) ::: The security deposit can be either equal to one month's rent or more.",
                    "Cat(fluffy) ∧ Owner(tom, fluffy) ::: Fluffy is Tom's cat.",
                    "∀x (Cat(x) → Pet(x)) ::: Cats are pets.",
                    "ManagedBuilding(olivegarden) ::: The Olive Garden is a managed building.",
                    "MonthlyRent(olivegarden, 2000) ::: The monthly rent at the Olive Garden is $2000.",
                    "AllowedIn(z,x)∧SecurityDeposit(x,y)∧(¬(Pet(z))) ::: Tom will rent an apartment in a managed building if and only if he is allowed to move in with Fluffy, and the security deposit is no more than $1500.",
                    "EqualOrMore(2000, 1500) ::: 2000$ is more than $1500."
                ],
                "First-Order-Logic Question": [
                    "MoveInWith(tom, fluffy, olivegarden) ::: Tom is allowed to move in an apartment in The Olive Garden with Fluffy."
                ]
            },
            "diff": [
                {
                    "raw": "∀x ∀y (SecurityDeposit(x, y) → EqualOrMore(y, MonthlyRent(x, 1))) ::: The security deposit can be either equal to one month's rent or more.",
                    "gram": "AllowedIn(x,y) ::: The security deposit can be either equal to one month's rent or more."
                },
                {
                    "raw": "∀x ∀y ∀z (Owner(y, z) ∧ ManagedBuilding(x) ∧ AllowedIn(z, x) ∧ SecurityDeposit(x, w) ∧ w ≤ 1500 ↔ MoveInWith(y, z, x)) ::: Tom will rent an apartment in a managed building if and only if he is allowed to move in with Fluffy, and the security deposit is no more than $1500.",
                    "gram": "AllowedIn(z,x)∧SecurityDeposit(x,y)∧(¬(Pet(z))) ::: Tom will rent an apartment in a managed building if and only if he is allowed to move in with Fluffy, and the security deposit is no more than $1500."
                }
            ],
            "answer": "C",
            "error_type":"",
            "grammar_answer": "A"
        },
        {
            "id": 95,
            "raw_prog": {
                "First-Order-Logic Rules": [
                    "∃x (ManagedBuilding(x) ∧ Pet(y) ∧ AllowedIn(y, x)) ::: Pets are allowed in some managed buildings.",
                    "∀x (ManagedBuilding(x) → DepositRequired(x)) ::: A deposit is required to rent an apartment in a managed building.",
                    "∀x ∀y (SecurityDeposit(x, y) → (EqualOrMore(y, MonthlyRent(x, 1)) ∨ EqualOrMore(y, MonthlyRent(x, 2)))) ::: The security deposit can be either equal to one month's rent or more.",
                    "Cat(fluffy) ∧ Owner(tom, fluffy) ::: Fluffy is Tom's cat.",
                    "∀x (Cat(x) → Pet(x)) ::: Cats are pets.",
                    "ManagedBuilding(olivegarden) ::: The Olive Garden is a managed building.",
                    "MonthlyRent(olivegarden, 2000) ::: The monthly rent at the Olive Garden is $2000.",
                    "∀x ∀y (Owner(tom, fluffy) ∧ ManagedBuilding(x) ∧ (AllowedIn(fluffy, x) ∧ SecurityDeposit(x, y) ∧ EqualOrMore(1500, y)) ↔ Rent(tom, x)) ::: Tom will rent an apartment in a managed building if and only if he is allowed to move in with Fluffy, and the security deposit is no more than $1500.",
                    "EqualOrMore(2000, 1500) ::: 2000$ is more than $1500."
                ],
                "First-Order-Logic Question": [
                    "SecurityDeposit(olivegarden, 2000) ∨ ∃y (SecurityDeposit(olivegarden, y) ∧ EqualOrMore(y, 2000)) ::: The security deposit at the Olive Garden is either $2000 or more."
                ]
            },
            "gram_prog": {
                "First-Order-Logic Rules": [
                    "∃x (ManagedBuilding(x) ∧ Pet(y) ∧ AllowedIn(y, x)) ::: Pets are allowed in some managed buildings.",
                    "∀x (ManagedBuilding(x) → DepositRequired(x)) ::: A deposit is required to rent an apartment in a managed building.",
                    "AllowedIn(x,y) ::: The security deposit can be either equal to one month's rent or more.",
                    "Cat(fluffy) ∧ Owner(tom, fluffy) ::: Fluffy is Tom's cat.",
                    "∀x (Cat(x) → Pet(x)) ::: Cats are pets.",
                    "ManagedBuilding(olivegarden) ::: The Olive Garden is a managed building.",
                    "MonthlyRent(olivegarden, 2000) ::: The monthly rent at the Olive Garden is $2000.",
                    "∀x ∀y (Owner(tom, fluffy) ∧ ManagedBuilding(x) ∧ (AllowedIn(fluffy, x) ∧ SecurityDeposit(x, y) ∧ EqualOrMore(1500, y)) ↔ Rent(tom, x)) ::: Tom will rent an apartment in a managed building if and only if he is allowed to move in with Fluffy, and the security deposit is no more than $1500.",
                    "EqualOrMore(2000, 1500) ::: 2000$ is more than $1500."
                ],
                "First-Order-Logic Question": [
                    "SecurityDeposit(olivegarden, 2000) ∨ ∃y (SecurityDeposit(olivegarden, y) ∧ EqualOrMore(y, 2000)) ::: The security deposit at the Olive Garden is either $2000 or more."
                ]
            },
            "diff": [
                {
                    "raw": "∀x ∀y (SecurityDeposit(x, y) → (EqualOrMore(y, MonthlyRent(x, 1)) ∨ EqualOrMore(y, MonthlyRent(x, 2)))) ::: The security deposit can be either equal to one month's rent or more.",
                    "gram": "AllowedIn(x,y) ::: The security deposit can be either equal to one month's rent or more."
                }
            ],
            "answer": "A",
            "error_type":"",
            "grammar_answer": "C"
        },
        {
            "id": 113,
            "raw_prog": {
                "First-Order-Logic Rules": [
                    "MountainRange(picurismountains) ∧ (In(picurismountains, newmexico) ⊕ In(picurismountains, texas)) ::: The Picuris Mountains are a mountain range in New Mexico or Texas.",
                    "Visit(juandeonate, picurismountains) ::: Juan de Onate visited the Picuris Mountains.",
                    "Mine(hardingpegmatitemine) ∧ LocatedIn(hardingpegmatitemine, picurismountains) ∧ Donate(hardingpegmatitemine) ::: The Harding Pegmatite Mine, located in the Picuris Mountains, was donated.",
                    "∀x (MountainRange(x) ∧ In(x, texas) → ¬∃y (Mine(y) ∧ LocatedIn(y, x) ∧ Donate(y))) ::: There are no mountain ranges in Texas that have mines which have been donated."
                ],
                "First-Order-Logic Question": "∃x (MountainRange(x) ∧ In(x, texas) ∧ Visit(juandeonate, x)) ::: Juan de Onate visited a mountain range in Texas."
            },
            "gram_prog": {
                "First-Order-Logic Rules": [
                    "MountainRange(picurismountains) ∧ (In(picurismountains, newmexico) ⊕ In(picurismountains, texas)) ::: The Picuris Mountains are a mountain range in New Mexico or Texas.",
                    "Visit(juandeonate, picurismountains) ::: Juan de Onate visited the Picuris Mountains.",
                    "Mine(hardingpegmatitemine) ∧ LocatedIn(hardingpegmatitemine, picurismountains) ∧ Donate(hardingpegmatitemine) ::: The Harding Pegmatite Mine, located in the Picuris Mountains, was donated.",
                    "In(x,y)∧MountainRange(x)→¬(Mine(y)∧LocatedIn(y,x)) ::: There are no mountain ranges in Texas that have mines which have been donated."
                ],
                "First-Order-Logic Question": "∃x (MountainRange(x) ∧ In(x, texas) ∧ Visit(juandeonate, x)) ::: Juan de Onate visited a mountain range in Texas."
            },
            "diff": [
                {
                    "raw": "∀x (MountainRange(x) ∧ In(x, texas) → ¬∃y (Mine(y) ∧ LocatedIn(y, x) ∧ Donate(y))) ::: There are no mountain ranges in Texas that have mines which have been donated.",
                    "gram": "In(x,y)∧MountainRange(x)→¬(Mine(y)∧LocatedIn(y,x)) ::: There are no mountain ranges in Texas that have mines which have been donated."
                }
            ],
            "answer": "C",
            "error_type":"",
            "grammar_answer": "C"
        },
        {
            "id": 123,
            "raw_prog": {
                "First-Order-Logic Rules": "∀x (TransportMultiplePassengers(x) → ¬Empty(x)) ::: If something can transport multiple passengers, then they are not empty.\n∀x (Airline(x) → TransportMultiplePassengers(x)) ::: All airlines can transport multiple passengers.\n∀x (Plane(x) → Empty(x)) ::: All planes are empty.\n∀x (Boeing707(x) → Plane(x)) ::: All Boeing 707s are planes.\n¬Airline(greyhound) → ¬∃y (Greyhound(y) ∧ Plane(y)) ::: If Greyhound is not an airline, then there are no Greyhound planes.\n",
                "First-Order-Logic Question": "Boeing707(greyhound) ::: A Greyhound is a Boeing 707."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∀x (TransportMultiplePassengers(x) → ¬Empty(x)) ::: If something can transport multiple passengers, then they are not empty.\n∀x (Airline(x) → TransportMultiplePassengers(x)) ::: All airlines can transport multiple passengers.\n∀x (Plane(x) → Empty(x)) ::: All planes are empty.\n∀x (Boeing707(x) → Plane(x)) ::: All Boeing 707s are planes.\n¬Airline(greyhound) → ¬(Plane(greyhound)) ::: If Greyhound is not an airline, then Greyhound is not a plane.\n",
                "First-Order-Logic Question": "Boeing707(greyhound) ::: A Greyhound is a Boeing 707."
            },
            "diff": [
                {
                    "raw": "¬Airline(greyhound) → ¬∃y (Greyhound(y) ∧ Plane(y)) ::: If Greyhound is not an airline, then there are no Greyhound planes.",
                    "gram": "¬Airline(greyhound) → ¬(Plane(greyhound)) ::: If Greyhound is not an airline, then Greyhound is not a plane."
                }
            ],
            "answer": "B",
            "error_type":"",
            "grammar_answer": "B"
        },
        {
            "id": 124,
            "raw_prog": {
                "First-Order-Logic Rules": "∀x (TransportMultiplePassengers(x) → ¬Empty(x)) ::: If something can transport multiple passengers, then they are not empty.\n∀x (Airline(x) → TransportMultiplePassengers(x)) ::: All airlines can transport multiple passengers.\n∀x (Plane(x) → Empty(x)) ::: All planes are empty.\n∀x (Boeing707(x) → Plane(x)) ::: All Boeing 707s are planes.\n¬Airline(greyhound) → ¬∃y (Greyhound(y) ∧ Plane(y)) ::: If Greyhound is not an airline, then there are no Greyhound planes.\n",
                "First-Order-Logic Question": "¬Greyhound(boeing707) ::: A Greyhound is not a Boeing 707."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∀x (TransportMultiplePassengers(x) → ¬Empty(x)) ::: If something can transport multiple passengers, then they are not empty.\n∀x (Airline(x) → TransportMultiplePassengers(x)) ::: All airlines can transport multiple passengers.\n∀x (Plane(x) → Empty(x)) ::: All planes are empty.\nPlane(boeing707) ::: Boeing 707 is a plane.\n∀x (Airline(x) → ¬(Greyhound(x) ∧ Plane(x))) ::: If Greyhound is not an airline, then there are no Greyhound planes.",
                "First-Order-Logic Question": "¬Greyhound(boeing707) ::: A Greyhound is not a Boeing 707."
            },
            "diff": [],
            "answer": "A",
            "error_type":"",
            "grammar_answer": "C"
        },
        {
            "id": 143,
            "raw_prog": {
                "First-Order-Logic Rules": "∀x (BreedingBack(x) → ArtificiallySelected(x)) ::: Breeding back is a form of artificial selection by the deliberate selective breeding of domestic animals.\nBredBack(heck_cattle, aurochs) ∧ Resemble(heck_cattle, aurochs) ::: Heck cattle were bred-back in the 1920s to resemble the aurochs.\nAnimal(heck_cattle) ::: Heck cattle are animals.\nAnimal(aurochs) ::: Aurochs are animals.\n∃x ∃y (Animal(x) ∧ Animal(y) ∧ BredBack(x, y) ∧ Resemble(x, y) ∧ Extinct(y)) ::: Some animals to be bred-back resemble animals that are extinct.\n",
                "First-Order-Logic Question": "∃x (Animal(x) ∧ ArtificiallySelected(x) ∧ x = heck_cattle) ::: Some Heck cattle are artificially selected."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∀x (BreedingBack(x) → ArtificiallySelected(x)) ::: Breeding back is a form of artificial selection by the deliberate selective breeding of domestic animals.\nBredBack(heck_cattle, aurochs) ∧ Resemble(heck_cattle, aurochs) ::: Heck cattle were bred-back in the 1920s to resemble the aurochs.\nAnimal(heck_cattle) ::: Heck cattle are animals.\nAnimal(aurochs) ::: Aurochs are animals.\n∃x ∃y (Animal(x) ∧ Animal(y) ∧ BredBack(x, y) ∧ Resemble(x, y) ∧ Extinct(y)) ::: Some animals to be bred-back resemble animals that are extinct.\n",
                "First-Order-Logic Question": "Animal(x)∧ArtificiallySelected(x)∧Resemble(x,x) ::: Some Heck cattle are artificially selected."
            },
            "diff": [
                {
                    "raw": "∃x (Animal(x) ∧ ArtificiallySelected(x) ∧ x = heck_cattle) ::: Some Heck cattle are artificially selected.",
                    "gram": "Animal(x)∧ArtificiallySelected(x)∧Resemble(x,x) ::: Some Heck cattle are artificially selected."
                }
            ],
            "answer": "A",
            "error_type":"",
            "grammar_answer": "C"
        },
        {
            "id": 10,
            "raw_prog": {
                "First-Order-Logic Rules": "∀x (WildTurkey(x) → (EasternWildTurkey(x) ∨ OsceolaWildTurkey(x) ∨ GouldsWildTurkey(x) ∨ MerriamsWildTurkey(x) ∨ RioGrandeWildTurkey(x) ∨ OcellatedWildTurkey(x))) ::: There are six types of wild turkeys: Eastern wild turkey, Osceola wild turkey, Gould’s wild turkey, Merriam’s wild turkey, Rio Grande wild turkey, and Ocellated wild turkey.\nNot(tom, EasternWildTurkey(tom)) ::: Tom is not an Eastern wild turkey.\nNot(tom, OsceolaWildTurkey(tom)) ::: Tom is not an Osceola wild turkey.\nNot(tom, GouldsWildTurkey(tom)) ∧ Not(tom, MerriamsWildTurkey(tom)) ∧ Not(tom, RioGrandeWildTurkey(tom)) ::: Tom is also not a Gould's wild turkey, or a Merriam's wild turkey, or a Rio Grande wild turkey.\nWildTurkey(tom) ::: Tom is a wild turkey.\n",
                "First-Order-Logic Question": "EasternWildTurkey(tom) ::: Tom is an Eastern wild turkey."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∀x (WildTurkey(x) → (EasternWildTurkey(x) ∨ OsceolaWildTurkey(x) ∨ GouldsWildTurkey(x) ∨ MerriamsWildTurkey(x) ∨ RioGrandeWildTurkey(x) ∨ OcellatedWildTurkey(x))) ::: There are six types of wild turkeys: Eastern wild turkey, Osceola wild turkey, Gould’s wild turkey, Merriam’s wild turkey, Rio Grande wild turkey, and Ocellated wild turkey.\nNot(y,y) ::: Tom is not an Eastern wild turkey.\nGouldsWildTurkey(y) ::: Tom is not an Osceola wild turkey.\nNot(y,y) ::: Tom is also not a Gould's wild turkey, or a Merriam's wild turkey, or a Rio Grande wild turkey.\nWildTurkey(tom) ::: Tom is a wild turkey.\n",
                "First-Order-Logic Question": "EasternWildTurkey(tom) ::: Tom is an Eastern wild turkey."
            },
            "diff": [
                {
                    "raw": "Not(tom, EasternWildTurkey(tom)) ::: Tom is not an Eastern wild turkey.",
                    "gram": "Not(y,y) ::: Tom is not an Eastern wild turkey."
                },
                {
                    "raw": "Not(tom, OsceolaWildTurkey(tom)) ::: Tom is not an Osceola wild turkey.",
                    "gram": "GouldsWildTurkey(y) ::: Tom is not an Osceola wild turkey."
                },
                {
                    "raw": "Not(tom, GouldsWildTurkey(tom)) ∧ Not(tom, MerriamsWildTurkey(tom)) ∧ Not(tom, RioGrandeWildTurkey(tom)) ::: Tom is also not a Gould's wild turkey, or a Merriam's wild turkey, or a Rio Grande wild turkey.",
                    "gram": "Not(y,y) ::: Tom is also not a Gould's wild turkey, or a Merriam's wild turkey, or a Rio Grande wild turkey."
                }
            ],
            "answer": "B",
            "error_type":"",
            "grammar_answer": "C"
        },
        {
            "id": 40,
            "raw_prog": {
                "First-Order-Logic Rules": [
                    "∀x (ZahaHadid(x) → Timeless(x)) ::: All of Zaha Hadid's design styles are timeless.",
                    "∀x (MassProduct(x) → ¬Timeless(x)) ::: No mass product design is timeless.",
                    "∀x (ZahaHadid(x) ∨ KellyWearstler(x)) ::: Either Zaha Hadid's design style or Kelly Wearstler's design style.",
                    "∀x (KellyWearstler(x) → Evocative(x)) ::: All of Kelly Wearstler's design styles are evocative.",
                    "∀x (KellyWearstler(x) → Dreamy(x)) ::: All of Kelly Wearstler's design styles are dreamy.",
                    "∀x (Timeless(Max(x)) → (MassProduct(Max(x)) ∧ Evocative(Max(x)))) ::: If a design by Max is timeless, then a design by Max is a mass product design and evocative."
                ],
                "First-Order-Logic Question": [
                    "Evocative(Max(x)) ∧ Dreamy(Max(x)) ::: A design by Max is evocative and dreamy."
                ]
            },
            "gram_prog": {
                "First-Order-Logic Rules": [
                    "∀x (ZahaHadid(x) → Timeless(x)) ::: All of Zaha Hadid's design styles are timeless.",
                    "∀x (MassProduct(x) → ¬Timeless(x)) ::: No mass product design is timeless.",
                    "∀x (ZahaHadid(x) ∨ KellyWearstler(x)) ::: Either Zaha Hadid's design style or Kelly Wearstler's design style.",
                    "∀x (KellyWearstler(x) → Evocative(x)) ::: All of Kelly Wearstler's design styles are evocative.",
                    "∀x (KellyWearstler(x) → Dreamy(x)) ::: All of Kelly Wearstler's design styles are dreamy.",
                    "DesignBy(x,y)∧Timeless(y)→(MassProduct(y)∧Evocative(y)) ::: If a design by Max is timeless, then a design by Max is a mass product design and evocative."
                ],
                "First-Order-Logic Question": [
                    "DesignBy(x,z)∧Evocative(z)∧Dreamy(z) ::: A design by Max is evocative and dreamy."
                ]
            },
            "diff": [
                {
                    "raw": "∀x (Timeless(Max(x)) → (MassProduct(Max(x)) ∧ Evocative(Max(x)))) ::: If a design by Max is timeless, then a design by Max is a mass product design and evocative.",
                    "gram": "DesignBy(x,y)∧Timeless(y)→(MassProduct(y)∧Evocative(y)) ::: If a design by Max is timeless, then a design by Max is a mass product design and evocative."
                },
                {
                    "raw": "Evocative(Max(x)) ∧ Dreamy(Max(x)) ::: A design by Max is evocative and dreamy.",
                    "gram": "DesignBy(x,z)∧Evocative(z)∧Dreamy(z) ::: A design by Max is evocative and dreamy."
                }
            ],
            "answer": "A",
            "error_type":"",
            "grammar_answer": "C"
        },
        {
            "id": 47,
            "raw_prog": {
                "First-Order-Logic Rules": [
                    "Season(spring) ∧ Season(summer) ∧ Season(fall) ∧ Season(winter) ::: There are four seasons in a year: Spring, Summer, Fall, and Winter.",
                    "∀x (Student(x) ∧ WantsLongVacation(x) → LovesMost(x, summer)) ::: All students who want to have a long vacation love summer the most.",
                    "FavoriteSeason(emma, summer) ::: Emma's favorite season is summer.",
                    "∀x (FavoriteSeason(mia, x) → x ≠ summer) ::: Mia's favorite season is not the same as Emma's.",
                    "WantsLongVacation(james) ::: James wants to have a long vacation."
                ],
                "First-Order-Logic Question": "FavoriteSeason(james, fall) ::: James's favorite season is fall."
            },
            "gram_prog": {
                "First-Order-Logic Rules": [
                    "Season(spring) ∧ Season(summer) ∧ Season(fall) ∧ Season(winter) ::: There are four seasons in a year: Spring, Summer, Fall, and Winter.",
                    "∀x (Student(x) ∧ WantsLongVacation(x) → LovesMost(x, summer)) ::: All students who want to have a long vacation love summer the most.",
                    "FavoriteSeason(emma, summer) ::: Emma's favorite season is summer.",
                    "DifferentFavoriteSeason(y) ∧ ¬(FavoriteSeason(y, summer)) ::: Mia's favorite season is not the same as Emma's.",
                    "WantsLongVacation(james) ::: James wants to have a long vacation."
                ],
                "First-Order-Logic Question": "FavoriteSeason(james, fall) ::: James's favorite season is fall."
            },
            "diff": [
                {
                    "raw": "∀x (FavoriteSeason(mia, x) → x ≠ summer) ::: Mia's favorite season is not the same as Emma's.",
                    "gram": "DifferentFavoriteSeason(y) ∧ ¬(FavoriteSeason(y, summer)) ::: Mia's favorite season is not the same as Emma's."
                }
            ],
            "answer": "C",
            "error_type":"",
            "grammar_answer": "A"
        },
        {
            "id": 53,
            "raw_prog": {
                "First-Order-Logic Rules": "∀x (RomanceLanguage(x) → IndoEuropeanLanguage(x)) ::: All Romance languages are Indo-European languages.\nLanguageFamily(romanceLanguages) ::: The Romance languages are a language family.\n∀x ∀y (LanguageFamily(f) ∧ RomanceLanguage(x) ∧ RomanceLanguage(y) → Related(x, y)) ::: All languages within a language family are related to each other.\nRomanceLanguage(french) ∧ RomanceLanguage(spanish) ::: French and Spanish are both Romance languages.\nRelated(german, spanish) ::: German is related to Spanish.\n∀x (Basque(x) → ¬∃y (Related(x, y))) ::: Basque is not related to any other language.\n",
                "First-Order-Logic Question": "RomanceLanguage(german) ::: German is a Romance language."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∀x (RomanceLanguage(x) → IndoEuropeanLanguage(x)) ::: All Romance languages are Indo-European languages.\nLanguageFamily(romanceLanguages) ::: The Romance languages are a language family.\n∀x ∀y (LanguageFamily(f) ∧ RomanceLanguage(x) ∧ RomanceLanguage(y) → Related(x, y)) ::: All languages within a language family are related to each other.\nRomanceLanguage(french) ∧ RomanceLanguage(spanish) ::: French and Spanish are both Romance languages.\nRelated(german, spanish) ::: German is related to Spanish.\nIndoEuropeanLanguage(x)∧¬Related(x,y) ::: Basque is not related to any other language.\n",
                "First-Order-Logic Question": "RomanceLanguage(german) ::: German is a Romance language."
            },
            "diff": [
                {
                    "raw": "∀x (Basque(x) → ¬∃y (Related(x, y))) ::: Basque is not related to any other language.",
                    "gram": "IndoEuropeanLanguage(x)∧¬Related(x,y) ::: Basque is not related to any other language."
                }
            ],
            "answer": "C",
            "error_type":"",
            "grammar_answer": "A"
        },
        {
            "id": 105,
            "raw_prog": {
                "First-Order-Logic Rules": "Cost(gre, 205) ::: It costs US $205 to take the GRE test.\n∀x (Applicant(x) ∧ Prove(x, EconomicHardship(x)) → Provide(ets, FinancialAid, x)) ::: ETS provides financial aid to those GRE applicants who prove economic hardship.\n∀x (EconomicHardship(x) ↔ (Difficulty(x) ∧ (¬Money(x) ∨ ¬Resources(x)))) ::: Economic hardship refers to difficulty caused by having too little money or too few resources.\nLive(tom, singleparentfamily) ::: Tom lives in a single-parent family.\nOutOfWork(tom_dad) ∧ Year(1) ::: His dad has been out of work for more than a year.\n",
                "First-Order-Logic Question": "Apply(tom, FinancialAid) ::: Tom can apply for financial aid from ETS to take the GRE test."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "Cost(gre, 205) ::: It costs US $205 to take the GRE test.\nApplicant(x)∧Prove(x,y)→Provide(y,x) ::: ETS provides financial aid to those GRE applicants who prove economic hardship.\n∀x (EconomicHardship(x) ↔ (Difficulty(x) ∧ (¬Money(x) ∨ ¬Resources(x)))) ::: Economic hardship refers to difficulty caused by having too little money or too few resources.\nLive(tom, singleparentfamily) ::: Tom lives in a single-parent family.\nOutOfWork(tom_dad) ∧ Year(1) ::: His dad has been out of work for more than a year.\n",
                "First-Order-Logic Question": "Apply(tom, FinancialAid) ::: Tom can apply for financial aid from ETS to take the GRE test."
            },
            "diff": [
                {
                    "raw": "∀x (Applicant(x) ∧ Prove(x, EconomicHardship(x)) → Provide(ets, FinancialAid, x)) ::: ETS provides financial aid to those GRE applicants who prove economic hardship.",
                    "gram": "Applicant(x)∧Prove(x,y)→Provide(y,x) ::: ETS provides financial aid to those GRE applicants who prove economic hardship."
                }
            ],
            "answer": "A",
            "error_type":"",
            "grammar_answer": "C"
        },
        {
            "id": 114,
            "raw_prog": {
                "First-Order-Logic Rules": [
                    "MountainRange(picurismountains) ∧ (In(picurismountains, newmexico) ⊕ In(picurismountains, texas)) ::: The Picuris Mountains are a mountain range in New Mexico or Texas.",
                    "Visit(juandeonate, picurismountains) ::: Juan de Onate visited the Picuris Mountains.",
                    "Mine(hardingpegmatitemine) ∧ In(hardingpegmatitemine, picurismountains) ∧ Donate(hardingpegmatitemine) ::: The Harding Pegmatite Mine, located in the Picuris Mountains, was donated.",
                    "∀x (MountainRange(x) ∧ In(x, texas) → ¬∃y (Mine(y) ∧ In(y, x) ∧ Donate(y))) ::: There are no mountain ranges in Texas that have mines which have been donated."
                ],
                "First-Order-Logic Question": [
                    "¬In(hardingpegmatitemine, newmexico) ::: The Harding Pegmatite Mine is not located in a mountain range in New Mexico."
                ]
            },
            "gram_prog": {
                "First-Order-Logic Rules": [
                    "MountainRange(picurismountains) ∧ (In(picurismountains, newmexico) ⊕ In(picurismountains, texas)) ::: The Picuris Mountains are a mountain range in New Mexico or Texas.",
                    "Visit(juandeonate, picurismountains) ::: Juan de Onate visited the Picuris Mountains.",
                    "Mine(hardingpegmatitemine) ∧ In(hardingpegmatitemine, picurismountains) ∧ Donate(hardingpegmatitemine) ::: The Harding Pegmatite Mine, located in the Picuris Mountains, was donated.",
                    "In(x,y)→¬(Mine(y)∧In(y,x)) ::: There are no mountain ranges in Texas that have mines which have been donated."
                ],
                "First-Order-Logic Question": [
                    "¬In(hardingpegmatitemine, newmexico) ::: The Harding Pegmatite Mine is not located in a mountain range in New Mexico."
                ]
            },
            "diff": [
                {
                    "raw": "∀x (MountainRange(x) ∧ In(x, texas) → ¬∃y (Mine(y) ∧ In(y, x) ∧ Donate(y))) ::: There are no mountain ranges in Texas that have mines which have been donated.",
                    "gram": "In(x,y)→¬(Mine(y)∧In(y,x)) ::: There are no mountain ranges in Texas that have mines which have been donated."
                }
            ],
            "answer": "B",
            "error_type":"",
            "grammar_answer": "C"
        },
        {
            "id": 38,
            "raw_prog": {
                "First-Order-Logic Rules": [
                    "MusicPiece(symphonyNo9) ::: Symphony No. 9 is a music piece.",
                    "∀x (Composer(x) → ∃y (Write(x, y) ∧ MusicPiece(y))) ::: Composers write music pieces.",
                    "Write(beethoven, symphonyNo9) ∧ Composer(beethoven) ::: Beethoven wrote Symphony No. 9.",
                    "Premiere(viennaMusicSociety, symphonyNo9) ::: Vienna Music Society premiered Symphony No. 9.",
                    "Orchestra(viennaMusicSociety) ::: Vienna Music Society is an orchestra.",
                    "Lead(beethoven, viennaMusicSociety) ::: Beethoven leads the Vienna Music Society.",
                    "∀x (Orchestra(x) → ∃y (Lead(y, x) ∧ Conductor(y))) ::: Orchestras are led by conductors."
                ],
                "First-Order-Logic Question": "Not(Conductor(beethoven)) ::: Beethoven is not a conductor."
            },
            "gram_prog": {
                "First-Order-Logic Rules": [
                    "MusicPiece(symphonyNo9) ::: Symphony No. 9 is a music piece.",
                    "∀x (Composer(x) → ∃y (Write(x, y) ∧ MusicPiece(y))) ::: Composers write music pieces.",
                    "Write(beethoven, symphonyNo9) ∧ Composer(beethoven) ::: Beethoven wrote Symphony No. 9.",
                    "Premiere(viennaMusicSociety, symphonyNo9) ::: Vienna Music Society premiered Symphony No. 9.",
                    "Orchestra(viennaMusicSociety) ::: Vienna Music Society is an orchestra.",
                    "Lead(beethoven, viennaMusicSociety) ::: Beethoven leads the Vienna Music Society.",
                    "∀x (Orchestra(x) → ∃y (Lead(y, x) ∧ Conductor(y))) ::: Orchestras are led by conductors."
                ],
                "First-Order-Logic Question": "Not(y) ::: Beethoven is not a conductor."
            },
            "diff": [
                {
                    "raw": "Not(Conductor(beethoven)) ::: Beethoven is not a conductor.",
                    "gram": "Not(y) ::: Beethoven is not a conductor."
                }
            ],
            "answer": "B",
            "error_type":"",
            "grammar_answer": "C"
        },
        {
            "id": 49,
            "raw_prog": {
                "First-Order-Logic Rules": "∀x (Digital(x) → ¬Analog(x)) ::: No digital media are analog.\n∀x (PrintedText(x) → Analog(x)) ::: Every printed text is analog.\n∀x (StreamingService(x) → Digital(x)) ::: All streaming services are digital.\n∀x (HardcoverBook(x) → PrintedText(x)) ::: If an object is a hardcover book then it is printed text.\n∀x (StreamingService(x) ∧ Object1984(x) → HardcoverBook(x)) ::: If 1984 is a streaming service, then 1984 is a hardcover book.\n",
                "First-Order-Logic Question": "PrintedText(Object1984(x)) ::: 1984 is printed text."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∀x (Digital(x) → ¬Analog(x)) ::: No digital media are analog.\n∀x (PrintedText(x) → Analog(x)) ::: Every printed text is analog.\n∀x (StreamingService(x) → Digital(x)) ::: All streaming services are digital.\n∀x (HardcoverBook(x) → PrintedText(x)) ::: If an object is a hardcover book then it is printed text.\n∀x (StreamingService(x) ∧ Object1984(x) → HardcoverBook(x)) ::: If 1984 is a streaming service, then 1984 is a hardcover book.\n",
                "First-Order-Logic Question": "Analog(x) ::: 1984 is printed text."
            },
            "diff": [
                {
                    "raw": "PrintedText(Object1984(x)) ::: 1984 is printed text.",
                    "gram": "Analog(x) ::: 1984 is printed text."
                }
            ],
            "answer": "C",
            "error_type":"",
            "grammar_answer": "C"
        }
    ],
    "logic_inference_gpt-3.5-turbo_3.5": [
        {
            "id": 4,
            "raw_prog": {
                "First-Order-Logic Rules": "∀x∀y (Schedule(x, y) → Appear(x)) ::: All employees who schedule a meeting with their customers will appear in the company today. \n∀x (Lunch(x) → ∃y (Schedule(x, y))) ::: Everyone who has lunch in the company schedules meetings with their customers. \n∀x (Lunch(x) ∨ Home(x)) ::: Employees will either have lunch in the company or have lunch at home. \n∀x (Home(x) → Remote(x)) ::: If an employee has lunch at home, then he/she is working remotely from home. \n∀x (Work(x, y) → Remote(x)) ::: All employees who are in other countries work remotely from home. \n∀x (Manager(x) → ¬Remote(x)) ::: No managers work remotely from home. \n(Manager(james) ∧ Appear(james)) ⊕ (¬Manager(james) ∧ ¬Appear(james)) ::: James is either a manager and appears in the company today or neither a manager nor appears in the company today.",
                "First-Order-Logic Question": "¬Lunch(james) ::: James does not have lunch in the company."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∀x∀y (Schedule(x, y) → Appear(x)) ::: All employees who schedule a meeting with their customers will appear in the company today. \n∀x (Lunch(x) → ∃y (Schedule(x, y))) ::: Everyone who has lunch in the company schedules meetings with their customers. \n∀x (Lunch(x) ∨ Home(x)) ::: Employees will either have lunch in the company or have lunch at home. \n∀x (Home(x) → Remote(x)) ::: If an employee has lunch at home, then he/she is working remotely from home. \n∀x (Work(x, y) → Remote(x)) ::: All employees who are in other countries work remotely from home. \n∀x (Manager(x) → ¬Remote(x)) ::: No managers work remotely from home. \n(Manager(james) ∧ Appear(james)) ⊕ (¬Manager(james) ∧ ¬Appear(james)) ::: James is either a manager and appears in the company today or neither a manager nor appears in the company today.",
                "First-Order-Logic Question": "¬Lunch(james) ::: James does not have lunch in the company."
            },
            "diff": [],
            "answer": "C",
            "error_type":"",
            "grammar_answer": "C"
        },
        {
            "id": 14,
            "raw_prog": {
                "First-Order-Logic Rules": "Create(japaneseGameCompany, legendOfZelda) ::: A Japanese game company created the game the Legend of Zelda.\n∀x (Game(x) ∧ Sell(x, moreThanOneMillion) → Select(x, Top10)) ::: If a game sells more than one million copies, then it will be selected into the Top 10 list.\nSelect(legendOfZelda, Top10) ::: The Legend of Zelda sold more than one million copies.\n∀x (Top10(x) → Japanese(Create(japanese, x))) ::: All games in the Top 10 list are made by Japanese game companies.\n",
                "First-Order-Logic Question": "¬Top10(legendOfZelda) ::: The Legend of Zelda is not in the Top 10 list."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "CreateGame(japaneseGameCompany, legendOfZelda) ::: A Japanese game company created the game the Legend of Zelda.\n∀x (Game(x) ∧ Sell(x, moreThanOneMillion) → Select(x, Top10List)) ::: If a game sells more than one million copies, then it will be selected into the Top 10 list.\nSelect(legendOfZelda, Top10List) ::: The Legend of Zelda sold more than one million copies.\n∀x (Top10Game(x) → ∃y (Game(y) ∧ CreateCompany(Japanese, y, x))) ::: All games in the Top 10 list are made by Japanese game companies.",
                "First-Order-Logic Question": "¬Top10Game(legendOfZelda) ::: The Legend of Zelda is not in the Top 10 list."
            },
            "diff": [],
            "answer": "B",
            "error_type":"",
            "grammar_answer": "C"
        },
        {
            "id": 43,
            "raw_prog": {
                "First-Order-Logic Rules": "∀x (RankedHighly(x) → Active(x)) ::: If a player is ranked highly by the Women's Tennis Association, then they are among the most active players in major tennis. \n∀x (LostTo(x, IgaSwiatek) → RankedHighly(x)) ::: Everyone who lost to Iga Swiatek is ranked highly by the Women's Tennis Association. \n∀x (Female(x) ∧ At(x, RolandGarros) → LostTo(x, IgaSwiatek)) ::: All female tennis players at Roland Garros 2022 lost to Iga Swiatek. \n(Female(x) ∧ At(x, RolandGarros)) ∨ (Male(x) ∧ At(x, RolandGarros)) ::: Either female tennis players at Roland Garros 2022 or male tennis players at Roland Garros 2022. \n∀x (Male(x) ∧ At(x, RolandGarros) → LostToRafaelNadal(x)) ::: All male tennis players at Roland Garros 2022 lost to Rafael Nadal. \n(RankedHighly(CocoGauff) ∨ LostTo(CocoGauff, RafaelNadal)) → ¬(Male(CocoGauff) ∧ At(CocoGauff, RolandGarros)) ::: If Coco Gauff is a player who is ranked highly by the Women's Tennis Association or a player who lost to Rafael Nadal, then Coco Gauff is not a male tennis player at Roland Garros 2022. \n",
                "First-Order-Logic Question": "LostTo(CocoGauff, RafaelNadal) ::: Coco Gauff has lost to Rafael Nadal."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∀x (RankedHighly(x) → Active(x)) ::: If a player is ranked highly by the Women's Tennis Association, then they are among the most active players in major tennis. \n∀x (LostTo(x, IgaSwiatek) → RankedHighly(x)) ::: Everyone who lost to Iga Swiatek is ranked highly by the Women's Tennis Association. \n∀x (Female(x) ∧ At(x, RolandGarros) → LostTo(x, IgaSwiatek)) ::: All female tennis players at Roland Garros 2022 lost to Iga Swiatek. \n(Female(x) ∧ At(x, RolandGarros)) ∨ (Male(x) ∧ At(x, RolandGarros)) ::: Either female tennis players at Roland Garros 2022 or male tennis players at Roland Garros 2022. \n∀x (Male(x) ∧ At(x, RolandGarros) → LostToRafaelNadal(x)) ::: All male tennis players at Roland Garros 2022 lost to Rafael Nadal. \n(RankedHighly(CocoGauff) ∨ LostTo(CocoGauff, RafaelNadal)) → ¬(Male(CocoGauff) ∧ At(CocoGauff, RolandGarros)) ::: If Coco Gauff is a player who is ranked highly by the Women's Tennis Association or a player who lost to Rafael Nadal, then Coco Gauff is not a male tennis player at Roland Garros 2022. \n",
                "First-Order-Logic Question": "LostTo(CocoGauff, RafaelNadal) ::: Coco Gauff has lost to Rafael Nadal."
            },
            "diff": [],
            "answer": "C",
            "error_type":"",
            "grammar_answer": "C"
        },
        {
            "id": 48,
            "raw_prog": {
                "First-Order-Logic Rules": "Season(spring) ∧ Season(summer) ∧ Season(fall) ∧ Season(winter) ::: There are four seasons in a year: Spring, Summer, Fall, and Winter. \n∀x (Student(x) ∧ WantLongVacation(x) → Love(x, summer)) ::: All students who want to have a long vacation love summer the most. \nFavoriteSeason(emma, summer) ::: Emma's favorite season is summer. \n∀x (FavoriteSeason(mia, y) → ¬FavoriteSeason(emma, y)) ::: Mia's favorite season is not the same as Emma's. \nWantLongVacation(james) ::: James wants to have a long vacation.",
                "First-Order-Logic Question": "FavoriteSeason(mia, spring) ::: Mia's favorite season is spring."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "Season(spring) ∧ Season(summer) ∧ Season(fall) ∧ Season(winter) ::: There are four seasons in a year: Spring, Summer, Fall, and Winter. \n∀x (Student(x) ∧ WantLongVacation(x) → Love(x, summer)) ::: All students who want to have a long vacation love summer the most. \nFavoriteSeason(emma, summer) ::: Emma's favorite season is summer. \n∀x (FavoriteSeason(mia, y) → ¬FavoriteSeason(emma, y)) ::: Mia's favorite season is not the same as Emma's. \nWantLongVacation(james) ::: James wants to have a long vacation.",
                "First-Order-Logic Question": "FavoriteSeason(mia, spring) ::: Mia's favorite season is spring."
            },
            "diff": [],
            "answer": "C",
            "error_type":"",
            "grammar_answer": "C"
        },
        {
            "id": 52,
            "raw_prog": {
                "First-Order-Logic Rules": "∀x (Romance(x) → IndoEuropean(x)) ::: All Romance languages are Indo-European languages.\nLanguageFamily(romance) ::: The Romance languages are a language family.\n∀x ∀y (LanguageFamily(x) ∧ LanguageFamily(y) → Related(x, y)) ::: All languages within a language family are related to each other.\nRomance(french) ∧ Romance(spanish) ::: French and Spanish are both Romance languages.\nRelated(german, spanish) ::: German is related to Spanish.\nBasque ::: Basque is not related to any other language.",
                "First-Order-Logic Question": "Romance(basque) ::: Basque is a Romance language."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∀x (RomanceLang(x) → IndoEuropean(x)) ::: All Romance languages are Indo-European languages.\nLanguageFamily(romance) ::: The Romance languages are a language family.\n∀x ∀y (LanguageFamily(x) ∧ LanguageFamily(y) → Related(x, y)) ::: All languages within a language family are related to each other.\nRomanceLang(french) ∧ RomanceLang(spanish) ::: French and Spanish are both Romance languages.\nRelated(german, spanish) ::: German is related to Spanish.\n¬∃x (Related(Basque, x)) ::: Basque is not related to any other language.",
                "First-Order-Logic Question": "RomanceLang(basque) ::: Basque is a Romance language."
            },
            "diff": [
                {
                    "raw": "Basque ::: Basque is not related to any other language.",
                    "gram": "¬∃x (Related(Basque, x)) ::: Basque is not related to any other language."
                }
            ],
            "answer": "B",
            "error_type":"",
            "grammar_answer": "C"
        },
        {
            "id": 57,
            "raw_prog": {
                "First-Order-Logic Rules": "Striker(robertlewandowski) ::: Robert Lewandowski is a striker.\n∀x (Striker(x) → SoccerPlayer(x)) ::: Strikers are soccer players.\nLeftTeam(robertlewandowski, bayernmunchen) ::: Robert Lewandowski left Bayern Munchen.\n∀x∀y (LeftTeam(x, y) → ¬PlayFor(x, y)) ::: If a player left a team they no longer play for that team.",
                "First-Order-Logic Question": "Star(robertlewandowski) ::: Robert Lewandowski is a star."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "Striker(robertlewandowski) ::: Robert Lewandowski is a striker.\n∀x (Striker(x) → SoccerPlayer(x)) ::: Strikers are soccer players.\nLeftTeam(robertlewandowski, bayernmunchen) ::: Robert Lewandowski left Bayern Munchen.\n∀x∀y (LeftTeam(x, y) → ¬PlayFor(x, y)) ::: If a player left a team they no longer play for that team.",
                "First-Order-Logic Question": "Star(robertlewandowski) ::: Robert Lewandowski is a star."
            },
            "diff": [],
            "answer": "C",
            "error_type":"",
            "grammar_answer": "C"
        },
        {
            "id": 59,
            "raw_prog": {
                "First-Order-Logic Rules": "City(billings) ∧ In(billings, montana) ::: Billings is a city in Montana.\nInclude(montana, butte) ∧ Include(montana, helena) ∧ Include(montana, missoula) ::: Montana includes the cities of Butte, Helena, and Missoula.\nCity(white_sulphur_springs) ∧ City(butte) ∧ SameState(white_sulphur_springs, butte) ::: White Sulphur Springs and Butte are cities in the same state.\n¬In(pierre, montana) ::: The city of Pierre is not in Montana.\n∀x (City(x) ∧ In(x, butte) → ¬In(x, pierre)) ::: Any city in Butte is not in Pierre.\n",
                "First-Order-Logic Question": "SameState(pierre, bismarck) ::: Pierre and Bismarck are in the same state."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "City(billings) ∧ In(billings, montana) ::: Billings is a city in Montana.\nInclude(montana, butte) ∧ Include(montana, helena) ∧ Include(montana, missoula) ::: Montana includes the cities of Butte, Helena, and Missoula.\nCity(white_sulphur_springs) ∧ City(butte) ∧ SameState(white_sulphur_springs, butte) ::: White Sulphur Springs and Butte are cities in the same state.\n¬In(pierre, montana) ::: The city of Pierre is not in Montana.\n∀x (City(x) ∧ In(x, butte) → ¬In(x, pierre)) ::: Any city in Butte is not in Pierre.\n",
                "First-Order-Logic Question": "SameState(pierre, bismarck) ::: Pierre and Bismarck are in the same state."
            },
            "diff": [],
            "answer": "C",
            "error_type":"",
            "grammar_answer": "C"
        },
        {
            "id": 61,
            "raw_prog": {
                "First-Order-Logic Rules": "∀x (InternationalStudent(x) ∧ InUS(x) → (HasVisa(x, F1Visa) ∨ HasVisa(x, J1Visa))) ::: International students in US have either an F1 visa or a J1 visa. \n∀x (InternationalStudent(x) ∧ InUS(x) ∧ HasVisa(x, F1Visa) ∧ WorkInUS(x) → NeedsToApplyFor(x, CPT)) ::: An international student in US with an F1 visa needs to apply for CPT or OPT if the student wants to work in the US. \nInternationalStudent(mike) ::: Mike is an international student. \nWorkInUS(mike) ∧ NeedsToApplyFor(mike, CPT) ::: Mike needs to apply for CPT if he wants to work in the US.",
                "First-Order-Logic Question": "HasVisa(mike, F1Visa) ::: Mike has an F1 visa."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∀x (InternationalStudent(x) ∧ InUS(x) → (HasVisa(x, F1Visa) ∨ HasVisa(x, J1Visa))) ::: International students in US have either an F1 visa or a J1 visa. \n∀x (InternationalStudent(x) ∧ InUS(x) ∧ HasVisa(x, F1Visa) ∧ WorkInUS(x) → NeedsToApplyFor(x, CPT)) ::: An international student in US with an F1 visa needs to apply for CPT or OPT if the student wants to work in the US. \nInternationalStudent(mike) ::: Mike is an international student. \nWorkInUS(mike) ∧ NeedsToApplyFor(mike, CPT) ::: Mike needs to apply for CPT if he wants to work in the US.",
                "First-Order-Logic Question": "HasVisa(mike, F1Visa) ::: Mike has an F1 visa."
            },
            "diff": [],
            "answer": "C",
            "error_type":"",
            "grammar_answer": "C"
        },
        {
            "id": 73,
            "raw_prog": {
                "First-Order-Logic Rules": "∀x (GrowthStock(x) → Volatile(x)) ::: All growth stocks of companies are volatile.\n∀x (Volatile(x) → ¬SuitableForRetirement(x)) ::: If the stock price is volatile, then it is not suitable for a retirement fund.\n∃x ∃y (GrowthStock(x) ∧ Company(y)) ::: Some stocks of some companies are growth stocks of companies.\n∀x (Stock(x) ∧ MatureCompany(x) → SuitableForRetirement(x)) ::: All stocks of mature companies are suitable for a retirement fund.\nKO(ko) ∧ Stock(ko) ∧ MatureCompany(ko) ::: KO is a stock of a mature company.\n",
                "First-Order-Logic Question": "(GrowthStock(ko) ∨ Volatile(ko)) → (¬Stock(ko) ∧ ¬Volatile(ko)) ::: If KO is a growth stock of a company or if its price is volatile, then KO is neither a stock of a company nor is its price volatile."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∀x (GrowthStock(x) → Volatile(x)) ::: All growth stocks of companies are volatile.\n∀x (Volatile(x) → ¬SuitableForRetirement(x)) ::: If the stock price is volatile, then it is not suitable for a retirement fund.\n∃x ∃y (GrowthStock(x) ∧ Company(y)) ::: Some stocks of some companies are growth stocks of companies.\n∀x (Stock(x) ∧ MatureCompany(x) → SuitableForRetirement(x)) ::: All stocks of mature companies are suitable for a retirement fund.\nKO(ko) ∧ Stock(ko) ∧ MatureCompany(ko) ::: KO is a stock of a mature company.\n",
                "First-Order-Logic Question": "(GrowthStock(ko) ∨ Volatile(ko)) → (¬Stock(ko) ∧ ¬Volatile(ko)) ::: If KO is a growth stock of a company or if its price is volatile, then KO is neither a stock of a company nor is its price volatile."
            },
            "diff": [],
            "answer": "A",
            "error_type":"",
            "grammar_answer": "A"
        },
        {
            "id": 104,
            "raw_prog": {
                "First-Order-Logic Rules": "∀x (Twins(x) ∨ Triplets(x) → SpendTimeWith(x, x)) ::: If people are twins or triplets, then they spend a lot of time hanging out with and playing with their siblings.\n∀x (Siblings(x, y) → Twins(x) ∨ Triplets(x)) ::: If people have siblings who are the same age, then they are twins or triplets.\n∀x (Complain(x) → Siblings(x, y)) ::: If people complain often about annoying siblings, then they have siblings who are the same age.\n∀x (¬LiveAtHome(x) → ¬DevelopBonds(x, y)) ::: If people do not live at home regularly, then they do not develop strong bonds with their family members.\n∀x (SpendTimeWith(x, y) → ¬LiveAtHome(x)) ::: If people spend a lot of time hanging out with and playing with their siblings, then they often did not live at home regularly.\n(Twins(luke) ∧ DevelopBonds(luke, luke)) ⊕ (¬Twins(luke) ∧ ¬DevelopBonds(luke, luke)) ::: Luke is either both a twin or triplet and develops strong bonds with his family members, or he neither is a twin or triplet nor develops strong bonds with his family members.\n",
                "First-Order-Logic Question": "¬(Twins(luke) ∨ Triplets(luke) ∨ Complain(luke)) ::: Luke is neither a twin nor triplet nor complains often about annoying siblings."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∀x (Twins(x) ∨ Triplets(x) → SpendTimeWith(x, x)) ::: If people are twins or triplets, then they spend a lot of time hanging out with and playing with their siblings.\n∀x (Siblings(x, y) → Twins(x) ∨ Triplets(x)) ::: If people have siblings who are the same age, then they are twins or triplets.\n∀x (Complain(x) → Siblings(x, y)) ::: If people complain often about annoying siblings, then they have siblings who are the same age.\n∀x (¬LiveAtHome(x) → ¬DevelopBonds(x, y)) ::: If people do not live at home regularly, then they do not develop strong bonds with their family members.\n∀x (SpendTimeWith(x, y) → ¬LiveAtHome(x)) ::: If people spend a lot of time hanging out with and playing with their siblings, then they often did not live at home regularly.\n(Twins(luke) ∧ DevelopBonds(luke, luke)) ⊕ (¬Twins(luke) ∧ ¬DevelopBonds(luke, luke)) ::: Luke is either both a twin or triplet and develops strong bonds with his family members, or he neither is a twin or triplet nor develops strong bonds with his family members.\n",
                "First-Order-Logic Question": "¬(Twins(luke) ∨ Triplets(luke) ∨ Complain(luke)) ::: Luke is neither a twin nor triplet nor complains often about annoying siblings."
            },
            "diff": [],
            "answer": "A",
            "error_type":"",
            "grammar_answer": "C"
        },
        {
            "id": 115,
            "raw_prog": {
                "First-Order-Logic Rules": "∀x ∀y (Man(x) ∧ Man(y) ∧ Taller(x, y) → Block(x, y)) ::: If a man is taller than another man, the taller one can block the other's shooting.\nMan(michael) ∧ ∀x (Man(x) ∧ x ≠ michael → Taller(michael, x)) ::: Michael is a man who is taller than everyone else in his class.\n∀x ∀y ∀z (Taller(x, y) ∧ Taller(y, z) → Taller(x, z)) ::: If person x is taller than person y, and person y is taller than person z, than x is taller than z\nMan(peter) ∧ Taller(peter, michael) ::: Peter is a man who is taller than Michael.\n∀x (Shooter(x) ∧ ¬Jump(x) → Block(michael, x)) ::: Michael can block any shooting from a person as long as the person does not jump when shooting.\n¬Block(michael, windy) ::: Michael cannot block Windy's shooting.\n∀x (Shooter(x) ∧ Jump(x) → GreatShooter(x)) ::: Every shooter who can jump when shooting is a great shooter.",
                "First-Order-Logic Question": "∃x (Man(x) ∧ Classmate(x, michael) ∧ Taller(x, peter)) ::: Peter is shorter than a man in Michael's class."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∃x (JapaneseCompany(x) ∧ Create(x, legendOfZelda)) ::: A Japanese game company created the game the Legend of Zelda.\n∀x ∃z (¬Top10(x) ∨ (JapaneseCompany(z) ∧ Create(z,x))) ::: All games in the Top 10 list are made by Japanese game companies.\n∀x (SellExactly(x, oneMillion) → Top10(x)) ::: If a game sells one million copies, then it will be selected into the Top 10 list.\nSellMore(legendOfZelda, oneMillion) ::: The Legend of Zelda sold more than one million copies.",
                "First-Order-Logic Question": "Top10(legendOfZelda) ::: The Legend of Zelda is in the Top 10 list."
            },
            "diff": [],
            "answer": "B",
            "error_type":"",
            "grammar_answer": "C"
        },
        {
            "id": 128,
            "raw_prog": {
                "First-Order-Logic Rules": "∀x (HaveWedding(x) → HaveChild(x)) ::: All people who have a wedding are people who have at least one child.\n∀x (TravelToParis(x) → HaveWedding(x)) ::: All people who travel to Paris for their honeymoon are people who have a wedding.\n∀x (OccurIn(x, July) ∧ HaveWedding(x) → TravelToParis(x)) ::: All weddings that occur in July belong to people who travel to Paris for their honeymoon.\n∃x (OccurIn(x, July) ∧ WellAttended(x)) ::: Some weddings in July are well-attended.\nHaveChild(John) → (¬TravelToParis(John) ∧ ¬HaveWedding(John)) ::: If John has at least one child, then John does not travel to Paris for his honeymoon and does not have a wedding.\nHaveWedding(John) ∧ WellAttended(John) → (OccurIn(John, July) ∨ (¬OccurIn(John, July) → TravelToParis(John))) ::: If John has a wedding that is well-attended, then John has a wedding in July or, if not, then John travels to Paris for their honeymoon.",
                "First-Order-Logic Question": "WellAttended(John) ::: John has a wedding that is well-attended."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∀x (HaveWedding(x) → HaveChild(x)) ::: All people who have a wedding are people who have at least one child.\n∀x (TravelToParis(x) → HaveWedding(x)) ::: All people who travel to Paris for their honeymoon are people who have a wedding.\n∀x (OccurIn(x, July) ∧ HaveWedding(x) → TravelToParis(x)) ::: All weddings that occur in July belong to people who travel to Paris for their honeymoon.\n∃x (OccurIn(x, July) ∧ WellAttended(x)) ::: Some weddings in July are well-attended.\nHaveChild(John) → (¬TravelToParis(John) ∧ ¬HaveWedding(John)) ::: If John has at least one child, then John does not travel to Paris for his honeymoon and does not have a wedding.\nHaveWedding(John) ∧ WellAttended(John) → (OccurIn(John, July) ∨ (¬OccurIn(John, July) → TravelToParis(John))) ::: If John has a wedding that is well-attended, then John has a wedding in July or, if not, then John travels to Paris for their honeymoon.",
                "First-Order-Logic Question": "WellAttended(John) ::: John has a wedding that is well-attended."
            },
            "diff": [],
            "answer": "B",
            "error_type":"",
            "grammar_answer": "C"
        },
        {
            "id": 153,
            "raw_prog": {
                "First-Order-Logic Rules": "∀x,y (Owns(x, y) → (WorkRegularlyAtHome(x) ∧ TidyOrganize(x))) ::: If people own a large desktop monitor at their home, then they work regularly and often at home.\n∀x (HasHomeOffice(x) → Owns(x, largeDesktopMonitor)) ::: All people who have a fully stocked and impressive home office are people who own a large desktop monitor at their home.\n∀x (WorkRegularlyAtHome(x) → TidyOrganize(x)) ::: All people who work regularly and often at home spend their free time tidying and organizing the spaces in their homes.\n∀x (WorkRegularlyAtHome(x) → VisitStore(x)) ::: All people who work regularly and often at home visit the office supply store regularly.\n∀x (TidyOrganize(x) → (¬GoToBedLate(x) ∧ WakeUpLate(x))) ::: If people spend their free time tidying and organizing the spaces in their home, then they do not go to bed late and wake up every day after noon.\n(TidyOrganize(remy) ∧ (GoToBedLate(remy) ∧ WakeUpLate(remy))) ⊕ (¬GoToBedLate(remy) ∧ ¬WakeUpLate(remy) ∧ ¬TidyOrganize(remy)) ::: Remy either both goes to bed late and wakes up every day after noon and spends their free time tidying and organizing the spaces in their home, or they do not go to bed late and wake up every day after noon nor spend their free time tidying and organizing the spaces in their home.\n",
                "First-Order-Logic Question": "VisitStore(remy) ::: Remy visits the office supply store regularly."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∀x (Owns(x, LargeDesktopMonitor) → (WorkRegularlyAtHome(x) ∧ TidyOrganize(x))) ::: If people own a large desktop monitor at their home, then they work regularly and often at home.\n∀x (HasHomeOffice(x) → Owns(x, largeDesktopMonitor)) ::: All people who have a fully stocked and impressive home office are people who own a large desktop monitor at their home.\n∀x (WorkRegularlyAtHome(x) → TidyOrganize(x)) ::: All people who work regularly and often at home spend their free time tidying and organizing the spaces in their homes.\n∀x (WorkRegularlyAtHome(x) → VisitStore(x)) ::: All people who work regularly and often at home visit the office supply store regularly.\n∀x (TidyOrganize(x) → (¬GoToBedLate(x) ∧ WakeUpLate(x))) ::: If people spend their free time tidying and organizing the spaces in their home, then they do not go to bed late and wake up every day after noon.\n(TidyOrganize(remy) ∧ (GoToBedLate(remy) ∧ WakeUpLate(remy))) ⊕ (¬GoToBedLate(remy) ∧ ¬WakeUpLate(remy) ∧ ¬TidyOrganize(remy)) ::: Remy either both goes to bed late and wakes up every day after noon and spends their free time tidying and organizing the spaces in their home, or they do not go to bed late and wake up every day after noon nor spend their free time tidying and organizing the spaces in their home.\n",
                "First-Order-Logic Question": "VisitStore(remy) ::: Remy visits the office supply store regularly."
            },
            "diff": [
                {
                    "raw": "∀x,y (Owns(x, y) → (WorkRegularlyAtHome(x) ∧ TidyOrganize(x))) ::: If people own a large desktop monitor at their home, then they work regularly and often at home.",
                    "gram": "∀x (Owns(x, LargeDesktopMonitor) → (WorkRegularlyAtHome(x) ∧ TidyOrganize(x))) ::: If people own a large desktop monitor at their home, then they work regularly and often at home."
                }
            ],
            "answer": "C",
            "error_type":"",
            "grammar_answer": "C"
        },
        {
            "id": 155,
            "raw_prog": {
                "First-Order-Logic Rules": "∀x,y (Owns(x, y) → (WorkRegularly(x) ∧ WorkOften(x))) ::: If people own a large desktop monitor at their home, then they work regularly and often at home.\n∀x (FullyStocked(x) → Owns(x, largeDesktopMonitor) ∧ Impressive(x)) ::: All people who have a fully stocked and impressive home office are people who own a large desktop monitor at their home.\n∀x (WorkRegularly(x) ∧ WorkOften(x) → Tidy(x)) ::: All people who work regularly and often at home spend their free time tidying and organizing the spaces in their homes.\n∀x (WorkRegularly(x) ∧ WorkOften(x) → VisitStore(x)) ::: All people who work regularly and often at home visit the office supply store regularly.\n∀x (Tidy(x) → (¬Late(x) ∧ ¬WakeLate(x))) ::: If people spend their free time tidying and organizing the spaces in their home, then they do not go to bed late and wake up every day after noon.\n(Tidy(remy) ∧ Late(remy) ∧ WakeLate(remy)) ⊕ (¬Late(remy) ∧ ¬WakeLate(remy) ∧ ¬Tidy(remy)) ::: Remy either both goes to bed late and wakes up every day after noon and spends their free time tidying and organizing the spaces in their home, or they do not go to bed late and wake up every day after noon nor spend their free time tidying and organizing the spaces in their home.\n",
                "First-Order-Logic Question": "((Late(remy) ∧ WakeLate(remy)) ∨ VisitStore(remy)) → (¬Tidy(remy) ∧ ¬FullyStocked(remy)) ::: If Remy either goes to bed late and wakes up every day after noon or visits the office supply store regularly, then Remy neither spends their free time tidying and organizing the spaces in their home nor has a fully stocked and impressive home office."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∀x (Owns(x, LargeDesktopMonitor) ∧ Home(x) → (WorkRegularly(x) ∧ WorkOften(x))) ::: If people own a large desktop monitor at their home, then they work regularly and often at home.\n∀x (FullyStocked(x) → Owns(x, largeDesktopMonitor) ∧ Impressive(x)) ::: All people who have a fully stocked and impressive home office are people who own a large desktop monitor at their home.\n∀x (WorkRegularly(x) ∧ WorkOften(x) → Tidy(x)) ::: All people who work regularly and often at home spend their free time tidying and organizing the spaces in their homes.\n∀x (WorkRegularly(x) ∧ WorkOften(x) → VisitStore(x)) ::: All people who work regularly and often at home visit the office supply store regularly.\n∀x (Tidy(x) → (¬Late(x) ∧ ¬WakeLate(x))) ::: If people spend their free time tidying and organizing the spaces in their home, then they do not go to bed late and wake up every day after noon.\n(Tidy(remy) ∧ Late(remy) ∧ WakeLate(remy)) ⊕ (¬Late(remy) ∧ ¬WakeLate(remy) ∧ ¬Tidy(remy)) ::: Remy either both goes to bed late and wakes up every day after noon and spends their free time tidying and organizing the spaces in their home, or they do not go to bed late and wake up every day after noon nor spend their free time tidying and organizing the spaces in their home.\n",
                "First-Order-Logic Question": "((Late(remy) ∧ WakeLate(remy)) ∨ VisitStore(remy)) → (¬Tidy(remy) ∧ ¬FullyStocked(remy)) ::: If Remy either goes to bed late and wakes up every day after noon or visits the office supply store regularly, then Remy neither spends their free time tidying and organizing the spaces in their home nor has a fully stocked and impressive home office."
            },
            "diff": [
                {
                    "raw": "∀x,y (Owns(x, y) → (WorkRegularly(x) ∧ WorkOften(x))) ::: If people own a large desktop monitor at their home, then they work regularly and often at home.",
                    "gram": "∀x (Owns(x, LargeDesktopMonitor) ∧ Home(x) → (WorkRegularly(x) ∧ WorkOften(x))) ::: If people own a large desktop monitor at their home, then they work regularly and often at home."
                }
            ],
            "answer": "A",
            "error_type":"",
            "grammar_answer": "C"
        },
        {
            "id": 178,
            "raw_prog": {
                "First-Order-Logic Rules": "SportingEvent(olympicGames) ::: The Olympic games is a sporting event.\nLastOlympicGames(tokyo) ::: The last Olympic games was in Tokyo.\nWonMostMedals(unitedStates, tokyo) ::: The United States won the most medals in Tokyo.\n",
                "First-Order-Logic Question": "WonMostMedals(unitedStates, tokyo) ::: The United States won the most medals in the last Olympic games."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "SportingEvent(olympicGames) ::: The Olympic games is a sporting event.\nLastOlympicGames(tokyo) ::: The last Olympic games was in Tokyo.\nWonMostMedals(unitedStates, tokyo) ::: The United States won the most medals in Tokyo.\n",
                "First-Order-Logic Question": "WonMostMedals(unitedStates, tokyo) ::: The United States won the most medals in the last Olympic games."
            },
            "diff": [],
            "answer": "A",
            "error_type":"",
            "grammar_answer": "A"
        },
        {
            "id": 181,
            "raw_prog": {
                "First-Order-Logic Rules": "Flies(susan, LGA) ::: Susan flies to LGA airport.\n∀x (Airport(x) ∧ Flies(john, x) ∧ ¬(DepartsFrom(john, x) ∧ ArrivesAt(john, x))) ::: The departure and arrival can not be the same airport.\n",
                "First-Order-Logic Question": "Flies(john, LGA) ::: John flies to LGA airport."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "Flies(susan, LGA) ::: Susan flies to LGA airport.\n∀x (Airport(x) ∧ Flies(john, x) ∧ ¬(DepartsFrom(john, x) ∧ ArrivesAt(john, x))) ::: The departure and arrival can not be the same airport.\n",
                "First-Order-Logic Question": "Flies(john, LGA) ::: John flies to LGA airport."
            },
            "diff": [],
            "answer": "B",
            "error_type":"",
            "grammar_answer": "A"
        },
        {
            "id": 13,
            "raw_prog": {
                "First-Order-Logic Rules": "Create(japaneseGameCompany, legendOfZelda) ::: A Japanese game company created the game the Legend of Zelda.\n∀x (Game(x) ∧ Sell(x, moreThanOneMillion) → Select(x, Top10(x))) ::: If a game sells more than one million copies, then it will be selected into the Top 10 list.\nSelect(legendOfZelda, Top10) ::: The Legend of Zelda sold more than one million copies and is selected into the Top 10 list.\n",
                "First-Order-Logic Question": "Create(japaneseVideoGameCompany, FIFA22) ::: FIFA 22 is made by a Japanese video game company."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "Create(japaneseGameCompany, legendOfZelda) ::: A Japanese game company created the game the Legend of Zelda.\n∀x (Game(x) ∧ Sell(x, moreThanOneMillion) → Select(x, Top10)) ::: If a game sells more than one million copies, then it will be selected into the Top 10 list.\nSelect(legendOfZelda, Top10) ::: The Legend of Zelda sold more than one million copies and is selected into the Top 10 list.\n",
                "First-Order-Logic Question": "Create(japaneseVideoGameCompany, FIFA22) ::: FIFA 22 is made by a Japanese video game company."
            },
            "diff": [],
            "answer": "C",
            "error_type":"",
            "grammar_answer": "C"
        },
        {
            "id": 46,
            "raw_prog": {
                "First-Order-Logic Rules": "∀x (Season(x) → (Spring(x) ∨ Summer(x) ∨ Fall(x) ∨ Winter(x))) ::: There are four seasons in a year: Spring, Summer, Fall, and Winter. \n∀x (Student(x) ∧ WantLongVacation(x) → Love(x, Summer)) ::: All students who want to have a long vacation love summer the most. \nFavoriteSeason(emma, Summer) ::: Emma's favorite season is summer. \n∀x (Student(mia) ∧ NotSame(FavoriteSeason(mia, emma), emma)) ::: Mia's favorite season is not the same as Emma's. \nWantLongVacation(james) ::: James wants to have a long vacation.",
                "First-Order-Logic Question": "FavoriteSeason(james, Summer) ::: James's favorite season is summer."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∀x (Season(x) → (Spring(x) ∨ SeasonSummer(x) ∨ Fall(x) ∨ Winter(x))) ::: There are four seasons in a year: Spring, Summer, Fall, and Winter. \n∀x (Student(x) ∧ WantLongVacation(x) → Love(x, SeasonSummer)) ::: All students who want to have a long vacation love summer the most. \nFavoriteSeason(emma, SeasonSummer) ::: Emma's favorite season is summer. \n∀x (Student(mia) ∧ ∀y (Season(y) → (FavoriteSeason(mia, y) ∧ ¬FavoriteSeason(emma, y)))) ::: Mia's favorite season is not the same as Emma's. \nWantLongVacation(james) ::: James wants to have a long vacation.",
                "First-Order-Logic Question": "FavoriteSeason(james, SeasonSummer) ::: James's favorite season is summer."
            },
            "diff": [
                {
                    "raw": "∀x (Student(mia) ∧ NotSame(FavoriteSeason(mia, emma), emma)) ::: Mia's favorite season is not the same as Emma's. ",
                    "gram": "∀x (Student(mia) ∧ ∀y (Season(y) → (FavoriteSeason(mia, y) ∧ ¬FavoriteSeason(emma, y)))) ::: Mia's favorite season is not the same as Emma's. "
                }
            ],
            "answer": "A",
            "error_type":"",
            "grammar_answer": "C"
        },
        {
            "id": 74,
            "raw_prog": {
                "First-Order-Logic Rules": "∀x (Plate(x) → BeginWith(x, number34)) ::: All vehicle registration plates in Istanbul begin with the number 34.\n∀x (¬BeginWith(x, number34) → ¬InCity(x, istanbul)) ::: Plates that do not begin with the number 34 are not from Istanbul.\nInCity(joePlate, istanbul) ::: Joe's vehicle registration plate is from Istanbul.\nBeginWith(tomPlate, number35) ::: Tom's license plate begins with the number 35.\n∀x (BG(BeginWith(x, number35), ¬BeginWith(x, number34))) ::: If a license plate begins with the number 35, then it does not begin with the number 34.",
                "First-Order-Logic Question": "BeginWith(joePlate, number34) ::: Joe's license plate begins with the number 34."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∀x (Plate(x) → BeginWith(x, number34)) ::: All vehicle registration plates in Istanbul begin with the number 34.\n∀x (¬BeginWith(x, number34) → ¬InCity(x, istanbul)) ::: Plates that do not begin with the number 34 are not from Istanbul.\nInCity(joePlate, istanbul) ::: Joe's vehicle registration plate is from Istanbul.\nBeginWith(tomPlate, number35) ::: Tom's license plate begins with the number 35.\n∀x (BeginWith(x, 35) → ¬BeginWith(x, 34)) ::: If a license plate begins with the number 35, then it does not begin with the number 34.",
                "First-Order-Logic Question": "BeginWith(joePlate, number34) ::: Joe's license plate begins with the number 34."
            },
            "diff": [
                {
                    "raw": "∀x (BG(BeginWith(x, number35), ¬BeginWith(x, number34))) ::: If a license plate begins with the number 35, then it does not begin with the number 34.",
                    "gram": "∀x (BeginWith(x, 35) → ¬BeginWith(x, 34)) ::: If a license plate begins with the number 35, then it does not begin with the number 34."
                }
            ],
            "answer": "A",
            "error_type":"",
            "grammar_answer": "A"
        },
        {
            "id": 107,
            "raw_prog": {
                "First-Order-Logic Rules": "Cost(gre, 205) ::: It costs US $205 to take the GRE test.\n∀x (Prove(x, EconomicHardship) → Provide(ETS, financial_aid, x)) ::: ETS provides financial aid to those GRE applicants who prove economic hardship.\n∀x (EconomicHardship(x) ↔ (LittleMoney(x) ∨ FewResources(x))) ::: Economic hardship refers to difficulty caused by having too little money or too few resources.\nSingleParent(tom) ::: Tom lives in a single-parent family.\nOutOfWork(dad, 1) ::: His dad has been out of work for more than a year.\n",
                "First-Order-Logic Question": "¬∃x ∀y (Prove(x, EconomicHardship) ∧ y = gre → Provide(ETS, financial_aid, x)) ::: There is no financial aid available for the GRE test."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "Cost(gre, 205) ::: It costs US $205 to take the GRE test.\n∀x (EconomicHardship(x) → (LittleMoney(x) ∨ FewResources(x))) ::: Economic hardship refers to difficulty caused by having too little money or too few resources.\nSingleParent(tom) ::: Tom lives in a single-parent family.\nOutOfWork(dad, 1) ::: His dad has been out of work for more than a year.",
                "First-Order-Logic Question": "¬∃x (EconomicHardship(x) ∧ Cost(gre, y) ∧ Provide(ETS, financial_aid, x)) ::: There is no financial aid available for the GRE test."
            },
            "diff": [],
            "answer": "B",
            "error_type":"",
            "grammar_answer": "C"
        },
        {
            "id": 108,
            "raw_prog": {
                "First-Order-Logic Rules": "∀x (SpillFood(x) → (¬TidySpaces(x) ∧ EnjoyCleaning(x))) ::: If people spill a lot of food on their clothing, then they do not tidy their spaces consistently and enjoy the process of cleaning.\n∀x (Foodie(x) → SpillFood(x)) ::: All foodies who go out frequently to find new food restaurants to try are people who spill a lot of food on their clothing.\n∀x (OnlyChild(x) → (TidySpaces(x) ∧ EnjoyCleaning(x))) ::: If people grew up as only children with no siblings, then they tidy their spaces consistently and enjoy the process of cleaning.\n∀x (BusyParents(x) → OnlyChild(x)) ::: If people have parents who are very busy with their regular jobs, then they grew up as only children with no siblings.\n∀x (HighIncomeHousehold(x) → BusyParents(Person(x))) ::: All households with a high net income have people who have parents who are very busy with their regular jobs.\n(SpillFood(Peter) ∧ OnlyChild(Peter)) ⊕ (¬SpillFood(Peter) ∧ ¬OnlyChild(Peter)) ::: Peter is either both a person who spills a lot of food on his clothing and grew up as an only child with no siblings, or he is neither a person who spills a lot of food on his clothing nor grew up as an only child with no siblings. ",
                "First-Order-Logic Question": "TidySpaces(Peter) ∧ EnjoyCleaning(Peter) ::: Peter tidies his space consistently and enjoys the process of cleaning."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∀x (SpillFood(x) → (¬TidySpaces(x) ∧ EnjoyCleaning(x))) ::: If people spill a lot of food on their clothing, then they do not tidy their spaces consistently and enjoy the process of cleaning.\n∀x (Foodie(x) → SpillFood(x)) ::: All foodies who go out frequently to find new food restaurants to try are people who spill a lot of food on their clothing.\n∀x (OnlyChild(x) → (TidySpaces(x) ∧ EnjoyCleaning(x))) ::: If people grew up as only children with no siblings, then they tidy their spaces consistently and enjoy the process of cleaning.\n∀x (BusyParents(x) → OnlyChild(x)) ::: If people have parents who are very busy with their regular jobs, then they grew up as only children with no siblings.\n∀x (HighIncomeHousehold(x) → ∃y BusyParents(y) ∧ Person(y)) ::: All households with a high net income have people who have parents who are very busy with their regular jobs.\n(SpillFood(Peter) ∧ OnlyChild(Peter)) ⊕ (¬SpillFood(Peter) ∧ ¬OnlyChild(Peter)) ::: Peter is either both a person who spills a lot of food on his clothing and grew up as an only child with no siblings, or he is neither a person who spills a lot of food on his clothing nor grew up as an only child with no siblings. ",
                "First-Order-Logic Question": "TidySpaces(Peter) ∧ EnjoyCleaning(Peter) ::: Peter tidies his space consistently and enjoys the process of cleaning."
            },
            "diff": [],
            "answer": "C",
            "error_type":"",
            "grammar_answer": "C"
        },
        {
            "id": 201,
            "raw_prog": {
                "First-Order-Logic Rules": "Person(ailtonSilva) ∧ Born(ailtonSilva, 1995) ∧ KnownAs(ailtonSilva, ailton) ::: Ailton Silva, born in 1995, is commonly known as Ailton.\nFootballPlayer(ailton) ∧ Loan(ailton, braga) ::: Ailton is a football player who was loaned out to Braga.\nBrazilian(ailtonSilva) ∧ FootballPlayer(ailtonSilva) ∧ PlaysFor(ailtonSilva, nautico) ::: Ailton Silva is a Brazillian footballer who plays for Nautico.\nClub(nautico) ∧ Club(braga) ∧ Team(nautico, braga) ::: Nautico is a football club along with Braga.\nClub(fluminense) ::: Fluminense is a football club.\n",
                "First-Order-Logic Question": "¬(∃x Loan(ailton, Club(x))) ::: Ailton was not loaned out to a football club."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "Person(ailtonSilva) ∧ Born(ailtonSilva, 1995) ∧ KnownAs(ailtonSilva, ailton) ::: Ailton Silva, born in 1995, is commonly known as Ailton.\nFootballPlayer(ailton) ∧ Loan(ailton, braga) ::: Ailton is a football player who was loaned out to Braga.\nBrazilian(ailtonSilva) ∧ FootballPlayer(ailtonSilva) ∧ PlaysFor(ailtonSilva, nautico) ::: Ailton Silva is a Brazillian footballer who plays for Nautico.\nClub(nautico) ∧ Club(braga) ∧ Team(nautico, braga) ::: Nautico is a football club along with Braga.\nClub(fluminense) ::: Fluminense is a football club.\n",
                "First-Order-Logic Question": "¬(∃y Loan(Ailton, y)) ::: Ailton was not loaned out to a football club."
            },
            "diff": [
                {
                    "raw": "¬(∃x Loan(ailton, Club(x))) ::: Ailton was not loaned out to a football club.",
                    "gram": "¬(∃y Loan(Ailton, y)) ::: Ailton was not loaned out to a football club."
                }
            ],
            "answer": "B",
            "error_type":"",
            "grammar_answer": "B"
        },
        {
            "id": 11,
            "raw_prog": {
                "First-Order-Logic Rules": "WildTurkey(tom) ::: Tom is a wild turkey.\n∀x (WildTurkey(x) → (x = EasternWildTurkey ∨ x = OsceolaWildTurkey ∨ x = GouldsWildTurkey ∨ x = MerriamsWildTurkey ∨ x = RioGrandeWildTurkey ∨ x = OcellatedWildTurkey)) ::: There are six types of wild turkeys: Eastern wild turkey, Osceola wild turkey, Gould’s wild turkey, Merriam’s wild turkey, Rio Grande wild turkey, and Ocellated wild turkey.\n¬EasternWildTurkey(tom) ∧ ¬OsceolaWildTurkey(tom) ∧ ¬GouldsWildTurkey(tom) ∧ ¬MerriamsWildTurkey(tom) ∧ ¬RioGrandeWildTurkey(tom) ::: Tom is not an Eastern wild turkey, Osceola wild turkey, Gould's wild turkey, Merriam's wild turkey, or Rio Grande wild turkey.\n",
                "First-Order-Logic Question": "WildTurkey(joey) ::: Joey is a wild turkey."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "WildTurkey(tom) ::: Tom is a wild turkey.\n∀x (WildTurkey(x) → (EasternWildTurkey(x) ∨ OsceolaWildTurkey(x) ∨ GouldsWildTurkey(x) ∨ MerriamsWildTurkey(x) ∨ RioGrandeWildTurkey(x) ∨ OcellatedWildTurkey(x))) ::: There are six types of wild turkeys: Eastern wild turkey, Osceola wild turkey, Gould’s wild turkey, Merriam’s wild turkey, Rio Grande wild turkey, and Ocellated wild turkey.\n¬EasternWildTurkey(tom) ∧ ¬OsceolaWildTurkey(tom) ∧ ¬GouldsWildTurkey(tom) ∧ ¬MerriamsWildTurkey(tom) ∧ ¬RioGrandeWildTurkey(tom) ::: Tom is not an Eastern wild turkey, Osceola wild turkey, Gould's wild turkey, Merriam's wild turkey, or Rio Grande wild turkey.\n",
                "First-Order-Logic Question": "WildTurkey(joey) ::: Joey is a wild turkey."
            },
            "diff": [
                {
                    "raw": "∀x (WildTurkey(x) → (x = EasternWildTurkey ∨ x = OsceolaWildTurkey ∨ x = GouldsWildTurkey ∨ x = MerriamsWildTurkey ∨ x = RioGrandeWildTurkey ∨ x = OcellatedWildTurkey)) ::: There are six types of wild turkeys: Eastern wild turkey, Osceola wild turkey, Gould’s wild turkey, Merriam’s wild turkey, Rio Grande wild turkey, and Ocellated wild turkey.",
                    "gram": "∀x (WildTurkey(x) → (EasternWildTurkey(x) ∨ OsceolaWildTurkey(x) ∨ GouldsWildTurkey(x) ∨ MerriamsWildTurkey(x) ∨ RioGrandeWildTurkey(x) ∨ OcellatedWildTurkey(x))) ::: There are six types of wild turkeys: Eastern wild turkey, Osceola wild turkey, Gould’s wild turkey, Merriam’s wild turkey, Rio Grande wild turkey, and Ocellated wild turkey."
                }
            ],
            "answer": "C",
            "error_type":"",
            "grammar_answer": "C"
        },
        {
            "id": 79,
            "raw_prog": {
                "First-Order-Logic Rules": "¬(∃x (Bakery(x) ∧ Spicy(x))) ::: No bakery is spicy.\n∀x (Cupcake(x) → Bakery(x)) ::: All cupcakes are bakeries.\n∀x (Hotpot(x) → Spicy(x)) ::: All hotpots are spicy.\n∀x (Product(BakedByMelissa(x), x) → Cupcake(x)) ::: All products of Baked by Melissa are cupcakes.\n(DriedThaiChilies(driedthaichilies) ∨ Bakery(driedthaichilies)) → (Hotpot(driedthaichilies) ∨ Spicy(driedthaichilies)) ::: If dried Thai chilies are spicy or a bakery, then dried Thai chilies are a hotpot or are spicy.\n",
                "First-Order-Logic Question": "Product(driedthaichilies, BakedByMelissa) ::: Dried Thai chilies are a product of Baked by Melissa."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "¬(∃x (Bakery(x) ∧ Spicy(x))) ::: No bakery is spicy.\n∀x (Cupcake(x) → Bakery(x)) ::: All cupcakes are bakeries.\n∀x (Hotpot(x) → Spicy(x)) ::: All hotpots are spicy.\n∀x (Product(x, BakedByMelissa) → Cupcake(x)) ::: All products of Baked by Melissa are cupcakes.\n(DriedThaiChilies(driedthaichilies) ∨ Bakery(driedthaichilies)) → (Hotpot(driedthaichilies) ∨ Spicy(driedthaichilies)) ::: If dried Thai chilies are spicy or a bakery, then dried Thai chilies are a hotpot or are spicy.\n",
                "First-Order-Logic Question": "Product(driedthaichilies, BakedByMelissa) ::: Dried Thai chilies are a product of Baked by Melissa."
            },
            "diff": [],
            "answer": "B",
            "error_type":"",
            "grammar_answer": "B"
        },
        {
            "id": 95,
            "raw_prog": {
                "First-Order-Logic Rules": "∃x (Pet(x) ∧ AllowedIn(x, y)) ::: Pets are allowed in some managed buildings.\n∀x (RequireDeposit(x) → (Equal(x, RentAmount(y, z)) ∨ MoreThan(x, RentAmount(y, z)))) ::: A deposit is required to rent an apartment in a managed building.\nCat(fluffy) ∧ Pet(fluffy) ∧ Owner(tom, fluffy) ::: Fluffy is Tom's cat.\nCat(x) → Pet(x) ::: Cats are pets.\nManaged(olivegarden) ∧ Building(olivegarden) ::: The Olive Garden is a managed building.\nRentAmount(olivegarden, 2000) ::: The monthly rent at the Olive Garden is $2000.\nRentApartment(tom, olivegarden) ↔ (MoveInWith(tom, fluffy) ∧ ¬MoreThan(deposit, 1500)) ::: Tom will rent an apartment in a managed building if and only if he is allowed to move in with Fluffy, and the security deposit is no more than $1500.\nMoreThan(2000, 1500) ::: 2000$ is more than $1500.\n",
                "First-Order-Logic Question": "Equal(deposit, 2000) ∨ MoreThan(deposit, 2000) ::: The security deposit at the Olive Garden is either $2000 or more."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∃x (Pet(x) ∧ AllowedIn(x, y)) ::: Pets are allowed in some managed buildings.\n∀x (RentApartment(x, y) ∧ Managed(y) → RequireDeposit(x)) ::: A deposit is required to rent an apartment in a managed building.\nCat(fluffy) ∧ Pet(fluffy) ∧ Owner(tom, fluffy) ::: Fluffy is Tom's cat.\nCat(x) → Pet(x) ::: Cats are pets.\nManaged(olivegarden) ∧ Building(olivegarden) ::: The Olive Garden is a managed building.\nRentAmount(olivegarden, 2000) ::: The monthly rent at the Olive Garden is $2000.\nRentApartment(tom, olivegarden) ↔ (MoveInWith(tom, fluffy) ∧ ¬MoreThan(deposit, 1500)) ::: Tom will rent an apartment in a managed building if and only if he is allowed to move in with Fluffy, and the security deposit is no more than $1500.\nMoreThan(2000, 1500) ::: 2000$ is more than $1500.\n",
                "First-Order-Logic Question": "Equal(deposit, 2000) ∨ MoreThan(deposit, 2000) ::: The security deposit at the Olive Garden is either $2000 or more."
            },
            "diff": [
                {
                    "raw": "∀x (RequireDeposit(x) → (Equal(x, RentAmount(y, z)) ∨ MoreThan(x, RentAmount(y, z)))) ::: A deposit is required to rent an apartment in a managed building.",
                    "gram": "∀x (RentApartment(x, y) ∧ Managed(y) → RequireDeposit(x)) ::: A deposit is required to rent an apartment in a managed building."
                }
            ],
            "answer": "A",
            "error_type":"",
            "grammar_answer": "C"
        },
        {
            "id": 105,
            "raw_prog": {
                "First-Order-Logic Rules": "Cost(gre_test, 205) ::: It costs US $205 to take the GRE test.\n∀x ∀y (Prove(x, EconomicHardship(y)) → ProvideFinancialAid(ETS, y)) ::: ETS provides financial aid to those GRE applicants who prove economic hardship.\n∀x (EconomicHardship(x) ↔ (Difficulty(x) ∧ (LittleMoney(x) ∨ FewResources(x)))) ::: Economic hardship refers to difficulty caused by having too little money or too few resources.\nSingleParentFamily(tom) ::: Tom lives in a single-parent family.\nOutOfWork(tom_dad, more_than_1_year) ::: His dad has been out of work for more than a year.\n",
                "First-Order-Logic Question": "ApplyFor(tom, ETS, gre_test) ::: Tom can apply for financial aid from ETS to take the GRE test."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "Cost(gre_test, 205) ::: It costs US $205 to take the GRE test.\n∀y (EconomicHardship(y) → (Prove(GREApplicants, y) → ProvideFinancialAid(ETS, GREApplicants))) ::: ETS provides financial aid to those GRE applicants who prove economic hardship.\n∀x (EconomicHardship(x) ↔ (Difficulty(x) ∧ (LittleMoney(x) ∨ FewResources(x)))) ::: Economic hardship refers to difficulty caused by having too little money or too few resources.\nSingleParentFamily(tom) ::: Tom lives in a single-parent family.\nOutOfWork(tom_dad, more_than_1_year) ::: His dad has been out of work for more than a year.\n",
                "First-Order-Logic Question": "ApplyFor(tom, ETS, gre_test) ::: Tom can apply for financial aid from ETS to take the GRE test."
            },
            "diff": [
                {
                    "raw": "∀x ∀y (Prove(x, EconomicHardship(y)) → ProvideFinancialAid(ETS, y)) ::: ETS provides financial aid to those GRE applicants who prove economic hardship.",
                    "gram": "∀y (EconomicHardship(y) → (Prove(GREApplicants, y) → ProvideFinancialAid(ETS, GREApplicants))) ::: ETS provides financial aid to those GRE applicants who prove economic hardship."
                }
            ],
            "answer": "A",
            "error_type":"",
            "grammar_answer": "C"
        }
    ]
}