[
    {
        "id": 79,
        "raw_prog": {
            "First-Order-Logic Rules": "Fair(eli) ::: Eli is fair.\n¬Fair(shane) ::: Shane is not fair.\n¬Educational(joey) ::: Joey is not educational.\nNew(halsey) ::: Halsey is new.\nFair(aaron) ::: Aaron is fair.\n¬Anxious(eli) ::: Eli is not anxious.\nFair(joey) ::: Joey is fair.\nEducational(eli) ::: Eli is educational.\nAwful(halsey) ::: Halsey is awful.\n¬Educational(shane) ::: Shane is not educational.\nFair(halbert) ::: Halbert is fair.\n(∀x (Short(x) ∧ Anxious(x))) → (Fair(halsey)) ::: If there is at least one people who is both short and anxious, then Halsey is fair.\n((¬Awful(eli))) ↔ ((Anxious(eli))) ::: If Eli is not awful, then Eli is anxious, and vice versa.\n((New(halbert) ∧ ¬Awful(eli))) → ((Anxious(halsey) ∧ ¬Fair(eli))) ::: If Halbert is new and Eli is not awful, then Halsey is anxious and Eli is not fair.\n((¬Educational(halbert) ∧ Short(roderick))) → (Awful(joey)) ::: If Halbert is not educational and Roderick is short, then Joey is awful.\n((¬New(halsey) ∨ ¬Awful(halbert))) → (¬Educational(halsey)) ::: If Halsey is not new or Halbert is not awful, then Halsey is not educational.\n(∀x (¬Awful(x))) → (¬Educational(x)) ::: All not awful people are not educational.\n(∀x (¬New(x) ∧ ¬Anxious(x))) ↔ (¬Educational(x)) ::: Someone is not new and not anxious if and only if he is not educational.\n(∀x (¬Awful(x))) ↔ (¬Anxious(x)) ::: Someone is not awful if and only if he is not anxious.\n((¬Short(halsey))) → ((¬Awful(halbert))) ::: Halsey being not short implies that Halbert is not awful.\n((Short(roderick))) → (Fair(halsey)) ::: If Roderick is short, then Halsey is fair.\n((Educational(x))) ↔ ((¬Awful(x))) ::: If someone is educational, then he is not awful, and vice versa.\n(∃x (New(x))) → ((Educational(halsey) ∧ Fair(roderick)) ::: If there is at least one people who is new, then Halsey is educational and Roderick is fair.\n",
            "First-Order-Logic Question": "Anxious(joey) ::: Joey is anxious."
        },
        "gram_prog": {
            "First-Order-Logic Rules": "Fair(eli) ::: Eli is fair.\n¬Fair(shane) ::: Shane is not fair.\n¬Educational(joey) ::: Joey is not educational.\nNew(halsey) ::: Halsey is new.\nFair(aaron) ::: Aaron is fair.\n¬Anxious(eli) ::: Eli is not anxious.\nFair(joey) ::: Joey is fair.\nEducational(eli) ::: Eli is educational.\nAwful(halsey) ::: Halsey is awful.\n¬Educational(shane) ::: Shane is not educational.\nFair(halbert) ::: Halbert is fair.\n(∀x (Short(x) ∧ Anxious(x))) → (Fair(halsey)) ::: If there is at least one people who is both short and anxious, then Halsey is fair.\n((¬Awful(eli))) ↔ ((Anxious(eli))) ::: If Eli is not awful, then Eli is anxious, and vice versa.\n((New(halbert) ∧ ¬Awful(eli))) → ((Anxious(halsey) ∧ ¬Fair(eli))) ::: If Halbert is new and Eli is not awful, then Halsey is anxious and Eli is not fair.\n((¬Educational(halbert) ∧ Short(roderick))) → (Awful(joey)) ::: If Halbert is not educational and Roderick is short, then Joey is awful.\n((¬New(halsey) ∨ ¬Awful(halbert))) → (¬Educational(halsey)) ::: If Halsey is not new or Halbert is not awful, then Halsey is not educational.\n(∀x (¬Awful(x))) → (¬Educational(x)) ::: All not awful people are not educational.\n(∀x (¬New(x) ∧ ¬Anxious(x))) ↔ (¬Educational(x)) ::: Someone is not new and not anxious if and only if he is not educational.\n(∀x (¬Awful(x))) ↔ (¬Anxious(x)) ::: Someone is not awful if and only if he is not anxious.\n((¬Short(halsey))) → ((¬Awful(halbert))) ::: Halsey being not short implies that Halbert is not awful.\n((Short(roderick))) → (Fair(halsey)) ::: If Roderick is short, then Halsey is fair.\n((Educational(x))) ↔ ((¬Awful(x))) ::: If someone is educational, then he is not awful, and vice versa.\n∃x((New(x))→(Educational(x))) ::: If there is at least one people who is new, then Halsey is educational and Roderick is fair.\n",
            "First-Order-Logic Question": "Anxious(joey) ::: Joey is anxious."
        },
        "diff": [
            {
                "raw": "(∃x (New(x))) → ((Educational(halsey) ∧ Fair(roderick)) ::: If there is at least one people who is new, then Halsey is educational and Roderick is fair.",
                "gram": "∃x((New(x))→(Educational(x))) ::: If there is at least one people who is new, then Halsey is educational and Roderick is fair."
            }
        ],
        "answer": "B",
        "grammar_answer": "A",
        "manual_prog": {
            "First-Order-Logic Rules": "Fair(eli) ::: Eli is fair.\n¬Fair(shane) ::: Shane is not fair.\n¬Educational(joey) ::: Joey is not educational.\nNew(halsey) ::: Halsey is new.\nFair(aaron) ::: Aaron is fair.\n¬Anxious(eli) ::: Eli is not anxious.\nFair(joey) ::: Joey is fair.\nEducational(eli) ::: Eli is educational.\nAwful(halsey) ::: Halsey is awful.\n¬Educational(shane) ::: Shane is not educational.\nFair(halbert) ::: Halbert is fair.\n(∀x (Short(x) ∧ Anxious(x))) → (Fair(halsey)) ::: If there is at least one people who is both short and anxious, then Halsey is fair.\n((¬Awful(eli))) ↔ ((Anxious(eli))) ::: If Eli is not awful, then Eli is anxious, and vice versa.\n((New(halbert) ∧ ¬Awful(eli))) → ((Anxious(halsey) ∧ ¬Fair(eli))) ::: If Halbert is new and Eli is not awful, then Halsey is anxious and Eli is not fair.\n((¬Educational(halbert) ∧ Short(roderick))) → (Awful(joey)) ::: If Halbert is not educational and Roderick is short, then Joey is awful.\n((¬New(halsey) ∨ ¬Awful(halbert))) → (¬Educational(halsey)) ::: If Halsey is not new or Halbert is not awful, then Halsey is not educational.\n(∀x (¬Awful(x))) → (¬Educational(x)) ::: All not awful people are not educational.\n(∀x (¬New(x) ∧ ¬Anxious(x))) ↔ (¬Educational(x)) ::: Someone is not new and not anxious if and only if he is not educational.\n(∀x (¬Awful(x))) ↔ (¬Anxious(x)) ::: Someone is not awful if and only if he is not anxious.\n((¬Short(halsey))) → ((¬Awful(halbert))) ::: Halsey being not short implies that Halbert is not awful.\n((Short(roderick))) → (Fair(halsey)) ::: If Roderick is short, then Halsey is fair.\n((Educational(x))) ↔ ((¬Awful(x))) ::: If someone is educational, then he is not awful, and vice versa.\n(∃x (New(x))) → ((Educational(halsey) ∧ Fair(roderick))) ::: If there is at least one people who is new, then Halsey is educational and Roderick is fair.\n",
            "First-Order-Logic Question": "Anxious(joey) ::: Joey is anxious."
        },
        "fixed": true
    },
    {
        "id": 88,
        "raw_prog": {
            "First-Order-Logic Rules": "Fair(eli) ::: Eli is fair.\n¬Fair(shane) ::: Shane is not fair.\n¬Educational(joey) ::: Joey is not educational.\nNew(halsey) ::: Halsey is new.\nFair(aaron) ::: Aaron is fair.\n¬Anxious(eli) ::: Eli is not anxious.\nFair(joey) ::: Joey is fair.\nEducational(eli) ::: Eli is educational.\nAwful(halsey) ::: Halsey is awful.\n¬Educational(shane) ::: Shane is not educational.\nFair(halbert) ::: Halbert is fair.\nShort(halsey) ::: Halsey is short.\n(∀x (¬Awful(x))) → (∀x (¬Educational(x))) ::: All not awful people are not educational.\n(∃x (Short(x) ∧ Anxious(x))) → (Fair(halsey)) ::: If there is at least one people who is both short and anxious, then Halsey is fair.\n((¬Awful(eli))) ↔ ((Anxious(eli))) ::: If Eli is not awful, then Eli is anxious, and vice versa.\n((New(halbert) ∧ ¬Awful(eli))) → ((Anxious(halsey) ∧ ¬Fair(eli))) ::: If Halbert is new and Eli is not awful, then Halsey is anxious and Eli is not fair.\n((¬Educational(halbert) ∧ Short(roderick))) → (Awful(joey)) ::: If Halbert is not educational and Roderick is short, then Joey is awful.\n((¬New(halsey) ∨ ¬Awful(halbert))) → (¬Educational(halsey)) ::: If Halsey is not new or Halbert is not awful, then Halsey is not educational.\n(∀x (¬New(x) ∧ ¬Anxious(x))) ↔ (∀x (¬Educational(x))) ::: Someone is not new and not anxious if and only if he is not educational.\n(∀x (¬Awful(x))) ↔ (∀x (¬Anxious(x))) ::: Someone is not awful if and only if he is not anxious.\n(¬Short(halsey)) → (¬Awful(halbert)) ::: Halsey being not short implies that Halbert is not awful.\n((Short(roderick))) → (Fair(halsey)) ::: If Roderick is short, then Halsey is fair.\n((Educational(x))) ↔ ((¬Awful(x))) ::: If someone is educational, then he is not awful, and vice versa.\n(∃x (New(x))) → ((Educational(halsey) ∧ Fair(roderick)) ::: If there is at least one people who is new, then Halsey is educational and Roderick is fair.\n",
            "First-Order-Logic Question": "New(halbert) ::: Halbert is new."
        },
        "gram_prog": {
            "First-Order-Logic Rules": "Fair(eli) ::: Eli is fair.\n¬Fair(shane) ::: Shane is not fair.\n¬Educational(joey) ::: Joey is not educational.\nNew(halsey) ::: Halsey is new.\nFair(aaron) ::: Aaron is fair.\n¬Anxious(eli) ::: Eli is not anxious.\nFair(joey) ::: Joey is fair.\nEducational(eli) ::: Eli is educational.\nAwful(halsey) ::: Halsey is awful.\n¬Educational(shane) ::: Shane is not educational.\nFair(halbert) ::: Halbert is fair.\nShort(halsey) ::: Halsey is short.\n(∀x (¬Awful(x))) → (∀x (¬Educational(x))) ::: All not awful people are not educational.\n(∃x (Short(x) ∧ Anxious(x))) → (Fair(halsey)) ::: If there is at least one people who is both short and anxious, then Halsey is fair.\n((¬Awful(eli))) ↔ ((Anxious(eli))) ::: If Eli is not awful, then Eli is anxious, and vice versa.\n((New(halbert) ∧ ¬Awful(eli))) → ((Anxious(halsey) ∧ ¬Fair(eli))) ::: If Halbert is new and Eli is not awful, then Halsey is anxious and Eli is not fair.\n((¬Educational(halbert) ∧ Short(roderick))) → (Awful(joey)) ::: If Halbert is not educational and Roderick is short, then Joey is awful.\n((¬New(halsey) ∨ ¬Awful(halbert))) → (¬Educational(halsey)) ::: If Halsey is not new or Halbert is not awful, then Halsey is not educational.\n(∀x (¬New(x) ∧ ¬Anxious(x))) ↔ (∀x (¬Educational(x))) ::: Someone is not new and not anxious if and only if he is not educational.\n(∀x (¬Awful(x))) ↔ (∀x (¬Anxious(x))) ::: Someone is not awful if and only if he is not anxious.\n(¬Short(halsey)) → (¬Awful(halbert)) ::: Halsey being not short implies that Halbert is not awful.\n((Short(roderick))) → (Fair(halsey)) ::: If Roderick is short, then Halsey is fair.\n((Educational(x))) ↔ ((¬Awful(x))) ::: If someone is educational, then he is not awful, and vice versa.\n∃x((New(x))→(Educational(x))) ::: If there is at least one people who is new, then Halsey is educational and Roderick is fair.\n",
            "First-Order-Logic Question": "New(halbert) ::: Halbert is new."
        },
        "diff": [
            {
                "raw": "(∃x (New(x))) → ((Educational(halsey) ∧ Fair(roderick)) ::: If there is at least one people who is new, then Halsey is educational and Roderick is fair.",
                "gram": "∃x((New(x))→(Educational(x))) ::: If there is at least one people who is new, then Halsey is educational and Roderick is fair."
            }
        ],
        "answer": "C",
        "grammar_answer": "A",
        "manual_prog": {
            "First-Order-Logic Rules": "Fair(eli) ::: Eli is fair.\n¬Fair(shane) ::: Shane is not fair.\n¬Educational(joey) ::: Joey is not educational.\nNew(halsey) ::: Halsey is new.\nFair(aaron) ::: Aaron is fair.\n¬Anxious(eli) ::: Eli is not anxious.\nFair(joey) ::: Joey is fair.\nEducational(eli) ::: Eli is educational.\nAwful(halsey) ::: Halsey is awful.\n¬Educational(shane) ::: Shane is not educational.\nFair(halbert) ::: Halbert is fair.\nShort(halsey) ::: Halsey is short.\n(∀x (¬Awful(x))) → (∀x (¬Educational(x))) ::: All not awful people are not educational.\n(∃x (Short(x) ∧ Anxious(x))) → (Fair(halsey)) ::: If there is at least one people who is both short and anxious, then Halsey is fair.\n((¬Awful(eli))) ↔ ((Anxious(eli))) ::: If Eli is not awful, then Eli is anxious, and vice versa.\n((New(halbert) ∧ ¬Awful(eli))) → ((Anxious(halsey) ∧ ¬Fair(eli))) ::: If Halbert is new and Eli is not awful, then Halsey is anxious and Eli is not fair.\n((¬Educational(halbert) ∧ Short(roderick))) → (Awful(joey)) ::: If Halbert is not educational and Roderick is short, then Joey is awful.\n((¬New(halsey) ∨ ¬Awful(halbert))) → (¬Educational(halsey)) ::: If Halsey is not new or Halbert is not awful, then Halsey is not educational.\n(∀x (¬New(x) ∧ ¬Anxious(x))) ↔ (∀x (¬Educational(x))) ::: Someone is not new and not anxious if and only if he is not educational.\n(∀x (¬Awful(x))) ↔ (∀x (¬Anxious(x))) ::: Someone is not awful if and only if he is not anxious.\n(¬Short(halsey)) → (¬Awful(halbert)) ::: Halsey being not short implies that Halbert is not awful.\n((Short(roderick))) → (Fair(halsey)) ::: If Roderick is short, then Halsey is fair.\n((Educational(x))) ↔ ((¬Awful(x))) ::: If someone is educational, then he is not awful, and vice versa.\n(∃x (New(x))) → ((Educational(halsey) ∧ Fair(roderick))) ::: If there is at least one people who is new, then Halsey is educational and Roderick is fair.\n",
            "First-Order-Logic Question": "New(halbert) ::: Halbert is new."
        },
        "fixed": true
    },
    {
        "id": 120,
        "raw_prog": {
            "First-Order-Logic Rules": "¬Hungry(gregory) ::: Gregory is not hungry.\nMushy(ronald) ::: Ronald is mushy.\nTeak(keith) ::: Keith is teak.\nPoised(crosby) ::: Crosby is poised.\nFrank(shane) ::: Shane is frank.\nPoised(gregory) ::: Gregory is poised.\n¬Poised(shane) ::: Shane is not poised.\nMushy(keith) ::: Keith is mushy.\n¬Frank(noel) ::: Noel is not frank.\nFrank(george) ::: George is frank.\nWicked(george) ::: George is wicked.\nFrank(keith) ::: Keith is frank.\n((Mushy(x) ∨ ¬Poised(x))) → ((Hungry(x) ∧ ¬Wicked(x))) ::: If someone is either mushy or not poised, then he is hungry and not wicked.\n((¬Poised(gregory))) → ((Mushy(shane))) ::: If Gregory is not poised, then Shane is mushy.\n(∃x (Wicked(x))) → ((¬Poised(shane) ∧ ¬Frank(george))) ::: If there is at least one people who is wicked, then Shane is not poised and George is not frank.\n((Teak(noel))) ↔ ((¬Poised(noel))) ::: If Noel is teak, then Noel is not poised, and vice versa.\n(¬∃x (¬x)) → ((Teak(shane) ∧ ¬Poised(shane))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised.\n((Wicked(x) ∧ Mushy(x))) ↔ ((Poised(x))) ::: Someone is wicked and mushy if and only if he is poised.\n(∃x (Poised(x) ∨ ¬Hungry(x))) → ((¬Mushy(george))) ::: If there is at least one people who is poised or not hungry, then George is not mushy.\n(∃x (Wicked(x) ∧ ¬Teak(x))) → ((Poised(crosby))) ::: If there is at least one people who is both wicked and not teak, then Crosby is poised.\n((Teak(keith))) ↔ ((¬Poised(gregory) ∧ ¬Wicked(noel))) ::: Keith is teak if and only if Gregory is not poised and Noel is not wicked.\n((Teak(noel))) ↔ ((Hungry(shane))) ::: Noel is teak if and only if Shane is hungry.\n((¬Teak(gregory) ∧ Wicked(crosby))) → ((¬Mushy(keith))) ::: If Gregory is not teak and Crosby is wicked, then Keith is not mushy.\n(∃x (Hungry(x) ∧ Wicked(x))) → ((Teak(noel))) ::: If there is at least one people who is both hungry and wicked, then Noel is teak.\n",
            "First-Order-Logic Question": "¬Mushy(noel) ::: Noel is not mushy."
        },
        "gram_prog": {
            "First-Order-Logic Rules": "¬Hungry(gregory) ::: Gregory is not hungry.\nMushy(ronald) ::: Ronald is mushy.\nTeak(keith) ::: Keith is teak.\nPoised(crosby) ::: Crosby is poised.\nFrank(shane) ::: Shane is frank.\nPoised(gregory) ::: Gregory is poised.\n¬Poised(shane) ::: Shane is not poised.\nMushy(keith) ::: Keith is mushy.\n¬Frank(noel) ::: Noel is not frank.\nFrank(george) ::: George is frank.\nWicked(george) ::: George is wicked.\nFrank(keith) ::: Keith is frank.\n((Mushy(x) ∨ ¬Poised(x))) → ((Hungry(x) ∧ ¬Wicked(x))) ::: If someone is either mushy or not poised, then he is hungry and not wicked.\n((¬Poised(gregory))) → ((Mushy(shane))) ::: If Gregory is not poised, then Shane is mushy.\n(∃x (Wicked(x))) → ((¬Poised(shane) ∧ ¬Frank(george))) ::: If there is at least one people who is wicked, then Shane is not poised and George is not frank.\n((Teak(noel))) ↔ ((¬Poised(noel))) ::: If Noel is teak, then Noel is not poised, and vice versa.\n¬∃x((¬(¬Frank(x)))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised.\n((Wicked(x) ∧ Mushy(x))) ↔ ((Poised(x))) ::: Someone is wicked and mushy if and only if he is poised.\n(∃x (Poised(x) ∨ ¬Hungry(x))) → ((¬Mushy(george))) ::: If there is at least one people who is poised or not hungry, then George is not mushy.\n(∃x (Wicked(x) ∧ ¬Teak(x))) → ((Poised(crosby))) ::: If there is at least one people who is both wicked and not teak, then Crosby is poised.\n((Teak(keith))) ↔ ((¬Poised(gregory) ∧ ¬Wicked(noel))) ::: Keith is teak if and only if Gregory is not poised and Noel is not wicked.\n((Teak(noel))) ↔ ((Hungry(shane))) ::: Noel is teak if and only if Shane is hungry.\n((¬Teak(gregory) ∧ Wicked(crosby))) → ((¬Mushy(keith))) ::: If Gregory is not teak and Crosby is wicked, then Keith is not mushy.\n(∃x (Hungry(x) ∧ Wicked(x))) → ((Teak(noel))) ::: If there is at least one people who is both hungry and wicked, then Noel is teak.\n",
            "First-Order-Logic Question": "¬Mushy(noel) ::: Noel is not mushy."
        },
        "diff": [
            {
                "raw": "(¬∃x (¬x)) → ((Teak(shane) ∧ ¬Poised(shane))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised.",
                "gram": "¬∃x((¬(¬Frank(x)))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised."
            }
        ],
        "answer": "C",
        "grammar_answer": "A",
        "manual_prog": {
            "First-Order-Logic Rules": "¬Hungry(gregory) ::: Gregory is not hungry.\nMushy(ronald) ::: Ronald is mushy.\nTeak(keith) ::: Keith is teak.\nPoised(crosby) ::: Crosby is poised.\nFrank(shane) ::: Shane is frank.\nPoised(gregory) ::: Gregory is poised.\n¬Poised(shane) ::: Shane is not poised.\nMushy(keith) ::: Keith is mushy.\n¬Frank(noel) ::: Noel is not frank.\nFrank(george) ::: George is frank.\nWicked(george) ::: George is wicked.\nFrank(keith) ::: Keith is frank.\n((Mushy(x) ∨ ¬Poised(x))) → ((Hungry(x) ∧ ¬Wicked(x))) ::: If someone is either mushy or not poised, then he is hungry and not wicked.\n((¬Poised(gregory))) → ((Mushy(shane))) ::: If Gregory is not poised, then Shane is mushy.\n(∃x (Wicked(x))) → ((¬Poised(shane) ∧ ¬Frank(george))) ::: If there is at least one people who is wicked, then Shane is not poised and George is not frank.\n((Teak(noel))) ↔ ((¬Poised(noel))) ::: If Noel is teak, then Noel is not poised, and vice versa.\n∃x (¬Not(x)) → (Teak(shane) ∧ ¬Poised(shane)) ::: If there is nobody who is not, then Shane is teak and Shane is not poised.\n((Wicked(x) ∧ Mushy(x))) ↔ ((Poised(x))) ::: Someone is wicked and mushy if and only if he is poised.\n(∃x (Poised(x) ∨ ¬Hungry(x))) → ((¬Mushy(george))) ::: If there is at least one people who is poised or not hungry, then George is not mushy.\n(∃x (Wicked(x) ∧ ¬Teak(x))) → ((Poised(crosby))) ::: If there is at least one people who is both wicked and not teak, then Crosby is poised.\n((Teak(keith))) ↔ ((¬Poised(gregory) ∧ ¬Wicked(noel))) ::: Keith is teak if and only if Gregory is not poised and Noel is not wicked.\n((Teak(noel))) ↔ ((Hungry(shane))) ::: Noel is teak if and only if Shane is hungry.\n((¬Teak(gregory) ∧ Wicked(crosby))) → ((¬Mushy(keith))) ::: If Gregory is not teak and Crosby is wicked, then Keith is not mushy.\n(∃x (Hungry(x) ∧ Wicked(x))) → ((Teak(noel))) ::: If there is at least one people who is both hungry and wicked, then Noel is teak.\n",
            "First-Order-Logic Question": "¬Mushy(noel) ::: Noel is not mushy."
        },
        "fixed": true
    },
    {
        "id": 121,
        "raw_prog": {
            "First-Order-Logic Rules": "¬Hungry(gregory) ::: Gregory is not hungry.\nMushy(ronald) ::: Ronald is mushy.\nTeak(keith) ::: Keith is teak.\nPoised(crosby) ::: Crosby is poised.\nFrank(shane) ::: Shane is frank.\nPoised(gregory) ::: Gregory is poised.\n¬Poised(shane) ::: Shane is not poised.\nMushy(keith) ::: Keith is mushy.\n¬Frank(noel) ::: Noel is not frank.\nFrank(george) ::: George is frank.\nWicked(george) ::: George is wicked.\nFrank(keith) ::: Keith is frank.\n((Mushy(x) ∨ ¬Poised(x))) → ((Hungry(x) ∧ ¬Wicked(x))) ::: If someone is either mushy or not poised, then he is hungry and not wicked.\n((¬Poised(gregory))) → ((Mushy(shane))) ::: If Gregory is not poised, then Shane is mushy.\n(∃x (Wicked(x))) → ((¬Poised(shane) ∧ ¬Frank(george))) ::: If there is at least one people who is wicked, then Shane is not poised and George is not frank.\n((Teak(noel))) ↔ ((¬Poised(noel))) ::: If Noel is teak, then Noel is not poised, and vice versa.\n(¬∃x (¬Entire(x))) → ((Teak(shane) ∧ ¬Poised(shane))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised.\n((Poised(x) ∧ Mushy(x))) ↔ ((Wicked(x))) ::: Someone is wicked and mushy if and only if he is poised.\n(∃x (Poised(x) ∨ ¬Hungry(x))) → ((¬Mushy(george))) ::: If there is at least one people who is poised or not hungry, then George is not mushy.\n(∃x (Wicked(x) ∧ ¬Teak(x))) → ((Poised(crosby))) ::: If there is at least one people who is both wicked and not teak, then Crosby is poised.\n((Teak(keith))) ↔ ((¬Poised(gregory) ∧ ¬Wicked(noel))) ::: Keith is teak if and only if Gregory is not poised and Noel is not wicked.\n((Teak(noel))) ↔ ((Hungry(shane))) ::: Noel is teak if and only if Shane is hungry.\n((¬Teak(gregory) ∧ Wicked(crosby))) → ((¬Mushy(keith))) ::: If Gregory is not teak and Crosby is wicked, then Keith is not mushy.\n(∃x (Hungry(x) ∧ Wicked(x))) → ((Teak(noel))) ::: If there is at least one people who is both hungry and wicked, then Noel is teak.\n",
            "First-Order-Logic Question": "¬Mushy(shane) ::: Shane is not mushy."
        },
        "gram_prog": {
            "First-Order-Logic Rules": "¬Hungry(gregory) ::: Gregory is not hungry.\nMushy(ronald) ::: Ronald is mushy.\nTeak(keith) ::: Keith is teak.\nPoised(crosby) ::: Crosby is poised.\nFrank(shane) ::: Shane is frank.\nPoised(gregory) ::: Gregory is poised.\n¬Poised(shane) ::: Shane is not poised.\nMushy(keith) ::: Keith is mushy.\n¬Frank(noel) ::: Noel is not frank.\nFrank(george) ::: George is frank.\nWicked(george) ::: George is wicked.\nFrank(keith) ::: Keith is frank.\n((Mushy(x) ∨ ¬Poised(x))) → ((Hungry(x) ∧ ¬Wicked(x))) ::: If someone is either mushy or not poised, then he is hungry and not wicked.\n((¬Poised(gregory))) → ((Mushy(shane))) ::: If Gregory is not poised, then Shane is mushy.\n(∃x (Wicked(x))) → ((¬Poised(shane) ∧ ¬Frank(george))) ::: If there is at least one people who is wicked, then Shane is not poised and George is not frank.\n((Teak(noel))) ↔ ((¬Poised(noel))) ::: If Noel is teak, then Noel is not poised, and vice versa.\n¬∃x(¬Entire(x))→((Serious(x))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised.\n((Poised(x) ∧ Mushy(x))) ↔ ((Wicked(x))) ::: Someone is wicked and mushy if and only if he is poised.\n(∃x (Poised(x) ∨ ¬Hungry(x))) → ((¬Mushy(george))) ::: If there is at least one people who is poised or not hungry, then George is not mushy.\n(∃x (Wicked(x) ∧ ¬Teak(x))) → ((Poised(crosby))) ::: If there is at least one people who is both wicked and not teak, then Crosby is poised.\n((Teak(keith))) ↔ ((¬Poised(gregory) ∧ ¬Wicked(noel))) ::: Keith is teak if and only if Gregory is not poised and Noel is not wicked.\n((Teak(noel))) ↔ ((Hungry(shane))) ::: Noel is teak if and only if Shane is hungry.\n((¬Teak(gregory) ∧ Wicked(crosby))) → ((¬Mushy(keith))) ::: If Gregory is not teak and Crosby is wicked, then Keith is not mushy.\n(∃x (Hungry(x) ∧ Wicked(x))) → ((Teak(noel))) ::: If there is at least one people who is both hungry and wicked, then Noel is teak.\n",
            "First-Order-Logic Question": "¬Mushy(shane) ::: Shane is not mushy."
        },
        "diff": [
            {
                "raw": "(¬∃x (¬Entire(x))) → ((Teak(shane) ∧ ¬Poised(shane))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised.",
                "gram": "¬∃x(¬Entire(x))→((Serious(x))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised."
            }
        ],
        "answer": "B",
        "grammar_answer": "A",
        "manual_prog": {
            "First-Order-Logic Rules": "¬Hungry(gregory) ::: Gregory is not hungry.\nMushy(ronald) ::: Ronald is mushy.\nTeak(keith) ::: Keith is teak.\nPoised(crosby) ::: Crosby is poised.\nFrank(shane) ::: Shane is frank.\nPoised(gregory) ::: Gregory is poised.\n¬Poised(shane) ::: Shane is not poised.\nMushy(keith) ::: Keith is mushy.\n¬Frank(noel) ::: Noel is not frank.\nFrank(george) ::: George is frank.\nWicked(george) ::: George is wicked.\nFrank(keith) ::: Keith is frank.\n((Mushy(x) ∨ ¬Poised(x))) → ((Hungry(x) ∧ ¬Wicked(x))) ::: If someone is either mushy or not poised, then he is hungry and not wicked.\n((¬Poised(gregory))) → ((Mushy(shane))) ::: If Gregory is not poised, then Shane is mushy.\n(∃x (Wicked(x))) → ((¬Poised(shane) ∧ ¬Frank(george))) ::: If there is at least one people who is wicked, then Shane is not poised and George is not frank.\n((Teak(noel))) ↔ ((¬Poised(noel))) ::: If Noel is teak, then Noel is not poised, and vice versa.\n(∃x ¬(¬Entire(x))) → ((Teak(shane) ∧ ¬Poised(shane))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised.\n((Poised(x) ∧ Mushy(x))) ↔ ((Wicked(x))) ::: Someone is wicked and mushy if and only if he is poised.\n(∃x (Poised(x) ∨ ¬Hungry(x))) → ((¬Mushy(george))) ::: If there is at least one people who is poised or not hungry, then George is not mushy.\n(∃x (Wicked(x) ∧ ¬Teak(x))) → ((Poised(crosby))) ::: If there is at least one people who is both wicked and not teak, then Crosby is poised.\n((Teak(keith))) ↔ ((¬Poised(gregory) ∧ ¬Wicked(noel))) ::: Keith is teak if and only if Gregory is not poised and Noel is not wicked.\n((Teak(noel))) ↔ ((Hungry(shane))) ::: Noel is teak if and only if Shane is hungry.\n((¬Teak(gregory) ∧ Wicked(crosby))) → ((¬Mushy(keith))) ::: If Gregory is not teak and Crosby is wicked, then Keith is not mushy.\n(∃x (Hungry(x) ∧ Wicked(x))) → ((Teak(noel))) ::: If there is at least one people who is both hungry and wicked, then Noel is teak.\n",
            "First-Order-Logic Question": "¬Mushy(shane) ::: Shane is not mushy."
        },
        "fixed": true
    },
    {
        "id": 124,
        "raw_prog": {
            "First-Order-Logic Rules": "¬Hungry(gregory) ::: Gregory is not hungry.\nMushy(ronald) ::: Ronald is mushy.\nTeak(keith) ::: Keith is teak.\nPoised(crosby) ::: Crosby is poised.\nFrank(shane) ::: Shane is frank.\nPoised(gregory) ::: Gregory is poised.\n¬Poised(shane) ::: Shane is not poised.\nMushy(keith) ::: Keith is mushy.\n¬Frank(noel) ::: Noel is not frank.\nFrank(george) ::: George is frank.\nWicked(george) ::: George is wicked.\nFrank(keith) ::: Keith is frank.\n((Mushy(x) ∨ ¬Poised(x))) → ((Hungry(x) ∧ ¬Wicked(x))) ::: If someone is either mushy or not poised, then he is hungry and not wicked.\n((¬Poised(gregory))) → ((Mushy(shane))) ::: If Gregory is not poised, then Shane is mushy.\n(∃x (Wicked(x))) → ((¬Poised(shane) ∧ ¬Frank(george))) ::: If there is at least one people who is wicked, then Shane is not poised and George is not frank.\n((Teak(noel))) ↔ ((¬Poised(noel))) ::: If Noel is teak, then Noel is not poised, and vice versa.\n(¬∃x (¬x)) → ((Teak(shane) ∧ ¬Poised(shane))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised.\n((Poised(x) ∧ Mushy(x))) ↔ ((Poised(x))) ::: Someone is wicked and mushy if and only if he is poised.\n(∃x (Poised(x) ∨ ¬Hungry(x))) → ((¬Mushy(george))) ::: If there is at least one people who is poised or not hungry, then George is not mushy.\n(∃x (Wicked(x) ∧ ¬Teak(x))) → ((Poised(crosby))) ::: If there is at least one people who is both wicked and not teak, then Crosby is poised.\n((Teak(keith))) ↔ ((¬Poised(gregory) ∧ ¬Wicked(noel))) ::: Keith is teak if and only if Gregory is not poised and Noel is not wicked.\n((Teak(noel))) ↔ ((Hungry(shane))) ::: Noel is teak if and only if Shane is hungry.\n((¬Teak(gregory) ∧ Wicked(crosby))) → ((¬Mushy(keith))) ::: If Gregory is not teak and Crosby is wicked, then Keith is not mushy.\n(∃x (Hungry(x) ∧ Wicked(x))) → ((Teak(noel))) ::: If there is at least one people who is both hungry and wicked, then Noel is teak.\n",
            "First-Order-Logic Question": "¬Hungry(shane) ::: Shane is not hungry."
        },
        "gram_prog": {
            "First-Order-Logic Rules": "¬Hungry(gregory) ::: Gregory is not hungry.\nMushy(ronald) ::: Ronald is mushy.\nTeak(keith) ::: Keith is teak.\nPoised(crosby) ::: Crosby is poised.\nFrank(shane) ::: Shane is frank.\nPoised(gregory) ::: Gregory is poised.\n¬Poised(shane) ::: Shane is not poised.\nMushy(keith) ::: Keith is mushy.\n¬Frank(noel) ::: Noel is not frank.\nFrank(george) ::: George is frank.\nWicked(george) ::: George is wicked.\nFrank(keith) ::: Keith is frank.\n((Mushy(x) ∨ ¬Poised(x))) → ((Hungry(x) ∧ ¬Wicked(x))) ::: If someone is either mushy or not poised, then he is hungry and not wicked.\n((¬Poised(gregory))) → ((Mushy(shane))) ::: If Gregory is not poised, then Shane is mushy.\n(∃x (Wicked(x))) → ((¬Poised(shane) ∧ ¬Frank(george))) ::: If there is at least one people who is wicked, then Shane is not poised and George is not frank.\n((Teak(noel))) ↔ ((¬Poised(noel))) ::: If Noel is teak, then Noel is not poised, and vice versa.\n¬∃x((¬(¬Frank(x)))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised.\n((Poised(x) ∧ Mushy(x))) ↔ ((Poised(x))) ::: Someone is wicked and mushy if and only if he is poised.\n(∃x (Poised(x) ∨ ¬Hungry(x))) → ((¬Mushy(george))) ::: If there is at least one people who is poised or not hungry, then George is not mushy.\n(∃x (Wicked(x) ∧ ¬Teak(x))) → ((Poised(crosby))) ::: If there is at least one people who is both wicked and not teak, then Crosby is poised.\n((Teak(keith))) ↔ ((¬Poised(gregory) ∧ ¬Wicked(noel))) ::: Keith is teak if and only if Gregory is not poised and Noel is not wicked.\n((Teak(noel))) ↔ ((Hungry(shane))) ::: Noel is teak if and only if Shane is hungry.\n((¬Teak(gregory) ∧ Wicked(crosby))) → ((¬Mushy(keith))) ::: If Gregory is not teak and Crosby is wicked, then Keith is not mushy.\n(∃x (Hungry(x) ∧ Wicked(x))) → ((Teak(noel))) ::: If there is at least one people who is both hungry and wicked, then Noel is teak.\n",
            "First-Order-Logic Question": "¬Hungry(shane) ::: Shane is not hungry."
        },
        "diff": [
            {
                "raw": "(¬∃x (¬x)) → ((Teak(shane) ∧ ¬Poised(shane))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised.",
                "gram": "¬∃x((¬(¬Frank(x)))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised."
            }
        ],
        "answer": "B",
        "grammar_answer": "A",
        "manual_prog": {
            "First-Order-Logic Rules": "¬Hungry(gregory) ::: Gregory is not hungry.\nMushy(ronald) ::: Ronald is mushy.\nTeak(keith) ::: Keith is teak.\nPoised(crosby) ::: Crosby is poised.\nFrank(shane) ::: Shane is frank.\nPoised(gregory) ::: Gregory is poised.\n¬Poised(shane) ::: Shane is not poised.\nMushy(keith) ::: Keith is mushy.\n¬Frank(noel) ::: Noel is not frank.\nFrank(george) ::: George is frank.\nWicked(george) ::: George is wicked.\nFrank(keith) ::: Keith is frank.\n((Mushy(x) ∨ ¬Poised(x))) → ((Hungry(x) ∧ ¬Wicked(x))) ::: If someone is either mushy or not poised, then he is hungry and not wicked.\n((¬Poised(gregory))) → ((Mushy(shane))) ::: If Gregory is not poised, then Shane is mushy.\n(∃x (Wicked(x))) → ((¬Poised(shane) ∧ ¬Frank(george))) ::: If there is at least one people who is wicked, then Shane is not poised and George is not frank.\n((Teak(noel))) ↔ ((¬Poised(noel))) ::: If Noel is teak, then Noel is not poised, and vice versa.\n∃x (¬Not(x)) → (Teak(shane) ∧ ¬Poised(shane)) ::: If there is nobody who is not, then Shane is teak and Shane is not poised.\n((Poised(x) ∧ Mushy(x))) ↔ ((Poised(x))) ::: Someone is wicked and mushy if and only if he is poised.\n(∃x (Poised(x) ∨ ¬Hungry(x))) → ((¬Mushy(george))) ::: If there is at least one people who is poised or not hungry, then George is not mushy.\n(∃x (Wicked(x) ∧ ¬Teak(x))) → ((Poised(crosby))) ::: If there is at least one people who is both wicked and not teak, then Crosby is poised.\n((Teak(keith))) ↔ ((¬Poised(gregory) ∧ ¬Wicked(noel))) ::: Keith is teak if and only if Gregory is not poised and Noel is not wicked.\n((Teak(noel))) ↔ ((Hungry(shane))) ::: Noel is teak if and only if Shane is hungry.\n((¬Teak(gregory) ∧ Wicked(crosby))) → ((¬Mushy(keith))) ::: If Gregory is not teak and Crosby is wicked, then Keith is not mushy.\n(∃x (Hungry(x) ∧ Wicked(x))) → ((Teak(noel))) ::: If there is at least one people who is both hungry and wicked, then Noel is teak.\n",
            "First-Order-Logic Question": "¬Hungry(shane) ::: Shane is not hungry."
        },
        "fixed": true
    },
    {
        "id": 125,
        "raw_prog": {
            "First-Order-Logic Rules": "¬Hungry(gregory) ::: Gregory is not hungry.\nMushy(ronald) ::: Ronald is mushy.\nTeak(keith) ::: Keith is teak.\nPoised(crosby) ::: Crosby is poised.\nFrank(shane) ::: Shane is frank.\nPoised(gregory) ::: Gregory is poised.\n¬Poised(shane) ::: Shane is not poised.\nMushy(keith) ::: Keith is mushy.\n¬Frank(noel) ::: Noel is not frank.\nFrank(george) ::: George is frank.\nWicked(george) ::: George is wicked.\nFrank(keith) ::: Keith is frank.\n((Mushy(x) ∨ ¬Poised(x))) → ((Hungry(x) ∧ ¬Wicked(x))) ::: If someone is either mushy or not poised, then he is hungry and not wicked.\n((¬Poised(gregory))) → ((Mushy(shane))) ::: If Gregory is not poised, then Shane is mushy.\n(∃x (Wicked(x))) → ((¬Poised(shane) ∧ ¬Frank(george))) ::: If there is at least one people who is wicked, then Shane is not poised and George is not frank.\n((Teak(noel))) ↔ ((¬Poised(noel))) ::: If Noel is teak, then Noel is not poised, and vice versa.\n(¬∃x (¬x)) → ((Teak(shane) ∧ ¬Poised(shane))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised.\n((Poised(x) ∧ Mushy(x))) ↔ ((Wicked(x))) ::: Someone is wicked and mushy if and only if he is poised.\n(∃x (Poised(x) ∨ ¬Hungry(x))) → ((¬Mushy(george))) ::: If there is at least one people who is poised or not hungry, then George is not mushy.\n(∃x (Wicked(x) ∧ ¬Teak(x))) → ((Poised(crosby))) ::: If there is at least one people who is both wicked and not teak, then Crosby is poised.\n((Teak(keith))) ↔ ((¬Poised(gregory) ∧ ¬Wicked(noel))) ::: Keith is teak if and only if Gregory is not poised and Noel is not wicked.\n((Teak(noel))) ↔ ((Hungry(shane))) ::: Noel is teak if and only if Shane is hungry.\n((¬Teak(gregory) ∧ Wicked(crosby))) → ((¬Mushy(keith))) ::: If Gregory is not teak and Crosby is wicked, then Keith is not mushy.\n(∃x (Hungry(x) ∧ Wicked(x))) → ((Teak(noel))) ::: If there is at least one people who is both hungry and wicked, then Noel is teak.\n",
            "First-Order-Logic Question": "Mushy(noel) ::: Noel is mushy."
        },
        "gram_prog": {
            "First-Order-Logic Rules": "¬Hungry(gregory) ::: Gregory is not hungry.\nMushy(ronald) ::: Ronald is mushy.\nTeak(keith) ::: Keith is teak.\nPoised(crosby) ::: Crosby is poised.\nFrank(shane) ::: Shane is frank.\nPoised(gregory) ::: Gregory is poised.\n¬Poised(shane) ::: Shane is not poised.\nMushy(keith) ::: Keith is mushy.\n¬Frank(noel) ::: Noel is not frank.\nFrank(george) ::: George is frank.\nWicked(george) ::: George is wicked.\nFrank(keith) ::: Keith is frank.\n((Mushy(x) ∨ ¬Poised(x))) → ((Hungry(x) ∧ ¬Wicked(x))) ::: If someone is either mushy or not poised, then he is hungry and not wicked.\n((¬Poised(gregory))) → ((Mushy(shane))) ::: If Gregory is not poised, then Shane is mushy.\n(∃x (Wicked(x))) → ((¬Poised(shane) ∧ ¬Frank(george))) ::: If there is at least one people who is wicked, then Shane is not poised and George is not frank.\n((Teak(noel))) ↔ ((¬Poised(noel))) ::: If Noel is teak, then Noel is not poised, and vice versa.\n¬∃x((¬(¬Fresh(x)))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised.\n((Poised(x) ∧ Mushy(x))) ↔ ((Wicked(x))) ::: Someone is wicked and mushy if and only if he is poised.\n(∃x (Poised(x) ∨ ¬Hungry(x))) → ((¬Mushy(george))) ::: If there is at least one people who is poised or not hungry, then George is not mushy.\n(∃x (Wicked(x) ∧ ¬Teak(x))) → ((Poised(crosby))) ::: If there is at least one people who is both wicked and not teak, then Crosby is poised.\n((Teak(keith))) ↔ ((¬Poised(gregory) ∧ ¬Wicked(noel))) ::: Keith is teak if and only if Gregory is not poised and Noel is not wicked.\n((Teak(noel))) ↔ ((Hungry(shane))) ::: Noel is teak if and only if Shane is hungry.\n((¬Teak(gregory) ∧ Wicked(crosby))) → ((¬Mushy(keith))) ::: If Gregory is not teak and Crosby is wicked, then Keith is not mushy.\n(∃x (Hungry(x) ∧ Wicked(x))) → ((Teak(noel))) ::: If there is at least one people who is both hungry and wicked, then Noel is teak.\n",
            "First-Order-Logic Question": "Mushy(noel) ::: Noel is mushy."
        },
        "diff": [
            {
                "raw": "(¬∃x (¬x)) → ((Teak(shane) ∧ ¬Poised(shane))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised.",
                "gram": "¬∃x((¬(¬Fresh(x)))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised."
            }
        ],
        "answer": "C",
        "grammar_answer": "A",
        "manual_prog": {
            "First-Order-Logic Rules": "¬Hungry(gregory) ::: Gregory is not hungry.\nMushy(ronald) ::: Ronald is mushy.\nTeak(keith) ::: Keith is teak.\nPoised(crosby) ::: Crosby is poised.\nFrank(shane) ::: Shane is frank.\nPoised(gregory) ::: Gregory is poised.\n¬Poised(shane) ::: Shane is not poised.\nMushy(keith) ::: Keith is mushy.\n¬Frank(noel) ::: Noel is not frank.\nFrank(george) ::: George is frank.\nWicked(george) ::: George is wicked.\nFrank(keith) ::: Keith is frank.\n((Mushy(x) ∨ ¬Poised(x))) → ((Hungry(x) ∧ ¬Wicked(x))) ::: If someone is either mushy or not poised, then he is hungry and not wicked.\n((¬Poised(gregory))) → ((Mushy(shane))) ::: If Gregory is not poised, then Shane is mushy.\n(∃x (Wicked(x))) → ((¬Poised(shane) ∧ ¬Frank(george))) ::: If there is at least one people who is wicked, then Shane is not poised and George is not frank.\n((Teak(noel))) ↔ ((¬Poised(noel))) ::: If Noel is teak, then Noel is not poised, and vice versa.\n∃x (¬Not(x)) → (Teak(shane) ∧ ¬Poised(shane)) ::: If there is nobody who is not, then Shane is teak and Shane is not poised.\n((Poised(x) ∧ Mushy(x))) ↔ ((Wicked(x))) ::: Someone is wicked and mushy if and only if he is poised.\n(∃x (Poised(x) ∨ ¬Hungry(x))) → ((¬Mushy(george))) ::: If there is at least one people who is poised or not hungry, then George is not mushy.\n(∃x (Wicked(x) ∧ ¬Teak(x))) → ((Poised(crosby))) ::: If there is at least one people who is both wicked and not teak, then Crosby is poised.\n((Teak(keith))) ↔ ((¬Poised(gregory) ∧ ¬Wicked(noel))) ::: Keith is teak if and only if Gregory is not poised and Noel is not wicked.\n((Teak(noel))) ↔ ((Hungry(shane))) ::: Noel is teak if and only if Shane is hungry.\n((¬Teak(gregory) ∧ Wicked(crosby))) → ((¬Mushy(keith))) ::: If Gregory is not teak and Crosby is wicked, then Keith is not mushy.\n(∃x (Hungry(x) ∧ Wicked(x))) → ((Teak(noel))) ::: If there is at least one people who is both hungry and wicked, then Noel is teak.\n",
            "First-Order-Logic Question": "Mushy(noel) ::: Noel is mushy."
        },
        "fixed": true
    },
    {
        "id": 127,
        "raw_prog": {
            "First-Order-Logic Rules": "¬Hungry(gregory) ::: Gregory is not hungry.\nMushy(ronald) ::: Ronald is mushy.\nTeak(keith) ::: Keith is teak.\nPoised(crosby) ::: Crosby is poised.\nFrank(shane) ::: Shane is frank.\nPoised(gregory) ::: Gregory is poised.\n¬Poised(shane) ::: Shane is not poised.\nMushy(keith) ::: Keith is mushy.\n¬Frank(noel) ::: Noel is not frank.\nFrank(george) ::: George is frank.\nWicked(george) ::: George is wicked.\nFrank(keith) ::: Keith is frank.\n((Mushy(x) ∨ ¬Poised(x))) → ((Hungry(x) ∧ ¬Wicked(x))) ::: If someone is either mushy or not poised, then he is hungry and not wicked.\n((¬Poised(gregory))) → ((Mushy(shane))) ::: If Gregory is not poised, then Shane is mushy.\n(∃x (Wicked(x))) → ((¬Poised(shane) ∧ ¬Frank(george))) ::: If there is at least one people who is wicked, then Shane is not poised and George is not frank.\n((Teak(noel))) ↔ ((¬Poised(noel))) ::: If Noel is teak, then Noel is not poised, and vice versa.\n(¬∃x (¬x)) → ((Teak(shane) ∧ ¬Poised(shane))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised.\n((Wicked(x) ∧ Mushy(x))) ↔ ((Poised(x))) ::: Someone is wicked and mushy if and only if he is poised.\n(∃x (Poised(x) ∨ ¬Hungry(x))) → ((¬Mushy(george))) ::: If there is at least one people who is poised or not hungry, then George is not mushy.\n(∃x (Wicked(x) ∧ ¬Teak(x))) → ((Poised(crosby))) ::: If there is at least one people who is both wicked and not teak, then Crosby is poised.\n((Teak(keith))) ↔ ((¬Poised(gregory) ∧ ¬Wicked(noel))) ::: Keith is teak if and only if Gregory is not poised and Noel is not wicked.\n((Teak(noel))) ↔ ((Hungry(shane))) ::: Noel is teak if and only if Shane is hungry.\n((¬Teak(gregory) ∧ Wicked(crosby))) → ((¬Mushy(keith))) ::: If Gregory is not teak and Crosby is wicked, then Keith is not mushy.\n(∃x (Hungry(x) ∧ Wicked(x))) → ((Teak(noel))) ::: If there is at least one people who is both hungry and wicked, then Noel is teak.\n",
            "First-Order-Logic Question": "¬Teak(ronald) ::: Ronald is not teak."
        },
        "gram_prog": {
            "First-Order-Logic Rules": "¬Hungry(gregory) ::: Gregory is not hungry.\nMushy(ronald) ::: Ronald is mushy.\nTeak(keith) ::: Keith is teak.\nPoised(crosby) ::: Crosby is poised.\nFrank(shane) ::: Shane is frank.\nPoised(gregory) ::: Gregory is poised.\n¬Poised(shane) ::: Shane is not poised.\nMushy(keith) ::: Keith is mushy.\n¬Frank(noel) ::: Noel is not frank.\nFrank(george) ::: George is frank.\nWicked(george) ::: George is wicked.\nFrank(keith) ::: Keith is frank.\n((Mushy(x) ∨ ¬Poised(x))) → ((Hungry(x) ∧ ¬Wicked(x))) ::: If someone is either mushy or not poised, then he is hungry and not wicked.\n((¬Poised(gregory))) → ((Mushy(shane))) ::: If Gregory is not poised, then Shane is mushy.\n(∃x (Wicked(x))) → ((¬Poised(shane) ∧ ¬Frank(george))) ::: If there is at least one people who is wicked, then Shane is not poised and George is not frank.\n((Teak(noel))) ↔ ((¬Poised(noel))) ::: If Noel is teak, then Noel is not poised, and vice versa.\n¬∃x((¬(¬Fresh(x)))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised.\n((Wicked(x) ∧ Mushy(x))) ↔ ((Poised(x))) ::: Someone is wicked and mushy if and only if he is poised.\n(∃x (Poised(x) ∨ ¬Hungry(x))) → ((¬Mushy(george))) ::: If there is at least one people who is poised or not hungry, then George is not mushy.\n(∃x (Wicked(x) ∧ ¬Teak(x))) → ((Poised(crosby))) ::: If there is at least one people who is both wicked and not teak, then Crosby is poised.\n((Teak(keith))) ↔ ((¬Poised(gregory) ∧ ¬Wicked(noel))) ::: Keith is teak if and only if Gregory is not poised and Noel is not wicked.\n((Teak(noel))) ↔ ((Hungry(shane))) ::: Noel is teak if and only if Shane is hungry.\n((¬Teak(gregory) ∧ Wicked(crosby))) → ((¬Mushy(keith))) ::: If Gregory is not teak and Crosby is wicked, then Keith is not mushy.\n(∃x (Hungry(x) ∧ Wicked(x))) → ((Teak(noel))) ::: If there is at least one people who is both hungry and wicked, then Noel is teak.\n",
            "First-Order-Logic Question": "¬Teak(ronald) ::: Ronald is not teak."
        },
        "diff": [
            {
                "raw": "(¬∃x (¬x)) → ((Teak(shane) ∧ ¬Poised(shane))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised.",
                "gram": "¬∃x((¬(¬Fresh(x)))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised."
            }
        ],
        "answer": "C",
        "grammar_answer": "A",
        "manual_prog": {
            "First-Order-Logic Rules": "¬Hungry(gregory) ::: Gregory is not hungry.\nMushy(ronald) ::: Ronald is mushy.\nTeak(keith) ::: Keith is teak.\nPoised(crosby) ::: Crosby is poised.\nFrank(shane) ::: Shane is frank.\nPoised(gregory) ::: Gregory is poised.\n¬Poised(shane) ::: Shane is not poised.\nMushy(keith) ::: Keith is mushy.\n¬Frank(noel) ::: Noel is not frank.\nFrank(george) ::: George is frank.\nWicked(george) ::: George is wicked.\nFrank(keith) ::: Keith is frank.\n((Mushy(x) ∨ ¬Poised(x))) → ((Hungry(x) ∧ ¬Wicked(x))) ::: If someone is either mushy or not poised, then he is hungry and not wicked.\n((¬Poised(gregory))) → ((Mushy(shane))) ::: If Gregory is not poised, then Shane is mushy.\n(∃x (Wicked(x))) → ((¬Poised(shane) ∧ ¬Frank(george))) ::: If there is at least one people who is wicked, then Shane is not poised and George is not frank.\n((Teak(noel))) ↔ ((¬Poised(noel))) ::: If Noel is teak, then Noel is not poised, and vice versa.\n∃x (¬Not(x)) → (Teak(shane) ∧ ¬Poised(shane)) ::: If there is nobody who is not, then Shane is teak and Shane is not poised.\n((Wicked(x) ∧ Mushy(x))) ↔ ((Poised(x))) ::: Someone is wicked and mushy if and only if he is poised.\n(∃x (Poised(x) ∨ ¬Hungry(x))) → ((¬Mushy(george))) ::: If there is at least one people who is poised or not hungry, then George is not mushy.\n(∃x (Wicked(x) ∧ ¬Teak(x))) → ((Poised(crosby))) ::: If there is at least one people who is both wicked and not teak, then Crosby is poised.\n((Teak(keith))) ↔ ((¬Poised(gregory) ∧ ¬Wicked(noel))) ::: Keith is teak if and only if Gregory is not poised and Noel is not wicked.\n((Teak(noel))) ↔ ((Hungry(shane))) ::: Noel is teak if and only if Shane is hungry.\n((¬Teak(gregory) ∧ Wicked(crosby))) → ((¬Mushy(keith))) ::: If Gregory is not teak and Crosby is wicked, then Keith is not mushy.\n(∃x (Hungry(x) ∧ Wicked(x))) → ((Teak(noel))) ::: If there is at least one people who is both hungry and wicked, then Noel is teak.\n",
            "First-Order-Logic Question": "¬Teak(ronald) ::: Ronald is not teak."
        },
        "fixed": true
    },
    {
        "id": 128,
        "raw_prog": {
            "First-Order-Logic Rules": "¬Hungry(gregory) ::: Gregory is not hungry.\nMushy(ronald) ::: Ronald is mushy.\nTeak(keith) ::: Keith is teak.\nPoised(crosby) ::: Crosby is poised.\nFrank(shane) ::: Shane is frank.\nPoised(gregory) ::: Gregory is poised.\n¬Poised(shane) ::: Shane is not poised.\nMushy(keith) ::: Keith is mushy.\n¬Frank(noel) ::: Noel is not frank.\nFrank(george) ::: George is frank.\nWicked(george) ::: George is wicked.\nFrank(keith) ::: Keith is frank.\n((Mushy(x) ∨ ¬Poised(x))) → ((Hungry(x) ∧ ¬Wicked(x))) ::: If someone is either mushy or not poised, then he is hungry and not wicked.\n((¬Poised(gregory))) → ((Mushy(shane))) ::: If Gregory is not poised, then Shane is mushy.\n(∃x (Wicked(x))) → ((¬Poised(shane) ∧ ¬Frank(george))) ::: If there is at least one people who is wicked, then Shane is not poised and George is not frank.\n((Teak(noel))) ↔ ((¬Poised(noel))) ::: If Noel is teak, then Noel is not poised, and vice versa.\n(¬∃x (¬x)) → ((Teak(shane) ∧ ¬Poised(shane))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised.\n((Poised(x) ∧ Mushy(x))) ↔ ((Wicked(x))) ::: Someone is wicked and mushy if and only if he is poised.\n(∃x (Poised(x) ∨ ¬Hungry(x))) → ((¬Mushy(george))) ::: If there is at least one people who is poised or not hungry, then George is not mushy.\n(∃x (Wicked(x) ∧ ¬Teak(x))) → ((Poised(crosby))) ::: If there is at least one people who is both wicked and not teak, then Crosby is poised.\n((Teak(keith))) ↔ ((¬Poised(gregory) ∧ ¬Wicked(noel))) ::: Keith is teak if and only if Gregory is not poised and Noel is not wicked.\n((Teak(noel))) ↔ ((Hungry(shane))) ::: Noel is teak if and only if Shane is hungry.\n((¬Teak(gregory) ∧ Wicked(crosby))) → ((¬Mushy(keith))) ::: If Gregory is not teak and Crosby is wicked, then Keith is not mushy.\n(∃x (Hungry(x) ∧ Wicked(x))) → ((Teak(noel))) ::: If there is at least one people who is both hungry and wicked, then Noel is teak.\n",
            "First-Order-Logic Question": "¬Hungry(crosby) ::: Crosby is not hungry."
        },
        "gram_prog": {
            "First-Order-Logic Rules": "¬Hungry(gregory) ::: Gregory is not hungry.\nMushy(ronald) ::: Ronald is mushy.\nTeak(keith) ::: Keith is teak.\nPoised(crosby) ::: Crosby is poised.\nFrank(shane) ::: Shane is frank.\nPoised(gregory) ::: Gregory is poised.\n¬Poised(shane) ::: Shane is not poised.\nMushy(keith) ::: Keith is mushy.\n¬Frank(noel) ::: Noel is not frank.\nFrank(george) ::: George is frank.\nWicked(george) ::: George is wicked.\nFrank(keith) ::: Keith is frank.\n((Mushy(x) ∨ ¬Poised(x))) → ((Hungry(x) ∧ ¬Wicked(x))) ::: If someone is either mushy or not poised, then he is hungry and not wicked.\n((¬Poised(gregory))) → ((Mushy(shane))) ::: If Gregory is not poised, then Shane is mushy.\n(∃x (Wicked(x))) → ((¬Poised(shane) ∧ ¬Frank(george))) ::: If there is at least one people who is wicked, then Shane is not poised and George is not frank.\n((Teak(noel))) ↔ ((¬Poised(noel))) ::: If Noel is teak, then Noel is not poised, and vice versa.\n¬∃x((¬(¬Fresh(x)))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised.\n((Poised(x) ∧ Mushy(x))) ↔ ((Wicked(x))) ::: Someone is wicked and mushy if and only if he is poised.\n(∃x (Poised(x) ∨ ¬Hungry(x))) → ((¬Mushy(george))) ::: If there is at least one people who is poised or not hungry, then George is not mushy.\n(∃x (Wicked(x) ∧ ¬Teak(x))) → ((Poised(crosby))) ::: If there is at least one people who is both wicked and not teak, then Crosby is poised.\n((Teak(keith))) ↔ ((¬Poised(gregory) ∧ ¬Wicked(noel))) ::: Keith is teak if and only if Gregory is not poised and Noel is not wicked.\n((Teak(noel))) ↔ ((Hungry(shane))) ::: Noel is teak if and only if Shane is hungry.\n((¬Teak(gregory) ∧ Wicked(crosby))) → ((¬Mushy(keith))) ::: If Gregory is not teak and Crosby is wicked, then Keith is not mushy.\n(∃x (Hungry(x) ∧ Wicked(x))) → ((Teak(noel))) ::: If there is at least one people who is both hungry and wicked, then Noel is teak.\n",
            "First-Order-Logic Question": "¬Hungry(crosby) ::: Crosby is not hungry."
        },
        "diff": [
            {
                "raw": "(¬∃x (¬x)) → ((Teak(shane) ∧ ¬Poised(shane))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised.",
                "gram": "¬∃x((¬(¬Fresh(x)))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised."
            }
        ],
        "answer": "B",
        "grammar_answer": "A",
        "manual_prog": {
            "First-Order-Logic Rules": "¬Hungry(gregory) ::: Gregory is not hungry.\nMushy(ronald) ::: Ronald is mushy.\nTeak(keith) ::: Keith is teak.\nPoised(crosby) ::: Crosby is poised.\nFrank(shane) ::: Shane is frank.\nPoised(gregory) ::: Gregory is poised.\n¬Poised(shane) ::: Shane is not poised.\nMushy(keith) ::: Keith is mushy.\n¬Frank(noel) ::: Noel is not frank.\nFrank(george) ::: George is frank.\nWicked(george) ::: George is wicked.\nFrank(keith) ::: Keith is frank.\n((Mushy(x) ∨ ¬Poised(x))) → ((Hungry(x) ∧ ¬Wicked(x))) ::: If someone is either mushy or not poised, then he is hungry and not wicked.\n((¬Poised(gregory))) → ((Mushy(shane))) ::: If Gregory is not poised, then Shane is mushy.\n(∃x (Wicked(x))) → ((¬Poised(shane) ∧ ¬Frank(george))) ::: If there is at least one people who is wicked, then Shane is not poised and George is not frank.\n((Teak(noel))) ↔ ((¬Poised(noel))) ::: If Noel is teak, then Noel is not poised, and vice versa.\n∃x (¬Not(x)) → (Teak(shane) ∧ ¬Poised(shane)) ::: If there is nobody who is not, then Shane is teak and Shane is not poised.\n((Poised(x) ∧ Mushy(x))) ↔ ((Wicked(x))) ::: Someone is wicked and mushy if and only if he is poised.\n(∃x (Poised(x) ∨ ¬Hungry(x))) → ((¬Mushy(george))) ::: If there is at least one people who is poised or not hungry, then George is not mushy.\n(∃x (Wicked(x) ∧ ¬Teak(x))) → ((Poised(crosby))) ::: If there is at least one people who is both wicked and not teak, then Crosby is poised.\n((Teak(keith))) ↔ ((¬Poised(gregory) ∧ ¬Wicked(noel))) ::: Keith is teak if and only if Gregory is not poised and Noel is not wicked.\n((Teak(noel))) ↔ ((Hungry(shane))) ::: Noel is teak if and only if Shane is hungry.\n((¬Teak(gregory) ∧ Wicked(crosby))) → ((¬Mushy(keith))) ::: If Gregory is not teak and Crosby is wicked, then Keith is not mushy.\n(∃x (Hungry(x) ∧ Wicked(x))) → ((Teak(noel))) ::: If there is at least one people who is both hungry and wicked, then Noel is teak.\n",
            "First-Order-Logic Question": "¬Hungry(crosby) ::: Crosby is not hungry."
        },
        "fixed": true
    },
    {
        "id": 129,
        "raw_prog": {
            "First-Order-Logic Rules": "¬Hungry(gregory) ::: Gregory is not hungry.\nMushy(ronald) ::: Ronald is mushy.\nTeak(keith) ::: Keith is teak.\nPoised(crosby) ::: Crosby is poised.\nFrank(shane) ::: Shane is frank.\nPoised(gregory) ::: Gregory is poised.\n¬Poised(shane) ::: Shane is not poised.\nMushy(keith) ::: Keith is mushy.\n¬Frank(noel) ::: Noel is not frank.\nFrank(george) ::: George is frank.\nWicked(george) ::: George is wicked.\nFrank(keith) ::: Keith is frank.\n((Mushy(x) ∨ ¬Poised(x))) → (Hungry(x) ∧ ¬Wicked(x)) ::: If someone is either mushy or not poised, then he is hungry and not wicked.\n(¬Poised(gregory)) → (Mushy(shane)) ::: If Gregory is not poised, then Shane is mushy.\n(∃x (Wicked(x))) → (¬Poised(shane) ∧ ¬Frank(george)) ::: If there is at least one people who is wicked, then Shane is not poised and George is not frank.\n(Teak(noel)) ↔ (¬Poised(noel)) ::: If Noel is teak, then Noel is not poised, and vice versa.\n(¬∃x (¬Entire(x))) → (Teak(shane) ∧ ¬Poised(shane)) ::: If there is nobody who is not, then Shane is teak and Shane is not poised.\n((Wicked(x) ∧ ¬Teak(x))) ↔ (Poised(x)) ::: Someone is wicked and mushy if and only if he is poised.\n(∃x (Poised(x) ∨ ¬Hungry(x))) → (¬Mushy(george)) ::: If there is at least one people who is poised or not hungry, then George is not mushy.\n(∃x (Wicked(x) ∧ ¬Teak(x))) → (Poised(crosby)) ::: If there is at least one people who is both wicked and not teak, then Crosby is poised.\n(Teak(keith)) ↔ (¬Poised(gregory) ∧ ¬Wicked(noel)) ::: Keith is teak if and only if Gregory is not poised and Noel is not wicked.\n(Teak(noel)) ↔ (Hungry(shane)) ::: Noel is teak if and only if Shane is hungry.\n(¬Teak(gregory) ∧ Wicked(crosby)) → (¬Mushy(keith)) ::: If Gregory is not teak and Crosby is wicked, then Keith is not mushy.\n(∃x (Hungry(x) ∧ Wicked(x))) → (Teak(noel)) ::: If there is at least one people who is both hungry and wicked, then Noel is teak.\n",
            "First-Order-Logic Question": "¬Mushy(keith) ::: Keith is not mushy."
        },
        "gram_prog": {
            "First-Order-Logic Rules": "¬Hungry(gregory) ::: Gregory is not hungry.\nMushy(ronald) ::: Ronald is mushy.\nTeak(keith) ::: Keith is teak.\nPoised(crosby) ::: Crosby is poised.\nFrank(shane) ::: Shane is frank.\nPoised(gregory) ::: Gregory is poised.\n¬Poised(shane) ::: Shane is not poised.\nMushy(keith) ::: Keith is mushy.\n¬Frank(noel) ::: Noel is not frank.\nFrank(george) ::: George is frank.\nWicked(george) ::: George is wicked.\nFrank(keith) ::: Keith is frank.\n((Mushy(x) ∨ ¬Poised(x))) → (Hungry(x) ∧ ¬Wicked(x)) ::: If someone is either mushy or not poised, then he is hungry and not wicked.\n(¬Poised(gregory)) → (Mushy(shane)) ::: If Gregory is not poised, then Shane is mushy.\n(∃x (Wicked(x))) → (¬Poised(shane) ∧ ¬Frank(george)) ::: If there is at least one people who is wicked, then Shane is not poised and George is not frank.\n(Teak(noel)) ↔ (¬Poised(noel)) ::: If Noel is teak, then Noel is not poised, and vice versa.\n¬∃x(¬Entire(x))→(Serious(x)∧¬Fresh(x)) ::: If there is nobody who is not, then Shane is teak and Shane is not poised.\n((Wicked(x) ∧ ¬Teak(x))) ↔ (Poised(x)) ::: Someone is wicked and mushy if and only if he is poised.\n(∃x (Poised(x) ∨ ¬Hungry(x))) → (¬Mushy(george)) ::: If there is at least one people who is poised or not hungry, then George is not mushy.\n(∃x (Wicked(x) ∧ ¬Teak(x))) → (Poised(crosby)) ::: If there is at least one people who is both wicked and not teak, then Crosby is poised.\n(Teak(keith)) ↔ (¬Poised(gregory) ∧ ¬Wicked(noel)) ::: Keith is teak if and only if Gregory is not poised and Noel is not wicked.\n(Teak(noel)) ↔ (Hungry(shane)) ::: Noel is teak if and only if Shane is hungry.\n(¬Teak(gregory) ∧ Wicked(crosby)) → (¬Mushy(keith)) ::: If Gregory is not teak and Crosby is wicked, then Keith is not mushy.\n(∃x (Hungry(x) ∧ Wicked(x))) → (Teak(noel)) ::: If there is at least one people who is both hungry and wicked, then Noel is teak.\n",
            "First-Order-Logic Question": "¬Mushy(keith) ::: Keith is not mushy."
        },
        "diff": [
            {
                "raw": "(¬∃x (¬Entire(x))) → (Teak(shane) ∧ ¬Poised(shane)) ::: If there is nobody who is not, then Shane is teak and Shane is not poised.",
                "gram": "¬∃x(¬Entire(x))→(Serious(x)∧¬Fresh(x)) ::: If there is nobody who is not, then Shane is teak and Shane is not poised."
            }
        ],
        "answer": "B",
        "grammar_answer": "A",
        "manual_prog": {
            "First-Order-Logic Rules": "¬Hungry(gregory) ::: Gregory is not hungry.\nMushy(ronald) ::: Ronald is mushy.\nTeak(keith) ::: Keith is teak.\nPoised(crosby) ::: Crosby is poised.\nFrank(shane) ::: Shane is frank.\nPoised(gregory) ::: Gregory is poised.\n¬Poised(shane) ::: Shane is not poised.\nMushy(keith) ::: Keith is mushy.\n¬Frank(noel) ::: Noel is not frank.\nFrank(george) ::: George is frank.\nWicked(george) ::: George is wicked.\nFrank(keith) ::: Keith is frank.\n((Mushy(x) ∨ ¬Poised(x))) → (Hungry(x) ∧ ¬Wicked(x)) ::: If someone is either mushy or not poised, then he is hungry and not wicked.\n(¬Poised(gregory)) → (Mushy(shane)) ::: If Gregory is not poised, then Shane is mushy.\n(∃x (Wicked(x))) → (¬Poised(shane) ∧ ¬Frank(george)) ::: If there is at least one people who is wicked, then Shane is not poised and George is not frank.\n(Teak(noel)) ↔ (¬Poised(noel)) ::: If Noel is teak, then Noel is not poised, and vice versa.\n(∃x ¬(¬Entire(x))) → ((Teak(shane) ∧ ¬Poised(shane))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised.\n((Wicked(x) ∧ ¬Teak(x))) ↔ (Poised(x)) ::: Someone is wicked and mushy if and only if he is poised.\n(∃x (Poised(x) ∨ ¬Hungry(x))) → (¬Mushy(george)) ::: If there is at least one people who is poised or not hungry, then George is not mushy.\n(∃x (Wicked(x) ∧ ¬Teak(x))) → (Poised(crosby)) ::: If there is at least one people who is both wicked and not teak, then Crosby is poised.\n(Teak(keith)) ↔ (¬Poised(gregory) ∧ ¬Wicked(noel)) ::: Keith is teak if and only if Gregory is not poised and Noel is not wicked.\n(Teak(noel)) ↔ (Hungry(shane)) ::: Noel is teak if and only if Shane is hungry.\n(¬Teak(gregory) ∧ Wicked(crosby)) → (¬Mushy(keith)) ::: If Gregory is not teak and Crosby is wicked, then Keith is not mushy.\n(∃x (Hungry(x) ∧ Wicked(x))) → (Teak(noel)) ::: If there is at least one people who is both hungry and wicked, then Noel is teak.\n",
            "First-Order-Logic Question": "¬Mushy(keith) ::: Keith is not mushy."
        },
        "fixed": true
    },
    {
        "id": 130,
        "raw_prog": {
            "First-Order-Logic Rules": "¬Hungry(gregory) ::: Gregory is not hungry.\nPoised(ronald) ::: Ronald is mushy.\nTeak(keith) ::: Keith is teak.\nPoised(crosby) ::: Crosby is poised.\nFrank(shane) ::: Shane is frank.\nPoised(gregory) ::: Gregory is poised.\n¬Poised(shane) ::: Shane is not poised.\nMushy(keith) ::: Keith is mushy.\n¬Frank(noel) ::: Noel is not frank.\nFrank(george) ::: George is frank.\nWicked(george) ::: George is wicked.\nFrank(keith) ::: Keith is frank.\n((Mushy(x) ∨ ¬Poised(x))) → ((Hungry(x) ∧ ¬Wicked(x))) ::: If someone is either mushy or not poised, then he is hungry and not wicked.\n(¬Poised(gregory)) → (Mushy(shane)) ::: If Gregory is not poised, then Shane is mushy.\n(∃x (Wicked(x))) → ((¬Poised(shane) ∧ ¬Frank(george))) ::: If there is at least one people who is wicked, then Shane is not poised and George is not frank.\n(Teak(noel)) ↔ (¬Poised(noel)) ::: If Noel is teak, then Noel is not poised, and vice versa.\n(¬∃x (¬x)) → (Teak(shane) ∧ ¬Poised(shane)) ::: If there is nobody who is not, then Shane is teak and Shane is not poised.\n((Wicked(x) ∧ ¬Teak(x))) ↔ (Poised(x)) ::: Someone is wicked and mushy if and only if he is poised.\n(∃x (Poised(x) ∨ ¬Hungry(x))) → (¬Mushy(george)) ::: If there is at least one people who is poised or not hungry, then George is not mushy.\n(∃x (Wicked(x) ∧ ¬Teak(x))) → (Poised(crosby)) ::: If there is at least one people who is both wicked and not teak, then Crosby is poised.\n(Teak(keith)) ↔ (¬Poised(gregory) ∧ ¬Wicked(noel)) ::: Keith is teak if and only if Gregory is not poised and Noel is not wicked.\n(Teak(noel)) ↔ (Hungry(shane)) ::: Noel is teak if and only if Shane is hungry.\n(¬Teak(gregory) ∧ Wicked(crosby)) → (¬Mushy(keith)) ::: If Gregory is not teak and Crosby is wicked, then Keith is not mushy.\n(∃x (Hungry(x) ∧ Wicked(x))) → (Teak(noel)) ::: If there is at least one people who is both hungry and wicked, then Noel is teak.\n",
            "First-Order-Logic Question": "Poised(keith) ::: Keith is poised."
        },
        "gram_prog": {
            "First-Order-Logic Rules": "¬Hungry(gregory) ::: Gregory is not hungry.\nPoised(ronald) ::: Ronald is mushy.\nTeak(keith) ::: Keith is teak.\nPoised(crosby) ::: Crosby is poised.\nFrank(shane) ::: Shane is frank.\nPoised(gregory) ::: Gregory is poised.\n¬Poised(shane) ::: Shane is not poised.\nMushy(keith) ::: Keith is mushy.\n¬Frank(noel) ::: Noel is not frank.\nFrank(george) ::: George is frank.\nWicked(george) ::: George is wicked.\nFrank(keith) ::: Keith is frank.\n((Mushy(x) ∨ ¬Poised(x))) → ((Hungry(x) ∧ ¬Wicked(x))) ::: If someone is either mushy or not poised, then he is hungry and not wicked.\n(¬Poised(gregory)) → (Mushy(shane)) ::: If Gregory is not poised, then Shane is mushy.\n(∃x (Wicked(x))) → ((¬Poised(shane) ∧ ¬Frank(george))) ::: If there is at least one people who is wicked, then Shane is not poised and George is not frank.\n(Teak(noel)) ↔ (¬Poised(noel)) ::: If Noel is teak, then Noel is not poised, and vice versa.\n¬∃x(¬(¬(Hungry(x)))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised.\n((Wicked(x) ∧ ¬Teak(x))) ↔ (Poised(x)) ::: Someone is wicked and mushy if and only if he is poised.\n(∃x (Poised(x) ∨ ¬Hungry(x))) → (¬Mushy(george)) ::: If there is at least one people who is poised or not hungry, then George is not mushy.\n(∃x (Wicked(x) ∧ ¬Teak(x))) → (Poised(crosby)) ::: If there is at least one people who is both wicked and not teak, then Crosby is poised.\n(Teak(keith)) ↔ (¬Poised(gregory) ∧ ¬Wicked(noel)) ::: Keith is teak if and only if Gregory is not poised and Noel is not wicked.\n(Teak(noel)) ↔ (Hungry(shane)) ::: Noel is teak if and only if Shane is hungry.\n(¬Teak(gregory) ∧ Wicked(crosby)) → (¬Mushy(keith)) ::: If Gregory is not teak and Crosby is wicked, then Keith is not mushy.\n(∃x (Hungry(x) ∧ Wicked(x))) → (Teak(noel)) ::: If there is at least one people who is both hungry and wicked, then Noel is teak.\n",
            "First-Order-Logic Question": "Poised(keith) ::: Keith is poised."
        },
        "diff": [
            {
                "raw": "(¬∃x (¬x)) → (Teak(shane) ∧ ¬Poised(shane)) ::: If there is nobody who is not, then Shane is teak and Shane is not poised.",
                "gram": "¬∃x(¬(¬(Hungry(x)))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised."
            }
        ],
        "answer": "C",
        "grammar_answer": "A",
        "manual_prog": {
            "First-Order-Logic Rules": "¬Hungry(gregory) ::: Gregory is not hungry.\nPoised(ronald) ::: Ronald is mushy.\nTeak(keith) ::: Keith is teak.\nPoised(crosby) ::: Crosby is poised.\nFrank(shane) ::: Shane is frank.\nPoised(gregory) ::: Gregory is poised.\n¬Poised(shane) ::: Shane is not poised.\nMushy(keith) ::: Keith is mushy.\n¬Frank(noel) ::: Noel is not frank.\nFrank(george) ::: George is frank.\nWicked(george) ::: George is wicked.\nFrank(keith) ::: Keith is frank.\n((Mushy(x) ∨ ¬Poised(x))) → ((Hungry(x) ∧ ¬Wicked(x))) ::: If someone is either mushy or not poised, then he is hungry and not wicked.\n(¬Poised(gregory)) → (Mushy(shane)) ::: If Gregory is not poised, then Shane is mushy.\n(∃x (Wicked(x))) → ((¬Poised(shane) ∧ ¬Frank(george))) ::: If there is at least one people who is wicked, then Shane is not poised and George is not frank.\n(Teak(noel)) ↔ (¬Poised(noel)) ::: If Noel is teak, then Noel is not poised, and vice versa.\n∃x (¬Not(x)) → (Teak(shane) ∧ ¬Poised(shane)) ::: If there is nobody who is not, then Shane is teak and Shane is not poised.\n((Wicked(x) ∧ ¬Teak(x))) ↔ (Poised(x)) ::: Someone is wicked and mushy if and only if he is poised.\n(∃x (Poised(x) ∨ ¬Hungry(x))) → (¬Mushy(george)) ::: If there is at least one people who is poised or not hungry, then George is not mushy.\n(∃x (Wicked(x) ∧ ¬Teak(x))) → (Poised(crosby)) ::: If there is at least one people who is both wicked and not teak, then Crosby is poised.\n(Teak(keith)) ↔ (¬Poised(gregory) ∧ ¬Wicked(noel)) ::: Keith is teak if and only if Gregory is not poised and Noel is not wicked.\n(Teak(noel)) ↔ (Hungry(shane)) ::: Noel is teak if and only if Shane is hungry.\n(¬Teak(gregory) ∧ Wicked(crosby)) → (¬Mushy(keith)) ::: If Gregory is not teak and Crosby is wicked, then Keith is not mushy.\n(∃x (Hungry(x) ∧ Wicked(x))) → (Teak(noel)) ::: If there is at least one people who is both hungry and wicked, then Noel is teak.\n",
            "First-Order-Logic Question": "Poised(keith) ::: Keith is poised."
        },
        "fixed": true
    },
    {
        "id": 131,
        "raw_prog": {
            "First-Order-Logic Rules": "¬Hungry(gregory) ::: Gregory is not hungry.\nPoised(ronald) ::: Ronald is mushy.\nTeak(keith) ::: Keith is teak.\nPoised(crosby) ::: Crosby is poised.\nFrank(shane) ::: Shane is frank.\nPoised(gregory) ::: Gregory is poised.\n¬Poised(shane) ::: Shane is not poised.\nMushy(keith) ::: Keith is mushy.\n¬Frank(noel) ::: Noel is not frank.\nFrank(george) ::: George is frank.\nWicked(george) ::: George is wicked.\nFrank(keith) ::: Keith is frank.\n((Mushy(x) ∨ ¬Poised(x))) → ((Hungry(x) ∧ ¬Wicked(x))) ::: If someone is either mushy or not poised, then he is hungry and not wicked.\n((¬Poised(gregory))) → ((Mushy(shane))) ::: If Gregory is not poised, then Shane is mushy.\n(∃x (Wicked(x))) → ((¬Poised(shane) ∧ ¬Frank(george))) ::: If there is at least one people who is wicked, then Shane is not poised and George is not frank.\n((Teak(noel))) ↔ ((¬Poised(noel))) ::: If Noel is teak, then Noel is not poised, and vice versa.\n(¬∃x (¬x)) → ((Teak(shane) ∧ ¬Poised(shane))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised.\n((Wicked(x) ∧ ¬Teak(x))) ↔ ((Poised(x))) ::: Someone is wicked and mushy if and only if he is poised.\n(∃x (Poised(x) ∨ ¬Hungry(x))) → ((¬Mushy(george))) ::: If there is at least one people who is poised or not hungry, then George is not mushy.\n(∃x (Wicked(x) ∧ ¬Teak(x))) → ((Poised(crosby))) ::: If there is at least one people who is both wicked and not teak, then Crosby is poised.\n((Teak(keith))) ↔ ((¬Poised(gregory) ∧ ¬Wicked(noel))) ::: Keith is teak if and only if Gregory is not poised and Noel is not wicked.\n((Teak(noel))) ↔ ((Hungry(shane))) ::: Noel is teak if and only if Shane is hungry.\n((¬Teak(gregory) ∧ Wicked(crosby))) → ((¬Mushy(keith))) ::: If Gregory is not teak and Crosby is wicked, then Keith is not mushy.\n(∃x (Hungry(x) ∧ Wicked(x))) → ((Teak(noel))) ::: If there is at least one people who is both hungry and wicked, then Noel is teak.\n",
            "First-Order-Logic Question": "Poised(george) ::: George is poised."
        },
        "gram_prog": {
            "First-Order-Logic Rules": "¬Hungry(gregory) ::: Gregory is not hungry.\nPoised(ronald) ::: Ronald is mushy.\nTeak(keith) ::: Keith is teak.\nPoised(crosby) ::: Crosby is poised.\nFrank(shane) ::: Shane is frank.\nPoised(gregory) ::: Gregory is poised.\n¬Poised(shane) ::: Shane is not poised.\nMushy(keith) ::: Keith is mushy.\n¬Frank(noel) ::: Noel is not frank.\nFrank(george) ::: George is frank.\nWicked(george) ::: George is wicked.\nFrank(keith) ::: Keith is frank.\n((Mushy(x) ∨ ¬Poised(x))) → ((Hungry(x) ∧ ¬Wicked(x))) ::: If someone is either mushy or not poised, then he is hungry and not wicked.\n((¬Poised(gregory))) → ((Mushy(shane))) ::: If Gregory is not poised, then Shane is mushy.\n(∃x (Wicked(x))) → ((¬Poised(shane) ∧ ¬Frank(george))) ::: If there is at least one people who is wicked, then Shane is not poised and George is not frank.\n((Teak(noel))) ↔ ((¬Poised(noel))) ::: If Noel is teak, then Noel is not poised, and vice versa.\n¬∃x((¬(¬Frank(x)))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised.\n((Wicked(x) ∧ ¬Teak(x))) ↔ ((Poised(x))) ::: Someone is wicked and mushy if and only if he is poised.\n(∃x (Poised(x) ∨ ¬Hungry(x))) → ((¬Mushy(george))) ::: If there is at least one people who is poised or not hungry, then George is not mushy.\n(∃x (Wicked(x) ∧ ¬Teak(x))) → ((Poised(crosby))) ::: If there is at least one people who is both wicked and not teak, then Crosby is poised.\n((Teak(keith))) ↔ ((¬Poised(gregory) ∧ ¬Wicked(noel))) ::: Keith is teak if and only if Gregory is not poised and Noel is not wicked.\n((Teak(noel))) ↔ ((Hungry(shane))) ::: Noel is teak if and only if Shane is hungry.\n((¬Teak(gregory) ∧ Wicked(crosby))) → ((¬Mushy(keith))) ::: If Gregory is not teak and Crosby is wicked, then Keith is not mushy.\n(∃x (Hungry(x) ∧ Wicked(x))) → ((Teak(noel))) ::: If there is at least one people who is both hungry and wicked, then Noel is teak.\n",
            "First-Order-Logic Question": "Poised(george) ::: George is poised."
        },
        "diff": [
            {
                "raw": "(¬∃x (¬x)) → ((Teak(shane) ∧ ¬Poised(shane))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised.",
                "gram": "¬∃x((¬(¬Frank(x)))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised."
            }
        ],
        "answer": "C",
        "grammar_answer": "A",
        "manual_prog": {
            "First-Order-Logic Rules": "¬Hungry(gregory) ::: Gregory is not hungry.\nPoised(ronald) ::: Ronald is mushy.\nTeak(keith) ::: Keith is teak.\nPoised(crosby) ::: Crosby is poised.\nFrank(shane) ::: Shane is frank.\nPoised(gregory) ::: Gregory is poised.\n¬Poised(shane) ::: Shane is not poised.\nMushy(keith) ::: Keith is mushy.\n¬Frank(noel) ::: Noel is not frank.\nFrank(george) ::: George is frank.\nWicked(george) ::: George is wicked.\nFrank(keith) ::: Keith is frank.\n((Mushy(x) ∨ ¬Poised(x))) → ((Hungry(x) ∧ ¬Wicked(x))) ::: If someone is either mushy or not poised, then he is hungry and not wicked.\n((¬Poised(gregory))) → ((Mushy(shane))) ::: If Gregory is not poised, then Shane is mushy.\n(∃x (Wicked(x))) → ((¬Poised(shane) ∧ ¬Frank(george))) ::: If there is at least one people who is wicked, then Shane is not poised and George is not frank.\n((Teak(noel))) ↔ ((¬Poised(noel))) ::: If Noel is teak, then Noel is not poised, and vice versa.\n∃x (¬Not(x)) → (Teak(shane) ∧ ¬Poised(shane)) ::: If there is nobody who is not, then Shane is teak and Shane is not poised.\n((Wicked(x) ∧ ¬Teak(x))) ↔ ((Poised(x))) ::: Someone is wicked and mushy if and only if he is poised.\n(∃x (Poised(x) ∨ ¬Hungry(x))) → ((¬Mushy(george))) ::: If there is at least one people who is poised or not hungry, then George is not mushy.\n(∃x (Wicked(x) ∧ ¬Teak(x))) → ((Poised(crosby))) ::: If there is at least one people who is both wicked and not teak, then Crosby is poised.\n((Teak(keith))) ↔ ((¬Poised(gregory) ∧ ¬Wicked(noel))) ::: Keith is teak if and only if Gregory is not poised and Noel is not wicked.\n((Teak(noel))) ↔ ((Hungry(shane))) ::: Noel is teak if and only if Shane is hungry.\n((¬Teak(gregory) ∧ Wicked(crosby))) → ((¬Mushy(keith))) ::: If Gregory is not teak and Crosby is wicked, then Keith is not mushy.\n(∃x (Hungry(x) ∧ Wicked(x))) → ((Teak(noel))) ::: If there is at least one people who is both hungry and wicked, then Noel is teak.\n",
            "First-Order-Logic Question": "Poised(george) ::: George is poised."
        },
        "fixed": true
    },
    {
        "id": 132,
        "raw_prog": {
            "First-Order-Logic Rules": "¬Hungry(gregory) ::: Gregory is not hungry.\nPoised(ronald) ::: Ronald is mushy.\nTeak(keith) ::: Keith is teak.\nPoised(crosby) ::: Crosby is poised.\nFrank(shane) ::: Shane is frank.\nPoised(gregory) ::: Gregory is poised.\n¬Poised(shane) ::: Shane is not poised.\nMushy(keith) ::: Keith is mushy.\n¬Frank(noel) ::: Noel is not frank.\nFrank(george) ::: George is frank.\nWicked(george) ::: George is wicked.\nFrank(keith) ::: Keith is frank.\n((Mushy(x) ∨ ¬Poised(x))) → ((Hungry(x) ∧ ¬Wicked(x))) ::: If someone is either mushy or not poised, then he is hungry and not wicked.\n((¬Poised(gregory))) → ((Mushy(shane))) ::: If Gregory is not poised, then Shane is mushy.\n(∃x (Wicked(x))) → ((¬Poised(shane) ∧ ¬Frank(george))) ::: If there is at least one people who is wicked, then Shane is not poised and George is not frank.\n((Teak(noel))) ↔ ((¬Poised(noel))) ::: If Noel is teak, then Noel is not poised, and vice versa.\n(¬∃x (¬x)) → ((Teak(shane) ∧ ¬Poised(shane))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised.\n((Poised(x) ∧ Mushy(x))) ↔ ((Poised(x))) ::: Someone is wicked and mushy if and only if he is poised.\n(∃x (Poised(x) ∨ ¬Hungry(x))) → ((¬Mushy(george))) ::: If there is at least one people who is poised or not hungry, then George is not mushy.\n(∃x (Wicked(x) ∧ ¬Teak(x))) → ((Poised(crosby))) ::: If there is at least one people who is both wicked and not teak, then Crosby is poised.\n((Teak(keith))) ↔ ((¬Poised(gregory) ∧ ¬Wicked(noel))) ::: Keith is teak if and only if Gregory is not poised and Noel is not wicked.\n((Teak(noel))) ↔ ((Hungry(shane))) ::: Noel is teak if and only if Shane is hungry.\n((¬Teak(gregory) ∧ Wicked(crosby))) → ((¬Mushy(keith))) ::: If Gregory is not teak and Crosby is wicked, then Keith is not mushy.\n(∃x (Hungry(x) ∧ Wicked(x))) → ((Teak(noel))) ::: If there is at least one people who is both hungry and wicked, then Noel is teak.\n",
            "First-Order-Logic Question": "Poised(noel) ::: Noel is poised."
        },
        "gram_prog": {
            "First-Order-Logic Rules": "¬Hungry(gregory) ::: Gregory is not hungry.\nPoised(ronald) ::: Ronald is mushy.\nTeak(keith) ::: Keith is teak.\nPoised(crosby) ::: Crosby is poised.\nFrank(shane) ::: Shane is frank.\nPoised(gregory) ::: Gregory is poised.\n¬Poised(shane) ::: Shane is not poised.\nMushy(keith) ::: Keith is mushy.\n¬Frank(noel) ::: Noel is not frank.\nFrank(george) ::: George is frank.\nWicked(george) ::: George is wicked.\nFrank(keith) ::: Keith is frank.\n((Mushy(x) ∨ ¬Poised(x))) → ((Hungry(x) ∧ ¬Wicked(x))) ::: If someone is either mushy or not poised, then he is hungry and not wicked.\n((¬Poised(gregory))) → ((Mushy(shane))) ::: If Gregory is not poised, then Shane is mushy.\n(∃x (Wicked(x))) → ((¬Poised(shane) ∧ ¬Frank(george))) ::: If there is at least one people who is wicked, then Shane is not poised and George is not frank.\n((Teak(noel))) ↔ ((¬Poised(noel))) ::: If Noel is teak, then Noel is not poised, and vice versa.\n¬∃x((¬(¬Frank(x)))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised.\n((Poised(x) ∧ Mushy(x))) ↔ ((Poised(x))) ::: Someone is wicked and mushy if and only if he is poised.\n(∃x (Poised(x) ∨ ¬Hungry(x))) → ((¬Mushy(george))) ::: If there is at least one people who is poised or not hungry, then George is not mushy.\n(∃x (Wicked(x) ∧ ¬Teak(x))) → ((Poised(crosby))) ::: If there is at least one people who is both wicked and not teak, then Crosby is poised.\n((Teak(keith))) ↔ ((¬Poised(gregory) ∧ ¬Wicked(noel))) ::: Keith is teak if and only if Gregory is not poised and Noel is not wicked.\n((Teak(noel))) ↔ ((Hungry(shane))) ::: Noel is teak if and only if Shane is hungry.\n((¬Teak(gregory) ∧ Wicked(crosby))) → ((¬Mushy(keith))) ::: If Gregory is not teak and Crosby is wicked, then Keith is not mushy.\n(∃x (Hungry(x) ∧ Wicked(x))) → ((Teak(noel))) ::: If there is at least one people who is both hungry and wicked, then Noel is teak.\n",
            "First-Order-Logic Question": "Poised(noel) ::: Noel is poised."
        },
        "diff": [
            {
                "raw": "(¬∃x (¬x)) → ((Teak(shane) ∧ ¬Poised(shane))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised.",
                "gram": "¬∃x((¬(¬Frank(x)))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised."
            }
        ],
        "answer": "B",
        "grammar_answer": "A",
        "manual_prog": {
            "First-Order-Logic Rules": "¬Hungry(gregory) ::: Gregory is not hungry.\nPoised(ronald) ::: Ronald is mushy.\nTeak(keith) ::: Keith is teak.\nPoised(crosby) ::: Crosby is poised.\nFrank(shane) ::: Shane is frank.\nPoised(gregory) ::: Gregory is poised.\n¬Poised(shane) ::: Shane is not poised.\nMushy(keith) ::: Keith is mushy.\n¬Frank(noel) ::: Noel is not frank.\nFrank(george) ::: George is frank.\nWicked(george) ::: George is wicked.\nFrank(keith) ::: Keith is frank.\n((Mushy(x) ∨ ¬Poised(x))) → ((Hungry(x) ∧ ¬Wicked(x))) ::: If someone is either mushy or not poised, then he is hungry and not wicked.\n((¬Poised(gregory))) → ((Mushy(shane))) ::: If Gregory is not poised, then Shane is mushy.\n(∃x (Wicked(x))) → ((¬Poised(shane) ∧ ¬Frank(george))) ::: If there is at least one people who is wicked, then Shane is not poised and George is not frank.\n((Teak(noel))) ↔ ((¬Poised(noel))) ::: If Noel is teak, then Noel is not poised, and vice versa.\n∃x (¬Not(x)) → (Teak(shane) ∧ ¬Poised(shane)) ::: If there is nobody who is not, then Shane is teak and Shane is not poised.\n((Poised(x) ∧ Mushy(x))) ↔ ((Poised(x))) ::: Someone is wicked and mushy if and only if he is poised.\n(∃x (Poised(x) ∨ ¬Hungry(x))) → ((¬Mushy(george))) ::: If there is at least one people who is poised or not hungry, then George is not mushy.\n(∃x (Wicked(x) ∧ ¬Teak(x))) → ((Poised(crosby))) ::: If there is at least one people who is both wicked and not teak, then Crosby is poised.\n((Teak(keith))) ↔ ((¬Poised(gregory) ∧ ¬Wicked(noel))) ::: Keith is teak if and only if Gregory is not poised and Noel is not wicked.\n((Teak(noel))) ↔ ((Hungry(shane))) ::: Noel is teak if and only if Shane is hungry.\n((¬Teak(gregory) ∧ Wicked(crosby))) → ((¬Mushy(keith))) ::: If Gregory is not teak and Crosby is wicked, then Keith is not mushy.\n(∃x (Hungry(x) ∧ Wicked(x))) → ((Teak(noel))) ::: If there is at least one people who is both hungry and wicked, then Noel is teak.\n",
            "First-Order-Logic Question": "Poised(noel) ::: Noel is poised."
        },
        "fixed": true
    },
    {
        "id": 149,
        "raw_prog": {
            "First-Order-Logic Rules": "¬Bewildered(abel) ::: Abel is not bewildered.\nCultural(aaron) ::: Aaron is cultural.\nCultural(seymour) ::: Seymour is cultural.\nAble(abel) ::: Abel is able.\nJolly(maurice) ::: Maurice is jolly.\nBewildered(cara) ::: Cara is bewildered.\nCultural(maurice) ::: Maurice is cultural.\nCultural(abel) ::: Abel is cultural.\n¬Jolly(algernon) ::: Algernon is not jolly.\n¬New(algernon) ::: Algernon is not new.\nBewildered(seymour) ::: Seymour is bewildered.\nNew(maurice) ::: Maurice is new.\n((¬Jolly(algernon) ∨ Able(maurice))) → (Cultural(cara)) ::: If Algernon is not jolly or Maurice is able, then Cara is cultural.\n(∃x (Bewildered(x) ∧ ¬Octagonal(x))) → (Jolly(algernon)) ::: If there is at least one people who is both bewildered and not octagonal, then Algernon is jolly.\n(∀x (¬New(x))) → (Bewildered(x) ∧ Cultural(x)) ::: Someone who is not new is always both bewildered and cultural.\n((Bewildered(abel))) ↔ (¬Jolly(algernon)) ::: If Abel is bewildered, then Algernon is not jolly, and vice versa.\n(∃x (¬New(x))) → (¬Jolly(lesley) ∧ Octagonal(lesley)) ::: If there is someone who is not new, then Lesley is not jolly and Lesley is octagonal.\n((Jolly(x) ∧ ¬Bewildered(x))) ↔ (¬Cultural(x)) ::: If someone is both jolly and not bewildered, then he is not cultural.\n(∃x (New(x) ∨ ¬Able(x))) → (¬Cultural(cara)) ::: If there is someone who is either new or not able, then Cara is not cultural.\n((¬Bewildered(x) ∧ ¬Able(x))) ↔ (Jolly(x)) ::: Someone being neither bewildered nor able is equivalent to being jolly.\n((Octagonal(x) ∧ ¬Cultural(x))) ↔ (Jolly(x) ∧ Bewildered(x)) ::: If someone is octagonal and not cultural, then he is both jolly and bewildered, and vice versa.\n(∃x (¬Bewildered(x))) → (Jolly(cara)) ::: If there is someone who is not bewildered, then Cara is jolly.\n(∀x ((¬Jolly(x) ∨ ¬Able(x))) → (New(x)) ::: Someone who is either not jolly or not able is always new.\n(∃x (Bewildered(x))) → (¬Cultural(lesley) ∧ Octagonal(seymour)) ::: If there is at least one people who is bewildered, then Lesley is not cultural and Seymour is octagonal.\n",
            "First-Order-Logic Question": "Bewildered(aaron) ::: Aaron is bewildered."
        },
        "gram_prog": {
            "First-Order-Logic Rules": "¬Bewildered(abel) ::: Abel is not bewildered.\nCultural(aaron) ::: Aaron is cultural.\nCultural(seymour) ::: Seymour is cultural.\nAble(abel) ::: Abel is able.\nJolly(maurice) ::: Maurice is jolly.\nBewildered(cara) ::: Cara is bewildered.\nCultural(maurice) ::: Maurice is cultural.\nCultural(abel) ::: Abel is cultural.\n¬Jolly(algernon) ::: Algernon is not jolly.\n¬New(algernon) ::: Algernon is not new.\nBewildered(seymour) ::: Seymour is bewildered.\nNew(maurice) ::: Maurice is new.\n((¬Jolly(algernon) ∨ Able(maurice))) → (Cultural(cara)) ::: If Algernon is not jolly or Maurice is able, then Cara is cultural.\n(∃x (Bewildered(x) ∧ ¬Octagonal(x))) → (Jolly(algernon)) ::: If there is at least one people who is both bewildered and not octagonal, then Algernon is jolly.\n(∀x (¬New(x))) → (Bewildered(x) ∧ Cultural(x)) ::: Someone who is not new is always both bewildered and cultural.\n((Bewildered(abel))) ↔ (¬Jolly(algernon)) ::: If Abel is bewildered, then Algernon is not jolly, and vice versa.\n(∃x (¬New(x))) → (¬Jolly(lesley) ∧ Octagonal(lesley)) ::: If there is someone who is not new, then Lesley is not jolly and Lesley is octagonal.\n((Jolly(x) ∧ ¬Bewildered(x))) ↔ (¬Cultural(x)) ::: If someone is both jolly and not bewildered, then he is not cultural.\n(∃x (New(x) ∨ ¬Able(x))) → (¬Cultural(cara)) ::: If there is someone who is either new or not able, then Cara is not cultural.\n((¬Bewildered(x) ∧ ¬Able(x))) ↔ (Jolly(x)) ::: Someone being neither bewildered nor able is equivalent to being jolly.\n((Octagonal(x) ∧ ¬Cultural(x))) ↔ (Jolly(x) ∧ Bewildered(x)) ::: If someone is octagonal and not cultural, then he is both jolly and bewildered, and vice versa.\n(∃x (¬Bewildered(x))) → (Jolly(cara)) ::: If there is someone who is not bewildered, then Cara is jolly.\n∀x((¬Blue(x)∨¬Serious(x))) ::: Someone who is either not jolly or not able is always new.\n(∃x (Bewildered(x))) → (¬Cultural(lesley) ∧ Octagonal(seymour)) ::: If there is at least one people who is bewildered, then Lesley is not cultural and Seymour is octagonal.\n",
            "First-Order-Logic Question": "Bewildered(aaron) ::: Aaron is bewildered."
        },
        "diff": [
            {
                "raw": "(∀x ((¬Jolly(x) ∨ ¬Able(x))) → (New(x)) ::: Someone who is either not jolly or not able is always new.",
                "gram": "∀x((¬Blue(x)∨¬Serious(x))) ::: Someone who is either not jolly or not able is always new."
            }
        ],
        "answer": "C",
        "grammar_answer": "A",
        "manual_prog": {
            "First-Order-Logic Rules": "¬Bewildered(abel) ::: Abel is not bewildered.\nCultural(aaron) ::: Aaron is cultural.\nCultural(seymour) ::: Seymour is cultural.\nAble(abel) ::: Abel is able.\nJolly(maurice) ::: Maurice is jolly.\nBewildered(cara) ::: Cara is bewildered.\nCultural(maurice) ::: Maurice is cultural.\nCultural(abel) ::: Abel is cultural.\n¬Jolly(algernon) ::: Algernon is not jolly.\n¬New(algernon) ::: Algernon is not new.\nBewildered(seymour) ::: Seymour is bewildered.\nNew(maurice) ::: Maurice is new.\n((¬Jolly(algernon) ∨ Able(maurice))) → (Cultural(cara)) ::: If Algernon is not jolly or Maurice is able, then Cara is cultural.\n(∃x (Bewildered(x) ∧ ¬Octagonal(x))) → (Jolly(algernon)) ::: If there is at least one people who is both bewildered and not octagonal, then Algernon is jolly.\n(∀x (¬New(x))) → (Bewildered(x) ∧ Cultural(x)) ::: Someone who is not new is always both bewildered and cultural.\n((Bewildered(abel))) ↔ (¬Jolly(algernon)) ::: If Abel is bewildered, then Algernon is not jolly, and vice versa.\n(∃x (¬New(x))) → (¬Jolly(lesley) ∧ Octagonal(lesley)) ::: If there is someone who is not new, then Lesley is not jolly and Lesley is octagonal.\n((Jolly(x) ∧ ¬Bewildered(x))) ↔ (¬Cultural(x)) ::: If someone is both jolly and not bewildered, then he is not cultural.\n(∃x (New(x) ∨ ¬Able(x))) → (¬Cultural(cara)) ::: If there is someone who is either new or not able, then Cara is not cultural.\n((¬Bewildered(x) ∧ ¬Able(x))) ↔ (Jolly(x)) ::: Someone being neither bewildered nor able is equivalent to being jolly.\n((Octagonal(x) ∧ ¬Cultural(x))) ↔ (Jolly(x) ∧ Bewildered(x)) ::: If someone is octagonal and not cultural, then he is both jolly and bewildered, and vice versa.\n(∃x (¬Bewildered(x))) → (Jolly(cara)) ::: If there is someone who is not bewildered, then Cara is jolly.\n(∀x ((¬Jolly(x) ∨ ¬Able(x))) → (New(x))) ::: Someone who is either not jolly or not able is always new.\n(∃x (Bewildered(x))) → (¬Cultural(lesley) ∧ Octagonal(seymour)) ::: If there is at least one people who is bewildered, then Lesley is not cultural and Seymour is octagonal.\n",
            "First-Order-Logic Question": "Bewildered(aaron) ::: Aaron is bewildered."
        },
        "fixed": true
    },
    {
        "id": 210,
        "raw_prog": {
            "First-Order-Logic Rules": "¬Soft(gregory) ::: Gregory is not soft.\n¬Significant(max) ::: Max is not significant.\nHollow(max) ::: Max is hollow.\n¬Significant(conrad) ::: Conrad is not significant.\n¬Significant(adler) ::: Adler is not significant.\nCombative(lamont) ::: Lamont is combative.\n¬Precious(max) ::: Max is not precious.\nHollow(cary) ::: Cary is hollow.\n¬Combative(adler) ::: Adler is not combative.\nSignificant(cary) ::: Cary is significant.\nSignificant(seymour) ::: Seymour is significant.\n¬Fearless(conrad) ::: Conrad is not fearless.\n(∀x ((Precious(x) ∧ ¬Significant(x)) ↔ (¬Soft(x))) ::: If someone is precious and not significant, then he is not soft, and vice versa.\n(∀x ((Fearless(x) ∧ ¬Precious(x)) ↔ (Significant(x))) ::: Someone being both fearless and not precious is equivalent to being significant.\n(∀x (Significant(x))) → (∀x (¬Fearless(x))) ::: Someone who is significant is always not fearless.\n(∀x (¬Precious(x))) → ((¬Hollow(x) ∧ ¬Soft(x))) ::: If someone is not precious, then he is neither hollow nor soft.\n(∀x ((Combative(x) ∧ Fearless(x)) ↔ (Significant(x) ∧ ¬Precious(x)))) ::: Someone being both combative and fearless is equivalent to being significant and not precious.\n(∀x ((¬Soft(x) ∨ ¬Significant(x)) → (Hollow(x)))) ::: If someone is not soft or not significant, then he is hollow.\n((¬Soft(seymour))) ↔ ((¬Combative(max) ∧ Hollow(gregory))) ::: Seymour being not soft is equivalent to Max being not combative and Gregory being hollow.\n(¬Precious(adler)) ↔ (Soft(lamont)) ::: Adler is not precious if and only if Lamont is soft.\n(∀x (¬Significant(x))) → (Hollow(x)) ::: All not significant people are hollow.\n(∀x (Fearless(x))) → (¬Significant(x)) ::: If someone is fearless, then he is not significant.\n((Hollow(adler))) → ((¬Fearless(adler) ∧ ¬Soft(lamont))) ::: If Adler is hollow, then Adler is not fearless and Lamont is not soft.\n((¬Hollow(lamont))) ↔ (Significant(max)) ::: Lamont is not hollow if and only if Max is significant.\n",
            "First-Order-Logic Question": "Significant(lamont) ::: Lamont is significant."
        },
        "gram_prog": {
            "First-Order-Logic Rules": "¬Soft(gregory) ::: Gregory is not soft.\n¬Significant(max) ::: Max is not significant.\nHollow(max) ::: Max is hollow.\n¬Significant(conrad) ::: Conrad is not significant.\n¬Significant(adler) ::: Adler is not significant.\nCombative(lamont) ::: Lamont is combative.\n¬Precious(max) ::: Max is not precious.\nHollow(cary) ::: Cary is hollow.\n¬Combative(adler) ::: Adler is not combative.\nSignificant(cary) ::: Cary is significant.\nSignificant(seymour) ::: Seymour is significant.\n¬Fearless(conrad) ::: Conrad is not fearless.\n∀x((Precious(x)∧¬Significant(x))) ::: If someone is precious and not significant, then he is not soft, and vice versa.\n∀x((Soft(x)∧¬Precious(x))) ::: Someone being both fearless and not precious is equivalent to being significant.\n(∀x (Significant(x))) → (∀x (¬Fearless(x))) ::: Someone who is significant is always not fearless.\n(∀x (¬Precious(x))) → ((¬Hollow(x) ∧ ¬Soft(x))) ::: If someone is not precious, then he is neither hollow nor soft.\n(∀x ((Combative(x) ∧ Fearless(x)) ↔ (Significant(x) ∧ ¬Precious(x)))) ::: Someone being both combative and fearless is equivalent to being significant and not precious.\n(∀x ((¬Soft(x) ∨ ¬Significant(x)) → (Hollow(x)))) ::: If someone is not soft or not significant, then he is hollow.\n((¬Soft(seymour))) ↔ ((¬Combative(max) ∧ Hollow(gregory))) ::: Seymour being not soft is equivalent to Max being not combative and Gregory being hollow.\n(¬Precious(adler)) ↔ (Soft(lamont)) ::: Adler is not precious if and only if Lamont is soft.\n(∀x (¬Significant(x))) → (Hollow(x)) ::: All not significant people are hollow.\n(∀x (Fearless(x))) → (¬Significant(x)) ::: If someone is fearless, then he is not significant.\n((Hollow(adler))) → ((¬Fearless(adler) ∧ ¬Soft(lamont))) ::: If Adler is hollow, then Adler is not fearless and Lamont is not soft.\n((¬Hollow(lamont))) ↔ (Significant(max)) ::: Lamont is not hollow if and only if Max is significant.\n",
            "First-Order-Logic Question": "Significant(lamont) ::: Lamont is significant."
        },
        "diff": [
            {
                "raw": "(∀x ((Precious(x) ∧ ¬Significant(x)) ↔ (¬Soft(x))) ::: If someone is precious and not significant, then he is not soft, and vice versa.",
                "gram": "∀x((Precious(x)∧¬Significant(x))) ::: If someone is precious and not significant, then he is not soft, and vice versa."
            },
            {
                "raw": "(∀x ((Fearless(x) ∧ ¬Precious(x)) ↔ (Significant(x))) ::: Someone being both fearless and not precious is equivalent to being significant.",
                "gram": "∀x((Soft(x)∧¬Precious(x))) ::: Someone being both fearless and not precious is equivalent to being significant."
            }
        ],
        "answer": "B",
        "grammar_answer": "A",
        "manual_prog": {
            "First-Order-Logic Rules": "¬Soft(gregory) ::: Gregory is not soft.\n¬Significant(max) ::: Max is not significant.\nHollow(max) ::: Max is hollow.\n¬Significant(conrad) ::: Conrad is not significant.\n¬Significant(adler) ::: Adler is not significant.\nCombative(lamont) ::: Lamont is combative.\n¬Precious(max) ::: Max is not precious.\nHollow(cary) ::: Cary is hollow.\n¬Combative(adler) ::: Adler is not combative.\nSignificant(cary) ::: Cary is significant.\nSignificant(seymour) ::: Seymour is significant.\n¬Fearless(conrad) ::: Conrad is not fearless.\n(∀x ((Precious(x) ∧ ¬Significant(x)) ↔ (¬Soft(x)))) ::: If someone is precious and not significant, then he is not soft, and vice versa.\n(∀x ((Fearless(x) ∧ ¬Precious(x)) ↔ (Significant(x)))) ::: Someone being both fearless and not precious is equivalent to being significant.\n(∀x (Significant(x))) → (∀x (¬Fearless(x))) ::: Someone who is significant is always not fearless.\n(∀x (¬Precious(x))) → ((¬Hollow(x) ∧ ¬Soft(x))) ::: If someone is not precious, then he is neither hollow nor soft.\n(∀x ((Combative(x) ∧ Fearless(x)) ↔ (Significant(x) ∧ ¬Precious(x)))) ::: Someone being both combative and fearless is equivalent to being significant and not precious.\n(∀x ((¬Soft(x) ∨ ¬Significant(x)) → (Hollow(x)))) ::: If someone is not soft or not significant, then he is hollow.\n((¬Soft(seymour))) ↔ ((¬Combative(max) ∧ Hollow(gregory))) ::: Seymour being not soft is equivalent to Max being not combative and Gregory being hollow.\n(¬Precious(adler)) ↔ (Soft(lamont)) ::: Adler is not precious if and only if Lamont is soft.\n(∀x (¬Significant(x))) → (Hollow(x)) ::: All not significant people are hollow.\n(∀x (Fearless(x))) → (¬Significant(x)) ::: If someone is fearless, then he is not significant.\n((Hollow(adler))) → ((¬Fearless(adler) ∧ ¬Soft(lamont))) ::: If Adler is hollow, then Adler is not fearless and Lamont is not soft.\n((¬Hollow(lamont))) ↔ (Significant(max)) ::: Lamont is not hollow if and only if Max is significant.\n",
            "First-Order-Logic Question": "Significant(lamont) ::: Lamont is significant."
        },
        "fixed": true
    },
    {
        "id": 212,
        "raw_prog": {
            "First-Order-Logic Rules": "¬Soft(gregory) ::: Gregory is not soft.\n¬Significant(max) ::: Max is not significant.\nHollow(max) ::: Max is hollow.\n¬Significant(conrad) ::: Conrad is not significant.\n¬Significant(adler) ::: Adler is not significant.\nCombative(lamont) ::: Lamont is combative.\n¬Precious(max) ::: Max is not precious.\nHollow(cary) ::: Cary is hollow.\n¬Combative(adler) ::: Adler is not combative.\nSignificant(cary) ::: Cary is significant.\nSignificant(seymour) ::: Seymour is significant.\n¬Fearless(conrad) ::: Conrad is not fearless.\n(∀x ((Precious(x) ∧ ¬Significant(x)) ↔ (¬Soft(x))) ::: If someone is precious and not significant, then he is not soft, and vice versa.\n(∀x ((Fearless(x) ∧ ¬Precious(x)) ↔ (Significant(x))) ::: Someone being both fearless and not precious is equivalent to being significant.\n(∀x (Significant(x))) → (∀x (¬Fearless(x))) ::: Someone who is significant is always not fearless.\n(∀x (¬Precious(x))) → ((¬Hollow(x) ∧ ¬Soft(x))) ::: If someone is not precious, then he is neither hollow nor soft.\n(∀x ((Combative(x) ∧ Fearless(x)) ↔ (Significant(x) ∧ ¬Precious(x))) ::: Someone being both combative and fearless is equivalent to being significant and not precious.\n(∀x (¬Soft(x) ∨ ¬Significant(x))) → (Hollow(x)) ::: If someone is not soft or not significant, then he is hollow.\n(¬Soft(seymour)) ↔ (¬Combative(max) ∧ Hollow(gregory)) ::: Seymour being not soft is equivalent to Max being not combative and Gregory being hollow.\n(¬Precious(adler)) ↔ (Soft(lamont)) ::: Adler is not precious if and only if Lamont is soft.\n(∀x (¬Significant(x))) → (Hollow(x)) ::: All not significant people are hollow.\n(∀x (Fearless(x))) → (¬Significant(x)) ::: If someone is fearless, then he is not significant.\n(Hollow(adler)) → (¬Fearless(adler) ∧ ¬Soft(lamont)) ::: If Adler is hollow, then Adler is not fearless and Lamont is not soft.\n(¬Hollow(lamont)) ↔ (Significant(max)) ::: Lamont is not hollow if and only if Max is significant.\n",
            "First-Order-Logic Question": "¬Hollow(lamont) ::: Lamont is not hollow."
        },
        "gram_prog": {
            "First-Order-Logic Rules": "¬Soft(gregory) ::: Gregory is not soft.\n¬Significant(max) ::: Max is not significant.\nHollow(max) ::: Max is hollow.\n¬Significant(conrad) ::: Conrad is not significant.\n¬Significant(adler) ::: Adler is not significant.\nCombative(lamont) ::: Lamont is combative.\n¬Precious(max) ::: Max is not precious.\nHollow(cary) ::: Cary is hollow.\n¬Combative(adler) ::: Adler is not combative.\nSignificant(cary) ::: Cary is significant.\nSignificant(seymour) ::: Seymour is significant.\n¬Fearless(conrad) ::: Conrad is not fearless.\n∀x((Precious(x)∧¬Significant(x))) ::: If someone is precious and not significant, then he is not soft, and vice versa.\n∀x((Soft(x)∧¬Precious(x))) ::: Someone being both fearless and not precious is equivalent to being significant.\n(∀x (Significant(x))) → (∀x (¬Fearless(x))) ::: Someone who is significant is always not fearless.\n(∀x (¬Precious(x))) → ((¬Hollow(x) ∧ ¬Soft(x))) ::: If someone is not precious, then he is neither hollow nor soft.\n∀x((Combative(x)∧Fearless(x))) ::: Someone being both combative and fearless is equivalent to being significant and not precious.\n(∀x (¬Soft(x) ∨ ¬Significant(x))) → (Hollow(x)) ::: If someone is not soft or not significant, then he is hollow.\n(¬Soft(seymour)) ↔ (¬Combative(max) ∧ Hollow(gregory)) ::: Seymour being not soft is equivalent to Max being not combative and Gregory being hollow.\n(¬Precious(adler)) ↔ (Soft(lamont)) ::: Adler is not precious if and only if Lamont is soft.\n(∀x (¬Significant(x))) → (Hollow(x)) ::: All not significant people are hollow.\n(∀x (Fearless(x))) → (¬Significant(x)) ::: If someone is fearless, then he is not significant.\n(Hollow(adler)) → (¬Fearless(adler) ∧ ¬Soft(lamont)) ::: If Adler is hollow, then Adler is not fearless and Lamont is not soft.\n(¬Hollow(lamont)) ↔ (Significant(max)) ::: Lamont is not hollow if and only if Max is significant.\n",
            "First-Order-Logic Question": "¬Hollow(lamont) ::: Lamont is not hollow."
        },
        "diff": [
            {
                "raw": "(∀x ((Precious(x) ∧ ¬Significant(x)) ↔ (¬Soft(x))) ::: If someone is precious and not significant, then he is not soft, and vice versa.",
                "gram": "∀x((Precious(x)∧¬Significant(x))) ::: If someone is precious and not significant, then he is not soft, and vice versa."
            },
            {
                "raw": "(∀x ((Fearless(x) ∧ ¬Precious(x)) ↔ (Significant(x))) ::: Someone being both fearless and not precious is equivalent to being significant.",
                "gram": "∀x((Soft(x)∧¬Precious(x))) ::: Someone being both fearless and not precious is equivalent to being significant."
            },
            {
                "raw": "(∀x ((Combative(x) ∧ Fearless(x)) ↔ (Significant(x) ∧ ¬Precious(x))) ::: Someone being both combative and fearless is equivalent to being significant and not precious.",
                "gram": "∀x((Combative(x)∧Fearless(x))) ::: Someone being both combative and fearless is equivalent to being significant and not precious."
            }
        ],
        "answer": "B",
        "grammar_answer": "A",
        "manual_prog": {
            "First-Order-Logic Rules": "¬Soft(gregory) ::: Gregory is not soft.\n¬Significant(max) ::: Max is not significant.\nHollow(max) ::: Max is hollow.\n¬Significant(conrad) ::: Conrad is not significant.\n¬Significant(adler) ::: Adler is not significant.\nCombative(lamont) ::: Lamont is combative.\n¬Precious(max) ::: Max is not precious.\nHollow(cary) ::: Cary is hollow.\n¬Combative(adler) ::: Adler is not combative.\nSignificant(cary) ::: Cary is significant.\nSignificant(seymour) ::: Seymour is significant.\n¬Fearless(conrad) ::: Conrad is not fearless.\n(∀x ((Precious(x) ∧ ¬Significant(x)) ↔ (¬Soft(x)))) ::: If someone is precious and not significant, then he is not soft, and vice versa.\n(∀x ((Fearless(x) ∧ ¬Precious(x)) ↔ (Significant(x)))) ::: Someone being both fearless and not precious is equivalent to being significant.\n(∀x (Significant(x))) → (∀x (¬Fearless(x))) ::: Someone who is significant is always not fearless.\n(∀x (¬Precious(x))) → ((¬Hollow(x) ∧ ¬Soft(x))) ::: If someone is not precious, then he is neither hollow nor soft.\n(∀x ((Combative(x) ∧ Fearless(x)) ↔ (Significant(x) ∧ ¬Precious(x)))) ::: Someone being both combative and fearless is equivalent to being significant and not precious.\n(∀x (¬Soft(x) ∨ ¬Significant(x))) → (Hollow(x)) ::: If someone is not soft or not significant, then he is hollow.\n(¬Soft(seymour)) ↔ (¬Combative(max) ∧ Hollow(gregory)) ::: Seymour being not soft is equivalent to Max being not combative and Gregory being hollow.\n(¬Precious(adler)) ↔ (Soft(lamont)) ::: Adler is not precious if and only if Lamont is soft.\n(∀x (¬Significant(x))) → (Hollow(x)) ::: All not significant people are hollow.\n(∀x (Fearless(x))) → (¬Significant(x)) ::: If someone is fearless, then he is not significant.\n(Hollow(adler)) → (¬Fearless(adler) ∧ ¬Soft(lamont)) ::: If Adler is hollow, then Adler is not fearless and Lamont is not soft.\n(¬Hollow(lamont)) ↔ (Significant(max)) ::: Lamont is not hollow if and only if Max is significant.\n",
            "First-Order-Logic Question": "¬Hollow(lamont) ::: Lamont is not hollow."
        },
        "fixed": true
    },
    {
        "id": 215,
        "raw_prog": {
            "First-Order-Logic Rules": "¬Soft(gregory) ::: Gregory is not soft.\n¬Significant(max) ::: Max is not significant.\nHollow(max) ::: Max is hollow.\n¬Significant(conrad) ::: Conrad is not significant.\n¬Significant(adler) ::: Adler is not significant.\nCombative(lamont) ::: Lamont is combative.\n¬Precious(max) ::: Max is not precious.\nHollow(cary) ::: Cary is hollow.\n¬Combative(adler) ::: Adler is not combative.\nSignificant(cary) ::: Cary is significant.\nSignificant(seymour) ::: Seymour is significant.\n¬Fearless(conrad) ::: Conrad is not fearless.\n(∀x ((Precious(x) ∧ ¬Significant(x)) ↔ (¬Soft(x))) ::: If someone is precious and not significant, then he is not soft, and vice versa.\n(∀x ((Fearless(x) ∧ ¬Precious(x)) ↔ (Significant(x))) ::: Someone being both fearless and not precious is equivalent to being significant.\n(∀x (Significant(x))) → (∀x (¬Fearless(x))) ::: Someone who is significant is always not fearless.\n(∀x (¬Precious(x))) → ((¬Hollow(x) ∧ ¬Soft(x))) ::: If someone is not precious, then he is neither hollow nor soft.\n(∀x ((Combative(x) ∧ Fearless(x)) ↔ (Significant(x) ∧ ¬Precious(x)))) ::: Someone being both combative and fearless is equivalent to being significant and not precious.\n(∀x ((¬Soft(x) ↔ (¬Combative(max) ∧ Hollow(gregory))))) ::: Seymour being not soft is equivalent to Max being not combative and Gregory being hollow.\n(∀x (¬Precious(adler))) ↔ (Soft(lamont)) ::: Adler is not precious if and only if Lamont is soft.\n(∀x (¬Significant(x))) → (Hollow(x)) ::: All not significant people are hollow.\n(∀x (Fearless(x))) → (¬Significant(x)) ::: If someone is fearless, then he is not significant.\n((Hollow(adler))) → ((¬Fearless(adler) ∧ ¬Soft(lamont))) ::: If Adler is hollow, then Adler is not fearless and Lamont is not soft.\n(∀x (¬Hollow(lamont))) ↔ (Significant(max)) ::: Lamont is not hollow if and only if Max is significant.\n",
            "First-Order-Logic Question": "¬Precious(adler) ::: Adler is not precious."
        },
        "gram_prog": {
            "First-Order-Logic Rules": "¬Soft(gregory) ::: Gregory is not soft.\n¬Significant(max) ::: Max is not significant.\nHollow(max) ::: Max is hollow.\n¬Significant(conrad) ::: Conrad is not significant.\n¬Significant(adler) ::: Adler is not significant.\nCombative(lamont) ::: Lamont is combative.\n¬Precious(max) ::: Max is not precious.\nHollow(cary) ::: Cary is hollow.\n¬Combative(adler) ::: Adler is not combative.\nSignificant(cary) ::: Cary is significant.\nSignificant(seymour) ::: Seymour is significant.\n¬Fearless(conrad) ::: Conrad is not fearless.\n∀x((Precious(x)∧¬Significant(x))) ::: If someone is precious and not significant, then he is not soft, and vice versa.\n∀x((Soft(x)∧¬Precious(x))) ::: Someone being both fearless and not precious is equivalent to being significant.\n(∀x (Significant(x))) → (∀x (¬Fearless(x))) ::: Someone who is significant is always not fearless.\n(∀x (¬Precious(x))) → ((¬Hollow(x) ∧ ¬Soft(x))) ::: If someone is not precious, then he is neither hollow nor soft.\n(∀x ((Combative(x) ∧ Fearless(x)) ↔ (Significant(x) ∧ ¬Precious(x)))) ::: Someone being both combative and fearless is equivalent to being significant and not precious.\n(∀x ((¬Soft(x) ↔ (¬Combative(max) ∧ Hollow(gregory))))) ::: Seymour being not soft is equivalent to Max being not combative and Gregory being hollow.\n(∀x (¬Precious(adler))) ↔ (Soft(lamont)) ::: Adler is not precious if and only if Lamont is soft.\n(∀x (¬Significant(x))) → (Hollow(x)) ::: All not significant people are hollow.\n(∀x (Fearless(x))) → (¬Significant(x)) ::: If someone is fearless, then he is not significant.\n((Hollow(adler))) → ((¬Fearless(adler) ∧ ¬Soft(lamont))) ::: If Adler is hollow, then Adler is not fearless and Lamont is not soft.\n(∀x (¬Hollow(lamont))) ↔ (Significant(max)) ::: Lamont is not hollow if and only if Max is significant.\n",
            "First-Order-Logic Question": "¬Precious(adler) ::: Adler is not precious."
        },
        "diff": [
            {
                "raw": "(∀x ((Precious(x) ∧ ¬Significant(x)) ↔ (¬Soft(x))) ::: If someone is precious and not significant, then he is not soft, and vice versa.",
                "gram": "∀x((Precious(x)∧¬Significant(x))) ::: If someone is precious and not significant, then he is not soft, and vice versa."
            },
            {
                "raw": "(∀x ((Fearless(x) ∧ ¬Precious(x)) ↔ (Significant(x))) ::: Someone being both fearless and not precious is equivalent to being significant.",
                "gram": "∀x((Soft(x)∧¬Precious(x))) ::: Someone being both fearless and not precious is equivalent to being significant."
            }
        ],
        "answer": "C",
        "grammar_answer": "A",
        "manual_prog": {
            "First-Order-Logic Rules": "¬Soft(gregory) ::: Gregory is not soft.\n¬Significant(max) ::: Max is not significant.\nHollow(max) ::: Max is hollow.\n¬Significant(conrad) ::: Conrad is not significant.\n¬Significant(adler) ::: Adler is not significant.\nCombative(lamont) ::: Lamont is combative.\n¬Precious(max) ::: Max is not precious.\nHollow(cary) ::: Cary is hollow.\n¬Combative(adler) ::: Adler is not combative.\nSignificant(cary) ::: Cary is significant.\nSignificant(seymour) ::: Seymour is significant.\n¬Fearless(conrad) ::: Conrad is not fearless.\n(∀x ((Precious(x) ∧ ¬Significant(x)) ↔ (¬Soft(x)))) ::: If someone is precious and not significant, then he is not soft, and vice versa.\n(∀x ((Fearless(x) ∧ ¬Precious(x)) ↔ (Significant(x)))) ::: Someone being both fearless and not precious is equivalent to being significant.\n(∀x (Significant(x))) → (∀x (¬Fearless(x))) ::: Someone who is significant is always not fearless.\n(∀x (¬Precious(x))) → ((¬Hollow(x) ∧ ¬Soft(x))) ::: If someone is not precious, then he is neither hollow nor soft.\n(∀x ((Combative(x) ∧ Fearless(x)) ↔ (Significant(x) ∧ ¬Precious(x)))) ::: Someone being both combative and fearless is equivalent to being significant and not precious.\n(∀x ((¬Soft(x) ↔ (¬Combative(max) ∧ Hollow(gregory))))) ::: Seymour being not soft is equivalent to Max being not combative and Gregory being hollow.\n(∀x (¬Precious(adler))) ↔ (Soft(lamont)) ::: Adler is not precious if and only if Lamont is soft.\n(∀x (¬Significant(x))) → (Hollow(x)) ::: All not significant people are hollow.\n(∀x (Fearless(x))) → (¬Significant(x)) ::: If someone is fearless, then he is not significant.\n((Hollow(adler))) → ((¬Fearless(adler) ∧ ¬Soft(lamont))) ::: If Adler is hollow, then Adler is not fearless and Lamont is not soft.\n(∀x (¬Hollow(lamont))) ↔ (Significant(max)) ::: Lamont is not hollow if and only if Max is significant.\n",
            "First-Order-Logic Question": "¬Precious(adler) ::: Adler is not precious."
        },
        "fixed": true
    },
    {
        "id": 216,
        "raw_prog": {
            "First-Order-Logic Rules": "¬Soft(gregory) ::: Gregory is not soft.\n¬Significant(max) ::: Max is not significant.\nHollow(max) ::: Max is hollow.\n¬Significant(conrad) ::: Conrad is not significant.\n¬Significant(adler) ::: Adler is not significant.\nCombative(lamont) ::: Lamont is combative.\n¬Precious(max) ::: Max is not precious.\nHollow(cary) ::: Cary is hollow.\n¬Combative(adler) ::: Adler is not combative.\nSignificant(cary) ::: Cary is significant.\nSignificant(seymour) ::: Seymour is significant.\n¬Fearless(conrad) ::: Conrad is not fearless.\n(∀x ((Precious(x) ∧ ¬Significant(x)) ↔ (¬Soft(x))) ::: If someone is precious and not significant, then he is not soft, and vice versa.\n(∀x ((Fearless(x) ∧ ¬Precious(x)) ↔ Significant(x))) ::: Someone being both fearless and not precious is equivalent to being significant.\n(∀x (Significant(x))) → (∀x (¬Fearless(x))) ::: Someone who is significant is always not fearless.\n(∀x (¬Precious(x))) → ((¬Hollow(x) ∧ ¬Soft(x))) ::: If someone is not precious, then he is neither hollow nor soft.\n(∀x ((Combative(x) ∧ Fearless(x)) ↔ (Significant(x) ∧ ¬Precious(x)))) ::: Someone being both combative and fearless is equivalent to being significant and not precious.\n(∀x ((¬Soft(x) ↔ (¬Combative(max) ∧ Hollow(gregory))))) ::: Seymour being not soft is equivalent to Max being not combative and Gregory being hollow.\n(¬Precious(adler)) ↔ (Soft(lamont)) ::: Adler is not precious if and only if Lamont is soft.\n(∀x (¬Significant(x))) → (Hollow(x)) ::: All not significant people are hollow.\n(∀x (Fearless(x))) → (¬Significant(x)) ::: If someone is fearless, then he is not significant.\n(Hollow(adler)) → ((¬Fearless(adler) ∧ ¬Soft(lamont))) ::: If Adler is hollow, then Adler is not fearless and Lamont is not soft.\n(¬Hollow(lamont)) ↔ (Significant(max)) ::: Lamont is not hollow if and only if Max is significant.\n",
            "First-Order-Logic Question": "¬Hollow(gregory) ::: Gregory is not hollow."
        },
        "gram_prog": {
            "First-Order-Logic Rules": "¬Soft(gregory) ::: Gregory is not soft.\n¬Significant(max) ::: Max is not significant.\nHollow(max) ::: Max is hollow.\n¬Significant(conrad) ::: Conrad is not significant.\n¬Significant(adler) ::: Adler is not significant.\nCombative(lamont) ::: Lamont is combative.\n¬Precious(max) ::: Max is not precious.\nHollow(cary) ::: Cary is hollow.\n¬Combative(adler) ::: Adler is not combative.\nSignificant(cary) ::: Cary is significant.\nSignificant(seymour) ::: Seymour is significant.\n¬Fearless(conrad) ::: Conrad is not fearless.\n∀x((Precious(x)∧¬Significant(x))) ::: If someone is precious and not significant, then he is not soft, and vice versa.\n(∀x ((Fearless(x) ∧ ¬Precious(x)) ↔ Significant(x))) ::: Someone being both fearless and not precious is equivalent to being significant.\n(∀x (Significant(x))) → (∀x (¬Fearless(x))) ::: Someone who is significant is always not fearless.\n(∀x (¬Precious(x))) → ((¬Hollow(x) ∧ ¬Soft(x))) ::: If someone is not precious, then he is neither hollow nor soft.\n(∀x ((Combative(x) ∧ Fearless(x)) ↔ (Significant(x) ∧ ¬Precious(x)))) ::: Someone being both combative and fearless is equivalent to being significant and not precious.\n(∀x ((¬Soft(x) ↔ (¬Combative(max) ∧ Hollow(gregory))))) ::: Seymour being not soft is equivalent to Max being not combative and Gregory being hollow.\n(¬Precious(adler)) ↔ (Soft(lamont)) ::: Adler is not precious if and only if Lamont is soft.\n(∀x (¬Significant(x))) → (Hollow(x)) ::: All not significant people are hollow.\n(∀x (Fearless(x))) → (¬Significant(x)) ::: If someone is fearless, then he is not significant.\n(Hollow(adler)) → ((¬Fearless(adler) ∧ ¬Soft(lamont))) ::: If Adler is hollow, then Adler is not fearless and Lamont is not soft.\n(¬Hollow(lamont)) ↔ (Significant(max)) ::: Lamont is not hollow if and only if Max is significant.\n",
            "First-Order-Logic Question": "¬Hollow(gregory) ::: Gregory is not hollow."
        },
        "diff": [
            {
                "raw": "(∀x ((Precious(x) ∧ ¬Significant(x)) ↔ (¬Soft(x))) ::: If someone is precious and not significant, then he is not soft, and vice versa.",
                "gram": "∀x((Precious(x)∧¬Significant(x))) ::: If someone is precious and not significant, then he is not soft, and vice versa."
            }
        ],
        "answer": "B",
        "grammar_answer": "A",
        "manual_prog": {
            "First-Order-Logic Rules": "¬Soft(gregory) ::: Gregory is not soft.\n¬Significant(max) ::: Max is not significant.\nHollow(max) ::: Max is hollow.\n¬Significant(conrad) ::: Conrad is not significant.\n¬Significant(adler) ::: Adler is not significant.\nCombative(lamont) ::: Lamont is combative.\n¬Precious(max) ::: Max is not precious.\nHollow(cary) ::: Cary is hollow.\n¬Combative(adler) ::: Adler is not combative.\nSignificant(cary) ::: Cary is significant.\nSignificant(seymour) ::: Seymour is significant.\n¬Fearless(conrad) ::: Conrad is not fearless.\n(∀x ((Precious(x) ∧ ¬Significant(x)) ↔ (¬Soft(x)))) ::: If someone is precious and not significant, then he is not soft, and vice versa.\n(∀x ((Fearless(x) ∧ ¬Precious(x)) ↔ Significant(x))) ::: Someone being both fearless and not precious is equivalent to being significant.\n(∀x (Significant(x))) → (∀x (¬Fearless(x))) ::: Someone who is significant is always not fearless.\n(∀x (¬Precious(x))) → ((¬Hollow(x) ∧ ¬Soft(x))) ::: If someone is not precious, then he is neither hollow nor soft.\n(∀x ((Combative(x) ∧ Fearless(x)) ↔ (Significant(x) ∧ ¬Precious(x)))) ::: Someone being both combative and fearless is equivalent to being significant and not precious.\n(∀x ((¬Soft(x) ↔ (¬Combative(max) ∧ Hollow(gregory))))) ::: Seymour being not soft is equivalent to Max being not combative and Gregory being hollow.\n(¬Precious(adler)) ↔ (Soft(lamont)) ::: Adler is not precious if and only if Lamont is soft.\n(∀x (¬Significant(x))) → (Hollow(x)) ::: All not significant people are hollow.\n(∀x (Fearless(x))) → (¬Significant(x)) ::: If someone is fearless, then he is not significant.\n(Hollow(adler)) → ((¬Fearless(adler) ∧ ¬Soft(lamont))) ::: If Adler is hollow, then Adler is not fearless and Lamont is not soft.\n(¬Hollow(lamont)) ↔ (Significant(max)) ::: Lamont is not hollow if and only if Max is significant.\n",
            "First-Order-Logic Question": "¬Hollow(gregory) ::: Gregory is not hollow."
        },
        "fixed": true
    },
    {
        "id": 217,
        "raw_prog": {
            "First-Order-Logic Rules": "¬Soft(gregory) ::: Gregory is not soft.\n¬Significant(max) ::: Max is not significant.\nHollow(max) ::: Max is hollow.\n¬Significant(conrad) ::: Conrad is not significant.\n¬Significant(adler) ::: Adler is not significant.\nCombative(lamont) ::: Lamont is combative.\n¬Precious(max) ::: Max is not precious.\nHollow(cary) ::: Cary is hollow.\n¬Combative(adler) ::: Adler is not combative.\nSignificant(cary) ::: Cary is significant.\nSignificant(seymour) ::: Seymour is significant.\n¬Fearless(conrad) ::: Conrad is not fearless.\n(∀x ((Precious(x) ∧ ¬Significant(x)) ↔ (¬Soft(x))) ::: If someone is precious and not significant, then he is not soft, and vice versa.\n(∀x ((Fearless(x) ∧ ¬Precious(x)) ↔ (Significant(x))) ::: Someone being both fearless and not precious is equivalent to being significant.\n(∀x (Significant(x))) → (∀x (¬Fearless(x))) ::: Someone who is significant is always not fearless.\n(∀x (¬Precious(x))) → ((¬Hollow(x) ∧ ¬Soft(x))) ::: If someone is not precious, then he is neither hollow nor soft.\n(∀x ((Combative(x) ∧ Fearless(x)) ↔ (Significant(x) ∧ ¬Precious(x))) ::: Someone being both combative and fearless is equivalent to being significant and not precious.\n(∀x (¬Soft(x) ∨ ¬Significant(x))) → (Hollow(x)) ::: If someone is not soft or not significant, then he is hollow.\n((¬Soft(seymour))) ↔ ((¬Combative(max) ∧ Hollow(gregory))) ::: Seymour being not soft is equivalent to Max being not combative and Gregory being hollow.\n(¬Precious(adler)) ↔ (Soft(lamont)) ::: Adler is not precious if and only if Lamont is soft.\n(∀x (¬Significant(x))) → (Hollow(x)) ::: All not significant people are hollow.\n(∀x (Fearless(x))) → (¬Significant(x)) ::: If someone is fearless, then he is not significant.\n(¬Hollow(adler)) → ((¬Fearless(adler) ∧ ¬Soft(lamont))) ::: If Adler is hollow, then Adler is not fearless and Lamont is not soft.\n((¬Hollow(lamont))) ↔ (Significant(max)) ::: Lamont is not hollow if and only if Max is significant.\n",
            "First-Order-Logic Question": "Significant(adler) ::: Adler is significant."
        },
        "gram_prog": {
            "First-Order-Logic Rules": "¬Soft(gregory) ::: Gregory is not soft.\n¬Significant(max) ::: Max is not significant.\nHollow(max) ::: Max is hollow.\n¬Significant(conrad) ::: Conrad is not significant.\n¬Significant(adler) ::: Adler is not significant.\nCombative(lamont) ::: Lamont is combative.\n¬Precious(max) ::: Max is not precious.\nHollow(cary) ::: Cary is hollow.\n¬Combative(adler) ::: Adler is not combative.\nSignificant(cary) ::: Cary is significant.\nSignificant(seymour) ::: Seymour is significant.\n¬Fearless(conrad) ::: Conrad is not fearless.\n∀x((Precious(x)∧¬Significant(x))) ::: If someone is precious and not significant, then he is not soft, and vice versa.\n∀x((Soft(x)∧¬Precious(x))) ::: Someone being both fearless and not precious is equivalent to being significant.\n(∀x (Significant(x))) → (∀x (¬Fearless(x))) ::: Someone who is significant is always not fearless.\n(∀x (¬Precious(x))) → ((¬Hollow(x) ∧ ¬Soft(x))) ::: If someone is not precious, then he is neither hollow nor soft.\n∀x((Combative(x)∧Fearless(x))) ::: Someone being both combative and fearless is equivalent to being significant and not precious.\n(∀x (¬Soft(x) ∨ ¬Significant(x))) → (Hollow(x)) ::: If someone is not soft or not significant, then he is hollow.\n((¬Soft(seymour))) ↔ ((¬Combative(max) ∧ Hollow(gregory))) ::: Seymour being not soft is equivalent to Max being not combative and Gregory being hollow.\n(¬Precious(adler)) ↔ (Soft(lamont)) ::: Adler is not precious if and only if Lamont is soft.\n(∀x (¬Significant(x))) → (Hollow(x)) ::: All not significant people are hollow.\n(∀x (Fearless(x))) → (¬Significant(x)) ::: If someone is fearless, then he is not significant.\n(¬Hollow(adler)) → ((¬Fearless(adler) ∧ ¬Soft(lamont))) ::: If Adler is hollow, then Adler is not fearless and Lamont is not soft.\n((¬Hollow(lamont))) ↔ (Significant(max)) ::: Lamont is not hollow if and only if Max is significant.\n",
            "First-Order-Logic Question": "Significant(adler) ::: Adler is significant."
        },
        "diff": [
            {
                "raw": "(∀x ((Precious(x) ∧ ¬Significant(x)) ↔ (¬Soft(x))) ::: If someone is precious and not significant, then he is not soft, and vice versa.",
                "gram": "∀x((Precious(x)∧¬Significant(x))) ::: If someone is precious and not significant, then he is not soft, and vice versa."
            },
            {
                "raw": "(∀x ((Fearless(x) ∧ ¬Precious(x)) ↔ (Significant(x))) ::: Someone being both fearless and not precious is equivalent to being significant.",
                "gram": "∀x((Soft(x)∧¬Precious(x))) ::: Someone being both fearless and not precious is equivalent to being significant."
            },
            {
                "raw": "(∀x ((Combative(x) ∧ Fearless(x)) ↔ (Significant(x) ∧ ¬Precious(x))) ::: Someone being both combative and fearless is equivalent to being significant and not precious.",
                "gram": "∀x((Combative(x)∧Fearless(x))) ::: Someone being both combative and fearless is equivalent to being significant and not precious."
            }
        ],
        "answer": "B",
        "grammar_answer": "A",
        "manual_prog": {
            "First-Order-Logic Rules": "¬Soft(gregory) ::: Gregory is not soft.\n¬Significant(max) ::: Max is not significant.\nHollow(max) ::: Max is hollow.\n¬Significant(conrad) ::: Conrad is not significant.\n¬Significant(adler) ::: Adler is not significant.\nCombative(lamont) ::: Lamont is combative.\n¬Precious(max) ::: Max is not precious.\nHollow(cary) ::: Cary is hollow.\n¬Combative(adler) ::: Adler is not combative.\nSignificant(cary) ::: Cary is significant.\nSignificant(seymour) ::: Seymour is significant.\n¬Fearless(conrad) ::: Conrad is not fearless.\n(∀x ((Precious(x) ∧ ¬Significant(x)) ↔ (¬Soft(x)))) ::: If someone is precious and not significant, then he is not soft, and vice versa.\n(∀x ((Fearless(x) ∧ ¬Precious(x)) ↔ (Significant(x)))) ::: Someone being both fearless and not precious is equivalent to being significant.\n(∀x (Significant(x))) → (∀x (¬Fearless(x))) ::: Someone who is significant is always not fearless.\n(∀x (¬Precious(x))) → ((¬Hollow(x) ∧ ¬Soft(x))) ::: If someone is not precious, then he is neither hollow nor soft.\n(∀x ((Combative(x) ∧ Fearless(x)) ↔ (Significant(x) ∧ ¬Precious(x)))) ::: Someone being both combative and fearless is equivalent to being significant and not precious.\n(∀x (¬Soft(x) ∨ ¬Significant(x))) → (Hollow(x)) ::: If someone is not soft or not significant, then he is hollow.\n((¬Soft(seymour))) ↔ ((¬Combative(max) ∧ Hollow(gregory))) ::: Seymour being not soft is equivalent to Max being not combative and Gregory being hollow.\n(¬Precious(adler)) ↔ (Soft(lamont)) ::: Adler is not precious if and only if Lamont is soft.\n(∀x (¬Significant(x))) → (Hollow(x)) ::: All not significant people are hollow.\n(∀x (Fearless(x))) → (¬Significant(x)) ::: If someone is fearless, then he is not significant.\n(¬Hollow(adler)) → ((¬Fearless(adler) ∧ ¬Soft(lamont))) ::: If Adler is hollow, then Adler is not fearless and Lamont is not soft.\n((¬Hollow(lamont))) ↔ (Significant(max)) ::: Lamont is not hollow if and only if Max is significant.\n",
            "First-Order-Logic Question": "Significant(adler) ::: Adler is significant."
        },
        "fixed": true
    },
    {
        "id": 220,
        "raw_prog": {
            "First-Order-Logic Rules": "¬Soft(gregory) ::: Gregory is not soft.\n¬Significant(max) ::: Max is not significant.\nHollow(max) ::: Max is hollow.\n¬Significant(conrad) ::: Conrad is not significant.\n¬Significant(adler) ::: Adler is not significant.\nCombative(lamont) ::: Lamont is combative.\n¬Precious(max) ::: Max is not precious.\nHollow(cary) ::: Cary is hollow.\n¬Combative(adler) ::: Adler is not combative.\nSignificant(cary) ::: Cary is significant.\nSignificant(seymour) ::: Seymour is significant.\n¬Fearless(conrad) ::: Conrad is not fearless.\n(∀x ((Precious(x) ∧ ¬Significant(x)) ↔ (¬Soft(x))) ::: If someone is precious and not significant, then he is not soft, and vice versa.\n(∀x ((Fearless(x) ∧ ¬Precious(x)) ↔ Significant(x))) ::: Someone being both fearless and not precious is equivalent to being significant.\n(∀x (Significant(x))) → (∀x (¬Fearless(x))) ::: Someone who is significant is always not fearless.\n(∀x (¬Precious(x))) → ((¬Hollow(x) ∧ ¬Soft(x))) ::: If someone is not precious, then he is neither hollow nor soft.\n(∀x ((Combative(x) ∧ Fearless(x)) ↔ (Significant(x) ∧ ¬Precious(x)))) ::: Someone being both combative and fearless is equivalent to being significant and not precious.\n(∀x ((¬Soft(x) ∧ ¬Significant(x)) ↔ Hollow(x))) ::: If someone is not soft or not significant, then he is hollow.\n((¬Soft(seymour))) ↔ ((¬Combative(max) ∧ Hollow(gregory))) ::: Seymour being not soft is equivalent to Max being not combative and Gregory being hollow.\n((¬Precious(adler))) ↔ (Soft(lamont)) ::: Adler is not precious if and only if Lamont is soft.\n(∀x (¬Significant(x))) → (Hollow(x)) ::: All not significant people are hollow.\n(∀x (Fearless(x))) → (¬Significant(x)) ::: If someone is fearless, then he is not significant.\n((Hollow(adler))) → ((¬Fearless(adler) ∧ ¬Soft(lamont))) ::: If Adler is hollow, then Adler is not fearless and Lamont is not soft.\n((¬Hollow(lamont))) ↔ (Significant(max)) ::: Lamont is not hollow if and only if Max is significant.\n",
            "First-Order-Logic Question": "¬Combative(conrad) ::: Conrad is not combative."
        },
        "gram_prog": {
            "First-Order-Logic Rules": "¬Soft(gregory) ::: Gregory is not soft.\n¬Significant(max) ::: Max is not significant.\nHollow(max) ::: Max is hollow.\n¬Significant(conrad) ::: Conrad is not significant.\n¬Significant(adler) ::: Adler is not significant.\nCombative(lamont) ::: Lamont is combative.\n¬Precious(max) ::: Max is not precious.\nHollow(cary) ::: Cary is hollow.\n¬Combative(adler) ::: Adler is not combative.\nSignificant(cary) ::: Cary is significant.\nSignificant(seymour) ::: Seymour is significant.\n¬Fearless(conrad) ::: Conrad is not fearless.\n∀x((Precious(x)∧¬Significant(x))) ::: If someone is precious and not significant, then he is not soft, and vice versa.\n(∀x ((Fearless(x) ∧ ¬Precious(x)) ↔ Significant(x))) ::: Someone being both fearless and not precious is equivalent to being significant.\n(∀x (Significant(x))) → (∀x (¬Fearless(x))) ::: Someone who is significant is always not fearless.\n(∀x (¬Precious(x))) → ((¬Hollow(x) ∧ ¬Soft(x))) ::: If someone is not precious, then he is neither hollow nor soft.\n(∀x ((Combative(x) ∧ Fearless(x)) ↔ (Significant(x) ∧ ¬Precious(x)))) ::: Someone being both combative and fearless is equivalent to being significant and not precious.\n(∀x ((¬Soft(x) ∧ ¬Significant(x)) ↔ Hollow(x))) ::: If someone is not soft or not significant, then he is hollow.\n((¬Soft(seymour))) ↔ ((¬Combative(max) ∧ Hollow(gregory))) ::: Seymour being not soft is equivalent to Max being not combative and Gregory being hollow.\n((¬Precious(adler))) ↔ (Soft(lamont)) ::: Adler is not precious if and only if Lamont is soft.\n(∀x (¬Significant(x))) → (Hollow(x)) ::: All not significant people are hollow.\n(∀x (Fearless(x))) → (¬Significant(x)) ::: If someone is fearless, then he is not significant.\n((Hollow(adler))) → ((¬Fearless(adler) ∧ ¬Soft(lamont))) ::: If Adler is hollow, then Adler is not fearless and Lamont is not soft.\n((¬Hollow(lamont))) ↔ (Significant(max)) ::: Lamont is not hollow if and only if Max is significant.\n",
            "First-Order-Logic Question": "¬Combative(conrad) ::: Conrad is not combative."
        },
        "diff": [
            {
                "raw": "(∀x ((Precious(x) ∧ ¬Significant(x)) ↔ (¬Soft(x))) ::: If someone is precious and not significant, then he is not soft, and vice versa.",
                "gram": "∀x((Precious(x)∧¬Significant(x))) ::: If someone is precious and not significant, then he is not soft, and vice versa."
            }
        ],
        "answer": "C",
        "grammar_answer": "A",
        "manual_prog": {
            "First-Order-Logic Rules": "¬Soft(gregory) ::: Gregory is not soft.\n¬Significant(max) ::: Max is not significant.\nHollow(max) ::: Max is hollow.\n¬Significant(conrad) ::: Conrad is not significant.\n¬Significant(adler) ::: Adler is not significant.\nCombative(lamont) ::: Lamont is combative.\n¬Precious(max) ::: Max is not precious.\nHollow(cary) ::: Cary is hollow.\n¬Combative(adler) ::: Adler is not combative.\nSignificant(cary) ::: Cary is significant.\nSignificant(seymour) ::: Seymour is significant.\n¬Fearless(conrad) ::: Conrad is not fearless.\n(∀x ((Precious(x) ∧ ¬Significant(x)) ↔ (¬Soft(x)))) ::: If someone is precious and not significant, then he is not soft, and vice versa.\n(∀x ((Fearless(x) ∧ ¬Precious(x)) ↔ Significant(x))) ::: Someone being both fearless and not precious is equivalent to being significant.\n(∀x (Significant(x))) → (∀x (¬Fearless(x))) ::: Someone who is significant is always not fearless.\n(∀x (¬Precious(x))) → ((¬Hollow(x) ∧ ¬Soft(x))) ::: If someone is not precious, then he is neither hollow nor soft.\n(∀x ((Combative(x) ∧ Fearless(x)) ↔ (Significant(x) ∧ ¬Precious(x)))) ::: Someone being both combative and fearless is equivalent to being significant and not precious.\n(∀x ((¬Soft(x) ∧ ¬Significant(x)) ↔ Hollow(x))) ::: If someone is not soft or not significant, then he is hollow.\n((¬Soft(seymour))) ↔ ((¬Combative(max) ∧ Hollow(gregory))) ::: Seymour being not soft is equivalent to Max being not combative and Gregory being hollow.\n((¬Precious(adler))) ↔ (Soft(lamont)) ::: Adler is not precious if and only if Lamont is soft.\n(∀x (¬Significant(x))) → (Hollow(x)) ::: All not significant people are hollow.\n(∀x (Fearless(x))) → (¬Significant(x)) ::: If someone is fearless, then he is not significant.\n((Hollow(adler))) → ((¬Fearless(adler) ∧ ¬Soft(lamont))) ::: If Adler is hollow, then Adler is not fearless and Lamont is not soft.\n((¬Hollow(lamont))) ↔ (Significant(max)) ::: Lamont is not hollow if and only if Max is significant.\n",
            "First-Order-Logic Question": "¬Combative(conrad) ::: Conrad is not combative."
        },
        "fixed": true
    },
    {
        "id": 221,
        "raw_prog": {
            "First-Order-Logic Rules": "¬Soft(gregory) ::: Gregory is not soft.\n¬Significant(max) ::: Max is not significant.\nHollow(max) ::: Max is hollow.\n¬Significant(conrad) ::: Conrad is not significant.\n¬Significant(adler) ::: Adler is not significant.\nCombative(lamont) ::: Lamont is combative.\n¬Precious(max) ::: Max is not precious.\nHollow(cary) ::: Cary is hollow.\n¬Combative(adler) ::: Adler is not combative.\nSignificant(cary) ::: Cary is significant.\nSignificant(seymour) ::: Seymour is significant.\n¬Fearless(conrad) ::: Conrad is not fearless.\n(∀x ((Precious(x) ∧ ¬Significant(x)) ↔ (¬Soft(x))) ::: If someone is precious and not significant, then he is not soft, and vice versa.\n(∀x ((Fearless(x) ∧ ¬Precious(x)) ↔ Significant(x))) ::: Someone being both fearless and not precious is equivalent to being significant.\n(∀x (Significant(x))) → (∀x (¬Fearless(x))) ::: Someone who is significant is always not fearless.\n(∀x (¬Precious(x))) → (∀x (¬Hollow(x) ∧ ¬Soft(x))) ::: If someone is not precious, then he is neither hollow nor soft.\n(∀x ((Combative(x) ∧ Fearless(x)) ↔ (Significant(x) ∧ ¬Precious(x)))) ::: Someone being both combative and fearless is equivalent to being significant and not precious.\n(∀x (¬Soft(x) ∨ ¬Significant(x))) → (∀x (Hollow(x))) ::: If someone is not soft or not significant, then he is hollow.\n(¬Soft(seymour)) ↔ (¬Combative(max) ∧ Hollow(gregory)) ::: Seymour being not soft is equivalent to Max being not combative and Gregory being hollow.\n(¬Precious(adler)) ↔ (Soft(lamont)) ::: Adler is not precious if and only if Lamont is soft.\n(∀x (¬Significant(x))) → (∀x (Hollow(x))) ::: All not significant people are hollow.\n(∀x (Fearless(x))) → (∀x (¬Significant(x))) ::: If someone is fearless, then he is not significant.\n(¬Hollow(adler)) → (¬Fearless(adler) ∧ ¬Soft(lamont)) ::: If Adler is hollow, then Adler is not fearless and Lamont is not soft.\n(¬Hollow(lamont)) ↔ (Significant(max)) ::: Lamont is not hollow if and only if Max is significant.\n",
            "First-Order-Logic Question": "¬Fearless(gregory) ::: Gregory is fearless."
        },
        "gram_prog": {
            "First-Order-Logic Rules": "¬Soft(gregory) ::: Gregory is not soft.\n¬Significant(max) ::: Max is not significant.\nHollow(max) ::: Max is hollow.\n¬Significant(conrad) ::: Conrad is not significant.\n¬Significant(adler) ::: Adler is not significant.\nCombative(lamont) ::: Lamont is combative.\n¬Precious(max) ::: Max is not precious.\nHollow(cary) ::: Cary is hollow.\n¬Combative(adler) ::: Adler is not combative.\nSignificant(cary) ::: Cary is significant.\nSignificant(seymour) ::: Seymour is significant.\n¬Fearless(conrad) ::: Conrad is not fearless.\n∀x((Precious(x)∧¬Significant(x))) ::: If someone is precious and not significant, then he is not soft, and vice versa.\n(∀x ((Fearless(x) ∧ ¬Precious(x)) ↔ Significant(x))) ::: Someone being both fearless and not precious is equivalent to being significant.\n(∀x (Significant(x))) → (∀x (¬Fearless(x))) ::: Someone who is significant is always not fearless.\n(∀x (¬Precious(x))) → (∀x (¬Hollow(x) ∧ ¬Soft(x))) ::: If someone is not precious, then he is neither hollow nor soft.\n(∀x ((Combative(x) ∧ Fearless(x)) ↔ (Significant(x) ∧ ¬Precious(x)))) ::: Someone being both combative and fearless is equivalent to being significant and not precious.\n(∀x (¬Soft(x) ∨ ¬Significant(x))) → (∀x (Hollow(x))) ::: If someone is not soft or not significant, then he is hollow.\n(¬Soft(seymour)) ↔ (¬Combative(max) ∧ Hollow(gregory)) ::: Seymour being not soft is equivalent to Max being not combative and Gregory being hollow.\n(¬Precious(adler)) ↔ (Soft(lamont)) ::: Adler is not precious if and only if Lamont is soft.\n(∀x (¬Significant(x))) → (∀x (Hollow(x))) ::: All not significant people are hollow.\n(∀x (Fearless(x))) → (∀x (¬Significant(x))) ::: If someone is fearless, then he is not significant.\n(¬Hollow(adler)) → (¬Fearless(adler) ∧ ¬Soft(lamont)) ::: If Adler is hollow, then Adler is not fearless and Lamont is not soft.\n(¬Hollow(lamont)) ↔ (Significant(max)) ::: Lamont is not hollow if and only if Max is significant.\n",
            "First-Order-Logic Question": "¬Fearless(gregory) ::: Gregory is fearless."
        },
        "diff": [
            {
                "raw": "(∀x ((Precious(x) ∧ ¬Significant(x)) ↔ (¬Soft(x))) ::: If someone is precious and not significant, then he is not soft, and vice versa.",
                "gram": "∀x((Precious(x)∧¬Significant(x))) ::: If someone is precious and not significant, then he is not soft, and vice versa."
            }
        ],
        "answer": "C",
        "grammar_answer": "A",
        "manual_prog": {
            "First-Order-Logic Rules": "¬Soft(gregory) ::: Gregory is not soft.\n¬Significant(max) ::: Max is not significant.\nHollow(max) ::: Max is hollow.\n¬Significant(conrad) ::: Conrad is not significant.\n¬Significant(adler) ::: Adler is not significant.\nCombative(lamont) ::: Lamont is combative.\n¬Precious(max) ::: Max is not precious.\nHollow(cary) ::: Cary is hollow.\n¬Combative(adler) ::: Adler is not combative.\nSignificant(cary) ::: Cary is significant.\nSignificant(seymour) ::: Seymour is significant.\n¬Fearless(conrad) ::: Conrad is not fearless.\n(∀x ((Precious(x) ∧ ¬Significant(x)) ↔ (¬Soft(x)))) ::: If someone is precious and not significant, then he is not soft, and vice versa.\n(∀x ((Fearless(x) ∧ ¬Precious(x)) ↔ Significant(x))) ::: Someone being both fearless and not precious is equivalent to being significant.\n(∀x (Significant(x))) → (∀x (¬Fearless(x))) ::: Someone who is significant is always not fearless.\n(∀x (¬Precious(x))) → (∀x (¬Hollow(x) ∧ ¬Soft(x))) ::: If someone is not precious, then he is neither hollow nor soft.\n(∀x ((Combative(x) ∧ Fearless(x)) ↔ (Significant(x) ∧ ¬Precious(x)))) ::: Someone being both combative and fearless is equivalent to being significant and not precious.\n(∀x (¬Soft(x) ∨ ¬Significant(x))) → (∀x (Hollow(x))) ::: If someone is not soft or not significant, then he is hollow.\n(¬Soft(seymour)) ↔ (¬Combative(max) ∧ Hollow(gregory)) ::: Seymour being not soft is equivalent to Max being not combative and Gregory being hollow.\n(¬Precious(adler)) ↔ (Soft(lamont)) ::: Adler is not precious if and only if Lamont is soft.\n(∀x (¬Significant(x))) → (∀x (Hollow(x))) ::: All not significant people are hollow.\n(∀x (Fearless(x))) → (∀x (¬Significant(x))) ::: If someone is fearless, then he is not significant.\n(¬Hollow(adler)) → (¬Fearless(adler) ∧ ¬Soft(lamont)) ::: If Adler is hollow, then Adler is not fearless and Lamont is not soft.\n(¬Hollow(lamont)) ↔ (Significant(max)) ::: Lamont is not hollow if and only if Max is significant.\n",
            "First-Order-Logic Question": "¬Fearless(gregory) ::: Gregory is fearless."
        },
        "fixed": true
    },
    {
        "id": 256,
        "raw_prog": {
            "First-Order-Logic Rules": "¬Teak(christopher) ::: Christopher is not teak.\n¬Dry(jack) ::: Jack is not dry.\nNew(christopher) ::: Christopher is new.\n¬Supportive(jack) ::: Jack is not supportive.\nNew(molly) ::: Molly is new.\n¬Teak(luka) ::: Luka is not teak.\n¬New(kayleigh) ::: Kayleigh is not new.\nAnxious(montague) ::: Montague is anxious.\nTeak(montague) ::: Montague is teak.\nDry(molly) ::: Molly is dry.\n¬Supportive(kayleigh) ::: Kayleigh is not supportive.\n(∀x ((Supportive(jack)) ↔ ((¬Teak(christopher) ∧ Anxious(luka)))) ::: Jack is supportive if and only if Christopher is not teak and Luka is anxious.\n(∃x (Teak(x))) → ((Anxious(montague) ∧ ¬Supportive(luka))) ::: If there is at least one people who is teak, then Montague is anxious and Luka is not supportive.\n((¬Anxious(luka))) ↔ ((Supportive(molly) ∧ ¬New(christopher))) ::: Luka is not anxious if and only if Molly is supportive and Christopher is not new.\n(∀x ((New(x) ∨ Dry(x))) → (¬Supportive(x))) ::: If someone is new or dry, then he is not supportive.\n((Supportive(jack)) ∨ New(quincy)) → (¬Supportive(quincy)) ::: It can be concluded that Quincy is not supportive once knowing that Jack is teak or Quincy is new.\n((¬Anxious(molly))) ↔ ((Supportive(kayleigh) ∧ ¬Busy(jack))) ::: Molly being not anxious is equivalent to Kayleigh being supportive and Jack being not busy.\n(∀x (New(x))) → (Supportive(x)) ::: Someone who is new is always supportive.\n(∃x (Anxious(x) ∧ Supportive(x))) → (¬Busy(molly)) ::: If there is at least one people who is both anxious and supportive, then Molly is not busy.\n(∀x (¬Teak(x))) → (Anxious(x) ∧ New(x)) ::: Someone who is not teak is always both anxious and new.\n(∀x (¬Anxious(x))) ↔ (¬Teak(x)) ::: Someone is not anxious if and only if he is not teak.\n((Anxious(molly))) ↔ (Teak(luka)) ::: If Molly is anxious, then Luka is teak, and vice versa.\n(∃x (¬New(x))) → (¬Busy(molly)) ::: If there is someone who is not new, then Molly is not busy.\n",
            "First-Order-Logic Question": "¬New(molly) ::: Molly is not new."
        },
        "gram_prog": {
            "First-Order-Logic Rules": "¬Teak(christopher) ::: Christopher is not teak.\n¬Dry(jack) ::: Jack is not dry.\nNew(christopher) ::: Christopher is new.\n¬Supportive(jack) ::: Jack is not supportive.\nNew(molly) ::: Molly is new.\n¬Teak(luka) ::: Luka is not teak.\n¬New(kayleigh) ::: Kayleigh is not new.\nAnxious(montague) ::: Montague is anxious.\nTeak(montague) ::: Montague is teak.\nDry(molly) ::: Molly is dry.\n¬Supportive(kayleigh) ::: Kayleigh is not supportive.\n∀x((Supportive(x)→¬Teak(x))) ::: Jack is supportive if and only if Christopher is not teak and Luka is anxious.\n(∃x (Teak(x))) → ((Anxious(montague) ∧ ¬Supportive(luka))) ::: If there is at least one people who is teak, then Montague is anxious and Luka is not supportive.\n((¬Anxious(luka))) ↔ ((Supportive(molly) ∧ ¬New(christopher))) ::: Luka is not anxious if and only if Molly is supportive and Christopher is not new.\n(∀x ((New(x) ∨ Dry(x))) → (¬Supportive(x))) ::: If someone is new or dry, then he is not supportive.\n((Supportive(jack)) ∨ New(quincy)) → (¬Supportive(quincy)) ::: It can be concluded that Quincy is not supportive once knowing that Jack is teak or Quincy is new.\n((¬Anxious(molly))) ↔ ((Supportive(kayleigh) ∧ ¬Busy(jack))) ::: Molly being not anxious is equivalent to Kayleigh being supportive and Jack being not busy.\n(∀x (New(x))) → (Supportive(x)) ::: Someone who is new is always supportive.\n(∃x (Anxious(x) ∧ Supportive(x))) → (¬Busy(molly)) ::: If there is at least one people who is both anxious and supportive, then Molly is not busy.\n(∀x (¬Teak(x))) → (Anxious(x) ∧ New(x)) ::: Someone who is not teak is always both anxious and new.\n(∀x (¬Anxious(x))) ↔ (¬Teak(x)) ::: Someone is not anxious if and only if he is not teak.\n((Anxious(molly))) ↔ (Teak(luka)) ::: If Molly is anxious, then Luka is teak, and vice versa.\n(∃x (¬New(x))) → (¬Busy(molly)) ::: If there is someone who is not new, then Molly is not busy.\n",
            "First-Order-Logic Question": "¬New(molly) ::: Molly is not new."
        },
        "diff": [
            {
                "raw": "(∀x ((Supportive(jack)) ↔ ((¬Teak(christopher) ∧ Anxious(luka)))) ::: Jack is supportive if and only if Christopher is not teak and Luka is anxious.",
                "gram": "∀x((Supportive(x)→¬Teak(x))) ::: Jack is supportive if and only if Christopher is not teak and Luka is anxious."
            }
        ],
        "answer": "B",
        "grammar_answer": "A",
        "manual_prog": {
            "First-Order-Logic Rules": "¬Teak(christopher) ::: Christopher is not teak.\n¬Dry(jack) ::: Jack is not dry.\nNew(christopher) ::: Christopher is new.\n¬Supportive(jack) ::: Jack is not supportive.\nNew(molly) ::: Molly is new.\n¬Teak(luka) ::: Luka is not teak.\n¬New(kayleigh) ::: Kayleigh is not new.\nAnxious(montague) ::: Montague is anxious.\nTeak(montague) ::: Montague is teak.\nDry(molly) ::: Molly is dry.\n¬Supportive(kayleigh) ::: Kayleigh is not supportive.\n(∀x ((Supportive(jack)) ↔ ((¬Teak(christopher) ∧ Anxious(luka))))) ::: Jack is supportive if and only if Christopher is not teak and Luka is anxious.\n(∃x (Teak(x))) → ((Anxious(montague) ∧ ¬Supportive(luka))) ::: If there is at least one people who is teak, then Montague is anxious and Luka is not supportive.\n((¬Anxious(luka))) ↔ ((Supportive(molly) ∧ ¬New(christopher))) ::: Luka is not anxious if and only if Molly is supportive and Christopher is not new.\n(∀x ((New(x) ∨ Dry(x))) → (¬Supportive(x))) ::: If someone is new or dry, then he is not supportive.\n((Supportive(jack)) ∨ New(quincy)) → (¬Supportive(quincy)) ::: It can be concluded that Quincy is not supportive once knowing that Jack is teak or Quincy is new.\n((¬Anxious(molly))) ↔ ((Supportive(kayleigh) ∧ ¬Busy(jack))) ::: Molly being not anxious is equivalent to Kayleigh being supportive and Jack being not busy.\n(∀x (New(x))) → (Supportive(x)) ::: Someone who is new is always supportive.\n(∃x (Anxious(x) ∧ Supportive(x))) → (¬Busy(molly)) ::: If there is at least one people who is both anxious and supportive, then Molly is not busy.\n(∀x (¬Teak(x))) → (Anxious(x) ∧ New(x)) ::: Someone who is not teak is always both anxious and new.\n(∀x (¬Anxious(x))) ↔ (¬Teak(x)) ::: Someone is not anxious if and only if he is not teak.\n((Anxious(molly))) ↔ (Teak(luka)) ::: If Molly is anxious, then Luka is teak, and vice versa.\n(∃x (¬New(x))) → (¬Busy(molly)) ::: If there is someone who is not new, then Molly is not busy.\n",
            "First-Order-Logic Question": "¬New(molly) ::: Molly is not new."
        },
        "fixed": true
    },
    {
        "id": 265,
        "raw_prog": {
            "First-Order-Logic Rules": "¬Teak(christopher) ::: Christopher is not teak.\n¬Dry(jack) ::: Jack is not dry.\nFresh(christopher) ::: Christopher is new.\n¬Supportive(jack) ::: Jack is not supportive.\nFresh(molly) ::: Molly is new.\n¬Teak(luka) ::: Luka is not teak.\n¬New(kayleigh) ::: Kayleigh is not new.\nAnxious(montague) ::: Montague is anxious.\nTeak(montague) ::: Montague is teak.\nDry(molly) ::: Molly is dry.\n¬Supportive(kayleigh) ::: Kayleigh is not supportive.\n(∀x ((Supportive(jack)) ↔ ((¬Teak(christopher) ∧ Anxious(luka)))) ::: Jack is supportive if and only if Christopher is not teak and Luka is anxious.\n(∃x (Teak(x))) → ((Anxious(montague) ∧ ¬Supportive(luka))) ::: If there is at least one people who is teak, then Montague is anxious and Luka is not supportive.\n(¬Anxious(luka)) ↔ ((Supportive(molly) ∧ ¬Fresh(christopher))) ::: Luka is not anxious if and only if Molly is supportive and Christopher is not new.\n(∀x ((New(x) ∨ Dry(x))) → (¬Supportive(x))) ::: If someone is new or dry, then he is not supportive.\n(∃x ((Teak(x) ∨ New(quincy))) → (¬Supportive(quincy))) ::: It can be concluded that Quincy is not supportive once knowing that Jack is teak or Quincy is new.\n(¬Anxious(molly)) ↔ ((Supportive(kayleigh) ∧ ¬Busy(jack))) ::: Molly being not anxious is equivalent to Kayleigh being supportive and Jack being not busy.\n(∀x (New(x))) → (Supportive(x)) ::: Someone who is new is always supportive.\n(∃x ((Anxious(x) ∧ Supportive(x))) → (¬Busy(molly)) ::: If there is at least one people who is both anxious and supportive, then Molly is not busy.\n(∀x (¬Teak(x))) → (Anxious(x) ∧ New(x)) ::: Someone who is not teak is always both anxious and new.\n(¬Anxious(x)) ↔ (¬Teak(x)) ::: Someone is not anxious if and only if he is not teak.\n(Anxious(molly)) ↔ (Teak(luka)) ::: If Molly is anxious, then Luka is teak, and vice versa.\n(∃x (¬New(x))) → (¬Busy(molly)) ::: If there is someone who is not new, then Molly is not busy.\n",
            "First-Order-Logic Question": "¬Teak(molly) ::: Molly is not teak."
        },
        "gram_prog": {
            "First-Order-Logic Rules": "¬Teak(christopher) ::: Christopher is not teak.\n¬Dry(jack) ::: Jack is not dry.\nFresh(christopher) ::: Christopher is new.\n¬Supportive(jack) ::: Jack is not supportive.\nFresh(molly) ::: Molly is new.\n¬Teak(luka) ::: Luka is not teak.\n¬New(kayleigh) ::: Kayleigh is not new.\nAnxious(montague) ::: Montague is anxious.\nTeak(montague) ::: Montague is teak.\nDry(molly) ::: Molly is dry.\n¬Supportive(kayleigh) ::: Kayleigh is not supportive.\n∀x((Serious(x)→Fresh(x))) ::: Jack is supportive if and only if Christopher is not teak and Luka is anxious.\n(∃x (Teak(x))) → ((Anxious(montague) ∧ ¬Supportive(luka))) ::: If there is at least one people who is teak, then Montague is anxious and Luka is not supportive.\n(¬Anxious(luka)) ↔ ((Supportive(molly) ∧ ¬Fresh(christopher))) ::: Luka is not anxious if and only if Molly is supportive and Christopher is not new.\n(∀x ((New(x) ∨ Dry(x))) → (¬Supportive(x))) ::: If someone is new or dry, then he is not supportive.\n(∃x ((Teak(x) ∨ New(quincy))) → (¬Supportive(quincy))) ::: It can be concluded that Quincy is not supportive once knowing that Jack is teak or Quincy is new.\n(¬Anxious(molly)) ↔ ((Supportive(kayleigh) ∧ ¬Busy(jack))) ::: Molly being not anxious is equivalent to Kayleigh being supportive and Jack being not busy.\n(∀x (New(x))) → (Supportive(x)) ::: Someone who is new is always supportive.\n∃x((Serious(x)∧Fresh(x))) ::: If there is at least one people who is both anxious and supportive, then Molly is not busy.\n(∀x (¬Teak(x))) → (Anxious(x) ∧ New(x)) ::: Someone who is not teak is always both anxious and new.\n(¬Anxious(x)) ↔ (¬Teak(x)) ::: Someone is not anxious if and only if he is not teak.\n(Anxious(molly)) ↔ (Teak(luka)) ::: If Molly is anxious, then Luka is teak, and vice versa.\n(∃x (¬New(x))) → (¬Busy(molly)) ::: If there is someone who is not new, then Molly is not busy.\n",
            "First-Order-Logic Question": "¬Teak(molly) ::: Molly is not teak."
        },
        "diff": [
            {
                "raw": "(∀x ((Supportive(jack)) ↔ ((¬Teak(christopher) ∧ Anxious(luka)))) ::: Jack is supportive if and only if Christopher is not teak and Luka is anxious.",
                "gram": "∀x((Serious(x)→Fresh(x))) ::: Jack is supportive if and only if Christopher is not teak and Luka is anxious."
            },
            {
                "raw": "(∃x ((Anxious(x) ∧ Supportive(x))) → (¬Busy(molly)) ::: If there is at least one people who is both anxious and supportive, then Molly is not busy.",
                "gram": "∃x((Serious(x)∧Fresh(x))) ::: If there is at least one people who is both anxious and supportive, then Molly is not busy."
            }
        ],
        "answer": "C",
        "grammar_answer": "A",
        "manual_prog": {
            "First-Order-Logic Rules": "¬Teak(christopher) ::: Christopher is not teak.\n¬Dry(jack) ::: Jack is not dry.\nFresh(christopher) ::: Christopher is new.\n¬Supportive(jack) ::: Jack is not supportive.\nFresh(molly) ::: Molly is new.\n¬Teak(luka) ::: Luka is not teak.\n¬New(kayleigh) ::: Kayleigh is not new.\nAnxious(montague) ::: Montague is anxious.\nTeak(montague) ::: Montague is teak.\nDry(molly) ::: Molly is dry.\n¬Supportive(kayleigh) ::: Kayleigh is not supportive.\n(∀x ((Supportive(jack)) ↔ ((¬Teak(christopher) ∧ Anxious(luka))))) ::: Jack is supportive if and only if Christopher is not teak and Luka is anxious.\n(∃x (Teak(x))) → ((Anxious(montague) ∧ ¬Supportive(luka))) ::: If there is at least one people who is teak, then Montague is anxious and Luka is not supportive.\n(¬Anxious(luka)) ↔ ((Supportive(molly) ∧ ¬Fresh(christopher))) ::: Luka is not anxious if and only if Molly is supportive and Christopher is not new.\n(∀x ((New(x) ∨ Dry(x))) → (¬Supportive(x))) ::: If someone is new or dry, then he is not supportive.\n(∃x ((Teak(x) ∨ New(quincy))) → (¬Supportive(quincy))) ::: It can be concluded that Quincy is not supportive once knowing that Jack is teak or Quincy is new.\n(¬Anxious(molly)) ↔ ((Supportive(kayleigh) ∧ ¬Busy(jack))) ::: Molly being not anxious is equivalent to Kayleigh being supportive and Jack being not busy.\n(∀x (New(x))) → (Supportive(x)) ::: Someone who is new is always supportive.\n(∃x ((Anxious(x) ∧ Supportive(x))) → (¬Busy(molly))) ::: If there is at least one people who is both anxious and supportive, then Molly is not busy.\n(∀x (¬Teak(x))) → (Anxious(x) ∧ New(x)) ::: Someone who is not teak is always both anxious and new.\n(¬Anxious(x)) ↔ (¬Teak(x)) ::: Someone is not anxious if and only if he is not teak.\n(Anxious(molly)) ↔ (Teak(luka)) ::: If Molly is anxious, then Luka is teak, and vice versa.\n(∃x (¬New(x))) → (¬Busy(molly)) ::: If there is someone who is not new, then Molly is not busy.\n",
            "First-Order-Logic Question": "¬Teak(molly) ::: Molly is not teak."
        },
        "fixed": true
    },
    {
        "id": 315,
        "raw_prog": {
            "First-Order-Logic Rules": "¬Hungry(morgan) ::: Morgan is not hungry.\nHungry(keith) ::: Keith is hungry.\n¬Recent(ernest) ::: Ernest is not recent.\n¬Gleaming(leroy) ::: Leroy is not gleaming.\n¬Recent(keith) ::: Keith is not recent.\n¬Lovely(cara) ::: Cara is not lovely.\n¬Precious(cary) ::: Cary is not precious.\n¬Lovely(leroy) ::: Leroy is not lovely.\n¬Recent(morgan) ::: Morgan is not recent.\n¬Precious(leroy) ::: Leroy is not precious.\nFat(leroy) ::: Leroy is fat.\n¬Hungry(ernest) ::: Ernest is not hungry.\n(∀x ((Gleaming(x) ∧ ¬Fat(x)) ↔ ¬Hungry(x))) ::: If someone is gleaming and not fat, then he is not hungry, and vice versa.\n(Fat(leroy)) → ((Hungry(leroy) ∧ Lovely(ernest))) ::: If Leroy is fat, then Leroy is hungry and Ernest is lovely.\n(∀x (Fat(x))) → (¬Gleaming(cary)) ::: If all people are fat, then Cary is not gleaming.\n(∃x ((Gleaming(x) ∧ ¬Recent(x)))) → ((¬Precious(ronald) ∧ ¬Hungry(cara))) ::: If there is someone who is both gleaming and not recent, then Ronald is not precious and Cara is not hungry.\n(∃x (¬Fat(x))) → ((Lovely(cary) ∧ Hungry(ernest))) ::: If there is someone who is not fat, then Cary is lovely and Ernest is hungry.\n((Gleaming(cara))) ↔ (¬Hungry(keith)) ::: Cara being gleaming is equivalent to Keith being not hungry.\n(∀x (¬Lovely(x))) → (Precious(x) ∧ ¬Gleaming(x)) ::: As long as someone is not lovely, he is precious and not gleaming.\n(∃x ((¬Lovely(x) ∧ Fat(x)))) → (Hungry(x)) ::: If someone who is not lovely is also fat, then he is hungry.\n(∀x ((Gleaming(x) ∧ ¬Lovely(x))) ↔ (Fat(x) ∧ ¬Precious(x))) ::: If someone is gleaming and not lovely, then he is both fat and not precious, and vice versa.\n((Gleaming(cary))) → (Lovely(cary)) ::: If Cary is gleaming, then Cary is lovely.\n(∃x ((Fat(x) ∨ ¬Hungry(x))) → (¬Lovely(cary)) ::: If there is someone who is either fat or not hungry, then Cary is not lovely.\n(∃x ((Precious(x) ∧ Hungry(x))) → (¬Gleaming(morgan)) ::: If there is someone who is both precious and hungry, then Morgan is not gleaming.\n",
            "First-Order-Logic Question": "Fat(ronald) ::: Ronald is fat."
        },
        "gram_prog": {
            "First-Order-Logic Rules": "¬Hungry(morgan) ::: Morgan is not hungry.\nHungry(keith) ::: Keith is hungry.\n¬Recent(ernest) ::: Ernest is not recent.\n¬Gleaming(leroy) ::: Leroy is not gleaming.\n¬Recent(keith) ::: Keith is not recent.\n¬Lovely(cara) ::: Cara is not lovely.\n¬Precious(cary) ::: Cary is not precious.\n¬Lovely(leroy) ::: Leroy is not lovely.\n¬Recent(morgan) ::: Morgan is not recent.\n¬Precious(leroy) ::: Leroy is not precious.\nFat(leroy) ::: Leroy is fat.\n¬Hungry(ernest) ::: Ernest is not hungry.\n(∀x ((Gleaming(x) ∧ ¬Fat(x)) ↔ ¬Hungry(x))) ::: If someone is gleaming and not fat, then he is not hungry, and vice versa.\n(Fat(leroy)) → ((Hungry(leroy) ∧ Lovely(ernest))) ::: If Leroy is fat, then Leroy is hungry and Ernest is lovely.\n(∀x (Fat(x))) → (¬Gleaming(cary)) ::: If all people are fat, then Cary is not gleaming.\n(∃x ((Gleaming(x) ∧ ¬Recent(x)))) → ((¬Precious(ronald) ∧ ¬Hungry(cara))) ::: If there is someone who is both gleaming and not recent, then Ronald is not precious and Cara is not hungry.\n(∃x (¬Fat(x))) → ((Lovely(cary) ∧ Hungry(ernest))) ::: If there is someone who is not fat, then Cary is lovely and Ernest is hungry.\n((Gleaming(cara))) ↔ (¬Hungry(keith)) ::: Cara being gleaming is equivalent to Keith being not hungry.\n(∀x (¬Lovely(x))) → (Precious(x) ∧ ¬Gleaming(x)) ::: As long as someone is not lovely, he is precious and not gleaming.\n(∃x ((¬Lovely(x) ∧ Fat(x)))) → (Hungry(x)) ::: If someone who is not lovely is also fat, then he is hungry.\n(∀x ((Gleaming(x) ∧ ¬Lovely(x))) ↔ (Fat(x) ∧ ¬Precious(x))) ::: If someone is gleaming and not lovely, then he is both fat and not precious, and vice versa.\n((Gleaming(cary))) → (Lovely(cary)) ::: If Cary is gleaming, then Cary is lovely.\n¬(Hungry(x)∨Fat(x))→Lovely(x) ::: If there is someone who is either fat or not hungry, then Cary is not lovely.\n∃x((Hungry(x)∧Recent(x))) ::: If there is someone who is both precious and hungry, then Morgan is not gleaming.\n",
            "First-Order-Logic Question": "Fat(ronald) ::: Ronald is fat."
        },
        "diff": [
            {
                "raw": "(∃x ((Fat(x) ∨ ¬Hungry(x))) → (¬Lovely(cary)) ::: If there is someone who is either fat or not hungry, then Cary is not lovely.",
                "gram": "¬(Hungry(x)∨Fat(x))→Lovely(x) ::: If there is someone who is either fat or not hungry, then Cary is not lovely."
            },
            {
                "raw": "(∃x ((Precious(x) ∧ Hungry(x))) → (¬Gleaming(morgan)) ::: If there is someone who is both precious and hungry, then Morgan is not gleaming.",
                "gram": "∃x((Hungry(x)∧Recent(x))) ::: If there is someone who is both precious and hungry, then Morgan is not gleaming."
            }
        ],
        "answer": "C",
        "grammar_answer": "A",
        "manual_prog": {
            "First-Order-Logic Rules": "¬Hungry(morgan) ::: Morgan is not hungry.\nHungry(keith) ::: Keith is hungry.\n¬Recent(ernest) ::: Ernest is not recent.\n¬Gleaming(leroy) ::: Leroy is not gleaming.\n¬Recent(keith) ::: Keith is not recent.\n¬Lovely(cara) ::: Cara is not lovely.\n¬Precious(cary) ::: Cary is not precious.\n¬Lovely(leroy) ::: Leroy is not lovely.\n¬Recent(morgan) ::: Morgan is not recent.\n¬Precious(leroy) ::: Leroy is not precious.\nFat(leroy) ::: Leroy is fat.\n¬Hungry(ernest) ::: Ernest is not hungry.\n(∀x ((Gleaming(x) ∧ ¬Fat(x)) ↔ ¬Hungry(x))) ::: If someone is gleaming and not fat, then he is not hungry, and vice versa.\n(Fat(leroy)) → ((Hungry(leroy) ∧ Lovely(ernest))) ::: If Leroy is fat, then Leroy is hungry and Ernest is lovely.\n(∀x (Fat(x))) → (¬Gleaming(cary)) ::: If all people are fat, then Cary is not gleaming.\n(∃x ((Gleaming(x) ∧ ¬Recent(x)))) → ((¬Precious(ronald) ∧ ¬Hungry(cara))) ::: If there is someone who is both gleaming and not recent, then Ronald is not precious and Cara is not hungry.\n(∃x (¬Fat(x))) → ((Lovely(cary) ∧ Hungry(ernest))) ::: If there is someone who is not fat, then Cary is lovely and Ernest is hungry.\n((Gleaming(cara))) ↔ (¬Hungry(keith)) ::: Cara being gleaming is equivalent to Keith being not hungry.\n(∀x (¬Lovely(x))) → (Precious(x) ∧ ¬Gleaming(x)) ::: As long as someone is not lovely, he is precious and not gleaming.\n(∃x ((¬Lovely(x) ∧ Fat(x)))) → (Hungry(x)) ::: If someone who is not lovely is also fat, then he is hungry.\n(∀x ((Gleaming(x) ∧ ¬Lovely(x))) ↔ (Fat(x) ∧ ¬Precious(x))) ::: If someone is gleaming and not lovely, then he is both fat and not precious, and vice versa.\n((Gleaming(cary))) → (Lovely(cary)) ::: If Cary is gleaming, then Cary is lovely.\n(∃x ((Fat(x) ∨ ¬Hungry(x))) → (¬Lovely(cary))) ::: If there is someone who is either fat or not hungry, then Cary is not lovely.\n(∃x ((Precious(x) ∧ Hungry(x))) → (¬Gleaming(morgan))) ::: If there is someone who is both precious and hungry, then Morgan is not gleaming.\n",
            "First-Order-Logic Question": "Fat(ronald) ::: Ronald is fat."
        },
        "fixed": true
    },
    {
        "id": 316,
        "raw_prog": {
            "First-Order-Logic Rules": "¬Hungry(morgan) ::: Morgan is not hungry.\nHungry(keith) ::: Keith is hungry.\n¬Recent(ernest) ::: Ernest is not recent.\n¬Gleaming(leroy) ::: Leroy is not gleaming.\n¬Recent(keith) ::: Keith is not recent.\n¬Lovely(cara) ::: Cara is not lovely.\n¬Precious(cary) ::: Cary is not precious.\n¬Lovely(leroy) ::: Leroy is not lovely.\n¬Recent(morgan) ::: Morgan is not recent.\n¬Precious(leroy) ::: Leroy is not precious.\nFat(leroy) ::: Leroy is fat.\n¬Hungry(ernest) ::: Ernest is not hungry.\n(∀x ((Gleaming(x) ∧ ¬Fat(x)) ↔ ¬Hungry(x))) ::: If someone is gleaming and not fat, then he is not hungry, and vice versa.\n(Fat(leroy)) → ((Hungry(leroy) ∧ Lovely(ernest))) ::: If Leroy is fat, then Leroy is hungry and Ernest is lovely.\n(∀x (Fat(x))) → (¬Gleaming(cary)) ::: If all people are fat, then Cary is not gleaming.\n(∃x ((Gleaming(x) ∧ ¬Recent(x))) → (¬Precious(ronald) ∧ ¬Hungry(cara))) ::: If there is someone who is both gleaming and not recent, then Ronald is not precious and Cara is not hungry.\n(∃x (¬Fat(x))) → (Lovely(cary) ∧ Hungry(ernest)) ::: If there is someone who is not fat, then Cary is lovely and Ernest is hungry.\n((Gleaming(cara))) ↔ (¬Hungry(keith)) ::: Cara being gleaming is equivalent to Keith being not hungry.\n(∀x (¬Lovely(x))) → (Precious(x) ∧ ¬Gleaming(x)) ::: As long as someone is not lovely, he is precious and not gleaming.\n(∀x ((¬Lovely(x) ∧ Fat(x))) → (Hungry(x)) ::: If someone who is not lovely is also fat, then he is hungry.\n(∀x ((Gleaming(x) ∧ ¬Lovely(x))) ↔ (Fat(x) ∧ ¬Precious(x))) ::: If someone is gleaming and not lovely, then he is both fat and not precious, and vice versa.\n((Gleaming(cary))) → (Lovely(cary)) ::: If Cary is gleaming, then Cary is lovely.\n(∃x ((Fat(x) ∨ ¬Hungry(x))) → (¬Lovely(cary)) ::: If there is someone who is either fat or not hungry, then Cary is not lovely.\n(∃x (Precious(x) ∧ Hungry(x))) → (¬Gleaming(morgan)) ::: If there is someone who is both precious and hungry, then Morgan is not gleaming.\n",
            "First-Order-Logic Question": "Lovely(morgan) ::: Morgan is lovely."
        },
        "gram_prog": {
            "First-Order-Logic Rules": "¬Hungry(morgan) ::: Morgan is not hungry.\nHungry(keith) ::: Keith is hungry.\n¬Recent(ernest) ::: Ernest is not recent.\n¬Gleaming(leroy) ::: Leroy is not gleaming.\n¬Recent(keith) ::: Keith is not recent.\n¬Lovely(cara) ::: Cara is not lovely.\n¬Precious(cary) ::: Cary is not precious.\n¬Lovely(leroy) ::: Leroy is not lovely.\n¬Recent(morgan) ::: Morgan is not recent.\n¬Precious(leroy) ::: Leroy is not precious.\nFat(leroy) ::: Leroy is fat.\n¬Hungry(ernest) ::: Ernest is not hungry.\n(∀x ((Gleaming(x) ∧ ¬Fat(x)) ↔ ¬Hungry(x))) ::: If someone is gleaming and not fat, then he is not hungry, and vice versa.\n(Fat(leroy)) → ((Hungry(leroy) ∧ Lovely(ernest))) ::: If Leroy is fat, then Leroy is hungry and Ernest is lovely.\n(∀x (Fat(x))) → (¬Gleaming(cary)) ::: If all people are fat, then Cary is not gleaming.\n(∃x ((Gleaming(x) ∧ ¬Recent(x))) → (¬Precious(ronald) ∧ ¬Hungry(cara))) ::: If there is someone who is both gleaming and not recent, then Ronald is not precious and Cara is not hungry.\n(∃x (¬Fat(x))) → (Lovely(cary) ∧ Hungry(ernest)) ::: If there is someone who is not fat, then Cary is lovely and Ernest is hungry.\n((Gleaming(cara))) ↔ (¬Hungry(keith)) ::: Cara being gleaming is equivalent to Keith being not hungry.\n(∀x (¬Lovely(x))) → (Precious(x) ∧ ¬Gleaming(x)) ::: As long as someone is not lovely, he is precious and not gleaming.\n∀x((¬Fresh(x)→Serious(x))) ::: If someone who is not lovely is also fat, then he is hungry.\n(∀x ((Gleaming(x) ∧ ¬Lovely(x))) ↔ (Fat(x) ∧ ¬Precious(x))) ::: If someone is gleaming and not lovely, then he is both fat and not precious, and vice versa.\n((Gleaming(cary))) → (Lovely(cary)) ::: If Cary is gleaming, then Cary is lovely.\n¬(Fresh(x)∨Serious(x))→¬(Entire(x)) ::: If there is someone who is either fat or not hungry, then Cary is not lovely.\n(∃x (Precious(x) ∧ Hungry(x))) → (¬Gleaming(morgan)) ::: If there is someone who is both precious and hungry, then Morgan is not gleaming.\n",
            "First-Order-Logic Question": "Lovely(morgan) ::: Morgan is lovely."
        },
        "diff": [
            {
                "raw": "(∀x ((¬Lovely(x) ∧ Fat(x))) → (Hungry(x)) ::: If someone who is not lovely is also fat, then he is hungry.",
                "gram": "∀x((¬Fresh(x)→Serious(x))) ::: If someone who is not lovely is also fat, then he is hungry."
            },
            {
                "raw": "(∃x ((Fat(x) ∨ ¬Hungry(x))) → (¬Lovely(cary)) ::: If there is someone who is either fat or not hungry, then Cary is not lovely.",
                "gram": "¬(Fresh(x)∨Serious(x))→¬(Entire(x)) ::: If there is someone who is either fat or not hungry, then Cary is not lovely."
            }
        ],
        "answer": "C",
        "grammar_answer": "A",
        "manual_prog": {
            "First-Order-Logic Rules": "¬Hungry(morgan) ::: Morgan is not hungry.\nHungry(keith) ::: Keith is hungry.\n¬Recent(ernest) ::: Ernest is not recent.\n¬Gleaming(leroy) ::: Leroy is not gleaming.\n¬Recent(keith) ::: Keith is not recent.\n¬Lovely(cara) ::: Cara is not lovely.\n¬Precious(cary) ::: Cary is not precious.\n¬Lovely(leroy) ::: Leroy is not lovely.\n¬Recent(morgan) ::: Morgan is not recent.\n¬Precious(leroy) ::: Leroy is not precious.\nFat(leroy) ::: Leroy is fat.\n¬Hungry(ernest) ::: Ernest is not hungry.\n(∀x ((Gleaming(x) ∧ ¬Fat(x)) ↔ ¬Hungry(x))) ::: If someone is gleaming and not fat, then he is not hungry, and vice versa.\n(Fat(leroy)) → ((Hungry(leroy) ∧ Lovely(ernest))) ::: If Leroy is fat, then Leroy is hungry and Ernest is lovely.\n(∀x (Fat(x))) → (¬Gleaming(cary)) ::: If all people are fat, then Cary is not gleaming.\n(∃x ((Gleaming(x) ∧ ¬Recent(x))) → (¬Precious(ronald) ∧ ¬Hungry(cara))) ::: If there is someone who is both gleaming and not recent, then Ronald is not precious and Cara is not hungry.\n(∃x (¬Fat(x))) → (Lovely(cary) ∧ Hungry(ernest)) ::: If there is someone who is not fat, then Cary is lovely and Ernest is hungry.\n((Gleaming(cara))) ↔ (¬Hungry(keith)) ::: Cara being gleaming is equivalent to Keith being not hungry.\n(∀x (¬Lovely(x))) → (Precious(x) ∧ ¬Gleaming(x)) ::: As long as someone is not lovely, he is precious and not gleaming.\n(∀x ((¬Lovely(x) ∧ Fat(x))) → (Hungry(x))) ::: If someone who is not lovely is also fat, then he is hungry.\n(∀x ((Gleaming(x) ∧ ¬Lovely(x))) ↔ (Fat(x) ∧ ¬Precious(x))) ::: If someone is gleaming and not lovely, then he is both fat and not precious, and vice versa.\n((Gleaming(cary))) → (Lovely(cary)) ::: If Cary is gleaming, then Cary is lovely.\n(∃x ((Fat(x) ∨ ¬Hungry(x))) → (¬Lovely(cary))) ::: If there is someone who is either fat or not hungry, then Cary is not lovely.\n(∃x (Precious(x) ∧ Hungry(x))) → (¬Gleaming(morgan)) ::: If there is someone who is both precious and hungry, then Morgan is not gleaming.\n",
            "First-Order-Logic Question": "Lovely(morgan) ::: Morgan is lovely."
        },
        "fixed": true
    },
    {
        "id": 318,
        "raw_prog": {
            "First-Order-Logic Rules": "¬Hungry(morgan) ::: Morgan is not hungry.\nHungry(keith) ::: Keith is hungry.\n¬Recent(ernest) ::: Ernest is not recent.\n¬Gleaming(leroy) ::: Leroy is not gleaming.\n¬Recent(keith) ::: Keith is not recent.\n¬Lovely(cara) ::: Cara is not lovely.\n¬Precious(cary) ::: Cary is not precious.\n¬Lovely(leroy) ::: Leroy is not lovely.\n¬Recent(morgan) ::: Morgan is not recent.\n¬Precious(leroy) ::: Leroy is not precious.\nFat(leroy) ::: Leroy is fat.\n¬Hungry(ernest) ::: Ernest is not hungry.\n(∀x ((Gleaming(x) ∧ ¬Fat(x)) ↔ ¬Hungry(x))) ::: If someone is gleaming and not fat, then he is not hungry, and vice versa.\n(Fat(leroy)) → ((Hungry(leroy) ∧ Lovely(ernest))) ::: If Leroy is fat, then Leroy is hungry and Ernest is lovely.\n(∀x (Fat(x))) → (¬Gleaming(cary)) ::: If all people are fat, then Cary is not gleaming.\n(∃x ((Gleaming(x) ∧ ¬Recent(x))) → (¬Precious(ronald) ∧ ¬Hungry(cara))) ::: If there is someone who is both gleaming and not recent, then Ronald is not precious and Cara is not hungry.\n(∃x (¬Fat(x))) → (Lovely(cary) ∧ Hungry(ernest)) ::: If there is someone who is not fat, then Cary is lovely and Ernest is hungry.\n((Gleaming(cara))) ↔ (¬Hungry(keith)) ::: Cara being gleaming is equivalent to Keith being not hungry.\n(∀x (¬Lovely(x))) → (Precious(x) ∧ ¬Gleaming(x)) ::: As long as someone is not lovely, he is precious and not gleaming.\n(∃x ((¬Lovely(x) ∧ Fat(x))) → (Hungry(x)) ::: If someone who is not lovely is also fat, then he is hungry.\n(∀x ((Gleaming(x) ∧ ¬Lovely(x)) ↔ (Fat(x) ∧ ¬Precious(x)))) ::: If someone is gleaming and not lovely, then he is both fat and not precious, and vice versa.\n((Gleaming(cary))) → (Lovely(cary)) ::: If Cary is gleaming, then Cary is lovely.\n(∃x (Fat(x) ∨ ¬Hungry(x))) → (¬Lovely(cary)) ::: If there is someone who is either fat or not hungry, then Cary is not lovely.\n(∃x (Precious(x) ∧ Hungry(x))) → (¬Gleaming(morgan)) ::: If there is someone who is both precious and hungry, then Morgan is not gleaming.\n",
            "First-Order-Logic Question": "¬Recent(cary) ::: Cary is not recent."
        },
        "gram_prog": {
            "First-Order-Logic Rules": "¬Hungry(morgan) ::: Morgan is not hungry.\nHungry(keith) ::: Keith is hungry.\n¬Recent(ernest) ::: Ernest is not recent.\n¬Gleaming(leroy) ::: Leroy is not gleaming.\n¬Recent(keith) ::: Keith is not recent.\n¬Lovely(cara) ::: Cara is not lovely.\n¬Precious(cary) ::: Cary is not precious.\n¬Lovely(leroy) ::: Leroy is not lovely.\n¬Recent(morgan) ::: Morgan is not recent.\n¬Precious(leroy) ::: Leroy is not precious.\nFat(leroy) ::: Leroy is fat.\n¬Hungry(ernest) ::: Ernest is not hungry.\n(∀x ((Gleaming(x) ∧ ¬Fat(x)) ↔ ¬Hungry(x))) ::: If someone is gleaming and not fat, then he is not hungry, and vice versa.\n(Fat(leroy)) → ((Hungry(leroy) ∧ Lovely(ernest))) ::: If Leroy is fat, then Leroy is hungry and Ernest is lovely.\n(∀x (Fat(x))) → (¬Gleaming(cary)) ::: If all people are fat, then Cary is not gleaming.\n(∃x ((Gleaming(x) ∧ ¬Recent(x))) → (¬Precious(ronald) ∧ ¬Hungry(cara))) ::: If there is someone who is both gleaming and not recent, then Ronald is not precious and Cara is not hungry.\n(∃x (¬Fat(x))) → (Lovely(cary) ∧ Hungry(ernest)) ::: If there is someone who is not fat, then Cary is lovely and Ernest is hungry.\n((Gleaming(cara))) ↔ (¬Hungry(keith)) ::: Cara being gleaming is equivalent to Keith being not hungry.\n(∀x (¬Lovely(x))) → (Precious(x) ∧ ¬Gleaming(x)) ::: As long as someone is not lovely, he is precious and not gleaming.\n¬(Fresh(x)→(Serious(x))) ::: If someone who is not lovely is also fat, then he is hungry.\n(∀x ((Gleaming(x) ∧ ¬Lovely(x)) ↔ (Fat(x) ∧ ¬Precious(x)))) ::: If someone is gleaming and not lovely, then he is both fat and not precious, and vice versa.\n((Gleaming(cary))) → (Lovely(cary)) ::: If Cary is gleaming, then Cary is lovely.\n(∃x (Fat(x) ∨ ¬Hungry(x))) → (¬Lovely(cary)) ::: If there is someone who is either fat or not hungry, then Cary is not lovely.\n(∃x (Precious(x) ∧ Hungry(x))) → (¬Gleaming(morgan)) ::: If there is someone who is both precious and hungry, then Morgan is not gleaming.\n",
            "First-Order-Logic Question": "¬Recent(cary) ::: Cary is not recent."
        },
        "diff": [
            {
                "raw": "(∃x ((¬Lovely(x) ∧ Fat(x))) → (Hungry(x)) ::: If someone who is not lovely is also fat, then he is hungry.",
                "gram": "¬(Fresh(x)→(Serious(x))) ::: If someone who is not lovely is also fat, then he is hungry."
            }
        ],
        "answer": "C",
        "grammar_answer": "A",
        "manual_prog": {
            "First-Order-Logic Rules": "¬Hungry(morgan) ::: Morgan is not hungry.\nHungry(keith) ::: Keith is hungry.\n¬Recent(ernest) ::: Ernest is not recent.\n¬Gleaming(leroy) ::: Leroy is not gleaming.\n¬Recent(keith) ::: Keith is not recent.\n¬Lovely(cara) ::: Cara is not lovely.\n¬Precious(cary) ::: Cary is not precious.\n¬Lovely(leroy) ::: Leroy is not lovely.\n¬Recent(morgan) ::: Morgan is not recent.\n¬Precious(leroy) ::: Leroy is not precious.\nFat(leroy) ::: Leroy is fat.\n¬Hungry(ernest) ::: Ernest is not hungry.\n(∀x ((Gleaming(x) ∧ ¬Fat(x)) ↔ ¬Hungry(x))) ::: If someone is gleaming and not fat, then he is not hungry, and vice versa.\n(Fat(leroy)) → ((Hungry(leroy) ∧ Lovely(ernest))) ::: If Leroy is fat, then Leroy is hungry and Ernest is lovely.\n(∀x (Fat(x))) → (¬Gleaming(cary)) ::: If all people are fat, then Cary is not gleaming.\n(∃x ((Gleaming(x) ∧ ¬Recent(x))) → (¬Precious(ronald) ∧ ¬Hungry(cara))) ::: If there is someone who is both gleaming and not recent, then Ronald is not precious and Cara is not hungry.\n(∃x (¬Fat(x))) → (Lovely(cary) ∧ Hungry(ernest)) ::: If there is someone who is not fat, then Cary is lovely and Ernest is hungry.\n((Gleaming(cara))) ↔ (¬Hungry(keith)) ::: Cara being gleaming is equivalent to Keith being not hungry.\n(∀x (¬Lovely(x))) → (Precious(x) ∧ ¬Gleaming(x)) ::: As long as someone is not lovely, he is precious and not gleaming.\n(∃x ((¬Lovely(x) ∧ Fat(x))) → (Hungry(x))) ::: If someone who is not lovely is also fat, then he is hungry.\n(∀x ((Gleaming(x) ∧ ¬Lovely(x)) ↔ (Fat(x) ∧ ¬Precious(x)))) ::: If someone is gleaming and not lovely, then he is both fat and not precious, and vice versa.\n((Gleaming(cary))) → (Lovely(cary)) ::: If Cary is gleaming, then Cary is lovely.\n(∃x (Fat(x) ∨ ¬Hungry(x))) → (¬Lovely(cary)) ::: If there is someone who is either fat or not hungry, then Cary is not lovely.\n(∃x (Precious(x) ∧ Hungry(x))) → (¬Gleaming(morgan)) ::: If there is someone who is both precious and hungry, then Morgan is not gleaming.\n",
            "First-Order-Logic Question": "¬Recent(cary) ::: Cary is not recent."
        },
        "fixed": true
    },
    {
        "id": 319,
        "raw_prog": {
            "First-Order-Logic Rules": "¬Hungry(morgan) ::: Morgan is not hungry.\nHungry(keith) ::: Keith is hungry.\n¬Recent(ernest) ::: Ernest is not recent.\n¬Gleaming(leroy) ::: Leroy is not gleaming.\n¬Recent(keith) ::: Keith is not recent.\n¬Lovely(cara) ::: Cara is not lovely.\n¬Precious(cary) ::: Cary is not precious.\n¬Lovely(leroy) ::: Leroy is not lovely.\n¬Recent(morgan) ::: Morgan is not recent.\n¬Precious(leroy) ::: Leroy is not precious.\nFat(leroy) ::: Leroy is fat.\n¬Hungry(ernest) ::: Ernest is not hungry.\n(∀x ((Gleaming(x) ∧ ¬Fat(x)) ↔ ¬Hungry(x))) ::: If someone is gleaming and not fat, then he is not hungry, and vice versa.\n(Fat(leroy)) → (Hungry(leroy) ∧ Lovely(ernest)) ::: If Leroy is fat, then Leroy is hungry and Ernest is lovely.\n(∀x (Fat(x))) → (¬Gleaming(cary)) ::: If all people are fat, then Cary is not gleaming.\n(∃x ((Gleaming(x) ∧ ¬Recent(x))) → (¬Precious(ronald) ∧ ¬Hungry(cara))) ::: If there is someone who is both gleaming and not recent, then Ronald is not precious and Cara is not hungry.\n(∃x (¬Fat(x))) → (Lovely(cary) ∧ Hungry(ernest)) ::: If there is someone who is not fat, then Cary is lovely and Ernest is hungry.\n((Gleaming(cara))) ↔ (¬Hungry(keith)) ::: Cara being gleaming is equivalent to Keith being not hungry.\n(∀x (¬Lovely(x))) → (Precious(x) ∧ ¬Gleaming(x)) ::: As long as someone is not lovely, he is precious and not gleaming.\n(∃x ((¬Lovely(x) ∧ Fat(x))) → (Hungry(x)) ::: If someone who is not lovely is also fat, then he is hungry.\n(∀x ((Gleaming(x) ∧ ¬Lovely(x)) ↔ (Fat(x) ∧ ¬Precious(x)))) ::: If someone is gleaming and not lovely, then he is both fat and not precious, and vice versa.\n((Gleaming(cary))) → (Lovely(cary)) ::: If Cary is gleaming, then Cary is lovely.\n(∃x ((Fat(x) ∨ ¬Hungry(x))) → (¬Lovely(cary)) ::: If there is someone who is either fat or not hungry, then Cary is not lovely.\n(∃x ((Precious(x) ∧ Hungry(x))) → (¬Gleaming(morgan)) ::: If there is someone who is both precious and hungry, then Morgan is not gleaming.\n",
            "First-Order-Logic Question": "¬Gleaming(ernest) ::: Ernest is not gleaming."
        },
        "gram_prog": {
            "First-Order-Logic Rules": "¬Hungry(morgan) ::: Morgan is not hungry.\nHungry(keith) ::: Keith is hungry.\n¬Recent(ernest) ::: Ernest is not recent.\n¬Gleaming(leroy) ::: Leroy is not gleaming.\n¬Recent(keith) ::: Keith is not recent.\n¬Lovely(cara) ::: Cara is not lovely.\n¬Precious(cary) ::: Cary is not precious.\n¬Lovely(leroy) ::: Leroy is not lovely.\n¬Recent(morgan) ::: Morgan is not recent.\n¬Precious(leroy) ::: Leroy is not precious.\nFat(leroy) ::: Leroy is fat.\n¬Hungry(ernest) ::: Ernest is not hungry.\n(∀x ((Gleaming(x) ∧ ¬Fat(x)) ↔ ¬Hungry(x))) ::: If someone is gleaming and not fat, then he is not hungry, and vice versa.\n(Fat(leroy)) → (Hungry(leroy) ∧ Lovely(ernest)) ::: If Leroy is fat, then Leroy is hungry and Ernest is lovely.\n(∀x (Fat(x))) → (¬Gleaming(cary)) ::: If all people are fat, then Cary is not gleaming.\n(∃x ((Gleaming(x) ∧ ¬Recent(x))) → (¬Precious(ronald) ∧ ¬Hungry(cara))) ::: If there is someone who is both gleaming and not recent, then Ronald is not precious and Cara is not hungry.\n(∃x (¬Fat(x))) → (Lovely(cary) ∧ Hungry(ernest)) ::: If there is someone who is not fat, then Cary is lovely and Ernest is hungry.\n((Gleaming(cara))) ↔ (¬Hungry(keith)) ::: Cara being gleaming is equivalent to Keith being not hungry.\n(∀x (¬Lovely(x))) → (Precious(x) ∧ ¬Gleaming(x)) ::: As long as someone is not lovely, he is precious and not gleaming.\n¬(Lovely(x)∧Fat(x))→Hungry(x) ::: If someone who is not lovely is also fat, then he is hungry.\n(∀x ((Gleaming(x) ∧ ¬Lovely(x)) ↔ (Fat(x) ∧ ¬Precious(x)))) ::: If someone is gleaming and not lovely, then he is both fat and not precious, and vice versa.\n((Gleaming(cary))) → (Lovely(cary)) ::: If Cary is gleaming, then Cary is lovely.\n¬(Hungry(x)∨Fat(x))→Lovely(x) ::: If there is someone who is either fat or not hungry, then Cary is not lovely.\n∃x((Hungry(x)∧Recent(x))) ::: If there is someone who is both precious and hungry, then Morgan is not gleaming.\n",
            "First-Order-Logic Question": "¬Gleaming(ernest) ::: Ernest is not gleaming."
        },
        "diff": [
            {
                "raw": "(∃x ((¬Lovely(x) ∧ Fat(x))) → (Hungry(x)) ::: If someone who is not lovely is also fat, then he is hungry.",
                "gram": "¬(Lovely(x)∧Fat(x))→Hungry(x) ::: If someone who is not lovely is also fat, then he is hungry."
            },
            {
                "raw": "(∃x ((Fat(x) ∨ ¬Hungry(x))) → (¬Lovely(cary)) ::: If there is someone who is either fat or not hungry, then Cary is not lovely.",
                "gram": "¬(Hungry(x)∨Fat(x))→Lovely(x) ::: If there is someone who is either fat or not hungry, then Cary is not lovely."
            },
            {
                "raw": "(∃x ((Precious(x) ∧ Hungry(x))) → (¬Gleaming(morgan)) ::: If there is someone who is both precious and hungry, then Morgan is not gleaming.",
                "gram": "∃x((Hungry(x)∧Recent(x))) ::: If there is someone who is both precious and hungry, then Morgan is not gleaming."
            }
        ],
        "answer": "B",
        "grammar_answer": "A",
        "manual_prog": {
            "First-Order-Logic Rules": "¬Hungry(morgan) ::: Morgan is not hungry.\nHungry(keith) ::: Keith is hungry.\n¬Recent(ernest) ::: Ernest is not recent.\n¬Gleaming(leroy) ::: Leroy is not gleaming.\n¬Recent(keith) ::: Keith is not recent.\n¬Lovely(cara) ::: Cara is not lovely.\n¬Precious(cary) ::: Cary is not precious.\n¬Lovely(leroy) ::: Leroy is not lovely.\n¬Recent(morgan) ::: Morgan is not recent.\n¬Precious(leroy) ::: Leroy is not precious.\nFat(leroy) ::: Leroy is fat.\n¬Hungry(ernest) ::: Ernest is not hungry.\n(∀x ((Gleaming(x) ∧ ¬Fat(x)) ↔ ¬Hungry(x))) ::: If someone is gleaming and not fat, then he is not hungry, and vice versa.\n(Fat(leroy)) → (Hungry(leroy) ∧ Lovely(ernest)) ::: If Leroy is fat, then Leroy is hungry and Ernest is lovely.\n(∀x (Fat(x))) → (¬Gleaming(cary)) ::: If all people are fat, then Cary is not gleaming.\n(∃x ((Gleaming(x) ∧ ¬Recent(x))) → (¬Precious(ronald) ∧ ¬Hungry(cara))) ::: If there is someone who is both gleaming and not recent, then Ronald is not precious and Cara is not hungry.\n(∃x (¬Fat(x))) → (Lovely(cary) ∧ Hungry(ernest)) ::: If there is someone who is not fat, then Cary is lovely and Ernest is hungry.\n((Gleaming(cara))) ↔ (¬Hungry(keith)) ::: Cara being gleaming is equivalent to Keith being not hungry.\n(∀x (¬Lovely(x))) → (Precious(x) ∧ ¬Gleaming(x)) ::: As long as someone is not lovely, he is precious and not gleaming.\n(∃x ((¬Lovely(x) ∧ Fat(x))) → (Hungry(x))) ::: If someone who is not lovely is also fat, then he is hungry.\n(∀x ((Gleaming(x) ∧ ¬Lovely(x)) ↔ (Fat(x) ∧ ¬Precious(x)))) ::: If someone is gleaming and not lovely, then he is both fat and not precious, and vice versa.\n((Gleaming(cary))) → (Lovely(cary)) ::: If Cary is gleaming, then Cary is lovely.\n(∃x ((Fat(x) ∨ ¬Hungry(x))) → (¬Lovely(cary))) ::: If there is someone who is either fat or not hungry, then Cary is not lovely.\n(∃x ((Precious(x) ∧ Hungry(x))) → (¬Gleaming(morgan))) ::: If there is someone who is both precious and hungry, then Morgan is not gleaming.\n",
            "First-Order-Logic Question": "¬Gleaming(ernest) ::: Ernest is not gleaming."
        },
        "fixed": true
    },
    {
        "id": 360,
        "raw_prog": {
            "First-Order-Logic Rules": "¬Able(jasper) ::: Jasper is not able.\n¬Frank(jack) ::: Jack is not frank.\nCivil(jasper) ::: Jasper is civil.\n¬Civil(george) ::: George is not civil.\nFrank(burgess) ::: Burgess is frank.\nJolly(roderick) ::: Roderick is jolly.\n¬Civil(myra) ::: Myra is not civil.\nPrecious(roderick) ::: Roderick is precious.\nJolly(jack) ::: Jack is jolly.\n¬Able(burgess) ::: Burgess is not able.\n¬Jolly(miles) ::: Miles is not jolly.\nJolly(jasper) ::: Jasper is jolly.\n((Jolly(burgess))) → ((¬Able(roderick))) ::: It can be concluded that Roderick is not able once knowing that Burgess is jolly.\n(∃x (Able(x) ∧ Jolly(x))) → ((¬Frank(jasper))) ::: If there is someone who is both able and jolly, then Jasper is not frank.\n(∃x (¬Frank(x) ∨ ¬Civil(x))) → ((Able(roderick))) ::: If there is at least one people who is not frank or not civil, then Roderick is able.\n(∃x (Able(x))) → ((¬Frank(george) ∧ ¬Technical(jack))) ::: If there is someone who is able, then George is not frank and Jack is not technical.\n(¬(∃x (¬x))) → ((¬Frank(jack))) ::: If there is nobody who is not, then Jack is not frank.\n(∃x (¬Frank(x) ∨ ¬Precious(x))) → ((¬Able(roderick))) ::: If there is at least one people who is not frank or not precious, then Roderick is not able.\n(∀x (Frank(x))) → ((¬Precious(x) ∧ ¬Civil(x))) ::: If someone is frank, then he is neither precious nor civil.\n((¬Jolly(burgess) ∨ ¬Civil(roderick))) → ((¬Technical(george))) ::: It can be concluded that George is not technical once knowing that Burgess is not jolly or Roderick is not civil.\n(∀x (Precious(x))) ↔ ((¬Frank(x))) ::: If someone is precious, then he is not frank, and vice versa.\n(∀x (x ∨ Precious(x))) → ((¬Jolly(x))) ::: If someone is he or not precious is technical, then he is not jolly.\n(∀x (¬Civil(x) ∧ ¬Jolly(x))) ↔ ((Able(x))) ::: If someone is not civil and not jolly, then he is able, and vice versa.\n((Able(roderick))) → ((Precious(burgess) ∧ ¬Civil(jack))) ::: Roderick being able implies that Burgess is precious and Jack is not civil.\n",
            "First-Order-Logic Question": "Civil(myra) ::: Myra is civil."
        },
        "gram_prog": {
            "First-Order-Logic Rules": "¬Able(jasper) ::: Jasper is not able.\n¬Frank(jack) ::: Jack is not frank.\nCivil(jasper) ::: Jasper is civil.\n¬Civil(george) ::: George is not civil.\nFrank(burgess) ::: Burgess is frank.\nJolly(roderick) ::: Roderick is jolly.\n¬Civil(myra) ::: Myra is not civil.\nPrecious(roderick) ::: Roderick is precious.\nJolly(jack) ::: Jack is jolly.\n¬Able(burgess) ::: Burgess is not able.\n¬Jolly(miles) ::: Miles is not jolly.\nJolly(jasper) ::: Jasper is jolly.\n((Jolly(burgess))) → ((¬Able(roderick))) ::: It can be concluded that Roderick is not able once knowing that Burgess is jolly.\n(∃x (Able(x) ∧ Jolly(x))) → ((¬Frank(jasper))) ::: If there is someone who is both able and jolly, then Jasper is not frank.\n(∃x (¬Frank(x) ∨ ¬Civil(x))) → ((Able(roderick))) ::: If there is at least one people who is not frank or not civil, then Roderick is able.\n(∃x (Able(x))) → ((¬Frank(george) ∧ ¬Technical(jack))) ::: If there is someone who is able, then George is not frank and Jack is not technical.\n¬(¬(¬(Serious(x)))) ::: If there is nobody who is not, then Jack is not frank.\n(∃x (¬Frank(x) ∨ ¬Precious(x))) → ((¬Able(roderick))) ::: If there is at least one people who is not frank or not precious, then Roderick is not able.\n(∀x (Frank(x))) → ((¬Precious(x) ∧ ¬Civil(x))) ::: If someone is frank, then he is neither precious nor civil.\n((¬Jolly(burgess) ∨ ¬Civil(roderick))) → ((¬Technical(george))) ::: It can be concluded that George is not technical once knowing that Burgess is not jolly or Roderick is not civil.\n(∀x (Precious(x))) ↔ ((¬Frank(x))) ::: If someone is precious, then he is not frank, and vice versa.\n¬(Serious(x)→(Fresh(x))) ::: If someone is he or not precious is technical, then he is not jolly.\n(∀x (¬Civil(x) ∧ ¬Jolly(x))) ↔ ((Able(x))) ::: If someone is not civil and not jolly, then he is able, and vice versa.\n((Able(roderick))) → ((Precious(burgess) ∧ ¬Civil(jack))) ::: Roderick being able implies that Burgess is precious and Jack is not civil.\n",
            "First-Order-Logic Question": "Civil(myra) ::: Myra is civil."
        },
        "diff": [
            {
                "raw": "(¬(∃x (¬x))) → ((¬Frank(jack))) ::: If there is nobody who is not, then Jack is not frank.",
                "gram": "¬(¬(¬(Serious(x)))) ::: If there is nobody who is not, then Jack is not frank."
            },
            {
                "raw": "(∀x (x ∨ Precious(x))) → ((¬Jolly(x))) ::: If someone is he or not precious is technical, then he is not jolly.",
                "gram": "¬(Serious(x)→(Fresh(x))) ::: If someone is he or not precious is technical, then he is not jolly."
            }
        ],
        "answer": "B",
        "grammar_answer": "A",
        "manual_prog": {
            "First-Order-Logic Rules": "¬Able(jasper) ::: Jasper is not able.\n¬Frank(jack) ::: Jack is not frank.\nCivil(jasper) ::: Jasper is civil.\n¬Civil(george) ::: George is not civil.\nFrank(burgess) ::: Burgess is frank.\nJolly(roderick) ::: Roderick is jolly.\n¬Civil(myra) ::: Myra is not civil.\nPrecious(roderick) ::: Roderick is precious.\nJolly(jack) ::: Jack is jolly.\n¬Able(burgess) ::: Burgess is not able.\n¬Jolly(miles) ::: Miles is not jolly.\nJolly(jasper) ::: Jasper is jolly.\n((Jolly(burgess))) → ((¬Able(roderick))) ::: It can be concluded that Roderick is not able once knowing that Burgess is jolly.\n(∃x (Able(x) ∧ Jolly(x))) → ((¬Frank(jasper))) ::: If there is someone who is both able and jolly, then Jasper is not frank.\n(∃x (¬Frank(x) ∨ ¬Civil(x))) → ((Able(roderick))) ::: If there is at least one people who is not frank or not civil, then Roderick is able.\n(∃x (Able(x))) → ((¬Frank(george) ∧ ¬Technical(jack))) ::: If there is someone who is able, then George is not frank and Jack is not technical.\n(∃x ¬Not(x)) → ((¬Frank(jack))) ::: If there is nobody who is not, then Jack is not frank.\n(∃x (¬Frank(x) ∨ ¬Precious(x))) → ((¬Able(roderick))) ::: If there is at least one people who is not frank or not precious, then Roderick is not able.\n(∀x (Frank(x))) → ((¬Precious(x) ∧ ¬Civil(x))) ::: If someone is frank, then he is neither precious nor civil.\n((¬Jolly(burgess) ∨ ¬Civil(roderick))) → ((¬Technical(george))) ::: It can be concluded that George is not technical once knowing that Burgess is not jolly or Roderick is not civil.\n(∀x (Precious(x))) ↔ ((¬Frank(x))) ::: If someone is precious, then he is not frank, and vice versa.\n(∃x (Precious(x))) → ((¬Jolly(x))) ::: If someone is he or not precious is technical, then he is not jolly.\n(∀x (¬Civil(x) ∧ ¬Jolly(x))) ↔ ((Able(x))) ::: If someone is not civil and not jolly, then he is able, and vice versa.\n((Able(roderick))) → ((Precious(burgess) ∧ ¬Civil(jack))) ::: Roderick being able implies that Burgess is precious and Jack is not civil.\n",
            "First-Order-Logic Question": "Civil(myra) ::: Myra is civil."
        },
        "fixed": true
    },
    {
        "id": 362,
        "raw_prog": {
            "First-Order-Logic Rules": "¬Able(jasper) ::: Jasper is not able.\n¬Frank(jack) ::: Jack is not frank.\nCivil(jasper) ::: Jasper is civil.\n¬Civil(george) ::: George is not civil.\nFrank(burgess) ::: Burgess is frank.\nJolly(roderick) ::: Roderick is jolly.\n¬Civil(myra) ::: Myra is not civil.\nPrecious(roderick) ::: Roderick is precious.\nJolly(jack) ::: Jack is jolly.\n¬Able(burgess) ::: Burgess is not able.\n¬Jolly(miles) ::: Miles is not jolly.\nJolly(jasper) ::: Jasper is jolly.\n((Jolly(burgess))) → ((¬Able(roderick))) ::: It can be concluded that Roderick is not able once knowing that Burgess is jolly.\n(∃x (Able(x) ∧ Jolly(x))) → ((¬Frank(jasper))) ::: If there is someone who is both able and jolly, then Jasper is not frank.\n(∃x (¬Frank(x) ∨ ¬Civil(x))) → ((Able(roderick))) ::: If there is at least one people who is not frank or not civil, then Roderick is able.\n(∃x (Able(x))) → ((¬Frank(george) ∧ ¬Technical(jack))) ::: If there is someone who is able, then George is not frank and Jack is not technical.\n(¬(∃x (¬x))) → ((¬Frank(jack))) ::: If there is nobody who is not, then Jack is not frank.\n(∃x (¬Frank(x) ∨ ¬Precious(x))) → ((¬Able(roderick))) ::: If there is at least one people who is not frank or not precious, then Roderick is not able.\n(∀x (Frank(x))) → ((¬Precious(x) ∧ ¬Civil(x))) ::: If someone is frank, then he is neither precious nor civil.\n((¬Jolly(burgess) ∨ ¬Civil(roderick))) → ((¬Technical(george))) ::: It can be concluded that George is not technical once knowing that Burgess is not jolly or Roderick is not civil.\n(∀x (Precious(x))) ↔ ((¬Frank(x))) ::: If someone is precious, then he is not frank, and vice versa.\n(∀x (x ∨ Precious(x))) → ((¬Jolly(x))) ::: If someone is he or not precious is technical, then he is not jolly.\n(∀x (¬Civil(x) ∧ ¬Jolly(x))) ↔ ((Able(x))) ::: If someone is not civil and not jolly, then he is able, and vice versa.\n((Able(roderick))) → ((Precious(burgess) ∧ ¬Civil(jack))) ::: Roderick being able implies that Burgess is precious and Jack is not civil.\n",
            "First-Order-Logic Question": "Precious(myra) ::: Myra is precious."
        },
        "gram_prog": {
            "First-Order-Logic Rules": "¬Able(jasper) ::: Jasper is not able.\n¬Frank(jack) ::: Jack is not frank.\nCivil(jasper) ::: Jasper is civil.\n¬Civil(george) ::: George is not civil.\nFrank(burgess) ::: Burgess is frank.\nJolly(roderick) ::: Roderick is jolly.\n¬Civil(myra) ::: Myra is not civil.\nPrecious(roderick) ::: Roderick is precious.\nJolly(jack) ::: Jack is jolly.\n¬Able(burgess) ::: Burgess is not able.\n¬Jolly(miles) ::: Miles is not jolly.\nJolly(jasper) ::: Jasper is jolly.\n((Jolly(burgess))) → ((¬Able(roderick))) ::: It can be concluded that Roderick is not able once knowing that Burgess is jolly.\n(∃x (Able(x) ∧ Jolly(x))) → ((¬Frank(jasper))) ::: If there is someone who is both able and jolly, then Jasper is not frank.\n(∃x (¬Frank(x) ∨ ¬Civil(x))) → ((Able(roderick))) ::: If there is at least one people who is not frank or not civil, then Roderick is able.\n(∃x (Able(x))) → ((¬Frank(george) ∧ ¬Technical(jack))) ::: If there is someone who is able, then George is not frank and Jack is not technical.\n¬(¬(¬(Serious(x)))) ::: If there is nobody who is not, then Jack is not frank.\n(∃x (¬Frank(x) ∨ ¬Precious(x))) → ((¬Able(roderick))) ::: If there is at least one people who is not frank or not precious, then Roderick is not able.\n(∀x (Frank(x))) → ((¬Precious(x) ∧ ¬Civil(x))) ::: If someone is frank, then he is neither precious nor civil.\n((¬Jolly(burgess) ∨ ¬Civil(roderick))) → ((¬Technical(george))) ::: It can be concluded that George is not technical once knowing that Burgess is not jolly or Roderick is not civil.\n(∀x (Precious(x))) ↔ ((¬Frank(x))) ::: If someone is precious, then he is not frank, and vice versa.\n¬(Serious(x)→(Fresh(x))) ::: If someone is he or not precious is technical, then he is not jolly.\n(∀x (¬Civil(x) ∧ ¬Jolly(x))) ↔ ((Able(x))) ::: If someone is not civil and not jolly, then he is able, and vice versa.\n((Able(roderick))) → ((Precious(burgess) ∧ ¬Civil(jack))) ::: Roderick being able implies that Burgess is precious and Jack is not civil.\n",
            "First-Order-Logic Question": "Precious(myra) ::: Myra is precious."
        },
        "diff": [
            {
                "raw": "(¬(∃x (¬x))) → ((¬Frank(jack))) ::: If there is nobody who is not, then Jack is not frank.",
                "gram": "¬(¬(¬(Serious(x)))) ::: If there is nobody who is not, then Jack is not frank."
            },
            {
                "raw": "(∀x (x ∨ Precious(x))) → ((¬Jolly(x))) ::: If someone is he or not precious is technical, then he is not jolly.",
                "gram": "¬(Serious(x)→(Fresh(x))) ::: If someone is he or not precious is technical, then he is not jolly."
            }
        ],
        "answer": "C",
        "grammar_answer": "A",
        "manual_prog": {
            "First-Order-Logic Rules": "¬Able(jasper) ::: Jasper is not able.\n¬Frank(jack) ::: Jack is not frank.\nCivil(jasper) ::: Jasper is civil.\n¬Civil(george) ::: George is not civil.\nFrank(burgess) ::: Burgess is frank.\nJolly(roderick) ::: Roderick is jolly.\n¬Civil(myra) ::: Myra is not civil.\nPrecious(roderick) ::: Roderick is precious.\nJolly(jack) ::: Jack is jolly.\n¬Able(burgess) ::: Burgess is not able.\n¬Jolly(miles) ::: Miles is not jolly.\nJolly(jasper) ::: Jasper is jolly.\n((Jolly(burgess))) → ((¬Able(roderick))) ::: It can be concluded that Roderick is not able once knowing that Burgess is jolly.\n(∃x (Able(x) ∧ Jolly(x))) → ((¬Frank(jasper))) ::: If there is someone who is both able and jolly, then Jasper is not frank.\n(∃x (¬Frank(x) ∨ ¬Civil(x))) → ((Able(roderick))) ::: If there is at least one people who is not frank or not civil, then Roderick is able.\n(∃x (Able(x))) → ((¬Frank(george) ∧ ¬Technical(jack))) ::: If there is someone who is able, then George is not frank and Jack is not technical.\n(∃x ¬Not(x)) → ((¬Frank(jack))) ::: If there is nobody who is not, then Jack is not frank.\n(∃x (¬Frank(x) ∨ ¬Precious(x))) → ((¬Able(roderick))) ::: If there is at least one people who is not frank or not precious, then Roderick is not able.\n(∀x (Frank(x))) → ((¬Precious(x) ∧ ¬Civil(x))) ::: If someone is frank, then he is neither precious nor civil.\n((¬Jolly(burgess) ∨ ¬Civil(roderick))) → ((¬Technical(george))) ::: It can be concluded that George is not technical once knowing that Burgess is not jolly or Roderick is not civil.\n(∀x (Precious(x))) ↔ ((¬Frank(x))) ::: If someone is precious, then he is not frank, and vice versa.\n(∃x (Precious(x))) → ((¬Jolly(x))) ::: If someone is he or not precious is technical, then he is not jolly.\n(∀x (¬Civil(x) ∧ ¬Jolly(x))) ↔ ((Able(x))) ::: If someone is not civil and not jolly, then he is able, and vice versa.\n((Able(roderick))) → ((Precious(burgess) ∧ ¬Civil(jack))) ::: Roderick being able implies that Burgess is precious and Jack is not civil.\n",
            "First-Order-Logic Question": "Precious(myra) ::: Myra is precious."
        },
        "fixed": true
    },
    {
        "id": 364,
        "raw_prog": {
            "First-Order-Logic Rules": "¬Precious(roderick) ::: Roderick is not precious.\n(∃x (Jolly(x) ∧ Able(x))) → (¬Frank(jasper)) ::: If there is someone who is both able and jolly, then Jasper is not frank.\n(∃x (¬Frank(x) ∨ ¬Civil(x))) → (Able(roderick)) ::: If there is at least one people who is not frank or not civil, then Roderick is able.\n(∃x (Able(x))) → (¬Frank(george) ∧ ¬Technical(jack)) ::: If there is someone who is able, then George is not frank and Jack is not technical.\n(¬∃x (¬Blue(x))) → (¬Frank(jack)) ::: If there is nobody who is not, then Jack is not frank.\n(∃x (¬Frank(x) ∨ ¬Precious(x))) → (¬Able(roderick)) ::: If there is at least one people who is not frank or not precious, then Roderick is not able.\n(∀x (Frank(x))) → (¬Precious(x) ∧ ¬Civil(x)) ::: If someone is frank, then he is neither precious nor civil.\n(¬Technical(george)) → (¬Jolly(burgess) ∨ ¬Civil(roderick)) ::: It can be concluded that George is not technical once knowing that Burgess is not jolly or Roderick is not civil.\n(∀x (Precious(x))) ↔ (¬Frank(x)) ::: If someone is precious, then he is not frank, and vice versa.\n(∀x (Precious(x) ∨ Technical(x))) → (¬Jolly(x)) ::: If someone is he or not precious is technical, then he is not jolly.\n(∀x (¬Civil(x) ∧ ¬Jolly(x))) ↔ (Able(x)) ::: If someone is not civil and not jolly, then he is able, and vice versa.\n(Able(roderick)) → (Precious(burgess) ∧ ¬Civil(jack)) ::: Roderick being able implies that Burgess is precious and Jack is not civil.\n",
            "First-Order-Logic Question": "¬Precious(roderick) ::: Roderick is not precious."
        },
        "gram_prog": {
            "First-Order-Logic Rules": "¬Precious(roderick) ::: Roderick is not precious.\n(∃x (Jolly(x) ∧ Able(x))) → (¬Frank(jasper)) ::: If there is someone who is both able and jolly, then Jasper is not frank.\n(∃x (¬Frank(x) ∨ ¬Civil(x))) → (Able(roderick)) ::: If there is at least one people who is not frank or not civil, then Roderick is able.\n(∃x (Able(x))) → (¬Frank(george) ∧ ¬Technical(jack)) ::: If there is someone who is able, then George is not frank and Jack is not technical.\n¬∃x(¬Blue(x))→¬Fresh(x) ::: If there is nobody who is not, then Jack is not frank.\n(∃x (¬Frank(x) ∨ ¬Precious(x))) → (¬Able(roderick)) ::: If there is at least one people who is not frank or not precious, then Roderick is not able.\n(∀x (Frank(x))) → (¬Precious(x) ∧ ¬Civil(x)) ::: If someone is frank, then he is neither precious nor civil.\n(¬Technical(george)) → (¬Jolly(burgess) ∨ ¬Civil(roderick)) ::: It can be concluded that George is not technical once knowing that Burgess is not jolly or Roderick is not civil.\n(∀x (Precious(x))) ↔ (¬Frank(x)) ::: If someone is precious, then he is not frank, and vice versa.\n(∀x (Precious(x) ∨ Technical(x))) → (¬Jolly(x)) ::: If someone is he or not precious is technical, then he is not jolly.\n(∀x (¬Civil(x) ∧ ¬Jolly(x))) ↔ (Able(x)) ::: If someone is not civil and not jolly, then he is able, and vice versa.\n(Able(roderick)) → (Precious(burgess) ∧ ¬Civil(jack)) ::: Roderick being able implies that Burgess is precious and Jack is not civil.\n",
            "First-Order-Logic Question": "¬Precious(roderick) ::: Roderick is not precious."
        },
        "diff": [
            {
                "raw": "(¬∃x (¬Blue(x))) → (¬Frank(jack)) ::: If there is nobody who is not, then Jack is not frank.",
                "gram": "¬∃x(¬Blue(x))→¬Fresh(x) ::: If there is nobody who is not, then Jack is not frank."
            }
        ],
        "answer": "B",
        "grammar_answer": "A",
        "manual_prog": {
            "First-Order-Logic Rules": "¬Precious(roderick) ::: Roderick is not precious.\n(∃x (Jolly(x) ∧ Able(x))) → (¬Frank(jasper)) ::: If there is someone who is both able and jolly, then Jasper is not frank.\n(∃x (¬Frank(x) ∨ ¬Civil(x))) → (Able(roderick)) ::: If there is at least one people who is not frank or not civil, then Roderick is able.\n(∃x (Able(x))) → (¬Frank(george) ∧ ¬Technical(jack)) ::: If there is someone who is able, then George is not frank and Jack is not technical.\n(∃x ¬(¬Blue(x))) → (¬Frank(jack)) ::: If there is nobody who is not, then Jack is not frank.\n(∃x (¬Frank(x) ∨ ¬Precious(x))) → (¬Able(roderick)) ::: If there is at least one people who is not frank or not precious, then Roderick is not able.\n(∀x (Frank(x))) → (¬Precious(x) ∧ ¬Civil(x)) ::: If someone is frank, then he is neither precious nor civil.\n(¬Technical(george)) → (¬Jolly(burgess) ∨ ¬Civil(roderick)) ::: It can be concluded that George is not technical once knowing that Burgess is not jolly or Roderick is not civil.\n(∀x (Precious(x))) ↔ (¬Frank(x)) ::: If someone is precious, then he is not frank, and vice versa.\n(∀x (Precious(x) ∨ Technical(x))) → (¬Jolly(x)) ::: If someone is he or not precious is technical, then he is not jolly.\n(∀x (¬Civil(x) ∧ ¬Jolly(x))) ↔ (Able(x)) ::: If someone is not civil and not jolly, then he is able, and vice versa.\n(Able(roderick)) → (Precious(burgess) ∧ ¬Civil(jack)) ::: Roderick being able implies that Burgess is precious and Jack is not civil.\n",
            "First-Order-Logic Question": "¬Precious(roderick) ::: Roderick is not precious."
        },
        "fixed": true
    },
    {
        "id": 365,
        "raw_prog": {
            "First-Order-Logic Rules": "¬Able(jasper) ::: Jasper is not able.\n¬Frank(jack) ::: Jack is not frank.\nCivil(jasper) ::: Jasper is civil.\n¬Civil(george) ::: George is not civil.\nFrank(burgess) ::: Burgess is frank.\nJolly(roderick) ::: Roderick is jolly.\n¬Civil(myra) ::: Myra is not civil.\nPrecious(roderick) ::: Roderick is precious.\nJolly(jack) ::: Jack is jolly.\n¬Able(burgess) ::: Burgess is not able.\n¬Jolly(miles) ::: Miles is not jolly.\nJolly(jasper) ::: Jasper is jolly.\n((Jolly(burgess))) → ((¬Able(roderick))) ::: It can be concluded that Roderick is not able once knowing that Burgess is jolly.\n(∃x (Able(x) ∧ Jolly(x))) → ((¬Frank(jasper))) ::: If there is someone who is both able and jolly, then Jasper is not frank.\n(∃x (¬Frank(x) ∨ ¬Civil(x))) → ((Able(roderick))) ::: If there is at least one people who is not frank or not civil, then Roderick is able.\n(∃x (Able(x))) → ((¬Frank(george) ∧ ¬Technical(jack))) ::: If there is someone who is able, then George is not frank and Jack is not technical.\n(¬(∃x (¬x))) → ((¬Frank(jack))) ::: If there is nobody who is not, then Jack is not frank.\n(∃x (¬Frank(x) ∨ ¬Precious(x))) → ((¬Able(roderick))) ::: If there is at least one people who is not frank or not precious, then Roderick is not able.\n(∀x (Frank(x))) → ((¬Precious(x) ∧ ¬Civil(x))) ::: If someone is frank, then he is neither precious nor civil.\n((¬Jolly(burgess) ∨ ¬Civil(roderick))) → ((¬Technical(george))) ::: It can be concluded that George is not technical once knowing that Burgess is not jolly or Roderick is not civil.\n(∀x (Precious(x))) ↔ ((¬Frank(x))) ::: If someone is precious, then he is not frank, and vice versa.\n(∀x (Precious(x) ∨ Technical(x))) → ((¬Jolly(x))) ::: If someone is he or not precious is technical, then he is not jolly.\n(∀x (¬Civil(x) ∧ ¬Jolly(x))) ↔ ((Able(x))) ::: If someone is not civil and not jolly, then he is able, and vice versa.\n((Able(roderick))) → ((Precious(burgess) ∧ ¬Civil(jack))) ::: Roderick being able implies that Burgess is precious and Jack is not civil.\n",
            "First-Order-Logic Question": "Civil(roderick) ::: Roderick is civil."
        },
        "gram_prog": {
            "First-Order-Logic Rules": "¬Able(jasper) ::: Jasper is not able.\n¬Frank(jack) ::: Jack is not frank.\nCivil(jasper) ::: Jasper is civil.\n¬Civil(george) ::: George is not civil.\nFrank(burgess) ::: Burgess is frank.\nJolly(roderick) ::: Roderick is jolly.\n¬Civil(myra) ::: Myra is not civil.\nPrecious(roderick) ::: Roderick is precious.\nJolly(jack) ::: Jack is jolly.\n¬Able(burgess) ::: Burgess is not able.\n¬Jolly(miles) ::: Miles is not jolly.\nJolly(jasper) ::: Jasper is jolly.\n((Jolly(burgess))) → ((¬Able(roderick))) ::: It can be concluded that Roderick is not able once knowing that Burgess is jolly.\n(∃x (Able(x) ∧ Jolly(x))) → ((¬Frank(jasper))) ::: If there is someone who is both able and jolly, then Jasper is not frank.\n(∃x (¬Frank(x) ∨ ¬Civil(x))) → ((Able(roderick))) ::: If there is at least one people who is not frank or not civil, then Roderick is able.\n(∃x (Able(x))) → ((¬Frank(george) ∧ ¬Technical(jack))) ::: If there is someone who is able, then George is not frank and Jack is not technical.\n¬((¬Frank(x))→(¬Able(x))) ::: If there is nobody who is not, then Jack is not frank.\n(∃x (¬Frank(x) ∨ ¬Precious(x))) → ((¬Able(roderick))) ::: If there is at least one people who is not frank or not precious, then Roderick is not able.\n(∀x (Frank(x))) → ((¬Precious(x) ∧ ¬Civil(x))) ::: If someone is frank, then he is neither precious nor civil.\n((¬Jolly(burgess) ∨ ¬Civil(roderick))) → ((¬Technical(george))) ::: It can be concluded that George is not technical once knowing that Burgess is not jolly or Roderick is not civil.\n(∀x (Precious(x))) ↔ ((¬Frank(x))) ::: If someone is precious, then he is not frank, and vice versa.\n(∀x (Precious(x) ∨ Technical(x))) → ((¬Jolly(x))) ::: If someone is he or not precious is technical, then he is not jolly.\n(∀x (¬Civil(x) ∧ ¬Jolly(x))) ↔ ((Able(x))) ::: If someone is not civil and not jolly, then he is able, and vice versa.\n((Able(roderick))) → ((Precious(burgess) ∧ ¬Civil(jack))) ::: Roderick being able implies that Burgess is precious and Jack is not civil.\n",
            "First-Order-Logic Question": "Civil(roderick) ::: Roderick is civil."
        },
        "diff": [
            {
                "raw": "(¬(∃x (¬x))) → ((¬Frank(jack))) ::: If there is nobody who is not, then Jack is not frank.",
                "gram": "¬((¬Frank(x))→(¬Able(x))) ::: If there is nobody who is not, then Jack is not frank."
            }
        ],
        "answer": "B",
        "grammar_answer": "A",
        "manual_prog": {
            "First-Order-Logic Rules": "¬Able(jasper) ::: Jasper is not able.\n¬Frank(jack) ::: Jack is not frank.\nCivil(jasper) ::: Jasper is civil.\n¬Civil(george) ::: George is not civil.\nFrank(burgess) ::: Burgess is frank.\nJolly(roderick) ::: Roderick is jolly.\n¬Civil(myra) ::: Myra is not civil.\nPrecious(roderick) ::: Roderick is precious.\nJolly(jack) ::: Jack is jolly.\n¬Able(burgess) ::: Burgess is not able.\n¬Jolly(miles) ::: Miles is not jolly.\nJolly(jasper) ::: Jasper is jolly.\n((Jolly(burgess))) → ((¬Able(roderick))) ::: It can be concluded that Roderick is not able once knowing that Burgess is jolly.\n(∃x (Able(x) ∧ Jolly(x))) → ((¬Frank(jasper))) ::: If there is someone who is both able and jolly, then Jasper is not frank.\n(∃x (¬Frank(x) ∨ ¬Civil(x))) → ((Able(roderick))) ::: If there is at least one people who is not frank or not civil, then Roderick is able.\n(∃x (Able(x))) → ((¬Frank(george) ∧ ¬Technical(jack))) ::: If there is someone who is able, then George is not frank and Jack is not technical.\n(∃x ¬Not(x)) → ((¬Frank(jack))) ::: If there is nobody who is not, then Jack is not frank.\n(∃x (¬Frank(x) ∨ ¬Precious(x))) → ((¬Able(roderick))) ::: If there is at least one people who is not frank or not precious, then Roderick is not able.\n(∀x (Frank(x))) → ((¬Precious(x) ∧ ¬Civil(x))) ::: If someone is frank, then he is neither precious nor civil.\n((¬Jolly(burgess) ∨ ¬Civil(roderick))) → ((¬Technical(george))) ::: It can be concluded that George is not technical once knowing that Burgess is not jolly or Roderick is not civil.\n(∀x (Precious(x))) ↔ ((¬Frank(x))) ::: If someone is precious, then he is not frank, and vice versa.\n(∀x (Precious(x) ∨ Technical(x))) → ((¬Jolly(x))) ::: If someone is he or not precious is technical, then he is not jolly.\n(∀x (¬Civil(x) ∧ ¬Jolly(x))) ↔ ((Able(x))) ::: If someone is not civil and not jolly, then he is able, and vice versa.\n((Able(roderick))) → ((Precious(burgess) ∧ ¬Civil(jack))) ::: Roderick being able implies that Burgess is precious and Jack is not civil.\n",
            "First-Order-Logic Question": "Civil(roderick) ::: Roderick is civil."
        },
        "fixed": true
    },
    {
        "id": 368,
        "raw_prog": {
            "First-Order-Logic Rules": "¬Able(jasper) ::: Jasper is not able.\n¬Frank(jack) ::: Jack is not frank.\nCivil(jasper) ::: Jasper is civil.\n¬Civil(george) ::: George is not civil.\nFrank(burgess) ::: Burgess is frank.\nJolly(roderick) ::: Roderick is jolly.\n¬Civil(myra) ::: Myra is not civil.\nPrecious(roderick) ::: Roderick is precious.\nJolly(jack) ::: Jack is jolly.\n¬Able(burgess) ::: Burgess is not able.\n¬Jolly(miles) ::: Miles is not jolly.\nJolly(jasper) ::: Jasper is jolly.\n((Jolly(burgess))) → ((¬Able(roderick))) ::: It can be concluded that Roderick is not able once knowing that Burgess is jolly.\n(∃x (Able(x) ∧ Jolly(x))) → ((¬Frank(jasper))) ::: If there is someone who is both able and jolly, then Jasper is not frank.\n(∃x (¬Frank(x) ∨ ¬Civil(x))) → ((Able(roderick))) ::: If there is at least one people who is not frank or not civil, then Roderick is able.\n(∃x (Able(x))) → ((¬Frank(george) ∧ ¬Technical(jack))) ::: If there is someone who is able, then George is not frank and Jack is not technical.\n(¬(∃x (¬x))) → ((¬Frank(jack))) ::: If there is nobody who is not, then Jack is not frank.\n(∃x (¬Frank(x) ∨ ¬Precious(x))) → ((¬Able(roderick))) ::: If there is at least one people who is not frank or not precious, then Roderick is not able.\n(∀x (Frank(x))) → ((¬Precious(x) ∧ ¬Civil(x))) ::: If someone is frank, then he is neither precious nor civil.\n((¬Jolly(burgess) ∨ ¬Civil(roderick))) → ((¬Technical(george))) ::: It can be concluded that George is not technical once knowing that Burgess is not jolly or Roderick is not civil.\n(∀x (Precious(x))) ↔ ((¬Frank(x))) ::: If someone is precious, then he is not frank, and vice versa.\n((Precious(x) ∨ ¬Technical(x))) → ((¬Jolly(x))) ::: If someone is he or not precious is technical, then he is not jolly.\n((¬Civil(x) ∧ ¬Jolly(x))) ↔ ((Able(x))) ::: If someone is not civil and not jolly, then he is able, and vice versa.\n((Able(roderick))) → ((Precious(burgess) ∧ ¬Civil(jack))) ::: Roderick being able implies that Burgess is precious and Jack is not civil.\n",
            "First-Order-Logic Question": "¬Jolly(george) ::: George is not jolly."
        },
        "gram_prog": {
            "First-Order-Logic Rules": "¬Able(jasper) ::: Jasper is not able.\n¬Frank(jack) ::: Jack is not frank.\nCivil(jasper) ::: Jasper is civil.\n¬Civil(george) ::: George is not civil.\nFrank(burgess) ::: Burgess is frank.\nJolly(roderick) ::: Roderick is jolly.\n¬Civil(myra) ::: Myra is not civil.\nPrecious(roderick) ::: Roderick is precious.\nJolly(jack) ::: Jack is jolly.\n¬Able(burgess) ::: Burgess is not able.\n¬Jolly(miles) ::: Miles is not jolly.\nJolly(jasper) ::: Jasper is jolly.\n((Jolly(burgess))) → ((¬Able(roderick))) ::: It can be concluded that Roderick is not able once knowing that Burgess is jolly.\n(∃x (Able(x) ∧ Jolly(x))) → ((¬Frank(jasper))) ::: If there is someone who is both able and jolly, then Jasper is not frank.\n(∃x (¬Frank(x) ∨ ¬Civil(x))) → ((Able(roderick))) ::: If there is at least one people who is not frank or not civil, then Roderick is able.\n(∃x (Able(x))) → ((¬Frank(george) ∧ ¬Technical(jack))) ::: If there is someone who is able, then George is not frank and Jack is not technical.\n¬(¬(¬(Serious(x)))) ::: If there is nobody who is not, then Jack is not frank.\n(∃x (¬Frank(x) ∨ ¬Precious(x))) → ((¬Able(roderick))) ::: If there is at least one people who is not frank or not precious, then Roderick is not able.\n(∀x (Frank(x))) → ((¬Precious(x) ∧ ¬Civil(x))) ::: If someone is frank, then he is neither precious nor civil.\n((¬Jolly(burgess) ∨ ¬Civil(roderick))) → ((¬Technical(george))) ::: It can be concluded that George is not technical once knowing that Burgess is not jolly or Roderick is not civil.\n(∀x (Precious(x))) ↔ ((¬Frank(x))) ::: If someone is precious, then he is not frank, and vice versa.\n((Precious(x) ∨ ¬Technical(x))) → ((¬Jolly(x))) ::: If someone is he or not precious is technical, then he is not jolly.\n((¬Civil(x) ∧ ¬Jolly(x))) ↔ ((Able(x))) ::: If someone is not civil and not jolly, then he is able, and vice versa.\n((Able(roderick))) → ((Precious(burgess) ∧ ¬Civil(jack))) ::: Roderick being able implies that Burgess is precious and Jack is not civil.\n",
            "First-Order-Logic Question": "¬Jolly(george) ::: George is not jolly."
        },
        "diff": [
            {
                "raw": "(¬(∃x (¬x))) → ((¬Frank(jack))) ::: If there is nobody who is not, then Jack is not frank.",
                "gram": "¬(¬(¬(Serious(x)))) ::: If there is nobody who is not, then Jack is not frank."
            }
        ],
        "answer": "C",
        "grammar_answer": "A",
        "manual_prog": {
            "First-Order-Logic Rules": "¬Able(jasper) ::: Jasper is not able.\n¬Frank(jack) ::: Jack is not frank.\nCivil(jasper) ::: Jasper is civil.\n¬Civil(george) ::: George is not civil.\nFrank(burgess) ::: Burgess is frank.\nJolly(roderick) ::: Roderick is jolly.\n¬Civil(myra) ::: Myra is not civil.\nPrecious(roderick) ::: Roderick is precious.\nJolly(jack) ::: Jack is jolly.\n¬Able(burgess) ::: Burgess is not able.\n¬Jolly(miles) ::: Miles is not jolly.\nJolly(jasper) ::: Jasper is jolly.\n((Jolly(burgess))) → ((¬Able(roderick))) ::: It can be concluded that Roderick is not able once knowing that Burgess is jolly.\n(∃x (Able(x) ∧ Jolly(x))) → ((¬Frank(jasper))) ::: If there is someone who is both able and jolly, then Jasper is not frank.\n(∃x (¬Frank(x) ∨ ¬Civil(x))) → ((Able(roderick))) ::: If there is at least one people who is not frank or not civil, then Roderick is able.\n(∃x (Able(x))) → ((¬Frank(george) ∧ ¬Technical(jack))) ::: If there is someone who is able, then George is not frank and Jack is not technical.\n(∃x ¬Not(x)) → ((¬Frank(jack))) ::: If there is nobody who is not, then Jack is not frank.\n(∃x (¬Frank(x) ∨ ¬Precious(x))) → ((¬Able(roderick))) ::: If there is at least one people who is not frank or not precious, then Roderick is not able.\n(∀x (Frank(x))) → ((¬Precious(x) ∧ ¬Civil(x))) ::: If someone is frank, then he is neither precious nor civil.\n((¬Jolly(burgess) ∨ ¬Civil(roderick))) → ((¬Technical(george))) ::: It can be concluded that George is not technical once knowing that Burgess is not jolly or Roderick is not civil.\n(∀x (Precious(x))) ↔ ((¬Frank(x))) ::: If someone is precious, then he is not frank, and vice versa.\n((Precious(x) ∨ ¬Technical(x))) → ((¬Jolly(x))) ::: If someone is he or not precious is technical, then he is not jolly.\n((¬Civil(x) ∧ ¬Jolly(x))) ↔ ((Able(x))) ::: If someone is not civil and not jolly, then he is able, and vice versa.\n((Able(roderick))) → ((Precious(burgess) ∧ ¬Civil(jack))) ::: Roderick being able implies that Burgess is precious and Jack is not civil.\n",
            "First-Order-Logic Question": "¬Jolly(george) ::: George is not jolly."
        },
        "fixed": true
    },
    {
        "id": 371,
        "raw_prog": {
            "First-Order-Logic Rules": "¬Able(jasper) ::: Jasper is not able.\n¬Frank(jack) ::: Jack is not frank.\nCivil(jasper) ::: Jasper is civil.\n¬Civil(george) ::: George is not civil.\nFrank(burgess) ::: Burgess is frank.\nJolly(roderick) ::: Roderick is jolly.\n¬Civil(myra) ::: Myra is not civil.\nPrecious(roderick) ::: Roderick is precious.\nJolly(jack) ::: Jack is jolly.\n¬Able(burgess) ::: Burgess is not able.\n¬Jolly(miles) ::: Miles is not jolly.\nJolly(jasper) ::: Jasper is jolly.\n((Jolly(burgess))) → ((¬Able(roderick))) ::: It can be concluded that Roderick is not able once knowing that Burgess is jolly.\n(∃x (Able(x) ∧ Jolly(x))) → ((¬Frank(jasper))) ::: If there is someone who is both able and jolly, then Jasper is not frank.\n(∃x (¬Frank(x) ∨ ¬Civil(x))) → ((Able(roderick))) ::: If there is at least one people who is not frank or not civil, then Roderick is able.\n(∃x (Able(x))) → ((¬Frank(george) ∧ ¬Technical(jack))) ::: If there is someone who is able, then George is not frank and Jack is not technical.\n(¬(∃x (¬x))) → ((¬Frank(jack))) ::: If there is nobody who is not, then Jack is not frank.\n(∃x (¬Frank(x) ∨ ¬Precious(x))) → ((¬Able(roderick))) ::: If there is at least one people who is not frank or not precious, then Roderick is not able.\n(∀x (Frank(x))) → ((¬Precious(x) ∧ ¬Civil(x))) ::: If someone is frank, then he is neither precious nor civil.\n((¬Jolly(burgess) ∨ ¬Civil(roderick))) → ((¬Technical(george))) ::: It can be concluded that George is not technical once knowing that Burgess is not jolly or Roderick is not civil.\n(∀x (Precious(x))) ↔ ((¬Frank(x))) ::: If someone is precious, then he is not frank, and vice versa.\n((Precious(x) ∨ ¬Technical(x))) → ((¬Jolly(x))) ::: If someone is he or not precious is technical, then he is not jolly.\n((¬Civil(x) ∧ ¬Jolly(x))) ↔ ((Able(x))) ::: If someone is not civil and not jolly, then he is able, and vice versa.\n((Able(roderick))) → ((Precious(burgess) ∧ ¬Civil(jack))) ::: Roderick being able implies that Burgess is precious and Jack is not civil.\n",
            "First-Order-Logic Question": "¬Able(myra) ::: Myra is not able."
        },
        "gram_prog": {
            "First-Order-Logic Rules": "¬Able(jasper) ::: Jasper is not able.\n¬Frank(jack) ::: Jack is not frank.\nCivil(jasper) ::: Jasper is civil.\n¬Civil(george) ::: George is not civil.\nFrank(burgess) ::: Burgess is frank.\nJolly(roderick) ::: Roderick is jolly.\n¬Civil(myra) ::: Myra is not civil.\nPrecious(roderick) ::: Roderick is precious.\nJolly(jack) ::: Jack is jolly.\n¬Able(burgess) ::: Burgess is not able.\n¬Jolly(miles) ::: Miles is not jolly.\nJolly(jasper) ::: Jasper is jolly.\n((Jolly(burgess))) → ((¬Able(roderick))) ::: It can be concluded that Roderick is not able once knowing that Burgess is jolly.\n(∃x (Able(x) ∧ Jolly(x))) → ((¬Frank(jasper))) ::: If there is someone who is both able and jolly, then Jasper is not frank.\n(∃x (¬Frank(x) ∨ ¬Civil(x))) → ((Able(roderick))) ::: If there is at least one people who is not frank or not civil, then Roderick is able.\n(∃x (Able(x))) → ((¬Frank(george) ∧ ¬Technical(jack))) ::: If there is someone who is able, then George is not frank and Jack is not technical.\n¬((¬Frank(x))→(¬Able(x))) ::: If there is nobody who is not, then Jack is not frank.\n(∃x (¬Frank(x) ∨ ¬Precious(x))) → ((¬Able(roderick))) ::: If there is at least one people who is not frank or not precious, then Roderick is not able.\n(∀x (Frank(x))) → ((¬Precious(x) ∧ ¬Civil(x))) ::: If someone is frank, then he is neither precious nor civil.\n((¬Jolly(burgess) ∨ ¬Civil(roderick))) → ((¬Technical(george))) ::: It can be concluded that George is not technical once knowing that Burgess is not jolly or Roderick is not civil.\n(∀x (Precious(x))) ↔ ((¬Frank(x))) ::: If someone is precious, then he is not frank, and vice versa.\n((Precious(x) ∨ ¬Technical(x))) → ((¬Jolly(x))) ::: If someone is he or not precious is technical, then he is not jolly.\n((¬Civil(x) ∧ ¬Jolly(x))) ↔ ((Able(x))) ::: If someone is not civil and not jolly, then he is able, and vice versa.\n((Able(roderick))) → ((Precious(burgess) ∧ ¬Civil(jack))) ::: Roderick being able implies that Burgess is precious and Jack is not civil.\n",
            "First-Order-Logic Question": "¬Able(myra) ::: Myra is not able."
        },
        "diff": [
            {
                "raw": "(¬(∃x (¬x))) → ((¬Frank(jack))) ::: If there is nobody who is not, then Jack is not frank.",
                "gram": "¬((¬Frank(x))→(¬Able(x))) ::: If there is nobody who is not, then Jack is not frank."
            }
        ],
        "answer": "C",
        "grammar_answer": "A",
        "manual_prog": {
            "First-Order-Logic Rules": "¬Able(jasper) ::: Jasper is not able.\n¬Frank(jack) ::: Jack is not frank.\nCivil(jasper) ::: Jasper is civil.\n¬Civil(george) ::: George is not civil.\nFrank(burgess) ::: Burgess is frank.\nJolly(roderick) ::: Roderick is jolly.\n¬Civil(myra) ::: Myra is not civil.\nPrecious(roderick) ::: Roderick is precious.\nJolly(jack) ::: Jack is jolly.\n¬Able(burgess) ::: Burgess is not able.\n¬Jolly(miles) ::: Miles is not jolly.\nJolly(jasper) ::: Jasper is jolly.\n((Jolly(burgess))) → ((¬Able(roderick))) ::: It can be concluded that Roderick is not able once knowing that Burgess is jolly.\n(∃x (Able(x) ∧ Jolly(x))) → ((¬Frank(jasper))) ::: If there is someone who is both able and jolly, then Jasper is not frank.\n(∃x (¬Frank(x) ∨ ¬Civil(x))) → ((Able(roderick))) ::: If there is at least one people who is not frank or not civil, then Roderick is able.\n(∃x (Able(x))) → ((¬Frank(george) ∧ ¬Technical(jack))) ::: If there is someone who is able, then George is not frank and Jack is not technical.\n(∃x ¬Not(x)) → ((¬Frank(jack))) ::: If there is nobody who is not, then Jack is not frank.\n(∃x (¬Frank(x) ∨ ¬Precious(x))) → ((¬Able(roderick))) ::: If there is at least one people who is not frank or not precious, then Roderick is not able.\n(∀x (Frank(x))) → ((¬Precious(x) ∧ ¬Civil(x))) ::: If someone is frank, then he is neither precious nor civil.\n((¬Jolly(burgess) ∨ ¬Civil(roderick))) → ((¬Technical(george))) ::: It can be concluded that George is not technical once knowing that Burgess is not jolly or Roderick is not civil.\n(∀x (Precious(x))) ↔ ((¬Frank(x))) ::: If someone is precious, then he is not frank, and vice versa.\n((Precious(x) ∨ ¬Technical(x))) → ((¬Jolly(x))) ::: If someone is he or not precious is technical, then he is not jolly.\n((¬Civil(x) ∧ ¬Jolly(x))) ↔ ((Able(x))) ::: If someone is not civil and not jolly, then he is able, and vice versa.\n((Able(roderick))) → ((Precious(burgess) ∧ ¬Civil(jack))) ::: Roderick being able implies that Burgess is precious and Jack is not civil.\n",
            "First-Order-Logic Question": "¬Able(myra) ::: Myra is not able."
        },
        "fixed": true
    },
    {
        "id": 372,
        "raw_prog": {
            "First-Order-Logic Rules": "¬Able(jasper) ::: Jasper is not able.\n¬Frank(jack) ::: Jack is not frank.\nCivil(jasper) ::: Jasper is civil.\n¬Civil(george) ::: George is not civil.\nFrank(burgess) ::: Burgess is frank.\nJolly(roderick) ::: Roderick is jolly.\n¬Civil(myra) ::: Myra is not civil.\nPrecious(roderick) ::: Roderick is precious.\nJolly(jack) ::: Jack is jolly.\n¬Able(burgess) ::: Burgess is not able.\n¬Jolly(miles) ::: Miles is not jolly.\nJolly(jasper) ::: Jasper is jolly.\n((Jolly(burgess))) → ((¬Able(roderick))) ::: It can be concluded that Roderick is not able once knowing that Burgess is jolly.\n(∃x (Able(x) ∧ Jolly(x))) → ((¬Frank(jasper))) ::: If there is someone who is both able and jolly, then Jasper is not frank.\n(∃x (¬Frank(x) ∨ ¬Civil(x))) → ((Able(roderick))) ::: If there is at least one people who is not frank or not civil, then Roderick is able.\n(∃x (Able(x))) → ((¬Frank(george) ∧ ¬Technical(jack))) ::: If there is someone who is able, then George is not frank and Jack is not technical.\n(¬∃x (¬x)) → ((¬Frank(jack))) ::: If there is nobody who is not, then Jack is not frank.\n(∃x (¬Frank(x) ∨ ¬Precious(x))) → ((¬Able(roderick))) ::: If there is at least one people who is not frank or not precious, then Roderick is not able.\n(∀x (Frank(x))) → ((¬Precious(x) ∧ ¬Civil(x))) ::: If someone is frank, then he is neither precious nor civil.\n((¬Jolly(burgess) ∨ ¬Civil(roderick))) → ((¬Technical(george))) ::: It can be concluded that George is not technical once knowing that Burgess is not jolly or Roderick is not civil.\n(∀x (Precious(x))) ↔ ((¬Frank(x))) ::: If someone is precious, then he is not frank, and vice versa.\n(∀x (Precious(x) ∨ Technical(x))) → ((¬Jolly(x))) ::: If someone is he or not precious is technical, then he is not jolly.\n(∀x (¬Civil(x) ∧ ¬Jolly(x))) ↔ ((Able(x))) ::: If someone is not civil and not jolly, then he is able, and vice versa.\n((Able(roderick))) → ((Precious(burgess) ∧ ¬Civil(jack))) ::: Roderick being able implies that Burgess is precious and Jack is not civil.\n",
            "First-Order-Logic Question": "¬Jolly(jack) ::: Jack is not jolly."
        },
        "gram_prog": {
            "First-Order-Logic Rules": "¬Able(jasper) ::: Jasper is not able.\n¬Frank(jack) ::: Jack is not frank.\nCivil(jasper) ::: Jasper is civil.\n¬Civil(george) ::: George is not civil.\nFrank(burgess) ::: Burgess is frank.\nJolly(roderick) ::: Roderick is jolly.\n¬Civil(myra) ::: Myra is not civil.\nPrecious(roderick) ::: Roderick is precious.\nJolly(jack) ::: Jack is jolly.\n¬Able(burgess) ::: Burgess is not able.\n¬Jolly(miles) ::: Miles is not jolly.\nJolly(jasper) ::: Jasper is jolly.\n((Jolly(burgess))) → ((¬Able(roderick))) ::: It can be concluded that Roderick is not able once knowing that Burgess is jolly.\n(∃x (Able(x) ∧ Jolly(x))) → ((¬Frank(jasper))) ::: If there is someone who is both able and jolly, then Jasper is not frank.\n(∃x (¬Frank(x) ∨ ¬Civil(x))) → ((Able(roderick))) ::: If there is at least one people who is not frank or not civil, then Roderick is able.\n(∃x (Able(x))) → ((¬Frank(george) ∧ ¬Technical(jack))) ::: If there is someone who is able, then George is not frank and Jack is not technical.\n¬∃x((¬Blue(x))→(¬Serious(x))) ::: If there is nobody who is not, then Jack is not frank.\n(∃x (¬Frank(x) ∨ ¬Precious(x))) → ((¬Able(roderick))) ::: If there is at least one people who is not frank or not precious, then Roderick is not able.\n(∀x (Frank(x))) → ((¬Precious(x) ∧ ¬Civil(x))) ::: If someone is frank, then he is neither precious nor civil.\n((¬Jolly(burgess) ∨ ¬Civil(roderick))) → ((¬Technical(george))) ::: It can be concluded that George is not technical once knowing that Burgess is not jolly or Roderick is not civil.\n(∀x (Precious(x))) ↔ ((¬Frank(x))) ::: If someone is precious, then he is not frank, and vice versa.\n(∀x (Precious(x) ∨ Technical(x))) → ((¬Jolly(x))) ::: If someone is he or not precious is technical, then he is not jolly.\n(∀x (¬Civil(x) ∧ ¬Jolly(x))) ↔ ((Able(x))) ::: If someone is not civil and not jolly, then he is able, and vice versa.\n((Able(roderick))) → ((Precious(burgess) ∧ ¬Civil(jack))) ::: Roderick being able implies that Burgess is precious and Jack is not civil.\n",
            "First-Order-Logic Question": "¬Jolly(jack) ::: Jack is not jolly."
        },
        "diff": [
            {
                "raw": "(¬∃x (¬x)) → ((¬Frank(jack))) ::: If there is nobody who is not, then Jack is not frank.",
                "gram": "¬∃x((¬Blue(x))→(¬Serious(x))) ::: If there is nobody who is not, then Jack is not frank."
            }
        ],
        "answer": "B",
        "grammar_answer": "A",
        "manual_prog": {
            "First-Order-Logic Rules": "¬Able(jasper) ::: Jasper is not able.\n¬Frank(jack) ::: Jack is not frank.\nCivil(jasper) ::: Jasper is civil.\n¬Civil(george) ::: George is not civil.\nFrank(burgess) ::: Burgess is frank.\nJolly(roderick) ::: Roderick is jolly.\n¬Civil(myra) ::: Myra is not civil.\nPrecious(roderick) ::: Roderick is precious.\nJolly(jack) ::: Jack is jolly.\n¬Able(burgess) ::: Burgess is not able.\n¬Jolly(miles) ::: Miles is not jolly.\nJolly(jasper) ::: Jasper is jolly.\n((Jolly(burgess))) → ((¬Able(roderick))) ::: It can be concluded that Roderick is not able once knowing that Burgess is jolly.\n(∃x (Able(x) ∧ Jolly(x))) → ((¬Frank(jasper))) ::: If there is someone who is both able and jolly, then Jasper is not frank.\n(∃x (¬Frank(x) ∨ ¬Civil(x))) → ((Able(roderick))) ::: If there is at least one people who is not frank or not civil, then Roderick is able.\n(∃x (Able(x))) → ((¬Frank(george) ∧ ¬Technical(jack))) ::: If there is someone who is able, then George is not frank and Jack is not technical.\n(∃x ¬Not(x)) → ((¬Frank(jack))) ::: If there is nobody who is not, then Jack is not frank.\n(∃x (¬Frank(x) ∨ ¬Precious(x))) → ((¬Able(roderick))) ::: If there is at least one people who is not frank or not precious, then Roderick is not able.\n(∀x (Frank(x))) → ((¬Precious(x) ∧ ¬Civil(x))) ::: If someone is frank, then he is neither precious nor civil.\n((¬Jolly(burgess) ∨ ¬Civil(roderick))) → ((¬Technical(george))) ::: It can be concluded that George is not technical once knowing that Burgess is not jolly or Roderick is not civil.\n(∀x (Precious(x))) ↔ ((¬Frank(x))) ::: If someone is precious, then he is not frank, and vice versa.\n(∀x (Precious(x) ∨ Technical(x))) → ((¬Jolly(x))) ::: If someone is he or not precious is technical, then he is not jolly.\n(∀x (¬Civil(x) ∧ ¬Jolly(x))) ↔ ((Able(x))) ::: If someone is not civil and not jolly, then he is able, and vice versa.\n((Able(roderick))) → ((Precious(burgess) ∧ ¬Civil(jack))) ::: Roderick being able implies that Burgess is precious and Jack is not civil.\n",
            "First-Order-Logic Question": "¬Jolly(jack) ::: Jack is not jolly."
        },
        "fixed": true
    },
    {
        "id": 373,
        "raw_prog": {
            "First-Order-Logic Rules": "¬Able(jasper) ::: Jasper is not able.\n¬Frank(jack) ::: Jack is not frank.\nCivil(jasper) ::: Jasper is civil.\n¬Civil(george) ::: George is not civil.\nFrank(burgess) ::: Burgess is frank.\nJolly(roderick) ::: Roderick is jolly.\n¬Civil(myra) ::: Myra is not civil.\nPrecious(roderick) ::: Roderick is precious.\nJolly(jack) ::: Jack is jolly.\n¬Able(burgess) ::: Burgess is not able.\n¬Jolly(miles) ::: Miles is not jolly.\nJolly(jasper) ::: Jasper is jolly.\n((Jolly(burgess))) → ((¬Able(roderick))) ::: It can be concluded that Roderick is not able once knowing that Burgess is jolly.\n(∃x (Able(x) ∧ Jolly(x))) → ((¬Frank(jasper))) ::: If there is someone who is both able and jolly, then Jasper is not frank.\n(∃x (¬Frank(x) ∨ ¬Civil(x))) → ((Able(roderick))) ::: If there is at least one people who is not frank or not civil, then Roderick is able.\n(∃x (Able(x))) → ((¬Frank(george) ∧ ¬Technical(jack))) ::: If there is someone who is able, then George is not frank and Jack is not technical.\n(¬(∃x (¬x))) → ((¬Frank(jack))) ::: If there is nobody who is not, then Jack is not frank.\n(∃x (¬Frank(x) ∨ ¬Precious(x))) → ((¬Able(roderick))) ::: If there is at least one people who is not frank or not precious, then Roderick is not able.\n(∀x (Frank(x))) → ((¬Precious(x) ∧ ¬Civil(x))) ::: If someone is frank, then he is neither precious nor civil.\n((¬Jolly(burgess) ∨ ¬Civil(roderick))) → ((¬Technical(george))) ::: It can be concluded that George is not technical once knowing that Burgess is not jolly or Roderick is not civil.\n(∀x (Precious(x))) ↔ ((¬Frank(x))) ::: If someone is precious, then he is not frank, and vice versa.\n(∀x (Precious(x) ∨ Technical(x))) → ((¬Jolly(x))) ::: If someone is he or not precious is technical, then he is not jolly.\n(∀x (¬Civil(x) ∧ ¬Jolly(x))) ↔ ((Able(x))) ::: If someone is not civil and not jolly, then he is able, and vice versa.\n((Able(roderick))) → ((Precious(burgess) ∧ ¬Civil(jack))) ::: Roderick being able implies that Burgess is precious and Jack is not civil.\n",
            "First-Order-Logic Question": "¬Jolly(george) ::: George is not jolly."
        },
        "gram_prog": {
            "First-Order-Logic Rules": "¬Able(jasper) ::: Jasper is not able.\n¬Frank(jack) ::: Jack is not frank.\nCivil(jasper) ::: Jasper is civil.\n¬Civil(george) ::: George is not civil.\nFrank(burgess) ::: Burgess is frank.\nJolly(roderick) ::: Roderick is jolly.\n¬Civil(myra) ::: Myra is not civil.\nPrecious(roderick) ::: Roderick is precious.\nJolly(jack) ::: Jack is jolly.\n¬Able(burgess) ::: Burgess is not able.\n¬Jolly(miles) ::: Miles is not jolly.\nJolly(jasper) ::: Jasper is jolly.\n((Jolly(burgess))) → ((¬Able(roderick))) ::: It can be concluded that Roderick is not able once knowing that Burgess is jolly.\n(∃x (Able(x) ∧ Jolly(x))) → ((¬Frank(jasper))) ::: If there is someone who is both able and jolly, then Jasper is not frank.\n(∃x (¬Frank(x) ∨ ¬Civil(x))) → ((Able(roderick))) ::: If there is at least one people who is not frank or not civil, then Roderick is able.\n(∃x (Able(x))) → ((¬Frank(george) ∧ ¬Technical(jack))) ::: If there is someone who is able, then George is not frank and Jack is not technical.\n¬((¬Frank(x))→(¬Able(x))) ::: If there is nobody who is not, then Jack is not frank.\n(∃x (¬Frank(x) ∨ ¬Precious(x))) → ((¬Able(roderick))) ::: If there is at least one people who is not frank or not precious, then Roderick is not able.\n(∀x (Frank(x))) → ((¬Precious(x) ∧ ¬Civil(x))) ::: If someone is frank, then he is neither precious nor civil.\n((¬Jolly(burgess) ∨ ¬Civil(roderick))) → ((¬Technical(george))) ::: It can be concluded that George is not technical once knowing that Burgess is not jolly or Roderick is not civil.\n(∀x (Precious(x))) ↔ ((¬Frank(x))) ::: If someone is precious, then he is not frank, and vice versa.\n(∀x (Precious(x) ∨ Technical(x))) → ((¬Jolly(x))) ::: If someone is he or not precious is technical, then he is not jolly.\n(∀x (¬Civil(x) ∧ ¬Jolly(x))) ↔ ((Able(x))) ::: If someone is not civil and not jolly, then he is able, and vice versa.\n((Able(roderick))) → ((Precious(burgess) ∧ ¬Civil(jack))) ::: Roderick being able implies that Burgess is precious and Jack is not civil.\n",
            "First-Order-Logic Question": "¬Jolly(george) ::: George is not jolly."
        },
        "diff": [
            {
                "raw": "(¬(∃x (¬x))) → ((¬Frank(jack))) ::: If there is nobody who is not, then Jack is not frank.",
                "gram": "¬((¬Frank(x))→(¬Able(x))) ::: If there is nobody who is not, then Jack is not frank."
            }
        ],
        "answer": "C",
        "grammar_answer": "A",
        "manual_prog": {
            "First-Order-Logic Rules": "¬Able(jasper) ::: Jasper is not able.\n¬Frank(jack) ::: Jack is not frank.\nCivil(jasper) ::: Jasper is civil.\n¬Civil(george) ::: George is not civil.\nFrank(burgess) ::: Burgess is frank.\nJolly(roderick) ::: Roderick is jolly.\n¬Civil(myra) ::: Myra is not civil.\nPrecious(roderick) ::: Roderick is precious.\nJolly(jack) ::: Jack is jolly.\n¬Able(burgess) ::: Burgess is not able.\n¬Jolly(miles) ::: Miles is not jolly.\nJolly(jasper) ::: Jasper is jolly.\n((Jolly(burgess))) → ((¬Able(roderick))) ::: It can be concluded that Roderick is not able once knowing that Burgess is jolly.\n(∃x (Able(x) ∧ Jolly(x))) → ((¬Frank(jasper))) ::: If there is someone who is both able and jolly, then Jasper is not frank.\n(∃x (¬Frank(x) ∨ ¬Civil(x))) → ((Able(roderick))) ::: If there is at least one people who is not frank or not civil, then Roderick is able.\n(∃x (Able(x))) → ((¬Frank(george) ∧ ¬Technical(jack))) ::: If there is someone who is able, then George is not frank and Jack is not technical.\n(∃x ¬Not(x)) → ((¬Frank(jack))) ::: If there is nobody who is not, then Jack is not frank.\n(∃x (¬Frank(x) ∨ ¬Precious(x))) → ((¬Able(roderick))) ::: If there is at least one people who is not frank or not precious, then Roderick is not able.\n(∀x (Frank(x))) → ((¬Precious(x) ∧ ¬Civil(x))) ::: If someone is frank, then he is neither precious nor civil.\n((¬Jolly(burgess) ∨ ¬Civil(roderick))) → ((¬Technical(george))) ::: It can be concluded that George is not technical once knowing that Burgess is not jolly or Roderick is not civil.\n(∀x (Precious(x))) ↔ ((¬Frank(x))) ::: If someone is precious, then he is not frank, and vice versa.\n(∀x (Precious(x) ∨ Technical(x))) → ((¬Jolly(x))) ::: If someone is he or not precious is technical, then he is not jolly.\n(∀x (¬Civil(x) ∧ ¬Jolly(x))) ↔ ((Able(x))) ::: If someone is not civil and not jolly, then he is able, and vice versa.\n((Able(roderick))) → ((Precious(burgess) ∧ ¬Civil(jack))) ::: Roderick being able implies that Burgess is precious and Jack is not civil.\n",
            "First-Order-Logic Question": "¬Jolly(george) ::: George is not jolly."
        },
        "fixed": true
    },
    {
        "id": 374,
        "raw_prog": {
            "First-Order-Logic Rules": "¬Able(jasper) ::: Jasper is not able.\n¬Frank(jack) ::: Jack is not frank.\nCivil(jasper) ::: Jasper is civil.\n¬Civil(george) ::: George is not civil.\nFrank(burgess) ::: Burgess is frank.\nJolly(roderick) ::: Roderick is jolly.\n¬Civil(myra) ::: Myra is not civil.\nPrecious(roderick) ::: Roderick is precious.\nJolly(jack) ::: Jack is jolly.\n¬Able(burgess) ::: Burgess is not able.\n¬Jolly(miles) ::: Miles is not jolly.\nJolly(jasper) ::: Jasper is jolly.\n((Jolly(burgess))) → ((¬Able(roderick))) ::: It can be concluded that Roderick is not able once knowing that Burgess is jolly.\n(∃x (Able(x) ∧ Jolly(x))) → ((¬Frank(jasper))) ::: If there is someone who is both able and jolly, then Jasper is not frank.\n(∃x (¬Frank(x) ∨ ¬Civil(x))) → ((Able(roderick))) ::: If there is at least one people who is not frank or not civil, then Roderick is able.\n(∃x (Able(x))) → ((¬Frank(george) ∧ ¬Technical(jack))) ::: If there is someone who is able, then George is not frank and Jack is not technical.\n(¬∃x (¬x)) → ((¬Frank(jack))) ::: If there is nobody who is not, then Jack is not frank.\n(∃x (¬Frank(x) ∨ ¬Precious(x))) → ((¬Able(roderick))) ::: If there is at least one people who is not frank or not precious, then Roderick is not able.\n(∀x (Frank(x))) → ((¬Precious(x) ∧ ¬Civil(x))) ::: If someone is frank, then he is neither precious nor civil.\n((¬Jolly(burgess) ∨ ¬Civil(roderick))) → ((¬Technical(george))) ::: It can be concluded that George is not technical once knowing that Burgess is not jolly or Roderick is not civil.\n(∀x (Precious(x))) ↔ ((¬Frank(x))) ::: If someone is precious, then he is not frank, and vice versa.\n(∀x (Precious(x) ∨ Technical(x))) → ((¬Jolly(x))) ::: If someone is he or not precious is technical, then he is not jolly.\n(∀x (¬Civil(x) ∧ ¬Jolly(x))) ↔ ((Able(x))) ::: If someone is not civil and not jolly, then he is able, and vice versa.\n((Able(roderick))) → ((Precious(burgess) ∧ ¬Civil(jack))) ::: Roderick being able implies that Burgess is precious and Jack is not civil.\n",
            "First-Order-Logic Question": "¬Civil(jasper) ::: Jasper is not civil."
        },
        "gram_prog": {
            "First-Order-Logic Rules": "¬Able(jasper) ::: Jasper is not able.\n¬Frank(jack) ::: Jack is not frank.\nCivil(jasper) ::: Jasper is civil.\n¬Civil(george) ::: George is not civil.\nFrank(burgess) ::: Burgess is frank.\nJolly(roderick) ::: Roderick is jolly.\n¬Civil(myra) ::: Myra is not civil.\nPrecious(roderick) ::: Roderick is precious.\nJolly(jack) ::: Jack is jolly.\n¬Able(burgess) ::: Burgess is not able.\n¬Jolly(miles) ::: Miles is not jolly.\nJolly(jasper) ::: Jasper is jolly.\n((Jolly(burgess))) → ((¬Able(roderick))) ::: It can be concluded that Roderick is not able once knowing that Burgess is jolly.\n(∃x (Able(x) ∧ Jolly(x))) → ((¬Frank(jasper))) ::: If there is someone who is both able and jolly, then Jasper is not frank.\n(∃x (¬Frank(x) ∨ ¬Civil(x))) → ((Able(roderick))) ::: If there is at least one people who is not frank or not civil, then Roderick is able.\n(∃x (Able(x))) → ((¬Frank(george) ∧ ¬Technical(jack))) ::: If there is someone who is able, then George is not frank and Jack is not technical.\n¬∃x((¬Blue(x))→(¬Serious(x))) ::: If there is nobody who is not, then Jack is not frank.\n(∃x (¬Frank(x) ∨ ¬Precious(x))) → ((¬Able(roderick))) ::: If there is at least one people who is not frank or not precious, then Roderick is not able.\n(∀x (Frank(x))) → ((¬Precious(x) ∧ ¬Civil(x))) ::: If someone is frank, then he is neither precious nor civil.\n((¬Jolly(burgess) ∨ ¬Civil(roderick))) → ((¬Technical(george))) ::: It can be concluded that George is not technical once knowing that Burgess is not jolly or Roderick is not civil.\n(∀x (Precious(x))) ↔ ((¬Frank(x))) ::: If someone is precious, then he is not frank, and vice versa.\n(∀x (Precious(x) ∨ Technical(x))) → ((¬Jolly(x))) ::: If someone is he or not precious is technical, then he is not jolly.\n(∀x (¬Civil(x) ∧ ¬Jolly(x))) ↔ ((Able(x))) ::: If someone is not civil and not jolly, then he is able, and vice versa.\n((Able(roderick))) → ((Precious(burgess) ∧ ¬Civil(jack))) ::: Roderick being able implies that Burgess is precious and Jack is not civil.\n",
            "First-Order-Logic Question": "¬Civil(jasper) ::: Jasper is not civil."
        },
        "diff": [
            {
                "raw": "(¬∃x (¬x)) → ((¬Frank(jack))) ::: If there is nobody who is not, then Jack is not frank.",
                "gram": "¬∃x((¬Blue(x))→(¬Serious(x))) ::: If there is nobody who is not, then Jack is not frank."
            }
        ],
        "answer": "B",
        "grammar_answer": "A",
        "manual_prog": {
            "First-Order-Logic Rules": "¬Able(jasper) ::: Jasper is not able.\n¬Frank(jack) ::: Jack is not frank.\nCivil(jasper) ::: Jasper is civil.\n¬Civil(george) ::: George is not civil.\nFrank(burgess) ::: Burgess is frank.\nJolly(roderick) ::: Roderick is jolly.\n¬Civil(myra) ::: Myra is not civil.\nPrecious(roderick) ::: Roderick is precious.\nJolly(jack) ::: Jack is jolly.\n¬Able(burgess) ::: Burgess is not able.\n¬Jolly(miles) ::: Miles is not jolly.\nJolly(jasper) ::: Jasper is jolly.\n((Jolly(burgess))) → ((¬Able(roderick))) ::: It can be concluded that Roderick is not able once knowing that Burgess is jolly.\n(∃x (Able(x) ∧ Jolly(x))) → ((¬Frank(jasper))) ::: If there is someone who is both able and jolly, then Jasper is not frank.\n(∃x (¬Frank(x) ∨ ¬Civil(x))) → ((Able(roderick))) ::: If there is at least one people who is not frank or not civil, then Roderick is able.\n(∃x (Able(x))) → ((¬Frank(george) ∧ ¬Technical(jack))) ::: If there is someone who is able, then George is not frank and Jack is not technical.\n(∃x ¬Not(x)) → ((¬Frank(jack))) ::: If there is nobody who is not, then Jack is not frank.\n(∃x (¬Frank(x) ∨ ¬Precious(x))) → ((¬Able(roderick))) ::: If there is at least one people who is not frank or not precious, then Roderick is not able.\n(∀x (Frank(x))) → ((¬Precious(x) ∧ ¬Civil(x))) ::: If someone is frank, then he is neither precious nor civil.\n((¬Jolly(burgess) ∨ ¬Civil(roderick))) → ((¬Technical(george))) ::: It can be concluded that George is not technical once knowing that Burgess is not jolly or Roderick is not civil.\n(∀x (Precious(x))) ↔ ((¬Frank(x))) ::: If someone is precious, then he is not frank, and vice versa.\n(∀x (Precious(x) ∨ Technical(x))) → ((¬Jolly(x))) ::: If someone is he or not precious is technical, then he is not jolly.\n(∀x (¬Civil(x) ∧ ¬Jolly(x))) ↔ ((Able(x))) ::: If someone is not civil and not jolly, then he is able, and vice versa.\n((Able(roderick))) → ((Precious(burgess) ∧ ¬Civil(jack))) ::: Roderick being able implies that Burgess is precious and Jack is not civil.\n",
            "First-Order-Logic Question": "¬Civil(jasper) ::: Jasper is not civil."
        },
        "fixed": true
    },
    {
        "id": 558,
        "raw_prog": {
            "First-Order-Logic Rules": "¬Mushy(montague) ::: Montague is not mushy.\nImpossible(ansel) ::: Ansel is impossible.\n¬Wicked(cyril) ::: Cyril is not wicked.\n¬Wicked(ansel) ::: Ansel is not wicked.\nDrab(katelynn) ::: Katelynn is drab.\n¬Drab(montague) ::: Montague is not drab.\n¬Mushy(ansel) ::: Ansel is not mushy.\n¬Wicked(joseph) ::: Joseph is not wicked.\nDrab(olive) ::: Olive is drab.\nBroadMinded(joseph) ::: Joseph is broad-minded.\n¬Wicked(montague) ::: Montague is not wicked.\n((Mushy(montague) ∧ ¬Wicked(katelynn))) → (¬Aggressive(ansel)) ::: Montague being mushy and Katelynn being not wicked imply that Ansel is not aggressive.\n(BroadMinded(joseph)) ↔ (¬Impossible(joseph)) ::: Joseph is broad-minded if and only if Joseph is not impossible.\n(∃x (¬Mushy(x))) → (¬Aggressive(whitney) ∧ Impossible(cyril)) ::: If there is at least one people who is not mushy, then Whitney is not aggressive and Cyril is impossible.\n(∃x (BroadMinded(x) ∨ Impossible(x))) → (Aggressive(olive)) ::: If there is someone who is either broad-minded or impossible, then Olive is aggressive.\n(∀x ¬(¬x)) → (¬BroadMinded(cyril) ∧ Aggressive(ansel)) ::: If there is nobody who is not, then Cyril is not broad-minded and Ansel is aggressive.\n((Wicked(olive) ∧ ¬Wicked(katelynn))) ↔ (Aggressive(joseph) ∧ ¬BroadMinded(montague)) ::: Olive is wicked and Katelynn is drab if and only if Joseph is aggressive and Montague is not broad-minded.\n(∃x (Mushy(x))) → (BroadMinded(katelynn) ∧ ¬Aggressive(joseph)) ::: If there is at least one people who is mushy, then Katelynn is broad-minded and Joseph is not aggressive.\n((Wicked(olive) ∨ BroadMinded(cyril)) → (Aggressive(katelynn)) ::: Olive being wicked or Cyril being broad-minded implies that Katelynn is aggressive.\n(∃x (Wicked(x) ∧ ¬Mushy(x))) → (¬Drab(montague)) ::: If there is someone who is both wicked and not mushy, then Montague is not drab.\n(¬Impossible(whitney)) → (¬Mushy(cyril) ∧ BroadMinded(joseph)) ::: Whitney being not impossible implies that Cyril is not mushy and Joseph is broad-minded.\n(¬Aggressive(x)) ↔ (¬Impossible(x)) ::: Someone is not aggressive if and only if he is not impossible.\n((Aggressive(x) ∧ ¬Drab(x))) ↔ (¬Impossible(x)) ::: Someone is aggressive and not drab if and only if he is not impossible.\n",
            "First-Order-Logic Question": "Mushy(ansel) ::: Ansel is mushy."
        },
        "gram_prog": {
            "First-Order-Logic Rules": "¬Mushy(montague) ::: Montague is not mushy.\nImpossible(ansel) ::: Ansel is impossible.\n¬Wicked(cyril) ::: Cyril is not wicked.\n¬Wicked(ansel) ::: Ansel is not wicked.\nDrab(katelynn) ::: Katelynn is drab.\n¬Drab(montague) ::: Montague is not drab.\n¬Mushy(ansel) ::: Ansel is not mushy.\n¬Wicked(joseph) ::: Joseph is not wicked.\nDrab(olive) ::: Olive is drab.\nBroadMinded(joseph) ::: Joseph is broad-minded.\n¬Wicked(montague) ::: Montague is not wicked.\n((Mushy(montague) ∧ ¬Wicked(katelynn))) → (¬Aggressive(ansel)) ::: Montague being mushy and Katelynn being not wicked imply that Ansel is not aggressive.\n(BroadMinded(joseph)) ↔ (¬Impossible(joseph)) ::: Joseph is broad-minded if and only if Joseph is not impossible.\n(∃x (¬Mushy(x))) → (¬Aggressive(whitney) ∧ Impossible(cyril)) ::: If there is at least one people who is not mushy, then Whitney is not aggressive and Cyril is impossible.\n(∃x (BroadMinded(x) ∨ Impossible(x))) → (Aggressive(olive)) ::: If there is someone who is either broad-minded or impossible, then Olive is aggressive.\n¬(¬Blue(x))→(¬Serious(x)∧Accurate(x)) ::: If there is nobody who is not, then Cyril is not broad-minded and Ansel is aggressive.\n((Wicked(olive) ∧ ¬Wicked(katelynn))) ↔ (Aggressive(joseph) ∧ ¬BroadMinded(montague)) ::: Olive is wicked and Katelynn is drab if and only if Joseph is aggressive and Montague is not broad-minded.\n(∃x (Mushy(x))) → (BroadMinded(katelynn) ∧ ¬Aggressive(joseph)) ::: If there is at least one people who is mushy, then Katelynn is broad-minded and Joseph is not aggressive.\n((Blue(x)∨Serious(x))) ::: Olive being wicked or Cyril being broad-minded implies that Katelynn is aggressive.\n(∃x (Wicked(x) ∧ ¬Mushy(x))) → (¬Drab(montague)) ::: If there is someone who is both wicked and not mushy, then Montague is not drab.\n(¬Impossible(whitney)) → (¬Mushy(cyril) ∧ BroadMinded(joseph)) ::: Whitney being not impossible implies that Cyril is not mushy and Joseph is broad-minded.\n(¬Aggressive(x)) ↔ (¬Impossible(x)) ::: Someone is not aggressive if and only if he is not impossible.\n((Aggressive(x) ∧ ¬Drab(x))) ↔ (¬Impossible(x)) ::: Someone is aggressive and not drab if and only if he is not impossible.\n",
            "First-Order-Logic Question": "Mushy(ansel) ::: Ansel is mushy."
        },
        "diff": [
            {
                "raw": "(∀x ¬(¬x)) → (¬BroadMinded(cyril) ∧ Aggressive(ansel)) ::: If there is nobody who is not, then Cyril is not broad-minded and Ansel is aggressive.",
                "gram": "¬(¬Blue(x))→(¬Serious(x)∧Accurate(x)) ::: If there is nobody who is not, then Cyril is not broad-minded and Ansel is aggressive."
            },
            {
                "raw": "((Wicked(olive) ∨ BroadMinded(cyril)) → (Aggressive(katelynn)) ::: Olive being wicked or Cyril being broad-minded implies that Katelynn is aggressive.",
                "gram": "((Blue(x)∨Serious(x))) ::: Olive being wicked or Cyril being broad-minded implies that Katelynn is aggressive."
            }
        ],
        "answer": "B",
        "grammar_answer": "A",
        "manual_prog": {
            "First-Order-Logic Rules": "¬Mushy(montague) ::: Montague is not mushy.\nImpossible(ansel) ::: Ansel is impossible.\n¬Wicked(cyril) ::: Cyril is not wicked.\n¬Wicked(ansel) ::: Ansel is not wicked.\nDrab(katelynn) ::: Katelynn is drab.\n¬Drab(montague) ::: Montague is not drab.\n¬Mushy(ansel) ::: Ansel is not mushy.\n¬Wicked(joseph) ::: Joseph is not wicked.\nDrab(olive) ::: Olive is drab.\nBroadMinded(joseph) ::: Joseph is broad-minded.\n¬Wicked(montague) ::: Montague is not wicked.\n((Mushy(montague) ∧ ¬Wicked(katelynn))) → (¬Aggressive(ansel)) ::: Montague being mushy and Katelynn being not wicked imply that Ansel is not aggressive.\n(BroadMinded(joseph)) ↔ (¬Impossible(joseph)) ::: Joseph is broad-minded if and only if Joseph is not impossible.\n(∃x (¬Mushy(x))) → (¬Aggressive(whitney) ∧ Impossible(cyril)) ::: If there is at least one people who is not mushy, then Whitney is not aggressive and Cyril is impossible.\n(∃x (BroadMinded(x) ∨ Impossible(x))) → (Aggressive(olive)) ::: If there is someone who is either broad-minded or impossible, then Olive is aggressive.\n(∃x (¬BroadMinded(cyril) ∧ Aggressive(ansel))) ::: If there is nobody who is not, then Cyril is not broad-minded and Ansel is aggressive.\n((Wicked(olive) ∧ ¬Wicked(katelynn))) ↔ (Aggressive(joseph) ∧ ¬BroadMinded(montague)) ::: Olive is wicked and Katelynn is drab if and only if Joseph is aggressive and Montague is not broad-minded.\n(∃x (Mushy(x))) → (BroadMinded(katelynn) ∧ ¬Aggressive(joseph)) ::: If there is at least one people who is mushy, then Katelynn is broad-minded and Joseph is not aggressive.\n((Wicked(olive) ∨ BroadMinded(cyril)) → (Aggressive(katelynn))) ::: Olive being wicked or Cyril being broad-minded implies that Katelynn is aggressive.\n(∃x (Wicked(x) ∧ ¬Mushy(x))) → (¬Drab(montague)) ::: If there is someone who is both wicked and not mushy, then Montague is not drab.\n(¬Impossible(whitney)) → (¬Mushy(cyril) ∧ BroadMinded(joseph)) ::: Whitney being not impossible implies that Cyril is not mushy and Joseph is broad-minded.\n(¬Aggressive(x)) ↔ (¬Impossible(x)) ::: Someone is not aggressive if and only if he is not impossible.\n((Aggressive(x) ∧ ¬Drab(x))) ↔ (¬Impossible(x)) ::: Someone is aggressive and not drab if and only if he is not impossible.\n",
            "First-Order-Logic Question": "Mushy(ansel) ::: Ansel is mushy."
        },
        "fixed": true
    },
    {
        "id": 560,
        "raw_prog": {
            "First-Order-Logic Rules": "Aggressive(montague) ::: Montague is aggressive.\nImpossible(ansel) ::: Ansel is impossible.\n¬Wicked(cyril) ::: Cyril is not wicked.\n¬Wicked(ansel) ::: Ansel is not wicked.\nDrab(katelynn) ::: Katelynn is drab.\n¬Drab(montague) ::: Montague is not drab.\n¬Mushy(ansel) ::: Ansel is not mushy.\n¬Wicked(joseph) ::: Joseph is not wicked.\nDrab(olive) ::: Olive is drab.\nBroad-minded(joseph) ::: Joseph is broad-minded.\n¬Drab(ansel) ::: Ansel is not drab.\n¬Wicked(montague) ::: Montague is not wicked.\n((Mushy(montague) ∧ ¬Wicked(katelynn))) → ((¬Aggressive(ansel))) ::: Montague being mushy and Katelynn being not wicked imply that Ansel is not aggressive.\n(Broad-minded(joseph)) ↔ (¬Impossible(joseph)) ::: Joseph is broad-minded if and only if Joseph is not impossible.\n(∃x (¬Mushy(x))) → ((¬Aggressive(whitney) ∧ Impossible(cyril))) ::: If there is at least one people who is not mushy, then Whitney is not aggressive and Cyril is impossible.\n(∃x (Broad-minded(x) ∨ Impossible(x))) → (Aggressive(olive)) ::: If there is someone who is either broad-minded or impossible, then Olive is aggressive.\n(∀x (¬¬x)) → ((¬Broad-minded(cyril) ∧ Aggressive(ansel))) ::: If there is nobody who is not, then Cyril is not broad-minded and Ansel is aggressive.\n((Wicked(olive) ∧ Drab(katelynn))) ↔ ((Aggressive(joseph) ∧ ¬Broad-minded(montague))) ::: Olive is wicked and Katelynn is drab if and only if Joseph is aggressive and Montague is not broad-minded.\n(∃x (Mushy(x))) → ((Broad-minded(katelynn) ∧ ¬Aggressive(joseph))) ::: If there is at least one people who is mushy, then Katelynn is broad-minded and Joseph is not aggressive.\n((Wicked(olive) ∨ Broad-minded(cyril))) → (Aggressive(katelynn)) ::: Olive being wicked or Cyril being broad-minded implies that Katelynn is aggressive.\n(∃x (Wicked(x) ∧ ¬Mushy(x))) → ((¬Drab(montague))) ::: If there is someone who is both wicked and not mushy, then Montague is not drab.\n(¬Impossible(whitney)) → ((¬Mushy(cyril) ∧ Broad-minded(joseph))) ::: Whitney being not impossible implies that Cyril is not mushy and Joseph is broad-minded.\n(¬Aggressive(x)) ↔ (¬Impossible(x)) ::: Someone is not aggressive if and only if he is not impossible.\n((Aggressive(x) ∧ ¬Drab(x))) ↔ (¬Impossible(x)) ::: Someone is aggressive and not drab if and only if he is not impossible.\n",
            "First-Order-Logic Question": "Impossible(katelynn) ::: Katelynn is impossible."
        },
        "gram_prog": {
            "First-Order-Logic Rules": "Aggressive(montague) ::: Montague is aggressive.\nImpossible(ansel) ::: Ansel is impossible.\n¬Wicked(cyril) ::: Cyril is not wicked.\n¬Wicked(ansel) ::: Ansel is not wicked.\nDrab(katelynn) ::: Katelynn is drab.\n¬Drab(montague) ::: Montague is not drab.\n¬Mushy(ansel) ::: Ansel is not mushy.\n¬Wicked(joseph) ::: Joseph is not wicked.\nDrab(olive) ::: Olive is drab.\nBroadMinded(joseph) ::: Joseph is broad-minded.\n¬Drab(ansel) ::: Ansel is not drab.\n¬Wicked(montague) ::: Montague is not wicked.\n((Mushy(montague) ∧ ¬Wicked(katelynn)) → (¬Aggressive(ansel))) ::: Montague being mushy and Katelynn being not wicked imply that Ansel is not aggressive.\n(BroadMinded(joseph) ↔ ¬Impossible(joseph)) ::: Joseph is broad-minded if and only if Joseph is not impossible.\n(∃x (¬Mushy(x)) → (¬Aggressive(whitney) ∧ Impossible(cyril))) ::: If there is at least one person who is not mushy, then Whitney is not aggressive and Cyril is impossible.\n(∃x (BroadMinded(x) ∨ Impossible(x)) → Aggressive(olive)) ::: If there is someone who is either broad-minded or impossible, then Olive is aggressive.\n¬¬(Blue(x)) → (¬Serious(x)) ::: If there is nobody who is not blue, then Cyril is not broad-minded and Ansel is aggressive.\n((Wicked(olive) ∧ Drab(katelynn)) ↔ (Aggressive(joseph) ∧ ¬BroadMinded(montague))) ::: Olive is wicked and Katelynn is drab if and only if Joseph is aggressive and Montague is not broad-minded.\n(∃x (Mushy(x)) → (BroadMinded(katelynn) ∧ ¬Aggressive(joseph))) ::: If there is at least one person who is mushy, then Katelynn is broad-minded and Joseph is not aggressive.\n((Wicked(olive) ∨ BroadMinded(cyril)) → Aggressive(katelynn)) ::: Olive being wicked or Cyril being broad-minded implies that Katelynn is aggressive.\n(∃x (Wicked(x) ∧ ¬Mushy(x)) → (¬Drab(montague))) ::: If there is someone who is both wicked and not mushy, then Montague is not drab.\n(¬Impossible(whitney) → (¬Mushy(cyril) ∧ BroadMinded(joseph))) ::: Whitney being not impossible implies that Cyril is not mushy and Joseph is broad-minded.\n(¬Aggressive(x) ↔ ¬Impossible(x)) ::: Someone is not aggressive if and only if he is not impossible.\n((Aggressive(x) ∧ ¬Drab(x)) ↔ ¬Impossible(x)) ::: Someone is aggressive and not drab if and only if he is not impossible.",
            "First-Order-Logic Question": "Impossible(katelynn) ::: Katelynn is impossible."
        },
        "diff": [],
        "answer": "C",
        "grammar_answer": "A",
        "manual_prog": {
            "First-Order-Logic Rules": "Aggressive(montague) ::: Montague is aggressive.\nImpossible(ansel) ::: Ansel is impossible.\n¬Wicked(cyril) ::: Cyril is not wicked.\n¬Wicked(ansel) ::: Ansel is not wicked.\nDrab(katelynn) ::: Katelynn is drab.\n¬Drab(montague) ::: Montague is not drab.\n¬Mushy(ansel) ::: Ansel is not mushy.\n¬Wicked(joseph) ::: Joseph is not wicked.\nDrab(olive) ::: Olive is drab.\nBroad-minded(joseph) ::: Joseph is broad-minded.\n¬Drab(ansel) ::: Ansel is not drab.\n¬Wicked(montague) ::: Montague is not wicked.\n((Mushy(montague) ∧ ¬Wicked(katelynn))) → ((¬Aggressive(ansel))) ::: Montague being mushy and Katelynn being not wicked imply that Ansel is not aggressive.\n(Broad-minded(joseph)) ↔ (¬Impossible(joseph)) ::: Joseph is broad-minded if and only if Joseph is not impossible.\n(∃x (¬Mushy(x))) → ((¬Aggressive(whitney) ∧ Impossible(cyril))) ::: If there is at least one people who is not mushy, then Whitney is not aggressive and Cyril is impossible.\n(∃x (Broad-minded(x) ∨ Impossible(x))) → (Aggressive(olive)) ::: If there is someone who is either broad-minded or impossible, then Olive is aggressive.\n(∀x (¬¬x)) → ((¬Broad-minded(cyril) ∧ Aggressive(ansel))) ::: If there is nobody who is not, then Cyril is not broad-minded and Ansel is aggressive.\n((Wicked(olive) ∧ Drab(katelynn))) ↔ ((Aggressive(joseph) ∧ ¬Broad-minded(montague))) ::: Olive is wicked and Katelynn is drab if and only if Joseph is aggressive and Montague is not broad-minded.\n(∃x (Mushy(x))) → ((Broad-minded(katelynn) ∧ ¬Aggressive(joseph))) ::: If there is at least one people who is mushy, then Katelynn is broad-minded and Joseph is not aggressive.\n((Wicked(olive) ∨ Broad-minded(cyril))) → (Aggressive(katelynn)) ::: Olive being wicked or Cyril being broad-minded implies that Katelynn is aggressive.\n(∃x (Wicked(x) ∧ ¬Mushy(x))) → ((¬Drab(montague))) ::: If there is someone who is both wicked and not mushy, then Montague is not drab.\n(¬Impossible(whitney)) → ((¬Mushy(cyril) ∧ Broad-minded(joseph))) ::: Whitney being not impossible implies that Cyril is not mushy and Joseph is broad-minded.\n(¬Aggressive(x)) ↔ (¬Impossible(x)) ::: Someone is not aggressive if and only if he is not impossible.\n((Aggressive(x) ∧ ¬Drab(x))) ↔ (¬Impossible(x)) ::: Someone is aggressive and not drab if and only if he is not impossible.\n",
            "First-Order-Logic Question": "Impossible(katelynn) ::: Katelynn is impossible."
        },
        "fixed": true
    },
    {
        "id": 561,
        "raw_prog": {
            "First-Order-Logic Rules": "Aggressive(montague) ::: Montague is aggressive.\nImpossible(ansel) ::: Ansel is impossible.\n¬Wicked(cyril) ::: Cyril is not wicked.\n¬Wicked(ansel) ::: Ansel is not wicked.\nDrab(katelynn) ::: Katelynn is drab.\n¬Drab(montague) ::: Montague is not drab.\n¬Mushy(ansel) ::: Ansel is not mushy.\n¬Wicked(joseph) ::: Joseph is not wicked.\nDrab(olive) ::: Olive is drab.\nBroad-minded(joseph) ::: Joseph is broad-minded.\n¬Wicked(montague) ::: Montague is not wicked.\n((Mushy(montague) ∧ ¬Wicked(katelynn))) → ((¬Aggressive(ansel))) ::: Montague being mushy and Katelynn being not wicked imply that Ansel is not aggressive.\n(Broad-minded(joseph)) ↔ (¬Impossible(joseph)) ::: Joseph is broad-minded if and only if Joseph is not impossible.\n(∃x (¬Mushy(x))) → ((¬Aggressive(whitney) ∧ Impossible(cyril))) ::: If there is at least one people who is not mushy, then Whitney is not aggressive and Cyril is impossible.\n(∃x (Broad-minded(x) ∨ Impossible(x))) → (Aggressive(olive)) ::: If there is someone who is either broad-minded or impossible, then Olive is aggressive.\n(∀x (¬¬x)) → (¬Broad-minded(cyril) ∧ Aggressive(ansel)) ::: If there is nobody who is not, then Cyril is not broad-minded and Ansel is aggressive.\n((Wicked(olive) ∧ Drab(katelynn))) ↔ ((Aggressive(joseph) ∧ ¬Broad-minded(montague))) ::: Olive is wicked and Katelynn is drab if and only if Joseph is aggressive and Montague is not broad-minded.\n(∃x (Mushy(x))) → ((Broad-minded(katelynn) ∧ ¬Aggressive(joseph))) ::: If there is at least one people who is mushy, then Katelynn is broad-minded and Joseph is not aggressive.\n((Wicked(olive) ∨ Broad-minded(cyril))) → (Aggressive(katelynn)) ::: Olive being wicked or Cyril being broad-minded implies that Katelynn is aggressive.\n(∃x (Wicked(x) ∧ ¬Mushy(x))) → (¬Drab(montague)) ::: If there is someone who is both wicked and not mushy, then Montague is not drab.\n(¬Impossible(whitney)) → (¬Mushy(cyril) ∧ Broad-minded(joseph)) ::: Whitney being not impossible implies that Cyril is not mushy and Joseph is broad-minded.\n(¬Aggressive(x)) ↔ (¬Impossible(x)) ::: Someone is not aggressive if and only if he is not impossible.\n((Aggressive(x) ∧ ¬Drab(x))) ↔ (¬Impossible(x)) ::: Someone is aggressive and not drab if and only if he is not impossible.\n",
            "First-Order-Logic Question": "Drab(joseph) ::: Joseph is drab."
        },
        "gram_prog": {
            "First-Order-Logic Rules": "Aggressive(montague) ::: Montague is aggressive.\nImpossible(ansel) ::: Ansel is impossible.\n¬Wicked(cyril) ::: Cyril is not wicked.\n¬Wicked(ansel) ::: Ansel is not wicked.\nDrab(katelynn) ::: Katelynn is drab.\n¬Drab(montague) ::: Montague is not drab.\n¬Mushy(ansel) ::: Ansel is not mushy.\n¬Wicked(joseph) ::: Joseph is not wicked.\nDrab(olive) ::: Olive is drab.\nBroad_minded(joseph) ::: Joseph is broad-minded.\n¬Wicked(montague) ::: Montague is not wicked.\n((Mushy(montague) ∧ ¬Wicked(katelynn))) → (¬Aggressive(ansel)) ::: Montague being mushy and Katelynn being not wicked imply that Ansel is not aggressive.\n(Broad_minded(joseph)) ↔ (¬Impossible(joseph)) ::: Joseph is broad-minded if and only if Joseph is not impossible.\n¬(Blue(x))→((¬Serious(x))) ::: If there is at least one people who is not mushy, then Whitney is not aggressive and Cyril is impossible.\n(∃x (Broad_minded(x) ∨ Impossible(x))) → (Aggressive(olive)) ::: If there is someone who is either broad-minded or impossible, then Olive is aggressive.\n¬¬(Blue(x)) → (¬Serious(x) ∧ Accurate(x)) ::: If there is nobody who is not, then Cyril is not broad-minded and Ansel is aggressive.\n((Wicked(olive) ∧ Drab(katelynn))) ↔ ((Aggressive(joseph) ∧ ¬Broad_minded(montague))) ::: Olive is wicked and Katelynn is drab if and only if Joseph is aggressive and Montague is not broad-minded.\n(∃x (Mushy(x))) → ((Broad_minded(katelynn) ∧ ¬Aggressive(joseph))) ::: If there is at least one people who is mushy, then Katelynn is broad-minded and Joseph is not aggressive.\n((Wicked(olive) ∨ Broad_minded(cyril))) → (Aggressive(katelynn)) ::: Olive being wicked or Cyril being broad-minded implies that Katelynn is aggressive.\n(∃x (Wicked(x) ∧ ¬Mushy(x))) → (¬Drab(montague)) ::: If there is someone who is both wicked and not mushy, then Montague is not drab.\n(¬Impossible(whitney)) → (¬Mushy(cyril) ∧ Broad_minded(joseph)) ::: Whitney being not impossible implies that Cyril is not mushy and Joseph is broad-minded.\n(¬Aggressive(x)) ↔ (¬Impossible(x)) ::: Someone is not aggressive if and only if he is not impossible.\n((Aggressive(x) ∧ ¬Drab(x))) ↔ (¬Impossible(x)) ::: Someone is aggressive and not drab if and only if he is not impossible.",
            "First-Order-Logic Question": "Drab(joseph) ::: Joseph is drab."
        },
        "diff": [],
        "answer": "B",
        "grammar_answer": "A",
        "manual_prog": {
            "First-Order-Logic Rules": "Aggressive(montague) ::: Montague is aggressive.\nImpossible(ansel) ::: Ansel is impossible.\n¬Wicked(cyril) ::: Cyril is not wicked.\n¬Wicked(ansel) ::: Ansel is not wicked.\nDrab(katelynn) ::: Katelynn is drab.\n¬Drab(montague) ::: Montague is not drab.\n¬Mushy(ansel) ::: Ansel is not mushy.\n¬Wicked(joseph) ::: Joseph is not wicked.\nDrab(olive) ::: Olive is drab.\nBroad-minded(joseph) ::: Joseph is broad-minded.\n¬Wicked(montague) ::: Montague is not wicked.\n((Mushy(montague) ∧ ¬Wicked(katelynn))) → ((¬Aggressive(ansel))) ::: Montague being mushy and Katelynn being not wicked imply that Ansel is not aggressive.\n(Broad-minded(joseph)) ↔ (¬Impossible(joseph)) ::: Joseph is broad-minded if and only if Joseph is not impossible.\n(∃x (¬Mushy(x))) → ((¬Aggressive(whitney) ∧ Impossible(cyril))) ::: If there is at least one people who is not mushy, then Whitney is not aggressive and Cyril is impossible.\n(∃x (Broad-minded(x) ∨ Impossible(x))) → (Aggressive(olive)) ::: If there is someone who is either broad-minded or impossible, then Olive is aggressive.\n(∀x (¬¬x)) → (¬Broad-minded(cyril) ∧ Aggressive(ansel)) ::: If there is nobody who is not, then Cyril is not broad-minded and Ansel is aggressive.\n((Wicked(olive) ∧ Drab(katelynn))) ↔ ((Aggressive(joseph) ∧ ¬Broad-minded(montague))) ::: Olive is wicked and Katelynn is drab if and only if Joseph is aggressive and Montague is not broad-minded.\n(∃x (Mushy(x))) → ((Broad-minded(katelynn) ∧ ¬Aggressive(joseph))) ::: If there is at least one people who is mushy, then Katelynn is broad-minded and Joseph is not aggressive.\n((Wicked(olive) ∨ Broad-minded(cyril))) → (Aggressive(katelynn)) ::: Olive being wicked or Cyril being broad-minded implies that Katelynn is aggressive.\n(∃x (Wicked(x) ∧ ¬Mushy(x))) → (¬Drab(montague)) ::: If there is someone who is both wicked and not mushy, then Montague is not drab.\n(¬Impossible(whitney)) → (¬Mushy(cyril) ∧ Broad-minded(joseph)) ::: Whitney being not impossible implies that Cyril is not mushy and Joseph is broad-minded.\n(¬Aggressive(x)) ↔ (¬Impossible(x)) ::: Someone is not aggressive if and only if he is not impossible.\n((Aggressive(x) ∧ ¬Drab(x))) ↔ (¬Impossible(x)) ::: Someone is aggressive and not drab if and only if he is not impossible.\n",
            "First-Order-Logic Question": "Drab(joseph) ::: Joseph is drab."
        },
        "fixed": true
    },
    {
        "id": 569,
        "raw_prog": {
            "First-Order-Logic Rules": "Aggressive(montague) ::: Montague is aggressive.\nImpossible(ansel) ::: Ansel is impossible.\n¬Wicked(cyril) ::: Cyril is not wicked.\n¬Wicked(ansel) ::: Ansel is not wicked.\nDrab(katelynn) ::: Katelynn is drab.\n¬Drab(montague) ::: Montague is not drab.\n¬Mushy(ansel) ::: Ansel is not mushy.\n¬Wicked(joseph) ::: Joseph is not wicked.\nDrab(olive) ::: Olive is drab.\nBroad-minded(joseph) ::: Joseph is broad-minded.\n¬Drab(ansel) ::: Ansel is not drab.\n¬Wicked(montague) ::: Montague is not wicked.\n((Mushy(montague) ∧ ¬Wicked(katelynn))) → (¬Aggressive(ansel)) ::: Montague being mushy and Katelynn being not wicked imply that Ansel is not aggressive.\n(Broad-minded(joseph)) ↔ (¬Impossible(joseph)) ::: Joseph is broad-minded if and only if Joseph is not impossible.\n(∃x (¬Mushy(x))) → (¬Aggressive(whitney) ∧ Impossible(cyril)) ::: If there is at least one people who is not mushy, then Whitney is not aggressive and Cyril is impossible.\n(∃x (Broad-minded(x) ∨ Impossible(x))) → (Aggressive(olive)) ::: If there is someone who is either broad-minded or impossible, then Olive is aggressive.\n(∀x (¬x)) → (¬Broad-minded(cyril) ∧ Aggressive(ansel)) ::: If there is nobody who is not, then Cyril is not broad-minded and Ansel is aggressive.\n((Wicked(olive) ∧ Drab(katelynn))) ↔ ((Aggressive(joseph) ∧ ¬Broad-minded(montague))) ::: Olive is wicked and Katelynn is drab if and only if Joseph is aggressive and Montague is not broad-minded.\n(∃x (Mushy(x))) → (Broad-minded(katelynn) ∧ ¬Aggressive(joseph)) ::: If there is at least one people who is mushy, then Katelynn is broad-minded and Joseph is not aggressive.\n((Wicked(olive) ∨ Broad-minded(cyril)) → (Aggressive(katelynn)) ::: Olive being wicked or Cyril being broad-minded implies that Katelynn is aggressive.\n(∃x (Wicked(x) ∧ ¬Mushy(x))) → (¬Drab(montague)) ::: If there is someone who is both wicked and not mushy, then Montague is not drab.\n(¬Impossible(whitney)) → (¬Mushy(cyril) ∧ Broad-minded(joseph)) ::: Whitney being not impossible implies that Cyril is not mushy and Joseph is broad-minded.\n(¬Aggressive(x)) ↔ (¬Impossible(x)) ::: Someone is not aggressive if and only if he is not impossible.\n((Aggressive(x) ∧ ¬Drab(x))) ↔ (¬Impossible(x)) ::: Someone is aggressive and not drab if and only if he is not impossible.\n",
            "First-Order-Logic Question": "Wicked(joseph) ::: Joseph is wicked."
        },
        "gram_prog": {
            "First-Order-Logic Rules": "Aggressive(montague) ::: Montague is aggressive.\nImpossible(ansel) ::: Ansel is impossible.\n¬Wicked(cyril) ::: Cyril is not wicked.\n¬Wicked(ansel) ::: Ansel is not wicked.\nDrab(katelynn) ::: Katelynn is drab.\n¬Drab(montague) ::: Montague is not drab.\n¬Mushy(ansel) ::: Ansel is not mushy.\n¬Wicked(joseph) ::: Joseph is not wicked.\nDrab(olive) ::: Olive is drab.\nBroad_minded(joseph) ::: Joseph is broad-minded.\n¬Drab(ansel) ::: Ansel is not drab.\n¬Wicked(montague) ::: Montague is not wicked.\n((Mushy(montague) ∧ ¬Wicked(katelynn))) → (¬Aggressive(ansel)) ::: Montague being mushy and Katelynn being not wicked imply that Ansel is not aggressive.\n(Broad_minded(joseph)) ↔ (¬Impossible(joseph)) ::: Joseph is broad-minded if and only if Joseph is not impossible.\n(∃x (¬Mushy(x))) → (¬Aggressive(whitney) ∧ Impossible(cyril)) ::: If there is at least one person who is not mushy, then Whitney is not aggressive and Cyril is impossible.\n(∃x (Broad_minded(x) ∨ Impossible(x))) → (Aggressive(olive)) ::: If there is someone who is either broad-minded or impossible, then Olive is aggressive.\n¬(¬Broad_minded(x)) → (Aggressive(x)) ::: If there is nobody who is not, then Cyril is not broad-minded and Ansel is aggressive.\n((Wicked(olive) ∧ Drab(katelynn))) ↔ ((Aggressive(joseph) ∧ ¬Broad_minded(montague))) ::: Olive is wicked and Katelynn is drab if and only if Joseph is aggressive and Montague is not broad-minded.\n(∃x (Mushy(x))) → (Broad_minded(katelynn) ∧ ¬Aggressive(joseph)) ::: If there is at least one person who is mushy, then Katelynn is broad-minded and Joseph is not aggressive.\nWicked(x) ∨ Broad_minded(x) → Aggressive(x) ::: Olive being wicked or Cyril being broad-minded implies that Katelynn is aggressive.\n(∃x (Wicked(x) ∧ ¬Mushy(x))) → (¬Drab(montague)) ::: If there is someone who is both wicked and not mushy, then Montague is not drab.\n(¬Impossible(whitney)) → (¬Mushy(cyril) ∧ Broad_minded(joseph)) ::: Whitney being not impossible implies that Cyril is not mushy and Joseph is broad-minded.\n(¬Aggressive(x)) ↔ (¬Impossible(x)) ::: Someone is not aggressive if and only if he is not impossible.\n((Aggressive(x) ∧ ¬Drab(x))) ↔ (¬Impossible(x)) ::: Someone is aggressive and not drab if and only if he is not impossible.",
            "First-Order-Logic Question": "Wicked(joseph) ::: Joseph is wicked."
        },
        "diff": [],
        "answer": "B",
        "grammar_answer": "A",
        "manual_prog": {
            "First-Order-Logic Rules": "Aggressive(montague) ::: Montague is aggressive.\nImpossible(ansel) ::: Ansel is impossible.\n¬Wicked(cyril) ::: Cyril is not wicked.\n¬Wicked(ansel) ::: Ansel is not wicked.\nDrab(katelynn) ::: Katelynn is drab.\n¬Drab(montague) ::: Montague is not drab.\n¬Mushy(ansel) ::: Ansel is not mushy.\n¬Wicked(joseph) ::: Joseph is not wicked.\nDrab(olive) ::: Olive is drab.\nBroad-minded(joseph) ::: Joseph is broad-minded.\n¬Drab(ansel) ::: Ansel is not drab.\n¬Wicked(montague) ::: Montague is not wicked.\n((Mushy(montague) ∧ ¬Wicked(katelynn))) → (¬Aggressive(ansel)) ::: Montague being mushy and Katelynn being not wicked imply that Ansel is not aggressive.\n(Broad-minded(joseph)) ↔ (¬Impossible(joseph)) ::: Joseph is broad-minded if and only if Joseph is not impossible.\n(∃x (¬Mushy(x))) → (¬Aggressive(whitney) ∧ Impossible(cyril)) ::: If there is at least one people who is not mushy, then Whitney is not aggressive and Cyril is impossible.\n(∃x (Broad-minded(x) ∨ Impossible(x))) → (Aggressive(olive)) ::: If there is someone who is either broad-minded or impossible, then Olive is aggressive.\n(∀x (¬x)) → (¬Broad-minded(cyril) ∧ Aggressive(ansel)) ::: If there is nobody who is not, then Cyril is not broad-minded and Ansel is aggressive.\n((Wicked(olive) ∧ Drab(katelynn))) ↔ ((Aggressive(joseph) ∧ ¬Broad-minded(montague))) ::: Olive is wicked and Katelynn is drab if and only if Joseph is aggressive and Montague is not broad-minded.\n(∃x (Mushy(x))) → (Broad-minded(katelynn) ∧ ¬Aggressive(joseph)) ::: If there is at least one people who is mushy, then Katelynn is broad-minded and Joseph is not aggressive.\n((Wicked(olive) ∨ Broad-minded(cyril)) → (Aggressive(katelynn)) ::: Olive being wicked or Cyril being broad-minded implies that Katelynn is aggressive.\n(∃x (Wicked(x) ∧ ¬Mushy(x))) → (¬Drab(montague)) ::: If there is someone who is both wicked and not mushy, then Montague is not drab.\n(¬Impossible(whitney)) → (¬Mushy(cyril) ∧ Broad-minded(joseph)) ::: Whitney being not impossible implies that Cyril is not mushy and Joseph is broad-minded.\n(¬Aggressive(x)) ↔ (¬Impossible(x)) ::: Someone is not aggressive if and only if he is not impossible.\n((Aggressive(x) ∧ ¬Drab(x))) ↔ (¬Impossible(x)) ::: Someone is aggressive and not drab if and only if he is not impossible.\n",
            "First-Order-Logic Question": "Wicked(joseph) ::: Joseph is wicked."
        },
        "fixed": true
    },
    {
        "id": 587,
        "raw_prog": {
            "First-Order-Logic Rules": "¬Hard(max) ::: Max is not hard.\n¬Average(noel) ::: Noel is not average.\n¬Jolly(roderick) ::: Roderick is not jolly.\nAverage(roderick) ::: Roderick is average.\n¬Several(cara) ::: Cara is not several.\nAverage(cara) ::: Cara is average.\nHard(keith) ::: Keith is hard.\nHard(jack) ::: Jack is hard.\nSeveral(noel) ::: Noel is several.\nGiant(jack) ::: Jack is giant.\n¬Giant(roderick) ::: Roderick is not giant.\nJolly(rose) ::: Rose is jolly.\n(∀x (¬Several(x))) → (∀x (¬Old(x) ∧ ¬Hard(x))) ::: As long as someone is not several, he is not old and not hard.\n(∃x (Hard(x) ∨ ¬Old(x))) → ((¬Average(max) ∧ Jolly(rose))) ::: If there is at least one people who is either hard or not old, then Max is not average and Rose is jolly.\n(∃x (Old(x) ∧ Hard(x))) → (Giant(noel)) ::: If there is someone who is both old and hard, then Noel is giant.\n(∃x (Old(x) ∨ ¬Jolly(x))) → (Several(rose)) ::: If there is at least one people who is old or not jolly, then Rose is several.\n(∃x (Jolly(x))) → ((Average(cara) ∧ ¬Hard(keith))) ::: If there is at least one people who is jolly, then Cara is average and Keith is not hard.\n(∀x (Old(x))) ↔ (∀x (¬Hard(x))) ::: If someone is old, then he is not hard, and vice versa.\n(Jack is not several) ↔ (Cara is not old) ::: Jack is not several if and only if Cara is not old.\n(∀x (Old(x) ∧ ¬Several(x))) → (∀x (¬Hard(x) ∧ ¬Jolly(x))) ::: As long as someone is old and not several, he is not hard and not jolly.\n(∀x (¬Hard(x) ∧ ¬Old(x))) ↔ (∀x (¬Giant(x))) ::: Someone being neither hard nor old is equivalent to being not giant.\n(∀x (Old(x) ∧ ¬Jolly(x))) ↔ (∀x (Average(x))) ::: If someone is old and not jolly, then he is average, and vice versa.\n(∀x (¬Average(x))) → (∀x (¬Old(x))) ::: If someone is not average, then he is not old.\n(∃x (Giant(x))) → ((¬Hard(max) ∧ Old(jack))) ::: If there is someone who is giant, then Max is not hard and Jack is old.\n",
            "First-Order-Logic Question": "Jolly(max) ::: Max is jolly."
        },
        "gram_prog": {
            "First-Order-Logic Rules": "¬Hard(max) ::: Max is not hard.\n¬Average(noel) ::: Noel is not average.\n¬Jolly(roderick) ::: Roderick is not jolly.\nAverage(roderick) ::: Roderick is average.\n¬Several(cara) ::: Cara is not several.\nAverage(cara) ::: Cara is average.\nHard(keith) ::: Keith is hard.\nHard(jack) ::: Jack is hard.\nSeveral(noel) ::: Noel is several.\nGiant(jack) ::: Jack is giant.\n¬Giant(roderick) ::: Roderick is not giant.\nJolly(rose) ::: Rose is jolly.\n(∀x (¬Several(x))) → (∀x (¬Old(x) ∧ ¬Hard(x))) ::: As long as someone is not several, he is not old and not hard.\n(∃x (Hard(x) ∨ ¬Old(x))) → ((¬Average(max) ∧ Jolly(rose))) ::: If there is at least one people who is either hard or not old, then Max is not average and Rose is jolly.\n(∃x (Old(x) ∧ Hard(x))) → (Giant(noel)) ::: If there is someone who is both old and hard, then Noel is giant.\n(∃x (Old(x) ∨ ¬Jolly(x))) → (Several(rose)) ::: If there is at least one people who is old or not jolly, then Rose is several.\n(∃x (Jolly(x))) → ((Average(cara) ∧ ¬Hard(keith))) ::: If there is at least one people who is jolly, then Cara is average and Keith is not hard.\n(∀x (Old(x))) ↔ (∀x (¬Hard(x))) ::: If someone is old, then he is not hard, and vice versa.\n¬(Concerned(x)→Serious(x)) ::: Jack is not several if and only if Cara is not old.\n(∀x (Old(x) ∧ ¬Several(x))) → (∀x (¬Hard(x) ∧ ¬Jolly(x))) ::: As long as someone is old and not several, he is not hard and not jolly.\n(∀x (¬Hard(x) ∧ ¬Old(x))) ↔ (∀x (¬Giant(x))) ::: Someone being neither hard nor old is equivalent to being not giant.\n(∀x (Old(x) ∧ ¬Jolly(x))) ↔ (∀x (Average(x))) ::: If someone is old and not jolly, then he is average, and vice versa.\n(∀x (¬Average(x))) → (∀x (¬Old(x))) ::: If someone is not average, then he is not old.\n(∃x (Giant(x))) → ((¬Hard(max) ∧ Old(jack))) ::: If there is someone who is giant, then Max is not hard and Jack is old.\n",
            "First-Order-Logic Question": "Jolly(max) ::: Max is jolly."
        },
        "diff": [
            {
                "raw": "(Jack is not several) ↔ (Cara is not old) ::: Jack is not several if and only if Cara is not old.",
                "gram": "¬(Concerned(x)→Serious(x)) ::: Jack is not several if and only if Cara is not old."
            }
        ],
        "answer": "C",
        "grammar_answer": "A",
        "manual_prog": {
            "First-Order-Logic Rules": "¬Hard(max) ::: Max is not hard.\n¬Average(noel) ::: Noel is not average.\n¬Jolly(roderick) ::: Roderick is not jolly.\nAverage(roderick) ::: Roderick is average.\n¬Several(cara) ::: Cara is not several.\nAverage(cara) ::: Cara is average.\nHard(keith) ::: Keith is hard.\nHard(jack) ::: Jack is hard.\nSeveral(noel) ::: Noel is several.\nGiant(jack) ::: Jack is giant.\n¬Giant(roderick) ::: Roderick is not giant.\nJolly(rose) ::: Rose is jolly.\n(∀x (¬Several(x))) → (∀x (¬Old(x) ∧ ¬Hard(x))) ::: As long as someone is not several, he is not old and not hard.\n(∃x (Hard(x) ∨ ¬Old(x))) → ((¬Average(max) ∧ Jolly(rose))) ::: If there is at least one people who is either hard or not old, then Max is not average and Rose is jolly.\n(∃x (Old(x) ∧ Hard(x))) → (Giant(noel)) ::: If there is someone who is both old and hard, then Noel is giant.\n(∃x (Old(x) ∨ ¬Jolly(x))) → (Several(rose)) ::: If there is at least one people who is old or not jolly, then Rose is several.\n(∃x (Jolly(x))) → ((Average(cara) ∧ ¬Hard(keith))) ::: If there is at least one people who is jolly, then Cara is average and Keith is not hard.\n(∀x (Old(x))) ↔ (∀x (¬Hard(x))) ::: If someone is old, then he is not hard, and vice versa.\n¬Several(jack) ↔ ¬Cold(cara) ::: Jack is not several if and only if Cara is not old.\n(∀x (Old(x) ∧ ¬Several(x))) → (∀x (¬Hard(x) ∧ ¬Jolly(x))) ::: As long as someone is old and not several, he is not hard and not jolly.\n(∀x (¬Hard(x) ∧ ¬Old(x))) ↔ (∀x (¬Giant(x))) ::: Someone being neither hard nor old is equivalent to being not giant.\n(∀x (Old(x) ∧ ¬Jolly(x))) ↔ (∀x (Average(x))) ::: If someone is old and not jolly, then he is average, and vice versa.\n(∀x (¬Average(x))) → (∀x (¬Old(x))) ::: If someone is not average, then he is not old.\n(∃x (Giant(x))) → ((¬Hard(max) ∧ Old(jack))) ::: If there is someone who is giant, then Max is not hard and Jack is old.\n",
            "First-Order-Logic Question": "Jolly(max) ::: Max is jolly."
        },
        "fixed": true
    },
    {
        "id": 591,
        "raw_prog": {
            "First-Order-Logic Rules": "¬Hard(max) ::: Max is not hard.\n¬Average(noel) ::: Noel is not average.\n¬Jolly(roderick) ::: Roderick is not jolly.\nAverage(roderick) ::: Roderick is average.\n¬Several(cara) ::: Cara is not several.\nAverage(cara) ::: Cara is average.\nHard(keith) ::: Keith is hard.\nHard(jack) ::: Jack is hard.\nSeveral(noel) ::: Noel is several.\nGiant(jack) ::: Jack is giant.\n¬Giant(roderick) ::: Roderick is not giant.\nJolly(rose) ::: Rose is jolly.\n(∀x (¬Several(x))) → (∀x (¬Old(x) ∧ ¬Hard(x))) ::: As long as someone is not several, he is not old and not hard.\n(∃x (Hard(x) ∨ ¬Old(x))) → ((¬Average(max) ∧ Jolly(rose))) ::: If there is at least one people who is either hard or not old, then Max is not average and Rose is jolly.\n(∃x (Old(x) ∧ Hard(x))) → ((Giant(noel))) ::: If there is someone who is both old and hard, then Noel is giant.\n(∃x (Old(x) ∨ ¬Jolly(x))) → ((Several(rose))) ::: If there is at least one people who is old or not jolly, then Rose is several.\n(∃x (Jolly(x))) → ((Average(cara) ∧ ¬Hard(keith))) ::: If there is at least one people who is jolly, then Cara is average and Keith is not hard.\n(∀x (Old(x))) ↔ (∀x (¬Hard(x))) ::: If someone is old, then he is not hard, and vice versa.\n(Jack is not several) ↔ (Cara is not old) ::: Jack is not several if and only if Cara is not old.\n(∀x (Old(x) ∧ ¬Several(x))) → (∀x (¬Hard(x) ∧ ¬Jolly(x))) ::: As long as someone is old and not several, he is not hard and not jolly.\n(∀x (¬Hard(x) ∧ ¬Old(x))) ↔ (∀x (¬Giant(x))) ::: Someone being neither hard nor old is equivalent to being not giant.\n(∀x (Old(x) ∧ ¬Jolly(x))) ↔ (∀x (Average(x))) ::: If someone is old and not jolly, then he is average, and vice versa.\n(∀x (¬Average(x))) → (∀x (¬Old(x))) ::: If someone is not average, then he is not old.\n(∃x (Giant(x))) → ((¬Hard(max) ∧ Old(jack))) ::: If there is someone who is giant, then Max is not hard and Jack is old.\n",
            "First-Order-Logic Question": "¬Old(rose) ::: Rose is not old."
        },
        "gram_prog": {
            "First-Order-Logic Rules": "¬Hard(max) ::: Max is not hard.\n¬Average(noel) ::: Noel is not average.\n¬Jolly(roderick) ::: Roderick is not jolly.\nAverage(roderick) ::: Roderick is average.\n¬Several(cara) ::: Cara is not several.\nAverage(cara) ::: Cara is average.\nHard(keith) ::: Keith is hard.\nHard(jack) ::: Jack is hard.\nSeveral(noel) ::: Noel is several.\nGiant(jack) ::: Jack is giant.\n¬Giant(roderick) ::: Roderick is not giant.\nJolly(rose) ::: Rose is jolly.\n(∀x (¬Several(x))) → (∀x (¬Old(x) ∧ ¬Hard(x))) ::: As long as someone is not several, he is not old and not hard.\n(∃x (Hard(x) ∨ ¬Old(x))) → ((¬Average(max) ∧ Jolly(rose))) ::: If there is at least one people who is either hard or not old, then Max is not average and Rose is jolly.\n(∃x (Old(x) ∧ Hard(x))) → ((Giant(noel))) ::: If there is someone who is both old and hard, then Noel is giant.\n(∃x (Old(x) ∨ ¬Jolly(x))) → ((Several(rose))) ::: If there is at least one people who is old or not jolly, then Rose is several.\n(∃x (Jolly(x))) → ((Average(cara) ∧ ¬Hard(keith))) ::: If there is at least one people who is jolly, then Cara is average and Keith is not hard.\n(∀x (Old(x))) ↔ (∀x (¬Hard(x))) ::: If someone is old, then he is not hard, and vice versa.\n¬(Concerned(x)→Serious(x)) ::: Jack is not several if and only if Cara is not old.\n(∀x (Old(x) ∧ ¬Several(x))) → (∀x (¬Hard(x) ∧ ¬Jolly(x))) ::: As long as someone is old and not several, he is not hard and not jolly.\n(∀x (¬Hard(x) ∧ ¬Old(x))) ↔ (∀x (¬Giant(x))) ::: Someone being neither hard nor old is equivalent to being not giant.\n(∀x (Old(x) ∧ ¬Jolly(x))) ↔ (∀x (Average(x))) ::: If someone is old and not jolly, then he is average, and vice versa.\n(∀x (¬Average(x))) → (∀x (¬Old(x))) ::: If someone is not average, then he is not old.\n(∃x (Giant(x))) → ((¬Hard(max) ∧ Old(jack))) ::: If there is someone who is giant, then Max is not hard and Jack is old.\n",
            "First-Order-Logic Question": "¬Old(rose) ::: Rose is not old."
        },
        "diff": [
            {
                "raw": "(Jack is not several) ↔ (Cara is not old) ::: Jack is not several if and only if Cara is not old.",
                "gram": "¬(Concerned(x)→Serious(x)) ::: Jack is not several if and only if Cara is not old."
            }
        ],
        "answer": "C",
        "grammar_answer": "A",
        "manual_prog": {
            "First-Order-Logic Rules": "¬Hard(max) ::: Max is not hard.\n¬Average(noel) ::: Noel is not average.\n¬Jolly(roderick) ::: Roderick is not jolly.\nAverage(roderick) ::: Roderick is average.\n¬Several(cara) ::: Cara is not several.\nAverage(cara) ::: Cara is average.\nHard(keith) ::: Keith is hard.\nHard(jack) ::: Jack is hard.\nSeveral(noel) ::: Noel is several.\nGiant(jack) ::: Jack is giant.\n¬Giant(roderick) ::: Roderick is not giant.\nJolly(rose) ::: Rose is jolly.\n(∀x (¬Several(x))) → (∀x (¬Old(x) ∧ ¬Hard(x))) ::: As long as someone is not several, he is not old and not hard.\n(∃x (Hard(x) ∨ ¬Old(x))) → ((¬Average(max) ∧ Jolly(rose))) ::: If there is at least one people who is either hard or not old, then Max is not average and Rose is jolly.\n(∃x (Old(x) ∧ Hard(x))) → ((Giant(noel))) ::: If there is someone who is both old and hard, then Noel is giant.\n(∃x (Old(x) ∨ ¬Jolly(x))) → ((Several(rose))) ::: If there is at least one people who is old or not jolly, then Rose is several.\n(∃x (Jolly(x))) → ((Average(cara) ∧ ¬Hard(keith))) ::: If there is at least one people who is jolly, then Cara is average and Keith is not hard.\n(∀x (Old(x))) ↔ (∀x (¬Hard(x))) ::: If someone is old, then he is not hard, and vice versa.\n¬Several(jack) ↔ ¬Cold(cara) ::: Jack is not several if and only if Cara is not old.\n(∀x (Old(x) ∧ ¬Several(x))) → (∀x (¬Hard(x) ∧ ¬Jolly(x))) ::: As long as someone is old and not several, he is not hard and not jolly.\n(∀x (¬Hard(x) ∧ ¬Old(x))) ↔ (∀x (¬Giant(x))) ::: Someone being neither hard nor old is equivalent to being not giant.\n(∀x (Old(x) ∧ ¬Jolly(x))) ↔ (∀x (Average(x))) ::: If someone is old and not jolly, then he is average, and vice versa.\n(∀x (¬Average(x))) → (∀x (¬Old(x))) ::: If someone is not average, then he is not old.\n(∃x (Giant(x))) → ((¬Hard(max) ∧ Old(jack))) ::: If there is someone who is giant, then Max is not hard and Jack is old.\n",
            "First-Order-Logic Question": "¬Old(rose) ::: Rose is not old."
        },
        "fixed": true
    },
    {
        "id": 596,
        "raw_prog": {
            "First-Order-Logic Rules": "¬Hard(max) ::: Max is not hard.\n¬Average(noel) ::: Noel is not average.\n¬Jolly(roderick) ::: Roderick is not jolly.\nAverage(roderick) ::: Roderick is average.\n¬Several(cara) ::: Cara is not several.\nAverage(cara) ::: Cara is average.\nHard(keith) ::: Keith is hard.\nHard(jack) ::: Jack is hard.\nSeveral(noel) ::: Noel is several.\nGiant(jack) ::: Jack is giant.\n¬Giant(roderick) ::: Roderick is not giant.\nJolly(rose) ::: Rose is jolly.\n(∀x (¬Several(x))) → (∀x (¬Old(x) ∧ ¬Hard(x))) ::: As long as someone is not several, he is not old and not hard.\n(∃x (Hard(x) ∨ ¬Old(x))) → ((¬Average(max) ∧ Jolly(rose))) ::: If there is at least one people who is either hard or not old, then Max is not average and Rose is jolly.\n(∃x (Old(x) ∧ Hard(x))) → (Giant(noel)) ::: If there is someone who is both old and hard, then Noel is giant.\n(∃x (Old(x) ∨ ¬Jolly(x))) → (Several(rose)) ::: If there is at least one people who is old or not jolly, then Rose is several.\n(∃x (Jolly(x))) → ((Average(cara) ∧ ¬Hard(keith))) ::: If there is at least one people who is jolly, then Cara is average and Keith is not hard.\n(∀x (Old(x))) ↔ (∀x (¬Hard(x))) ::: If someone is old, then he is not hard, and vice versa.\n(Jack is not several) ↔ (Cara is not old) ::: Jack is not several if and only if Cara is not old.\n(∀x (Old(x) ∧ ¬Several(x))) → (∀x (¬Hard(x) ∧ ¬Jolly(x))) ::: As long as someone is old and not several, he is not hard and not jolly.\n(∀x (¬Hard(x) ∧ ¬Old(x))) ↔ (∀x (¬Giant(x))) ::: Someone being neither hard nor old is equivalent to being not giant.\n(∀x (Old(x) ∧ ¬Jolly(x))) ↔ (∀x (Average(x))) ::: If someone is old and not jolly, then he is average, and vice versa.\n(∀x (¬Average(x))) → (∀x (¬Old(x))) ::: If someone is not average, then he is not old.\n(∃x (Giant(x))) → ((¬Hard(max) ∧ Old(jack))) ::: If there is someone who is giant, then Max is not hard and Jack is old.\n",
            "First-Order-Logic Question": "Jolly(noel) ::: Noel is jolly."
        },
        "gram_prog": {
            "First-Order-Logic Rules": "¬Hard(max) ::: Max is not hard.\n¬Average(noel) ::: Noel is not average.\n¬Jolly(roderick) ::: Roderick is not jolly.\nAverage(roderick) ::: Roderick is average.\n¬Several(cara) ::: Cara is not several.\nAverage(cara) ::: Cara is average.\nHard(keith) ::: Keith is hard.\nHard(jack) ::: Jack is hard.\nSeveral(noel) ::: Noel is several.\nGiant(jack) ::: Jack is giant.\n¬Giant(roderick) ::: Roderick is not giant.\nJolly(rose) ::: Rose is jolly.\n(∀x (¬Several(x))) → (∀x (¬Old(x) ∧ ¬Hard(x))) ::: As long as someone is not several, he is not old and not hard.\n(∃x (Hard(x) ∨ ¬Old(x))) → ((¬Average(max) ∧ Jolly(rose))) ::: If there is at least one people who is either hard or not old, then Max is not average and Rose is jolly.\n(∃x (Old(x) ∧ Hard(x))) → (Giant(noel)) ::: If there is someone who is both old and hard, then Noel is giant.\n(∃x (Old(x) ∨ ¬Jolly(x))) → (Several(rose)) ::: If there is at least one people who is old or not jolly, then Rose is several.\n(∃x (Jolly(x))) → ((Average(cara) ∧ ¬Hard(keith))) ::: If there is at least one people who is jolly, then Cara is average and Keith is not hard.\n(∀x (Old(x))) ↔ (∀x (¬Hard(x))) ::: If someone is old, then he is not hard, and vice versa.\n¬(Concerned(x)→Serious(x)) ::: Jack is not several if and only if Cara is not old.\n(∀x (Old(x) ∧ ¬Several(x))) → (∀x (¬Hard(x) ∧ ¬Jolly(x))) ::: As long as someone is old and not several, he is not hard and not jolly.\n(∀x (¬Hard(x) ∧ ¬Old(x))) ↔ (∀x (¬Giant(x))) ::: Someone being neither hard nor old is equivalent to being not giant.\n(∀x (Old(x) ∧ ¬Jolly(x))) ↔ (∀x (Average(x))) ::: If someone is old and not jolly, then he is average, and vice versa.\n(∀x (¬Average(x))) → (∀x (¬Old(x))) ::: If someone is not average, then he is not old.\n(∃x (Giant(x))) → ((¬Hard(max) ∧ Old(jack))) ::: If there is someone who is giant, then Max is not hard and Jack is old.\n",
            "First-Order-Logic Question": "Jolly(noel) ::: Noel is jolly."
        },
        "diff": [
            {
                "raw": "(Jack is not several) ↔ (Cara is not old) ::: Jack is not several if and only if Cara is not old.",
                "gram": "¬(Concerned(x)→Serious(x)) ::: Jack is not several if and only if Cara is not old."
            }
        ],
        "answer": "C",
        "grammar_answer": "A",
        "manual_prog": {
            "First-Order-Logic Rules": "¬Hard(max) ::: Max is not hard.\n¬Average(noel) ::: Noel is not average.\n¬Jolly(roderick) ::: Roderick is not jolly.\nAverage(roderick) ::: Roderick is average.\n¬Several(cara) ::: Cara is not several.\nAverage(cara) ::: Cara is average.\nHard(keith) ::: Keith is hard.\nHard(jack) ::: Jack is hard.\nSeveral(noel) ::: Noel is several.\nGiant(jack) ::: Jack is giant.\n¬Giant(roderick) ::: Roderick is not giant.\nJolly(rose) ::: Rose is jolly.\n(∀x (¬Several(x))) → (∀x (¬Old(x) ∧ ¬Hard(x))) ::: As long as someone is not several, he is not old and not hard.\n(∃x (Hard(x) ∨ ¬Old(x))) → ((¬Average(max) ∧ Jolly(rose))) ::: If there is at least one people who is either hard or not old, then Max is not average and Rose is jolly.\n(∃x (Old(x) ∧ Hard(x))) → (Giant(noel)) ::: If there is someone who is both old and hard, then Noel is giant.\n(∃x (Old(x) ∨ ¬Jolly(x))) → (Several(rose)) ::: If there is at least one people who is old or not jolly, then Rose is several.\n(∃x (Jolly(x))) → ((Average(cara) ∧ ¬Hard(keith))) ::: If there is at least one people who is jolly, then Cara is average and Keith is not hard.\n(∀x (Old(x))) ↔ (∀x (¬Hard(x))) ::: If someone is old, then he is not hard, and vice versa.\n¬Several(jack) ↔ ¬Cold(cara) ::: Jack is not several if and only if Cara is not old.\n(∀x (Old(x) ∧ ¬Several(x))) → (∀x (¬Hard(x) ∧ ¬Jolly(x))) ::: As long as someone is old and not several, he is not hard and not jolly.\n(∀x (¬Hard(x) ∧ ¬Old(x))) ↔ (∀x (¬Giant(x))) ::: Someone being neither hard nor old is equivalent to being not giant.\n(∀x (Old(x) ∧ ¬Jolly(x))) ↔ (∀x (Average(x))) ::: If someone is old and not jolly, then he is average, and vice versa.\n(∀x (¬Average(x))) → (∀x (¬Old(x))) ::: If someone is not average, then he is not old.\n(∃x (Giant(x))) → ((¬Hard(max) ∧ Old(jack))) ::: If there is someone who is giant, then Max is not hard and Jack is old.\n",
            "First-Order-Logic Question": "Jolly(noel) ::: Noel is jolly."
        },
        "fixed": true
    },
    {
        "id": 694,
        "raw_prog": {
            "First-Order-Logic Rules": "Alert(tristin) ::: Tristin is alert.\n¬Substantial(tristin) ::: Tristin is not substantial.\n¬Alert(sandra) ::: Sandra is not alert.\nAlert(barnaby) ::: Barnaby is alert.\n¬Energetic(barnaby) ::: Barnaby is not energetic.\n¬Energetic(tristin) ::: Tristin is not energetic.\nWonderful(noel) ::: Noel is wonderful.\n¬Fair(tristin) ::: Tristin is not fair.\nFair(barnaby) ::: Barnaby is fair.\n¬Alert(noel) ::: Noel is not alert.\n¬Fancy(cara) ::: Cara is not fancy.\n¬Energetic(adler) ::: Adler is not energetic.\n(∃x (¬Substantial(x))) → (Alert(adler) ∧ ¬Wonderful(blaine)) ::: If there is someone who is not substantial, then Adler is alert and Blaine is not wonderful.\n(Substantial(sandra)) ↔ (¬Energetic(noel) ∧ Fancy(sandra)) ::: Sandra being substantial is equivalent to Noel being not energetic and Sandra being fancy.\n((Substantial(x) ∧ ¬Fair(x))) ↔ (¬Energetic(x)) ::: If someone is substantial and not fair, then he is not energetic, and vice versa.\n((Wonderful(x) ∧ Energetic(x))) → (Fair(sandra) ∧ ¬Substantial(tristin)) ::: If there is someone who is both wonderful and energetic, then Sandra is fair and Tristin is not substantial.\n(¬Fair(x)) → (Wonderful(x)) ::: If someone is not fair, then he is wonderful.\n(Fancy(cara)) → (Sandra is fancy) ::: It can be concluded that Sandra is fancy once knowing that Cara is fair.\n((¬Substantial(x) ∧ Fair(x))) → (¬Fancy(x)) ::: If someone who is not substantial is also fair, then he is not fancy.\n(∀x (Wonderful(x))) → (Substantial(x)) ::: All wonderful people are substantial.\n(¬Fair(adler)) → (Alert(cara) ∧ ¬Wonderful(cara)) ::: Adler being not fair implies that Cara is alert and Cara is not wonderful.\n((Fancy(tristin) ∧ Wonderful(adler))) → (¬Energetic(cara) ∧ Alert(adler)) ::: If Tristin is fancy and Adler is wonderful, then Cara is not energetic and Adler is alert.\n((Substantial(x) ∧ ¬Fair(x))) → (¬Wonderful(x)) ::: Someone who is both substantial and not fair is always not wonderful.\n(¬Fancy(x)) → (¬Alert(x)) ::: If someone is not fancy, then he is not alert.",
            "First-Order-Logic Question": "¬Alert(tristin) ::: Tristin is not alert."
        },
        "gram_prog": {
            "First-Order-Logic Rules": "Alert(tristin) ::: Tristin is alert.\n¬Substantial(tristin) ::: Tristin is not substantial.\n¬Alert(sandra) ::: Sandra is not alert.\nAlert(barnaby) ::: Barnaby is alert.\n¬Energetic(barnaby) ::: Barnaby is not energetic.\n¬Energetic(tristin) ::: Tristin is not energetic.\nWonderful(noel) ::: Noel is wonderful.\n¬Fair(tristin) ::: Tristin is not fair.\nFair(barnaby) ::: Barnaby is fair.\n¬Alert(noel) ::: Noel is not alert.\n¬Fancy(cara) ::: Cara is not fancy.\n¬Energetic(adler) ::: Adler is not energetic.\n(∃x (¬Substantial(x))) → (Alert(adler) ∧ ¬Wonderful(blaine)) ::: If there is someone who is not substantial, then Adler is alert and Blaine is not wonderful.\n(Substantial(sandra)) ↔ (¬Energetic(noel) ∧ Fancy(sandra)) ::: Sandra being substantial is equivalent to Noel being not energetic and Sandra being fancy.\n((Substantial(x) ∧ ¬Fair(x))) ↔ (¬Energetic(x)) ::: If someone is substantial and not fair, then he is not energetic, and vice versa.\n((Wonderful(x) ∧ Energetic(x))) → (Fair(sandra) ∧ ¬Substantial(tristin)) ::: If there is someone who is both wonderful and energetic, then Sandra is fair and Tristin is not substantial.\n(¬Fair(x)) → (Wonderful(x)) ::: If someone is not fair, then he is wonderful.\nFancy(x)→(Substantial(x)) ::: It can be concluded that Sandra is fancy once knowing that Cara is fair.\n((¬Substantial(x) ∧ Fair(x))) → (¬Fancy(x)) ::: If someone who is not substantial is also fair, then he is not fancy.\n(∀x (Wonderful(x))) → (Substantial(x)) ::: All wonderful people are substantial.\n(¬Fair(adler)) → (Alert(cara) ∧ ¬Wonderful(cara)) ::: Adler being not fair implies that Cara is alert and Cara is not wonderful.\n((Fancy(tristin) ∧ Wonderful(adler))) → (¬Energetic(cara) ∧ Alert(adler)) ::: If Tristin is fancy and Adler is wonderful, then Cara is not energetic and Adler is alert.\n((Substantial(x) ∧ ¬Fair(x))) → (¬Wonderful(x)) ::: Someone who is both substantial and not fair is always not wonderful.\n(¬Fancy(x)) → (¬Alert(x)) ::: If someone is not fancy, then he is not alert.",
            "First-Order-Logic Question": "¬Alert(tristin) ::: Tristin is not alert."
        },
        "diff": [
            {
                "raw": "(Fancy(cara)) → (Sandra is fancy) ::: It can be concluded that Sandra is fancy once knowing that Cara is fair.",
                "gram": "Fancy(x)→(Substantial(x)) ::: It can be concluded that Sandra is fancy once knowing that Cara is fair."
            }
        ],
        "answer": "B",
        "grammar_answer": "A",
        "manual_prog": {
            "First-Order-Logic Rules": "Alert(tristin) ::: Tristin is alert.\n¬Substantial(tristin) ::: Tristin is not substantial.\n¬Alert(sandra) ::: Sandra is not alert.\nAlert(barnaby) ::: Barnaby is alert.\n¬Energetic(barnaby) ::: Barnaby is not energetic.\n¬Energetic(tristin) ::: Tristin is not energetic.\nWonderful(noel) ::: Noel is wonderful.\n¬Fair(tristin) ::: Tristin is not fair.\nFair(barnaby) ::: Barnaby is fair.\n¬Alert(noel) ::: Noel is not alert.\n¬Fancy(cara) ::: Cara is not fancy.\n¬Energetic(adler) ::: Adler is not energetic.\n(∃x (¬Substantial(x))) → (Alert(adler) ∧ ¬Wonderful(blaine)) ::: If there is someone who is not substantial, then Adler is alert and Blaine is not wonderful.\n(Substantial(sandra)) ↔ (¬Energetic(noel) ∧ Fancy(sandra)) ::: Sandra being substantial is equivalent to Noel being not energetic and Sandra being fancy.\n((Substantial(x) ∧ ¬Fair(x))) ↔ (¬Energetic(x)) ::: If someone is substantial and not fair, then he is not energetic, and vice versa.\n((Wonderful(x) ∧ Energetic(x))) → (Fair(sandra) ∧ ¬Substantial(tristin)) ::: If there is someone who is both wonderful and energetic, then Sandra is fair and Tristin is not substantial.\n(¬Fair(x)) → (Wonderful(x)) ::: If someone is not fair, then he is wonderful.\n(Fancy(cara)) → (Fancy(sandra)) ::: It can be concluded that Sandra is fancy once knowing that Cara is fair.\n((¬Substantial(x) ∧ Fair(x))) → (¬Fancy(x)) ::: If someone who is not substantial is also fair, then he is not fancy.\n(∀x (Wonderful(x))) → (Substantial(x)) ::: All wonderful people are substantial.\n(¬Fair(adler)) → (Alert(cara) ∧ ¬Wonderful(cara)) ::: Adler being not fair implies that Cara is alert and Cara is not wonderful.\n((Fancy(tristin) ∧ Wonderful(adler))) → (¬Energetic(cara) ∧ Alert(adler)) ::: If Tristin is fancy and Adler is wonderful, then Cara is not energetic and Adler is alert.\n((Substantial(x) ∧ ¬Fair(x))) → (¬Wonderful(x)) ::: Someone who is both substantial and not fair is always not wonderful.\n(¬Fancy(x)) → (¬Alert(x)) ::: If someone is not fancy, then he is not alert.",
            "First-Order-Logic Question": "¬Alert(tristin) ::: Tristin is not alert."
        },
        "fixed": true
    },
    {
        "id": 737,
        "raw_prog": {
            "First-Order-Logic Rules": "¬Energetic(lesley) ::: Lesley is not energetic.\nCrowded(lesley) ::: Lesley is crowded.\nFaithful(max) ::: Max is faithful.\n¬Faithful(dan) ::: Dan is not faithful.\n¬Energetic(clarence) ::: Clarence is not energetic.\nWonderful(cara) ::: Cara is wonderful.\nAngry(clarence) ::: Clarence is angry.\nLong(max) ::: Max is long.\n¬Angry(christina) ::: Christina is not angry.\nEnergetic(cara) ::: Cara is energetic.\nLong(cara) ::: Cara is long.\n¬Long(christina) ::: Christina is not long.\n(∃x (¬Long(x))) → (Wonderful(christina)) ::: If there is someone who is not long, then Christina is wonderful.\n(∃x (Crowded(x) ∧ ¬Angry(x))) → (¬Long(x)) ::: If someone is both crowded and not angry, then he is not long.\n(∃x (Long(x))) → (¬Crowded(max) ∧ ¬Angry(cara)) ::: If there is someone who is long, then Max is not crowded and Cara is not angry.\n((¬Faithful(lesley))) ↔ (Energetic(dan) ∧ ¬Crowded(lesley)) ::: Lesley being not faithful is equivalent to Dan being energetic and Lesley being not crowded.\n(∃x (Wonderful(x))) → (¬Energetic(dan)) ::: If there is someone who is wonderful, then Dan is not energetic.\n((¬Wonderful(lesley) ∨ Angry(clarence))) → (¬Long(dan)) ::: Lesley being not wonderful or Clarence being angry implies that Dan is not long.\n(∀x (Faithful(x) ∨ ¬Wonderful(x))) → (¬Long(x)) ::: If someone is faithful or not wonderful, then he is not long.\n(∀x ((Angry(x) ∧ Faithful(x))) → (Energetic(x))) ::: If someone who is angry is also faithful, then he is energetic.\n((¬Crowded(christina))) → (Energetic(christina)) ::: Christina being not crowded implies that Christina is energetic.\n(∀x (¬Long(x))) → (Energetic(x) ∧ ¬Wonderful(x)) ::: If someone is not long, then he is both energetic and not wonderful.\n(∀x ((¬Energetic(x) ∧ ¬Wonderful(x))) ↔ (Long(x)) ::: Someone being neither energetic nor wonderful is equivalent to being long.\n(∀x ((Long(x) ∧ ¬Crowded(x))) ↔ (¬Faithful(x) ∧ ¬Angry(x))) ::: Someone being both long and not crowded is equivalent to being not faithful and not angry.\n",
            "First-Order-Logic Question": "¬Long(clarence) ::: Clarence is not long."
        },
        "gram_prog": {
            "First-Order-Logic Rules": "¬Energetic(lesley) ::: Lesley is not energetic.\nCrowded(lesley) ::: Lesley is crowded.\nFaithful(max) ::: Max is faithful.\n¬Faithful(dan) ::: Dan is not faithful.\n¬Energetic(clarence) ::: Clarence is not energetic.\nWonderful(cara) ::: Cara is wonderful.\nAngry(clarence) ::: Clarence is angry.\nLong(max) ::: Max is long.\n¬Angry(christina) ::: Christina is not angry.\nEnergetic(cara) ::: Cara is energetic.\nLong(cara) ::: Cara is long.\n¬Long(christina) ::: Christina is not long.\n(∃x (¬Long(x))) → (Wonderful(christina)) ::: If there is someone who is not long, then Christina is wonderful.\n(∃x (Crowded(x) ∧ ¬Angry(x))) → (¬Long(x)) ::: If someone is both crowded and not angry, then he is not long.\n(∃x (Long(x))) → (¬Crowded(max) ∧ ¬Angry(cara)) ::: If there is someone who is long, then Max is not crowded and Cara is not angry.\n((¬Faithful(lesley))) ↔ (Energetic(dan) ∧ ¬Crowded(lesley)) ::: Lesley being not faithful is equivalent to Dan being energetic and Lesley being not crowded.\n(∃x (Wonderful(x))) → (¬Energetic(dan)) ::: If there is someone who is wonderful, then Dan is not energetic.\n((¬Wonderful(lesley) ∨ Angry(clarence))) → (¬Long(dan)) ::: Lesley being not wonderful or Clarence being angry implies that Dan is not long.\n(∀x (Faithful(x) ∨ ¬Wonderful(x))) → (¬Long(x)) ::: If someone is faithful or not wonderful, then he is not long.\n(∀x ((Angry(x) ∧ Faithful(x))) → (Energetic(x))) ::: If someone who is angry is also faithful, then he is energetic.\n((¬Crowded(christina))) → (Energetic(christina)) ::: Christina being not crowded implies that Christina is energetic.\n(∀x (¬Long(x))) → (Energetic(x) ∧ ¬Wonderful(x)) ::: If someone is not long, then he is both energetic and not wonderful.\n¬Entire(x)→(Serious(x)∨Fresh(x)) ::: Someone being neither energetic nor wonderful is equivalent to being long.\n(∀x ((Long(x) ∧ ¬Crowded(x))) ↔ (¬Faithful(x) ∧ ¬Angry(x))) ::: Someone being both long and not crowded is equivalent to being not faithful and not angry.\n",
            "First-Order-Logic Question": "¬Long(clarence) ::: Clarence is not long."
        },
        "diff": [
            {
                "raw": "(∀x ((¬Energetic(x) ∧ ¬Wonderful(x))) ↔ (Long(x)) ::: Someone being neither energetic nor wonderful is equivalent to being long.",
                "gram": "¬Entire(x)→(Serious(x)∨Fresh(x)) ::: Someone being neither energetic nor wonderful is equivalent to being long."
            }
        ],
        "answer": "C",
        "grammar_answer": "A",
        "manual_prog": {
            "First-Order-Logic Rules": "¬Energetic(lesley) ::: Lesley is not energetic.\nCrowded(lesley) ::: Lesley is crowded.\nFaithful(max) ::: Max is faithful.\n¬Faithful(dan) ::: Dan is not faithful.\n¬Energetic(clarence) ::: Clarence is not energetic.\nWonderful(cara) ::: Cara is wonderful.\nAngry(clarence) ::: Clarence is angry.\nLong(max) ::: Max is long.\n¬Angry(christina) ::: Christina is not angry.\nEnergetic(cara) ::: Cara is energetic.\nLong(cara) ::: Cara is long.\n¬Long(christina) ::: Christina is not long.\n(∃x (¬Long(x))) → (Wonderful(christina)) ::: If there is someone who is not long, then Christina is wonderful.\n(∃x (Crowded(x) ∧ ¬Angry(x))) → (¬Long(x)) ::: If someone is both crowded and not angry, then he is not long.\n(∃x (Long(x))) → (¬Crowded(max) ∧ ¬Angry(cara)) ::: If there is someone who is long, then Max is not crowded and Cara is not angry.\n((¬Faithful(lesley))) ↔ (Energetic(dan) ∧ ¬Crowded(lesley)) ::: Lesley being not faithful is equivalent to Dan being energetic and Lesley being not crowded.\n(∃x (Wonderful(x))) → (¬Energetic(dan)) ::: If there is someone who is wonderful, then Dan is not energetic.\n((¬Wonderful(lesley) ∨ Angry(clarence))) → (¬Long(dan)) ::: Lesley being not wonderful or Clarence being angry implies that Dan is not long.\n(∀x (Faithful(x) ∨ ¬Wonderful(x))) → (¬Long(x)) ::: If someone is faithful or not wonderful, then he is not long.\n(∀x ((Angry(x) ∧ Faithful(x))) → (Energetic(x))) ::: If someone who is angry is also faithful, then he is energetic.\n((¬Crowded(christina))) → (Energetic(christina)) ::: Christina being not crowded implies that Christina is energetic.\n(∀x (¬Long(x))) → (Energetic(x) ∧ ¬Wonderful(x)) ::: If someone is not long, then he is both energetic and not wonderful.\n(∀x ((¬Energetic(x) ∧ ¬Wonderful(x))) ↔ (Long(x))) ::: Someone being neither energetic nor wonderful is equivalent to being long.\n(∀x ((Long(x) ∧ ¬Crowded(x))) ↔ (¬Faithful(x) ∧ ¬Angry(x))) ::: Someone being both long and not crowded is equivalent to being not faithful and not angry.\n",
            "First-Order-Logic Question": "¬Long(clarence) ::: Clarence is not long."
        },
        "fixed": true
    },
    {
        "id": 741,
        "raw_prog": {
            "First-Order-Logic Rules": "¬Energetic(lesley) ::: Lesley is not energetic.\nCrowded(lesley) ::: Lesley is crowded.\nFaithful(max) ::: Max is faithful.\n¬Faithful(dan) ::: Dan is not faithful.\n¬Energetic(clarence) ::: Clarence is not energetic.\nWonderful(cara) ::: Cara is wonderful.\nAngry(clarence) ::: Clarence is angry.\nLong(max) ::: Max is long.\n¬Angry(christina) ::: Christina is not angry.\nEnergetic(cara) ::: Cara is energetic.\nLong(cara) ::: Cara is long.\n¬Long(christina) ::: Christina is not long.\n(∃x (¬Long(x))) → (Wonderful(christina)) ::: If there is someone who is not long, then Christina is wonderful.\n(∀x ((Crowded(x) ∧ ¬Angry(x))) → (¬Long(x))) ::: If someone is both crowded and not angry, then he is not long.\n(∀x (Long(x))) → (¬Crowded(max) ∧ ¬Angry(cara)) ::: If there is someone who is long, then Max is not crowded and Cara is not angry.\n((¬Faithful(lesley))) ↔ ((Energetic(dan) ∧ ¬Crowded(lesley))) ::: Lesley being not faithful is equivalent to Dan being energetic and Lesley being not crowded.\n(∃x (Wonderful(x))) → (¬Energetic(dan)) ::: If there is someone who is wonderful, then Dan is not energetic.\n((¬Wonderful(lesley) ∨ Angry(clarence))) → (¬Long(dan)) ::: Lesley being not wonderful or Clarence being angry implies that Dan is not long.\n(∀x (Faithful(x) ∨ ¬Wonderful(x))) → (¬Long(x)) ::: If someone is faithful or not wonderful, then he is not long.\n(∀x ((Angry(x) ∧ Faithful(x))) → (Energetic(x))) ::: If someone who is angry is also faithful, then he is energetic.\n(¬Crowded(christina)) → (Energetic(christina)) ::: Christina being not crowded implies that Christina is energetic.\n(∀x (¬Long(x))) → (Energetic(x) ∧ ¬Wonderful(x)) ::: If someone is not long, then he is both energetic and not wonderful.\n(∀x ((¬Energetic(x) ∧ ¬Wonderful(x))) ↔ (Long(x)) ::: Someone being neither energetic nor wonderful is equivalent to being long.\n(∀x ((Long(x) ∧ ¬Crowded(x))) ↔ (¬Faithful(x) ∧ ¬Angry(x))) ::: Someone being both long and not crowded is equivalent to being not faithful and not angry.\n",
            "First-Order-Logic Question": "Crowded(max) ::: Max is crowded."
        },
        "gram_prog": {
            "First-Order-Logic Rules": "¬Energetic(lesley) ::: Lesley is not energetic.\nCrowded(lesley) ::: Lesley is crowded.\nFaithful(max) ::: Max is faithful.\n¬Faithful(dan) ::: Dan is not faithful.\n¬Energetic(clarence) ::: Clarence is not energetic.\nWonderful(cara) ::: Cara is wonderful.\nAngry(clarence) ::: Clarence is angry.\nLong(max) ::: Max is long.\n¬Angry(christina) ::: Christina is not angry.\nEnergetic(cara) ::: Cara is energetic.\nLong(cara) ::: Cara is long.\n¬Long(christina) ::: Christina is not long.\n(∃x (¬Long(x))) → (Wonderful(christina)) ::: If there is someone who is not long, then Christina is wonderful.\n(∀x ((Crowded(x) ∧ ¬Angry(x))) → (¬Long(x))) ::: If someone is both crowded and not angry, then he is not long.\n(∀x (Long(x))) → (¬Crowded(max) ∧ ¬Angry(cara)) ::: If there is someone who is long, then Max is not crowded and Cara is not angry.\n((¬Faithful(lesley))) ↔ ((Energetic(dan) ∧ ¬Crowded(lesley))) ::: Lesley being not faithful is equivalent to Dan being energetic and Lesley being not crowded.\n(∃x (Wonderful(x))) → (¬Energetic(dan)) ::: If there is someone who is wonderful, then Dan is not energetic.\n((¬Wonderful(lesley) ∨ Angry(clarence))) → (¬Long(dan)) ::: Lesley being not wonderful or Clarence being angry implies that Dan is not long.\n(∀x (Faithful(x) ∨ ¬Wonderful(x))) → (¬Long(x)) ::: If someone is faithful or not wonderful, then he is not long.\n(∀x ((Angry(x) ∧ Faithful(x))) → (Energetic(x))) ::: If someone who is angry is also faithful, then he is energetic.\n(¬Crowded(christina)) → (Energetic(christina)) ::: Christina being not crowded implies that Christina is energetic.\n(∀x (¬Long(x))) → (Energetic(x) ∧ ¬Wonderful(x)) ::: If someone is not long, then he is both energetic and not wonderful.\n¬Energetic(x)∧¬Wonderful(x)↔Long(x) ::: Someone being neither energetic nor wonderful is equivalent to being long.\n(∀x ((Long(x) ∧ ¬Crowded(x))) ↔ (¬Faithful(x) ∧ ¬Angry(x))) ::: Someone being both long and not crowded is equivalent to being not faithful and not angry.\n",
            "First-Order-Logic Question": "Crowded(max) ::: Max is crowded."
        },
        "diff": [
            {
                "raw": "(∀x ((¬Energetic(x) ∧ ¬Wonderful(x))) ↔ (Long(x)) ::: Someone being neither energetic nor wonderful is equivalent to being long.",
                "gram": "¬Energetic(x)∧¬Wonderful(x)↔Long(x) ::: Someone being neither energetic nor wonderful is equivalent to being long."
            }
        ],
        "answer": "B",
        "grammar_answer": "A",
        "manual_prog": {
            "First-Order-Logic Rules": "¬Energetic(lesley) ::: Lesley is not energetic.\nCrowded(lesley) ::: Lesley is crowded.\nFaithful(max) ::: Max is faithful.\n¬Faithful(dan) ::: Dan is not faithful.\n¬Energetic(clarence) ::: Clarence is not energetic.\nWonderful(cara) ::: Cara is wonderful.\nAngry(clarence) ::: Clarence is angry.\nLong(max) ::: Max is long.\n¬Angry(christina) ::: Christina is not angry.\nEnergetic(cara) ::: Cara is energetic.\nLong(cara) ::: Cara is long.\n¬Long(christina) ::: Christina is not long.\n(∃x (¬Long(x))) → (Wonderful(christina)) ::: If there is someone who is not long, then Christina is wonderful.\n(∀x ((Crowded(x) ∧ ¬Angry(x))) → (¬Long(x))) ::: If someone is both crowded and not angry, then he is not long.\n(∀x (Long(x))) → (¬Crowded(max) ∧ ¬Angry(cara)) ::: If there is someone who is long, then Max is not crowded and Cara is not angry.\n((¬Faithful(lesley))) ↔ ((Energetic(dan) ∧ ¬Crowded(lesley))) ::: Lesley being not faithful is equivalent to Dan being energetic and Lesley being not crowded.\n(∃x (Wonderful(x))) → (¬Energetic(dan)) ::: If there is someone who is wonderful, then Dan is not energetic.\n((¬Wonderful(lesley) ∨ Angry(clarence))) → (¬Long(dan)) ::: Lesley being not wonderful or Clarence being angry implies that Dan is not long.\n(∀x (Faithful(x) ∨ ¬Wonderful(x))) → (¬Long(x)) ::: If someone is faithful or not wonderful, then he is not long.\n(∀x ((Angry(x) ∧ Faithful(x))) → (Energetic(x))) ::: If someone who is angry is also faithful, then he is energetic.\n(¬Crowded(christina)) → (Energetic(christina)) ::: Christina being not crowded implies that Christina is energetic.\n(∀x (¬Long(x))) → (Energetic(x) ∧ ¬Wonderful(x)) ::: If someone is not long, then he is both energetic and not wonderful.\n(∀x ((¬Energetic(x) ∧ ¬Wonderful(x))) ↔ (Long(x))) ::: Someone being neither energetic nor wonderful is equivalent to being long.\n(∀x ((Long(x) ∧ ¬Crowded(x))) ↔ (¬Faithful(x) ∧ ¬Angry(x))) ::: Someone being both long and not crowded is equivalent to being not faithful and not angry.\n",
            "First-Order-Logic Question": "Crowded(max) ::: Max is crowded."
        },
        "fixed": true
    },
    {
        "id": 745,
        "raw_prog": {
            "First-Order-Logic Rules": "¬Energetic(lesley) ::: Lesley is not energetic.\nCrowded(lesley) ::: Lesley is crowded.\nFaithful(max) ::: Max is faithful.\n¬Faithful(dan) ::: Dan is not faithful.\n¬Energetic(clarence) ::: Clarence is not energetic.\nWonderful(cara) ::: Cara is wonderful.\nAngry(clarence) ::: Clarence is angry.\nLong(max) ::: Max is long.\n¬Angry(christina) ::: Christina is not angry.\nEnergetic(cara) ::: Cara is energetic.\nLong(cara) ::: Cara is long.\n¬Long(christina) ::: Christina is not long.\n(∃x (¬Long(x))) → (Wonderful(christina)) ::: If there is someone who is not long, then Christina is wonderful.\n(∃x (Crowded(x) ∧ ¬Angry(x))) → (∀x (¬Long(x))) ::: If someone is both crowded and not angry, then he is not long.\n(∃x (Long(x))) → (¬Crowded(max) ∧ ¬Angry(cara)) ::: If there is someone who is long, then Max is not crowded and Cara is not angry.\n((¬Faithful(lesley))) ↔ (Energetic(dan) ∧ ¬Crowded(lesley)) ::: Lesley being not faithful is equivalent to Dan being energetic and Lesley being not crowded.\n(∃x (Wonderful(x))) → (¬Energetic(dan)) ::: If there is someone who is wonderful, then Dan is not energetic.\n((¬Wonderful(lesley) ∨ Angry(clarence))) → (¬Long(dan)) ::: Lesley being not wonderful or Clarence being angry implies that Dan is not long.\n(∀x (Faithful(x) ∨ ¬Wonderful(x))) → (∀x (¬Long(x))) ::: If someone is faithful or not wonderful, then he is not long.\n(∀x ((Angry(x) ∧ Faithful(x))) → (Energetic(x))) ::: If someone who is angry is also faithful, then he is energetic.\n(¬Crowded(christina)) → (Energetic(christina)) ::: Christina being not crowded implies that Christina is energetic.\n(¬Long(x)) → (Energetic(x) ∧ ¬Wonderful(x)) ::: If someone is not long, then he is both energetic and not wonderful.\n(∀x ((¬Energetic(x) ∧ ¬Wonderful(x))) ↔ (Long(x)) ::: Someone being neither energetic nor wonderful is equivalent to being long.\n(∀x ((Long(x) ∧ ¬Crowded(x))) ↔ (¬Faithful(x) ∧ ¬Angry(x))) ::: Someone being both long and not crowded is equivalent to being not faithful and not angry.\n",
            "First-Order-Logic Question": "Energetic(lesley) ::: Lesley is energetic."
        },
        "gram_prog": {
            "First-Order-Logic Rules": "¬Energetic(lesley) ::: Lesley is not energetic.\nCrowded(lesley) ::: Lesley is crowded.\nFaithful(max) ::: Max is faithful.\n¬Faithful(dan) ::: Dan is not faithful.\n¬Energetic(clarence) ::: Clarence is not energetic.\nWonderful(cara) ::: Cara is wonderful.\nAngry(clarence) ::: Clarence is angry.\nLong(max) ::: Max is long.\n¬Angry(christina) ::: Christina is not angry.\nEnergetic(cara) ::: Cara is energetic.\nLong(cara) ::: Cara is long.\n¬Long(christina) ::: Christina is not long.\n(∃x (¬Long(x))) → (Wonderful(christina)) ::: If there is someone who is not long, then Christina is wonderful.\n(∃x (Crowded(x) ∧ ¬Angry(x))) → (∀x (¬Long(x))) ::: If someone is both crowded and not angry, then he is not long.\n(∃x (Long(x))) → (¬Crowded(max) ∧ ¬Angry(cara)) ::: If there is someone who is long, then Max is not crowded and Cara is not angry.\n((¬Faithful(lesley))) ↔ (Energetic(dan) ∧ ¬Crowded(lesley)) ::: Lesley being not faithful is equivalent to Dan being energetic and Lesley being not crowded.\n(∃x (Wonderful(x))) → (¬Energetic(dan)) ::: If there is someone who is wonderful, then Dan is not energetic.\n((¬Wonderful(lesley) ∨ Angry(clarence))) → (¬Long(dan)) ::: Lesley being not wonderful or Clarence being angry implies that Dan is not long.\n(∀x (Faithful(x) ∨ ¬Wonderful(x))) → (∀x (¬Long(x))) ::: If someone is faithful or not wonderful, then he is not long.\n(∀x ((Angry(x) ∧ Faithful(x))) → (Energetic(x))) ::: If someone who is angry is also faithful, then he is energetic.\n(¬Crowded(christina)) → (Energetic(christina)) ::: Christina being not crowded implies that Christina is energetic.\n(¬Long(x)) → (Energetic(x) ∧ ¬Wonderful(x)) ::: If someone is not long, then he is both energetic and not wonderful.\n¬Energetic(x)∧¬Wonderful(x)↔Long(x) ::: Someone being neither energetic nor wonderful is equivalent to being long.\n(∀x ((Long(x) ∧ ¬Crowded(x))) ↔ (¬Faithful(x) ∧ ¬Angry(x))) ::: Someone being both long and not crowded is equivalent to being not faithful and not angry.\n",
            "First-Order-Logic Question": "Energetic(lesley) ::: Lesley is energetic."
        },
        "diff": [
            {
                "raw": "(∀x ((¬Energetic(x) ∧ ¬Wonderful(x))) ↔ (Long(x)) ::: Someone being neither energetic nor wonderful is equivalent to being long.",
                "gram": "¬Energetic(x)∧¬Wonderful(x)↔Long(x) ::: Someone being neither energetic nor wonderful is equivalent to being long."
            }
        ],
        "answer": "B",
        "grammar_answer": "A",
        "manual_prog": {
            "First-Order-Logic Rules": "¬Energetic(lesley) ::: Lesley is not energetic.\nCrowded(lesley) ::: Lesley is crowded.\nFaithful(max) ::: Max is faithful.\n¬Faithful(dan) ::: Dan is not faithful.\n¬Energetic(clarence) ::: Clarence is not energetic.\nWonderful(cara) ::: Cara is wonderful.\nAngry(clarence) ::: Clarence is angry.\nLong(max) ::: Max is long.\n¬Angry(christina) ::: Christina is not angry.\nEnergetic(cara) ::: Cara is energetic.\nLong(cara) ::: Cara is long.\n¬Long(christina) ::: Christina is not long.\n(∃x (¬Long(x))) → (Wonderful(christina)) ::: If there is someone who is not long, then Christina is wonderful.\n(∃x (Crowded(x) ∧ ¬Angry(x))) → (∀x (¬Long(x))) ::: If someone is both crowded and not angry, then he is not long.\n(∃x (Long(x))) → (¬Crowded(max) ∧ ¬Angry(cara)) ::: If there is someone who is long, then Max is not crowded and Cara is not angry.\n((¬Faithful(lesley))) ↔ (Energetic(dan) ∧ ¬Crowded(lesley)) ::: Lesley being not faithful is equivalent to Dan being energetic and Lesley being not crowded.\n(∃x (Wonderful(x))) → (¬Energetic(dan)) ::: If there is someone who is wonderful, then Dan is not energetic.\n((¬Wonderful(lesley) ∨ Angry(clarence))) → (¬Long(dan)) ::: Lesley being not wonderful or Clarence being angry implies that Dan is not long.\n(∀x (Faithful(x) ∨ ¬Wonderful(x))) → (∀x (¬Long(x))) ::: If someone is faithful or not wonderful, then he is not long.\n(∀x ((Angry(x) ∧ Faithful(x))) → (Energetic(x))) ::: If someone who is angry is also faithful, then he is energetic.\n(¬Crowded(christina)) → (Energetic(christina)) ::: Christina being not crowded implies that Christina is energetic.\n(¬Long(x)) → (Energetic(x) ∧ ¬Wonderful(x)) ::: If someone is not long, then he is both energetic and not wonderful.\n(∀x ((¬Energetic(x) ∧ ¬Wonderful(x))) ↔ (Long(x))) ::: Someone being neither energetic nor wonderful is equivalent to being long.\n(∀x ((Long(x) ∧ ¬Crowded(x))) ↔ (¬Faithful(x) ∧ ¬Angry(x))) ::: Someone being both long and not crowded is equivalent to being not faithful and not angry.\n",
            "First-Order-Logic Question": "Energetic(lesley) ::: Lesley is energetic."
        },
        "fixed": true
    },
    {
        "id": 783,
        "raw_prog": {
            "First-Order-Logic Rules": "Octagonal(owen) ::: Owen is octagonal.\n¬Sour(molly) ::: Molly is not sour.\n¬Significant(owen) ::: Owen is not significant.\n¬Wild(tristan) ::: Tristan is not wild.\nSignificant(luther) ::: Luther is significant.\n¬Wild(adam) ::: Adam is not wild.\n¬Wonderful(adam) ::: Adam is not wonderful.\nSour(morgan) ::: Morgan is sour.\nSour(tristan) ::: Tristan is sour.\nSour(godwin) ::: Godwin is sour.\nWonderful(owen) ::: Owen is wonderful.\n¬Wild(molly) ::: Molly is not wild.\n(∃x (Putrid(x) ∧ ¬Sour(x))) ↔ ((Octagonal(x) ∧ ¬Wonderful(x))) ::: Someone is putrid and not sour if and only if he is octagonal and not wonderful.\n(¬∃x (¬Significant(x))) → (Significant(owen)) ::: If there is nobody who is not, then Owen is significant.\n(Significant(x)) ↔ (¬Wonderful(x)) ::: Someone is significant if and only if he is not wonderful.\n(∃x (¬Significant(x))) → ((¬Putrid(godwin) ∧ Wild(molly))) ::: If there is at least one people who is not significant, then Godwin is not putrid and Molly is wild.\n((Wonderful(x) ∨ Sour(x))) → (Wild(x)) ::: If someone is wonderful or he is sour, then he is wild.\n(Putrid(owen)) → ((¬Octagonal(molly) ∧ ¬Wonderful(adam))) ::: Owen being putrid implies that Molly is not octagonal and Adam is not wonderful.\n(∀x (¬Sour(x))) → (¬Significant(x)) ::: All not sour people are not significant.\n(¬Significant(x)) → (Wonderful(godwin) ∧ ¬Octagonal(luther)) ::: If everyone is not significant, then Godwin is wonderful and Luther is not octagonal.\n(Wild(x)) → (Wonderful(x)) ::: If someone is wild, then he is wonderful.\n(∃x (Wild(x))) → (Octagonal(godwin) ∧ Sour(morgan)) ::: If there is someone who is wild, then Godwin is octagonal and Morgan is sour.\n(¬Wonderful(x) ∧ ¬Putrid(x)) ↔ (Wild(x)) ::: Someone is not wonderful and not putrid if and only if he is wild.\n((Sour(molly) ∧ ¬Wild(molly))) → (¬Wonderful(owen)) ::: It can be concluded that Owen is not wonderful once knowing that Molly is sour and Molly is not wild.\n",
            "First-Order-Logic Question": "¬Sour(luther) ::: Luther is not sour."
        },
        "gram_prog": {
            "First-Order-Logic Rules": "Octagonal(owen) ::: Owen is octagonal.\n¬Sour(molly) ::: Molly is not sour.\n¬Significant(owen) ::: Owen is not significant.\n¬Wild(tristan) ::: Tristan is not wild.\nSignificant(luther) ::: Luther is significant.\n¬Wild(adam) ::: Adam is not wild.\n¬Wonderful(adam) ::: Adam is not wonderful.\nSour(morgan) ::: Morgan is sour.\nSour(tristan) ::: Tristan is sour.\nSour(godwin) ::: Godwin is sour.\nWonderful(owen) ::: Owen is wonderful.\n¬Wild(molly) ::: Molly is not wild.\n(∃x (Putrid(x) ∧ ¬Sour(x))) ↔ ((Octagonal(x) ∧ ¬Wonderful(x))) ::: Someone is putrid and not sour if and only if he is octagonal and not wonderful.\n¬∃x(¬Significant(x))→Significant(x) ::: If there is nobody who is not, then Owen is significant.\n(Significant(x)) ↔ (¬Wonderful(x)) ::: Someone is significant if and only if he is not wonderful.\n(∃x (¬Significant(x))) → ((¬Putrid(godwin) ∧ Wild(molly))) ::: If there is at least one people who is not significant, then Godwin is not putrid and Molly is wild.\n((Wonderful(x) ∨ Sour(x))) → (Wild(x)) ::: If someone is wonderful or he is sour, then he is wild.\n(Putrid(owen)) → ((¬Octagonal(molly) ∧ ¬Wonderful(adam))) ::: Owen being putrid implies that Molly is not octagonal and Adam is not wonderful.\n(∀x (¬Sour(x))) → (¬Significant(x)) ::: All not sour people are not significant.\n(¬Significant(x)) → (Wonderful(godwin) ∧ ¬Octagonal(luther)) ::: If everyone is not significant, then Godwin is wonderful and Luther is not octagonal.\n(Wild(x)) → (Wonderful(x)) ::: If someone is wild, then he is wonderful.\n(∃x (Wild(x))) → (Octagonal(godwin) ∧ Sour(morgan)) ::: If there is someone who is wild, then Godwin is octagonal and Morgan is sour.\n(¬Wonderful(x) ∧ ¬Putrid(x)) ↔ (Wild(x)) ::: Someone is not wonderful and not putrid if and only if he is wild.\n((Sour(molly) ∧ ¬Wild(molly))) → (¬Wonderful(owen)) ::: It can be concluded that Owen is not wonderful once knowing that Molly is sour and Molly is not wild.\n",
            "First-Order-Logic Question": "¬Sour(luther) ::: Luther is not sour."
        },
        "diff": [
            {
                "raw": "(¬∃x (¬Significant(x))) → (Significant(owen)) ::: If there is nobody who is not, then Owen is significant.",
                "gram": "¬∃x(¬Significant(x))→Significant(x) ::: If there is nobody who is not, then Owen is significant."
            }
        ],
        "answer": "C",
        "grammar_answer": "A",
        "manual_prog": {
            "First-Order-Logic Rules": "Octagonal(owen) ::: Owen is octagonal.\n¬Sour(molly) ::: Molly is not sour.\n¬Significant(owen) ::: Owen is not significant.\n¬Wild(tristan) ::: Tristan is not wild.\nSignificant(luther) ::: Luther is significant.\n¬Wild(adam) ::: Adam is not wild.\n¬Wonderful(adam) ::: Adam is not wonderful.\nSour(morgan) ::: Morgan is sour.\nSour(tristan) ::: Tristan is sour.\nSour(godwin) ::: Godwin is sour.\nWonderful(owen) ::: Owen is wonderful.\n¬Wild(molly) ::: Molly is not wild.\n(∃x (Putrid(x) ∧ ¬Sour(x))) ↔ ((Octagonal(x) ∧ ¬Wonderful(x))) ::: Someone is putrid and not sour if and only if he is octagonal and not wonderful.\n(∃x (¬Significant(x))) → (Significant(owen)) ::: If there is nobody who is not, then Owen is significant.\n(Significant(x)) ↔ (¬Wonderful(x)) ::: Someone is significant if and only if he is not wonderful.\n(∃x (¬Significant(x))) → ((¬Putrid(godwin) ∧ Wild(molly))) ::: If there is at least one people who is not significant, then Godwin is not putrid and Molly is wild.\n((Wonderful(x) ∨ Sour(x))) → (Wild(x)) ::: If someone is wonderful or he is sour, then he is wild.\n(Putrid(owen)) → ((¬Octagonal(molly) ∧ ¬Wonderful(adam))) ::: Owen being putrid implies that Molly is not octagonal and Adam is not wonderful.\n(∀x (¬Sour(x))) → (¬Significant(x)) ::: All not sour people are not significant.\n(¬Significant(x)) → (Wonderful(godwin) ∧ ¬Octagonal(luther)) ::: If everyone is not significant, then Godwin is wonderful and Luther is not octagonal.\n(Wild(x)) → (Wonderful(x)) ::: If someone is wild, then he is wonderful.\n(∃x (Wild(x))) → (Octagonal(godwin) ∧ Sour(morgan)) ::: If there is someone who is wild, then Godwin is octagonal and Morgan is sour.\n(¬Wonderful(x) ∧ ¬Putrid(x)) ↔ (Wild(x)) ::: Someone is not wonderful and not putrid if and only if he is wild.\n((Sour(molly) ∧ ¬Wild(molly))) → (¬Wonderful(owen)) ::: It can be concluded that Owen is not wonderful once knowing that Molly is sour and Molly is not wild.\n",
            "First-Order-Logic Question": "¬Sour(luther) ::: Luther is not sour."
        },
        "fixed": true
    },
    {
        "id": 784,
        "raw_prog": {
            "First-Order-Logic Rules": "Blue(owen) ::: Owen is octagonal.\n¬Sour(molly) ::: Molly is not sour.\n¬Significant(owen) ::: Owen is not significant.\n¬Wild(tristan) ::: Tristan is not wild.\nSignificant(luther) ::: Luther is significant.\n¬Wild(adam) ::: Adam is not wild.\n¬Wonderful(adam) ::: Adam is not wonderful.\nSour(morgan) ::: Morgan is sour.\nSour(tristan) ::: Tristan is sour.\nSour(godwin) ::: Godwin is sour.\nWonderful(owen) ::: Owen is wonderful.\n¬Wild(molly) ::: Molly is not wild.\n(∃x (Putrid(x) ∧ ¬Sour(x))) ↔ ((Octagonal(x) ∧ ¬Wonderful(x))) ::: Someone is putrid and not sour if and only if he is octagonal and not wonderful.\n(¬∃x (¬x)) → (Significant(owen)) ::: If there is nobody who is not, then Owen is significant.\n(Significant(x)) ↔ (¬Wonderful(x)) ::: Someone is significant if and only if he is not wonderful.\n(∃x (¬Significant(x))) → ((¬Putrid(godwin) ∧ Wild(molly))) ::: If there is at least one people who is not significant, then Godwin is not putrid and Molly is wild.\n((Wonderful(x) ∨ Sour(x))) → (Wild(x)) ::: If someone is wonderful or he is sour, then he is wild.\n(Putrid(owen)) → ((¬Octagonal(molly) ∧ ¬Wonderful(adam))) ::: Owen being putrid implies that Molly is not octagonal and Adam is not wonderful.\n(∀x (¬Sour(x))) → (¬Significant(x)) ::: All not sour people are not significant.\n(∀x (¬Significant(x))) → (Wonderful(godwin) ∧ ¬Octagonal(luther)) ::: If everyone is not significant, then Godwin is wonderful and Luther is not octagonal.\n(Wild(x)) → (Wonderful(x)) ::: If someone is wild, then he is wonderful.\n(∃x (Wild(x))) → (Octagonal(godwin) ∧ Sour(morgan)) ::: If there is someone who is wild, then Godwin is octagonal and Morgan is sour.\n(¬Wonderful(x) ∧ ¬Putrid(x)) ↔ (Wild(x)) ::: Someone is not wonderful and not putrid if and only if he is wild.\n((Sour(molly) ∧ ¬Wild(molly))) → (¬Wonderful(owen)) ::: It can be concluded that Owen is not wonderful once knowing that Molly is sour and Molly is not wild.\n",
            "First-Order-Logic Question": "Sour(luther) ::: Luther is sour."
        },
        "gram_prog": {
            "First-Order-Logic Rules": "Blue(owen) ::: Owen is octagonal.\n¬Sour(molly) ::: Molly is not sour.\n¬Significant(owen) ::: Owen is not significant.\n¬Wild(tristan) ::: Tristan is not wild.\nSignificant(luther) ::: Luther is significant.\n¬Wild(adam) ::: Adam is not wild.\n¬Wonderful(adam) ::: Adam is not wonderful.\nSour(morgan) ::: Morgan is sour.\nSour(tristan) ::: Tristan is sour.\nSour(godwin) ::: Godwin is sour.\nWonderful(owen) ::: Owen is wonderful.\n¬Wild(molly) ::: Molly is not wild.\n(∃x (Putrid(x) ∧ ¬Sour(x))) ↔ ((Octagonal(x) ∧ ¬Wonderful(x))) ::: Someone is putrid and not sour if and only if he is octagonal and not wonderful.\n¬∃x(¬(¬(Serious(x)))) ::: If there is nobody who is not, then Owen is significant.\n(Significant(x)) ↔ (¬Wonderful(x)) ::: Someone is significant if and only if he is not wonderful.\n(∃x (¬Significant(x))) → ((¬Putrid(godwin) ∧ Wild(molly))) ::: If there is at least one people who is not significant, then Godwin is not putrid and Molly is wild.\n((Wonderful(x) ∨ Sour(x))) → (Wild(x)) ::: If someone is wonderful or he is sour, then he is wild.\n(Putrid(owen)) → ((¬Octagonal(molly) ∧ ¬Wonderful(adam))) ::: Owen being putrid implies that Molly is not octagonal and Adam is not wonderful.\n(∀x (¬Sour(x))) → (¬Significant(x)) ::: All not sour people are not significant.\n(∀x (¬Significant(x))) → (Wonderful(godwin) ∧ ¬Octagonal(luther)) ::: If everyone is not significant, then Godwin is wonderful and Luther is not octagonal.\n(Wild(x)) → (Wonderful(x)) ::: If someone is wild, then he is wonderful.\n(∃x (Wild(x))) → (Octagonal(godwin) ∧ Sour(morgan)) ::: If there is someone who is wild, then Godwin is octagonal and Morgan is sour.\n(¬Wonderful(x) ∧ ¬Putrid(x)) ↔ (Wild(x)) ::: Someone is not wonderful and not putrid if and only if he is wild.\n((Sour(molly) ∧ ¬Wild(molly))) → (¬Wonderful(owen)) ::: It can be concluded that Owen is not wonderful once knowing that Molly is sour and Molly is not wild.\n",
            "First-Order-Logic Question": "Sour(luther) ::: Luther is sour."
        },
        "diff": [
            {
                "raw": "(¬∃x (¬x)) → (Significant(owen)) ::: If there is nobody who is not, then Owen is significant.",
                "gram": "¬∃x(¬(¬(Serious(x)))) ::: If there is nobody who is not, then Owen is significant."
            }
        ],
        "answer": "C",
        "grammar_answer": "A",
        "manual_prog": {
            "First-Order-Logic Rules": "Blue(owen) ::: Owen is octagonal.\n¬Sour(molly) ::: Molly is not sour.\n¬Significant(owen) ::: Owen is not significant.\n¬Wild(tristan) ::: Tristan is not wild.\nSignificant(luther) ::: Luther is significant.\n¬Wild(adam) ::: Adam is not wild.\n¬Wonderful(adam) ::: Adam is not wonderful.\nSour(morgan) ::: Morgan is sour.\nSour(tristan) ::: Tristan is sour.\nSour(godwin) ::: Godwin is sour.\nWonderful(owen) ::: Owen is wonderful.\n¬Wild(molly) ::: Molly is not wild.\n(∃x (Putrid(x) ∧ ¬Sour(x))) ↔ ((Octagonal(x) ∧ ¬Wonderful(x))) ::: Someone is putrid and not sour if and only if he is octagonal and not wonderful.\n(∃x (¬Significant(x))) → (Significant(owen)) ::: If there is nobody who is not, then Owen is significant.\n(Significant(x)) ↔ (¬Wonderful(x)) ::: Someone is significant if and only if he is not wonderful.\n(∃x (¬Significant(x))) → ((¬Putrid(godwin) ∧ Wild(molly))) ::: If there is at least one people who is not significant, then Godwin is not putrid and Molly is wild.\n((Wonderful(x) ∨ Sour(x))) → (Wild(x)) ::: If someone is wonderful or he is sour, then he is wild.\n(Putrid(owen)) → ((¬Octagonal(molly) ∧ ¬Wonderful(adam))) ::: Owen being putrid implies that Molly is not octagonal and Adam is not wonderful.\n(∀x (¬Sour(x))) → (¬Significant(x)) ::: All not sour people are not significant.\n(∀x (¬Significant(x))) → (Wonderful(godwin) ∧ ¬Octagonal(luther)) ::: If everyone is not significant, then Godwin is wonderful and Luther is not octagonal.\n(Wild(x)) → (Wonderful(x)) ::: If someone is wild, then he is wonderful.\n(∃x (Wild(x))) → (Octagonal(godwin) ∧ Sour(morgan)) ::: If there is someone who is wild, then Godwin is octagonal and Morgan is sour.\n(¬Wonderful(x) ∧ ¬Putrid(x)) ↔ (Wild(x)) ::: Someone is not wonderful and not putrid if and only if he is wild.\n((Sour(molly) ∧ ¬Wild(molly))) → (¬Wonderful(owen)) ::: It can be concluded that Owen is not wonderful once knowing that Molly is sour and Molly is not wild.\n",
            "First-Order-Logic Question": "Sour(luther) ::: Luther is sour."
        },
        "fixed": true
    },
    {
        "id": 785,
        "raw_prog": {
            "First-Order-Logic Rules": "Blue(owen) ::: Owen is octagonal.\n¬Sour(molly) ::: Molly is not sour.\n¬Significant(owen) ::: Owen is not significant.\n¬Wild(tristan) ::: Tristan is not wild.\nSignificant(luther) ::: Luther is significant.\n¬Wild(adam) ::: Adam is not wild.\n¬Wonderful(adam) ::: Adam is not wonderful.\nSour(morgan) ::: Morgan is sour.\nSour(tristan) ::: Tristan is sour.\nSour(godwin) ::: Godwin is sour.\nWonderful(owen) ::: Owen is wonderful.\n¬Wild(molly) ::: Molly is not wild.\n(∃x (Putrid(x) ∧ ¬Sour(x))) ↔ ((Octagonal(x) ∧ ¬Wonderful(x))) ::: Someone is putrid and not sour if and only if he is octagonal and not wonderful.\n(¬¬∃x (¬x)) → (Significant(owen)) ::: If there is nobody who is not, then Owen is significant.\n(Significant(x)) ↔ (¬Wonderful(x)) ::: Someone is significant if and only if he is not wonderful.\n(∃x (¬Significant(x))) → ((¬Putrid(godwin) ∧ Wild(molly))) ::: If there is at least one people who is not significant, then Godwin is not putrid and Molly is wild.\n((Wonderful(x) ∨ Sour(x))) → (Wild(x)) ::: If someone is wonderful or he is sour, then he is wild.\n(Putrid(owen)) → ((¬Octagonal(molly) ∧ ¬Wonderful(adam))) ::: Owen being putrid implies that Molly is not octagonal and Adam is not wonderful.\n(∀x (¬Sour(x))) → (¬Significant(x)) ::: All not sour people are not significant.\n(∀x (¬Significant(x))) → (Wonderful(godwin) ∧ ¬Octagonal(luther)) ::: If everyone is not significant, then Godwin is wonderful and Luther is not octagonal.\n(Wild(x)) → (Wonderful(x)) ::: If someone is wild, then he is wonderful.\n(∃x (Wild(x))) → (Octagonal(godwin) ∧ Sour(morgan)) ::: If there is someone who is wild, then Godwin is octagonal and Morgan is sour.\n(¬Wonderful(x) ∧ ¬Putrid(x)) ↔ (Wild(x)) ::: Someone is not wonderful and not putrid if and only if he is wild.\n((¬Sour(molly) ∧ ¬Wild(molly))) → (¬Wonderful(owen)) ::: It can be concluded that Owen is not wonderful once knowing that Molly is sour and Molly is not wild.\n",
            "First-Order-Logic Question": "¬Sour(morgan) ::: Morgan is not sour."
        },
        "gram_prog": {
            "First-Order-Logic Rules": "Blue(owen) ::: Owen is octagonal.\n¬Sour(molly) ::: Molly is not sour.\n¬Significant(owen) ::: Owen is not significant.\n¬Wild(tristan) ::: Tristan is not wild.\nSignificant(luther) ::: Luther is significant.\n¬Wild(adam) ::: Adam is not wild.\n¬Wonderful(adam) ::: Adam is not wonderful.\nSour(morgan) ::: Morgan is sour.\nSour(tristan) ::: Tristan is sour.\nSour(godwin) ::: Godwin is sour.\nWonderful(owen) ::: Owen is wonderful.\n¬Wild(molly) ::: Molly is not wild.\n(∃x (Putrid(x) ∧ ¬Sour(x))) ↔ ((Octagonal(x) ∧ ¬Wonderful(x))) ::: Someone is putrid and not sour if and only if he is octagonal and not wonderful.\n¬¬∃x(¬(¬(¬Serious(x)))) ::: If there is nobody who is not, then Owen is significant.\n(Significant(x)) ↔ (¬Wonderful(x)) ::: Someone is significant if and only if he is not wonderful.\n(∃x (¬Significant(x))) → ((¬Putrid(godwin) ∧ Wild(molly))) ::: If there is at least one people who is not significant, then Godwin is not putrid and Molly is wild.\n((Wonderful(x) ∨ Sour(x))) → (Wild(x)) ::: If someone is wonderful or he is sour, then he is wild.\n(Putrid(owen)) → ((¬Octagonal(molly) ∧ ¬Wonderful(adam))) ::: Owen being putrid implies that Molly is not octagonal and Adam is not wonderful.\n(∀x (¬Sour(x))) → (¬Significant(x)) ::: All not sour people are not significant.\n(∀x (¬Significant(x))) → (Wonderful(godwin) ∧ ¬Octagonal(luther)) ::: If everyone is not significant, then Godwin is wonderful and Luther is not octagonal.\n(Wild(x)) → (Wonderful(x)) ::: If someone is wild, then he is wonderful.\n(∃x (Wild(x))) → (Octagonal(godwin) ∧ Sour(morgan)) ::: If there is someone who is wild, then Godwin is octagonal and Morgan is sour.\n(¬Wonderful(x) ∧ ¬Putrid(x)) ↔ (Wild(x)) ::: Someone is not wonderful and not putrid if and only if he is wild.\n((¬Sour(molly) ∧ ¬Wild(molly))) → (¬Wonderful(owen)) ::: It can be concluded that Owen is not wonderful once knowing that Molly is sour and Molly is not wild.\n",
            "First-Order-Logic Question": "¬Sour(morgan) ::: Morgan is not sour."
        },
        "diff": [
            {
                "raw": "(¬¬∃x (¬x)) → (Significant(owen)) ::: If there is nobody who is not, then Owen is significant.",
                "gram": "¬¬∃x(¬(¬(¬Serious(x)))) ::: If there is nobody who is not, then Owen is significant."
            }
        ],
        "answer": "B",
        "grammar_answer": "A",
        "manual_prog": {
            "First-Order-Logic Rules": "Blue(owen) ::: Owen is octagonal.\n¬Sour(molly) ::: Molly is not sour.\n¬Significant(owen) ::: Owen is not significant.\n¬Wild(tristan) ::: Tristan is not wild.\nSignificant(luther) ::: Luther is significant.\n¬Wild(adam) ::: Adam is not wild.\n¬Wonderful(adam) ::: Adam is not wonderful.\nSour(morgan) ::: Morgan is sour.\nSour(tristan) ::: Tristan is sour.\nSour(godwin) ::: Godwin is sour.\nWonderful(owen) ::: Owen is wonderful.\n¬Wild(molly) ::: Molly is not wild.\n(∃x (Putrid(x) ∧ ¬Sour(x))) ↔ ((Octagonal(x) ∧ ¬Wonderful(x))) ::: Someone is putrid and not sour if and only if he is octagonal and not wonderful.\n(∃x (¬Significant(x))) → (Significant(owen)) ::: If there is nobody who is not, then Owen is significant.\n(Significant(x)) ↔ (¬Wonderful(x)) ::: Someone is significant if and only if he is not wonderful.\n(∃x (¬Significant(x))) → ((¬Putrid(godwin) ∧ Wild(molly))) ::: If there is at least one people who is not significant, then Godwin is not putrid and Molly is wild.\n((Wonderful(x) ∨ Sour(x))) → (Wild(x)) ::: If someone is wonderful or he is sour, then he is wild.\n(Putrid(owen)) → ((¬Octagonal(molly) ∧ ¬Wonderful(adam))) ::: Owen being putrid implies that Molly is not octagonal and Adam is not wonderful.\n(∀x (¬Sour(x))) → (¬Significant(x)) ::: All not sour people are not significant.\n(∀x (¬Significant(x))) → (Wonderful(godwin) ∧ ¬Octagonal(luther)) ::: If everyone is not significant, then Godwin is wonderful and Luther is not octagonal.\n(Wild(x)) → (Wonderful(x)) ::: If someone is wild, then he is wonderful.\n(∃x (Wild(x))) → (Octagonal(godwin) ∧ Sour(morgan)) ::: If there is someone who is wild, then Godwin is octagonal and Morgan is sour.\n(¬Wonderful(x) ∧ ¬Putrid(x)) ↔ (Wild(x)) ::: Someone is not wonderful and not putrid if and only if he is wild.\n((¬Sour(molly) ∧ ¬Wild(molly))) → (¬Wonderful(owen)) ::: It can be concluded that Owen is not wonderful once knowing that Molly is sour and Molly is not wild.\n",
            "First-Order-Logic Question": "¬Sour(morgan) ::: Morgan is not sour."
        },
        "fixed": true
    },
    {
        "id": 786,
        "raw_prog": {
            "First-Order-Logic Rules": "Octagonal(owen) ::: Owen is octagonal.\n¬Sour(molly) ::: Molly is not sour.\n¬Significant(owen) ::: Owen is not significant.\n¬Wild(tristan) ::: Tristan is not wild.\nSignificant(luther) ::: Luther is significant.\n¬Wild(adam) ::: Adam is not wild.\n¬Wonderful(adam) ::: Adam is not wonderful.\nSour(morgan) ::: Morgan is sour.\nSour(tristan) ::: Tristan is sour.\nSour(godwin) ::: Godwin is sour.\nWonderful(owen) ::: Owen is wonderful.\n¬Wild(molly) ::: Molly is not wild.\n(∃x (Putrid(x) ∧ ¬Sour(x))) ↔ ((Octagonal(x) ∧ ¬Wonderful(x))) ::: Someone is putrid and not sour if and only if he is octagonal and not wonderful.\n(¬∃x (¬Significant(x))) → (Significant(owen)) ::: If there is nobody who is not, then Owen is significant.\n(∀x (Significant(x))) ↔ (∀x (¬Wonderful(x))) ::: Someone is significant if and only if he is not wonderful.\n(∃x (¬Significant(x))) → ((¬Putrid(godwin) ∧ Wild(molly))) ::: If there is at least one people who is not significant, then Godwin is not putrid and Molly is wild.\n(∀x (Wonderful(x) ∨ Sour(x))) → (Wild(x)) ::: If someone is wonderful or he is sour, then he is wild.\n(Putrid(owen)) → ((¬Octagonal(molly) ∧ ¬Wonderful(adam))) ::: Owen being putrid implies that Molly is not octagonal and Adam is not wonderful.\n(∀x (¬Sour(x))) → (∀x (¬Significant(x))) ::: All not sour people are not significant.\n(∀x (¬Significant(x))) → (Wonderful(godwin) ∧ ¬Octagonal(luther)) ::: If everyone is not significant, then Godwin is wonderful and Luther is not octagonal.\n(∀x (Wild(x))) → (Wonderful(x)) ::: If someone is wild, then he is wonderful.\n(∃x (Wild(x))) → (Octagonal(godwin) ∧ Sour(morgan)) ::: If there is someone who is wild, then Godwin is octagonal and Morgan is sour.\n(∀x (¬Wonderful(x) ∧ ¬Putrid(x))) ↔ (Wild(x)) ::: Someone is not wonderful and not putrid if and only if he is wild.\n(Wild(molly) ∧ ¬Sour(molly)) → (¬Wonderful(owen)) ::: It can be concluded that Owen is not wonderful once knowing that Molly is sour and Molly is not wild.\n",
            "First-Order-Logic Question": "¬Sour(adam) ::: Adam is not sour."
        },
        "gram_prog": {
            "First-Order-Logic Rules": "Octagonal(owen) ::: Owen is octagonal.\n¬Sour(molly) ::: Molly is not sour.\n¬Significant(owen) ::: Owen is not significant.\n¬Wild(tristan) ::: Tristan is not wild.\nSignificant(luther) ::: Luther is significant.\n¬Wild(adam) ::: Adam is not wild.\n¬Wonderful(adam) ::: Adam is not wonderful.\nSour(morgan) ::: Morgan is sour.\nSour(tristan) ::: Tristan is sour.\nSour(godwin) ::: Godwin is sour.\nWonderful(owen) ::: Owen is wonderful.\n¬Wild(molly) ::: Molly is not wild.\n(∃x (Putrid(x) ∧ ¬Sour(x))) ↔ ((Octagonal(x) ∧ ¬Wonderful(x))) ::: Someone is putrid and not sour if and only if he is octagonal and not wonderful.\n¬∃x(¬Significant(x))→Significant(x) ::: If there is nobody who is not, then Owen is significant.\n(∀x (Significant(x))) ↔ (∀x (¬Wonderful(x))) ::: Someone is significant if and only if he is not wonderful.\n(∃x (¬Significant(x))) → ((¬Putrid(godwin) ∧ Wild(molly))) ::: If there is at least one people who is not significant, then Godwin is not putrid and Molly is wild.\n(∀x (Wonderful(x) ∨ Sour(x))) → (Wild(x)) ::: If someone is wonderful or he is sour, then he is wild.\n(Putrid(owen)) → ((¬Octagonal(molly) ∧ ¬Wonderful(adam))) ::: Owen being putrid implies that Molly is not octagonal and Adam is not wonderful.\n(∀x (¬Sour(x))) → (∀x (¬Significant(x))) ::: All not sour people are not significant.\n(∀x (¬Significant(x))) → (Wonderful(godwin) ∧ ¬Octagonal(luther)) ::: If everyone is not significant, then Godwin is wonderful and Luther is not octagonal.\n(∀x (Wild(x))) → (Wonderful(x)) ::: If someone is wild, then he is wonderful.\n(∃x (Wild(x))) → (Octagonal(godwin) ∧ Sour(morgan)) ::: If there is someone who is wild, then Godwin is octagonal and Morgan is sour.\n(∀x (¬Wonderful(x) ∧ ¬Putrid(x))) ↔ (Wild(x)) ::: Someone is not wonderful and not putrid if and only if he is wild.\n(Wild(molly) ∧ ¬Sour(molly)) → (¬Wonderful(owen)) ::: It can be concluded that Owen is not wonderful once knowing that Molly is sour and Molly is not wild.\n",
            "First-Order-Logic Question": "¬Sour(adam) ::: Adam is not sour."
        },
        "diff": [
            {
                "raw": "(¬∃x (¬Significant(x))) → (Significant(owen)) ::: If there is nobody who is not, then Owen is significant.",
                "gram": "¬∃x(¬Significant(x))→Significant(x) ::: If there is nobody who is not, then Owen is significant."
            }
        ],
        "answer": "C",
        "grammar_answer": "A",
        "manual_prog": {
            "First-Order-Logic Rules": "Octagonal(owen) ::: Owen is octagonal.\n¬Sour(molly) ::: Molly is not sour.\n¬Significant(owen) ::: Owen is not significant.\n¬Wild(tristan) ::: Tristan is not wild.\nSignificant(luther) ::: Luther is significant.\n¬Wild(adam) ::: Adam is not wild.\n¬Wonderful(adam) ::: Adam is not wonderful.\nSour(morgan) ::: Morgan is sour.\nSour(tristan) ::: Tristan is sour.\nSour(godwin) ::: Godwin is sour.\nWonderful(owen) ::: Owen is wonderful.\n¬Wild(molly) ::: Molly is not wild.\n(∃x (Putrid(x) ∧ ¬Sour(x))) ↔ ((Octagonal(x) ∧ ¬Wonderful(x))) ::: Someone is putrid and not sour if and only if he is octagonal and not wonderful.\n(∃x (¬Significant(x))) → (Significant(owen)) ::: If there is nobody who is not, then Owen is significant.\n(∀x (Significant(x))) ↔ (∀x (¬Wonderful(x))) ::: Someone is significant if and only if he is not wonderful.\n(∃x (¬Significant(x))) → ((¬Putrid(godwin) ∧ Wild(molly))) ::: If there is at least one people who is not significant, then Godwin is not putrid and Molly is wild.\n(∀x (Wonderful(x) ∨ Sour(x))) → (Wild(x)) ::: If someone is wonderful or he is sour, then he is wild.\n(Putrid(owen)) → ((¬Octagonal(molly) ∧ ¬Wonderful(adam))) ::: Owen being putrid implies that Molly is not octagonal and Adam is not wonderful.\n(∀x (¬Sour(x))) → (∀x (¬Significant(x))) ::: All not sour people are not significant.\n(∀x (¬Significant(x))) → (Wonderful(godwin) ∧ ¬Octagonal(luther)) ::: If everyone is not significant, then Godwin is wonderful and Luther is not octagonal.\n(∀x (Wild(x))) → (Wonderful(x)) ::: If someone is wild, then he is wonderful.\n(∃x (Wild(x))) → (Octagonal(godwin) ∧ Sour(morgan)) ::: If there is someone who is wild, then Godwin is octagonal and Morgan is sour.\n(∀x (¬Wonderful(x) ∧ ¬Putrid(x))) ↔ (Wild(x)) ::: Someone is not wonderful and not putrid if and only if he is wild.\n(Wild(molly) ∧ ¬Sour(molly)) → (¬Wonderful(owen)) ::: It can be concluded that Owen is not wonderful once knowing that Molly is sour and Molly is not wild.\n",
            "First-Order-Logic Question": "¬Sour(adam) ::: Adam is not sour."
        },
        "fixed": true
    },
    {
        "id": 787,
        "raw_prog": {
            "First-Order-Logic Rules": "Octagonal(owen) ::: Owen is octagonal.\n¬Sour(molly) ::: Molly is not sour.\n¬Significant(owen) ::: Owen is not significant.\n¬Wild(tristan) ::: Tristan is not wild.\nSignificant(luther) ::: Luther is significant.\n¬Wild(adam) ::: Adam is not wild.\n¬Wonderful(adam) ::: Adam is not wonderful.\nSour(morgan) ::: Morgan is sour.\nSour(tristan) ::: Tristan is sour.\nSour(godwin) ::: Godwin is sour.\nWonderful(owen) ::: Owen is wonderful.\n¬Wild(molly) ::: Molly is not wild.\n(∃x (Putrid(x) ∧ ¬Sour(x))) ↔ ((Octagonal(x) ∧ ¬Wonderful(x))) ::: Someone is putrid and not sour if and only if he is octagonal and not wonderful.\n(¬∃x (¬Significant(x))) → (Significant(owen)) ::: If there is nobody who is not, then Owen is significant.\n(∀x (Significant(x))) ↔ (¬Wonderful(x)) ::: Someone is significant if and only if he is not wonderful.\n(∃x (¬Significant(x))) → ((¬Putrid(godwin) ∧ Wild(molly))) ::: If there is at least one people who is not significant, then Godwin is not putrid and Molly is wild.\n(∀x (Wonderful(x) ∨ Sour(x))) → (Wild(x)) ::: If someone is wonderful or he is sour, then he is wild.\n(Putrid(owen)) → ((¬Octagonal(molly) ∧ ¬Wonderful(adam))) ::: Owen being putrid implies that Molly is not octagonal and Adam is not wonderful.\n(∀x (¬Sour(x))) → (¬Significant(x)) ::: All not sour people are not significant.\n(∀x (¬Significant(x))) → (Wonderful(godwin) ∧ ¬Octagonal(luther)) ::: If everyone is not significant, then Godwin is wonderful and Luther is not octagonal.\n(Wild(x)) → (Wonderful(x)) ::: If someone is wild, then he is wonderful.\n(∃x (Wild(x))) → (Octagonal(godwin) ∧ Sour(morgan)) ::: If there is someone who is wild, then Godwin is octagonal and Morgan is sour.\n(¬∃x (Wonderful(x) ∧ ¬Putrid(x))) ↔ (Wild(x)) ::: Someone is not wonderful and not putrid if and only if he is wild.\n(¬Wonderful(owen)) ↔ (Sour(molly) ∧ ¬Wild(molly)) ::: It can be concluded that Owen is not wonderful once knowing that Molly is sour and Molly is not wild.\n",
            "First-Order-Logic Question": "¬Octagonal(morgan) ::: Morgan is not octagonal."
        },
        "gram_prog": {
            "First-Order-Logic Rules": "Octagonal(owen) ::: Owen is octagonal.\n¬Sour(molly) ::: Molly is not sour.\n¬Significant(owen) ::: Owen is not significant.\n¬Wild(tristan) ::: Tristan is not wild.\nSignificant(luther) ::: Luther is significant.\n¬Wild(adam) ::: Adam is not wild.\n¬Wonderful(adam) ::: Adam is not wonderful.\nSour(morgan) ::: Morgan is sour.\nSour(tristan) ::: Tristan is sour.\nSour(godwin) ::: Godwin is sour.\nWonderful(owen) ::: Owen is wonderful.\n¬Wild(molly) ::: Molly is not wild.\n(∃x (Putrid(x) ∧ ¬Sour(x))) ↔ ((Octagonal(x) ∧ ¬Wonderful(x))) ::: Someone is putrid and not sour if and only if he is octagonal and not wonderful.\n¬∃x(¬Serious(x))→(Serious(x)) ::: If there is nobody who is not, then Owen is significant.\n(∀x (Significant(x))) ↔ (¬Wonderful(x)) ::: Someone is significant if and only if he is not wonderful.\n(∃x (¬Significant(x))) → ((¬Putrid(godwin) ∧ Wild(molly))) ::: If there is at least one people who is not significant, then Godwin is not putrid and Molly is wild.\n(∀x (Wonderful(x) ∨ Sour(x))) → (Wild(x)) ::: If someone is wonderful or he is sour, then he is wild.\n(Putrid(owen)) → ((¬Octagonal(molly) ∧ ¬Wonderful(adam))) ::: Owen being putrid implies that Molly is not octagonal and Adam is not wonderful.\n(∀x (¬Sour(x))) → (¬Significant(x)) ::: All not sour people are not significant.\n(∀x (¬Significant(x))) → (Wonderful(godwin) ∧ ¬Octagonal(luther)) ::: If everyone is not significant, then Godwin is wonderful and Luther is not octagonal.\n(Wild(x)) → (Wonderful(x)) ::: If someone is wild, then he is wonderful.\n(∃x (Wild(x))) → (Octagonal(godwin) ∧ Sour(morgan)) ::: If there is someone who is wild, then Godwin is octagonal and Morgan is sour.\n¬∃x(Serious(x)∧¬(Fresh(x))) ::: Someone is not wonderful and not putrid if and only if he is wild.\n(¬Wonderful(owen)) ↔ (Sour(molly) ∧ ¬Wild(molly)) ::: It can be concluded that Owen is not wonderful once knowing that Molly is sour and Molly is not wild.\n",
            "First-Order-Logic Question": "¬Octagonal(morgan) ::: Morgan is not octagonal."
        },
        "diff": [
            {
                "raw": "(¬∃x (¬Significant(x))) → (Significant(owen)) ::: If there is nobody who is not, then Owen is significant.",
                "gram": "¬∃x(¬Serious(x))→(Serious(x)) ::: If there is nobody who is not, then Owen is significant."
            },
            {
                "raw": "(¬∃x (Wonderful(x) ∧ ¬Putrid(x))) ↔ (Wild(x)) ::: Someone is not wonderful and not putrid if and only if he is wild.",
                "gram": "¬∃x(Serious(x)∧¬(Fresh(x))) ::: Someone is not wonderful and not putrid if and only if he is wild."
            }
        ],
        "answer": "C",
        "grammar_answer": "A",
        "manual_prog": {
            "First-Order-Logic Rules": "Octagonal(owen) ::: Owen is octagonal.\n¬Sour(molly) ::: Molly is not sour.\n¬Significant(owen) ::: Owen is not significant.\n¬Wild(tristan) ::: Tristan is not wild.\nSignificant(luther) ::: Luther is significant.\n¬Wild(adam) ::: Adam is not wild.\n¬Wonderful(adam) ::: Adam is not wonderful.\nSour(morgan) ::: Morgan is sour.\nSour(tristan) ::: Tristan is sour.\nSour(godwin) ::: Godwin is sour.\nWonderful(owen) ::: Owen is wonderful.\n¬Wild(molly) ::: Molly is not wild.\n(∃x (Putrid(x) ∧ ¬Sour(x))) ↔ ((Octagonal(x) ∧ ¬Wonderful(x))) ::: Someone is putrid and not sour if and only if he is octagonal and not wonderful.\n(∃x (¬Significant(x))) → (Significant(owen)) ::: If there is nobody who is not, then Owen is significant.\n(∀x (Significant(x))) ↔ (¬Wonderful(x)) ::: Someone is significant if and only if he is not wonderful.\n(∃x (¬Significant(x))) → ((¬Putrid(godwin) ∧ Wild(molly))) ::: If there is at least one people who is not significant, then Godwin is not putrid and Molly is wild.\n(∀x (Wonderful(x) ∨ Sour(x))) → (Wild(x)) ::: If someone is wonderful or he is sour, then he is wild.\n(Putrid(owen)) → ((¬Octagonal(molly) ∧ ¬Wonderful(adam))) ::: Owen being putrid implies that Molly is not octagonal and Adam is not wonderful.\n(∀x (¬Sour(x))) → (¬Significant(x)) ::: All not sour people are not significant.\n(∀x (¬Significant(x))) → (Wonderful(godwin) ∧ ¬Octagonal(luther)) ::: If everyone is not significant, then Godwin is wonderful and Luther is not octagonal.\n(Wild(x)) → (Wonderful(x)) ::: If someone is wild, then he is wonderful.\n(∃x (Wild(x))) → (Octagonal(godwin) ∧ Sour(morgan)) ::: If there is someone who is wild, then Godwin is octagonal and Morgan is sour.\n(∀x (Wonderful(x) ∧ ¬Putrid(x))) ↔ (Wild(x)) ::: Someone is not wonderful and not putrid if and only if he is wild.\n(¬Wonderful(owen)) ↔ (Sour(molly) ∧ ¬Wild(molly)) ::: It can be concluded that Owen is not wonderful once knowing that Molly is sour and Molly is not wild.\n",
            "First-Order-Logic Question": "¬Octagonal(morgan) ::: Morgan is not octagonal."
        },
        "fixed": true
    },
    {
        "id": 788,
        "raw_prog": {
            "First-Order-Logic Rules": "Octagonal(owen) ::: Owen is octagonal.\n¬Sour(molly) ::: Molly is not sour.\n¬Significant(owen) ::: Owen is not significant.\n¬Wild(tristan) ::: Tristan is not wild.\nSignificant(luther) ::: Luther is significant.\n¬Wild(adam) ::: Adam is not wild.\n¬Wonderful(adam) ::: Adam is not wonderful.\nSour(morgan) ::: Morgan is sour.\nSour(tristan) ::: Tristan is sour.\nSour(godwin) ::: Godwin is sour.\nWonderful(owen) ::: Owen is wonderful.\n¬Wild(molly) ::: Molly is not wild.\n(∃x (Putrid(x) ∧ ¬Sour(x))) ↔ ((Octagonal(x) ∧ ¬Wonderful(x))) ::: Someone is putrid and not sour if and only if he is octagonal and not wonderful.\n(¬∃x (¬x)) → (Significant(owen)) ::: If there is nobody who is not, then Owen is significant.\n(∀x (Significant(x))) ↔ (∀x (¬Wonderful(x))) ::: Someone is significant if and only if he is not wonderful.\n(∃x (¬Significant(x))) → ((¬Putrid(godwin) ∧ Wild(molly))) ::: If there is at least one people who is not significant, then Godwin is not putrid and Molly is wild.\n(∀x (Wonderful(x) ∨ Sour(x))) → (∀x (Wild(x))) ::: If someone is wonderful or he is sour, then he is wild.\n(Putrid(owen)) → ((¬Octagonal(molly) ∧ ¬Wonderful(adam))) ::: Owen being putrid implies that Molly is not octagonal and Adam is not wonderful.\n(∀x (¬Sour(x))) → (∀x (¬Significant(x))) ::: All not sour people are not significant.\n(∀x (¬Significant(x))) → (Wonderful(godwin) ∧ ¬Octagonal(luther)) ::: If everyone is not significant, then Godwin is wonderful and Luther is not octagonal.\n(∀x (Wild(x))) → (Wonderful(x)) ::: If someone is wild, then he is wonderful.\n(∃x (Wild(x))) → (Octagonal(godwin) ∧ Sour(morgan)) ::: If there is someone who is wild, then Godwin is octagonal and Morgan is sour.\n(¬Wonderful(x) ∧ ¬Putrid(x)) ↔ (Wild(x)) ::: Someone is not wonderful and not putrid if and only if he is wild.\n(¬Wonderful(owen)) → ((Sour(molly) ∧ ¬Wild(molly))) ::: It can be concluded that Owen is not wonderful once knowing that Molly is sour and Molly is not wild.\n",
            "First-Order-Logic Question": "¬Octagonal(tristan) ::: Tristan is not octagonal."
        },
        "gram_prog": {
            "First-Order-Logic Rules": "Octagonal(owen) ::: Owen is octagonal.\n¬Sour(molly) ::: Molly is not sour.\n¬Significant(owen) ::: Owen is not significant.\n¬Wild(tristan) ::: Tristan is not wild.\nSignificant(luther) ::: Luther is significant.\n¬Wild(adam) ::: Adam is not wild.\n¬Wonderful(adam) ::: Adam is not wonderful.\nSour(morgan) ::: Morgan is sour.\nSour(tristan) ::: Tristan is sour.\nSour(godwin) ::: Godwin is sour.\nWonderful(owen) ::: Owen is wonderful.\n¬Wild(molly) ::: Molly is not wild.\n(∃x (Putrid(x) ∧ ¬Sour(x))) ↔ ((Octagonal(x) ∧ ¬Wonderful(x))) ::: Someone is putrid and not sour if and only if he is octagonal and not wonderful.\n¬∃x(¬(¬(Octagonal(x)))) ::: If there is nobody who is not, then Owen is significant.\n(∀x (Significant(x))) ↔ (∀x (¬Wonderful(x))) ::: Someone is significant if and only if he is not wonderful.\n(∃x (¬Significant(x))) → ((¬Putrid(godwin) ∧ Wild(molly))) ::: If there is at least one people who is not significant, then Godwin is not putrid and Molly is wild.\n(∀x (Wonderful(x) ∨ Sour(x))) → (∀x (Wild(x))) ::: If someone is wonderful or he is sour, then he is wild.\n(Putrid(owen)) → ((¬Octagonal(molly) ∧ ¬Wonderful(adam))) ::: Owen being putrid implies that Molly is not octagonal and Adam is not wonderful.\n(∀x (¬Sour(x))) → (∀x (¬Significant(x))) ::: All not sour people are not significant.\n(∀x (¬Significant(x))) → (Wonderful(godwin) ∧ ¬Octagonal(luther)) ::: If everyone is not significant, then Godwin is wonderful and Luther is not octagonal.\n(∀x (Wild(x))) → (Wonderful(x)) ::: If someone is wild, then he is wonderful.\n(∃x (Wild(x))) → (Octagonal(godwin) ∧ Sour(morgan)) ::: If there is someone who is wild, then Godwin is octagonal and Morgan is sour.\n(¬Wonderful(x) ∧ ¬Putrid(x)) ↔ (Wild(x)) ::: Someone is not wonderful and not putrid if and only if he is wild.\n(¬Wonderful(owen)) → ((Sour(molly) ∧ ¬Wild(molly))) ::: It can be concluded that Owen is not wonderful once knowing that Molly is sour and Molly is not wild.\n",
            "First-Order-Logic Question": "¬Octagonal(tristan) ::: Tristan is not octagonal."
        },
        "diff": [
            {
                "raw": "(¬∃x (¬x)) → (Significant(owen)) ::: If there is nobody who is not, then Owen is significant.",
                "gram": "¬∃x(¬(¬(Octagonal(x)))) ::: If there is nobody who is not, then Owen is significant."
            }
        ],
        "answer": "C",
        "grammar_answer": "A",
        "manual_prog": {
            "First-Order-Logic Rules": "Octagonal(owen) ::: Owen is octagonal.\n¬Sour(molly) ::: Molly is not sour.\n¬Significant(owen) ::: Owen is not significant.\n¬Wild(tristan) ::: Tristan is not wild.\nSignificant(luther) ::: Luther is significant.\n¬Wild(adam) ::: Adam is not wild.\n¬Wonderful(adam) ::: Adam is not wonderful.\nSour(morgan) ::: Morgan is sour.\nSour(tristan) ::: Tristan is sour.\nSour(godwin) ::: Godwin is sour.\nWonderful(owen) ::: Owen is wonderful.\n¬Wild(molly) ::: Molly is not wild.\n(∃x (Putrid(x) ∧ ¬Sour(x))) ↔ ((Octagonal(x) ∧ ¬Wonderful(x))) ::: Someone is putrid and not sour if and only if he is octagonal and not wonderful.\n(∃x (¬Significant(x))) → (Significant(owen)) ::: If there is nobody who is not, then Owen is significant.\n(∀x (Significant(x))) ↔ (∀x (¬Wonderful(x))) ::: Someone is significant if and only if he is not wonderful.\n(∃x (¬Significant(x))) → ((¬Putrid(godwin) ∧ Wild(molly))) ::: If there is at least one people who is not significant, then Godwin is not putrid and Molly is wild.\n(∀x (Wonderful(x) ∨ Sour(x))) → (∀x (Wild(x))) ::: If someone is wonderful or he is sour, then he is wild.\n(Putrid(owen)) → ((¬Octagonal(molly) ∧ ¬Wonderful(adam))) ::: Owen being putrid implies that Molly is not octagonal and Adam is not wonderful.\n(∀x (¬Sour(x))) → (∀x (¬Significant(x))) ::: All not sour people are not significant.\n(∀x (¬Significant(x))) → (Wonderful(godwin) ∧ ¬Octagonal(luther)) ::: If everyone is not significant, then Godwin is wonderful and Luther is not octagonal.\n(∀x (Wild(x))) → (Wonderful(x)) ::: If someone is wild, then he is wonderful.\n(∃x (Wild(x))) → (Octagonal(godwin) ∧ Sour(morgan)) ::: If there is someone who is wild, then Godwin is octagonal and Morgan is sour.\n(¬Wonderful(x) ∧ ¬Putrid(x)) ↔ (Wild(x)) ::: Someone is not wonderful and not putrid if and only if he is wild.\n(¬Wonderful(owen)) → ((Sour(molly) ∧ ¬Wild(molly))) ::: It can be concluded that Owen is not wonderful once knowing that Molly is sour and Molly is not wild.\n",
            "First-Order-Logic Question": "¬Octagonal(tristan) ::: Tristan is not octagonal."
        },
        "fixed": true
    },
    {
        "id": 789,
        "raw_prog": {
            "First-Order-Logic Rules": "Blue(owen) ::: Owen is octagonal.\n¬Sour(molly) ::: Molly is not sour.\n¬Significant(owen) ::: Owen is not significant.\n¬Wild(tristan) ::: Tristan is not wild.\nSignificant(luther) ::: Luther is significant.\n¬Wild(adam) ::: Adam is not wild.\n¬Wonderful(adam) ::: Adam is not wonderful.\nSour(morgan) ::: Morgan is sour.\nSour(tristan) ::: Tristan is sour.\nSour(godwin) ::: Godwin is sour.\nWonderful(owen) ::: Owen is wonderful.\n¬Wild(molly) ::: Molly is not wild.\n(∃x (Putrid(x) ∧ ¬Sour(x))) ↔ ((Octagonal(x) ∧ ¬Wonderful(x))) ::: Someone is putrid and not sour if and only if he is octagonal and not wonderful.\n(¬∃x (¬Significant(x))) → (Significant(owen)) ::: If there is nobody who is not, then Owen is significant.\n(Significant(x)) ↔ (¬Wonderful(x)) ::: Someone is significant if and only if he is not wonderful.\n(∃x (¬Significant(x))) → ((¬Putrid(godwin) ∧ Wild(molly))) ::: If there is at least one people who is not significant, then Godwin is not putrid and Molly is wild.\n((Wonderful(x) ∨ Sour(x))) → (Wild(x)) ::: If someone is wonderful or he is sour, then he is wild.\n(Putrid(owen)) → ((¬Octagonal(molly) ∧ ¬Wonderful(adam))) ::: Owen being putrid implies that Molly is not octagonal and Adam is not wonderful.\n(∀x (¬Sour(x))) → (¬Significant(x)) ::: All not sour people are not significant.\n(∀x (¬Significant(x))) → (Wonderful(godwin) ∧ ¬Octagonal(luther)) ::: If everyone is not significant, then Godwin is wonderful and Luther is not octagonal.\n(Wild(x)) → (Wonderful(x)) ::: If someone is wild, then he is wonderful.\n(∃x (Wild(x))) → (Octagonal(godwin) ∧ Sour(morgan)) ::: If there is someone who is wild, then Godwin is octagonal and Morgan is sour.\n(¬Wonderful(x) ∧ ¬Putrid(x)) ↔ (Wild(x)) ::: Someone is not wonderful and not putrid if and only if he is wild.\n((Sour(molly) ∧ ¬Wild(molly))) → (¬Wonderful(owen)) ::: It can be concluded that Owen is not wonderful once knowing that Molly is sour and Molly is not wild.\n",
            "First-Order-Logic Question": "¬Significant(morgan) ::: Morgan is not significant."
        },
        "gram_prog": {
            "First-Order-Logic Rules": "Blue(owen) ::: Owen is octagonal.\n¬Sour(molly) ::: Molly is not sour.\n¬Significant(owen) ::: Owen is not significant.\n¬Wild(tristan) ::: Tristan is not wild.\nSignificant(luther) ::: Luther is significant.\n¬Wild(adam) ::: Adam is not wild.\n¬Wonderful(adam) ::: Adam is not wonderful.\nSour(morgan) ::: Morgan is sour.\nSour(tristan) ::: Tristan is sour.\nSour(godwin) ::: Godwin is sour.\nWonderful(owen) ::: Owen is wonderful.\n¬Wild(molly) ::: Molly is not wild.\n(∃x (Putrid(x) ∧ ¬Sour(x))) ↔ ((Octagonal(x) ∧ ¬Wonderful(x))) ::: Someone is putrid and not sour if and only if he is octagonal and not wonderful.\n¬∃x(¬Serious(x))→(Serious(x)) ::: If there is nobody who is not, then Owen is significant.\n(Significant(x)) ↔ (¬Wonderful(x)) ::: Someone is significant if and only if he is not wonderful.\n(∃x (¬Significant(x))) → ((¬Putrid(godwin) ∧ Wild(molly))) ::: If there is at least one people who is not significant, then Godwin is not putrid and Molly is wild.\n((Wonderful(x) ∨ Sour(x))) → (Wild(x)) ::: If someone is wonderful or he is sour, then he is wild.\n(Putrid(owen)) → ((¬Octagonal(molly) ∧ ¬Wonderful(adam))) ::: Owen being putrid implies that Molly is not octagonal and Adam is not wonderful.\n(∀x (¬Sour(x))) → (¬Significant(x)) ::: All not sour people are not significant.\n(∀x (¬Significant(x))) → (Wonderful(godwin) ∧ ¬Octagonal(luther)) ::: If everyone is not significant, then Godwin is wonderful and Luther is not octagonal.\n(Wild(x)) → (Wonderful(x)) ::: If someone is wild, then he is wonderful.\n(∃x (Wild(x))) → (Octagonal(godwin) ∧ Sour(morgan)) ::: If there is someone who is wild, then Godwin is octagonal and Morgan is sour.\n(¬Wonderful(x) ∧ ¬Putrid(x)) ↔ (Wild(x)) ::: Someone is not wonderful and not putrid if and only if he is wild.\n((Sour(molly) ∧ ¬Wild(molly))) → (¬Wonderful(owen)) ::: It can be concluded that Owen is not wonderful once knowing that Molly is sour and Molly is not wild.\n",
            "First-Order-Logic Question": "¬Significant(morgan) ::: Morgan is not significant."
        },
        "diff": [
            {
                "raw": "(¬∃x (¬Significant(x))) → (Significant(owen)) ::: If there is nobody who is not, then Owen is significant.",
                "gram": "¬∃x(¬Serious(x))→(Serious(x)) ::: If there is nobody who is not, then Owen is significant."
            }
        ],
        "answer": "B",
        "grammar_answer": "A",
        "manual_prog": {
            "First-Order-Logic Rules": "Blue(owen) ::: Owen is octagonal.\n¬Sour(molly) ::: Molly is not sour.\n¬Significant(owen) ::: Owen is not significant.\n¬Wild(tristan) ::: Tristan is not wild.\nSignificant(luther) ::: Luther is significant.\n¬Wild(adam) ::: Adam is not wild.\n¬Wonderful(adam) ::: Adam is not wonderful.\nSour(morgan) ::: Morgan is sour.\nSour(tristan) ::: Tristan is sour.\nSour(godwin) ::: Godwin is sour.\nWonderful(owen) ::: Owen is wonderful.\n¬Wild(molly) ::: Molly is not wild.\n(∃x (Putrid(x) ∧ ¬Sour(x))) ↔ ((Octagonal(x) ∧ ¬Wonderful(x))) ::: Someone is putrid and not sour if and only if he is octagonal and not wonderful.\n(∃x (¬Significant(x))) → (Significant(owen)) ::: If there is nobody who is not, then Owen is significant.\n(Significant(x)) ↔ (¬Wonderful(x)) ::: Someone is significant if and only if he is not wonderful.\n(∃x (¬Significant(x))) → ((¬Putrid(godwin) ∧ Wild(molly))) ::: If there is at least one people who is not significant, then Godwin is not putrid and Molly is wild.\n((Wonderful(x) ∨ Sour(x))) → (Wild(x)) ::: If someone is wonderful or he is sour, then he is wild.\n(Putrid(owen)) → ((¬Octagonal(molly) ∧ ¬Wonderful(adam))) ::: Owen being putrid implies that Molly is not octagonal and Adam is not wonderful.\n(∀x (¬Sour(x))) → (¬Significant(x)) ::: All not sour people are not significant.\n(∀x (¬Significant(x))) → (Wonderful(godwin) ∧ ¬Octagonal(luther)) ::: If everyone is not significant, then Godwin is wonderful and Luther is not octagonal.\n(Wild(x)) → (Wonderful(x)) ::: If someone is wild, then he is wonderful.\n(∃x (Wild(x))) → (Octagonal(godwin) ∧ Sour(morgan)) ::: If there is someone who is wild, then Godwin is octagonal and Morgan is sour.\n(¬Wonderful(x) ∧ ¬Putrid(x)) ↔ (Wild(x)) ::: Someone is not wonderful and not putrid if and only if he is wild.\n((Sour(molly) ∧ ¬Wild(molly))) → (¬Wonderful(owen)) ::: It can be concluded that Owen is not wonderful once knowing that Molly is sour and Molly is not wild.\n",
            "First-Order-Logic Question": "¬Significant(morgan) ::: Morgan is not significant."
        },
        "fixed": true
    },
    {
        "id": 790,
        "raw_prog": {
            "First-Order-Logic Rules": "Octagonal(owen) ::: Owen is octagonal.\n¬Sour(molly) ::: Molly is not sour.\n¬Significant(owen) ::: Owen is not significant.\n¬Wild(tristan) ::: Tristan is not wild.\nSignificant(luther) ::: Luther is significant.\n¬Wild(adam) ::: Adam is not wild.\n¬Wonderful(adam) ::: Adam is not wonderful.\nSour(morgan) ::: Morgan is sour.\nSour(tristan) ::: Tristan is sour.\nSour(godwin) ::: Godwin is sour.\nWonderful(owen) ::: Owen is wonderful.\n¬Wild(molly) ::: Molly is not wild.\n(∃x (Putrid(x) ∧ ¬Sour(x))) ↔ ((Octagonal(x) ∧ ¬Wonderful(x))) ::: Someone is putrid and not sour if and only if he is octagonal and not wonderful.\n(¬∃x (¬x)) → (Significant(owen)) ::: If there is nobody who is not, then Owen is significant.\n(∀x (Significant(x))) ↔ (∀x (¬Wonderful(x))) ::: Someone is significant if and only if he is not wonderful.\n(∃x (¬Significant(x))) → ((¬Putrid(godwin) ∧ Wild(molly))) ::: If there is at least one people who is not significant, then Godwin is not putrid and Molly is wild.\n(∀x (Wonderful(x) ∨ Sour(x))) → (∀x (Wild(x))) ::: If someone is wonderful or he is sour, then he is wild.\n(Putrid(owen)) → ((¬Octagonal(molly) ∧ ¬Wonderful(adam))) ::: Owen being putrid implies that Molly is not octagonal and Adam is not wonderful.\n(∀x (¬Sour(x))) → (∀x (¬Significant(x))) ::: All not sour people are not significant.\n(∀x (¬Significant(x))) → (Wonderful(godwin) ∧ ¬Octagonal(luther)) ::: If everyone is not significant, then Godwin is wonderful and Luther is not octagonal.\n(∀x (Wild(x))) → (Wonderful(x)) ::: If someone is wild, then he is wonderful.\n(∃x (Wild(x))) → (Octagonal(godwin) ∧ Sour(morgan)) ::: If there is someone who is wild, then Godwin is octagonal and Morgan is sour.\n(∀x (¬Wonderful(x) ∧ ¬Putrid(x))) ↔ (∀x (Wild(x))) ::: Someone is not wonderful and not putrid if and only if he is wild.\n(¬Wonderful(owen)) ↔ (Sour(molly) ∧ ¬Wild(molly)) ::: It can be concluded that Owen is not wonderful once knowing that Molly is sour and Molly is not wild.\n",
            "First-Order-Logic Question": "¬Octagonal(owen) ::: Owen is not octagonal."
        },
        "gram_prog": {
            "First-Order-Logic Rules": "Octagonal(owen) ::: Owen is octagonal.\n¬Sour(molly) ::: Molly is not sour.\n¬Significant(owen) ::: Owen is not significant.\n¬Wild(tristan) ::: Tristan is not wild.\nSignificant(luther) ::: Luther is significant.\n¬Wild(adam) ::: Adam is not wild.\n¬Wonderful(adam) ::: Adam is not wonderful.\nSour(morgan) ::: Morgan is sour.\nSour(tristan) ::: Tristan is sour.\nSour(godwin) ::: Godwin is sour.\nWonderful(owen) ::: Owen is wonderful.\n¬Wild(molly) ::: Molly is not wild.\n(∃x (Putrid(x) ∧ ¬Sour(x))) ↔ ((Octagonal(x) ∧ ¬Wonderful(x))) ::: Someone is putrid and not sour if and only if he is octagonal and not wonderful.\n¬∃x(¬(¬(Octagonal(x)))) ::: If there is nobody who is not, then Owen is significant.\n(∀x (Significant(x))) ↔ (∀x (¬Wonderful(x))) ::: Someone is significant if and only if he is not wonderful.\n(∃x (¬Significant(x))) → ((¬Putrid(godwin) ∧ Wild(molly))) ::: If there is at least one people who is not significant, then Godwin is not putrid and Molly is wild.\n(∀x (Wonderful(x) ∨ Sour(x))) → (∀x (Wild(x))) ::: If someone is wonderful or he is sour, then he is wild.\n(Putrid(owen)) → ((¬Octagonal(molly) ∧ ¬Wonderful(adam))) ::: Owen being putrid implies that Molly is not octagonal and Adam is not wonderful.\n(∀x (¬Sour(x))) → (∀x (¬Significant(x))) ::: All not sour people are not significant.\n(∀x (¬Significant(x))) → (Wonderful(godwin) ∧ ¬Octagonal(luther)) ::: If everyone is not significant, then Godwin is wonderful and Luther is not octagonal.\n(∀x (Wild(x))) → (Wonderful(x)) ::: If someone is wild, then he is wonderful.\n(∃x (Wild(x))) → (Octagonal(godwin) ∧ Sour(morgan)) ::: If there is someone who is wild, then Godwin is octagonal and Morgan is sour.\n(∀x (¬Wonderful(x) ∧ ¬Putrid(x))) ↔ (∀x (Wild(x))) ::: Someone is not wonderful and not putrid if and only if he is wild.\n(¬Wonderful(owen)) ↔ (Sour(molly) ∧ ¬Wild(molly)) ::: It can be concluded that Owen is not wonderful once knowing that Molly is sour and Molly is not wild.\n",
            "First-Order-Logic Question": "¬Octagonal(owen) ::: Owen is not octagonal."
        },
        "diff": [
            {
                "raw": "(¬∃x (¬x)) → (Significant(owen)) ::: If there is nobody who is not, then Owen is significant.",
                "gram": "¬∃x(¬(¬(Octagonal(x)))) ::: If there is nobody who is not, then Owen is significant."
            }
        ],
        "answer": "B",
        "grammar_answer": "A",
        "manual_prog": {
            "First-Order-Logic Rules": "Octagonal(owen) ::: Owen is octagonal.\n¬Sour(molly) ::: Molly is not sour.\n¬Significant(owen) ::: Owen is not significant.\n¬Wild(tristan) ::: Tristan is not wild.\nSignificant(luther) ::: Luther is significant.\n¬Wild(adam) ::: Adam is not wild.\n¬Wonderful(adam) ::: Adam is not wonderful.\nSour(morgan) ::: Morgan is sour.\nSour(tristan) ::: Tristan is sour.\nSour(godwin) ::: Godwin is sour.\nWonderful(owen) ::: Owen is wonderful.\n¬Wild(molly) ::: Molly is not wild.\n(∃x (Putrid(x) ∧ ¬Sour(x))) ↔ ((Octagonal(x) ∧ ¬Wonderful(x))) ::: Someone is putrid and not sour if and only if he is octagonal and not wonderful.\n(∃x (¬Significant(x))) → (Significant(owen)) ::: If there is nobody who is not, then Owen is significant.\n(∀x (Significant(x))) ↔ (∀x (¬Wonderful(x))) ::: Someone is significant if and only if he is not wonderful.\n(∃x (¬Significant(x))) → ((¬Putrid(godwin) ∧ Wild(molly))) ::: If there is at least one people who is not significant, then Godwin is not putrid and Molly is wild.\n(∀x (Wonderful(x) ∨ Sour(x))) → (∀x (Wild(x))) ::: If someone is wonderful or he is sour, then he is wild.\n(Putrid(owen)) → ((¬Octagonal(molly) ∧ ¬Wonderful(adam))) ::: Owen being putrid implies that Molly is not octagonal and Adam is not wonderful.\n(∀x (¬Sour(x))) → (∀x (¬Significant(x))) ::: All not sour people are not significant.\n(∀x (¬Significant(x))) → (Wonderful(godwin) ∧ ¬Octagonal(luther)) ::: If everyone is not significant, then Godwin is wonderful and Luther is not octagonal.\n(∀x (Wild(x))) → (Wonderful(x)) ::: If someone is wild, then he is wonderful.\n(∃x (Wild(x))) → (Octagonal(godwin) ∧ Sour(morgan)) ::: If there is someone who is wild, then Godwin is octagonal and Morgan is sour.\n(∀x (¬Wonderful(x) ∧ ¬Putrid(x))) ↔ (∀x (Wild(x))) ::: Someone is not wonderful and not putrid if and only if he is wild.\n(¬Wonderful(owen)) ↔ (Sour(molly) ∧ ¬Wild(molly)) ::: It can be concluded that Owen is not wonderful once knowing that Molly is sour and Molly is not wild.\n",
            "First-Order-Logic Question": "¬Octagonal(owen) ::: Owen is not octagonal."
        },
        "fixed": true
    },
    {
        "id": 791,
        "raw_prog": {
            "First-Order-Logic Rules": "Blue(owen) ::: Owen is octagonal.\n¬Sour(molly) ::: Molly is not sour.\n¬Significant(owen) ::: Owen is not significant.\n¬Wild(tristan) ::: Tristan is not wild.\nSignificant(luther) ::: Luther is significant.\n¬Wild(adam) ::: Adam is not wild.\n¬Wonderful(adam) ::: Adam is not wonderful.\nSour(morgan) ::: Morgan is sour.\nSour(tristan) ::: Tristan is sour.\nSour(godwin) ::: Godwin is sour.\nWonderful(owen) ::: Owen is wonderful.\n¬Wild(molly) ::: Molly is not wild.\n(∃x (Putrid(x) ∧ ¬Sour(x))) ↔ ((Octagonal(x) ∧ ¬Wonderful(x))) ::: Someone is putrid and not sour if and only if he is octagonal and not wonderful.\n(¬∃x (¬x)) → (Significant(owen)) ::: If there is nobody who is not, then Owen is significant.\n(∀x (Significant(x))) ↔ (¬Wonderful(x)) ::: Someone is significant if and only if he is not wonderful.\n(∃x (¬Significant(x))) → ((¬Putrid(godwin) ∧ Wild(molly))) ::: If there is at least one people who is not significant, then Godwin is not putrid and Molly is wild.\n(∀x (Wonderful(x) ∨ Sour(x))) → (Wild(x)) ::: If someone is wonderful or he is sour, then he is wild.\n(Putrid(owen)) → ((¬Octagonal(molly) ∧ ¬Wonderful(adam))) ::: Owen being putrid implies that Molly is not octagonal and Adam is not wonderful.\n(∀x (¬Sour(x))) → (¬Significant(x)) ::: All not sour people are not significant.\n(¬∃x (Significant(x))) → (Wonderful(godwin) ∧ ¬Octagonal(luther)) ::: If everyone is not significant, then Godwin is wonderful and Luther is not octagonal.\n(Wild(x)) → (Wonderful(x)) ::: If someone is wild, then he is wonderful.\n(∃x (Wild(x))) → (Octagonal(godwin) ∧ Sour(morgan)) ::: If there is someone who is wild, then Godwin is octagonal and Morgan is sour.\n(¬Wonderful(x) ∧ ¬Putrid(x)) ↔ (Wild(x)) ::: Someone is not wonderful and not putrid if and only if he is wild.\n(¬Wonderful(owen)) ↔ (Sour(molly) ∧ ¬Wild(molly)) ::: It can be concluded that Owen is not wonderful once knowing that Molly is sour and Molly is not wild.\n",
            "First-Order-Logic Question": "Putrid(tristan) ::: Tristan is putrid."
        },
        "gram_prog": {
            "First-Order-Logic Rules": "Blue(owen) ::: Owen is octagonal.\n¬Sour(molly) ::: Molly is not sour.\n¬Significant(owen) ::: Owen is not significant.\n¬Wild(tristan) ::: Tristan is not wild.\nSignificant(luther) ::: Luther is significant.\n¬Wild(adam) ::: Adam is not wild.\n¬Wonderful(adam) ::: Adam is not wonderful.\nSour(morgan) ::: Morgan is sour.\nSour(tristan) ::: Tristan is sour.\nSour(godwin) ::: Godwin is sour.\nWonderful(owen) ::: Owen is wonderful.\n¬Wild(molly) ::: Molly is not wild.\n(∃x (Putrid(x) ∧ ¬Sour(x))) ↔ ((Octagonal(x) ∧ ¬Wonderful(x))) ::: Someone is putrid and not sour if and only if he is octagonal and not wonderful.\n¬∃x(¬(¬(Serious(x)))) ::: If there is nobody who is not, then Owen is significant.\n(∀x (Significant(x))) ↔ (¬Wonderful(x)) ::: Someone is significant if and only if he is not wonderful.\n(∃x (¬Significant(x))) → ((¬Putrid(godwin) ∧ Wild(molly))) ::: If there is at least one people who is not significant, then Godwin is not putrid and Molly is wild.\n(∀x (Wonderful(x) ∨ Sour(x))) → (Wild(x)) ::: If someone is wonderful or he is sour, then he is wild.\n(Putrid(owen)) → ((¬Octagonal(molly) ∧ ¬Wonderful(adam))) ::: Owen being putrid implies that Molly is not octagonal and Adam is not wonderful.\n(∀x (¬Sour(x))) → (¬Significant(x)) ::: All not sour people are not significant.\n¬∃x(Serious(x))→(Fresh(x)∧Entire(x)) ::: If everyone is not significant, then Godwin is wonderful and Luther is not octagonal.\n(Wild(x)) → (Wonderful(x)) ::: If someone is wild, then he is wonderful.\n(∃x (Wild(x))) → (Octagonal(godwin) ∧ Sour(morgan)) ::: If there is someone who is wild, then Godwin is octagonal and Morgan is sour.\n(¬Wonderful(x) ∧ ¬Putrid(x)) ↔ (Wild(x)) ::: Someone is not wonderful and not putrid if and only if he is wild.\n(¬Wonderful(owen)) ↔ (Sour(molly) ∧ ¬Wild(molly)) ::: It can be concluded that Owen is not wonderful once knowing that Molly is sour and Molly is not wild.\n",
            "First-Order-Logic Question": "Putrid(tristan) ::: Tristan is putrid."
        },
        "diff": [
            {
                "raw": "(¬∃x (¬x)) → (Significant(owen)) ::: If there is nobody who is not, then Owen is significant.",
                "gram": "¬∃x(¬(¬(Serious(x)))) ::: If there is nobody who is not, then Owen is significant."
            },
            {
                "raw": "(¬∃x (Significant(x))) → (Wonderful(godwin) ∧ ¬Octagonal(luther)) ::: If everyone is not significant, then Godwin is wonderful and Luther is not octagonal.",
                "gram": "¬∃x(Serious(x))→(Fresh(x)∧Entire(x)) ::: If everyone is not significant, then Godwin is wonderful and Luther is not octagonal."
            }
        ],
        "answer": "B",
        "grammar_answer": "A",
        "manual_prog": {
            "First-Order-Logic Rules": "Blue(owen) ::: Owen is octagonal.\n¬Sour(molly) ::: Molly is not sour.\n¬Significant(owen) ::: Owen is not significant.\n¬Wild(tristan) ::: Tristan is not wild.\nSignificant(luther) ::: Luther is significant.\n¬Wild(adam) ::: Adam is not wild.\n¬Wonderful(adam) ::: Adam is not wonderful.\nSour(morgan) ::: Morgan is sour.\nSour(tristan) ::: Tristan is sour.\nSour(godwin) ::: Godwin is sour.\nWonderful(owen) ::: Owen is wonderful.\n¬Wild(molly) ::: Molly is not wild.\n(∃x (Putrid(x) ∧ ¬Sour(x))) ↔ ((Octagonal(x) ∧ ¬Wonderful(x))) ::: Someone is putrid and not sour if and only if he is octagonal and not wonderful.\n(∃x (¬Significant(x))) → (Significant(owen)) ::: If there is nobody who is not, then Owen is significant.\n(∀x (Significant(x))) ↔ (¬Wonderful(x)) ::: Someone is significant if and only if he is not wonderful.\n(∃x (¬Significant(x))) → ((¬Putrid(godwin) ∧ Wild(molly))) ::: If there is at least one people who is not significant, then Godwin is not putrid and Molly is wild.\n(∀x (Wonderful(x) ∨ Sour(x))) → (Wild(x)) ::: If someone is wonderful or he is sour, then he is wild.\n(Putrid(owen)) → ((¬Octagonal(molly) ∧ ¬Wonderful(adam))) ::: Owen being putrid implies that Molly is not octagonal and Adam is not wonderful.\n(∀x (¬Sour(x))) → (¬Significant(x)) ::: All not sour people are not significant.\n(∀x (Significant(x))) → (Wonderful(godwin) ∧ ¬Octagonal(luther)) ::: If everyone is not significant, then Godwin is wonderful and Luther is not octagonal.\n(Wild(x)) → (Wonderful(x)) ::: If someone is wild, then he is wonderful.\n(∃x (Wild(x))) → (Octagonal(godwin) ∧ Sour(morgan)) ::: If there is someone who is wild, then Godwin is octagonal and Morgan is sour.\n(¬Wonderful(x) ∧ ¬Putrid(x)) ↔ (Wild(x)) ::: Someone is not wonderful and not putrid if and only if he is wild.\n(¬Wonderful(owen)) ↔ (Sour(molly) ∧ ¬Wild(molly)) ::: It can be concluded that Owen is not wonderful once knowing that Molly is sour and Molly is not wild.\n",
            "First-Order-Logic Question": "Putrid(tristan) ::: Tristan is putrid."
        },
        "fixed": true
    },
    {
        "id": 793,
        "raw_prog": {
            "First-Order-Logic Rules": "Octagonal(owen) ::: Owen is octagonal.\n¬Sour(molly) ::: Molly is not sour.\n¬Significant(owen) ::: Owen is not significant.\n¬Wild(tristan) ::: Tristan is not wild.\nSignificant(luther) ::: Luther is significant.\n¬Wild(adam) ::: Adam is not wild.\n¬Wonderful(adam) ::: Adam is not wonderful.\nSour(morgan) ::: Morgan is sour.\nSour(tristan) ::: Tristan is sour.\nSour(godwin) ::: Godwin is sour.\nWonderful(owen) ::: Owen is wonderful.\n¬Wild(molly) ::: Molly is not wild.\n(∃x (Putrid(x) ∧ ¬Sour(x))) ↔ ((Octagonal(x) ∧ ¬Wonderful(x))) ::: Someone is putrid and not sour if and only if he is octagonal and not wonderful.\n(¬∃x (¬Significant(x))) → (Significant(owen)) ::: If there is nobody who is not, then Owen is significant.\n(∀x (Significant(x))) ↔ (∀x (¬Wonderful(x))) ::: Someone is significant if and only if he is not wonderful.\n(∃x (¬Significant(x))) → ((¬Putrid(godwin) ∧ Wild(molly))) ::: If there is at least one people who is not significant, then Godwin is not putrid and Molly is wild.\n(∀x (Wonderful(x) ∨ Sour(x))) → (∀x (Wild(x))) ::: If someone is wonderful or he is sour, then he is wild.\n(Putrid(owen)) → ((¬Octagonal(molly) ∧ ¬Wonderful(adam))) ::: Owen being putrid implies that Molly is not octagonal and Adam is not wonderful.\n(∀x (¬Sour(x))) → (∀x (¬Significant(x))) ::: All not sour people are not significant.\n(∀x (¬Significant(x))) → (Wonderful(godwin) ∧ ¬Octagonal(luther)) ::: If everyone is not significant, then Godwin is wonderful and Luther is not octagonal.\n(∀x (Wild(x))) → (Wonderful(x)) ::: If someone is wild, then he is wonderful.\n(∃x (Wild(x))) → (Octagonal(godwin) ∧ Sour(morgan)) ::: If there is someone who is wild, then Godwin is octagonal and Morgan is sour.\n(∀x (¬Wonderful(x) ∧ ¬Putrid(x))) ↔ (∀x (Wild(x))) ::: Someone is not wonderful and not putrid if and only if he is wild.\n(¬Wonderful(owen)) ↔ (Sour(molly) ∧ ¬Wild(molly)) ::: It can be concluded that Owen is not wonderful once knowing that Molly is sour and Molly is not wild.\n",
            "First-Order-Logic Question": "¬Sour(tristan) ::: Tristan is not sour."
        },
        "gram_prog": {
            "First-Order-Logic Rules": "Octagonal(owen) ::: Owen is octagonal.\n¬Sour(molly) ::: Molly is not sour.\n¬Significant(owen) ::: Owen is not significant.\n¬Wild(tristan) ::: Tristan is not wild.\nSignificant(luther) ::: Luther is significant.\n¬Wild(adam) ::: Adam is not wild.\n¬Wonderful(adam) ::: Adam is not wonderful.\nSour(morgan) ::: Morgan is sour.\nSour(tristan) ::: Tristan is sour.\nSour(godwin) ::: Godwin is sour.\nWonderful(owen) ::: Owen is wonderful.\n¬Wild(molly) ::: Molly is not wild.\n(∃x (Putrid(x) ∧ ¬Sour(x))) ↔ ((Octagonal(x) ∧ ¬Wonderful(x))) ::: Someone is putrid and not sour if and only if he is octagonal and not wonderful.\n¬∃x(¬Significant(x))→Significant(x) ::: If there is nobody who is not, then Owen is significant.\n(∀x (Significant(x))) ↔ (∀x (¬Wonderful(x))) ::: Someone is significant if and only if he is not wonderful.\n(∃x (¬Significant(x))) → ((¬Putrid(godwin) ∧ Wild(molly))) ::: If there is at least one people who is not significant, then Godwin is not putrid and Molly is wild.\n(∀x (Wonderful(x) ∨ Sour(x))) → (∀x (Wild(x))) ::: If someone is wonderful or he is sour, then he is wild.\n(Putrid(owen)) → ((¬Octagonal(molly) ∧ ¬Wonderful(adam))) ::: Owen being putrid implies that Molly is not octagonal and Adam is not wonderful.\n(∀x (¬Sour(x))) → (∀x (¬Significant(x))) ::: All not sour people are not significant.\n(∀x (¬Significant(x))) → (Wonderful(godwin) ∧ ¬Octagonal(luther)) ::: If everyone is not significant, then Godwin is wonderful and Luther is not octagonal.\n(∀x (Wild(x))) → (Wonderful(x)) ::: If someone is wild, then he is wonderful.\n(∃x (Wild(x))) → (Octagonal(godwin) ∧ Sour(morgan)) ::: If there is someone who is wild, then Godwin is octagonal and Morgan is sour.\n(∀x (¬Wonderful(x) ∧ ¬Putrid(x))) ↔ (∀x (Wild(x))) ::: Someone is not wonderful and not putrid if and only if he is wild.\n(¬Wonderful(owen)) ↔ (Sour(molly) ∧ ¬Wild(molly)) ::: It can be concluded that Owen is not wonderful once knowing that Molly is sour and Molly is not wild.\n",
            "First-Order-Logic Question": "¬Sour(tristan) ::: Tristan is not sour."
        },
        "diff": [
            {
                "raw": "(¬∃x (¬Significant(x))) → (Significant(owen)) ::: If there is nobody who is not, then Owen is significant.",
                "gram": "¬∃x(¬Significant(x))→Significant(x) ::: If there is nobody who is not, then Owen is significant."
            }
        ],
        "answer": "B",
        "grammar_answer": "A",
        "manual_prog": {
            "First-Order-Logic Rules": "Octagonal(owen) ::: Owen is octagonal.\n¬Sour(molly) ::: Molly is not sour.\n¬Significant(owen) ::: Owen is not significant.\n¬Wild(tristan) ::: Tristan is not wild.\nSignificant(luther) ::: Luther is significant.\n¬Wild(adam) ::: Adam is not wild.\n¬Wonderful(adam) ::: Adam is not wonderful.\nSour(morgan) ::: Morgan is sour.\nSour(tristan) ::: Tristan is sour.\nSour(godwin) ::: Godwin is sour.\nWonderful(owen) ::: Owen is wonderful.\n¬Wild(molly) ::: Molly is not wild.\n(∃x (Putrid(x) ∧ ¬Sour(x))) ↔ ((Octagonal(x) ∧ ¬Wonderful(x))) ::: Someone is putrid and not sour if and only if he is octagonal and not wonderful.\n(∃x (¬Significant(x))) → (Significant(owen)) ::: If there is nobody who is not, then Owen is significant.\n(∀x (Significant(x))) ↔ (∀x (¬Wonderful(x))) ::: Someone is significant if and only if he is not wonderful.\n(∃x (¬Significant(x))) → ((¬Putrid(godwin) ∧ Wild(molly))) ::: If there is at least one people who is not significant, then Godwin is not putrid and Molly is wild.\n(∀x (Wonderful(x) ∨ Sour(x))) → (∀x (Wild(x))) ::: If someone is wonderful or he is sour, then he is wild.\n(Putrid(owen)) → ((¬Octagonal(molly) ∧ ¬Wonderful(adam))) ::: Owen being putrid implies that Molly is not octagonal and Adam is not wonderful.\n(∀x (¬Sour(x))) → (∀x (¬Significant(x))) ::: All not sour people are not significant.\n(∀x (¬Significant(x))) → (Wonderful(godwin) ∧ ¬Octagonal(luther)) ::: If everyone is not significant, then Godwin is wonderful and Luther is not octagonal.\n(∀x (Wild(x))) → (Wonderful(x)) ::: If someone is wild, then he is wonderful.\n(∃x (Wild(x))) → (Octagonal(godwin) ∧ Sour(morgan)) ::: If there is someone who is wild, then Godwin is octagonal and Morgan is sour.\n(∀x (¬Wonderful(x) ∧ ¬Putrid(x))) ↔ (∀x (Wild(x))) ::: Someone is not wonderful and not putrid if and only if he is wild.\n(¬Wonderful(owen)) ↔ (Sour(molly) ∧ ¬Wild(molly)) ::: It can be concluded that Owen is not wonderful once knowing that Molly is sour and Molly is not wild.\n",
            "First-Order-Logic Question": "¬Sour(tristan) ::: Tristan is not sour."
        },
        "fixed": true
    },
    {
        "id": 796,
        "raw_prog": {
            "First-Order-Logic Rules": "¬Zany(dan) ::: Dan is not zany.\n¬Sour(kenyon) ::: Kenyon is not sour.\nAggressive(terry) ::: Terry is aggressive.\nZany(lesley) ::: Lesley is zany.\nAggressive(kenyon) ::: Kenyon is aggressive.\n¬Comfortable(melvin) ::: Melvin is not comfortable.\nHappy(melvin) ::: Melvin is happy.\nHappy(kenyon) ::: Kenyon is happy.\nComfortable(dan) ::: Dan is comfortable.\nZany(christopher) ::: Christopher is zany.\n¬Sour(terry) ::: Terry is not sour.\n¬Comfortable(christopher) ::: Christopher is not comfortable.\n((Bad(terry))) → ((Zany(melvin))) ::: If Terry is bad, then Melvin is zany.\n(∀x (¬Bad(x) ∨ ¬Aggressive(x))) → (∀x (Sour(x))) ::: If someone is not bad or not aggressive, then he is sour.\n((Aggressive(melvin) ∨ ¬Bad(melvin))) → ((¬Comfortable(terry))) ::: If Melvin is aggressive or Melvin is not bad, then Terry is not comfortable.\n(∀x (Aggressive(x))) ↔ (∀x (Zany(x))) ::: If someone is aggressive, then he is zany, and vice versa.\n((Comfortable(melvin) ∧ ¬Bad(melvin))) → ((Aggressive(graciela))) ::: If Melvin is comfortable and Melvin is not bad, then Graciela is aggressive.\n((Aggressive(lesley))) ↔ ((¬Happy(christopher) ∧ ¬Comfortable(kenyon))) ::: Lesley is aggressive if and only if Christopher is not happy and Kenyon is not comfortable.\n(∀x ((Happy(x) ∨ ¬Bad(x)))) → ((¬Aggressive(x))) ::: If someone is he or not bad is happy, then he is not aggressive.\n(∃x ((¬Comfortable(x) ∧ ¬Happy(x)))) → ((¬Aggressive(terry) ∧ Sour(terry))) ::: If there is someone who is neither comfortable nor happy, then Terry is not aggressive and Terry is sour.\n(∀x ((Happy(x) ∨ ¬Zany(x)))) → ((¬Comfortable(x))) ::: If someone is he or not zany is happy, then he is not comfortable.\n(∀x ((Sour(x) ∧ ¬Comfortable(x)))) ↔ ((Zany(x))) ::: If someone is sour and not comfortable, then he is zany, and vice versa.\n(∀x ((Comfortable(x) ∧ ¬Aggressive(x))) ↔ ((Sour(x) ∧ ¬Bad(x))) ::: Someone who is comfortable and not aggressive is always sour and not bad.\n(∃x (¬Happy(x))) → ((¬Bad(melvin))) ::: If there is at least one people who is not happy, then Melvin is not bad.\n",
            "First-Order-Logic Question": "Zany(graciela) ::: Graciela is zany."
        },
        "gram_prog": {
            "First-Order-Logic Rules": "¬Zany(dan) ::: Dan is not zany.\n¬Sour(kenyon) ::: Kenyon is not sour.\nAggressive(terry) ::: Terry is aggressive.\nZany(lesley) ::: Lesley is zany.\nAggressive(kenyon) ::: Kenyon is aggressive.\n¬Comfortable(melvin) ::: Melvin is not comfortable.\nHappy(melvin) ::: Melvin is happy.\nHappy(kenyon) ::: Kenyon is happy.\nComfortable(dan) ::: Dan is comfortable.\nZany(christopher) ::: Christopher is zany.\n¬Sour(terry) ::: Terry is not sour.\n¬Comfortable(christopher) ::: Christopher is not comfortable.\n((Bad(terry))) → ((Zany(melvin))) ::: If Terry is bad, then Melvin is zany.\n(∀x (¬Bad(x) ∨ ¬Aggressive(x))) → (∀x (Sour(x))) ::: If someone is not bad or not aggressive, then he is sour.\n((Aggressive(melvin) ∨ ¬Bad(melvin))) → ((¬Comfortable(terry))) ::: If Melvin is aggressive or Melvin is not bad, then Terry is not comfortable.\n(∀x (Aggressive(x))) ↔ (∀x (Zany(x))) ::: If someone is aggressive, then he is zany, and vice versa.\n((Comfortable(melvin) ∧ ¬Bad(melvin))) → ((Aggressive(graciela))) ::: If Melvin is comfortable and Melvin is not bad, then Graciela is aggressive.\n((Aggressive(lesley))) ↔ ((¬Happy(christopher) ∧ ¬Comfortable(kenyon))) ::: Lesley is aggressive if and only if Christopher is not happy and Kenyon is not comfortable.\n(∀x ((Happy(x) ∨ ¬Bad(x)))) → ((¬Aggressive(x))) ::: If someone is he or not bad is happy, then he is not aggressive.\n(∃x ((¬Comfortable(x) ∧ ¬Happy(x)))) → ((¬Aggressive(terry) ∧ Sour(terry))) ::: If there is someone who is neither comfortable nor happy, then Terry is not aggressive and Terry is sour.\n(∀x ((Happy(x) ∨ ¬Zany(x)))) → ((¬Comfortable(x))) ::: If someone is he or not zany is happy, then he is not comfortable.\n(∀x ((Sour(x) ∧ ¬Comfortable(x)))) ↔ ((Zany(x))) ::: If someone is sour and not comfortable, then he is zany, and vice versa.\n∀x((Serious(x)→Fresh(x))) ::: Someone who is comfortable and not aggressive is always sour and not bad.\n(∃x (¬Happy(x))) → ((¬Bad(melvin))) ::: If there is at least one people who is not happy, then Melvin is not bad.\n",
            "First-Order-Logic Question": "Zany(graciela) ::: Graciela is zany."
        },
        "diff": [
            {
                "raw": "(∀x ((Comfortable(x) ∧ ¬Aggressive(x))) ↔ ((Sour(x) ∧ ¬Bad(x))) ::: Someone who is comfortable and not aggressive is always sour and not bad.",
                "gram": "∀x((Serious(x)→Fresh(x))) ::: Someone who is comfortable and not aggressive is always sour and not bad."
            }
        ],
        "answer": "C",
        "grammar_answer": "A",
        "manual_prog": {
            "First-Order-Logic Rules": "¬Zany(dan) ::: Dan is not zany.\n¬Sour(kenyon) ::: Kenyon is not sour.\nAggressive(terry) ::: Terry is aggressive.\nZany(lesley) ::: Lesley is zany.\nAggressive(kenyon) ::: Kenyon is aggressive.\n¬Comfortable(melvin) ::: Melvin is not comfortable.\nHappy(melvin) ::: Melvin is happy.\nHappy(kenyon) ::: Kenyon is happy.\nComfortable(dan) ::: Dan is comfortable.\nZany(christopher) ::: Christopher is zany.\n¬Sour(terry) ::: Terry is not sour.\n¬Comfortable(christopher) ::: Christopher is not comfortable.\n((Bad(terry))) → ((Zany(melvin))) ::: If Terry is bad, then Melvin is zany.\n(∀x (¬Bad(x) ∨ ¬Aggressive(x))) → (∀x (Sour(x))) ::: If someone is not bad or not aggressive, then he is sour.\n((Aggressive(melvin) ∨ ¬Bad(melvin))) → ((¬Comfortable(terry))) ::: If Melvin is aggressive or Melvin is not bad, then Terry is not comfortable.\n(∀x (Aggressive(x))) ↔ (∀x (Zany(x))) ::: If someone is aggressive, then he is zany, and vice versa.\n((Comfortable(melvin) ∧ ¬Bad(melvin))) → ((Aggressive(graciela))) ::: If Melvin is comfortable and Melvin is not bad, then Graciela is aggressive.\n((Aggressive(lesley))) ↔ ((¬Happy(christopher) ∧ ¬Comfortable(kenyon))) ::: Lesley is aggressive if and only if Christopher is not happy and Kenyon is not comfortable.\n(∀x ((Happy(x) ∨ ¬Bad(x)))) → ((¬Aggressive(x))) ::: If someone is he or not bad is happy, then he is not aggressive.\n(∃x ((¬Comfortable(x) ∧ ¬Happy(x)))) → ((¬Aggressive(terry) ∧ Sour(terry))) ::: If there is someone who is neither comfortable nor happy, then Terry is not aggressive and Terry is sour.\n(∀x ((Happy(x) ∨ ¬Zany(x)))) → ((¬Comfortable(x))) ::: If someone is he or not zany is happy, then he is not comfortable.\n(∀x ((Sour(x) ∧ ¬Comfortable(x)))) ↔ ((Zany(x))) ::: If someone is sour and not comfortable, then he is zany, and vice versa.\n(∀x ((Comfortable(x) ∧ ¬Aggressive(x))) ↔ ((Sour(x) ∧ ¬Bad(x)))) ::: Someone who is comfortable and not aggressive is always sour and not bad.\n(∃x (¬Happy(x))) → ((¬Bad(melvin))) ::: If there is at least one people who is not happy, then Melvin is not bad.\n",
            "First-Order-Logic Question": "Zany(graciela) ::: Graciela is zany."
        },
        "fixed": true
    },
    {
        "id": 797,
        "raw_prog": {
            "First-Order-Logic Rules": "¬Zany(dan) ::: Dan is not zany.\n¬Sour(kenyon) ::: Kenyon is not sour.\nAggressive(terry) ::: Terry is aggressive.\nZany(lesley) ::: Lesley is zany.\nAggressive(kenyon) ::: Kenyon is aggressive.\n¬Comfortable(melvin) ::: Melvin is not comfortable.\nHappy(melvin) ::: Melvin is happy.\nHappy(kenyon) ::: Kenyon is happy.\nComfortable(dan) ::: Dan is comfortable.\nZany(christopher) ::: Christopher is zany.\n¬Sour(terry) ::: Terry is not sour.\n¬Comfortable(christopher) ::: Christopher is not comfortable.\n((Bad(terry))) → ((Zany(melvin))) ::: If Terry is bad, then Melvin is zany.\n(∀x (¬Bad(x) ∨ ¬Aggressive(x))) → (∀x (Sour(x))) ::: If someone is not bad or not aggressive, then he is sour.\n((Aggressive(melvin) ∨ ¬Bad(melvin))) → ((¬Comfortable(terry))) ::: If Melvin is aggressive or Melvin is not bad, then Terry is not comfortable.\n(∀x (Aggressive(x))) ↔ (∀x (Zany(x))) ::: If someone is aggressive, then he is zany, and vice versa.\n((Comfortable(melvin) ∧ ¬Bad(melvin))) → ((Aggressive(graciela))) ::: If Melvin is comfortable and Melvin is not bad, then Graciela is aggressive.\n(Aggressive(lesley)) ↔ ((¬Happy(christopher) ∧ ¬Comfortable(kenyon))) ::: Lesley is aggressive if and only if Christopher is not happy and Kenyon is not comfortable.\n(∀x ((¬Bad(x) ∨ Happy(x))) → (¬Aggressive(x))) ::: If someone is he or not bad is happy, then he is not aggressive.\n(∃x ((¬Comfortable(x) ∧ ¬Happy(x))) → ((¬Aggressive(terry) ∧ Sour(terry))) ::: If there is someone who is neither comfortable nor happy, then Terry is not aggressive and Terry is sour.\n(∀x ((¬Zany(x) ∨ Happy(x))) → (¬Comfortable(x))) ::: If someone is he or not zany is happy, then he is not comfortable.\n(∀x ((Sour(x) ∧ ¬Comfortable(x))) ↔ (Zany(x))) ::: If someone is sour and not comfortable, then he is zany, and vice versa.\n((Comfortable(x) ∧ ¬Aggressive(x))) → ((Sour(x) ∧ ¬Bad(x))) ::: Someone who is comfortable and not aggressive is always sour and not bad.\n(∃x (¬Happy(x))) → ((¬Bad(melvin))) ::: If there is at least one people who is not happy, then Melvin is not bad.\n",
            "First-Order-Logic Question": "¬Sour(lesley) ::: Lesley is not sour."
        },
        "gram_prog": {
            "First-Order-Logic Rules": "¬Zany(dan) ::: Dan is not zany.\n¬Sour(kenyon) ::: Kenyon is not sour.\nAggressive(terry) ::: Terry is aggressive.\nZany(lesley) ::: Lesley is zany.\nAggressive(kenyon) ::: Kenyon is aggressive.\n¬Comfortable(melvin) ::: Melvin is not comfortable.\nHappy(melvin) ::: Melvin is happy.\nHappy(kenyon) ::: Kenyon is happy.\nComfortable(dan) ::: Dan is comfortable.\nZany(christopher) ::: Christopher is zany.\n¬Sour(terry) ::: Terry is not sour.\n¬Comfortable(christopher) ::: Christopher is not comfortable.\n((Bad(terry))) → ((Zany(melvin))) ::: If Terry is bad, then Melvin is zany.\n(∀x (¬Bad(x) ∨ ¬Aggressive(x))) → (∀x (Sour(x))) ::: If someone is not bad or not aggressive, then he is sour.\n((Aggressive(melvin) ∨ ¬Bad(melvin))) → ((¬Comfortable(terry))) ::: If Melvin is aggressive or Melvin is not bad, then Terry is not comfortable.\n(∀x (Aggressive(x))) ↔ (∀x (Zany(x))) ::: If someone is aggressive, then he is zany, and vice versa.\n((Comfortable(melvin) ∧ ¬Bad(melvin))) → ((Aggressive(graciela))) ::: If Melvin is comfortable and Melvin is not bad, then Graciela is aggressive.\n(Aggressive(lesley)) ↔ ((¬Happy(christopher) ∧ ¬Comfortable(kenyon))) ::: Lesley is aggressive if and only if Christopher is not happy and Kenyon is not comfortable.\n(∀x ((¬Bad(x) ∨ Happy(x))) → (¬Aggressive(x))) ::: If someone is he or not bad is happy, then he is not aggressive.\n¬Comfortable(x)∧¬Happy(x)→¬Aggressive(x)∧Sour(x) ::: If there is someone who is neither comfortable nor happy, then Terry is not aggressive and Terry is sour.\n(∀x ((¬Zany(x) ∨ Happy(x))) → (¬Comfortable(x))) ::: If someone is he or not zany is happy, then he is not comfortable.\n(∀x ((Sour(x) ∧ ¬Comfortable(x))) ↔ (Zany(x))) ::: If someone is sour and not comfortable, then he is zany, and vice versa.\n((Comfortable(x) ∧ ¬Aggressive(x))) → ((Sour(x) ∧ ¬Bad(x))) ::: Someone who is comfortable and not aggressive is always sour and not bad.\n(∃x (¬Happy(x))) → ((¬Bad(melvin))) ::: If there is at least one people who is not happy, then Melvin is not bad.\n",
            "First-Order-Logic Question": "¬Sour(lesley) ::: Lesley is not sour."
        },
        "diff": [
            {
                "raw": "(∃x ((¬Comfortable(x) ∧ ¬Happy(x))) → ((¬Aggressive(terry) ∧ Sour(terry))) ::: If there is someone who is neither comfortable nor happy, then Terry is not aggressive and Terry is sour.",
                "gram": "¬Comfortable(x)∧¬Happy(x)→¬Aggressive(x)∧Sour(x) ::: If there is someone who is neither comfortable nor happy, then Terry is not aggressive and Terry is sour."
            }
        ],
        "answer": "B",
        "grammar_answer": "A",
        "manual_prog": {
            "First-Order-Logic Rules": "¬Zany(dan) ::: Dan is not zany.\n¬Sour(kenyon) ::: Kenyon is not sour.\nAggressive(terry) ::: Terry is aggressive.\nZany(lesley) ::: Lesley is zany.\nAggressive(kenyon) ::: Kenyon is aggressive.\n¬Comfortable(melvin) ::: Melvin is not comfortable.\nHappy(melvin) ::: Melvin is happy.\nHappy(kenyon) ::: Kenyon is happy.\nComfortable(dan) ::: Dan is comfortable.\nZany(christopher) ::: Christopher is zany.\n¬Sour(terry) ::: Terry is not sour.\n¬Comfortable(christopher) ::: Christopher is not comfortable.\n((Bad(terry))) → ((Zany(melvin))) ::: If Terry is bad, then Melvin is zany.\n(∀x (¬Bad(x) ∨ ¬Aggressive(x))) → (∀x (Sour(x))) ::: If someone is not bad or not aggressive, then he is sour.\n((Aggressive(melvin) ∨ ¬Bad(melvin))) → ((¬Comfortable(terry))) ::: If Melvin is aggressive or Melvin is not bad, then Terry is not comfortable.\n(∀x (Aggressive(x))) ↔ (∀x (Zany(x))) ::: If someone is aggressive, then he is zany, and vice versa.\n((Comfortable(melvin) ∧ ¬Bad(melvin))) → ((Aggressive(graciela))) ::: If Melvin is comfortable and Melvin is not bad, then Graciela is aggressive.\n(Aggressive(lesley)) ↔ ((¬Happy(christopher) ∧ ¬Comfortable(kenyon))) ::: Lesley is aggressive if and only if Christopher is not happy and Kenyon is not comfortable.\n(∀x ((¬Bad(x) ∨ Happy(x))) → (¬Aggressive(x))) ::: If someone is he or not bad is happy, then he is not aggressive.\n(∃x ((¬Comfortable(x) ∧ ¬Happy(x))) → ((¬Aggressive(terry) ∧ Sour(terry)))) ::: If there is someone who is neither comfortable nor happy, then Terry is not aggressive and Terry is sour.\n(∀x ((¬Zany(x) ∨ Happy(x))) → (¬Comfortable(x))) ::: If someone is he or not zany is happy, then he is not comfortable.\n(∀x ((Sour(x) ∧ ¬Comfortable(x))) ↔ (Zany(x))) ::: If someone is sour and not comfortable, then he is zany, and vice versa.\n((Comfortable(x) ∧ ¬Aggressive(x))) → ((Sour(x) ∧ ¬Bad(x))) ::: Someone who is comfortable and not aggressive is always sour and not bad.\n(∃x (¬Happy(x))) → ((¬Bad(melvin))) ::: If there is at least one people who is not happy, then Melvin is not bad.\n",
            "First-Order-Logic Question": "¬Sour(lesley) ::: Lesley is not sour."
        },
        "fixed": true
    },
    {
        "id": 799,
        "raw_prog": {
            "First-Order-Logic Rules": "¬Zany(dan) ::: Dan is not zany.\n¬Sour(kenyon) ::: Kenyon is not sour.\nAggressive(terry) ::: Terry is aggressive.\nZany(lesley) ::: Lesley is zany.\nAggressive(kenyon) ::: Kenyon is aggressive.\n¬Comfortable(melvin) ::: Melvin is not comfortable.\nHappy(melvin) ::: Melvin is happy.\nHappy(kenyon) ::: Kenyon is happy.\nComfortable(dan) ::: Dan is comfortable.\nZany(christopher) ::: Christopher is zany.\n¬Sour(terry) ::: Terry is not sour.\n¬Comfortable(christopher) ::: Christopher is not comfortable.\n((Bad(terry))) → ((Zany(melvin))) ::: If Terry is bad, then Melvin is zany.\n(∀x (¬Bad(x) ∨ ¬Aggressive(x))) → (∀x (Sour(x))) ::: If someone is not bad or not aggressive, then he is sour.\n((Aggressive(melvin) ∨ ¬Bad(melvin))) → ((¬Comfortable(terry))) ::: If Melvin is aggressive or Melvin is not bad, then Terry is not comfortable.\n(∀x (Aggressive(x))) ↔ (∀x (Zany(x))) ::: If someone is aggressive, then he is zany, and vice versa.\n((Comfortable(melvin) ∧ ¬Bad(melvin))) → ((Aggressive(graciela))) ::: If Melvin is comfortable and Melvin is not bad, then Graciela is aggressive.\n(Aggressive(lesley)) ↔ ((¬Happy(christopher) ∧ ¬Comfortable(kenyon))) ::: Lesley is aggressive if and only if Christopher is not happy and Kenyon is not comfortable.\n(∀x ((¬Bad(x) ∨ Happy(x))) → (¬Aggressive(x))) ::: If someone is not bad or not happy, then he is not aggressive.\n(∃x ((¬Comfortable(x) ∧ ¬Happy(x))) → ((¬Aggressive(terry) ∧ Sour(terry))) ::: If there is someone who is neither comfortable nor happy, then Terry is not aggressive and Terry is sour.\n(∀x ((¬Zany(x) ∨ Happy(x))) → (¬Comfortable(x))) ::: If someone is he or not zany is happy, then he is not comfortable.\n(∀x ((Sour(x) ∧ ¬Comfortable(x))) ↔ (Zany(x))) ::: If someone is sour and not comfortable, then he is zany, and vice versa.\n((Comfortable(x) ∧ ¬Aggressive(x))) → ((Sour(x) ∧ ¬Bad(x))) ::: Someone who is comfortable and not aggressive is always sour and not bad.\n(∃x (¬Happy(x))) → (¬Bad(melvin)) ::: If there is at least one people who is not happy, then Melvin is not bad.\n",
            "First-Order-Logic Question": "¬Comfortable(graciela) ::: Graciela is not comfortable."
        },
        "gram_prog": {
            "First-Order-Logic Rules": "¬Zany(dan) ::: Dan is not zany.\n¬Sour(kenyon) ::: Kenyon is not sour.\nAggressive(terry) ::: Terry is aggressive.\nZany(lesley) ::: Lesley is zany.\nAggressive(kenyon) ::: Kenyon is aggressive.\n¬Comfortable(melvin) ::: Melvin is not comfortable.\nHappy(melvin) ::: Melvin is happy.\nHappy(kenyon) ::: Kenyon is happy.\nComfortable(dan) ::: Dan is comfortable.\nZany(christopher) ::: Christopher is zany.\n¬Sour(terry) ::: Terry is not sour.\n¬Comfortable(christopher) ::: Christopher is not comfortable.\n((Bad(terry))) → ((Zany(melvin))) ::: If Terry is bad, then Melvin is zany.\n(∀x (¬Bad(x) ∨ ¬Aggressive(x))) → (∀x (Sour(x))) ::: If someone is not bad or not aggressive, then he is sour.\n((Aggressive(melvin) ∨ ¬Bad(melvin))) → ((¬Comfortable(terry))) ::: If Melvin is aggressive or Melvin is not bad, then Terry is not comfortable.\n(∀x (Aggressive(x))) ↔ (∀x (Zany(x))) ::: If someone is aggressive, then he is zany, and vice versa.\n((Comfortable(melvin) ∧ ¬Bad(melvin))) → ((Aggressive(graciela))) ::: If Melvin is comfortable and Melvin is not bad, then Graciela is aggressive.\n(Aggressive(lesley)) ↔ ((¬Happy(christopher) ∧ ¬Comfortable(kenyon))) ::: Lesley is aggressive if and only if Christopher is not happy and Kenyon is not comfortable.\n(∀x ((¬Bad(x) ∨ Happy(x))) → (¬Aggressive(x))) ::: If someone is not bad or not happy, then he is not aggressive.\n¬Comfortable(x)∧¬Happy(x)→¬Aggressive(x)∧Sour(x) ::: If there is someone who is neither comfortable nor happy, then Terry is not aggressive and Terry is sour.\n(∀x ((¬Zany(x) ∨ Happy(x))) → (¬Comfortable(x))) ::: If someone is he or not zany is happy, then he is not comfortable.\n(∀x ((Sour(x) ∧ ¬Comfortable(x))) ↔ (Zany(x))) ::: If someone is sour and not comfortable, then he is zany, and vice versa.\n((Comfortable(x) ∧ ¬Aggressive(x))) → ((Sour(x) ∧ ¬Bad(x))) ::: Someone who is comfortable and not aggressive is always sour and not bad.\n(∃x (¬Happy(x))) → (¬Bad(melvin)) ::: If there is at least one people who is not happy, then Melvin is not bad.\n",
            "First-Order-Logic Question": "¬Comfortable(graciela) ::: Graciela is not comfortable."
        },
        "diff": [
            {
                "raw": "(∃x ((¬Comfortable(x) ∧ ¬Happy(x))) → ((¬Aggressive(terry) ∧ Sour(terry))) ::: If there is someone who is neither comfortable nor happy, then Terry is not aggressive and Terry is sour.",
                "gram": "¬Comfortable(x)∧¬Happy(x)→¬Aggressive(x)∧Sour(x) ::: If there is someone who is neither comfortable nor happy, then Terry is not aggressive and Terry is sour."
            }
        ],
        "answer": "C",
        "grammar_answer": "A",
        "manual_prog": {
            "First-Order-Logic Rules": "¬Zany(dan) ::: Dan is not zany.\n¬Sour(kenyon) ::: Kenyon is not sour.\nAggressive(terry) ::: Terry is aggressive.\nZany(lesley) ::: Lesley is zany.\nAggressive(kenyon) ::: Kenyon is aggressive.\n¬Comfortable(melvin) ::: Melvin is not comfortable.\nHappy(melvin) ::: Melvin is happy.\nHappy(kenyon) ::: Kenyon is happy.\nComfortable(dan) ::: Dan is comfortable.\nZany(christopher) ::: Christopher is zany.\n¬Sour(terry) ::: Terry is not sour.\n¬Comfortable(christopher) ::: Christopher is not comfortable.\n((Bad(terry))) → ((Zany(melvin))) ::: If Terry is bad, then Melvin is zany.\n(∀x (¬Bad(x) ∨ ¬Aggressive(x))) → (∀x (Sour(x))) ::: If someone is not bad or not aggressive, then he is sour.\n((Aggressive(melvin) ∨ ¬Bad(melvin))) → ((¬Comfortable(terry))) ::: If Melvin is aggressive or Melvin is not bad, then Terry is not comfortable.\n(∀x (Aggressive(x))) ↔ (∀x (Zany(x))) ::: If someone is aggressive, then he is zany, and vice versa.\n((Comfortable(melvin) ∧ ¬Bad(melvin))) → ((Aggressive(graciela))) ::: If Melvin is comfortable and Melvin is not bad, then Graciela is aggressive.\n(Aggressive(lesley)) ↔ ((¬Happy(christopher) ∧ ¬Comfortable(kenyon))) ::: Lesley is aggressive if and only if Christopher is not happy and Kenyon is not comfortable.\n(∀x ((¬Bad(x) ∨ Happy(x))) → (¬Aggressive(x))) ::: If someone is not bad or not happy, then he is not aggressive.\n(∃x ((¬Comfortable(x) ∧ ¬Happy(x))) → ((¬Aggressive(terry) ∧ Sour(terry)))) ::: If there is someone who is neither comfortable nor happy, then Terry is not aggressive and Terry is sour.\n(∀x ((¬Zany(x) ∨ Happy(x))) → (¬Comfortable(x))) ::: If someone is he or not zany is happy, then he is not comfortable.\n(∀x ((Sour(x) ∧ ¬Comfortable(x))) ↔ (Zany(x))) ::: If someone is sour and not comfortable, then he is zany, and vice versa.\n((Comfortable(x) ∧ ¬Aggressive(x))) → ((Sour(x) ∧ ¬Bad(x))) ::: Someone who is comfortable and not aggressive is always sour and not bad.\n(∃x (¬Happy(x))) → (¬Bad(melvin)) ::: If there is at least one people who is not happy, then Melvin is not bad.\n",
            "First-Order-Logic Question": "¬Comfortable(graciela) ::: Graciela is not comfortable."
        },
        "fixed": true
    },
    {
        "id": 1005,
        "raw_prog": {
            "First-Order-Logic Rules": "¬Loving(ansel) ::: Ansel is not loving.\nSupportive(barnaby) ::: Barnaby is supportive.\n¬Hungry(aaron) ::: Aaron is not hungry.\n¬Emotional(aaron) ::: Aaron is not emotional.\nLoving(russell) ::: Russell is loving.\n¬Hungry(ansel) ::: Ansel is not hungry.\nLoving(halsey) ::: Halsey is loving.\n¬Busy(cyril) ::: Cyril is not busy.\nBusy(russell) ::: Russell is busy.\n¬Busy(aaron) ::: Aaron is not busy.\n(∀x ((Hungry(x) ∨ Supportive(x)))) → ((Emotional(x) ∧ Loving(x))) ::: If someone is either hungry or supportive, then he is emotional and loving.\n(∀x (¬Supportive(x))) → (¬Hungry(halsey)) ::: If all people are not supportive, then Halsey is not hungry.\n(∀x ((Supportive(x) ∧ ¬Loving(x)))) → (¬Busy(x)) ::: Someone who is both supportive and not loving is always not busy.\n(∀x (¬Supportive(x))) ↔ (Loving(x)) ::: Someone being not supportive is equivalent to being loving.\n(¬Emotional(halsey)) ↔ (¬Busy(aaron)) ::: Halsey is not emotional if and only if Aaron is not busy.\n(¬Emotional(halsey)) → (¬Careful(russell)) ::: If Halsey is not emotional, then Russell is not careful.\n(∀x ((Hungry(x) ∧ ¬Careful(x))) ↔ (¬Supportive(x)) ::: Someone being both hungry and not careful is equivalent to being not supportive.\n(¬Loving(halsey)) → ((¬Emotional(conrad) ∧ Careful(halsey))) ::: Halsey being not loving implies that Conrad is not emotional and Halsey is careful.\n(¬Careful(ansel)) ↔ ((¬Supportive(cyril) ∧ Hungry(conrad))) ::: Ansel being not careful is equivalent to Cyril being not supportive and Conrad being hungry.\n(∀x (Careful(x))) ↔ (Emotional(x)) ::: Someone being careful is equivalent to being emotional.\n(∀x (Careful(x))) → (Emotional(x)) ::: If someone is careful, then he is emotional.\n(∃x ((Emotional(x) ∧ ¬Supportive(x)))) → (¬Loving(aaron)) ::: If there is at least one people who is both emotional and not supportive, then Aaron is not loving.\n",
            "First-Order-Logic Question": "Hungry(aaron) ::: Aaron is hungry."
        },
        "gram_prog": {
            "First-Order-Logic Rules": "¬Loving(ansel) ::: Ansel is not loving.\nSupportive(barnaby) ::: Barnaby is supportive.\n¬Hungry(aaron) ::: Aaron is not hungry.\n¬Emotional(aaron) ::: Aaron is not emotional.\nLoving(russell) ::: Russell is loving.\n¬Hungry(ansel) ::: Ansel is not hungry.\nLoving(halsey) ::: Halsey is loving.\n¬Busy(cyril) ::: Cyril is not busy.\nBusy(russell) ::: Russell is busy.\n¬Busy(aaron) ::: Aaron is not busy.\n(∀x ((Hungry(x) ∨ Supportive(x)))) → ((Emotional(x) ∧ Loving(x))) ::: If someone is either hungry or supportive, then he is emotional and loving.\n(∀x (¬Supportive(x))) → (¬Hungry(halsey)) ::: If all people are not supportive, then Halsey is not hungry.\n(∀x ((Supportive(x) ∧ ¬Loving(x)))) → (¬Busy(x)) ::: Someone who is both supportive and not loving is always not busy.\n(∀x (¬Supportive(x))) ↔ (Loving(x)) ::: Someone being not supportive is equivalent to being loving.\n(¬Emotional(halsey)) ↔ (¬Busy(aaron)) ::: Halsey is not emotional if and only if Aaron is not busy.\n(¬Emotional(halsey)) → (¬Careful(russell)) ::: If Halsey is not emotional, then Russell is not careful.\n∀x((Hungry(x)∧¬Careful(x))) ::: Someone being both hungry and not careful is equivalent to being not supportive.\n(¬Loving(halsey)) → ((¬Emotional(conrad) ∧ Careful(halsey))) ::: Halsey being not loving implies that Conrad is not emotional and Halsey is careful.\n(¬Careful(ansel)) ↔ ((¬Supportive(cyril) ∧ Hungry(conrad))) ::: Ansel being not careful is equivalent to Cyril being not supportive and Conrad being hungry.\n(∀x (Careful(x))) ↔ (Emotional(x)) ::: Someone being careful is equivalent to being emotional.\n(∀x (Careful(x))) → (Emotional(x)) ::: If someone is careful, then he is emotional.\n(∃x ((Emotional(x) ∧ ¬Supportive(x)))) → (¬Loving(aaron)) ::: If there is at least one people who is both emotional and not supportive, then Aaron is not loving.\n",
            "First-Order-Logic Question": "Hungry(aaron) ::: Aaron is hungry."
        },
        "diff": [
            {
                "raw": "(∀x ((Hungry(x) ∧ ¬Careful(x))) ↔ (¬Supportive(x)) ::: Someone being both hungry and not careful is equivalent to being not supportive.",
                "gram": "∀x((Hungry(x)∧¬Careful(x))) ::: Someone being both hungry and not careful is equivalent to being not supportive."
            }
        ],
        "answer": "B",
        "grammar_answer": "A",
        "manual_prog": {
            "First-Order-Logic Rules": "¬Loving(ansel) ::: Ansel is not loving.\nSupportive(barnaby) ::: Barnaby is supportive.\n¬Hungry(aaron) ::: Aaron is not hungry.\n¬Emotional(aaron) ::: Aaron is not emotional.\nLoving(russell) ::: Russell is loving.\n¬Hungry(ansel) ::: Ansel is not hungry.\nLoving(halsey) ::: Halsey is loving.\n¬Busy(cyril) ::: Cyril is not busy.\nBusy(russell) ::: Russell is busy.\n¬Busy(aaron) ::: Aaron is not busy.\n(∀x ((Hungry(x) ∨ Supportive(x)))) → ((Emotional(x) ∧ Loving(x))) ::: If someone is either hungry or supportive, then he is emotional and loving.\n(∀x (¬Supportive(x))) → (¬Hungry(halsey)) ::: If all people are not supportive, then Halsey is not hungry.\n(∀x ((Supportive(x) ∧ ¬Loving(x)))) → (¬Busy(x)) ::: Someone who is both supportive and not loving is always not busy.\n(∀x (¬Supportive(x))) ↔ (Loving(x)) ::: Someone being not supportive is equivalent to being loving.\n(¬Emotional(halsey)) ↔ (¬Busy(aaron)) ::: Halsey is not emotional if and only if Aaron is not busy.\n(¬Emotional(halsey)) → (¬Careful(russell)) ::: If Halsey is not emotional, then Russell is not careful.\n(∀x ((Hungry(x) ∧ ¬Careful(x))) ↔ (¬Supportive(x))) ::: Someone being both hungry and not careful is equivalent to being not supportive.\n(¬Loving(halsey)) → ((¬Emotional(conrad) ∧ Careful(halsey))) ::: Halsey being not loving implies that Conrad is not emotional and Halsey is careful.\n(¬Careful(ansel)) ↔ ((¬Supportive(cyril) ∧ Hungry(conrad))) ::: Ansel being not careful is equivalent to Cyril being not supportive and Conrad being hungry.\n(∀x (Careful(x))) ↔ (Emotional(x)) ::: Someone being careful is equivalent to being emotional.\n(∀x (Careful(x))) → (Emotional(x)) ::: If someone is careful, then he is emotional.\n(∃x ((Emotional(x) ∧ ¬Supportive(x)))) → (¬Loving(aaron)) ::: If there is at least one people who is both emotional and not supportive, then Aaron is not loving.\n",
            "First-Order-Logic Question": "Hungry(aaron) ::: Aaron is hungry."
        },
        "fixed": true
    },
    {
        "id": 1008,
        "raw_prog": {
            "First-Order-Logic Rules": "¬Loving(ansel) ::: Ansel is not loving.\nSupportive(barnaby) ::: Barnaby is supportive.\n¬Hungry(aaron) ::: Aaron is not hungry.\n¬Emotional(aaron) ::: Aaron is not emotional.\nLoving(russell) ::: Russell is loving.\n¬Hungry(ansel) ::: Ansel is not hungry.\nLoving(halsey) ::: Halsey is loving.\n¬Busy(cyril) ::: Cyril is not busy.\nBusy(russell) ::: Russell is busy.\n¬Busy(aaron) ::: Aaron is not busy.\n¬Hungry(conrad) ::: Conrad is not hungry.\nLoving(conrad) ::: Conrad is loving.\n(∀x ((Hungry(x) ∨ Supportive(x)))) → ((Emotional(x) ∧ Loving(x))) ::: If someone is either hungry or supportive, then he is emotional and loving.\n(∀x (¬Supportive(x))) → (¬Hungry(halsey)) ::: If all people are not supportive, then Halsey is not hungry.\n(∀x ((Supportive(x) ∧ ¬Loving(x)))) → (¬Busy(x)) ::: Someone who is both supportive and not loving is always not busy.\n(∀x (¬Supportive(x))) ↔ (Loving(x)) ::: Someone being not supportive is equivalent to being loving.\n(¬Emotional(halsey)) ↔ (¬Busy(aaron)) ::: Halsey is not emotional if and only if Aaron is not busy.\n(¬Emotional(halsey)) → (¬Careful(russell)) ::: If Halsey is not emotional, then Russell is not careful.\n(∀x ((Hungry(x) ∧ ¬Careful(x))) ↔ (¬Supportive(x)) ::: Someone being both hungry and not careful is equivalent to being not supportive.\n(¬Loving(halsey)) → ((¬Emotional(conrad) ∧ Careful(halsey))) ::: Halsey being not loving implies that Conrad is not emotional and Halsey is careful.\n(¬Careful(ansel)) ↔ ((¬Supportive(cyril) ∧ Hungry(conrad))) ::: Ansel being not careful is equivalent to Cyril being not supportive and Conrad being hungry.\n(∀x (Careful(x))) ↔ (Emotional(x)) ::: Someone being careful is equivalent to being emotional.\n(∀x (Careful(x))) → (Emotional(x)) ::: If someone is careful, then he is emotional.\n(∃x ((Emotional(x) ∧ ¬Supportive(x)))) → (¬Loving(aaron)) ::: If there is at least one people who is both emotional and not supportive, then Aaron is not loving.\n",
            "First-Order-Logic Question": "Emotional(aaron) ::: Aaron is emotional."
        },
        "gram_prog": {
            "First-Order-Logic Rules": "¬Loving(ansel) ::: Ansel is not loving.\nSupportive(barnaby) ::: Barnaby is supportive.\n¬Hungry(aaron) ::: Aaron is not hungry.\n¬Emotional(aaron) ::: Aaron is not emotional.\nLoving(russell) ::: Russell is loving.\n¬Hungry(ansel) ::: Ansel is not hungry.\nLoving(halsey) ::: Halsey is loving.\n¬Busy(cyril) ::: Cyril is not busy.\nBusy(russell) ::: Russell is busy.\n¬Busy(aaron) ::: Aaron is not busy.\n¬Hungry(conrad) ::: Conrad is not hungry.\nLoving(conrad) ::: Conrad is loving.\n(∀x ((Hungry(x) ∨ Supportive(x)))) → ((Emotional(x) ∧ Loving(x))) ::: If someone is either hungry or supportive, then he is emotional and loving.\n(∀x (¬Supportive(x))) → (¬Hungry(halsey)) ::: If all people are not supportive, then Halsey is not hungry.\n(∀x ((Supportive(x) ∧ ¬Loving(x)))) → (¬Busy(x)) ::: Someone who is both supportive and not loving is always not busy.\n(∀x (¬Supportive(x))) ↔ (Loving(x)) ::: Someone being not supportive is equivalent to being loving.\n(¬Emotional(halsey)) ↔ (¬Busy(aaron)) ::: Halsey is not emotional if and only if Aaron is not busy.\n(¬Emotional(halsey)) → (¬Careful(russell)) ::: If Halsey is not emotional, then Russell is not careful.\n∀x((Hungry(x)∧¬Careful(x))) ::: Someone being both hungry and not careful is equivalent to being not supportive.\n(¬Loving(halsey)) → ((¬Emotional(conrad) ∧ Careful(halsey))) ::: Halsey being not loving implies that Conrad is not emotional and Halsey is careful.\n(¬Careful(ansel)) ↔ ((¬Supportive(cyril) ∧ Hungry(conrad))) ::: Ansel being not careful is equivalent to Cyril being not supportive and Conrad being hungry.\n(∀x (Careful(x))) ↔ (Emotional(x)) ::: Someone being careful is equivalent to being emotional.\n(∀x (Careful(x))) → (Emotional(x)) ::: If someone is careful, then he is emotional.\n(∃x ((Emotional(x) ∧ ¬Supportive(x)))) → (¬Loving(aaron)) ::: If there is at least one people who is both emotional and not supportive, then Aaron is not loving.\n",
            "First-Order-Logic Question": "Emotional(aaron) ::: Aaron is emotional."
        },
        "diff": [
            {
                "raw": "(∀x ((Hungry(x) ∧ ¬Careful(x))) ↔ (¬Supportive(x)) ::: Someone being both hungry and not careful is equivalent to being not supportive.",
                "gram": "∀x((Hungry(x)∧¬Careful(x))) ::: Someone being both hungry and not careful is equivalent to being not supportive."
            }
        ],
        "answer": "B",
        "grammar_answer": "A",
        "manual_prog": {
            "First-Order-Logic Rules": "¬Loving(ansel) ::: Ansel is not loving.\nSupportive(barnaby) ::: Barnaby is supportive.\n¬Hungry(aaron) ::: Aaron is not hungry.\n¬Emotional(aaron) ::: Aaron is not emotional.\nLoving(russell) ::: Russell is loving.\n¬Hungry(ansel) ::: Ansel is not hungry.\nLoving(halsey) ::: Halsey is loving.\n¬Busy(cyril) ::: Cyril is not busy.\nBusy(russell) ::: Russell is busy.\n¬Busy(aaron) ::: Aaron is not busy.\n¬Hungry(conrad) ::: Conrad is not hungry.\nLoving(conrad) ::: Conrad is loving.\n(∀x ((Hungry(x) ∨ Supportive(x)))) → ((Emotional(x) ∧ Loving(x))) ::: If someone is either hungry or supportive, then he is emotional and loving.\n(∀x (¬Supportive(x))) → (¬Hungry(halsey)) ::: If all people are not supportive, then Halsey is not hungry.\n(∀x ((Supportive(x) ∧ ¬Loving(x)))) → (¬Busy(x)) ::: Someone who is both supportive and not loving is always not busy.\n(∀x (¬Supportive(x))) ↔ (Loving(x)) ::: Someone being not supportive is equivalent to being loving.\n(¬Emotional(halsey)) ↔ (¬Busy(aaron)) ::: Halsey is not emotional if and only if Aaron is not busy.\n(¬Emotional(halsey)) → (¬Careful(russell)) ::: If Halsey is not emotional, then Russell is not careful.\n(∀x ((Hungry(x) ∧ ¬Careful(x))) ↔ (¬Supportive(x))) ::: Someone being both hungry and not careful is equivalent to being not supportive.\n(¬Loving(halsey)) → ((¬Emotional(conrad) ∧ Careful(halsey))) ::: Halsey being not loving implies that Conrad is not emotional and Halsey is careful.\n(¬Careful(ansel)) ↔ ((¬Supportive(cyril) ∧ Hungry(conrad))) ::: Ansel being not careful is equivalent to Cyril being not supportive and Conrad being hungry.\n(∀x (Careful(x))) ↔ (Emotional(x)) ::: Someone being careful is equivalent to being emotional.\n(∀x (Careful(x))) → (Emotional(x)) ::: If someone is careful, then he is emotional.\n(∃x ((Emotional(x) ∧ ¬Supportive(x)))) → (¬Loving(aaron)) ::: If there is at least one people who is both emotional and not supportive, then Aaron is not loving.\n",
            "First-Order-Logic Question": "Emotional(aaron) ::: Aaron is emotional."
        },
        "fixed": true
    },
    {
        "id": 1020,
        "raw_prog": {
            "First-Order-Logic Rules": "Fat(tristan) ::: Tristan is fat.\n¬Straightforward(tristan) ::: Tristan is not straightforward.\n¬Hard(tristan) ::: Tristan is not hard.\n¬Hard(halsey) ::: Halsey is not hard.\nStraightforward(lewis) ::: Lewis is straightforward.\n¬Fat(noel) ::: Noel is not fat.\n¬Shiny(tristan) ::: Tristan is not shiny.\n¬Dry(lewis) ::: Lewis is not dry.\nZany(tristan) ::: Tristan is zany.\nDry(noel) ::: Noel is dry.\nShiny(noel) ::: Noel is shiny.\n(∀x ((¬Straightforward(x) ∨ ¬Fat(x)))) → (Shiny(noel)) ::: If all people are not straightforward or not fat, then Noel is shiny.\n(∀x (Hard(x))) ↔ (Straightforward(x)) ::: Someone being hard is equivalent to being straightforward.\n(∀x ((Fat(x) ∧ ¬Dry(x)))) ↔ (Shiny(x)) ::: Someone being both fat and not dry is equivalent to being shiny.\n(∀x (¬Dry(x))) ↔ (Hard(x)) ::: Someone is not dry if and only if he is hard.\n(∃x ((Dry(x) ∧ Hard(x)))) → (Fat(lewis)) ::: If there is someone who is both dry and hard, then Lewis is fat.\n(∃x ((¬Straightforward(x) ∨ ¬Shiny(x)))) → (Fat(tristan)) ::: If there is at least one people who is not straightforward or not shiny, then Tristan is fat.\n(∀x ((Hard(x) ∨ Straightforward(x))) → (¬Zany(x))) ::: If someone is hard or he is straightforward, then he is not zany.\n(¬Dry(miles)) ↔ (¬Straightforward(lewis)) ::: Miles is not dry if and only if Lewis is not straightforward.\n(¬Zany(tristan)) ↔ (¬Dry(lewis)) ::: If Tristan is not zany, then Lewis is not dry, and vice versa.\n(∀x ((Zany(x) ∧ ¬Shiny(x))) → (Fat(x))) ::: If someone is both zany and not shiny, then he is fat.\n(∀x ((Fat(x) ∧ ¬Shiny(x))) ↔ (¬Straightforward(x) ∧ ¬Dry(x)) ::: Someone who is fat and not shiny is always not straightforward and not dry.\n(¬Hard(miles)) ↔ (Dry(miles)) ::: Miles being not hard is equivalent to Miles being dry.\n",
            "First-Order-Logic Question": "Dry(tristan) ::: Tristan is dry."
        },
        "gram_prog": {
            "First-Order-Logic Rules": "Fat(tristan) ::: Tristan is fat.\n¬Straightforward(tristan) ::: Tristan is not straightforward.\n¬Hard(tristan) ::: Tristan is not hard.\n¬Hard(halsey) ::: Halsey is not hard.\nStraightforward(lewis) ::: Lewis is straightforward.\n¬Fat(noel) ::: Noel is not fat.\n¬Shiny(tristan) ::: Tristan is not shiny.\n¬Dry(lewis) ::: Lewis is not dry.\nZany(tristan) ::: Tristan is zany.\nDry(noel) ::: Noel is dry.\nShiny(noel) ::: Noel is shiny.\n(∀x ((¬Straightforward(x) ∨ ¬Fat(x)))) → (Shiny(noel)) ::: If all people are not straightforward or not fat, then Noel is shiny.\n(∀x (Hard(x))) ↔ (Straightforward(x)) ::: Someone being hard is equivalent to being straightforward.\n(∀x ((Fat(x) ∧ ¬Dry(x)))) ↔ (Shiny(x)) ::: Someone being both fat and not dry is equivalent to being shiny.\n(∀x (¬Dry(x))) ↔ (Hard(x)) ::: Someone is not dry if and only if he is hard.\n(∃x ((Dry(x) ∧ Hard(x)))) → (Fat(lewis)) ::: If there is someone who is both dry and hard, then Lewis is fat.\n(∃x ((¬Straightforward(x) ∨ ¬Shiny(x)))) → (Fat(tristan)) ::: If there is at least one people who is not straightforward or not shiny, then Tristan is fat.\n(∀x ((Hard(x) ∨ Straightforward(x))) → (¬Zany(x))) ::: If someone is hard or he is straightforward, then he is not zany.\n(¬Dry(miles)) ↔ (¬Straightforward(lewis)) ::: Miles is not dry if and only if Lewis is not straightforward.\n(¬Zany(tristan)) ↔ (¬Dry(lewis)) ::: If Tristan is not zany, then Lewis is not dry, and vice versa.\n(∀x ((Zany(x) ∧ ¬Shiny(x))) → (Fat(x))) ::: If someone is both zany and not shiny, then he is fat.\n∀x((Fresh(x)→Serious(x))) ::: Someone who is fat and not shiny is always not straightforward and not dry.\n(¬Hard(miles)) ↔ (Dry(miles)) ::: Miles being not hard is equivalent to Miles being dry.\n",
            "First-Order-Logic Question": "Dry(tristan) ::: Tristan is dry."
        },
        "diff": [
            {
                "raw": "(∀x ((Fat(x) ∧ ¬Shiny(x))) ↔ (¬Straightforward(x) ∧ ¬Dry(x)) ::: Someone who is fat and not shiny is always not straightforward and not dry.",
                "gram": "∀x((Fresh(x)→Serious(x))) ::: Someone who is fat and not shiny is always not straightforward and not dry."
            }
        ],
        "answer": "B",
        "grammar_answer": "A",
        "manual_prog": {
            "First-Order-Logic Rules": "Fat(tristan) ::: Tristan is fat.\n¬Straightforward(tristan) ::: Tristan is not straightforward.\n¬Hard(tristan) ::: Tristan is not hard.\n¬Hard(halsey) ::: Halsey is not hard.\nStraightforward(lewis) ::: Lewis is straightforward.\n¬Fat(noel) ::: Noel is not fat.\n¬Shiny(tristan) ::: Tristan is not shiny.\n¬Dry(lewis) ::: Lewis is not dry.\nZany(tristan) ::: Tristan is zany.\nDry(noel) ::: Noel is dry.\nShiny(noel) ::: Noel is shiny.\n(∀x ((¬Straightforward(x) ∨ ¬Fat(x)))) → (Shiny(noel)) ::: If all people are not straightforward or not fat, then Noel is shiny.\n(∀x (Hard(x))) ↔ (Straightforward(x)) ::: Someone being hard is equivalent to being straightforward.\n(∀x ((Fat(x) ∧ ¬Dry(x)))) ↔ (Shiny(x)) ::: Someone being both fat and not dry is equivalent to being shiny.\n(∀x (¬Dry(x))) ↔ (Hard(x)) ::: Someone is not dry if and only if he is hard.\n(∃x ((Dry(x) ∧ Hard(x)))) → (Fat(lewis)) ::: If there is someone who is both dry and hard, then Lewis is fat.\n(∃x ((¬Straightforward(x) ∨ ¬Shiny(x)))) → (Fat(tristan)) ::: If there is at least one people who is not straightforward or not shiny, then Tristan is fat.\n(∀x ((Hard(x) ∨ Straightforward(x))) → (¬Zany(x))) ::: If someone is hard or he is straightforward, then he is not zany.\n(¬Dry(miles)) ↔ (¬Straightforward(lewis)) ::: Miles is not dry if and only if Lewis is not straightforward.\n(¬Zany(tristan)) ↔ (¬Dry(lewis)) ::: If Tristan is not zany, then Lewis is not dry, and vice versa.\n(∀x ((Zany(x) ∧ ¬Shiny(x))) → (Fat(x))) ::: If someone is both zany and not shiny, then he is fat.\n(∀x ((Fat(x) ∧ ¬Shiny(x))) ↔ (¬Straightforward(x) ∧ ¬Dry(x))) ::: Someone who is fat and not shiny is always not straightforward and not dry.\n(¬Hard(miles)) ↔ (Dry(miles)) ::: Miles being not hard is equivalent to Miles being dry.\n",
            "First-Order-Logic Question": "Dry(tristan) ::: Tristan is dry."
        },
        "fixed": true
    },
    {
        "id": 1023,
        "raw_prog": {
            "First-Order-Logic Rules": "Fat(tristan) ::: Tristan is fat.\n¬Straightforward(tristan) ::: Tristan is not straightforward.\n¬Hard(tristan) ::: Tristan is not hard.\n¬Hard(halsey) ::: Halsey is not hard.\nStraightforward(lewis) ::: Lewis is straightforward.\n¬Fat(noel) ::: Noel is not fat.\n¬Shiny(tristan) ::: Tristan is not shiny.\n¬Dry(lewis) ::: Lewis is not dry.\nZany(tristan) ::: Tristan is zany.\nDry(noel) ::: Noel is dry.\nShiny(noel) ::: Noel is shiny.\nShiny(lewis) ::: Lewis is shiny.\n(∀x ((¬Straightforward(x) ∨ ¬Fat(x)))) → (Shiny(noel)) ::: If all people are not straightforward or not fat, then Noel is shiny.\n(∀x (Hard(x))) ↔ (Straightforward(x)) ::: Someone being hard is equivalent to being straightforward.\n(∀x ((Fat(x) ∧ ¬Dry(x)))) ↔ (Shiny(x)) ::: Someone being both fat and not dry is equivalent to being shiny.\n(∀x (¬Dry(x))) ↔ (Hard(x)) ::: Someone is not dry if and only if he is hard.\n(∃x (Dry(x) ∧ Hard(x))) → (Fat(lewis)) ::: If there is someone who is both dry and hard, then Lewis is fat.\n(∃x ((¬Straightforward(x) ∨ ¬Shiny(x))) → (Fat(tristan)) ::: If there is at least one people who is not straightforward or not shiny, then Tristan is fat.\n(∀x ((Hard(x) ∨ Straightforward(x))) → (¬Zany(x))) ::: If someone is hard or he is straightforward, then he is not zany.\n(¬Dry(miles)) ↔ (¬Straightforward(lewis)) ::: Miles is not dry if and only if Lewis is not straightforward.\n(¬Zany(tristan)) ↔ (¬Dry(lewis)) ::: If Tristan is not zany, then Lewis is not dry, and vice versa.\n(∀x ((Zany(x) ∧ ¬Shiny(x))) → (Fat(x))) ::: If someone is both zany and not shiny, then he is fat.\n(∀x ((Fat(x) ∧ ¬Shiny(x))) → (¬Straightforward(x) ∧ ¬Dry(x))) ::: Someone who is fat and not shiny is always not straightforward and not dry.\n(¬Hard(miles)) ↔ (Dry(miles)) ::: Miles being not hard is equivalent to Miles being dry.\n",
            "First-Order-Logic Question": "¬Fat(rolf) ::: Rolf is not fat."
        },
        "gram_prog": {
            "First-Order-Logic Rules": "Fat(tristan) ::: Tristan is fat.\n¬Straightforward(tristan) ::: Tristan is not straightforward.\n¬Hard(tristan) ::: Tristan is not hard.\n¬Hard(halsey) ::: Halsey is not hard.\nStraightforward(lewis) ::: Lewis is straightforward.\n¬Fat(noel) ::: Noel is not fat.\n¬Shiny(tristan) ::: Tristan is not shiny.\n¬Dry(lewis) ::: Lewis is not dry.\nZany(tristan) ::: Tristan is zany.\nDry(noel) ::: Noel is dry.\nShiny(noel) ::: Noel is shiny.\nShiny(lewis) ::: Lewis is shiny.\n(∀x ((¬Straightforward(x) ∨ ¬Fat(x)))) → (Shiny(noel)) ::: If all people are not straightforward or not fat, then Noel is shiny.\n(∀x (Hard(x))) ↔ (Straightforward(x)) ::: Someone being hard is equivalent to being straightforward.\n(∀x ((Fat(x) ∧ ¬Dry(x)))) ↔ (Shiny(x)) ::: Someone being both fat and not dry is equivalent to being shiny.\n(∀x (¬Dry(x))) ↔ (Hard(x)) ::: Someone is not dry if and only if he is hard.\n(∃x (Dry(x) ∧ Hard(x))) → (Fat(lewis)) ::: If there is someone who is both dry and hard, then Lewis is fat.\n¬Straightforward(x)∨¬Shiny(x)→Fat(x) ::: If there is at least one people who is not straightforward or not shiny, then Tristan is fat.\n(∀x ((Hard(x) ∨ Straightforward(x))) → (¬Zany(x))) ::: If someone is hard or he is straightforward, then he is not zany.\n(¬Dry(miles)) ↔ (¬Straightforward(lewis)) ::: Miles is not dry if and only if Lewis is not straightforward.\n(¬Zany(tristan)) ↔ (¬Dry(lewis)) ::: If Tristan is not zany, then Lewis is not dry, and vice versa.\n(∀x ((Zany(x) ∧ ¬Shiny(x))) → (Fat(x))) ::: If someone is both zany and not shiny, then he is fat.\n(∀x ((Fat(x) ∧ ¬Shiny(x))) → (¬Straightforward(x) ∧ ¬Dry(x))) ::: Someone who is fat and not shiny is always not straightforward and not dry.\n(¬Hard(miles)) ↔ (Dry(miles)) ::: Miles being not hard is equivalent to Miles being dry.\n",
            "First-Order-Logic Question": "¬Fat(rolf) ::: Rolf is not fat."
        },
        "diff": [
            {
                "raw": "(∃x ((¬Straightforward(x) ∨ ¬Shiny(x))) → (Fat(tristan)) ::: If there is at least one people who is not straightforward or not shiny, then Tristan is fat.",
                "gram": "¬Straightforward(x)∨¬Shiny(x)→Fat(x) ::: If there is at least one people who is not straightforward or not shiny, then Tristan is fat."
            }
        ],
        "answer": "C",
        "grammar_answer": "A",
        "manual_prog": {
            "First-Order-Logic Rules": "Fat(tristan) ::: Tristan is fat.\n¬Straightforward(tristan) ::: Tristan is not straightforward.\n¬Hard(tristan) ::: Tristan is not hard.\n¬Hard(halsey) ::: Halsey is not hard.\nStraightforward(lewis) ::: Lewis is straightforward.\n¬Fat(noel) ::: Noel is not fat.\n¬Shiny(tristan) ::: Tristan is not shiny.\n¬Dry(lewis) ::: Lewis is not dry.\nZany(tristan) ::: Tristan is zany.\nDry(noel) ::: Noel is dry.\nShiny(noel) ::: Noel is shiny.\nShiny(lewis) ::: Lewis is shiny.\n(∀x ((¬Straightforward(x) ∨ ¬Fat(x)))) → (Shiny(noel)) ::: If all people are not straightforward or not fat, then Noel is shiny.\n(∀x (Hard(x))) ↔ (Straightforward(x)) ::: Someone being hard is equivalent to being straightforward.\n(∀x ((Fat(x) ∧ ¬Dry(x)))) ↔ (Shiny(x)) ::: Someone being both fat and not dry is equivalent to being shiny.\n(∀x (¬Dry(x))) ↔ (Hard(x)) ::: Someone is not dry if and only if he is hard.\n(∃x (Dry(x) ∧ Hard(x))) → (Fat(lewis)) ::: If there is someone who is both dry and hard, then Lewis is fat.\n(∃x ((¬Straightforward(x) ∨ ¬Shiny(x))) → (Fat(tristan))) ::: If there is at least one people who is not straightforward or not shiny, then Tristan is fat.\n(∀x ((Hard(x) ∨ Straightforward(x))) → (¬Zany(x))) ::: If someone is hard or he is straightforward, then he is not zany.\n(¬Dry(miles)) ↔ (¬Straightforward(lewis)) ::: Miles is not dry if and only if Lewis is not straightforward.\n(¬Zany(tristan)) ↔ (¬Dry(lewis)) ::: If Tristan is not zany, then Lewis is not dry, and vice versa.\n(∀x ((Zany(x) ∧ ¬Shiny(x))) → (Fat(x))) ::: If someone is both zany and not shiny, then he is fat.\n(∀x ((Fat(x) ∧ ¬Shiny(x))) → (¬Straightforward(x) ∧ ¬Dry(x))) ::: Someone who is fat and not shiny is always not straightforward and not dry.\n(¬Hard(miles)) ↔ (Dry(miles)) ::: Miles being not hard is equivalent to Miles being dry.\n",
            "First-Order-Logic Question": "¬Fat(rolf) ::: Rolf is not fat."
        },
        "fixed": true
    },
    {
        "id": 1025,
        "raw_prog": {
            "First-Order-Logic Rules": "Fat(tristan) ::: Tristan is fat.\n¬Straightforward(tristan) ::: Tristan is not straightforward.\n¬Hard(tristan) ::: Tristan is not hard.\n¬Hard(halsey) ::: Halsey is not hard.\nStraightforward(lewis) ::: Lewis is straightforward.\n¬Fat(noel) ::: Noel is not fat.\n¬Shiny(tristan) ::: Tristan is not shiny.\n¬Dry(lewis) ::: Lewis is not dry.\nZany(tristan) ::: Tristan is zany.\nDry(noel) ::: Noel is dry.\nShiny(noel) ::: Noel is shiny.\nShiny(lewis) ::: Lewis is shiny.\n(∀x ((¬Straightforward(x)) ∨ (¬Fat(x)))) → (Shiny(noel)) ::: If all people are not straightforward or not fat, then Noel is shiny.\n(∀x (Hard(x))) ↔ (Straightforward(x)) ::: Someone being hard is equivalent to being straightforward.\n(∀x ((Fat(x) ∧ ¬Dry(x))) ↔ (Shiny(x)) ::: Someone being both fat and not dry is equivalent to being shiny.\n(∀x (¬Dry(x))) ↔ (Hard(x)) ::: Someone is not dry if and only if he is hard.\n(∃x ((Dry(x) ∧ Hard(x))) → (Fat(lewis))) ::: If there is someone who is both dry and hard, then Lewis is fat.\n(∃x ((¬Straightforward(x)) ∨ (¬Shiny(x))) → (Fat(tristan))) ::: If there is at least one people who is not straightforward or not shiny, then Tristan is fat.\n(∀x ((Hard(x)) ∨ (Straightforward(x))) → (¬Zany(x))) ::: If someone is hard or he is straightforward, then he is not zany.\n(¬Dry(miles)) ↔ (¬Straightforward(lewis)) ::: Miles is not dry if and only if Lewis is not straightforward.\n(¬Zany(tristan)) ↔ (¬Dry(lewis)) ::: If Tristan is not zany, then Lewis is not dry, and vice versa.\n(∀x ((Zany(x) ∧ ¬Shiny(x))) → (Fat(x))) ::: If someone is both zany and not shiny, then he is fat.\n(∀x ((Fat(x) ∧ ¬Shiny(x))) → ((¬Straightforward(x) ∧ ¬Dry(x))) ::: Someone who is fat and not shiny is always not straightforward and not dry.\n(¬Hard(miles)) ↔ (Dry(miles)) ::: Miles being not hard is equivalent to Miles being dry.\n",
            "First-Order-Logic Question": "Zany(sigmund) ::: Sigmund is zany."
        },
        "gram_prog": {
            "First-Order-Logic Rules": "Fat(tristan) ::: Tristan is fat.\n¬Straightforward(tristan) ::: Tristan is not straightforward.\n¬Hard(tristan) ::: Tristan is not hard.\n¬Hard(halsey) ::: Halsey is not hard.\nStraightforward(lewis) ::: Lewis is straightforward.\n¬Fat(noel) ::: Noel is not fat.\n¬Shiny(tristan) ::: Tristan is not shiny.\n¬Dry(lewis) ::: Lewis is not dry.\nZany(tristan) ::: Tristan is zany.\nDry(noel) ::: Noel is dry.\nShiny(noel) ::: Noel is shiny.\nShiny(lewis) ::: Lewis is shiny.\n(∀x ((¬Straightforward(x)) ∨ (¬Fat(x)))) → (Shiny(noel)) ::: If all people are not straightforward or not fat, then Noel is shiny.\n(∀x (Hard(x))) ↔ (Straightforward(x)) ::: Someone being hard is equivalent to being straightforward.\n∀x((Fat(x)∧¬Dry(x))) ::: Someone being both fat and not dry is equivalent to being shiny.\n(∀x (¬Dry(x))) ↔ (Hard(x)) ::: Someone is not dry if and only if he is hard.\n(∃x ((Dry(x) ∧ Hard(x))) → (Fat(lewis))) ::: If there is someone who is both dry and hard, then Lewis is fat.\n(∃x ((¬Straightforward(x)) ∨ (¬Shiny(x))) → (Fat(tristan))) ::: If there is at least one people who is not straightforward or not shiny, then Tristan is fat.\n(∀x ((Hard(x)) ∨ (Straightforward(x))) → (¬Zany(x))) ::: If someone is hard or he is straightforward, then he is not zany.\n(¬Dry(miles)) ↔ (¬Straightforward(lewis)) ::: Miles is not dry if and only if Lewis is not straightforward.\n(¬Zany(tristan)) ↔ (¬Dry(lewis)) ::: If Tristan is not zany, then Lewis is not dry, and vice versa.\n(∀x ((Zany(x) ∧ ¬Shiny(x))) → (Fat(x))) ::: If someone is both zany and not shiny, then he is fat.\n∀x((Fat(x)∧¬Shiny(x))) ::: Someone who is fat and not shiny is always not straightforward and not dry.\n(¬Hard(miles)) ↔ (Dry(miles)) ::: Miles being not hard is equivalent to Miles being dry.\n",
            "First-Order-Logic Question": "Zany(sigmund) ::: Sigmund is zany."
        },
        "diff": [
            {
                "raw": "(∀x ((Fat(x) ∧ ¬Dry(x))) ↔ (Shiny(x)) ::: Someone being both fat and not dry is equivalent to being shiny.",
                "gram": "∀x((Fat(x)∧¬Dry(x))) ::: Someone being both fat and not dry is equivalent to being shiny."
            },
            {
                "raw": "(∀x ((Fat(x) ∧ ¬Shiny(x))) → ((¬Straightforward(x) ∧ ¬Dry(x))) ::: Someone who is fat and not shiny is always not straightforward and not dry.",
                "gram": "∀x((Fat(x)∧¬Shiny(x))) ::: Someone who is fat and not shiny is always not straightforward and not dry."
            }
        ],
        "answer": "C",
        "grammar_answer": "A",
        "manual_prog": {
            "First-Order-Logic Rules": "Fat(tristan) ::: Tristan is fat.\n¬Straightforward(tristan) ::: Tristan is not straightforward.\n¬Hard(tristan) ::: Tristan is not hard.\n¬Hard(halsey) ::: Halsey is not hard.\nStraightforward(lewis) ::: Lewis is straightforward.\n¬Fat(noel) ::: Noel is not fat.\n¬Shiny(tristan) ::: Tristan is not shiny.\n¬Dry(lewis) ::: Lewis is not dry.\nZany(tristan) ::: Tristan is zany.\nDry(noel) ::: Noel is dry.\nShiny(noel) ::: Noel is shiny.\nShiny(lewis) ::: Lewis is shiny.\n(∀x ((¬Straightforward(x)) ∨ (¬Fat(x)))) → (Shiny(noel)) ::: If all people are not straightforward or not fat, then Noel is shiny.\n(∀x (Hard(x))) ↔ (Straightforward(x)) ::: Someone being hard is equivalent to being straightforward.\n(∀x ((Fat(x) ∧ ¬Dry(x))) ↔ (Shiny(x))) ::: Someone being both fat and not dry is equivalent to being shiny.\n(∀x (¬Dry(x))) ↔ (Hard(x)) ::: Someone is not dry if and only if he is hard.\n(∃x ((Dry(x) ∧ Hard(x))) → (Fat(lewis))) ::: If there is someone who is both dry and hard, then Lewis is fat.\n(∃x ((¬Straightforward(x)) ∨ (¬Shiny(x))) → (Fat(tristan))) ::: If there is at least one people who is not straightforward or not shiny, then Tristan is fat.\n(∀x ((Hard(x)) ∨ (Straightforward(x))) → (¬Zany(x))) ::: If someone is hard or he is straightforward, then he is not zany.\n(¬Dry(miles)) ↔ (¬Straightforward(lewis)) ::: Miles is not dry if and only if Lewis is not straightforward.\n(¬Zany(tristan)) ↔ (¬Dry(lewis)) ::: If Tristan is not zany, then Lewis is not dry, and vice versa.\n(∀x ((Zany(x) ∧ ¬Shiny(x))) → (Fat(x))) ::: If someone is both zany and not shiny, then he is fat.\n(∀x ((Fat(x) ∧ ¬Shiny(x))) → ((¬Straightforward(x) ∧ ¬Dry(x)))) ::: Someone who is fat and not shiny is always not straightforward and not dry.\n(¬Hard(miles)) ↔ (Dry(miles)) ::: Miles being not hard is equivalent to Miles being dry.\n",
            "First-Order-Logic Question": "Zany(sigmund) ::: Sigmund is zany."
        },
        "fixed": true
    },
    {
        "id": 1089,
        "raw_prog": {
            "First-Order-Logic Rules": "¬Crowded(howard) ::: Howard is not crowded.\nPutrid(tyra) ::: Tyra is putrid.\n¬Bewildered(rosa) ::: Rosa is not bewildered.\n¬Bewildered(howard) ::: Howard is not bewildered.\n¬Putrid(rosa) ::: Rosa is not putrid.\nStrong(godfrey) ::: Godfrey is strong.\nJolly(adam) ::: Adam is jolly.\nCrowded(kenyon) ::: Kenyon is crowded.\n¬Lovely(rose) ::: Rose is not lovely.\n¬Strong(rose) ::: Rose is not strong.\n¬Lovely(tyra) ::: Tyra is not lovely.\nStrong(rosa) ::: Rosa is strong.\n((¬Putrid(x))) ↔ ((¬Lovely(x))) ::: Someone is not putrid if and only if he is not lovely.\n(∀x ((¬Putrid(x)) ∨ (¬Strong(x)))) → (¬Bewildered(x)) ::: Someone who is eithor not putrid or not strong is always not bewildered.\n(∀x ((Strong(x) ∧ ¬Bewildered(x)))) → (Putrid(x)) ::: If someone is both strong and not bewildered, then he is putrid.\n(∀x ((Jolly(x) ∧ Putrid(x))) → (Lovely(x)) ::: Someone who is both jolly and putrid is always lovely.\n(∀x ((Lovely(x) ∧ ¬Crowded(x)))) ↔ ((Bewildered(x) ∧ Putrid(x))) ::: Someone being both lovely and not crowded is equivalent to being bewildered and putrid.\n(∃x ((Bewildered(x) ∧ ¬Lovely(x)))) → (Jolly(howard)) ::: If there is at least one people who is both bewildered and not lovely, then Howard is jolly.\n((¬Lovely(x))) ↔ ((Bewildered(x))) ::: Someone is not lovely if and only if he is bewildered.\n(∃x ((Lovely(x) ∨ ¬Strong(x)))) → (¬Crowded(godfrey)) ::: If there is at least one people who is lovely or not strong, then Godfrey is not crowded.\n(∀x ((Jolly(x) ∨ ¬Putrid(x))) → (Lovely(x)) ::: If someone is jolly or not putrid, then he is lovely.\n((¬Jolly(howard) ∧ Putrid(howard))) → (¬Bewildered(kenyon)) ::: If Howard is not jolly and Howard is putrid, then Kenyon is not bewildered.\n(∀x ((¬Crowded(x) ∧ ¬Jolly(x))) → ((Putrid(x) ∧ ¬Strong(x))) ::: If someone is not crowded and not jolly, then he is putrid and not strong.\n(∀x (Putrid(x))) → (Jolly(x)) ::: All putrid people are jolly.\n",
            "First-Order-Logic Question": "Putrid(rose) ::: Rose is putrid."
        },
        "gram_prog": {
            "First-Order-Logic Rules": "¬Crowded(howard) ::: Howard is not crowded.\nPutrid(tyra) ::: Tyra is putrid.\n¬Bewildered(rosa) ::: Rosa is not bewildered.\n¬Bewildered(howard) ::: Howard is not bewildered.\n¬Putrid(rosa) ::: Rosa is not putrid.\nStrong(godfrey) ::: Godfrey is strong.\nJolly(adam) ::: Adam is jolly.\nCrowded(kenyon) ::: Kenyon is crowded.\n¬Lovely(rose) ::: Rose is not lovely.\n¬Strong(rose) ::: Rose is not strong.\n¬Lovely(tyra) ::: Tyra is not lovely.\nStrong(rosa) ::: Rosa is strong.\n((¬Putrid(x))) ↔ ((¬Lovely(x))) ::: Someone is not putrid if and only if he is not lovely.\n(∀x ((¬Putrid(x)) ∨ (¬Strong(x)))) → (¬Bewildered(x)) ::: Someone who is eithor not putrid or not strong is always not bewildered.\n(∀x ((Strong(x) ∧ ¬Bewildered(x)))) → (Putrid(x)) ::: If someone is both strong and not bewildered, then he is putrid.\n∀x((Serious(x)∧Fresh(x))) ::: Someone who is both jolly and putrid is always lovely.\n(∀x ((Lovely(x) ∧ ¬Crowded(x)))) ↔ ((Bewildered(x) ∧ Putrid(x))) ::: Someone being both lovely and not crowded is equivalent to being bewildered and putrid.\n(∃x ((Bewildered(x) ∧ ¬Lovely(x)))) → (Jolly(howard)) ::: If there is at least one people who is both bewildered and not lovely, then Howard is jolly.\n((¬Lovely(x))) ↔ ((Bewildered(x))) ::: Someone is not lovely if and only if he is bewildered.\n(∃x ((Lovely(x) ∨ ¬Strong(x)))) → (¬Crowded(godfrey)) ::: If there is at least one people who is lovely or not strong, then Godfrey is not crowded.\n∀x((Serious(x)∨¬Blue(x))) ::: If someone is jolly or not putrid, then he is lovely.\n((¬Jolly(howard) ∧ Putrid(howard))) → (¬Bewildered(kenyon)) ::: If Howard is not jolly and Howard is putrid, then Kenyon is not bewildered.\n∀x((¬Concerned(x)∧¬Fresh(x))) ::: If someone is not crowded and not jolly, then he is putrid and not strong.\n(∀x (Putrid(x))) → (Jolly(x)) ::: All putrid people are jolly.\n",
            "First-Order-Logic Question": "Putrid(rose) ::: Rose is putrid."
        },
        "diff": [
            {
                "raw": "(∀x ((Jolly(x) ∧ Putrid(x))) → (Lovely(x)) ::: Someone who is both jolly and putrid is always lovely.",
                "gram": "∀x((Serious(x)∧Fresh(x))) ::: Someone who is both jolly and putrid is always lovely."
            },
            {
                "raw": "(∀x ((Jolly(x) ∨ ¬Putrid(x))) → (Lovely(x)) ::: If someone is jolly or not putrid, then he is lovely.",
                "gram": "∀x((Serious(x)∨¬Blue(x))) ::: If someone is jolly or not putrid, then he is lovely."
            },
            {
                "raw": "(∀x ((¬Crowded(x) ∧ ¬Jolly(x))) → ((Putrid(x) ∧ ¬Strong(x))) ::: If someone is not crowded and not jolly, then he is putrid and not strong.",
                "gram": "∀x((¬Concerned(x)∧¬Fresh(x))) ::: If someone is not crowded and not jolly, then he is putrid and not strong."
            }
        ],
        "answer": "B",
        "grammar_answer": "A",
        "manual_prog": {
            "First-Order-Logic Rules": "¬Crowded(howard) ::: Howard is not crowded.\nPutrid(tyra) ::: Tyra is putrid.\n¬Bewildered(rosa) ::: Rosa is not bewildered.\n¬Bewildered(howard) ::: Howard is not bewildered.\n¬Putrid(rosa) ::: Rosa is not putrid.\nStrong(godfrey) ::: Godfrey is strong.\nJolly(adam) ::: Adam is jolly.\nCrowded(kenyon) ::: Kenyon is crowded.\n¬Lovely(rose) ::: Rose is not lovely.\n¬Strong(rose) ::: Rose is not strong.\n¬Lovely(tyra) ::: Tyra is not lovely.\nStrong(rosa) ::: Rosa is strong.\n((¬Putrid(x))) ↔ ((¬Lovely(x))) ::: Someone is not putrid if and only if he is not lovely.\n(∀x ((¬Putrid(x)) ∨ (¬Strong(x)))) → (¬Bewildered(x)) ::: Someone who is eithor not putrid or not strong is always not bewildered.\n(∀x ((Strong(x) ∧ ¬Bewildered(x)))) → (Putrid(x)) ::: If someone is both strong and not bewildered, then he is putrid.\n(∀x ((Jolly(x) ∧ Putrid(x))) → (Lovely(x))) ::: Someone who is both jolly and putrid is always lovely.\n(∀x ((Lovely(x) ∧ ¬Crowded(x)))) ↔ ((Bewildered(x) ∧ Putrid(x))) ::: Someone being both lovely and not crowded is equivalent to being bewildered and putrid.\n(∃x ((Bewildered(x) ∧ ¬Lovely(x)))) → (Jolly(howard)) ::: If there is at least one people who is both bewildered and not lovely, then Howard is jolly.\n((¬Lovely(x))) ↔ ((Bewildered(x))) ::: Someone is not lovely if and only if he is bewildered.\n(∃x ((Lovely(x) ∨ ¬Strong(x)))) → (¬Crowded(godfrey)) ::: If there is at least one people who is lovely or not strong, then Godfrey is not crowded.\n(∀x ((Jolly(x) ∨ ¬Putrid(x))) → (Lovely(x))) ::: If someone is jolly or not putrid, then he is lovely.\n((¬Jolly(howard) ∧ Putrid(howard))) → (¬Bewildered(kenyon)) ::: If Howard is not jolly and Howard is putrid, then Kenyon is not bewildered.\n(∀x ((¬Crowded(x) ∧ ¬Jolly(x))) → ((Putrid(x) ∧ ¬Strong(x)))) ::: If someone is not crowded and not jolly, then he is putrid and not strong.\n(∀x (Putrid(x))) → (Jolly(x)) ::: All putrid people are jolly.\n",
            "First-Order-Logic Question": "Putrid(rose) ::: Rose is putrid."
        },
        "fixed": true
    },
    {
        "id": 1126,
        "raw_prog": {
            "First-Order-Logic Rules": "¬Different(brandi) ::: Brandi is not different.\nAlert(julie) ::: Julie is alert.\nLong(leroy) ::: Leroy is long.\n¬Poised(leroy) ::: Leroy is not poised.\nLong(julie) ::: Julie is long.\nPoised(tristan) ::: Tristan is poised.\n¬Faithful(cyril) ::: Cyril is not faithful.\n¬Different(tristan) ::: Tristan is not different.\n¬Different(cyril) ::: Cyril is not different.\nLong(cyril) ::: Cyril is long.\nLong(brandi) ::: Brandi is long.\nPoised(shane) ::: Shane is poised.\n(∀x (Faithful(x) ∨ ¬Poised(x))) → (∀x (¬Short(x))) ::: Someone who is eithor faithful or not poised is always not short.\n(∀x ((¬Faithful(x)) ↔ (¬Different(x)))) ::: If someone is not faithful, then he is not different, and vice versa.\n(∃x (Short(x) ∨ ¬Different(x))) → ((Alert(julie) ∧ Faithful(cyril))) ::: If there is at least one people who is either short or not different, then Julie is alert and Cyril is faithful.\n(Alert(x)) ↔ (Poised(x)) ::: Someone is alert if and only if he is poised.\n((¬Poised(julie) ∨ Different(tristan))) → (Long(leroy)) ::: If Julie is not poised or Tristan is different, then Leroy is long.\n(∀x (Short(x))) ↔ (Faithful(x)) ::: If someone is short, then he is faithful, and vice versa.\n((Alert(brandi) ∨ Short(cyril))) → (¬Poised(cyril)) ::: If Brandi is alert or Cyril is short, then Cyril is not poised.\n(∃x (Alert(x) ∨ ¬Poised(x))) → (¬Long(shane)) ::: If there is at least one people who is alert or not poised, then Shane is not long.\n(∀x ((¬Poised(x) ∧ ¬Short(x))) → (¬Alert(x))) ::: If someone is neither poised nor short, then he is not alert.\n(∀x (Alert(x))) → ((¬Different(neal) ∧ Faithful(julie))) ::: If everyone is alert, then Neal is not different and Julie is faithful.\n(∀x ((¬Faithful(x)) → (Alert(x))) ::: If someone is not faithful, then he is alert.\n(∀x ((Long(x) ∨ ¬Different(x)) → (Alert(x))) ::: If someone is he or not long is not different, then he is alert.\n",
            "First-Order-Logic Question": "¬Faithful(leroy) ::: Leroy is not faithful."
        },
        "gram_prog": {
            "First-Order-Logic Rules": "¬Different(brandi) ::: Brandi is not different.\nAlert(julie) ::: Julie is alert.\nLong(leroy) ::: Leroy is long.\n¬Poised(leroy) ::: Leroy is not poised.\nLong(julie) ::: Julie is long.\nPoised(tristan) ::: Tristan is poised.\n¬Faithful(cyril) ::: Cyril is not faithful.\n¬Different(tristan) ::: Tristan is not different.\n¬Different(cyril) ::: Cyril is not different.\nLong(cyril) ::: Cyril is long.\nLong(brandi) ::: Brandi is long.\nPoised(shane) ::: Shane is poised.\n(∀x (Faithful(x) ∨ ¬Poised(x))) → (∀x (¬Short(x))) ::: Someone who is eithor faithful or not poised is always not short.\n(∀x ((¬Faithful(x)) ↔ (¬Different(x)))) ::: If someone is not faithful, then he is not different, and vice versa.\n(∃x (Short(x) ∨ ¬Different(x))) → ((Alert(julie) ∧ Faithful(cyril))) ::: If there is at least one people who is either short or not different, then Julie is alert and Cyril is faithful.\n(Alert(x)) ↔ (Poised(x)) ::: Someone is alert if and only if he is poised.\n((¬Poised(julie) ∨ Different(tristan))) → (Long(leroy)) ::: If Julie is not poised or Tristan is different, then Leroy is long.\n(∀x (Short(x))) ↔ (Faithful(x)) ::: If someone is short, then he is faithful, and vice versa.\n((Alert(brandi) ∨ Short(cyril))) → (¬Poised(cyril)) ::: If Brandi is alert or Cyril is short, then Cyril is not poised.\n(∃x (Alert(x) ∨ ¬Poised(x))) → (¬Long(shane)) ::: If there is at least one people who is alert or not poised, then Shane is not long.\n(∀x ((¬Poised(x) ∧ ¬Short(x))) → (¬Alert(x))) ::: If someone is neither poised nor short, then he is not alert.\n(∀x (Alert(x))) → ((¬Different(neal) ∧ Faithful(julie))) ::: If everyone is alert, then Neal is not different and Julie is faithful.\n∀x((¬Faithful(x))→Alert(x)) ::: If someone is not faithful, then he is alert.\n∀x((Long(x)∨¬Different(x))) ::: If someone is he or not long is not different, then he is alert.\n",
            "First-Order-Logic Question": "¬Faithful(leroy) ::: Leroy is not faithful."
        },
        "diff": [
            {
                "raw": "(∀x ((Long(x) ∨ ¬Different(x)) → (Alert(x))) ::: If someone is he or not long is not different, then he is alert.",
                "gram": "∀x((Long(x)∨¬Different(x))) ::: If someone is he or not long is not different, then he is alert."
            }
        ],
        "answer": "C",
        "grammar_answer": "A",
        "manual_prog": {
            "First-Order-Logic Rules": "¬Different(brandi) ::: Brandi is not different.\nAlert(julie) ::: Julie is alert.\nLong(leroy) ::: Leroy is long.\n¬Poised(leroy) ::: Leroy is not poised.\nLong(julie) ::: Julie is long.\nPoised(tristan) ::: Tristan is poised.\n¬Faithful(cyril) ::: Cyril is not faithful.\n¬Different(tristan) ::: Tristan is not different.\n¬Different(cyril) ::: Cyril is not different.\nLong(cyril) ::: Cyril is long.\nLong(brandi) ::: Brandi is long.\nPoised(shane) ::: Shane is poised.\n(∀x (Faithful(x) ∨ ¬Poised(x))) → (∀x (¬Short(x))) ::: Someone who is eithor faithful or not poised is always not short.\n(∀x ((¬Faithful(x)) ↔ (¬Different(x)))) ::: If someone is not faithful, then he is not different, and vice versa.\n(∃x (Short(x) ∨ ¬Different(x))) → ((Alert(julie) ∧ Faithful(cyril))) ::: If there is at least one people who is either short or not different, then Julie is alert and Cyril is faithful.\n(Alert(x)) ↔ (Poised(x)) ::: Someone is alert if and only if he is poised.\n((¬Poised(julie) ∨ Different(tristan))) → (Long(leroy)) ::: If Julie is not poised or Tristan is different, then Leroy is long.\n(∀x (Short(x))) ↔ (Faithful(x)) ::: If someone is short, then he is faithful, and vice versa.\n((Alert(brandi) ∨ Short(cyril))) → (¬Poised(cyril)) ::: If Brandi is alert or Cyril is short, then Cyril is not poised.\n(∃x (Alert(x) ∨ ¬Poised(x))) → (¬Long(shane)) ::: If there is at least one people who is alert or not poised, then Shane is not long.\n(∀x ((¬Poised(x) ∧ ¬Short(x))) → (¬Alert(x))) ::: If someone is neither poised nor short, then he is not alert.\n(∀x (Alert(x))) → ((¬Different(neal) ∧ Faithful(julie))) ::: If everyone is alert, then Neal is not different and Julie is faithful.\n(∀x ((¬Faithful(x)) → (Alert(x))) ::: If someone is not faithful, then he is alert.\n(∀x ((Long(x) ∨ ¬Different(x)) → (Alert(x)))) ::: If someone is he or not long is not different, then he is alert.\n",
            "First-Order-Logic Question": "¬Faithful(leroy) ::: Leroy is not faithful."
        },
        "fixed": true
    },
    {
        "id": 1127,
        "raw_prog": {
            "First-Order-Logic Rules": "¬Different(brandi) ::: Brandi is not different.\nAlert(julie) ::: Julie is alert.\nLong(leroy) ::: Leroy is long.\n¬Poised(leroy) ::: Leroy is not poised.\nLong(julie) ::: Julie is long.\nPoised(tristan) ::: Tristan is poised.\n¬Faithful(cyril) ::: Cyril is not faithful.\n¬Different(tristan) ::: Tristan is not different.\n¬Different(cyril) ::: Cyril is not different.\nLong(cyril) ::: Cyril is long.\nLong(brandi) ::: Brandi is long.\nPoised(shane) ::: Shane is poised.\n(∀x (Faithful(x) ∨ ¬Poised(x))) → (∀x (¬Short(x))) ::: Someone who is eithor faithful or not poised is always not short.\n(∀x ((¬Faithful(x)) ↔ (¬Different(x)))) ::: If someone is not faithful, then he is not different, and vice versa.\n(∃x (Short(x) ∨ ¬Different(x))) → ((Alert(julie) ∧ Faithful(cyril))) ::: If there is at least one people who is either short or not different, then Julie is alert and Cyril is faithful.\n(Alert(x)) ↔ (Poised(x)) ::: Someone is alert if and only if he is poised.\n((¬Poised(julie) ∨ Different(tristan))) → (Long(leroy)) ::: If Julie is not poised or Tristan is different, then Leroy is long.\n(∀x (Short(x))) ↔ (Faithful(x)) ::: If someone is short, then he is faithful, and vice versa.\n((Alert(brandi) ∨ Short(cyril))) → (¬Poised(cyril)) ::: If Brandi is alert or Cyril is short, then Cyril is not poised.\n(∃x (Alert(x) ∨ ¬Poised(x))) → (¬Long(shane)) ::: If there is at least one people who is alert or not poised, then Shane is not long.\n(∀x ((¬Poised(x) ∧ ¬Short(x))) → (¬Alert(x))) ::: If someone is neither poised nor short, then he is not alert.\n(∀x (Alert(x))) → ((¬Different(neal) ∧ Faithful(julie))) ::: If everyone is alert, then Neal is not different and Julie is faithful.\n(∀x ((¬Faithful(x)) → (Alert(x))) ::: If someone is not faithful, then he is alert.\n(∀x ((Long(x) ∨ ¬Different(x)) → (Alert(x))) ::: If someone is he or not long is not different, then he is alert.\n",
            "First-Order-Logic Question": "Faithful(leroy) ::: Leroy is faithful."
        },
        "gram_prog": {
            "First-Order-Logic Rules": "¬Different(brandi) ::: Brandi is not different.\nAlert(julie) ::: Julie is alert.\nLong(leroy) ::: Leroy is long.\n¬Poised(leroy) ::: Leroy is not poised.\nLong(julie) ::: Julie is long.\nPoised(tristan) ::: Tristan is poised.\n¬Faithful(cyril) ::: Cyril is not faithful.\n¬Different(tristan) ::: Tristan is not different.\n¬Different(cyril) ::: Cyril is not different.\nLong(cyril) ::: Cyril is long.\nLong(brandi) ::: Brandi is long.\nPoised(shane) ::: Shane is poised.\n(∀x (Faithful(x) ∨ ¬Poised(x))) → (∀x (¬Short(x))) ::: Someone who is eithor faithful or not poised is always not short.\n(∀x ((¬Faithful(x)) ↔ (¬Different(x)))) ::: If someone is not faithful, then he is not different, and vice versa.\n(∃x (Short(x) ∨ ¬Different(x))) → ((Alert(julie) ∧ Faithful(cyril))) ::: If there is at least one people who is either short or not different, then Julie is alert and Cyril is faithful.\n(Alert(x)) ↔ (Poised(x)) ::: Someone is alert if and only if he is poised.\n((¬Poised(julie) ∨ Different(tristan))) → (Long(leroy)) ::: If Julie is not poised or Tristan is different, then Leroy is long.\n(∀x (Short(x))) ↔ (Faithful(x)) ::: If someone is short, then he is faithful, and vice versa.\n((Alert(brandi) ∨ Short(cyril))) → (¬Poised(cyril)) ::: If Brandi is alert or Cyril is short, then Cyril is not poised.\n(∃x (Alert(x) ∨ ¬Poised(x))) → (¬Long(shane)) ::: If there is at least one people who is alert or not poised, then Shane is not long.\n(∀x ((¬Poised(x) ∧ ¬Short(x))) → (¬Alert(x))) ::: If someone is neither poised nor short, then he is not alert.\n(∀x (Alert(x))) → ((¬Different(neal) ∧ Faithful(julie))) ::: If everyone is alert, then Neal is not different and Julie is faithful.\n∀x((¬Faithful(x))→Alert(x)) ::: If someone is not faithful, then he is alert.\n∀x((Long(x)∨¬Different(x))) ::: If someone is he or not long is not different, then he is alert.\n",
            "First-Order-Logic Question": "Faithful(leroy) ::: Leroy is faithful."
        },
        "diff": [
            {
                "raw": "(∀x ((Long(x) ∨ ¬Different(x)) → (Alert(x))) ::: If someone is he or not long is not different, then he is alert.",
                "gram": "∀x((Long(x)∨¬Different(x))) ::: If someone is he or not long is not different, then he is alert."
            }
        ],
        "answer": "C",
        "grammar_answer": "A",
        "manual_prog": {
            "First-Order-Logic Rules": "¬Different(brandi) ::: Brandi is not different.\nAlert(julie) ::: Julie is alert.\nLong(leroy) ::: Leroy is long.\n¬Poised(leroy) ::: Leroy is not poised.\nLong(julie) ::: Julie is long.\nPoised(tristan) ::: Tristan is poised.\n¬Faithful(cyril) ::: Cyril is not faithful.\n¬Different(tristan) ::: Tristan is not different.\n¬Different(cyril) ::: Cyril is not different.\nLong(cyril) ::: Cyril is long.\nLong(brandi) ::: Brandi is long.\nPoised(shane) ::: Shane is poised.\n(∀x (Faithful(x) ∨ ¬Poised(x))) → (∀x (¬Short(x))) ::: Someone who is eithor faithful or not poised is always not short.\n(∀x ((¬Faithful(x)) ↔ (¬Different(x)))) ::: If someone is not faithful, then he is not different, and vice versa.\n(∃x (Short(x) ∨ ¬Different(x))) → ((Alert(julie) ∧ Faithful(cyril))) ::: If there is at least one people who is either short or not different, then Julie is alert and Cyril is faithful.\n(Alert(x)) ↔ (Poised(x)) ::: Someone is alert if and only if he is poised.\n((¬Poised(julie) ∨ Different(tristan))) → (Long(leroy)) ::: If Julie is not poised or Tristan is different, then Leroy is long.\n(∀x (Short(x))) ↔ (Faithful(x)) ::: If someone is short, then he is faithful, and vice versa.\n((Alert(brandi) ∨ Short(cyril))) → (¬Poised(cyril)) ::: If Brandi is alert or Cyril is short, then Cyril is not poised.\n(∃x (Alert(x) ∨ ¬Poised(x))) → (¬Long(shane)) ::: If there is at least one people who is alert or not poised, then Shane is not long.\n(∀x ((¬Poised(x) ∧ ¬Short(x))) → (¬Alert(x))) ::: If someone is neither poised nor short, then he is not alert.\n(∀x (Alert(x))) → ((¬Different(neal) ∧ Faithful(julie))) ::: If everyone is alert, then Neal is not different and Julie is faithful.\n(∀x ((¬Faithful(x)) → (Alert(x))) ::: If someone is not faithful, then he is alert.\n(∀x ((Long(x) ∨ ¬Different(x)) → (Alert(x)))) ::: If someone is he or not long is not different, then he is alert.\n",
            "First-Order-Logic Question": "Faithful(leroy) ::: Leroy is faithful."
        },
        "fixed": true
    },
    {
        "id": 1128,
        "raw_prog": {
            "First-Order-Logic Rules": "¬Different(brandi) ::: Brandi is not different.\nAlert(julie) ::: Julie is alert.\nLong(leroy) ::: Leroy is long.\n¬Poised(leroy) ::: Leroy is not poised.\nLong(julie) ::: Julie is long.\nPoised(tristan) ::: Tristan is poised.\n¬Faithful(cyril) ::: Cyril is not faithful.\n¬Different(tristan) ::: Tristan is not different.\n¬Different(cyril) ::: Cyril is not different.\nLong(cyril) ::: Cyril is long.\nLong(brandi) ::: Brandi is long.\nPoised(shane) ::: Shane is poised.\n(∀x (Faithful(x) ∨ ¬Poised(x))) → (∀x (¬Short(x))) ::: Someone who is eithor faithful or not poised is always not short.\n(∀x ((¬Faithful(x)) ↔ (¬Different(x)))) ::: If someone is not faithful, then he is not different, and vice versa.\n(∃x (Short(x) ∨ ¬Different(x))) → ((Alert(julie) ∧ Faithful(cyril))) ::: If there is at least one people who is either short or not different, then Julie is alert and Cyril is faithful.\n(Alert(x)) ↔ (Poised(x)) ::: Someone is alert if and only if he is poised.\n((¬Poised(julie) ∨ Different(tristan))) → (Long(leroy)) ::: If Julie is not poised or Tristan is different, then Leroy is long.\n(∀x (Short(x))) ↔ (Faithful(x)) ::: If someone is short, then he is faithful, and vice versa.\n((Alert(brandi) ∨ Short(cyril))) → (¬Poised(cyril)) ::: If Brandi is alert or Cyril is short, then Cyril is not poised.\n(∃x (Alert(x) ∨ ¬Poised(x))) → (¬Long(shane)) ::: If there is at least one people who is alert or not poised, then Shane is not long.\n(∀x ((¬Poised(x) ∧ ¬Short(x))) → (¬Alert(x))) ::: If someone is neither poised nor short, then he is not alert.\n(∀x (Alert(x))) → ((¬Different(neal) ∧ Faithful(julie))) ::: If everyone is alert, then Neal is not different and Julie is faithful.\n(∀x ((¬Faithful(x)) → (Alert(x))) ::: If someone is not faithful, then he is alert.\n(∀x ((Long(x) ∨ ¬Different(x)) → (Alert(x))) ::: If someone is he or not long is not different, then he is alert.\n",
            "First-Order-Logic Question": "Alert(leroy) ::: Leroy is alert."
        },
        "gram_prog": {
            "First-Order-Logic Rules": "¬Different(brandi) ::: Brandi is not different.\nAlert(julie) ::: Julie is alert.\nLong(leroy) ::: Leroy is long.\n¬Poised(leroy) ::: Leroy is not poised.\nLong(julie) ::: Julie is long.\nPoised(tristan) ::: Tristan is poised.\n¬Faithful(cyril) ::: Cyril is not faithful.\n¬Different(tristan) ::: Tristan is not different.\n¬Different(cyril) ::: Cyril is not different.\nLong(cyril) ::: Cyril is long.\nLong(brandi) ::: Brandi is long.\nPoised(shane) ::: Shane is poised.\n(∀x (Faithful(x) ∨ ¬Poised(x))) → (∀x (¬Short(x))) ::: Someone who is eithor faithful or not poised is always not short.\n(∀x ((¬Faithful(x)) ↔ (¬Different(x)))) ::: If someone is not faithful, then he is not different, and vice versa.\n(∃x (Short(x) ∨ ¬Different(x))) → ((Alert(julie) ∧ Faithful(cyril))) ::: If there is at least one people who is either short or not different, then Julie is alert and Cyril is faithful.\n(Alert(x)) ↔ (Poised(x)) ::: Someone is alert if and only if he is poised.\n((¬Poised(julie) ∨ Different(tristan))) → (Long(leroy)) ::: If Julie is not poised or Tristan is different, then Leroy is long.\n(∀x (Short(x))) ↔ (Faithful(x)) ::: If someone is short, then he is faithful, and vice versa.\n((Alert(brandi) ∨ Short(cyril))) → (¬Poised(cyril)) ::: If Brandi is alert or Cyril is short, then Cyril is not poised.\n(∃x (Alert(x) ∨ ¬Poised(x))) → (¬Long(shane)) ::: If there is at least one people who is alert or not poised, then Shane is not long.\n(∀x ((¬Poised(x) ∧ ¬Short(x))) → (¬Alert(x))) ::: If someone is neither poised nor short, then he is not alert.\n(∀x (Alert(x))) → ((¬Different(neal) ∧ Faithful(julie))) ::: If everyone is alert, then Neal is not different and Julie is faithful.\n∀x((¬Faithful(x))→Alert(x)) ::: If someone is not faithful, then he is alert.\n∀x((Long(x)∨¬Different(x))) ::: If someone is he or not long is not different, then he is alert.\n",
            "First-Order-Logic Question": "Alert(leroy) ::: Leroy is alert."
        },
        "diff": [
            {
                "raw": "(∀x ((Long(x) ∨ ¬Different(x)) → (Alert(x))) ::: If someone is he or not long is not different, then he is alert.",
                "gram": "∀x((Long(x)∨¬Different(x))) ::: If someone is he or not long is not different, then he is alert."
            }
        ],
        "answer": "B",
        "grammar_answer": "A",
        "manual_prog": {
            "First-Order-Logic Rules": "¬Different(brandi) ::: Brandi is not different.\nAlert(julie) ::: Julie is alert.\nLong(leroy) ::: Leroy is long.\n¬Poised(leroy) ::: Leroy is not poised.\nLong(julie) ::: Julie is long.\nPoised(tristan) ::: Tristan is poised.\n¬Faithful(cyril) ::: Cyril is not faithful.\n¬Different(tristan) ::: Tristan is not different.\n¬Different(cyril) ::: Cyril is not different.\nLong(cyril) ::: Cyril is long.\nLong(brandi) ::: Brandi is long.\nPoised(shane) ::: Shane is poised.\n(∀x (Faithful(x) ∨ ¬Poised(x))) → (∀x (¬Short(x))) ::: Someone who is eithor faithful or not poised is always not short.\n(∀x ((¬Faithful(x)) ↔ (¬Different(x)))) ::: If someone is not faithful, then he is not different, and vice versa.\n(∃x (Short(x) ∨ ¬Different(x))) → ((Alert(julie) ∧ Faithful(cyril))) ::: If there is at least one people who is either short or not different, then Julie is alert and Cyril is faithful.\n(Alert(x)) ↔ (Poised(x)) ::: Someone is alert if and only if he is poised.\n((¬Poised(julie) ∨ Different(tristan))) → (Long(leroy)) ::: If Julie is not poised or Tristan is different, then Leroy is long.\n(∀x (Short(x))) ↔ (Faithful(x)) ::: If someone is short, then he is faithful, and vice versa.\n((Alert(brandi) ∨ Short(cyril))) → (¬Poised(cyril)) ::: If Brandi is alert or Cyril is short, then Cyril is not poised.\n(∃x (Alert(x) ∨ ¬Poised(x))) → (¬Long(shane)) ::: If there is at least one people who is alert or not poised, then Shane is not long.\n(∀x ((¬Poised(x) ∧ ¬Short(x))) → (¬Alert(x))) ::: If someone is neither poised nor short, then he is not alert.\n(∀x (Alert(x))) → ((¬Different(neal) ∧ Faithful(julie))) ::: If everyone is alert, then Neal is not different and Julie is faithful.\n(∀x ((¬Faithful(x)) → (Alert(x))) ::: If someone is not faithful, then he is alert.\n(∀x ((Long(x) ∨ ¬Different(x)) → (Alert(x)))) ::: If someone is he or not long is not different, then he is alert.\n",
            "First-Order-Logic Question": "Alert(leroy) ::: Leroy is alert."
        },
        "fixed": true
    },
    {
        "id": 1130,
        "raw_prog": {
            "First-Order-Logic Rules": "¬Different(brandi) ::: Brandi is not different.\nAlert(julie) ::: Julie is alert.\nLong(leroy) ::: Leroy is long.\n¬Poised(leroy) ::: Leroy is not poised.\nLong(julie) ::: Julie is long.\nPoised(tristan) ::: Tristan is poised.\n¬Faithful(cyril) ::: Cyril is not faithful.\n¬Different(tristan) ::: Tristan is not different.\n¬Different(cyril) ::: Cyril is not different.\nLong(cyril) ::: Cyril is long.\nLong(brandi) ::: Brandi is long.\nPoised(shane) ::: Shane is poised.\n(∀x (Faithful(x) ∨ ¬Poised(x))) → (∀x (¬Short(x))) ::: Someone who is eithor faithful or not poised is always not short.\n(∀x ((¬Faithful(x)) ↔ (¬Different(x)))) ::: If someone is not faithful, then he is not different, and vice versa.\n(∃x (Short(x) ∨ ¬Different(x))) → ((Alert(julie) ∧ Faithful(cyril))) ::: If there is at least one people who is either short or not different, then Julie is alert and Cyril is faithful.\n(Alert(x)) ↔ (Poised(x)) ::: Someone is alert if and only if he is poised.\n((¬Poised(julie) ∨ Different(tristan))) → (Long(leroy)) ::: If Julie is not poised or Tristan is different, then Leroy is long.\n(∀x (Short(x))) ↔ (Faithful(x)) ::: If someone is short, then he is faithful, and vice versa.\n((Alert(brandi) ∨ Short(cyril))) → (¬Poised(cyril)) ::: If Brandi is alert or Cyril is short, then Cyril is not poised.\n(∃x (Alert(x) ∨ ¬Poised(x))) → (¬Long(shane)) ::: If there is at least one people who is alert or not poised, then Shane is not long.\n(∀x ((¬Poised(x) ∧ ¬Short(x))) → (¬Alert(x))) ::: If someone is neither poised nor short, then he is not alert.\n(∀x (Alert(x))) → ((¬Different(neal) ∧ Faithful(julie))) ::: If everyone is alert, then Neal is not different and Julie is faithful.\n(∀x (¬Faithful(x))) → (Alert(x)) ::: If someone is not faithful, then he is alert.\n(∀x ((x ∨ ¬Long(x)) ↔ ¬Different(x))) ::: If someone is he or not long is not different, then he is alert.\n",
            "First-Order-Logic Question": "¬Short(shane) ::: Shane is not short."
        },
        "gram_prog": {
            "First-Order-Logic Rules": "¬Different(brandi) ::: Brandi is not different.\nAlert(julie) ::: Julie is alert.\nLong(leroy) ::: Leroy is long.\n¬Poised(leroy) ::: Leroy is not poised.\nLong(julie) ::: Julie is long.\nPoised(tristan) ::: Tristan is poised.\n¬Faithful(cyril) ::: Cyril is not faithful.\n¬Different(tristan) ::: Tristan is not different.\n¬Different(cyril) ::: Cyril is not different.\nLong(cyril) ::: Cyril is long.\nLong(brandi) ::: Brandi is long.\nPoised(shane) ::: Shane is poised.\n(∀x (Faithful(x) ∨ ¬Poised(x))) → (∀x (¬Short(x))) ::: Someone who is eithor faithful or not poised is always not short.\n(∀x ((¬Faithful(x)) ↔ (¬Different(x)))) ::: If someone is not faithful, then he is not different, and vice versa.\n(∃x (Short(x) ∨ ¬Different(x))) → ((Alert(julie) ∧ Faithful(cyril))) ::: If there is at least one people who is either short or not different, then Julie is alert and Cyril is faithful.\n(Alert(x)) ↔ (Poised(x)) ::: Someone is alert if and only if he is poised.\n((¬Poised(julie) ∨ Different(tristan))) → (Long(leroy)) ::: If Julie is not poised or Tristan is different, then Leroy is long.\n(∀x (Short(x))) ↔ (Faithful(x)) ::: If someone is short, then he is faithful, and vice versa.\n((Alert(brandi) ∨ Short(cyril))) → (¬Poised(cyril)) ::: If Brandi is alert or Cyril is short, then Cyril is not poised.\n(∃x (Alert(x) ∨ ¬Poised(x))) → (¬Long(shane)) ::: If there is at least one people who is alert or not poised, then Shane is not long.\n(∀x ((¬Poised(x) ∧ ¬Short(x))) → (¬Alert(x))) ::: If someone is neither poised nor short, then he is not alert.\n(∀x (Alert(x))) → ((¬Different(neal) ∧ Faithful(julie))) ::: If everyone is alert, then Neal is not different and Julie is faithful.\n(∀x (¬Faithful(x))) → (Alert(x)) ::: If someone is not faithful, then he is alert.\n∀x((¬Long(x)↔¬Different(x))) ::: If someone is he or not long is not different, then he is alert.\n",
            "First-Order-Logic Question": "¬Short(shane) ::: Shane is not short."
        },
        "diff": [],
        "answer": "C",
        "grammar_answer": "A",
        "manual_prog": {
            "First-Order-Logic Rules": "¬Different(brandi) ::: Brandi is not different.\nAlert(julie) ::: Julie is alert.\nLong(leroy) ::: Leroy is long.\n¬Poised(leroy) ::: Leroy is not poised.\nLong(julie) ::: Julie is long.\nPoised(tristan) ::: Tristan is poised.\n¬Faithful(cyril) ::: Cyril is not faithful.\n¬Different(tristan) ::: Tristan is not different.\n¬Different(cyril) ::: Cyril is not different.\nLong(cyril) ::: Cyril is long.\nLong(brandi) ::: Brandi is long.\nPoised(shane) ::: Shane is poised.\n(∀x (Faithful(x) ∨ ¬Poised(x))) → (∀x (¬Short(x))) ::: Someone who is eithor faithful or not poised is always not short.\n(∀x ((¬Faithful(x)) ↔ (¬Different(x)))) ::: If someone is not faithful, then he is not different, and vice versa.\n(∃x (Short(x) ∨ ¬Different(x))) → ((Alert(julie) ∧ Faithful(cyril))) ::: If there is at least one people who is either short or not different, then Julie is alert and Cyril is faithful.\n(Alert(x)) ↔ (Poised(x)) ::: Someone is alert if and only if he is poised.\n((¬Poised(julie) ∨ Different(tristan))) → (Long(leroy)) ::: If Julie is not poised or Tristan is different, then Leroy is long.\n(∀x (Short(x))) ↔ (Faithful(x)) ::: If someone is short, then he is faithful, and vice versa.\n((Alert(brandi) ∨ Short(cyril))) → (¬Poised(cyril)) ::: If Brandi is alert or Cyril is short, then Cyril is not poised.\n(∃x (Alert(x) ∨ ¬Poised(x))) → (¬Long(shane)) ::: If there is at least one people who is alert or not poised, then Shane is not long.\n(∀x ((¬Poised(x) ∧ ¬Short(x))) → (¬Alert(x))) ::: If someone is neither poised nor short, then he is not alert.\n(∀x (Alert(x))) → ((¬Different(neal) ∧ Faithful(julie))) ::: If everyone is alert, then Neal is not different and Julie is faithful.\n(∀x (¬Faithful(x))) → (Alert(x)) ::: If someone is not faithful, then he is alert.\n(∀x ((x ∨ ¬Long(x)) ↔ ¬Different(x))) ::: If someone is he or not long is not different, then he is alert.\n",
            "First-Order-Logic Question": "¬Short(shane) ::: Shane is not short."
        },
        "fixed": true
    },
    {
        "id": 1134,
        "raw_prog": {
            "First-Order-Logic Rules": "¬Different(brandi) ::: Brandi is not different.\nAlert(julie) ::: Julie is alert.\nLong(leroy) ::: Leroy is long.\n¬Poised(leroy) ::: Leroy is not poised.\nLong(julie) ::: Julie is long.\nPoised(tristan) ::: Tristan is poised.\n¬Faithful(cyril) ::: Cyril is not faithful.\n¬Different(tristan) ::: Tristan is not different.\n¬Different(cyril) ::: Cyril is not different.\nLong(cyril) ::: Cyril is long.\nLong(brandi) ::: Brandi is long.\nPoised(shane) ::: Shane is poised.\n(∀x (Faithful(x) ∨ ¬Poised(x))) → (∀x (¬Short(x))) ::: Someone who is eithor faithful or not poised is always not short.\n(∀x (¬Faithful(x))) ↔ (∀x (¬Different(x))) ::: If someone is not faithful, then he is not different, and vice versa.\n(∃x (Short(x) ∨ ¬Different(x))) → ((Alert(julie) ∧ Faithful(cyril))) ::: If there is at least one people who is either short or not different, then Julie is alert and Cyril is faithful.\n(Alert(x)) ↔ (Poised(x)) ::: Someone is alert if and only if he is poised.\n((¬Poised(julie) ∨ Different(tristan))) → (Long(leroy)) ::: If Julie is not poised or Tristan is different, then Leroy is long.\n(∀x (Short(x))) ↔ (∀x (Faithful(x))) ::: If someone is short, then he is faithful, and vice versa.\n((Alert(brandi) ∨ Short(cyril))) → (¬Poised(cyril)) ::: If Brandi is alert or Cyril is short, then Cyril is not poised.\n(∃x (Alert(x) ∨ ¬Poised(x))) → (¬Long(shane)) ::: If there is at least one people who is alert or not poised, then Shane is not long.\n(∀x (¬Poised(x) ∧ Short(x))) → (¬Alert(x)) ::: If someone is neither poised nor short, then he is not alert.\n(∀x (Alert(x))) → (¬Different(neal) ∧ Faithful(julie)) ::: If everyone is alert, then Neal is not different and Julie is faithful.\n(∀x (¬Faithful(x))) → (Alert(x)) ::: If someone is not faithful, then he is alert.\n(∀x ((x ∨ ¬Long(x)) ↔ ¬Different(x))) → (Alert(x)) ::: If someone is he or not long is not different, then he is alert.\n",
            "First-Order-Logic Question": "¬Poised(brandi) ::: Brandi is not poised."
        },
        "gram_prog": {
            "First-Order-Logic Rules": "¬Different(brandi) ::: Brandi is not different.\nAlert(julie) ::: Julie is alert.\nLong(leroy) ::: Leroy is long.\n¬Poised(leroy) ::: Leroy is not poised.\nLong(julie) ::: Julie is long.\nPoised(tristan) ::: Tristan is poised.\n¬Faithful(cyril) ::: Cyril is not faithful.\n¬Different(tristan) ::: Tristan is not different.\n¬Different(cyril) ::: Cyril is not different.\nLong(cyril) ::: Cyril is long.\nLong(brandi) ::: Brandi is long.\nPoised(shane) ::: Shane is poised.\n(∀x (Faithful(x) ∨ ¬Poised(x))) → (∀x (¬Short(x))) ::: Someone who is eithor faithful or not poised is always not short.\n(∀x (¬Faithful(x))) ↔ (∀x (¬Different(x))) ::: If someone is not faithful, then he is not different, and vice versa.\n(∃x (Short(x) ∨ ¬Different(x))) → ((Alert(julie) ∧ Faithful(cyril))) ::: If there is at least one people who is either short or not different, then Julie is alert and Cyril is faithful.\n(Alert(x)) ↔ (Poised(x)) ::: Someone is alert if and only if he is poised.\n((¬Poised(julie) ∨ Different(tristan))) → (Long(leroy)) ::: If Julie is not poised or Tristan is different, then Leroy is long.\n(∀x (Short(x))) ↔ (∀x (Faithful(x))) ::: If someone is short, then he is faithful, and vice versa.\n((Alert(brandi) ∨ Short(cyril))) → (¬Poised(cyril)) ::: If Brandi is alert or Cyril is short, then Cyril is not poised.\n(∃x (Alert(x) ∨ ¬Poised(x))) → (¬Long(shane)) ::: If there is at least one people who is alert or not poised, then Shane is not long.\n(∀x (¬Poised(x) ∧ Short(x))) → (¬Alert(x)) ::: If someone is neither poised nor short, then he is not alert.\n(∀x (Alert(x))) → (¬Different(neal) ∧ Faithful(julie)) ::: If everyone is alert, then Neal is not different and Julie is faithful.\n(∀x (¬Faithful(x))) → (Alert(x)) ::: If someone is not faithful, then he is alert.\n¬(Serious(x)→(Fresh(x))) ::: If someone is he or not long is not different, then he is alert.\n",
            "First-Order-Logic Question": "¬Poised(brandi) ::: Brandi is not poised."
        },
        "diff": [
            {
                "raw": "(∀x ((x ∨ ¬Long(x)) ↔ ¬Different(x))) → (Alert(x)) ::: If someone is he or not long is not different, then he is alert.",
                "gram": "¬(Serious(x)→(Fresh(x))) ::: If someone is he or not long is not different, then he is alert."
            }
        ],
        "answer": "B",
        "grammar_answer": "A",
        "manual_prog": {
            "First-Order-Logic Rules": "¬Different(brandi) ::: Brandi is not different.\nAlert(julie) ::: Julie is alert.\nLong(leroy) ::: Leroy is long.\n¬Poised(leroy) ::: Leroy is not poised.\nLong(julie) ::: Julie is long.\nPoised(tristan) ::: Tristan is poised.\n¬Faithful(cyril) ::: Cyril is not faithful.\n¬Different(tristan) ::: Tristan is not different.\n¬Different(cyril) ::: Cyril is not different.\nLong(cyril) ::: Cyril is long.\nLong(brandi) ::: Brandi is long.\nPoised(shane) ::: Shane is poised.\n(∀x (Faithful(x) ∨ ¬Poised(x))) → (∀x (¬Short(x))) ::: Someone who is eithor faithful or not poised is always not short.\n(∀x (¬Faithful(x))) ↔ (∀x (¬Different(x))) ::: If someone is not faithful, then he is not different, and vice versa.\n(∃x (Short(x) ∨ ¬Different(x))) → ((Alert(julie) ∧ Faithful(cyril))) ::: If there is at least one people who is either short or not different, then Julie is alert and Cyril is faithful.\n(Alert(x)) ↔ (Poised(x)) ::: Someone is alert if and only if he is poised.\n((¬Poised(julie) ∨ Different(tristan))) → (Long(leroy)) ::: If Julie is not poised or Tristan is different, then Leroy is long.\n(∀x (Short(x))) ↔ (∀x (Faithful(x))) ::: If someone is short, then he is faithful, and vice versa.\n((Alert(brandi) ∨ Short(cyril))) → (¬Poised(cyril)) ::: If Brandi is alert or Cyril is short, then Cyril is not poised.\n(∃x (Alert(x) ∨ ¬Poised(x))) → (¬Long(shane)) ::: If there is at least one people who is alert or not poised, then Shane is not long.\n(∀x (¬Poised(x) ∧ Short(x))) → (¬Alert(x)) ::: If someone is neither poised nor short, then he is not alert.\n(∀x (Alert(x))) → (¬Different(neal) ∧ Faithful(julie)) ::: If everyone is alert, then Neal is not different and Julie is faithful.\n(∀x (¬Faithful(x))) → (Alert(x)) ::: If someone is not faithful, then he is alert.\n(∀x ((¬Long(x)) ↔ ¬Different(x))) → (Alert(x)) ::: If someone is he or not long is not different, then he is alert.\n",
            "First-Order-Logic Question": "¬Poised(brandi) ::: Brandi is not poised."
        },
        "fixed": true
    },
    {
        "id": 1136,
        "raw_prog": {
            "First-Order-Logic Rules": "¬Different(brandi) ::: Brandi is not different.\nAlert(julie) ::: Julie is alert.\nLong(leroy) ::: Leroy is long.\n¬Poised(leroy) ::: Leroy is not poised.\nLong(julie) ::: Julie is long.\nPoised(tristan) ::: Tristan is poised.\n¬Faithful(cyril) ::: Cyril is not faithful.\n¬Different(tristan) ::: Tristan is not different.\n¬Different(cyril) ::: Cyril is not different.\nLong(cyril) ::: Cyril is long.\nLong(brandi) ::: Brandi is long.\nPoised(shane) ::: Shane is poised.\n(∀x (Faithful(x) ∨ ¬Poised(x))) → (∀x (¬Short(x))) ::: Someone who is eithor faithful or not poised is always not short.\n(∀x ((¬Faithful(x)) ↔ (¬Different(x)))) ::: If someone is not faithful, then he is not different, and vice versa.\n(∃x (Short(x) ∨ ¬Different(x))) → ((Alert(julie) ∧ Faithful(cyril))) ::: If there is at least one people who is either short or not different, then Julie is alert and Cyril is faithful.\n(Alert(x)) ↔ (Poised(x)) ::: Someone is alert if and only if he is poised.\n((¬Poised(julie) ∨ Different(tristan))) → (Long(leroy)) ::: If Julie is not poised or Tristan is different, then Leroy is long.\n(∀x (Short(x))) ↔ (Faithful(x)) ::: If someone is short, then he is faithful, and vice versa.\n((Alert(brandi) ∨ Short(cyril))) → (¬Poised(cyril)) ::: If Brandi is alert or Cyril is short, then Cyril is not poised.\n(∃x (Alert(x) ∨ ¬Poised(x))) → (¬Long(shane)) ::: If there is at least one people who is alert or not poised, then Shane is not long.\n(∀x ((¬Poised(x) ∧ Short(x))) → (¬Alert(x))) ::: If someone is neither poised nor short, then he is not alert.\n(∀x (Alert(x))) → ((¬Different(neal) ∧ Faithful(julie))) ::: If everyone is alert, then Neal is not different and Julie is faithful.\n(∀x (¬Faithful(x))) → (Alert(x)) ::: If someone is not faithful, then he is alert.\n(∀x ((x ∨ ¬Long(x)) ↔ ¬Different(x))) ::: If someone is he or not long is not different, then he is alert.\n",
            "First-Order-Logic Question": "Faithful(tristan) ::: Tristan is faithful."
        },
        "gram_prog": {
            "First-Order-Logic Rules": "¬Different(brandi) ::: Brandi is not different.\nAlert(julie) ::: Julie is alert.\nLong(leroy) ::: Leroy is long.\n¬Poised(leroy) ::: Leroy is not poised.\nLong(julie) ::: Julie is long.\nPoised(tristan) ::: Tristan is poised.\n¬Faithful(cyril) ::: Cyril is not faithful.\n¬Different(tristan) ::: Tristan is not different.\n¬Different(cyril) ::: Cyril is not different.\nLong(cyril) ::: Cyril is long.\nLong(brandi) ::: Brandi is long.\nPoised(shane) ::: Shane is poised.\n(∀x (Faithful(x) ∨ ¬Poised(x))) → (∀x (¬Short(x))) ::: Someone who is eithor faithful or not poised is always not short.\n(∀x ((¬Faithful(x)) ↔ (¬Different(x)))) ::: If someone is not faithful, then he is not different, and vice versa.\n(∃x (Short(x) ∨ ¬Different(x))) → ((Alert(julie) ∧ Faithful(cyril))) ::: If there is at least one people who is either short or not different, then Julie is alert and Cyril is faithful.\n(Alert(x)) ↔ (Poised(x)) ::: Someone is alert if and only if he is poised.\n((¬Poised(julie) ∨ Different(tristan))) → (Long(leroy)) ::: If Julie is not poised or Tristan is different, then Leroy is long.\n(∀x (Short(x))) ↔ (Faithful(x)) ::: If someone is short, then he is faithful, and vice versa.\n((Alert(brandi) ∨ Short(cyril))) → (¬Poised(cyril)) ::: If Brandi is alert or Cyril is short, then Cyril is not poised.\n(∃x (Alert(x) ∨ ¬Poised(x))) → (¬Long(shane)) ::: If there is at least one people who is alert or not poised, then Shane is not long.\n(∀x ((¬Poised(x) ∧ Short(x))) → (¬Alert(x))) ::: If someone is neither poised nor short, then he is not alert.\n(∀x (Alert(x))) → ((¬Different(neal) ∧ Faithful(julie))) ::: If everyone is alert, then Neal is not different and Julie is faithful.\n(∀x (¬Faithful(x))) → (Alert(x)) ::: If someone is not faithful, then he is alert.\n∀x((¬Long(x)↔¬Different(x))) ::: If someone is he or not long is not different, then he is alert.\n",
            "First-Order-Logic Question": "Faithful(tristan) ::: Tristan is faithful."
        },
        "diff": [],
        "answer": "B",
        "grammar_answer": "A",
        "manual_prog": {
            "First-Order-Logic Rules": "¬Different(brandi) ::: Brandi is not different.\nAlert(julie) ::: Julie is alert.\nLong(leroy) ::: Leroy is long.\n¬Poised(leroy) ::: Leroy is not poised.\nLong(julie) ::: Julie is long.\nPoised(tristan) ::: Tristan is poised.\n¬Faithful(cyril) ::: Cyril is not faithful.\n¬Different(tristan) ::: Tristan is not different.\n¬Different(cyril) ::: Cyril is not different.\nLong(cyril) ::: Cyril is long.\nLong(brandi) ::: Brandi is long.\nPoised(shane) ::: Shane is poised.\n(∀x (Faithful(x) ∨ ¬Poised(x))) → (∀x (¬Short(x))) ::: Someone who is eithor faithful or not poised is always not short.\n(∀x ((¬Faithful(x)) ↔ (¬Different(x)))) ::: If someone is not faithful, then he is not different, and vice versa.\n(∃x (Short(x) ∨ ¬Different(x))) → ((Alert(julie) ∧ Faithful(cyril))) ::: If there is at least one people who is either short or not different, then Julie is alert and Cyril is faithful.\n(Alert(x)) ↔ (Poised(x)) ::: Someone is alert if and only if he is poised.\n((¬Poised(julie) ∨ Different(tristan))) → (Long(leroy)) ::: If Julie is not poised or Tristan is different, then Leroy is long.\n(∀x (Short(x))) ↔ (Faithful(x)) ::: If someone is short, then he is faithful, and vice versa.\n((Alert(brandi) ∨ Short(cyril))) → (¬Poised(cyril)) ::: If Brandi is alert or Cyril is short, then Cyril is not poised.\n(∃x (Alert(x) ∨ ¬Poised(x))) → (¬Long(shane)) ::: If there is at least one people who is alert or not poised, then Shane is not long.\n(∀x ((¬Poised(x) ∧ Short(x))) → (¬Alert(x))) ::: If someone is neither poised nor short, then he is not alert.\n(∀x (Alert(x))) → ((¬Different(neal) ∧ Faithful(julie))) ::: If everyone is alert, then Neal is not different and Julie is faithful.\n(∀x (¬Faithful(x))) → (Alert(x)) ::: If someone is not faithful, then he is alert.\n(∀x ((x ∨ ¬Long(x)) ↔ ¬Different(x))) ::: If someone is he or not long is not different, then he is alert.\n",
            "First-Order-Logic Question": "Faithful(tristan) ::: Tristan is faithful."
        },
        "fixed": true
    },
    {
        "id": 1139,
        "raw_prog": {
            "First-Order-Logic Rules": "¬Different(brandi) ::: Brandi is not different.\nAlert(julie) ::: Julie is alert.\nLong(leroy) ::: Leroy is long.\n¬Poised(leroy) ::: Leroy is not poised.\nLong(julie) ::: Julie is long.\nPoised(tristan) ::: Tristan is poised.\n¬Faithful(cyril) ::: Cyril is not faithful.\n¬Different(tristan) ::: Tristan is not different.\n¬Different(cyril) ::: Cyril is not different.\nLong(cyril) ::: Cyril is long.\nLong(brandi) ::: Brandi is long.\nPoised(shane) ::: Shane is poised.\n(∀x (Faithful(x) ∨ ¬Poised(x))) → (∀x (¬Short(x))) ::: Someone who is eithor faithful or not poised is always not short.\n(∀x (¬Faithful(x))) ↔ (∀x (¬Different(x))) ::: If someone is not faithful, then he is not different, and vice versa.\n(∃x (Short(x) ∨ ¬Different(x))) → ((Alert(julie) ∧ Faithful(cyril))) ::: If there is at least one people who is either short or not different, then Julie is alert and Cyril is faithful.\n(Alert(x)) ↔ (Poised(x)) ::: Someone is alert if and only if he is poised.\n((¬Poised(julie) ∨ Different(tristan))) → (Long(leroy)) ::: If Julie is not poised or Tristan is different, then Leroy is long.\n(∀x (Short(x))) ↔ (∀x (Faithful(x))) ::: If someone is short, then he is faithful, and vice versa.\n((Alert(brandi) ∨ Short(cyril))) → (¬Poised(cyril)) ::: If Brandi is alert or Cyril is short, then Cyril is not poised.\n(∃x (Alert(x) ∨ ¬Poised(x))) → (¬Long(shane)) ::: If there is at least one people who is alert or not poised, then Shane is not long.\n(∀x (¬Poised(x) ∧ Short(x))) → (¬Alert(x)) ::: If someone is neither poised nor short, then he is not alert.\n(∀x (Alert(x))) → ((¬Different(neal) ∧ Faithful(julie))) ::: If everyone is alert, then Neal is not different and Julie is faithful.\n(∀x (¬Faithful(x))) → (Alert(x)) ::: If someone is not faithful, then he is alert.\n(∀x ((x ∨ ¬Long(x)) ↔ ¬Different(x))) → (Alert(x)) ::: If someone is he or not long is not different, then he is alert.\n",
            "First-Order-Logic Question": "Faithful(brandi) ::: Brandi is faithful."
        },
        "gram_prog": {
            "First-Order-Logic Rules": "¬Different(brandi) ::: Brandi is not different.\nAlert(julie) ::: Julie is alert.\nLong(leroy) ::: Leroy is long.\n¬Poised(leroy) ::: Leroy is not poised.\nLong(julie) ::: Julie is long.\nPoised(tristan) ::: Tristan is poised.\n¬Faithful(cyril) ::: Cyril is not faithful.\n¬Different(tristan) ::: Tristan is not different.\n¬Different(cyril) ::: Cyril is not different.\nLong(cyril) ::: Cyril is long.\nLong(brandi) ::: Brandi is long.\nPoised(shane) ::: Shane is poised.\n(∀x (Faithful(x) ∨ ¬Poised(x))) → (∀x (¬Short(x))) ::: Someone who is eithor faithful or not poised is always not short.\n(∀x (¬Faithful(x))) ↔ (∀x (¬Different(x))) ::: If someone is not faithful, then he is not different, and vice versa.\n(∃x (Short(x) ∨ ¬Different(x))) → ((Alert(julie) ∧ Faithful(cyril))) ::: If there is at least one people who is either short or not different, then Julie is alert and Cyril is faithful.\n(Alert(x)) ↔ (Poised(x)) ::: Someone is alert if and only if he is poised.\n((¬Poised(julie) ∨ Different(tristan))) → (Long(leroy)) ::: If Julie is not poised or Tristan is different, then Leroy is long.\n(∀x (Short(x))) ↔ (∀x (Faithful(x))) ::: If someone is short, then he is faithful, and vice versa.\n((Alert(brandi) ∨ Short(cyril))) → (¬Poised(cyril)) ::: If Brandi is alert or Cyril is short, then Cyril is not poised.\n(∃x (Alert(x) ∨ ¬Poised(x))) → (¬Long(shane)) ::: If there is at least one people who is alert or not poised, then Shane is not long.\n(∀x (¬Poised(x) ∧ Short(x))) → (¬Alert(x)) ::: If someone is neither poised nor short, then he is not alert.\n(∀x (Alert(x))) → ((¬Different(neal) ∧ Faithful(julie))) ::: If everyone is alert, then Neal is not different and Julie is faithful.\n(∀x (¬Faithful(x))) → (Alert(x)) ::: If someone is not faithful, then he is alert.\n¬(Fresh(x)→Serious(x))→(Entire(x))∨(Accurate(x)) ::: If someone is he or not long is not different, then he is alert.\n",
            "First-Order-Logic Question": "Faithful(brandi) ::: Brandi is faithful."
        },
        "diff": [
            {
                "raw": "(∀x ((x ∨ ¬Long(x)) ↔ ¬Different(x))) → (Alert(x)) ::: If someone is he or not long is not different, then he is alert.",
                "gram": "¬(Fresh(x)→Serious(x))→(Entire(x))∨(Accurate(x)) ::: If someone is he or not long is not different, then he is alert."
            }
        ],
        "answer": "B",
        "grammar_answer": "A",
        "manual_prog": {
            "First-Order-Logic Rules": "¬Different(brandi) ::: Brandi is not different.\nAlert(julie) ::: Julie is alert.\nLong(leroy) ::: Leroy is long.\n¬Poised(leroy) ::: Leroy is not poised.\nLong(julie) ::: Julie is long.\nPoised(tristan) ::: Tristan is poised.\n¬Faithful(cyril) ::: Cyril is not faithful.\n¬Different(tristan) ::: Tristan is not different.\n¬Different(cyril) ::: Cyril is not different.\nLong(cyril) ::: Cyril is long.\nLong(brandi) ::: Brandi is long.\nPoised(shane) ::: Shane is poised.\n(∀x (Faithful(x) ∨ ¬Poised(x))) → (∀x (¬Short(x))) ::: Someone who is eithor faithful or not poised is always not short.\n(∀x (¬Faithful(x))) ↔ (∀x (¬Different(x))) ::: If someone is not faithful, then he is not different, and vice versa.\n(∃x (Short(x) ∨ ¬Different(x))) → ((Alert(julie) ∧ Faithful(cyril))) ::: If there is at least one people who is either short or not different, then Julie is alert and Cyril is faithful.\n(Alert(x)) ↔ (Poised(x)) ::: Someone is alert if and only if he is poised.\n((¬Poised(julie) ∨ Different(tristan))) → (Long(leroy)) ::: If Julie is not poised or Tristan is different, then Leroy is long.\n(∀x (Short(x))) ↔ (∀x (Faithful(x))) ::: If someone is short, then he is faithful, and vice versa.\n((Alert(brandi) ∨ Short(cyril))) → (¬Poised(cyril)) ::: If Brandi is alert or Cyril is short, then Cyril is not poised.\n(∃x (Alert(x) ∨ ¬Poised(x))) → (¬Long(shane)) ::: If there is at least one people who is alert or not poised, then Shane is not long.\n(∀x (¬Poised(x) ∧ Short(x))) → (¬Alert(x)) ::: If someone is neither poised nor short, then he is not alert.\n(∀x (Alert(x))) → ((¬Different(neal) ∧ Faithful(julie))) ::: If everyone is alert, then Neal is not different and Julie is faithful.\n(∀x (¬Faithful(x))) → (Alert(x)) ::: If someone is not faithful, then he is alert.\n(∀x ((¬Long(x)) ↔ ¬Different(x))) → (Alert(x)) ::: If someone is he or not long is not different, then he is alert.\n",
            "First-Order-Logic Question": "Faithful(brandi) ::: Brandi is faithful."
        },
        "fixed": true
    },
    {
        "id": 1161,
        "raw_prog": {
            "First-Order-Logic Rules": "¬Wonderful(neal) ::: Neal is not wonderful.\nFat(janine) ::: Janine is fat.\nCultural(tyra) ::: Tyra is cultural.\nJittery(lewis) ::: Lewis is jittery.\nJittery(george) ::: George is jittery.\n¬Able(neal) ::: Neal is not able.\nExpensive(neal) ::: Neal is expensive.\nFat(george) ::: George is fat.\n¬Expensive(tyra) ::: Tyra is not expensive.\nAble(clarence) ::: Clarence is able.\n¬Fat(clarence) ::: Clarence is not fat.\n¬Jittery(neal) ::: Neal is not jittery.\n(∀x ((Able(x) ∧ Fat(x))) → (¬Expensive(x)) ::: If someone who is able is also fat, then he is not expensive.\n(∃x ((Jittery(x) ∨ Expensive(x))) → (¬Cultural(george))) ::: If there is at least one people who is jittery or expensive, then George is not cultural.\n(Expensive(neal)) → ((¬Jittery(tyra) ∧ Wonderful(janine))) ::: Neal being expensive implies that Tyra is not jittery and Janine is wonderful.\n(¬Wonderful(neal)) → (Able(janine)) ::: If Neal is not wonderful, then Janine is able, and vice versa.\n(∃x (¬Able(x))) → (¬Wonderful(barry) ∧ ¬Jittery(clarence)) ::: If there is at least one people who is not able, then Barry is not wonderful and Clarence is not jittery.\n(∀x (Fat(x))) ↔ (¬Jittery(x)) ::: Someone is fat if and only if he is not jittery.\n(Expensive(lewis)) → (¬Cultural(tyra) ∧ ¬Cultural(neal)) ::: It can be concluded that Tyra is not wonderful and Neal is not cultural once knowing that Lewis is not expensive.\n(∃x (Able(x))) → (¬Expensive(clarence)) ::: If there is someone who is able, then Clarence is not expensive.\n(∀x ((¬Cultural(x) ∧ Wonderful(x))) → (Jittery(x))) ::: If someone who is not cultural is also wonderful, then he is jittery.\n(Expensive(lewis)) → (¬Cultural(george)) ::: It can be concluded that George is not cultural once knowing that Lewis is jittery.\n(∃x (¬Jittery(x))) → (Expensive(clarence) ∧ Cultural(neal)) ::: If there is at least one people who is not jittery, then Clarence is expensive and Neal is cultural.\n(∀x ((¬Cultural(x) ∧ ¬Able(x))) ↔ (¬Expensive(x))) ::: Someone being neither cultural nor able is equivalent to being not expensive.\n",
            "First-Order-Logic Question": "Cultural(clarence) ::: Clarence is cultural."
        },
        "gram_prog": {
            "First-Order-Logic Rules": "¬Wonderful(neal) ::: Neal is not wonderful.\nFat(janine) ::: Janine is fat.\nCultural(tyra) ::: Tyra is cultural.\nJittery(lewis) ::: Lewis is jittery.\nJittery(george) ::: George is jittery.\n¬Able(neal) ::: Neal is not able.\nExpensive(neal) ::: Neal is expensive.\nFat(george) ::: George is fat.\n¬Expensive(tyra) ::: Tyra is not expensive.\nAble(clarence) ::: Clarence is able.\n¬Fat(clarence) ::: Clarence is not fat.\n¬Jittery(neal) ::: Neal is not jittery.\n∀x((Wonderful(x)→Fat(x))) ::: If someone who is able is also fat, then he is not expensive.\n(∃x ((Jittery(x) ∨ Expensive(x))) → (¬Cultural(george))) ::: If there is at least one people who is jittery or expensive, then George is not cultural.\n(Expensive(neal)) → ((¬Jittery(tyra) ∧ Wonderful(janine))) ::: Neal being expensive implies that Tyra is not jittery and Janine is wonderful.\n(¬Wonderful(neal)) → (Able(janine)) ::: If Neal is not wonderful, then Janine is able, and vice versa.\n(∃x (¬Able(x))) → (¬Wonderful(barry) ∧ ¬Jittery(clarence)) ::: If there is at least one people who is not able, then Barry is not wonderful and Clarence is not jittery.\n(∀x (Fat(x))) ↔ (¬Jittery(x)) ::: Someone is fat if and only if he is not jittery.\n(Expensive(lewis)) → (¬Cultural(tyra) ∧ ¬Cultural(neal)) ::: It can be concluded that Tyra is not wonderful and Neal is not cultural once knowing that Lewis is not expensive.\n(∃x (Able(x))) → (¬Expensive(clarence)) ::: If there is someone who is able, then Clarence is not expensive.\n(∀x ((¬Cultural(x) ∧ Wonderful(x))) → (Jittery(x))) ::: If someone who is not cultural is also wonderful, then he is jittery.\n(Expensive(lewis)) → (¬Cultural(george)) ::: It can be concluded that George is not cultural once knowing that Lewis is jittery.\n(∃x (¬Jittery(x))) → (Expensive(clarence) ∧ Cultural(neal)) ::: If there is at least one people who is not jittery, then Clarence is expensive and Neal is cultural.\n(∀x ((¬Cultural(x) ∧ ¬Able(x))) ↔ (¬Expensive(x))) ::: Someone being neither cultural nor able is equivalent to being not expensive.\n",
            "First-Order-Logic Question": "Cultural(clarence) ::: Clarence is cultural."
        },
        "diff": [
            {
                "raw": "(∀x ((Able(x) ∧ Fat(x))) → (¬Expensive(x)) ::: If someone who is able is also fat, then he is not expensive.",
                "gram": "∀x((Wonderful(x)→Fat(x))) ::: If someone who is able is also fat, then he is not expensive."
            }
        ],
        "answer": "B",
        "grammar_answer": "A",
        "manual_prog": {
            "First-Order-Logic Rules": "¬Wonderful(neal) ::: Neal is not wonderful.\nFat(janine) ::: Janine is fat.\nCultural(tyra) ::: Tyra is cultural.\nJittery(lewis) ::: Lewis is jittery.\nJittery(george) ::: George is jittery.\n¬Able(neal) ::: Neal is not able.\nExpensive(neal) ::: Neal is expensive.\nFat(george) ::: George is fat.\n¬Expensive(tyra) ::: Tyra is not expensive.\nAble(clarence) ::: Clarence is able.\n¬Fat(clarence) ::: Clarence is not fat.\n¬Jittery(neal) ::: Neal is not jittery.\n(∀x ((Able(x) ∧ Fat(x))) → (¬Expensive(x))) ::: If someone who is able is also fat, then he is not expensive.\n(∃x ((Jittery(x) ∨ Expensive(x))) → (¬Cultural(george))) ::: If there is at least one people who is jittery or expensive, then George is not cultural.\n(Expensive(neal)) → ((¬Jittery(tyra) ∧ Wonderful(janine))) ::: Neal being expensive implies that Tyra is not jittery and Janine is wonderful.\n(¬Wonderful(neal)) → (Able(janine)) ::: If Neal is not wonderful, then Janine is able, and vice versa.\n(∃x (¬Able(x))) → (¬Wonderful(barry) ∧ ¬Jittery(clarence)) ::: If there is at least one people who is not able, then Barry is not wonderful and Clarence is not jittery.\n(∀x (Fat(x))) ↔ (¬Jittery(x)) ::: Someone is fat if and only if he is not jittery.\n(Expensive(lewis)) → (¬Cultural(tyra) ∧ ¬Cultural(neal)) ::: It can be concluded that Tyra is not wonderful and Neal is not cultural once knowing that Lewis is not expensive.\n(∃x (Able(x))) → (¬Expensive(clarence)) ::: If there is someone who is able, then Clarence is not expensive.\n(∀x ((¬Cultural(x) ∧ Wonderful(x))) → (Jittery(x))) ::: If someone who is not cultural is also wonderful, then he is jittery.\n(Expensive(lewis)) → (¬Cultural(george)) ::: It can be concluded that George is not cultural once knowing that Lewis is jittery.\n(∃x (¬Jittery(x))) → (Expensive(clarence) ∧ Cultural(neal)) ::: If there is at least one people who is not jittery, then Clarence is expensive and Neal is cultural.\n(∀x ((¬Cultural(x) ∧ ¬Able(x))) ↔ (¬Expensive(x))) ::: Someone being neither cultural nor able is equivalent to being not expensive.\n",
            "First-Order-Logic Question": "Cultural(clarence) ::: Clarence is cultural."
        },
        "fixed": true
    },
    {
        "id": 1165,
        "raw_prog": {
            "First-Order-Logic Rules": "¬Wonderful(neal) ::: Neal is not wonderful.\nFat(janine) ::: Janine is fat.\nCultural(tyra) ::: Tyra is cultural.\nJittery(lewis) ::: Lewis is jittery.\nJittery(george) ::: George is jittery.\n¬Able(neal) ::: Neal is not able.\nExpensive(neal) ::: Neal is expensive.\nFat(george) ::: George is fat.\n¬Expensive(tyra) ::: Tyra is not expensive.\nAble(clarence) ::: Clarence is able.\n¬Fat(clarence) ::: Clarence is not fat.\n¬Jittery(neal) ::: Neal is not jittery.\n(∀x ((Able(x) ∧ Fat(x))) → (¬Expensive(x)) ::: If someone who is able is also fat, then he is not expensive.\n(∃x (Jittery(x) ∨ Expensive(x))) → (¬Cultural(george)) ::: If there is at least one people who is jittery or expensive, then George is not cultural.\n(Expensive(neal)) → ((¬Jittery(tyra) ∧ Wonderful(janine))) ::: Neal being expensive implies that Tyra is not jittery and Janine is wonderful.\n(¬Wonderful(neal)) ↔ (Able(janine)) ::: If Neal is not wonderful, then Janine is able, and vice versa.\n(∃x (¬Able(x))) → (¬Wonderful(barry) ∧ ¬Jittery(clarence)) ::: If there is at least one people who is not able, then Barry is not wonderful and Clarence is not jittery.\n(∀x (Fat(x))) ↔ (¬Jittery(x)) ::: Someone is fat if and only if he is not jittery.\n(¬Expensive(lewis)) → (¬Cultural(tyra) ∧ ¬Wonderful(neal)) ::: It can be concluded that Tyra is not wonderful and Neal is not cultural once knowing that Lewis is not expensive.\n(∃x (Able(x))) → (¬Expensive(clarence)) ::: If there is someone who is able, then Clarence is not expensive.\n(∀x ((¬Cultural(x) ∧ Wonderful(x))) → (Jittery(x))) ::: If someone who is not cultural is also wonderful, then he is jittery.\n(¬Cultural(george)) → (Jittery(lewis)) ::: It can be concluded that George is not cultural once knowing that Lewis is jittery.\n(∃x (¬Jittery(x))) → (Expensive(clarence) ∧ Cultural(neal)) ::: If there is at least one people who is not jittery, then Clarence is expensive and Neal is cultural.\n(∀x ((¬Cultural(x) ∧ ¬Able(x))) ↔ (¬Expensive(x))) ::: Someone being neither cultural nor able is equivalent to being not expensive.\n",
            "First-Order-Logic Question": "¬Fat(neal) ::: Neal is not fat."
        },
        "gram_prog": {
            "First-Order-Logic Rules": "¬Wonderful(neal) ::: Neal is not wonderful.\nFat(janine) ::: Janine is fat.\nCultural(tyra) ::: Tyra is cultural.\nJittery(lewis) ::: Lewis is jittery.\nJittery(george) ::: George is jittery.\n¬Able(neal) ::: Neal is not able.\nExpensive(neal) ::: Neal is expensive.\nFat(george) ::: George is fat.\n¬Expensive(tyra) ::: Tyra is not expensive.\nAble(clarence) ::: Clarence is able.\n¬Fat(clarence) ::: Clarence is not fat.\n¬Jittery(neal) ::: Neal is not jittery.\n∀x((Wonderful(x)→Cultural(x))) ::: If someone who is able is also fat, then he is not expensive.\n(∃x (Jittery(x) ∨ Expensive(x))) → (¬Cultural(george)) ::: If there is at least one people who is jittery or expensive, then George is not cultural.\n(Expensive(neal)) → ((¬Jittery(tyra) ∧ Wonderful(janine))) ::: Neal being expensive implies that Tyra is not jittery and Janine is wonderful.\n(¬Wonderful(neal)) ↔ (Able(janine)) ::: If Neal is not wonderful, then Janine is able, and vice versa.\n(∃x (¬Able(x))) → (¬Wonderful(barry) ∧ ¬Jittery(clarence)) ::: If there is at least one people who is not able, then Barry is not wonderful and Clarence is not jittery.\n(∀x (Fat(x))) ↔ (¬Jittery(x)) ::: Someone is fat if and only if he is not jittery.\n(¬Expensive(lewis)) → (¬Cultural(tyra) ∧ ¬Wonderful(neal)) ::: It can be concluded that Tyra is not wonderful and Neal is not cultural once knowing that Lewis is not expensive.\n(∃x (Able(x))) → (¬Expensive(clarence)) ::: If there is someone who is able, then Clarence is not expensive.\n(∀x ((¬Cultural(x) ∧ Wonderful(x))) → (Jittery(x))) ::: If someone who is not cultural is also wonderful, then he is jittery.\n(¬Cultural(george)) → (Jittery(lewis)) ::: It can be concluded that George is not cultural once knowing that Lewis is jittery.\n(∃x (¬Jittery(x))) → (Expensive(clarence) ∧ Cultural(neal)) ::: If there is at least one people who is not jittery, then Clarence is expensive and Neal is cultural.\n(∀x ((¬Cultural(x) ∧ ¬Able(x))) ↔ (¬Expensive(x))) ::: Someone being neither cultural nor able is equivalent to being not expensive.\n",
            "First-Order-Logic Question": "¬Fat(neal) ::: Neal is not fat."
        },
        "diff": [
            {
                "raw": "(∀x ((Able(x) ∧ Fat(x))) → (¬Expensive(x)) ::: If someone who is able is also fat, then he is not expensive.",
                "gram": "∀x((Wonderful(x)→Cultural(x))) ::: If someone who is able is also fat, then he is not expensive."
            }
        ],
        "answer": "B",
        "grammar_answer": "A",
        "manual_prog": {
            "First-Order-Logic Rules": "¬Wonderful(neal) ::: Neal is not wonderful.\nFat(janine) ::: Janine is fat.\nCultural(tyra) ::: Tyra is cultural.\nJittery(lewis) ::: Lewis is jittery.\nJittery(george) ::: George is jittery.\n¬Able(neal) ::: Neal is not able.\nExpensive(neal) ::: Neal is expensive.\nFat(george) ::: George is fat.\n¬Expensive(tyra) ::: Tyra is not expensive.\nAble(clarence) ::: Clarence is able.\n¬Fat(clarence) ::: Clarence is not fat.\n¬Jittery(neal) ::: Neal is not jittery.\n(∀x ((Able(x) ∧ Fat(x))) → (¬Expensive(x))) ::: If someone who is able is also fat, then he is not expensive.\n(∃x (Jittery(x) ∨ Expensive(x))) → (¬Cultural(george)) ::: If there is at least one people who is jittery or expensive, then George is not cultural.\n(Expensive(neal)) → ((¬Jittery(tyra) ∧ Wonderful(janine))) ::: Neal being expensive implies that Tyra is not jittery and Janine is wonderful.\n(¬Wonderful(neal)) ↔ (Able(janine)) ::: If Neal is not wonderful, then Janine is able, and vice versa.\n(∃x (¬Able(x))) → (¬Wonderful(barry) ∧ ¬Jittery(clarence)) ::: If there is at least one people who is not able, then Barry is not wonderful and Clarence is not jittery.\n(∀x (Fat(x))) ↔ (¬Jittery(x)) ::: Someone is fat if and only if he is not jittery.\n(¬Expensive(lewis)) → (¬Cultural(tyra) ∧ ¬Wonderful(neal)) ::: It can be concluded that Tyra is not wonderful and Neal is not cultural once knowing that Lewis is not expensive.\n(∃x (Able(x))) → (¬Expensive(clarence)) ::: If there is someone who is able, then Clarence is not expensive.\n(∀x ((¬Cultural(x) ∧ Wonderful(x))) → (Jittery(x))) ::: If someone who is not cultural is also wonderful, then he is jittery.\n(¬Cultural(george)) → (Jittery(lewis)) ::: It can be concluded that George is not cultural once knowing that Lewis is jittery.\n(∃x (¬Jittery(x))) → (Expensive(clarence) ∧ Cultural(neal)) ::: If there is at least one people who is not jittery, then Clarence is expensive and Neal is cultural.\n(∀x ((¬Cultural(x) ∧ ¬Able(x))) ↔ (¬Expensive(x))) ::: Someone being neither cultural nor able is equivalent to being not expensive.\n",
            "First-Order-Logic Question": "¬Fat(neal) ::: Neal is not fat."
        },
        "fixed": true
    },
    {
        "id": 1166,
        "raw_prog": {
            "First-Order-Logic Rules": "¬Wonderful(neal) ::: Neal is not wonderful.\nFat(janine) ::: Janine is fat.\nCultural(tyra) ::: Tyra is cultural.\nJittery(lewis) ::: Lewis is jittery.\nJittery(george) ::: George is jittery.\n¬Able(neal) ::: Neal is not able.\nExpensive(neal) ::: Neal is expensive.\nFat(george) ::: George is fat.\n¬Expensive(tyra) ::: Tyra is not expensive.\nAble(clarence) ::: Clarence is able.\n¬Fat(clarence) ::: Clarence is not fat.\n¬Jittery(neal) ::: Neal is not jittery.\n(∀x ((Able(x) ∧ Fat(x))) → (¬Expensive(x)) ::: If someone who is able is also fat, then he is not expensive.\n(∃x ((Jittery(x) ∨ Expensive(x))) → (¬Cultural(george))) ::: If there is at least one people who is jittery or expensive, then George is not cultural.\n(Expensive(neal)) → ((¬Jittery(tyra) ∧ Wonderful(janine))) ::: Neal being expensive implies that Tyra is not jittery and Janine is wonderful.\n(¬Wonderful(neal)) → (Able(janine)) ::: If Neal is not wonderful, then Janine is able, and vice versa.\n(∃x (¬Able(x))) → (¬Wonderful(barry) ∧ ¬Jittery(clarence)) ::: If there is at least one people who is not able, then Barry is not wonderful and Clarence is not jittery.\n(∀x (Fat(x))) ↔ (¬Jittery(x)) ::: Someone is fat if and only if he is not jittery.\n(¬Expensive(lewis)) → (¬Cultural(tyra) ∧ ¬Cultural(neal)) ::: It can be concluded that Tyra is not wonderful and Neal is not cultural once knowing that Lewis is not expensive.\n(∃x (Able(x))) → (¬Expensive(clarence)) ::: If there is someone who is able, then Clarence is not expensive.\n(∀x ((¬Cultural(x) ∧ Wonderful(x))) → (Jittery(x))) ::: If someone who is not cultural is also wonderful, then he is jittery.\n(¬Cultural(george)) → (Jittery(lewis)) ::: It can be concluded that George is not cultural once knowing that Lewis is jittery.\n(∃x (¬Jittery(x))) → (Expensive(clarence) ∧ Cultural(neal)) ::: If there is at least one people who is not jittery, then Clarence is expensive and Neal is cultural.\n(∀x ((¬Cultural(x) ∧ ¬Able(x))) ↔ (¬Expensive(x)) ::: Someone being neither cultural nor able is equivalent to being not expensive.\n",
            "First-Order-Logic Question": "¬Cultural(lewis) ::: Lewis is not cultural."
        },
        "gram_prog": {
            "First-Order-Logic Rules": "¬Wonderful(neal) ::: Neal is not wonderful.\nFat(janine) ::: Janine is fat.\nCultural(tyra) ::: Tyra is cultural.\nJittery(lewis) ::: Lewis is jittery.\nJittery(george) ::: George is jittery.\n¬Able(neal) ::: Neal is not able.\nExpensive(neal) ::: Neal is expensive.\nFat(george) ::: George is fat.\n¬Expensive(tyra) ::: Tyra is not expensive.\nAble(clarence) ::: Clarence is able.\n¬Fat(clarence) ::: Clarence is not fat.\n¬Jittery(neal) ::: Neal is not jittery.\n¬(Accurate(x)→Fresh(x)) ::: If someone who is able is also fat, then he is not expensive.\n(∃x ((Jittery(x) ∨ Expensive(x))) → (¬Cultural(george))) ::: If there is at least one people who is jittery or expensive, then George is not cultural.\n(Expensive(neal)) → ((¬Jittery(tyra) ∧ Wonderful(janine))) ::: Neal being expensive implies that Tyra is not jittery and Janine is wonderful.\n(¬Wonderful(neal)) → (Able(janine)) ::: If Neal is not wonderful, then Janine is able, and vice versa.\n(∃x (¬Able(x))) → (¬Wonderful(barry) ∧ ¬Jittery(clarence)) ::: If there is at least one people who is not able, then Barry is not wonderful and Clarence is not jittery.\n(∀x (Fat(x))) ↔ (¬Jittery(x)) ::: Someone is fat if and only if he is not jittery.\n(¬Expensive(lewis)) → (¬Cultural(tyra) ∧ ¬Cultural(neal)) ::: It can be concluded that Tyra is not wonderful and Neal is not cultural once knowing that Lewis is not expensive.\n(∃x (Able(x))) → (¬Expensive(clarence)) ::: If there is someone who is able, then Clarence is not expensive.\n(∀x ((¬Cultural(x) ∧ Wonderful(x))) → (Jittery(x))) ::: If someone who is not cultural is also wonderful, then he is jittery.\n(¬Cultural(george)) → (Jittery(lewis)) ::: It can be concluded that George is not cultural once knowing that Lewis is jittery.\n(∃x (¬Jittery(x))) → (Expensive(clarence) ∧ Cultural(neal)) ::: If there is at least one people who is not jittery, then Clarence is expensive and Neal is cultural.\n¬Concerned(x)↔¬Fresh(x)∨¬Entire(x)∨¬Accurate(x)∨¬Serious(x)∨¬Blue(x)∨¬Fresh(x) ::: Someone being neither cultural nor able is equivalent to being not expensive.\n",
            "First-Order-Logic Question": "¬Cultural(lewis) ::: Lewis is not cultural."
        },
        "diff": [
            {
                "raw": "(∀x ((Able(x) ∧ Fat(x))) → (¬Expensive(x)) ::: If someone who is able is also fat, then he is not expensive.",
                "gram": "¬(Accurate(x)→Fresh(x)) ::: If someone who is able is also fat, then he is not expensive."
            },
            {
                "raw": "(∀x ((¬Cultural(x) ∧ ¬Able(x))) ↔ (¬Expensive(x)) ::: Someone being neither cultural nor able is equivalent to being not expensive.",
                "gram": "¬Concerned(x)↔¬Fresh(x)∨¬Entire(x)∨¬Accurate(x)∨¬Serious(x)∨¬Blue(x)∨¬Fresh(x) ::: Someone being neither cultural nor able is equivalent to being not expensive."
            }
        ],
        "answer": "C",
        "grammar_answer": "A",
        "manual_prog": {
            "First-Order-Logic Rules": "¬Wonderful(neal) ::: Neal is not wonderful.\nFat(janine) ::: Janine is fat.\nCultural(tyra) ::: Tyra is cultural.\nJittery(lewis) ::: Lewis is jittery.\nJittery(george) ::: George is jittery.\n¬Able(neal) ::: Neal is not able.\nExpensive(neal) ::: Neal is expensive.\nFat(george) ::: George is fat.\n¬Expensive(tyra) ::: Tyra is not expensive.\nAble(clarence) ::: Clarence is able.\n¬Fat(clarence) ::: Clarence is not fat.\n¬Jittery(neal) ::: Neal is not jittery.\n(∀x ((Able(x) ∧ Fat(x))) → (¬Expensive(x))) ::: If someone who is able is also fat, then he is not expensive.\n(∃x ((Jittery(x) ∨ Expensive(x))) → (¬Cultural(george))) ::: If there is at least one people who is jittery or expensive, then George is not cultural.\n(Expensive(neal)) → ((¬Jittery(tyra) ∧ Wonderful(janine))) ::: Neal being expensive implies that Tyra is not jittery and Janine is wonderful.\n(¬Wonderful(neal)) → (Able(janine)) ::: If Neal is not wonderful, then Janine is able, and vice versa.\n(∃x (¬Able(x))) → (¬Wonderful(barry) ∧ ¬Jittery(clarence)) ::: If there is at least one people who is not able, then Barry is not wonderful and Clarence is not jittery.\n(∀x (Fat(x))) ↔ (¬Jittery(x)) ::: Someone is fat if and only if he is not jittery.\n(¬Expensive(lewis)) → (¬Cultural(tyra) ∧ ¬Cultural(neal)) ::: It can be concluded that Tyra is not wonderful and Neal is not cultural once knowing that Lewis is not expensive.\n(∃x (Able(x))) → (¬Expensive(clarence)) ::: If there is someone who is able, then Clarence is not expensive.\n(∀x ((¬Cultural(x) ∧ Wonderful(x))) → (Jittery(x))) ::: If someone who is not cultural is also wonderful, then he is jittery.\n(¬Cultural(george)) → (Jittery(lewis)) ::: It can be concluded that George is not cultural once knowing that Lewis is jittery.\n(∃x (¬Jittery(x))) → (Expensive(clarence) ∧ Cultural(neal)) ::: If there is at least one people who is not jittery, then Clarence is expensive and Neal is cultural.\n(∀x ((¬Cultural(x) ∧ ¬Able(x))) ↔ (¬Expensive(x))) ::: Someone being neither cultural nor able is equivalent to being not expensive.\n",
            "First-Order-Logic Question": "¬Cultural(lewis) ::: Lewis is not cultural."
        },
        "fixed": true
    },
    {
        "id": 1200,
        "raw_prog": {
            "First-Order-Logic Rules": "¬Several(rolf) ::: Rolf is not several.\n¬Precious(sigmund) ::: Sigmund is not precious.\nPrecious(godwin) ::: Godwin is precious.\nFearless(sigmund) ::: Sigmund is fearless.\nPrecious(rolf) ::: Rolf is precious.\n¬Stubborn(rose) ::: Rose is not stubborn.\nJittery(conrad) ::: Conrad is jittery.\n¬Fearless(brandi) ::: Brandi is not fearless.\n¬Sour(brandi) ::: Brandi is not sour.\nJittery(rolf) ::: Rolf is jittery.\nStubborn(owen) ::: Owen is stubborn.\n¬Fearless(godwin) ::: Godwin is not fearless.\n(¬∃x (¬x)) → (¬Jittery(godwin)) ::: If there is nobody who is not, then Godwin is not jittery.\n(∃x (Several(x) ∨ ¬Sour(x))) → (¬Stubborn(brandi)) ::: If there is someone who is either several or not sour, then Brandi is not stubborn.\n(∃x (¬Sour(x))) → (¬Stubborn(owen) ∧ ¬Several(conrad)) ::: If there is at least one people who is not sour, then Owen is not stubborn and Conrad is not several.\n(∀x (Several(x) → ¬Sour(x))) → (Stubborn(x)) ::: If someone who is several is also not sour, then he is stubborn.\n(∃x (Sour(x) ∨ Jittery(x))) → (¬Several(brandi) ∧ Stubborn(conrad)) ::: If there is at least one people who is either sour or jittery, then Brandi is not several and Conrad is stubborn.\n(¬Fearless(rolf)) → (¬Jittery(conrad)) ::: If Rolf is not fearless, then Conrad is not jittery.\n(¬Precious(godwin)) → (Jittery(godwin) ∧ ¬Fearless(owen)) ::: It can be concluded that Godwin is jittery and Owen is not fearless once knowing that Godwin is not precious.\n(¬Precious(sigmund)) → (¬Jittery(godwin) ∧ ¬Several(sigmund)) ::: It can be concluded that Sigmund is precious once knowing that Godwin is not jittery and Sigmund is not several.\n((Several(rolf) ∨ Fearless(brandi))) → (¬Precious(brandi)) ::: If Rolf is several or Brandi is fearless, then Brandi is not precious.\n(¬Jittery(godwin) ∧ Several(conrad)) → (Sour(owen)) ::: If Godwin is not jittery and Conrad is several, then Owen is sour.\n(∀x (Precious(x))) → (¬Several(x)) ::: Someone who is precious is always not several.\n(¬Fearless(godwin)) ↔ (Several(brandi)) ::: If Godwin is not fearless, then Brandi is several, and vice versa.\n",
            "First-Order-Logic Question": "Sour(brandi) ::: Brandi is sour."
        },
        "gram_prog": {
            "First-Order-Logic Rules": "¬Several(rolf) ::: Rolf is not several.\n¬Precious(sigmund) ::: Sigmund is not precious.\nPrecious(godwin) ::: Godwin is precious.\nFearless(sigmund) ::: Sigmund is fearless.\nPrecious(rolf) ::: Rolf is precious.\n¬Stubborn(rose) ::: Rose is not stubborn.\nJittery(conrad) ::: Conrad is jittery.\n¬Fearless(brandi) ::: Brandi is not fearless.\n¬Sour(brandi) ::: Brandi is not sour.\nJittery(rolf) ::: Rolf is jittery.\nStubborn(owen) ::: Owen is stubborn.\n¬Fearless(godwin) ::: Godwin is not fearless.\n¬∃x(¬(¬(¬Blue(x)))) ::: If there is nobody who is not, then Godwin is not jittery.\n(∃x (Several(x) ∨ ¬Sour(x))) → (¬Stubborn(brandi)) ::: If there is someone who is either several or not sour, then Brandi is not stubborn.\n(∃x (¬Sour(x))) → (¬Stubborn(owen) ∧ ¬Several(conrad)) ::: If there is at least one people who is not sour, then Owen is not stubborn and Conrad is not several.\n(∀x (Several(x) → ¬Sour(x))) → (Stubborn(x)) ::: If someone who is several is also not sour, then he is stubborn.\n(∃x (Sour(x) ∨ Jittery(x))) → (¬Several(brandi) ∧ Stubborn(conrad)) ::: If there is at least one people who is either sour or jittery, then Brandi is not several and Conrad is stubborn.\n(¬Fearless(rolf)) → (¬Jittery(conrad)) ::: If Rolf is not fearless, then Conrad is not jittery.\n(¬Precious(godwin)) → (Jittery(godwin) ∧ ¬Fearless(owen)) ::: It can be concluded that Godwin is jittery and Owen is not fearless once knowing that Godwin is not precious.\n(¬Precious(sigmund)) → (¬Jittery(godwin) ∧ ¬Several(sigmund)) ::: It can be concluded that Sigmund is precious once knowing that Godwin is not jittery and Sigmund is not several.\n((Several(rolf) ∨ Fearless(brandi))) → (¬Precious(brandi)) ::: If Rolf is several or Brandi is fearless, then Brandi is not precious.\n(¬Jittery(godwin) ∧ Several(conrad)) → (Sour(owen)) ::: If Godwin is not jittery and Conrad is several, then Owen is sour.\n(∀x (Precious(x))) → (¬Several(x)) ::: Someone who is precious is always not several.\n(¬Fearless(godwin)) ↔ (Several(brandi)) ::: If Godwin is not fearless, then Brandi is several, and vice versa.\n",
            "First-Order-Logic Question": "Sour(brandi) ::: Brandi is sour."
        },
        "diff": [
            {
                "raw": "(¬∃x (¬x)) → (¬Jittery(godwin)) ::: If there is nobody who is not, then Godwin is not jittery.",
                "gram": "¬∃x(¬(¬(¬Blue(x)))) ::: If there is nobody who is not, then Godwin is not jittery."
            }
        ],
        "answer": "B",
        "grammar_answer": "A",
        "manual_prog": {
            "First-Order-Logic Rules": "¬Several(rolf) ::: Rolf is not several.\n¬Precious(sigmund) ::: Sigmund is not precious.\nPrecious(godwin) ::: Godwin is precious.\nFearless(sigmund) ::: Sigmund is fearless.\nPrecious(rolf) ::: Rolf is precious.\n¬Stubborn(rose) ::: Rose is not stubborn.\nJittery(conrad) ::: Conrad is jittery.\n¬Fearless(brandi) ::: Brandi is not fearless.\n¬Sour(brandi) ::: Brandi is not sour.\nJittery(rolf) ::: Rolf is jittery.\nStubborn(owen) ::: Owen is stubborn.\n¬Fearless(godwin) ::: Godwin is not fearless.\n(¬Jittery(godwin)) ::: If there is nobody who is not, then Godwin is not jittery.\n(∃x (Several(x) ∨ ¬Sour(x))) → (¬Stubborn(brandi)) ::: If there is someone who is either several or not sour, then Brandi is not stubborn.\n(∃x (¬Sour(x))) → (¬Stubborn(owen) ∧ ¬Several(conrad)) ::: If there is at least one people who is not sour, then Owen is not stubborn and Conrad is not several.\n(∀x (Several(x) → ¬Sour(x))) → (Stubborn(x)) ::: If someone who is several is also not sour, then he is stubborn.\n(∃x (Sour(x) ∨ Jittery(x))) → (¬Several(brandi) ∧ Stubborn(conrad)) ::: If there is at least one people who is either sour or jittery, then Brandi is not several and Conrad is stubborn.\n(¬Fearless(rolf)) → (¬Jittery(conrad)) ::: If Rolf is not fearless, then Conrad is not jittery.\n(¬Precious(godwin)) → (Jittery(godwin) ∧ ¬Fearless(owen)) ::: It can be concluded that Godwin is jittery and Owen is not fearless once knowing that Godwin is not precious.\n(¬Precious(sigmund)) → (¬Jittery(godwin) ∧ ¬Several(sigmund)) ::: It can be concluded that Sigmund is precious once knowing that Godwin is not jittery and Sigmund is not several.\n((Several(rolf) ∨ Fearless(brandi))) → (¬Precious(brandi)) ::: If Rolf is several or Brandi is fearless, then Brandi is not precious.\n(¬Jittery(godwin) ∧ Several(conrad)) → (Sour(owen)) ::: If Godwin is not jittery and Conrad is several, then Owen is sour.\n(∀x (Precious(x))) → (¬Several(x)) ::: Someone who is precious is always not several.\n(¬Fearless(godwin)) ↔ (Several(brandi)) ::: If Godwin is not fearless, then Brandi is several, and vice versa.\n",
            "First-Order-Logic Question": "Sour(brandi) ::: Brandi is sour."
        },
        "fixed": true
    },
    {
        "id": 1201,
        "raw_prog": {
            "First-Order-Logic Rules": "¬Several(rolf) ::: Rolf is not several.\n¬Precious(sigmund) ::: Sigmund is not precious.\nPrecious(godwin) ::: Godwin is precious.\nFearless(sigmund) ::: Sigmund is fearless.\nPrecious(rolf) ::: Rolf is precious.\n¬Stubborn(rose) ::: Rose is not stubborn.\nJittery(conrad) ::: Conrad is jittery.\n¬Fearless(brandi) ::: Brandi is not fearless.\n¬Sour(brandi) ::: Brandi is not sour.\nJittery(rolf) ::: Rolf is jittery.\nStubborn(owen) ::: Owen is stubborn.\n¬Fearless(godwin) ::: Godwin is not fearless.\n(∀x (¬¬x)) → (¬Jittery(godwin)) ::: If there is nobody who is not, then Godwin is not jittery.\n(∃x (Several(x) ∨ ¬Sour(x))) → (¬Stubborn(brandi)) ::: If there is someone who is either several or not sour, then Brandi is not stubborn.\n(∃x (¬Sour(x))) → (¬Stubborn(owen) ∧ ¬Several(conrad)) ::: If there is at least one people who is not sour, then Owen is not stubborn and Conrad is not several.\n(∀x (Several(x) → ¬Sour(x))) → (Stubborn(x)) ::: If someone who is several is also not sour, then he is stubborn.\n(∃x (Sour(x) ∨ Jittery(x))) → (¬Several(brandi) ∧ Stubborn(conrad)) ::: If there is at least one people who is either sour or jittery, then Brandi is not several and Conrad is stubborn.\n(¬Fearless(rolf)) → (¬Jittery(conrad)) ::: If Rolf is not fearless, then Conrad is not jittery.\n(¬Precious(godwin)) → (Jittery(godwin) ∧ ¬Fearless(owen)) ::: It can be concluded that Godwin is jittery and Owen is not fearless once knowing that Godwin is not precious.\n(¬Jittery(godwin) ∧ ¬Several(sigmund)) → (Precious(sigmund)) ::: It can be concluded that Sigmund is precious once knowing that Godwin is not jittery and Sigmund is not several.\n((Several(rolf) ∨ Fearless(brandi))) → (¬Precious(brandi)) ::: If Rolf is several or Brandi is fearless, then Brandi is not precious.\n(¬Jittery(godwin) ∧ Several(conrad)) → (Sour(owen)) ::: If Godwin is not jittery and Conrad is several, then Owen is sour.\n(∀x (Precious(x))) → (¬Several(x)) ::: Someone who is precious is always not several.\n(¬Fearless(godwin)) ↔ (Several(brandi)) ::: If Godwin is not fearless, then Brandi is several, and vice versa.\n",
            "First-Order-Logic Question": "¬Fearless(rose) ::: Rose is not fearless."
        },
        "gram_prog": {
            "First-Order-Logic Rules": "¬Several(rolf) ::: Rolf is not several.\n¬Precious(sigmund) ::: Sigmund is not precious.\nPrecious(godwin) ::: Godwin is precious.\nFearless(sigmund) ::: Sigmund is fearless.\nPrecious(rolf) ::: Rolf is precious.\n¬Stubborn(rose) ::: Rose is not stubborn.\nJittery(conrad) ::: Conrad is jittery.\n¬Fearless(brandi) ::: Brandi is not fearless.\n¬Sour(brandi) ::: Brandi is not sour.\nJittery(rolf) ::: Rolf is jittery.\nStubborn(owen) ::: Owen is stubborn.\n¬Fearless(godwin) ::: Godwin is not fearless.\n¬¬(¬(¬(¬Serious(x)))) ::: If there is nobody who is not, then Godwin is not jittery.\n(∃x (Several(x) ∨ ¬Sour(x))) → (¬Stubborn(brandi)) ::: If there is someone who is either several or not sour, then Brandi is not stubborn.\n(∃x (¬Sour(x))) → (¬Stubborn(owen) ∧ ¬Several(conrad)) ::: If there is at least one people who is not sour, then Owen is not stubborn and Conrad is not several.\n(∀x (Several(x) → ¬Sour(x))) → (Stubborn(x)) ::: If someone who is several is also not sour, then he is stubborn.\n(∃x (Sour(x) ∨ Jittery(x))) → (¬Several(brandi) ∧ Stubborn(conrad)) ::: If there is at least one people who is either sour or jittery, then Brandi is not several and Conrad is stubborn.\n(¬Fearless(rolf)) → (¬Jittery(conrad)) ::: If Rolf is not fearless, then Conrad is not jittery.\n(¬Precious(godwin)) → (Jittery(godwin) ∧ ¬Fearless(owen)) ::: It can be concluded that Godwin is jittery and Owen is not fearless once knowing that Godwin is not precious.\n(¬Jittery(godwin) ∧ ¬Several(sigmund)) → (Precious(sigmund)) ::: It can be concluded that Sigmund is precious once knowing that Godwin is not jittery and Sigmund is not several.\n((Several(rolf) ∨ Fearless(brandi))) → (¬Precious(brandi)) ::: If Rolf is several or Brandi is fearless, then Brandi is not precious.\n(¬Jittery(godwin) ∧ Several(conrad)) → (Sour(owen)) ::: If Godwin is not jittery and Conrad is several, then Owen is sour.\n(∀x (Precious(x))) → (¬Several(x)) ::: Someone who is precious is always not several.\n(¬Fearless(godwin)) ↔ (Several(brandi)) ::: If Godwin is not fearless, then Brandi is several, and vice versa.\n",
            "First-Order-Logic Question": "¬Fearless(rose) ::: Rose is not fearless."
        },
        "diff": [
            {
                "raw": "(∀x (¬¬x)) → (¬Jittery(godwin)) ::: If there is nobody who is not, then Godwin is not jittery.",
                "gram": "¬¬(¬(¬(¬Serious(x)))) ::: If there is nobody who is not, then Godwin is not jittery."
            }
        ],
        "answer": "C",
        "grammar_answer": "A",
        "manual_prog": {
            "First-Order-Logic Rules": "¬Several(rolf) ::: Rolf is not several.\n¬Precious(sigmund) ::: Sigmund is not precious.\nPrecious(godwin) ::: Godwin is precious.\nFearless(sigmund) ::: Sigmund is fearless.\nPrecious(rolf) ::: Rolf is precious.\n¬Stubborn(rose) ::: Rose is not stubborn.\nJittery(conrad) ::: Conrad is jittery.\n¬Fearless(brandi) ::: Brandi is not fearless.\n¬Sour(brandi) ::: Brandi is not sour.\nJittery(rolf) ::: Rolf is jittery.\nStubborn(owen) ::: Owen is stubborn.\n¬Fearless(godwin) ::: Godwin is not fearless.\n(¬Jittery(godwin)) ::: If there is nobody who is not, then Godwin is not jittery.\n(∃x (Several(x) ∨ ¬Sour(x))) → (¬Stubborn(brandi)) ::: If there is someone who is either several or not sour, then Brandi is not stubborn.\n(∃x (¬Sour(x))) → (¬Stubborn(owen) ∧ ¬Several(conrad)) ::: If there is at least one people who is not sour, then Owen is not stubborn and Conrad is not several.\n(∀x (Several(x) → ¬Sour(x))) → (Stubborn(x)) ::: If someone who is several is also not sour, then he is stubborn.\n(∃x (Sour(x) ∨ Jittery(x))) → (¬Several(brandi) ∧ Stubborn(conrad)) ::: If there is at least one people who is either sour or jittery, then Brandi is not several and Conrad is stubborn.\n(¬Fearless(rolf)) → (¬Jittery(conrad)) ::: If Rolf is not fearless, then Conrad is not jittery.\n(¬Precious(godwin)) → (Jittery(godwin) ∧ ¬Fearless(owen)) ::: It can be concluded that Godwin is jittery and Owen is not fearless once knowing that Godwin is not precious.\n(¬Jittery(godwin) ∧ ¬Several(sigmund)) → (Precious(sigmund)) ::: It can be concluded that Sigmund is precious once knowing that Godwin is not jittery and Sigmund is not several.\n((Several(rolf) ∨ Fearless(brandi))) → (¬Precious(brandi)) ::: If Rolf is several or Brandi is fearless, then Brandi is not precious.\n(¬Jittery(godwin) ∧ Several(conrad)) → (Sour(owen)) ::: If Godwin is not jittery and Conrad is several, then Owen is sour.\n(∀x (Precious(x))) → (¬Several(x)) ::: Someone who is precious is always not several.\n(¬Fearless(godwin)) ↔ (Several(brandi)) ::: If Godwin is not fearless, then Brandi is several, and vice versa.\n",
            "First-Order-Logic Question": "¬Fearless(rose) ::: Rose is not fearless."
        },
        "fixed": true
    },
    {
        "id": 1207,
        "raw_prog": {
            "First-Order-Logic Rules": "¬Several(rolf) ::: Rolf is not several.\n¬Precious(sigmund) ::: Sigmund is not precious.\nPrecious(godwin) ::: Godwin is precious.\nFearless(sigmund) ::: Sigmund is fearless.\nPrecious(rolf) ::: Rolf is precious.\n¬Stubborn(rose) ::: Rose is not stubborn.\nJittery(conrad) ::: Conrad is jittery.\n¬Fearless(brandi) ::: Brandi is not fearless.\n¬Sour(brandi) ::: Brandi is not sour.\nJittery(rolf) ::: Rolf is jittery.\nStubborn(owen) ::: Owen is stubborn.\n¬Fearless(godwin) ::: Godwin is not fearless.\n(∀x (¬¬x)) → (¬Jittery(godwin)) ::: If there is nobody who is not, then Godwin is not jittery.\n(∃x (Several(x) ∨ ¬Sour(x))) → (¬Stubborn(brandi)) ::: If there is someone who is either several or not sour, then Brandi is not stubborn.\n(∃x (¬Sour(x))) → (¬Stubborn(owen) ∧ ¬Several(conrad)) ::: If there is at least one people who is not sour, then Owen is not stubborn and Conrad is not several.\n(∀x (Several(x) → ¬Sour(x))) → (Stubborn(x)) ::: If someone who is several is also not sour, then he is stubborn.\n(∃x (Sour(x) ∨ Jittery(x))) → (¬Several(brandi) ∧ Stubborn(conrad)) ::: If there is at least one people who is either sour or jittery, then Brandi is not several and Conrad is stubborn.\n(¬Fearless(rolf)) → (¬Jittery(conrad)) ::: If Rolf is not fearless, then Conrad is not jittery.\n(¬Precious(godwin)) → (Jittery(godwin) ∧ ¬Fearless(owen)) ::: It can be concluded that Godwin is jittery and Owen is not fearless once knowing that Godwin is not precious.\n(¬Precious(sigmund)) → (¬Jittery(godwin) ∧ ¬Several(sigmund)) ::: It can be concluded that Sigmund is precious once knowing that Godwin is not jittery and Sigmund is not several.\n((Several(rolf) ∨ Fearless(brandi))) → (¬Precious(brandi)) ::: If Rolf is several or Brandi is fearless, then Brandi is not precious.\n(¬Jittery(godwin) ∧ Several(conrad)) → (Sour(owen)) ::: If Godwin is not jittery and Conrad is several, then Owen is sour.\n(∀x (Precious(x))) → (¬Several(x)) ::: Someone who is precious is always not several.\n(¬Fearless(godwin)) → (Several(brandi) ↔ ¬Fearless(brandi)) ::: If Godwin is not fearless, then Brandi is several, and vice versa.\n",
            "First-Order-Logic Question": "Precious(conrad) ::: Conrad is precious."
        },
        "gram_prog": {
            "First-Order-Logic Rules": "¬Several(rolf) ::: Rolf is not several.\n¬Precious(sigmund) ::: Sigmund is not precious.\nPrecious(godwin) ::: Godwin is precious.\nFearless(sigmund) ::: Sigmund is fearless.\nPrecious(rolf) ::: Rolf is precious.\n¬Stubborn(rose) ::: Rose is not stubborn.\nJittery(conrad) ::: Conrad is jittery.\n¬Fearless(brandi) ::: Brandi is not fearless.\n¬Sour(brandi) ::: Brandi is not sour.\nJittery(rolf) ::: Rolf is jittery.\nStubborn(owen) ::: Owen is stubborn.\n¬Fearless(godwin) ::: Godwin is not fearless.\n¬¬(¬(¬(¬Serious(x)))) ::: If there is nobody who is not, then Godwin is not jittery.\n(∃x (Several(x) ∨ ¬Sour(x))) → (¬Stubborn(brandi)) ::: If there is someone who is either several or not sour, then Brandi is not stubborn.\n(∃x (¬Sour(x))) → (¬Stubborn(owen) ∧ ¬Several(conrad)) ::: If there is at least one people who is not sour, then Owen is not stubborn and Conrad is not several.\n(∀x (Several(x) → ¬Sour(x))) → (Stubborn(x)) ::: If someone who is several is also not sour, then he is stubborn.\n(∃x (Sour(x) ∨ Jittery(x))) → (¬Several(brandi) ∧ Stubborn(conrad)) ::: If there is at least one people who is either sour or jittery, then Brandi is not several and Conrad is stubborn.\n(¬Fearless(rolf)) → (¬Jittery(conrad)) ::: If Rolf is not fearless, then Conrad is not jittery.\n(¬Precious(godwin)) → (Jittery(godwin) ∧ ¬Fearless(owen)) ::: It can be concluded that Godwin is jittery and Owen is not fearless once knowing that Godwin is not precious.\n(¬Precious(sigmund)) → (¬Jittery(godwin) ∧ ¬Several(sigmund)) ::: It can be concluded that Sigmund is precious once knowing that Godwin is not jittery and Sigmund is not several.\n((Several(rolf) ∨ Fearless(brandi))) → (¬Precious(brandi)) ::: If Rolf is several or Brandi is fearless, then Brandi is not precious.\n(¬Jittery(godwin) ∧ Several(conrad)) → (Sour(owen)) ::: If Godwin is not jittery and Conrad is several, then Owen is sour.\n(∀x (Precious(x))) → (¬Several(x)) ::: Someone who is precious is always not several.\n(¬Fearless(godwin)) → (Several(brandi) ↔ ¬Fearless(brandi)) ::: If Godwin is not fearless, then Brandi is several, and vice versa.\n",
            "First-Order-Logic Question": "Precious(conrad) ::: Conrad is precious."
        },
        "diff": [
            {
                "raw": "(∀x (¬¬x)) → (¬Jittery(godwin)) ::: If there is nobody who is not, then Godwin is not jittery.",
                "gram": "¬¬(¬(¬(¬Serious(x)))) ::: If there is nobody who is not, then Godwin is not jittery."
            }
        ],
        "answer": "C",
        "grammar_answer": "A",
        "manual_prog": {
            "First-Order-Logic Rules": "¬Several(rolf) ::: Rolf is not several.\n¬Precious(sigmund) ::: Sigmund is not precious.\nPrecious(godwin) ::: Godwin is precious.\nFearless(sigmund) ::: Sigmund is fearless.\nPrecious(rolf) ::: Rolf is precious.\n¬Stubborn(rose) ::: Rose is not stubborn.\nJittery(conrad) ::: Conrad is jittery.\n¬Fearless(brandi) ::: Brandi is not fearless.\n¬Sour(brandi) ::: Brandi is not sour.\nJittery(rolf) ::: Rolf is jittery.\nStubborn(owen) ::: Owen is stubborn.\n¬Fearless(godwin) ::: Godwin is not fearless.\n(¬Jittery(godwin)) ::: If there is nobody who is not, then Godwin is not jittery.\n(∃x (Several(x) ∨ ¬Sour(x))) → (¬Stubborn(brandi)) ::: If there is someone who is either several or not sour, then Brandi is not stubborn.\n(∃x (¬Sour(x))) → (¬Stubborn(owen) ∧ ¬Several(conrad)) ::: If there is at least one people who is not sour, then Owen is not stubborn and Conrad is not several.\n(∀x (Several(x) → ¬Sour(x))) → (Stubborn(x)) ::: If someone who is several is also not sour, then he is stubborn.\n(∃x (Sour(x) ∨ Jittery(x))) → (¬Several(brandi) ∧ Stubborn(conrad)) ::: If there is at least one people who is either sour or jittery, then Brandi is not several and Conrad is stubborn.\n(¬Fearless(rolf)) → (¬Jittery(conrad)) ::: If Rolf is not fearless, then Conrad is not jittery.\n(¬Precious(godwin)) → (Jittery(godwin) ∧ ¬Fearless(owen)) ::: It can be concluded that Godwin is jittery and Owen is not fearless once knowing that Godwin is not precious.\n(¬Precious(sigmund)) → (¬Jittery(godwin) ∧ ¬Several(sigmund)) ::: It can be concluded that Sigmund is precious once knowing that Godwin is not jittery and Sigmund is not several.\n((Several(rolf) ∨ Fearless(brandi))) → (¬Precious(brandi)) ::: If Rolf is several or Brandi is fearless, then Brandi is not precious.\n(¬Jittery(godwin) ∧ Several(conrad)) → (Sour(owen)) ::: If Godwin is not jittery and Conrad is several, then Owen is sour.\n(∀x (Precious(x))) → (¬Several(x)) ::: Someone who is precious is always not several.\n(¬Fearless(godwin)) → (Several(brandi) ↔ ¬Fearless(brandi)) ::: If Godwin is not fearless, then Brandi is several, and vice versa.\n",
            "First-Order-Logic Question": "Precious(conrad) ::: Conrad is precious."
        },
        "fixed": true
    },
    {
        "id": 1353,
        "raw_prog": {
            "First-Order-Logic Rules": "¬New(howard) ::: Howard is not new.\nNew(cara) ::: Cara is new.\n¬Granite(howard) ::: Howard is not granite.\n¬Granite(luka) ::: Luka is not granite.\nComfortable(christopher) ::: Christopher is comfortable.\n¬Soft(blaine) ::: Blaine is not soft.\n¬Cheap(blaine) ::: Blaine is not cheap.\nComfortable(luka) ::: Luka is comfortable.\nShiny(algernon) ::: Algernon is shiny.\nSoft(howard) ::: Howard is soft.\nShiny(cara) ::: Cara is shiny.\nGranite(cara) ::: Cara is granite.\n((¬Cheap(algernon))) ↔ ((¬Comfortable(howard))) ::: Algernon is not cheap if and only if Howard is not comfortable.\n(∀x (Cheap(x) ∧ Comfortable(x))) ↔ (Soft(x)) ::: Someone is cheap and comfortable if and only if he is soft.\n(∀x (Comfortable(x) ∨ New(x))) → (∀x (¬Cheap(x) ∧ ¬Granite(x))) ::: Someone who is comfortable or new is always not cheap and not granite.\n(∀x (Soft(x))) → ((Comfortable(x) ∧ Cheap(x))) ::: As long as someone is soft, he is comfortable and cheap.\n((Shiny(cara))) ↔ ((¬New(cara) ∧ Comfortable(cara))) ::: Cara is shiny if and only if Cara is not new and Cara is comfortable.\n((¬Soft(christopher))) → ((¬Comfortable(graciela) ∧ Cheap(graciela))) ::: If Christopher is not soft, then Graciela is not comfortable and Graciela is cheap, and vice versa.\n(∀x (¬New(x) ∧ ¬Soft(x))) ↔ ((Shiny(x) ∧ Comfortable(x))) ::: Someone being neither new nor soft is equivalent to being shiny and comfortable.\n(∃x (Soft(x))) → (New(howard)) ::: If there is someone who is soft, then Howard is new.\n((Shiny(howard))) → ((¬Soft(howard) ∧ New(christopher))) ::: It can be concluded that Howard is not soft and Christopher is new once knowing that Howard is shiny.\n((Cheap(graciela) ∧ ¬Soft(christopher)) → (¬New(cara)) ::: If Graciela is cheap and Christopher is not soft, then Cara is not new.\n((¬New(graciela))) ↔ ((¬Granite(howard))) ::: Graciela being not new is equivalent to Howard being not granite.\n(∃x (Soft(x) ∧ ¬Comfortable(x))) → (Granite(blaine)) ::: If there is at least one people who is both soft and not comfortable, then Blaine is granite.\n",
            "First-Order-Logic Question": "¬Shiny(algernon) ::: Algernon is not shiny."
        },
        "gram_prog": {
            "First-Order-Logic Rules": "¬New(howard) ::: Howard is not new.\nNew(cara) ::: Cara is new.\n¬Granite(howard) ::: Howard is not granite.\n¬Granite(luka) ::: Luka is not granite.\nComfortable(christopher) ::: Christopher is comfortable.\n¬Soft(blaine) ::: Blaine is not soft.\n¬Cheap(blaine) ::: Blaine is not cheap.\nComfortable(luka) ::: Luka is comfortable.\nShiny(algernon) ::: Algernon is shiny.\nSoft(howard) ::: Howard is soft.\nShiny(cara) ::: Cara is shiny.\nGranite(cara) ::: Cara is granite.\n((¬Cheap(algernon))) ↔ ((¬Comfortable(howard))) ::: Algernon is not cheap if and only if Howard is not comfortable.\n(∀x (Cheap(x) ∧ Comfortable(x))) ↔ (Soft(x)) ::: Someone is cheap and comfortable if and only if he is soft.\n(∀x (Comfortable(x) ∨ New(x))) → (∀x (¬Cheap(x) ∧ ¬Granite(x))) ::: Someone who is comfortable or new is always not cheap and not granite.\n(∀x (Soft(x))) → ((Comfortable(x) ∧ Cheap(x))) ::: As long as someone is soft, he is comfortable and cheap.\n((Shiny(cara))) ↔ ((¬New(cara) ∧ Comfortable(cara))) ::: Cara is shiny if and only if Cara is not new and Cara is comfortable.\n((¬Soft(christopher))) → ((¬Comfortable(graciela) ∧ Cheap(graciela))) ::: If Christopher is not soft, then Graciela is not comfortable and Graciela is cheap, and vice versa.\n(∀x (¬New(x) ∧ ¬Soft(x))) ↔ ((Shiny(x) ∧ Comfortable(x))) ::: Someone being neither new nor soft is equivalent to being shiny and comfortable.\n(∃x (Soft(x))) → (New(howard)) ::: If there is someone who is soft, then Howard is new.\n((Shiny(howard))) → ((¬Soft(howard) ∧ New(christopher))) ::: It can be concluded that Howard is not soft and Christopher is new once knowing that Howard is shiny.\n¬(Fresh(x)→(Serious(x))) ::: If Graciela is cheap and Christopher is not soft, then Cara is not new.\n((¬New(graciela))) ↔ ((¬Granite(howard))) ::: Graciela being not new is equivalent to Howard being not granite.\n(∃x (Soft(x) ∧ ¬Comfortable(x))) → (Granite(blaine)) ::: If there is at least one people who is both soft and not comfortable, then Blaine is granite.\n",
            "First-Order-Logic Question": "¬Shiny(algernon) ::: Algernon is not shiny."
        },
        "diff": [
            {
                "raw": "((Cheap(graciela) ∧ ¬Soft(christopher)) → (¬New(cara)) ::: If Graciela is cheap and Christopher is not soft, then Cara is not new.",
                "gram": "¬(Fresh(x)→(Serious(x))) ::: If Graciela is cheap and Christopher is not soft, then Cara is not new."
            }
        ],
        "answer": "B",
        "grammar_answer": "A",
        "manual_prog": {
            "First-Order-Logic Rules": "¬New(howard) ::: Howard is not new.\nNew(cara) ::: Cara is new.\n¬Granite(howard) ::: Howard is not granite.\n¬Granite(luka) ::: Luka is not granite.\nComfortable(christopher) ::: Christopher is comfortable.\n¬Soft(blaine) ::: Blaine is not soft.\n¬Cheap(blaine) ::: Blaine is not cheap.\nComfortable(luka) ::: Luka is comfortable.\nShiny(algernon) ::: Algernon is shiny.\nSoft(howard) ::: Howard is soft.\nShiny(cara) ::: Cara is shiny.\nGranite(cara) ::: Cara is granite.\n((¬Cheap(algernon))) ↔ ((¬Comfortable(howard))) ::: Algernon is not cheap if and only if Howard is not comfortable.\n(∀x (Cheap(x) ∧ Comfortable(x))) ↔ (Soft(x)) ::: Someone is cheap and comfortable if and only if he is soft.\n(∀x (Comfortable(x) ∨ New(x))) → (∀x (¬Cheap(x) ∧ ¬Granite(x))) ::: Someone who is comfortable or new is always not cheap and not granite.\n(∀x (Soft(x))) → ((Comfortable(x) ∧ Cheap(x))) ::: As long as someone is soft, he is comfortable and cheap.\n((Shiny(cara))) ↔ ((¬New(cara) ∧ Comfortable(cara))) ::: Cara is shiny if and only if Cara is not new and Cara is comfortable.\n((¬Soft(christopher))) → ((¬Comfortable(graciela) ∧ Cheap(graciela))) ::: If Christopher is not soft, then Graciela is not comfortable and Graciela is cheap, and vice versa.\n(∀x (¬New(x) ∧ ¬Soft(x))) ↔ ((Shiny(x) ∧ Comfortable(x))) ::: Someone being neither new nor soft is equivalent to being shiny and comfortable.\n(∃x (Soft(x))) → (New(howard)) ::: If there is someone who is soft, then Howard is new.\n((Shiny(howard))) → ((¬Soft(howard) ∧ New(christopher))) ::: It can be concluded that Howard is not soft and Christopher is new once knowing that Howard is shiny.\n((Cheap(graciela) ∧ ¬Soft(christopher)) → (¬New(cara))) ::: If Graciela is cheap and Christopher is not soft, then Cara is not new.\n((¬New(graciela))) ↔ ((¬Granite(howard))) ::: Graciela being not new is equivalent to Howard being not granite.\n(∃x (Soft(x) ∧ ¬Comfortable(x))) → (Granite(blaine)) ::: If there is at least one people who is both soft and not comfortable, then Blaine is granite.\n",
            "First-Order-Logic Question": "¬Shiny(algernon) ::: Algernon is not shiny."
        },
        "fixed": true
    },
    {
        "id": 1356,
        "raw_prog": {
            "First-Order-Logic Rules": "¬New(howard) ::: Howard is not new.\nNew(cara) ::: Cara is new.\n¬Granite(howard) ::: Howard is not granite.\n¬Granite(luka) ::: Luka is not granite.\nComfortable(christopher) ::: Christopher is comfortable.\n¬Soft(blaine) ::: Blaine is not soft.\n¬Cheap(blaine) ::: Blaine is not cheap.\nComfortable(luka) ::: Luka is comfortable.\nShiny(algernon) ::: Algernon is shiny.\nSoft(howard) ::: Howard is soft.\nShiny(cara) ::: Cara is shiny.\nGranite(cara) ::: Cara is granite.\n(¬Cheap(algernon)) ↔ (¬Comfortable(howard)) ::: Algernon is not cheap if and only if Howard is not comfortable.\n((Cheap(x) ∧ Comfortable(x))) ↔ (Soft(x)) ::: Someone is cheap and comfortable if and only if he is soft.\n((Comfortable(x) ∨ New(x))) → ((¬Cheap(x) ∧ ¬Granite(x))) ::: Someone who is comfortable or new is always not cheap and not granite.\n(∀x (Soft(x))) → ((Comfortable(x) ∧ Cheap(x))) ::: As long as someone is soft, he is comfortable and cheap.\n(Shiny(cara)) ↔ ((¬New(cara) ∧ Comfortable(cara))) ::: Cara is shiny if and only if Cara is not new and Cara is comfortable.\n((¬Soft(christopher))) → ((¬Comfortable(graciela) ∧ Cheap(graciela))) ::: If Christopher is not soft, then Graciela is not comfortable and Graciela is cheap, and vice versa.\n((¬New(x) ∧ ¬Soft(x))) ↔ ((Shiny(x) ∧ Comfortable(x))) ::: Someone being neither new nor soft is equivalent to being shiny and comfortable.\n(∃x (Soft(x))) → (New(howard)) ::: If there is someone who is soft, then Howard is new.\n((Shiny(howard))) ↔ ((¬Soft(howard) ∧ New(christopher))) ::: It can be concluded that Howard is not soft and Christopher is new once knowing that Howard is shiny.\n((Cheap(graciela) ∧ ¬Soft(christopher)) → (¬New(cara)) ::: If Graciela is cheap and Christopher is not soft, then Cara is not new.\n((¬New(graciela))) ↔ ((¬Granite(howard))) ::: Graciela being not new is equivalent to Howard being not granite.\n(∃x (Soft(x) ∧ ¬Comfortable(x))) → (Granite(blaine)) ::: If there is at least one people who is both soft and not comfortable, then Blaine is granite.\n",
            "First-Order-Logic Question": "Shiny(luka) ::: Luka is shiny."
        },
        "gram_prog": {
            "First-Order-Logic Rules": "¬New(howard) ::: Howard is not new.\nNew(cara) ::: Cara is new.\n¬Granite(howard) ::: Howard is not granite.\n¬Granite(luka) ::: Luka is not granite.\nComfortable(christopher) ::: Christopher is comfortable.\n¬Soft(blaine) ::: Blaine is not soft.\n¬Cheap(blaine) ::: Blaine is not cheap.\nComfortable(luka) ::: Luka is comfortable.\nShiny(algernon) ::: Algernon is shiny.\nSoft(howard) ::: Howard is soft.\nShiny(cara) ::: Cara is shiny.\nGranite(cara) ::: Cara is granite.\n(¬Cheap(algernon)) ↔ (¬Comfortable(howard)) ::: Algernon is not cheap if and only if Howard is not comfortable.\n((Cheap(x) ∧ Comfortable(x))) ↔ (Soft(x)) ::: Someone is cheap and comfortable if and only if he is soft.\n((Comfortable(x) ∨ New(x))) → ((¬Cheap(x) ∧ ¬Granite(x))) ::: Someone who is comfortable or new is always not cheap and not granite.\n(∀x (Soft(x))) → ((Comfortable(x) ∧ Cheap(x))) ::: As long as someone is soft, he is comfortable and cheap.\n(Shiny(cara)) ↔ ((¬New(cara) ∧ Comfortable(cara))) ::: Cara is shiny if and only if Cara is not new and Cara is comfortable.\n((¬Soft(christopher))) → ((¬Comfortable(graciela) ∧ Cheap(graciela))) ::: If Christopher is not soft, then Graciela is not comfortable and Graciela is cheap, and vice versa.\n((¬New(x) ∧ ¬Soft(x))) ↔ ((Shiny(x) ∧ Comfortable(x))) ::: Someone being neither new nor soft is equivalent to being shiny and comfortable.\n(∃x (Soft(x))) → (New(howard)) ::: If there is someone who is soft, then Howard is new.\n((Shiny(howard))) ↔ ((¬Soft(howard) ∧ New(christopher))) ::: It can be concluded that Howard is not soft and Christopher is new once knowing that Howard is shiny.\n¬(Fresh(x)→(Serious(x))) ::: If Graciela is cheap and Christopher is not soft, then Cara is not new.\n((¬New(graciela))) ↔ ((¬Granite(howard))) ::: Graciela being not new is equivalent to Howard being not granite.\n(∃x (Soft(x) ∧ ¬Comfortable(x))) → (Granite(blaine)) ::: If there is at least one people who is both soft and not comfortable, then Blaine is granite.\n",
            "First-Order-Logic Question": "Shiny(luka) ::: Luka is shiny."
        },
        "diff": [
            {
                "raw": "((Cheap(graciela) ∧ ¬Soft(christopher)) → (¬New(cara)) ::: If Graciela is cheap and Christopher is not soft, then Cara is not new.",
                "gram": "¬(Fresh(x)→(Serious(x))) ::: If Graciela is cheap and Christopher is not soft, then Cara is not new."
            }
        ],
        "answer": "C",
        "grammar_answer": "A",
        "manual_prog": {
            "First-Order-Logic Rules": "¬New(howard) ::: Howard is not new.\nNew(cara) ::: Cara is new.\n¬Granite(howard) ::: Howard is not granite.\n¬Granite(luka) ::: Luka is not granite.\nComfortable(christopher) ::: Christopher is comfortable.\n¬Soft(blaine) ::: Blaine is not soft.\n¬Cheap(blaine) ::: Blaine is not cheap.\nComfortable(luka) ::: Luka is comfortable.\nShiny(algernon) ::: Algernon is shiny.\nSoft(howard) ::: Howard is soft.\nShiny(cara) ::: Cara is shiny.\nGranite(cara) ::: Cara is granite.\n(¬Cheap(algernon)) ↔ (¬Comfortable(howard)) ::: Algernon is not cheap if and only if Howard is not comfortable.\n((Cheap(x) ∧ Comfortable(x))) ↔ (Soft(x)) ::: Someone is cheap and comfortable if and only if he is soft.\n((Comfortable(x) ∨ New(x))) → ((¬Cheap(x) ∧ ¬Granite(x))) ::: Someone who is comfortable or new is always not cheap and not granite.\n(∀x (Soft(x))) → ((Comfortable(x) ∧ Cheap(x))) ::: As long as someone is soft, he is comfortable and cheap.\n(Shiny(cara)) ↔ ((¬New(cara) ∧ Comfortable(cara))) ::: Cara is shiny if and only if Cara is not new and Cara is comfortable.\n((¬Soft(christopher))) → ((¬Comfortable(graciela) ∧ Cheap(graciela))) ::: If Christopher is not soft, then Graciela is not comfortable and Graciela is cheap, and vice versa.\n((¬New(x) ∧ ¬Soft(x))) ↔ ((Shiny(x) ∧ Comfortable(x))) ::: Someone being neither new nor soft is equivalent to being shiny and comfortable.\n(∃x (Soft(x))) → (New(howard)) ::: If there is someone who is soft, then Howard is new.\n((Shiny(howard))) ↔ ((¬Soft(howard) ∧ New(christopher))) ::: It can be concluded that Howard is not soft and Christopher is new once knowing that Howard is shiny.\n((Cheap(graciela) ∧ ¬Soft(christopher)) → (¬New(cara))) ::: If Graciela is cheap and Christopher is not soft, then Cara is not new.\n((¬New(graciela))) ↔ ((¬Granite(howard))) ::: Graciela being not new is equivalent to Howard being not granite.\n(∃x (Soft(x) ∧ ¬Comfortable(x))) → (Granite(blaine)) ::: If there is at least one people who is both soft and not comfortable, then Blaine is granite.\n",
            "First-Order-Logic Question": "Shiny(luka) ::: Luka is shiny."
        },
        "fixed": true
    },
    {
        "id": 1357,
        "raw_prog": {
            "First-Order-Logic Rules": "¬New(howard) ::: Howard is not new.\nNew(cara) ::: Cara is new.\n¬Granite(howard) ::: Howard is not granite.\n¬Granite(luka) ::: Luka is not granite.\nComfortable(christopher) ::: Christopher is comfortable.\n¬Soft(blaine) ::: Blaine is not soft.\n¬Cheap(blaine) ::: Blaine is not cheap.\nComfortable(luka) ::: Luka is comfortable.\nShiny(algernon) ::: Algernon is shiny.\nSoft(howard) ::: Howard is soft.\nShiny(cara) ::: Cara is shiny.\nGranite(cara) ::: Cara is granite.\n((¬Cheap(algernon)) ↔ (¬Comfortable(howard))) ::: Algernon is not cheap if and only if Howard is not comfortable.\n((Cheap(x) ∧ Comfortable(x)) ↔ Soft(x)) ::: Someone is cheap and comfortable if and only if he is soft.\n((Comfortable(x) ∨ New(x)) → (¬Cheap(x) ∧ ¬Granite(x))) ::: Someone who is comfortable or new is always not cheap and not granite.\n((Soft(x)) → (Comfortable(x) ∧ Cheap(x))) ::: As long as someone is soft, he is comfortable and cheap.\n((Shiny(cara)) ↔ ((¬New(cara)) ∧ Comfortable(cara))) ::: Cara is shiny if and only if Cara is not new and Cara is comfortable.\n((¬Soft(christopher)) → ((¬Comfortable(graciela) ∧ Cheap(graciela)))) ↔ ((Soft(christopher)) → ((Comfortable(graciela) ∧ ¬Cheap(graciela))) ::: If Christopher is not soft, then Graciela is not comfortable and Graciela is cheap, and vice versa.\n((¬New(x) ∧ ¬Soft(x)) ↔ (Shiny(x) ∧ Comfortable(x))) ::: Someone being neither new nor soft is equivalent to being shiny and comfortable.\n((∃x (Soft(x))) → (New(howard))) ::: If there is someone who is soft, then Howard is new.\n((Shiny(howard))) → ((¬Soft(howard) ∧ New(christopher))) ::: It can be concluded that Howard is not soft and Christopher is new once knowing that Howard is shiny.\n((Cheap(graciela) ∧ ¬Soft(christopher)) → (¬New(cara))) ::: If Graciela is cheap and Christopher is not soft, then Cara is not new.\n((¬New(graciela)) ↔ (¬Granite(howard))) ::: Graciela being not new is equivalent to Howard being not granite.\n((∃x (Soft(x) ∧ ¬Comfortable(x))) → (Granite(blaine))) ::: If there is at least one people who is both soft and not comfortable, then Blaine is granite.\n",
            "First-Order-Logic Question": "Comfortable(blaine) ::: Blaine is comfortable."
        },
        "gram_prog": {
            "First-Order-Logic Rules": "¬New(howard) ::: Howard is not new.\nNew(cara) ::: Cara is new.\n¬Granite(howard) ::: Howard is not granite.\n¬Granite(luka) ::: Luka is not granite.\nComfortable(christopher) ::: Christopher is comfortable.\n¬Soft(blaine) ::: Blaine is not soft.\n¬Cheap(blaine) ::: Blaine is not cheap.\nComfortable(luka) ::: Luka is comfortable.\nShiny(algernon) ::: Algernon is shiny.\nSoft(howard) ::: Howard is soft.\nShiny(cara) ::: Cara is shiny.\nGranite(cara) ::: Cara is granite.\n((¬Cheap(algernon)) ↔ (¬Comfortable(howard))) ::: Algernon is not cheap if and only if Howard is not comfortable.\n((Cheap(x) ∧ Comfortable(x)) ↔ Soft(x)) ::: Someone is cheap and comfortable if and only if he is soft.\n((Comfortable(x) ∨ New(x)) → (¬Cheap(x) ∧ ¬Granite(x))) ::: Someone who is comfortable or new is always not cheap and not granite.\n((Soft(x)) → (Comfortable(x) ∧ Cheap(x))) ::: As long as someone is soft, he is comfortable and cheap.\n((Shiny(cara)) ↔ ((¬New(cara)) ∧ Comfortable(cara))) ::: Cara is shiny if and only if Cara is not new and Cara is comfortable.\n¬Serious(x)→((¬Fresh(x))) ::: If Christopher is not soft, then Graciela is not comfortable and Graciela is cheap, and vice versa.\n((¬New(x) ∧ ¬Soft(x)) ↔ (Shiny(x) ∧ Comfortable(x))) ::: Someone being neither new nor soft is equivalent to being shiny and comfortable.\n((∃x (Soft(x))) → (New(howard))) ::: If there is someone who is soft, then Howard is new.\n((Shiny(howard))) → ((¬Soft(howard) ∧ New(christopher))) ::: It can be concluded that Howard is not soft and Christopher is new once knowing that Howard is shiny.\n((Cheap(graciela) ∧ ¬Soft(christopher)) → (¬New(cara))) ::: If Graciela is cheap and Christopher is not soft, then Cara is not new.\n((¬New(graciela)) ↔ (¬Granite(howard))) ::: Graciela being not new is equivalent to Howard being not granite.\n((∃x (Soft(x) ∧ ¬Comfortable(x))) → (Granite(blaine))) ::: If there is at least one people who is both soft and not comfortable, then Blaine is granite.\n",
            "First-Order-Logic Question": "Comfortable(blaine) ::: Blaine is comfortable."
        },
        "diff": [
            {
                "raw": "((¬Soft(christopher)) → ((¬Comfortable(graciela) ∧ Cheap(graciela)))) ↔ ((Soft(christopher)) → ((Comfortable(graciela) ∧ ¬Cheap(graciela))) ::: If Christopher is not soft, then Graciela is not comfortable and Graciela is cheap, and vice versa.",
                "gram": "¬Serious(x)→((¬Fresh(x))) ::: If Christopher is not soft, then Graciela is not comfortable and Graciela is cheap, and vice versa."
            }
        ],
        "answer": "C",
        "grammar_answer": "A",
        "manual_prog": {
            "First-Order-Logic Rules": "¬New(howard) ::: Howard is not new.\nNew(cara) ::: Cara is new.\n¬Granite(howard) ::: Howard is not granite.\n¬Granite(luka) ::: Luka is not granite.\nComfortable(christopher) ::: Christopher is comfortable.\n¬Soft(blaine) ::: Blaine is not soft.\n¬Cheap(blaine) ::: Blaine is not cheap.\nComfortable(luka) ::: Luka is comfortable.\nShiny(algernon) ::: Algernon is shiny.\nSoft(howard) ::: Howard is soft.\nShiny(cara) ::: Cara is shiny.\nGranite(cara) ::: Cara is granite.\n((¬Cheap(algernon)) ↔ (¬Comfortable(howard))) ::: Algernon is not cheap if and only if Howard is not comfortable.\n((Cheap(x) ∧ Comfortable(x)) ↔ Soft(x)) ::: Someone is cheap and comfortable if and only if he is soft.\n((Comfortable(x) ∨ New(x)) → (¬Cheap(x) ∧ ¬Granite(x))) ::: Someone who is comfortable or new is always not cheap and not granite.\n((Soft(x)) → (Comfortable(x) ∧ Cheap(x))) ::: As long as someone is soft, he is comfortable and cheap.\n((Shiny(cara)) ↔ ((¬New(cara)) ∧ Comfortable(cara))) ::: Cara is shiny if and only if Cara is not new and Cara is comfortable.\n((¬Soft(christopher)) → ((¬Comfortable(graciela) ∧ Cheap(graciela)))) ↔ ((Soft(christopher)) → ((Comfortable(graciela) ∧ ¬Cheap(graciela)))) ::: If Christopher is not soft, then Graciela is not comfortable and Graciela is cheap, and vice versa.\n((¬New(x) ∧ ¬Soft(x)) ↔ (Shiny(x) ∧ Comfortable(x))) ::: Someone being neither new nor soft is equivalent to being shiny and comfortable.\n((∃x (Soft(x))) → (New(howard))) ::: If there is someone who is soft, then Howard is new.\n((Shiny(howard))) → ((¬Soft(howard) ∧ New(christopher))) ::: It can be concluded that Howard is not soft and Christopher is new once knowing that Howard is shiny.\n((Cheap(graciela) ∧ ¬Soft(christopher)) → (¬New(cara))) ::: If Graciela is cheap and Christopher is not soft, then Cara is not new.\n((¬New(graciela)) ↔ (¬Granite(howard))) ::: Graciela being not new is equivalent to Howard being not granite.\n((∃x (Soft(x) ∧ ¬Comfortable(x))) → (Granite(blaine))) ::: If there is at least one people who is both soft and not comfortable, then Blaine is granite.\n",
            "First-Order-Logic Question": "Comfortable(blaine) ::: Blaine is comfortable."
        },
        "fixed": true
    },
    {
        "id": 1362,
        "raw_prog": {
            "First-Order-Logic Rules": "¬New(howard) ::: Howard is not new.\nNew(cara) ::: Cara is new.\n¬Granite(howard) ::: Howard is not granite.\n¬Granite(luka) ::: Luka is not granite.\nComfortable(christopher) ::: Christopher is comfortable.\n¬Soft(blaine) ::: Blaine is not soft.\n¬Cheap(blaine) ::: Blaine is not cheap.\nComfortable(luka) ::: Luka is comfortable.\nShiny(algernon) ::: Algernon is shiny.\nSoft(howard) ::: Howard is soft.\nShiny(cara) ::: Cara is shiny.\nGranite(cara) ::: Cara is granite.\n(¬Cheap(algernon)) ↔ (¬Comfortable(howard)) ::: Algernon is not cheap if and only if Howard is not comfortable.\n((Cheap(x) ∧ Comfortable(x))) ↔ (Soft(x)) ::: Someone is cheap and comfortable if and only if he is soft.\n((Comfortable(x) ∨ New(x))) → ((¬Cheap(x) ∧ ¬Granite(x))) ::: Someone who is comfortable or new is always not cheap and not granite.\n(∀x (Soft(x))) → ((Comfortable(x) ∧ Cheap(x))) ::: As long as someone is soft, he is comfortable and cheap.\n((Shiny(cara))) ↔ ((¬New(cara) ∧ Comfortable(cara))) ::: Cara is shiny if and only if Cara is not new and Cara is comfortable.\n((¬Soft(christopher))) → ((¬Comfortable(graciela) ∧ Cheap(graciela))) ::: If Christopher is not soft, then Graciela is not comfortable and Graciela is cheap, and vice versa.\n(¬New(x) ∧ ¬Soft(x)) ↔ (Shiny(x) ∧ Comfortable(x)) ::: Someone being neither new nor soft is equivalent to being shiny and comfortable.\n(∃x (Soft(x))) → (New(howard)) ::: If there is someone who is soft, then Howard is new.\n((Shiny(howard))) ↔ ((¬Soft(howard) ∧ New(christopher))) ::: It can be concluded that Howard is not soft and Christopher is new once knowing that Howard is shiny.\n((Cheap(graciela) ∧ ¬Soft(christopher)) → (¬New(cara)) ::: If Graciela is cheap and Christopher is not soft, then Cara is not new.\n(¬New(graciela)) ↔ (¬Granite(howard)) ::: Graciela being not new is equivalent to Howard being not granite.\n(∃x (Soft(x) ∧ ¬Comfortable(x))) → (Granite(blaine)) ::: If there is at least one people who is both soft and not comfortable, then Blaine is granite.\n",
            "First-Order-Logic Question": "Granite(luka) ::: Luka is granite."
        },
        "gram_prog": {
            "First-Order-Logic Rules": "¬New(howard) ::: Howard is not new.\nNew(cara) ::: Cara is new.\n¬Granite(howard) ::: Howard is not granite.\n¬Granite(luka) ::: Luka is not granite.\nComfortable(christopher) ::: Christopher is comfortable.\n¬Soft(blaine) ::: Blaine is not soft.\n¬Cheap(blaine) ::: Blaine is not cheap.\nComfortable(luka) ::: Luka is comfortable.\nShiny(algernon) ::: Algernon is shiny.\nSoft(howard) ::: Howard is soft.\nShiny(cara) ::: Cara is shiny.\nGranite(cara) ::: Cara is granite.\n(¬Cheap(algernon)) ↔ (¬Comfortable(howard)) ::: Algernon is not cheap if and only if Howard is not comfortable.\n((Cheap(x) ∧ Comfortable(x))) ↔ (Soft(x)) ::: Someone is cheap and comfortable if and only if he is soft.\n((Comfortable(x) ∨ New(x))) → ((¬Cheap(x) ∧ ¬Granite(x))) ::: Someone who is comfortable or new is always not cheap and not granite.\n(∀x (Soft(x))) → ((Comfortable(x) ∧ Cheap(x))) ::: As long as someone is soft, he is comfortable and cheap.\n((Shiny(cara))) ↔ ((¬New(cara) ∧ Comfortable(cara))) ::: Cara is shiny if and only if Cara is not new and Cara is comfortable.\n((¬Soft(christopher))) → ((¬Comfortable(graciela) ∧ Cheap(graciela))) ::: If Christopher is not soft, then Graciela is not comfortable and Graciela is cheap, and vice versa.\n(¬New(x) ∧ ¬Soft(x)) ↔ (Shiny(x) ∧ Comfortable(x)) ::: Someone being neither new nor soft is equivalent to being shiny and comfortable.\n(∃x (Soft(x))) → (New(howard)) ::: If there is someone who is soft, then Howard is new.\n((Shiny(howard))) ↔ ((¬Soft(howard) ∧ New(christopher))) ::: It can be concluded that Howard is not soft and Christopher is new once knowing that Howard is shiny.\n¬(Fresh(x)→(Serious(x))) ::: If Graciela is cheap and Christopher is not soft, then Cara is not new.\n(¬New(graciela)) ↔ (¬Granite(howard)) ::: Graciela being not new is equivalent to Howard being not granite.\n(∃x (Soft(x) ∧ ¬Comfortable(x))) → (Granite(blaine)) ::: If there is at least one people who is both soft and not comfortable, then Blaine is granite.\n",
            "First-Order-Logic Question": "Granite(luka) ::: Luka is granite."
        },
        "diff": [
            {
                "raw": "((Cheap(graciela) ∧ ¬Soft(christopher)) → (¬New(cara)) ::: If Graciela is cheap and Christopher is not soft, then Cara is not new.",
                "gram": "¬(Fresh(x)→(Serious(x))) ::: If Graciela is cheap and Christopher is not soft, then Cara is not new."
            }
        ],
        "answer": "B",
        "grammar_answer": "A",
        "manual_prog": {
            "First-Order-Logic Rules": "¬New(howard) ::: Howard is not new.\nNew(cara) ::: Cara is new.\n¬Granite(howard) ::: Howard is not granite.\n¬Granite(luka) ::: Luka is not granite.\nComfortable(christopher) ::: Christopher is comfortable.\n¬Soft(blaine) ::: Blaine is not soft.\n¬Cheap(blaine) ::: Blaine is not cheap.\nComfortable(luka) ::: Luka is comfortable.\nShiny(algernon) ::: Algernon is shiny.\nSoft(howard) ::: Howard is soft.\nShiny(cara) ::: Cara is shiny.\nGranite(cara) ::: Cara is granite.\n(¬Cheap(algernon)) ↔ (¬Comfortable(howard)) ::: Algernon is not cheap if and only if Howard is not comfortable.\n((Cheap(x) ∧ Comfortable(x))) ↔ (Soft(x)) ::: Someone is cheap and comfortable if and only if he is soft.\n((Comfortable(x) ∨ New(x))) → ((¬Cheap(x) ∧ ¬Granite(x))) ::: Someone who is comfortable or new is always not cheap and not granite.\n(∀x (Soft(x))) → ((Comfortable(x) ∧ Cheap(x))) ::: As long as someone is soft, he is comfortable and cheap.\n((Shiny(cara))) ↔ ((¬New(cara) ∧ Comfortable(cara))) ::: Cara is shiny if and only if Cara is not new and Cara is comfortable.\n((¬Soft(christopher))) → ((¬Comfortable(graciela) ∧ Cheap(graciela))) ::: If Christopher is not soft, then Graciela is not comfortable and Graciela is cheap, and vice versa.\n(¬New(x) ∧ ¬Soft(x)) ↔ (Shiny(x) ∧ Comfortable(x)) ::: Someone being neither new nor soft is equivalent to being shiny and comfortable.\n(∃x (Soft(x))) → (New(howard)) ::: If there is someone who is soft, then Howard is new.\n((Shiny(howard))) ↔ ((¬Soft(howard) ∧ New(christopher))) ::: It can be concluded that Howard is not soft and Christopher is new once knowing that Howard is shiny.\n((Cheap(graciela) ∧ ¬Soft(christopher)) → (¬New(cara))) ::: If Graciela is cheap and Christopher is not soft, then Cara is not new.\n(¬New(graciela)) ↔ (¬Granite(howard)) ::: Graciela being not new is equivalent to Howard being not granite.\n(∃x (Soft(x) ∧ ¬Comfortable(x))) → (Granite(blaine)) ::: If there is at least one people who is both soft and not comfortable, then Blaine is granite.\n",
            "First-Order-Logic Question": "Granite(luka) ::: Luka is granite."
        },
        "fixed": true
    },
    {
        "id": 1363,
        "raw_prog": {
            "First-Order-Logic Rules": "¬New(howard) ::: Howard is not new.\nNew(cara) ::: Cara is new.\n¬Granite(howard) ::: Howard is not granite.\n¬Granite(luka) ::: Luka is not granite.\nComfortable(christopher) ::: Christopher is comfortable.\n¬Soft(blaine) ::: Blaine is not soft.\n¬Cheap(blaine) ::: Blaine is not cheap.\nComfortable(luka) ::: Luka is comfortable.\nShiny(algernon) ::: Algernon is shiny.\nSoft(howard) ::: Howard is soft.\nShiny(cara) ::: Cara is shiny.\nGranite(cara) ::: Cara is granite.\n((¬Cheap(algernon))) ↔ ((¬Comfortable(howard))) ::: Algernon is not cheap if and only if Howard is not comfortable.\n(∀x (Cheap(x) ∧ Comfortable(x))) ↔ (∀x (Soft(x))) ::: Someone is cheap and comfortable if and only if he is soft.\n(∀x (Comfortable(x) ∨ New(x))) → (∀x (¬Cheap(x) ∧ ¬Granite(x))) ::: Someone who is comfortable or new is always not cheap and not granite.\n(∀x (Soft(x))) → (∀x (Comfortable(x) ∧ Cheap(x))) ::: As long as someone is soft, he is comfortable and cheap.\n((Shiny(cara))) ↔ ((¬New(cara) ∧ Comfortable(cara))) ::: Cara is shiny if and only if Cara is not new and Cara is comfortable.\n((¬Soft(christopher))) → ((¬Comfortable(graciela) ∧ Cheap(graciela))) ::: If Christopher is not soft, then Graciela is not comfortable and Graciela is cheap, and vice versa.\n(∀x (¬New(x) ∧ ¬Soft(x))) ↔ (∀x (Shiny(x) ∧ Comfortable(x))) ::: Someone being neither new nor soft is equivalent to being shiny and comfortable.\n(∃x (Soft(x))) → (New(howard)) ::: If there is someone who is soft, then Howard is new.\n((Shiny(howard))) → ((¬Soft(howard) ∧ New(christopher))) ::: It can be concluded that Howard is not soft and Christopher is new once knowing that Howard is shiny.\n((Cheap(graciela) ∧ ¬Soft(christopher)) → (¬New(cara)) ::: If Graciela is cheap and Christopher is not soft, then Cara is not new.\n((¬New(graciela))) ↔ ((¬Granite(howard))) ::: Graciela being not new is equivalent to Howard being not granite.\n(∃x (Soft(x) ∧ ¬Comfortable(x))) → (Granite(blaine)) ::: If there is at least one people who is both soft and not comfortable, then Blaine is granite.\n",
            "First-Order-Logic Question": "Soft(graciela) ::: Graciela is soft."
        },
        "gram_prog": {
            "First-Order-Logic Rules": "¬New(howard) ::: Howard is not new.\nNew(cara) ::: Cara is new.\n¬Granite(howard) ::: Howard is not granite.\n¬Granite(luka) ::: Luka is not granite.\nComfortable(christopher) ::: Christopher is comfortable.\n¬Soft(blaine) ::: Blaine is not soft.\n¬Cheap(blaine) ::: Blaine is not cheap.\nComfortable(luka) ::: Luka is comfortable.\nShiny(algernon) ::: Algernon is shiny.\nSoft(howard) ::: Howard is soft.\nShiny(cara) ::: Cara is shiny.\nGranite(cara) ::: Cara is granite.\n((¬Cheap(algernon))) ↔ ((¬Comfortable(howard))) ::: Algernon is not cheap if and only if Howard is not comfortable.\n(∀x (Cheap(x) ∧ Comfortable(x))) ↔ (∀x (Soft(x))) ::: Someone is cheap and comfortable if and only if he is soft.\n(∀x (Comfortable(x) ∨ New(x))) → (∀x (¬Cheap(x) ∧ ¬Granite(x))) ::: Someone who is comfortable or new is always not cheap and not granite.\n(∀x (Soft(x))) → (∀x (Comfortable(x) ∧ Cheap(x))) ::: As long as someone is soft, he is comfortable and cheap.\n((Shiny(cara))) ↔ ((¬New(cara) ∧ Comfortable(cara))) ::: Cara is shiny if and only if Cara is not new and Cara is comfortable.\n((¬Soft(christopher))) → ((¬Comfortable(graciela) ∧ Cheap(graciela))) ::: If Christopher is not soft, then Graciela is not comfortable and Graciela is cheap, and vice versa.\n(∀x (¬New(x) ∧ ¬Soft(x))) ↔ (∀x (Shiny(x) ∧ Comfortable(x))) ::: Someone being neither new nor soft is equivalent to being shiny and comfortable.\n(∃x (Soft(x))) → (New(howard)) ::: If there is someone who is soft, then Howard is new.\n((Shiny(howard))) → ((¬Soft(howard) ∧ New(christopher))) ::: It can be concluded that Howard is not soft and Christopher is new once knowing that Howard is shiny.\n¬(Fresh(x)→(Serious(x))) ::: If Graciela is cheap and Christopher is not soft, then Cara is not new.\n((¬New(graciela))) ↔ ((¬Granite(howard))) ::: Graciela being not new is equivalent to Howard being not granite.\n(∃x (Soft(x) ∧ ¬Comfortable(x))) → (Granite(blaine)) ::: If there is at least one people who is both soft and not comfortable, then Blaine is granite.\n",
            "First-Order-Logic Question": "Soft(graciela) ::: Graciela is soft."
        },
        "diff": [
            {
                "raw": "((Cheap(graciela) ∧ ¬Soft(christopher)) → (¬New(cara)) ::: If Graciela is cheap and Christopher is not soft, then Cara is not new.",
                "gram": "¬(Fresh(x)→(Serious(x))) ::: If Graciela is cheap and Christopher is not soft, then Cara is not new."
            }
        ],
        "answer": "C",
        "grammar_answer": "A",
        "manual_prog": {
            "First-Order-Logic Rules": "¬New(howard) ::: Howard is not new.\nNew(cara) ::: Cara is new.\n¬Granite(howard) ::: Howard is not granite.\n¬Granite(luka) ::: Luka is not granite.\nComfortable(christopher) ::: Christopher is comfortable.\n¬Soft(blaine) ::: Blaine is not soft.\n¬Cheap(blaine) ::: Blaine is not cheap.\nComfortable(luka) ::: Luka is comfortable.\nShiny(algernon) ::: Algernon is shiny.\nSoft(howard) ::: Howard is soft.\nShiny(cara) ::: Cara is shiny.\nGranite(cara) ::: Cara is granite.\n((¬Cheap(algernon))) ↔ ((¬Comfortable(howard))) ::: Algernon is not cheap if and only if Howard is not comfortable.\n(∀x (Cheap(x) ∧ Comfortable(x))) ↔ (∀x (Soft(x))) ::: Someone is cheap and comfortable if and only if he is soft.\n(∀x (Comfortable(x) ∨ New(x))) → (∀x (¬Cheap(x) ∧ ¬Granite(x))) ::: Someone who is comfortable or new is always not cheap and not granite.\n(∀x (Soft(x))) → (∀x (Comfortable(x) ∧ Cheap(x))) ::: As long as someone is soft, he is comfortable and cheap.\n((Shiny(cara))) ↔ ((¬New(cara) ∧ Comfortable(cara))) ::: Cara is shiny if and only if Cara is not new and Cara is comfortable.\n((¬Soft(christopher))) → ((¬Comfortable(graciela) ∧ Cheap(graciela))) ::: If Christopher is not soft, then Graciela is not comfortable and Graciela is cheap, and vice versa.\n(∀x (¬New(x) ∧ ¬Soft(x))) ↔ (∀x (Shiny(x) ∧ Comfortable(x))) ::: Someone being neither new nor soft is equivalent to being shiny and comfortable.\n(∃x (Soft(x))) → (New(howard)) ::: If there is someone who is soft, then Howard is new.\n((Shiny(howard))) → ((¬Soft(howard) ∧ New(christopher))) ::: It can be concluded that Howard is not soft and Christopher is new once knowing that Howard is shiny.\n((Cheap(graciela) ∧ ¬Soft(christopher)) → (¬New(cara))) ::: If Graciela is cheap and Christopher is not soft, then Cara is not new.\n((¬New(graciela))) ↔ ((¬Granite(howard))) ::: Graciela being not new is equivalent to Howard being not granite.\n(∃x (Soft(x) ∧ ¬Comfortable(x))) → (Granite(blaine)) ::: If there is at least one people who is both soft and not comfortable, then Blaine is granite.\n",
            "First-Order-Logic Question": "Soft(graciela) ::: Graciela is soft."
        },
        "fixed": true
    },
    {
        "id": 1364,
        "raw_prog": {
            "First-Order-Logic Rules": "¬New(howard) ::: Howard is not new.\nNew(cara) ::: Cara is new.\n¬Granite(howard) ::: Howard is not granite.\n¬Granite(luka) ::: Luka is not granite.\nComfortable(christopher) ::: Christopher is comfortable.\n¬Soft(blaine) ::: Blaine is not soft.\n¬Cheap(blaine) ::: Blaine is not cheap.\nComfortable(luka) ::: Luka is comfortable.\nShiny(algernon) ::: Algernon is shiny.\nSoft(howard) ::: Howard is soft.\nShiny(cara) ::: Cara is shiny.\nGranite(cara) ::: Cara is granite.\n((¬Cheap(algernon)) ↔ (¬Comfortable(howard))) ::: Algernon is not cheap if and only if Howard is not comfortable.\n((Cheap(x) ∧ Comfortable(x)) ↔ Soft(x)) ::: Someone is cheap and comfortable if and only if he is soft.\n((Comfortable(x) ∨ New(x)) ↔ (¬Cheap(x) ∧ ¬Granite(x))) ::: Someone who is comfortable or new is always not cheap and not granite.\n((Soft(x)) → (Comfortable(x) ∧ Cheap(x))) ::: As long as someone is soft, he is comfortable and cheap.\n((Shiny(cara)) ↔ ((¬New(cara)) ∧ Comfortable(cara))) ::: Cara is shiny if and only if Cara is not new and Cara is comfortable.\n((¬Soft(christopher)) → ((¬Comfortable(graciela) ∧ Cheap(graciela)))) ↔ ((Soft(christopher)) ↔ ((Comfortable(graciela) ∧ ¬Cheap(graciela))) ::: If Christopher is not soft, then Graciela is not comfortable and Graciela is cheap, and vice versa.\n((¬New(x) ∧ ¬Soft(x)) ↔ (Shiny(x) ∧ Comfortable(x))) ::: Someone being neither new nor soft is equivalent to being shiny and comfortable.\n((Soft(x)) → (New(howard))) ::: If there is someone who is soft, then Howard is new.\n((Shiny(howard))) → ((¬Soft(howard) ∧ New(christopher))) ::: It can be concluded that Howard is not soft and Christopher is new once knowing that Howard is shiny.\n((Cheap(graciela) ∧ ¬Soft(christopher)) → (¬New(cara))) ::: If Graciela is cheap and Christopher is not soft, then Cara is not new.\n((¬New(graciela)) ↔ (¬Granite(howard))) ::: Graciela being not new is equivalent to Howard being not granite.\n(∃x (Soft(x) ∧ ¬Comfortable(x))) → (Granite(blaine)) ::: If there is at least one people who is both soft and not comfortable, then Blaine is granite.\n",
            "First-Order-Logic Question": "Soft(blaine) ::: Blaine is soft."
        },
        "gram_prog": {
            "First-Order-Logic Rules": "¬New(howard) ::: Howard is not new.\nNew(cara) ::: Cara is new.\n¬Granite(howard) ::: Howard is not granite.\n¬Granite(luka) ::: Luka is not granite.\nComfortable(christopher) ::: Christopher is comfortable.\n¬Soft(blaine) ::: Blaine is not soft.\n¬Cheap(blaine) ::: Blaine is not cheap.\nComfortable(luka) ::: Luka is comfortable.\nShiny(algernon) ::: Algernon is shiny.\nSoft(howard) ::: Howard is soft.\nShiny(cara) ::: Cara is shiny.\nGranite(cara) ::: Cara is granite.\n((¬Cheap(algernon)) ↔ (¬Comfortable(howard))) ::: Algernon is not cheap if and only if Howard is not comfortable.\n((Cheap(x) ∧ Comfortable(x)) ↔ Soft(x)) ::: Someone is cheap and comfortable if and only if he is soft.\n((Comfortable(x) ∨ New(x)) ↔ (¬Cheap(x) ∧ ¬Granite(x))) ::: Someone who is comfortable or new is always not cheap and not granite.\n((Soft(x)) → (Comfortable(x) ∧ Cheap(x))) ::: As long as someone is soft, he is comfortable and cheap.\n((Shiny(cara)) ↔ ((¬New(cara)) ∧ Comfortable(cara))) ::: Cara is shiny if and only if Cara is not new and Cara is comfortable.\n¬Serious(x)→((¬Fresh(x))) ::: If Christopher is not soft, then Graciela is not comfortable and Graciela is cheap, and vice versa.\n((¬New(x) ∧ ¬Soft(x)) ↔ (Shiny(x) ∧ Comfortable(x))) ::: Someone being neither new nor soft is equivalent to being shiny and comfortable.\n((Soft(x)) → (New(howard))) ::: If there is someone who is soft, then Howard is new.\n((Shiny(howard))) → ((¬Soft(howard) ∧ New(christopher))) ::: It can be concluded that Howard is not soft and Christopher is new once knowing that Howard is shiny.\n((Cheap(graciela) ∧ ¬Soft(christopher)) → (¬New(cara))) ::: If Graciela is cheap and Christopher is not soft, then Cara is not new.\n((¬New(graciela)) ↔ (¬Granite(howard))) ::: Graciela being not new is equivalent to Howard being not granite.\n(∃x (Soft(x) ∧ ¬Comfortable(x))) → (Granite(blaine)) ::: If there is at least one people who is both soft and not comfortable, then Blaine is granite.\n",
            "First-Order-Logic Question": "Soft(blaine) ::: Blaine is soft."
        },
        "diff": [
            {
                "raw": "((¬Soft(christopher)) → ((¬Comfortable(graciela) ∧ Cheap(graciela)))) ↔ ((Soft(christopher)) ↔ ((Comfortable(graciela) ∧ ¬Cheap(graciela))) ::: If Christopher is not soft, then Graciela is not comfortable and Graciela is cheap, and vice versa.",
                "gram": "¬Serious(x)→((¬Fresh(x))) ::: If Christopher is not soft, then Graciela is not comfortable and Graciela is cheap, and vice versa."
            }
        ],
        "answer": "B",
        "grammar_answer": "A",
        "manual_prog": {
            "First-Order-Logic Rules": "¬New(howard) ::: Howard is not new.\nNew(cara) ::: Cara is new.\n¬Granite(howard) ::: Howard is not granite.\n¬Granite(luka) ::: Luka is not granite.\nComfortable(christopher) ::: Christopher is comfortable.\n¬Soft(blaine) ::: Blaine is not soft.\n¬Cheap(blaine) ::: Blaine is not cheap.\nComfortable(luka) ::: Luka is comfortable.\nShiny(algernon) ::: Algernon is shiny.\nSoft(howard) ::: Howard is soft.\nShiny(cara) ::: Cara is shiny.\nGranite(cara) ::: Cara is granite.\n((¬Cheap(algernon)) ↔ (¬Comfortable(howard))) ::: Algernon is not cheap if and only if Howard is not comfortable.\n((Cheap(x) ∧ Comfortable(x)) ↔ Soft(x)) ::: Someone is cheap and comfortable if and only if he is soft.\n((Comfortable(x) ∨ New(x)) ↔ (¬Cheap(x) ∧ ¬Granite(x))) ::: Someone who is comfortable or new is always not cheap and not granite.\n((Soft(x)) → (Comfortable(x) ∧ Cheap(x))) ::: As long as someone is soft, he is comfortable and cheap.\n((Shiny(cara)) ↔ ((¬New(cara)) ∧ Comfortable(cara))) ::: Cara is shiny if and only if Cara is not new and Cara is comfortable.\n((¬Soft(christopher)) → ((¬Comfortable(graciela) ∧ Cheap(graciela)))) ↔ ((Soft(christopher)) → ((Comfortable(graciela) ∧ ¬Cheap(graciela)))) ::: If Christopher is not soft, then Graciela is not comfortable and Graciela is cheap, and vice versa.\n((¬New(x) ∧ ¬Soft(x)) ↔ (Shiny(x) ∧ Comfortable(x))) ::: Someone being neither new nor soft is equivalent to being shiny and comfortable.\n((Soft(x)) → (New(howard))) ::: If there is someone who is soft, then Howard is new.\n((Shiny(howard))) → ((¬Soft(howard) ∧ New(christopher))) ::: It can be concluded that Howard is not soft and Christopher is new once knowing that Howard is shiny.\n((Cheap(graciela) ∧ ¬Soft(christopher)) → (¬New(cara))) ::: If Graciela is cheap and Christopher is not soft, then Cara is not new.\n((¬New(graciela)) ↔ (¬Granite(howard))) ::: Graciela being not new is equivalent to Howard being not granite.\n(∃x (Soft(x) ∧ ¬Comfortable(x))) → (Granite(blaine)) ::: If there is at least one people who is both soft and not comfortable, then Blaine is granite.\n",
            "First-Order-Logic Question": "Soft(blaine) ::: Blaine is soft."
        },
        "fixed": true
    },
    {
        "id": 1395,
        "raw_prog": {
            "First-Order-Logic Rules": "¬Substantial(tristin) ::: Tristin is not substantial.\nFancy(julie) ::: Julie is fancy.\nHappy(jasper) ::: Jasper is happy.\nFancy(george) ::: George is fancy.\n¬Happy(lyndon) ::: Lyndon is not happy.\nFancy(jasper) ::: Jasper is fancy.\nSubstantial(george) ::: George is substantial.\nPoor(lyndon) ::: Lyndon is poor.\n¬Fancy(tristin) ::: Tristin is not fancy.\nHappy(george) ::: George is happy.\nJittery(george) ::: George is jittery.\nJittery(julie) ::: Julie is jittery.\n((Substantial(george))) → ((¬Poor(tristin))) ::: It can be concluded that Tristin is not poor once knowing that George is substantial.\n(∀x ((Poor(x) ∧ ¬New(x)) ↔ (¬Happy(x))) ::: Someone is poor and not new if and only if he is not happy.\n(∃x (¬New(x))) → ((¬Jittery(dan) ∧ Fancy(lyndon))) ::: If there is someone who is not new, then Dan is not jittery and Lyndon is fancy.\n((¬Poor(jack) ∨ ¬Substantial(dan))) → ((¬Fancy(tristin))) ::: Jack being not poor or Dan being not substantial implies that Tristin is not fancy.\n(∀x (Fancy(x))) → (Jittery(x)) ::: If someone is fancy, then he is jittery.\n(∃x (¬Substantial(x))) → ((Jittery(jasper) ∧ ¬New(jasper))) ::: If there is someone who is not substantial, then Jasper is jittery and Jasper is not new.\n(∀x ((¬Fancy(x) ∧ ¬Substantial(x)) ↔ ¬New(x))) ::: Someone is not fancy and not substantial if and only if he is not new.\n((New(jack) ∨ Fancy(jasper))) → ((¬Poor(lyndon))) ::: Jack being new or Jasper being fancy implies that Lyndon is not poor.\n(∃x ((¬Happy(x)) ∧ ¬Poor(x))) → (Fancy(george)) ::: If there is at least one people who is neither happy nor poor, then George is fancy.\n((¬Fancy(lyndon) ∧ ¬New(tristin))) → (Poor(george)) ::: It can be concluded that George is poor once knowing that Lyndon is not fancy and Tristin is not new.\n((Fancy(tristin))) ↔ (Happy(julie)) ::: Tristin is fancy if and only if Julie is happy.\n(∀x ((Jittery(x) ∧ Happy(x)) ↔ ¬Fancy(x))) ::: If someone is both jittery and happy, then he is not fancy.\n",
            "First-Order-Logic Question": "¬Happy(jack) ::: Jack is not happy."
        },
        "gram_prog": {
            "First-Order-Logic Rules": "¬Substantial(tristin) ::: Tristin is not substantial.\nFancy(julie) ::: Julie is fancy.\nHappy(jasper) ::: Jasper is happy.\nFancy(george) ::: George is fancy.\n¬Happy(lyndon) ::: Lyndon is not happy.\nFancy(jasper) ::: Jasper is fancy.\nSubstantial(george) ::: George is substantial.\nPoor(lyndon) ::: Lyndon is poor.\n¬Fancy(tristin) ::: Tristin is not fancy.\nHappy(george) ::: George is happy.\nJittery(george) ::: George is jittery.\nJittery(julie) ::: Julie is jittery.\n((Substantial(george))) → ((¬Poor(tristin))) ::: It can be concluded that Tristin is not poor once knowing that George is substantial.\n∀x((Serious(x)→Fresh(x))) ::: Someone is poor and not new if and only if he is not happy.\n(∃x (¬New(x))) → ((¬Jittery(dan) ∧ Fancy(lyndon))) ::: If there is someone who is not new, then Dan is not jittery and Lyndon is fancy.\n((¬Poor(jack) ∨ ¬Substantial(dan))) → ((¬Fancy(tristin))) ::: Jack being not poor or Dan being not substantial implies that Tristin is not fancy.\n(∀x (Fancy(x))) → (Jittery(x)) ::: If someone is fancy, then he is jittery.\n(∃x (¬Substantial(x))) → ((Jittery(jasper) ∧ ¬New(jasper))) ::: If there is someone who is not substantial, then Jasper is jittery and Jasper is not new.\n(∀x ((¬Fancy(x) ∧ ¬Substantial(x)) ↔ ¬New(x))) ::: Someone is not fancy and not substantial if and only if he is not new.\n((New(jack) ∨ Fancy(jasper))) → ((¬Poor(lyndon))) ::: Jack being new or Jasper being fancy implies that Lyndon is not poor.\n(∃x ((¬Happy(x)) ∧ ¬Poor(x))) → (Fancy(george)) ::: If there is at least one people who is neither happy nor poor, then George is fancy.\n((¬Fancy(lyndon) ∧ ¬New(tristin))) → (Poor(george)) ::: It can be concluded that George is poor once knowing that Lyndon is not fancy and Tristin is not new.\n((Fancy(tristin))) ↔ (Happy(julie)) ::: Tristin is fancy if and only if Julie is happy.\n(∀x ((Jittery(x) ∧ Happy(x)) ↔ ¬Fancy(x))) ::: If someone is both jittery and happy, then he is not fancy.\n",
            "First-Order-Logic Question": "¬Happy(jack) ::: Jack is not happy."
        },
        "diff": [
            {
                "raw": "(∀x ((Poor(x) ∧ ¬New(x)) ↔ (¬Happy(x))) ::: Someone is poor and not new if and only if he is not happy.",
                "gram": "∀x((Serious(x)→Fresh(x))) ::: Someone is poor and not new if and only if he is not happy."
            }
        ],
        "answer": "C",
        "grammar_answer": "A",
        "manual_prog": {
            "First-Order-Logic Rules": "¬Substantial(tristin) ::: Tristin is not substantial.\nFancy(julie) ::: Julie is fancy.\nHappy(jasper) ::: Jasper is happy.\nFancy(george) ::: George is fancy.\n¬Happy(lyndon) ::: Lyndon is not happy.\nFancy(jasper) ::: Jasper is fancy.\nSubstantial(george) ::: George is substantial.\nPoor(lyndon) ::: Lyndon is poor.\n¬Fancy(tristin) ::: Tristin is not fancy.\nHappy(george) ::: George is happy.\nJittery(george) ::: George is jittery.\nJittery(julie) ::: Julie is jittery.\n((Substantial(george))) → ((¬Poor(tristin))) ::: It can be concluded that Tristin is not poor once knowing that George is substantial.\n(∀x ((Poor(x) ∧ ¬New(x)) ↔ (¬Happy(x)))) ::: Someone is poor and not new if and only if he is not happy.\n(∃x (¬New(x))) → ((¬Jittery(dan) ∧ Fancy(lyndon))) ::: If there is someone who is not new, then Dan is not jittery and Lyndon is fancy.\n((¬Poor(jack) ∨ ¬Substantial(dan))) → ((¬Fancy(tristin))) ::: Jack being not poor or Dan being not substantial implies that Tristin is not fancy.\n(∀x (Fancy(x))) → (Jittery(x)) ::: If someone is fancy, then he is jittery.\n(∃x (¬Substantial(x))) → ((Jittery(jasper) ∧ ¬New(jasper))) ::: If there is someone who is not substantial, then Jasper is jittery and Jasper is not new.\n(∀x ((¬Fancy(x) ∧ ¬Substantial(x)) ↔ ¬New(x))) ::: Someone is not fancy and not substantial if and only if he is not new.\n((New(jack) ∨ Fancy(jasper))) → ((¬Poor(lyndon))) ::: Jack being new or Jasper being fancy implies that Lyndon is not poor.\n(∃x ((¬Happy(x)) ∧ ¬Poor(x))) → (Fancy(george)) ::: If there is at least one people who is neither happy nor poor, then George is fancy.\n((¬Fancy(lyndon) ∧ ¬New(tristin))) → (Poor(george)) ::: It can be concluded that George is poor once knowing that Lyndon is not fancy and Tristin is not new.\n((Fancy(tristin))) ↔ (Happy(julie)) ::: Tristin is fancy if and only if Julie is happy.\n(∀x ((Jittery(x) ∧ Happy(x)) ↔ ¬Fancy(x))) ::: If someone is both jittery and happy, then he is not fancy.\n",
            "First-Order-Logic Question": "¬Happy(jack) ::: Jack is not happy."
        },
        "fixed": true
    },
    {
        "id": 1446,
        "raw_prog": {
            "First-Order-Logic Rules": "Former(lowell) ::: Lowell is former.\nBored(lowell) ::: Lowell is bored.\n¬Immediate(lowell) ::: Lowell is not immediate.\n¬Bored(whitney) ::: Whitney is not bored.\n¬Expensive(ansel) ::: Ansel is not expensive.\nExpensive(dan) ::: Dan is expensive.\nFormer(whitney) ::: Whitney is former.\n¬Bored(benedict) ::: Benedict is not bored.\n¬Expensive(whitney) ::: Whitney is not expensive.\nBored(sigmund) ::: Sigmund is bored.\nExpensive(benedict) ::: Benedict is expensive.\n¬Granite(sigmund) ::: Sigmund is not granite.\n(∀x (Expensive(x))) → (∀x (¬Former(x))) ::: All expensive people are not former.\n(¬Bored(lowell) ∧ ¬Bored(benedict)) → (Granite(lowell)) ::: If Lowell is not bored and Benedict is not putrid, then Lowell is granite.\n(∀x (Bored(x))) ↔ (∀x (Former(x))) ::: Someone being bored is equivalent to being former.\n(¬Former(whitney)) → (Granite(dan)) ::: If Whitney is not former, then Dan is granite.\n((¬Expensive(dan) ∧ ¬Former(dan))) → ((Bored(ansel) ∧ Immediate(lowell))) ∧ ((Bored(ansel) ∧ Immediate(lowell)) → ((¬Expensive(dan) ∧ ¬Former(dan))) ::: If Dan is not expensive and Dan is not former, then Ansel is bored and Lowell is immediate, and vice versa.\n(∀x (Immediate(x))) → ((¬Expensive(benedict) ∧ Granite(dan))) ::: If all people are immediate, then Benedict is not expensive and Dan is granite.\n(∀x (Bored(x) ∨ Immediate(x))) → (∀x (¬Granite(x))) ::: If someone is bored or immediate, then he is not granite.\n((Granite(dan) ∧ ¬Expensive(benedict))) → (¬Putrid(benedict)) ::: It can be concluded that Benedict is not putrid once knowing that Dan is granite and Whitney is not expensive.\n((¬Bored(whitney) ∨ ¬Expensive(dan))) → (Granite(sigmund)) ::: If Whitney is not bored or Dan is not expensive, then Sigmund is granite.\n(∀x (Granite(x) ∧ Former(x))) ↔ (∀x (Immediate(x))) ::: If someone is granite and former, then he is immediate, and vice versa.\n(∃x (¬Expensive(x))) → (Granite(benedict) ∧ ¬Immediate(sigmund)) ::: If there is someone who is not expensive, then Benedict is granite and Sigmund is not immediate.\n(Granite(dan)) ↔ ((¬Expensive(dan) ∧ Immediate(whitney))) ::: Dan being granite is equivalent to Dan being not expensive and Whitney being immediate.\n",
            "First-Order-Logic Question": "Bored(benedict) ::: Benedict is bored."
        },
        "gram_prog": {
            "First-Order-Logic Rules": "Former(lowell) ::: Lowell is former.\nBored(lowell) ::: Lowell is bored.\n¬Immediate(lowell) ::: Lowell is not immediate.\n¬Bored(whitney) ::: Whitney is not bored.\n¬Expensive(ansel) ::: Ansel is not expensive.\nExpensive(dan) ::: Dan is expensive.\nFormer(whitney) ::: Whitney is former.\n¬Bored(benedict) ::: Benedict is not bored.\n¬Expensive(whitney) ::: Whitney is not expensive.\nBored(sigmund) ::: Sigmund is bored.\nExpensive(benedict) ::: Benedict is expensive.\n¬Granite(sigmund) ::: Sigmund is not granite.\n(∀x (Expensive(x))) → (∀x (¬Former(x))) ::: All expensive people are not former.\n(¬Bored(lowell) ∧ ¬Bored(benedict)) → (Granite(lowell)) ::: If Lowell is not bored and Benedict is not putrid, then Lowell is granite.\n(∀x (Bored(x))) ↔ (∀x (Former(x))) ::: Someone being bored is equivalent to being former.\n(¬Former(whitney)) → (Granite(dan)) ::: If Whitney is not former, then Dan is granite.\n¬(Blue(x)→Serious(x))→(Blue(x)→Accurate(x)) ::: If Dan is not expensive and Dan is not former, then Ansel is bored and Lowell is immediate, and vice versa.\n(∀x (Immediate(x))) → ((¬Expensive(benedict) ∧ Granite(dan))) ::: If all people are immediate, then Benedict is not expensive and Dan is granite.\n(∀x (Bored(x) ∨ Immediate(x))) → (∀x (¬Granite(x))) ::: If someone is bored or immediate, then he is not granite.\n((Granite(dan) ∧ ¬Expensive(benedict))) → (¬Putrid(benedict)) ::: It can be concluded that Benedict is not putrid once knowing that Dan is granite and Whitney is not expensive.\n((¬Bored(whitney) ∨ ¬Expensive(dan))) → (Granite(sigmund)) ::: If Whitney is not bored or Dan is not expensive, then Sigmund is granite.\n(∀x (Granite(x) ∧ Former(x))) ↔ (∀x (Immediate(x))) ::: If someone is granite and former, then he is immediate, and vice versa.\n(∃x (¬Expensive(x))) → (Granite(benedict) ∧ ¬Immediate(sigmund)) ::: If there is someone who is not expensive, then Benedict is granite and Sigmund is not immediate.\n(Granite(dan)) ↔ ((¬Expensive(dan) ∧ Immediate(whitney))) ::: Dan being granite is equivalent to Dan being not expensive and Whitney being immediate.\n",
            "First-Order-Logic Question": "Bored(benedict) ::: Benedict is bored."
        },
        "diff": [
            {
                "raw": "((¬Expensive(dan) ∧ ¬Former(dan))) → ((Bored(ansel) ∧ Immediate(lowell))) ∧ ((Bored(ansel) ∧ Immediate(lowell)) → ((¬Expensive(dan) ∧ ¬Former(dan))) ::: If Dan is not expensive and Dan is not former, then Ansel is bored and Lowell is immediate, and vice versa.",
                "gram": "¬(Blue(x)→Serious(x))→(Blue(x)→Accurate(x)) ::: If Dan is not expensive and Dan is not former, then Ansel is bored and Lowell is immediate, and vice versa."
            }
        ],
        "answer": "B",
        "grammar_answer": "A",
        "manual_prog": {
            "First-Order-Logic Rules": "Former(lowell) ::: Lowell is former.\nBored(lowell) ::: Lowell is bored.\n¬Immediate(lowell) ::: Lowell is not immediate.\n¬Bored(whitney) ::: Whitney is not bored.\n¬Expensive(ansel) ::: Ansel is not expensive.\nExpensive(dan) ::: Dan is expensive.\nFormer(whitney) ::: Whitney is former.\n¬Bored(benedict) ::: Benedict is not bored.\n¬Expensive(whitney) ::: Whitney is not expensive.\nBored(sigmund) ::: Sigmund is bored.\nExpensive(benedict) ::: Benedict is expensive.\n¬Granite(sigmund) ::: Sigmund is not granite.\n(∀x (Expensive(x))) → (∀x (¬Former(x))) ::: All expensive people are not former.\n(¬Bored(lowell) ∧ ¬Bored(benedict)) → (Granite(lowell)) ::: If Lowell is not bored and Benedict is not putrid, then Lowell is granite.\n(∀x (Bored(x))) ↔ (∀x (Former(x))) ::: Someone being bored is equivalent to being former.\n(¬Former(whitney)) → (Granite(dan)) ::: If Whitney is not former, then Dan is granite.\n((¬Expensive(dan) ∧ ¬Former(dan))) → ((Bored(ansel) ∧ Immediate(lowell))) ∧ ((Bored(ansel) ∧ Immediate(lowell)) → ((¬Expensive(dan) ∧ ¬Former(dan)))) ::: If Dan is not expensive and Dan is not former, then Ansel is bored and Lowell is immediate, and vice versa.\n(∀x (Immediate(x))) → ((¬Expensive(benedict) ∧ Granite(dan))) ::: If all people are immediate, then Benedict is not expensive and Dan is granite.\n(∀x (Bored(x) ∨ Immediate(x))) → (∀x (¬Granite(x))) ::: If someone is bored or immediate, then he is not granite.\n((Granite(dan) ∧ ¬Expensive(benedict))) → (¬Putrid(benedict)) ::: It can be concluded that Benedict is not putrid once knowing that Dan is granite and Whitney is not expensive.\n((¬Bored(whitney) ∨ ¬Expensive(dan))) → (Granite(sigmund)) ::: If Whitney is not bored or Dan is not expensive, then Sigmund is granite.\n(∀x (Granite(x) ∧ Former(x))) ↔ (∀x (Immediate(x))) ::: If someone is granite and former, then he is immediate, and vice versa.\n(∃x (¬Expensive(x))) → (Granite(benedict) ∧ ¬Immediate(sigmund)) ::: If there is someone who is not expensive, then Benedict is granite and Sigmund is not immediate.\n(Granite(dan)) ↔ ((¬Expensive(dan) ∧ Immediate(whitney))) ::: Dan being granite is equivalent to Dan being not expensive and Whitney being immediate.\n",
            "First-Order-Logic Question": "Bored(benedict) ::: Benedict is bored."
        },
        "fixed": true
    },
    {
        "id": 1448,
        "raw_prog": {
            "First-Order-Logic Rules": "Former(lowell) ::: Lowell is former.\nBored(lowell) ::: Lowell is bored.\n¬Immediate(lowell) ::: Lowell is not immediate.\n¬Bored(whitney) ::: Whitney is not bored.\n¬Expensive(ansel) ::: Ansel is not expensive.\nExpensive(dan) ::: Dan is expensive.\nFormer(whitney) ::: Whitney is former.\n¬Bored(benedict) ::: Benedict is not bored.\n¬Expensive(whitney) ::: Whitney is not expensive.\nBored(sigmund) ::: Sigmund is bored.\nExpensive(benedict) ::: Benedict is expensive.\n¬Granite(sigmund) ::: Sigmund is not granite.\n(∀x (Expensive(x))) → (∀x (¬Former(x))) ::: All expensive people are not former.\n(¬Bored(lowell) ∧ ¬Putrid(benedict)) → (Granite(lowell)) ::: If Lowell is not bored and Benedict is not putrid, then Lowell is granite.\n(∀x (Bored(x))) ↔ (∀x (Former(x))) ::: Someone being bored is equivalent to being former.\n(¬Former(whitney)) → (Granite(dan)) ::: If Whitney is not former, then Dan is granite.\n((¬Expensive(dan) ∧ ¬Former(dan)) ↔ (Bored(ansel) ∧ Immediate(lowell))) ::: If Dan is not expensive and Dan is not former, then Ansel is bored and Lowell is immediate, and vice versa.\n(∀x (Immediate(x))) → ((¬Expensive(benedict) ∧ Granite(dan))) ::: If all people are immediate, then Benedict is not expensive and Dan is granite.\n(∀x (Bored(x) ∨ Immediate(x))) → (∀x (¬Granite(x))) ::: If someone is bored or immediate, then he is not granite.\n((Granite(dan) ∧ ¬Expensive(whitney)) → (¬Putrid(benedict))) ::: It can be concluded that Benedict is not putrid once knowing that Dan is granite and Whitney is not expensive.\n((¬Bored(whitney) ∨ ¬Expensive(dan)) → (Granite(sigmund))) ::: If Whitney is not bored or Dan is not expensive, then Sigmund is granite.\n((Granite(x) ∧ Former(x)) ↔ (Immediate(x))) ::: If someone is granite and former, then he is immediate, and vice versa.\n(∃x (¬Expensive(x))) → ((Granite(benedict) ∧ ¬Immediate(sigmund))) ::: If there is someone who is not expensive, then Benedict is granite and Sigmund is not immediate.\n((Granite(dan)) ↔ ((¬Expensive(dan) ∧ Immediate(whitney))) ::: Dan being granite is equivalent to Dan being not expensive and Whitney being immediate.\n",
            "First-Order-Logic Question": "Former(benedict) ::: Benedict is former."
        },
        "gram_prog": {
            "First-Order-Logic Rules": "Former(lowell) ::: Lowell is former.\nBored(lowell) ::: Lowell is bored.\n¬Immediate(lowell) ::: Lowell is not immediate.\n¬Bored(whitney) ::: Whitney is not bored.\n¬Expensive(ansel) ::: Ansel is not expensive.\nExpensive(dan) ::: Dan is expensive.\nFormer(whitney) ::: Whitney is former.\n¬Bored(benedict) ::: Benedict is not bored.\n¬Expensive(whitney) ::: Whitney is not expensive.\nBored(sigmund) ::: Sigmund is bored.\nExpensive(benedict) ::: Benedict is expensive.\n¬Granite(sigmund) ::: Sigmund is not granite.\n(∀x (Expensive(x))) → (∀x (¬Former(x))) ::: All expensive people are not former.\n(¬Bored(lowell) ∧ ¬Putrid(benedict)) → (Granite(lowell)) ::: If Lowell is not bored and Benedict is not putrid, then Lowell is granite.\n(∀x (Bored(x))) ↔ (∀x (Former(x))) ::: Someone being bored is equivalent to being former.\n(¬Former(whitney)) → (Granite(dan)) ::: If Whitney is not former, then Dan is granite.\n((¬Expensive(dan) ∧ ¬Former(dan)) ↔ (Bored(ansel) ∧ Immediate(lowell))) ::: If Dan is not expensive and Dan is not former, then Ansel is bored and Lowell is immediate, and vice versa.\n(∀x (Immediate(x))) → ((¬Expensive(benedict) ∧ Granite(dan))) ::: If all people are immediate, then Benedict is not expensive and Dan is granite.\n(∀x (Bored(x) ∨ Immediate(x))) → (∀x (¬Granite(x))) ::: If someone is bored or immediate, then he is not granite.\n((Granite(dan) ∧ ¬Expensive(whitney)) → (¬Putrid(benedict))) ::: It can be concluded that Benedict is not putrid once knowing that Dan is granite and Whitney is not expensive.\n((¬Bored(whitney) ∨ ¬Expensive(dan)) → (Granite(sigmund))) ::: If Whitney is not bored or Dan is not expensive, then Sigmund is granite.\n((Granite(x) ∧ Former(x)) ↔ (Immediate(x))) ::: If someone is granite and former, then he is immediate, and vice versa.\n(∃x (¬Expensive(x))) → ((Granite(benedict) ∧ ¬Immediate(sigmund))) ::: If there is someone who is not expensive, then Benedict is granite and Sigmund is not immediate.\nGranite(x)↔((¬Expensive(x))) ::: Dan being granite is equivalent to Dan being not expensive and Whitney being immediate.\n",
            "First-Order-Logic Question": "Former(benedict) ::: Benedict is former."
        },
        "diff": [
            {
                "raw": "((Granite(dan)) ↔ ((¬Expensive(dan) ∧ Immediate(whitney))) ::: Dan being granite is equivalent to Dan being not expensive and Whitney being immediate.",
                "gram": "Granite(x)↔((¬Expensive(x))) ::: Dan being granite is equivalent to Dan being not expensive and Whitney being immediate."
            }
        ],
        "answer": "B",
        "grammar_answer": "A",
        "manual_prog": {
            "First-Order-Logic Rules": "Former(lowell) ::: Lowell is former.\nBored(lowell) ::: Lowell is bored.\n¬Immediate(lowell) ::: Lowell is not immediate.\n¬Bored(whitney) ::: Whitney is not bored.\n¬Expensive(ansel) ::: Ansel is not expensive.\nExpensive(dan) ::: Dan is expensive.\nFormer(whitney) ::: Whitney is former.\n¬Bored(benedict) ::: Benedict is not bored.\n¬Expensive(whitney) ::: Whitney is not expensive.\nBored(sigmund) ::: Sigmund is bored.\nExpensive(benedict) ::: Benedict is expensive.\n¬Granite(sigmund) ::: Sigmund is not granite.\n(∀x (Expensive(x))) → (∀x (¬Former(x))) ::: All expensive people are not former.\n(¬Bored(lowell) ∧ ¬Putrid(benedict)) → (Granite(lowell)) ::: If Lowell is not bored and Benedict is not putrid, then Lowell is granite.\n(∀x (Bored(x))) ↔ (∀x (Former(x))) ::: Someone being bored is equivalent to being former.\n(¬Former(whitney)) → (Granite(dan)) ::: If Whitney is not former, then Dan is granite.\n((¬Expensive(dan) ∧ ¬Former(dan)) ↔ (Bored(ansel) ∧ Immediate(lowell))) ::: If Dan is not expensive and Dan is not former, then Ansel is bored and Lowell is immediate, and vice versa.\n(∀x (Immediate(x))) → ((¬Expensive(benedict) ∧ Granite(dan))) ::: If all people are immediate, then Benedict is not expensive and Dan is granite.\n(∀x (Bored(x) ∨ Immediate(x))) → (∀x (¬Granite(x))) ::: If someone is bored or immediate, then he is not granite.\n((Granite(dan) ∧ ¬Expensive(whitney)) → (¬Putrid(benedict))) ::: It can be concluded that Benedict is not putrid once knowing that Dan is granite and Whitney is not expensive.\n((¬Bored(whitney) ∨ ¬Expensive(dan)) → (Granite(sigmund))) ::: If Whitney is not bored or Dan is not expensive, then Sigmund is granite.\n((Granite(x) ∧ Former(x)) ↔ (Immediate(x))) ::: If someone is granite and former, then he is immediate, and vice versa.\n(∃x (¬Expensive(x))) → ((Granite(benedict) ∧ ¬Immediate(sigmund))) ::: If there is someone who is not expensive, then Benedict is granite and Sigmund is not immediate.\n((Granite(dan)) ↔ ((¬Expensive(dan) ∧ Immediate(whitney)))) ::: Dan being granite is equivalent to Dan being not expensive and Whitney being immediate.\n",
            "First-Order-Logic Question": "Former(benedict) ::: Benedict is former."
        },
        "fixed": true
    },
    {
        "id": 1453,
        "raw_prog": {
            "First-Order-Logic Rules": "Former(lowell) ::: Lowell is former.\nBored(lowell) ::: Lowell is bored.\n¬Immediate(lowell) ::: Lowell is not immediate.\n¬Bored(whitney) ::: Whitney is not bored.\n¬Expensive(ansel) ::: Ansel is not expensive.\nExpensive(dan) ::: Dan is expensive.\nFormer(whitney) ::: Whitney is former.\n¬Bored(benedict) ::: Benedict is not bored.\n¬Expensive(whitney) ::: Whitney is not expensive.\nBored(sigmund) ::: Sigmund is bored.\nExpensive(benedict) ::: Benedict is expensive.\n¬Granite(sigmund) ::: Sigmund is not granite.\n(∀x (Expensive(x))) → (∀x (¬Former(x))) ::: All expensive people are not former.\n(¬Bored(lowell) ∧ ¬Bored(benedict)) → (Granite(lowell)) ::: If Lowell is not bored and Benedict is not putrid, then Lowell is granite.\n(∀x (Bored(x))) ↔ (∀x (Former(x))) ::: Someone being bored is equivalent to being former.\n(¬Former(whitney)) → (Granite(dan)) ::: If Whitney is not former, then Dan is granite.\n((¬Expensive(dan) ∧ ¬Former(dan))) → ((Bored(ansel) ∧ Immediate(lowell))) ∧ ((Bored(ansel) ∧ Immediate(lowell)) → ((¬Expensive(dan) ∧ ¬Former(dan))) ::: If Dan is not expensive and Dan is not former, then Ansel is bored and Lowell is immediate, and vice versa.\n(∀x (Immediate(x))) → ((¬Expensive(benedict) ∧ Granite(dan))) ::: If all people are immediate, then Benedict is not expensive and Dan is granite.\n(∀x (Bored(x) ∨ Immediate(x))) → (∀x (¬Granite(x))) ::: If someone is bored or immediate, then he is not granite.\n((Granite(dan) ∧ ¬Expensive(benedict))) → (¬Putrid(benedict)) ::: It can be concluded that Benedict is not putrid once knowing that Dan is granite and Whitney is not expensive.\n((¬Bored(whitney) ∨ ¬Expensive(dan))) → (Granite(sigmund)) ::: If Whitney is not bored or Dan is not expensive, then Sigmund is granite.\n(∀x (Granite(x) ∧ Former(x))) ↔ (∀x (Immediate(x))) ::: If someone is granite and former, then he is immediate, and vice versa.\n(∃x (¬Expensive(x))) → (Granite(benedict) ∧ ¬Immediate(sigmund)) ::: If there is someone who is not expensive, then Benedict is granite and Sigmund is not immediate.\n(Granite(dan)) ↔ ((¬Expensive(dan) ∧ Immediate(whitney))) ::: Dan being granite is equivalent to Dan being not expensive and Whitney being immediate.\n",
            "First-Order-Logic Question": "¬Granite(benedict) ::: Benedict is not granite."
        },
        "gram_prog": {
            "First-Order-Logic Rules": "Former(lowell) ::: Lowell is former.\nBored(lowell) ::: Lowell is bored.\n¬Immediate(lowell) ::: Lowell is not immediate.\n¬Bored(whitney) ::: Whitney is not bored.\n¬Expensive(ansel) ::: Ansel is not expensive.\nExpensive(dan) ::: Dan is expensive.\nFormer(whitney) ::: Whitney is former.\n¬Bored(benedict) ::: Benedict is not bored.\n¬Expensive(whitney) ::: Whitney is not expensive.\nBored(sigmund) ::: Sigmund is bored.\nExpensive(benedict) ::: Benedict is expensive.\n¬Granite(sigmund) ::: Sigmund is not granite.\n(∀x (Expensive(x))) → (∀x (¬Former(x))) ::: All expensive people are not former.\n(¬Bored(lowell) ∧ ¬Bored(benedict)) → (Granite(lowell)) ::: If Lowell is not bored and Benedict is not putrid, then Lowell is granite.\n(∀x (Bored(x))) ↔ (∀x (Former(x))) ::: Someone being bored is equivalent to being former.\n(¬Former(whitney)) → (Granite(dan)) ::: If Whitney is not former, then Dan is granite.\n¬(Blue(x)→Serious(x))→(Blue(x)→Accurate(x)) ::: If Dan is not expensive and Dan is not former, then Ansel is bored and Lowell is immediate, and vice versa.\n(∀x (Immediate(x))) → ((¬Expensive(benedict) ∧ Granite(dan))) ::: If all people are immediate, then Benedict is not expensive and Dan is granite.\n(∀x (Bored(x) ∨ Immediate(x))) → (∀x (¬Granite(x))) ::: If someone is bored or immediate, then he is not granite.\n((Granite(dan) ∧ ¬Expensive(benedict))) → (¬Putrid(benedict)) ::: It can be concluded that Benedict is not putrid once knowing that Dan is granite and Whitney is not expensive.\n((¬Bored(whitney) ∨ ¬Expensive(dan))) → (Granite(sigmund)) ::: If Whitney is not bored or Dan is not expensive, then Sigmund is granite.\n(∀x (Granite(x) ∧ Former(x))) ↔ (∀x (Immediate(x))) ::: If someone is granite and former, then he is immediate, and vice versa.\n(∃x (¬Expensive(x))) → (Granite(benedict) ∧ ¬Immediate(sigmund)) ::: If there is someone who is not expensive, then Benedict is granite and Sigmund is not immediate.\n(Granite(dan)) ↔ ((¬Expensive(dan) ∧ Immediate(whitney))) ::: Dan being granite is equivalent to Dan being not expensive and Whitney being immediate.\n",
            "First-Order-Logic Question": "¬Granite(benedict) ::: Benedict is not granite."
        },
        "diff": [
            {
                "raw": "((¬Expensive(dan) ∧ ¬Former(dan))) → ((Bored(ansel) ∧ Immediate(lowell))) ∧ ((Bored(ansel) ∧ Immediate(lowell)) → ((¬Expensive(dan) ∧ ¬Former(dan))) ::: If Dan is not expensive and Dan is not former, then Ansel is bored and Lowell is immediate, and vice versa.",
                "gram": "¬(Blue(x)→Serious(x))→(Blue(x)→Accurate(x)) ::: If Dan is not expensive and Dan is not former, then Ansel is bored and Lowell is immediate, and vice versa."
            }
        ],
        "answer": "B",
        "grammar_answer": "A",
        "manual_prog": {
            "First-Order-Logic Rules": "Former(lowell) ::: Lowell is former.\nBored(lowell) ::: Lowell is bored.\n¬Immediate(lowell) ::: Lowell is not immediate.\n¬Bored(whitney) ::: Whitney is not bored.\n¬Expensive(ansel) ::: Ansel is not expensive.\nExpensive(dan) ::: Dan is expensive.\nFormer(whitney) ::: Whitney is former.\n¬Bored(benedict) ::: Benedict is not bored.\n¬Expensive(whitney) ::: Whitney is not expensive.\nBored(sigmund) ::: Sigmund is bored.\nExpensive(benedict) ::: Benedict is expensive.\n¬Granite(sigmund) ::: Sigmund is not granite.\n(∀x (Expensive(x))) → (∀x (¬Former(x))) ::: All expensive people are not former.\n(¬Bored(lowell) ∧ ¬Bored(benedict)) → (Granite(lowell)) ::: If Lowell is not bored and Benedict is not putrid, then Lowell is granite.\n(∀x (Bored(x))) ↔ (∀x (Former(x))) ::: Someone being bored is equivalent to being former.\n(¬Former(whitney)) → (Granite(dan)) ::: If Whitney is not former, then Dan is granite.\n((¬Expensive(dan) ∧ ¬Former(dan))) → ((Bored(ansel) ∧ Immediate(lowell))) ∧ ((Bored(ansel) ∧ Immediate(lowell)) → ((¬Expensive(dan) ∧ ¬Former(dan)))) ::: If Dan is not expensive and Dan is not former, then Ansel is bored and Lowell is immediate, and vice versa.\n(∀x (Immediate(x))) → ((¬Expensive(benedict) ∧ Granite(dan))) ::: If all people are immediate, then Benedict is not expensive and Dan is granite.\n(∀x (Bored(x) ∨ Immediate(x))) → (∀x (¬Granite(x))) ::: If someone is bored or immediate, then he is not granite.\n((Granite(dan) ∧ ¬Expensive(benedict))) → (¬Putrid(benedict)) ::: It can be concluded that Benedict is not putrid once knowing that Dan is granite and Whitney is not expensive.\n((¬Bored(whitney) ∨ ¬Expensive(dan))) → (Granite(sigmund)) ::: If Whitney is not bored or Dan is not expensive, then Sigmund is granite.\n(∀x (Granite(x) ∧ Former(x))) ↔ (∀x (Immediate(x))) ::: If someone is granite and former, then he is immediate, and vice versa.\n(∃x (¬Expensive(x))) → (Granite(benedict) ∧ ¬Immediate(sigmund)) ::: If there is someone who is not expensive, then Benedict is granite and Sigmund is not immediate.\n(Granite(dan)) ↔ ((¬Expensive(dan) ∧ Immediate(whitney))) ::: Dan being granite is equivalent to Dan being not expensive and Whitney being immediate.\n",
            "First-Order-Logic Question": "¬Granite(benedict) ::: Benedict is not granite."
        },
        "fixed": true
    },
    {
        "id": 1486,
        "raw_prog": {
            "First-Order-Logic Rules": "¬Combative(barrett) ::: Barrett is not combative.\n¬Recent(abel) ::: Abel is not recent.\n¬Combative(montague) ::: Montague is not combative.\nOld(montague) ::: Montague is old.\nDifferent(barrett) ::: Barrett is different.\nDifferent(montague) ::: Montague is different.\nBored(dan) ::: Dan is bored.\nRecent(ansel) ::: Ansel is recent.\n¬Bewildered(barrett) ::: Barrett is not bewildered.\n¬Bored(godfrey) ::: Godfrey is not bored.\n¬Bored(abel) ::: Abel is not bored.\nCombative(abel) ::: Abel is combative.\n((Bored(x) ∧ ¬Old(x))) ↔ Bewildered(x) ::: Someone is bored and not old if and only if he is bewildered.\n(∀x (Combative(x))) → (∀x (¬Bewildered(x))) ::: If someone is combative, then he is not bewildered.\n(Recent(dan)) → ((Old(abel) ∧ Combative(bret))) ∧ vice versa ::: If Dan is recent, then Abel is old and Bret is combative, and vice versa.\n((¬Combative(x) ∧ Old(x))) → ((¬Different(x))) ::: If someone who is not combative is also old, then he is not different.\n(∃x (Bored(x))) → ((Old(ansel) ∧ ¬Combative(barrett))) ::: If there is someone who is bored, then Ansel is old and Barrett is not combative.\n(¬Bored(dan) ∧ Old(godfrey)) → (Different(barrett)) ::: If Dan is not bored and Godfrey is old, then Barrett is different.\n(∃x (Recent(x) ∨ ¬Bored(x))) → (Combative(montague) ∧ Different(dan)) ::: If there is at least one people who is either recent or not bored, then Montague is combative and Dan is different.\n(∃x (¬Combative(x) ∧ ¬Recent(x))) → (¬Bored(ansel)) ::: If there is at least one people who is neither combative nor recent, then Ansel is not bored.\n(∃x (¬Recent(x))) → (Old(godfrey)) ::: If there is someone who is not recent, then Godfrey is old.\n(∃x (Bored(x) ∨ ¬Recent(x))) → (¬Old(godfrey)) ::: If there is at least one people who is bored or not recent, then Godfrey is not old.\n((Old(abel) ∨ ¬Recent(dan))) → (Different(barrett)) ::: Abel being old or Dan being not recent implies that Barrett is different.\n",
            "First-Order-Logic Question": "¬Bored(barrett) ::: Barrett is not bored."
        },
        "gram_prog": {
            "First-Order-Logic Rules": "¬Combative(barrett) ::: Barrett is not combative.\n¬Recent(abel) ::: Abel is not recent.\n¬Combative(montague) ::: Montague is not combative.\nOld(montague) ::: Montague is old.\nDifferent(barrett) ::: Barrett is different.\nDifferent(montague) ::: Montague is different.\nBored(dan) ::: Dan is bored.\nRecent(ansel) ::: Ansel is recent.\n¬Bewildered(barrett) ::: Barrett is not bewildered.\n¬Bored(godfrey) ::: Godfrey is not bored.\n¬Bored(abel) ::: Abel is not bored.\nCombative(abel) ::: Abel is combative.\n((Bored(x) ∧ ¬Old(x))) ↔ Bewildered(x) ::: Someone is bored and not old if and only if he is bewildered.\n(∀x (Combative(x))) → (∀x (¬Bewildered(x))) ::: If someone is combative, then he is not bewildered.\n¬((Serious(x)→Fresh(x))) ::: If Dan is recent, then Abel is old and Bret is combative, and vice versa.\n((¬Combative(x) ∧ Old(x))) → ((¬Different(x))) ::: If someone who is not combative is also old, then he is not different.\n(∃x (Bored(x))) → ((Old(ansel) ∧ ¬Combative(barrett))) ::: If there is someone who is bored, then Ansel is old and Barrett is not combative.\n(¬Bored(dan) ∧ Old(godfrey)) → (Different(barrett)) ::: If Dan is not bored and Godfrey is old, then Barrett is different.\n(∃x (Recent(x) ∨ ¬Bored(x))) → (Combative(montague) ∧ Different(dan)) ::: If there is at least one people who is either recent or not bored, then Montague is combative and Dan is different.\n(∃x (¬Combative(x) ∧ ¬Recent(x))) → (¬Bored(ansel)) ::: If there is at least one people who is neither combative nor recent, then Ansel is not bored.\n(∃x (¬Recent(x))) → (Old(godfrey)) ::: If there is someone who is not recent, then Godfrey is old.\n(∃x (Bored(x) ∨ ¬Recent(x))) → (¬Old(godfrey)) ::: If there is at least one people who is bored or not recent, then Godfrey is not old.\n((Old(abel) ∨ ¬Recent(dan))) → (Different(barrett)) ::: Abel being old or Dan being not recent implies that Barrett is different.\n",
            "First-Order-Logic Question": "¬Bored(barrett) ::: Barrett is not bored."
        },
        "diff": [
            {
                "raw": "(Recent(dan)) → ((Old(abel) ∧ Combative(bret))) ∧ vice versa ::: If Dan is recent, then Abel is old and Bret is combative, and vice versa.",
                "gram": "¬((Serious(x)→Fresh(x))) ::: If Dan is recent, then Abel is old and Bret is combative, and vice versa."
            }
        ],
        "answer": "C",
        "grammar_answer": "A",
        "manual_prog": {
            "First-Order-Logic Rules": "¬Combative(barrett) ::: Barrett is not combative.\n¬Recent(abel) ::: Abel is not recent.\n¬Combative(montague) ::: Montague is not combative.\nOld(montague) ::: Montague is old.\nDifferent(barrett) ::: Barrett is different.\nDifferent(montague) ::: Montague is different.\nBored(dan) ::: Dan is bored.\nRecent(ansel) ::: Ansel is recent.\n¬Bewildered(barrett) ::: Barrett is not bewildered.\n¬Bored(godfrey) ::: Godfrey is not bored.\n¬Bored(abel) ::: Abel is not bored.\nCombative(abel) ::: Abel is combative.\n((Bored(x) ∧ ¬Old(x))) ↔ Bewildered(x) ::: Someone is bored and not old if and only if he is bewildered.\n(∀x (Combative(x))) → (∀x (¬Bewildered(x))) ::: If someone is combative, then he is not bewildered.\n(Recent(dan)) ↔ ((Old(abel) ∧ Combative(bret))) ::: If Dan is recent, then Abel is old and Bret is combative, and vice versa.\n((¬Combative(x) ∧ Old(x))) → ((¬Different(x))) ::: If someone who is not combative is also old, then he is not different.\n(∃x (Bored(x))) → ((Old(ansel) ∧ ¬Combative(barrett))) ::: If there is someone who is bored, then Ansel is old and Barrett is not combative.\n(¬Bored(dan) ∧ Old(godfrey)) → (Different(barrett)) ::: If Dan is not bored and Godfrey is old, then Barrett is different.\n(∃x (Recent(x) ∨ ¬Bored(x))) → (Combative(montague) ∧ Different(dan)) ::: If there is at least one people who is either recent or not bored, then Montague is combative and Dan is different.\n(∃x (¬Combative(x) ∧ ¬Recent(x))) → (¬Bored(ansel)) ::: If there is at least one people who is neither combative nor recent, then Ansel is not bored.\n(∃x (¬Recent(x))) → (Old(godfrey)) ::: If there is someone who is not recent, then Godfrey is old.\n(∃x (Bored(x) ∨ ¬Recent(x))) → (¬Old(godfrey)) ::: If there is at least one people who is bored or not recent, then Godfrey is not old.\n((Old(abel) ∨ ¬Recent(dan))) → (Different(barrett)) ::: Abel being old or Dan being not recent implies that Barrett is different.\n",
            "First-Order-Logic Question": "¬Bored(barrett) ::: Barrett is not bored."
        },
        "fixed": true
    },
    {
        "id": 18,
        "raw_prog": {
            "First-Order-Logic Rules": "Angry(adler) ::: Adler is angry.\nShort(wiley) ::: Wiley is short.\nShort(rosa) ::: Rosa is short.\n¬Angry(rosa) ::: Rosa is not angry.\n¬Poised(rosa) ::: Rosa is not poised.\n¬Poised(wiley) ::: Wiley is not poised.\n¬Angry(wiley) ::: Wiley is not angry.\nShiny(rosa) ::: Rosa is shiny.\n¬Different(wiley) ::: Wiley is not different.\nShort(cary) ::: Cary is short.\n¬Different(blaine) ::: Blaine is not different.\nPoised(dan) ::: Dan is poised.\n(∃x (Different(x) ∨ Poised(x))) → (Talkative(wiley)) ::: If there is at least one people who is different or poised, then Wiley is talkative.\n(∀x (Talkative(x) ∨ ¬Poised(x))) → (¬Angry(rosa)) ::: If everyone is talkative or not poised, then Rosa is not angry.\n(Short(x) ∧ ¬Shiny(x)) ↔ (¬Angry(x)) ::: If someone is short and not shiny, then he is not angry, and vice versa.\n(Different(x) ∧ Short(x)) ↔ (¬Talkative(x)) ::: If someone is different and short, then he is not talkative, and vice versa.\n((Shiny(dan) ∨ Different(adler))) → (Short(wiley)) ::: If Dan is shiny or Adler is different, then Wiley is short.\n(∃x (Different(x) ∨ Poised(x))) → (Talkative(wiley)) ::: If there is at least one people who is different or poised, then Wiley is talkative.\n(∀x (Short(x))) → ((¬Short(rosa) → (Angry(adler) ∧ ¬Different(blaine))) ::: It can be concluded that Adler is angry and Blaine is not different once knowing that Rosa is not short.\n((Talkative(wiley) ∨ Short(adler))) → (Different(wiley)) ::: Wiley being talkative or Adler being short implies that Wiley is different.\n(∃x (Angry(x))) → (¬Talkative(dan)) ::: If there is at least one people who is angry, then Dan is not talkative.\n(Poised(dan)) ↔ (¬Shiny(rosa)) ::: Dan being poised is equivalent to Rosa being not shiny.\n((Poised(blaine) ∧ ¬Angry(blaine))) → (Different(rosa) ∧ Shiny(rosa)) ::: If Blaine is poised and Blaine is not angry, then Rosa is different and Rosa is shiny.\n(∃x (¬Short(x))) → (Talkative(adler)) ::: If there is someone who is not short, then Adler is talkative.\n(Short(x) ∨ ¬Shiny(x)) → (¬Angry(x)) ::: If someone is short or not shiny, then he is not angry.\n",
            "First-Order-Logic Question": "¬Talkative(adler) ::: Adler is not talkative."
        },
        "gram_prog": {
            "First-Order-Logic Rules": "Angry(adler) ::: Adler is angry.\nShort(wiley) ::: Wiley is short.\nShort(rosa) ::: Rosa is short.\n¬Angry(rosa) ::: Rosa is not angry.\n¬Poised(rosa) ::: Rosa is not poised.\n¬Poised(wiley) ::: Wiley is not poised.\n¬Angry(wiley) ::: Wiley is not angry.\nShiny(rosa) ::: Rosa is shiny.\n¬Different(wiley) ::: Wiley is not different.\nShort(cary) ::: Cary is short.\n¬Different(blaine) ::: Blaine is not different.\nPoised(dan) ::: Dan is poised.\n(∃x (Different(x) ∨ Poised(x))) → (Talkative(wiley)) ::: If there is at least one people who is different or poised, then Wiley is talkative.\n(∀x (Talkative(x) ∨ ¬Poised(x))) → (¬Angry(rosa)) ::: If everyone is talkative or not poised, then Rosa is not angry.\n(Short(x) ∧ ¬Shiny(x)) ↔ (¬Angry(x)) ::: If someone is short and not shiny, then he is not angry, and vice versa.\n(Different(x) ∧ Short(x)) ↔ (¬Talkative(x)) ::: If someone is different and short, then he is not talkative, and vice versa.\n((Shiny(dan) ∨ Different(adler))) → (Short(wiley)) ::: If Dan is shiny or Adler is different, then Wiley is short.\n(∃x (Different(x) ∨ Poised(x))) → (Talkative(wiley)) ::: If there is at least one people who is different or poised, then Wiley is talkative.\n¬Short(x)→((Angry(x))) ::: It can be concluded that Adler is angry and Blaine is not different once knowing that Rosa is not short.\n((Talkative(wiley) ∨ Short(adler))) → (Different(wiley)) ::: Wiley being talkative or Adler being short implies that Wiley is different.\n(∃x (Angry(x))) → (¬Talkative(dan)) ::: If there is at least one people who is angry, then Dan is not talkative.\n(Poised(dan)) ↔ (¬Shiny(rosa)) ::: Dan being poised is equivalent to Rosa being not shiny.\n((Poised(blaine) ∧ ¬Angry(blaine))) → (Different(rosa) ∧ Shiny(rosa)) ::: If Blaine is poised and Blaine is not angry, then Rosa is different and Rosa is shiny.\n(∃x (¬Short(x))) → (Talkative(adler)) ::: If there is someone who is not short, then Adler is talkative.\n(Short(x) ∨ ¬Shiny(x)) → (¬Angry(x)) ::: If someone is short or not shiny, then he is not angry.\n",
            "First-Order-Logic Question": "¬Talkative(adler) ::: Adler is not talkative."
        },
        "diff": [
            {
                "raw": "(∀x (Short(x))) → ((¬Short(rosa) → (Angry(adler) ∧ ¬Different(blaine))) ::: It can be concluded that Adler is angry and Blaine is not different once knowing that Rosa is not short.",
                "gram": "¬Short(x)→((Angry(x))) ::: It can be concluded that Adler is angry and Blaine is not different once knowing that Rosa is not short."
            }
        ],
        "answer": "C",
        "grammar_answer": "A",
        "manual_prog": {
            "First-Order-Logic Rules": "Angry(adler) ::: Adler is angry.\nShort(wiley) ::: Wiley is short.\nShort(rosa) ::: Rosa is short.\n¬Angry(rosa) ::: Rosa is not angry.\n¬Poised(rosa) ::: Rosa is not poised.\n¬Poised(wiley) ::: Wiley is not poised.\n¬Angry(wiley) ::: Wiley is not angry.\nShiny(rosa) ::: Rosa is shiny.\n¬Different(wiley) ::: Wiley is not different.\nShort(cary) ::: Cary is short.\n¬Different(blaine) ::: Blaine is not different.\nPoised(dan) ::: Dan is poised.\n(∃x (Different(x) ∨ Poised(x))) → (Talkative(wiley)) ::: If there is at least one people who is different or poised, then Wiley is talkative.\n(∀x (Talkative(x) ∨ ¬Poised(x))) → (¬Angry(rosa)) ::: If everyone is talkative or not poised, then Rosa is not angry.\n(Short(x) ∧ ¬Shiny(x)) ↔ (¬Angry(x)) ::: If someone is short and not shiny, then he is not angry, and vice versa.\n(Different(x) ∧ Short(x)) ↔ (¬Talkative(x)) ::: If someone is different and short, then he is not talkative, and vice versa.\n((Shiny(dan) ∨ Different(adler))) → (Short(wiley)) ::: If Dan is shiny or Adler is different, then Wiley is short.\n(∃x (Different(x) ∨ Poised(x))) → (Talkative(wiley)) ::: If there is at least one people who is different or poised, then Wiley is talkative.\n(∀x (Short(x))) → ((¬Short(rosa) → (Angry(adler) ∧ ¬Different(blaine)))) ::: It can be concluded that Adler is angry and Blaine is not different once knowing that Rosa is not short.\n((Talkative(wiley) ∨ Short(adler))) → (Different(wiley)) ::: Wiley being talkative or Adler being short implies that Wiley is different.\n(∃x (Angry(x))) → (¬Talkative(dan)) ::: If there is at least one people who is angry, then Dan is not talkative.\n(Poised(dan)) ↔ (¬Shiny(rosa)) ::: Dan being poised is equivalent to Rosa being not shiny.\n((Poised(blaine) ∧ ¬Angry(blaine))) → (Different(rosa) ∧ Shiny(rosa)) ::: If Blaine is poised and Blaine is not angry, then Rosa is different and Rosa is shiny.\n(∃x (¬Short(x))) → (Talkative(adler)) ::: If there is someone who is not short, then Adler is talkative.\n(Short(x) ∨ ¬Shiny(x)) → (¬Angry(x)) ::: If someone is short or not shiny, then he is not angry.\n",
            "First-Order-Logic Question": "¬Talkative(adler) ::: Adler is not talkative."
        },
        "fixed": true
    },
    {
        "id": 136,
        "raw_prog": {
            "First-Order-Logic Rules": "¬Bewildered(abel) ::: Abel is not bewildered.\nCultural(aaron) ::: Aaron is cultural.\nCultural(seymour) ::: Seymour is cultural.\nAble(abel) ::: Abel is able.\nJolly(maurice) ::: Maurice is jolly.\nBewildered(cara) ::: Cara is bewildered.\nCultural(maurice) ::: Maurice is cultural.\nCultural(abel) ::: Abel is cultural.\n¬Jolly(algernon) ::: Algernon is not jolly.\n¬New(algernon) ::: Algernon is not new.\nBewildered(seymour) ::: Seymour is bewildered.\nNew(maurice) ::: Maurice is new.\n((¬Jolly(algernon) ∨ Able(maurice))) → (Cultural(cara)) ::: If Algernon is not jolly or Maurice is able, then Cara is cultural.\n(∃x (Bewildered(x) ∧ ¬Octagonal(x))) → (Jolly(algernon)) ::: If there is at least one people who is both bewildered and not octagonal, then Algernon is jolly.\n(∀x (¬New(x))) → (Bewildered(x) ∧ Cultural(x)) ::: Someone who is not new is always both bewildered and cultural.\n(Bewildered(abel)) ↔ (¬Jolly(algernon)) ::: If Abel is bewildered, then Algernon is not jolly, and vice versa.\n(∃x (¬New(x))) → (¬Jolly(lesley) ∧ Octagonal(lesley)) ::: If there is someone who is not new, then Lesley is not jolly and Lesley is octagonal.\n((Jolly(x) ∧ ¬Bewildered(x))) ↔ (¬Cultural(x)) ::: If someone is both jolly and not bewildered, then he is not cultural.\n(∃x (New(x) ∨ ¬Able(x))) → (¬Cultural(cara)) ::: If there is someone who is either new or not able, then Cara is not cultural.\n((¬Bewildered(x) ∧ Able(x))) ↔ (Jolly(x)) ::: Someone being neither bewildered nor able is equivalent to being jolly.\n((Octagonal(x) ∧ ¬Cultural(x))) ↔ ((Jolly(x) ∧ Bewildered(x))) ::: If someone is octagonal and not cultural, then he is both jolly and bewildered, and vice versa.\n(∃x (¬Bewildered(x))) → (Jolly(cara)) ::: If there is someone who is not bewildered, then Cara is jolly.\n(∀x ((¬Jolly(x) ∨ ¬Able(x))) → (New(x)) ::: Someone who is either not jolly or not able is always new.\n(∃x (Bewildered(x))) → (¬Cultural(lesley) ∧ Octagonal(seymour)) ::: If there is at least one people who is bewildered, then Lesley is not cultural and Seymour is octagonal.\n",
            "First-Order-Logic Question": "¬Cultural(algernon) ::: Algernon is not cultural."
        },
        "gram_prog": {
            "First-Order-Logic Rules": "¬Bewildered(abel) ::: Abel is not bewildered.\nCultural(aaron) ::: Aaron is cultural.\nCultural(seymour) ::: Seymour is cultural.\nAble(abel) ::: Abel is able.\nJolly(maurice) ::: Maurice is jolly.\nBewildered(cara) ::: Cara is bewildered.\nCultural(maurice) ::: Maurice is cultural.\nCultural(abel) ::: Abel is cultural.\n¬Jolly(algernon) ::: Algernon is not jolly.\n¬New(algernon) ::: Algernon is not new.\nBewildered(seymour) ::: Seymour is bewildered.\nNew(maurice) ::: Maurice is new.\n((¬Jolly(algernon) ∨ Able(maurice))) → (Cultural(cara)) ::: If Algernon is not jolly or Maurice is able, then Cara is cultural.\n(∃x (Bewildered(x) ∧ ¬Octagonal(x))) → (Jolly(algernon)) ::: If there is at least one people who is both bewildered and not octagonal, then Algernon is jolly.\n(∀x (¬New(x))) → (Bewildered(x) ∧ Cultural(x)) ::: Someone who is not new is always both bewildered and cultural.\n(Bewildered(abel)) ↔ (¬Jolly(algernon)) ::: If Abel is bewildered, then Algernon is not jolly, and vice versa.\n(∃x (¬New(x))) → (¬Jolly(lesley) ∧ Octagonal(lesley)) ::: If there is someone who is not new, then Lesley is not jolly and Lesley is octagonal.\n((Jolly(x) ∧ ¬Bewildered(x))) ↔ (¬Cultural(x)) ::: If someone is both jolly and not bewildered, then he is not cultural.\n(∃x (New(x) ∨ ¬Able(x))) → (¬Cultural(cara)) ::: If there is someone who is either new or not able, then Cara is not cultural.\n((¬Bewildered(x) ∧ Able(x))) ↔ (Jolly(x)) ::: Someone being neither bewildered nor able is equivalent to being jolly.\n((Octagonal(x) ∧ ¬Cultural(x))) ↔ ((Jolly(x) ∧ Bewildered(x))) ::: If someone is octagonal and not cultural, then he is both jolly and bewildered, and vice versa.\n(∃x (¬Bewildered(x))) → (Jolly(cara)) ::: If there is someone who is not bewildered, then Cara is jolly.\n∀x((¬Blue(x)∨¬Serious(x))) ::: Someone who is either not jolly or not able is always new.\n(∃x (Bewildered(x))) → (¬Cultural(lesley) ∧ Octagonal(seymour)) ::: If there is at least one people who is bewildered, then Lesley is not cultural and Seymour is octagonal.\n",
            "First-Order-Logic Question": "¬Cultural(algernon) ::: Algernon is not cultural."
        },
        "diff": [
            {
                "raw": "(∀x ((¬Jolly(x) ∨ ¬Able(x))) → (New(x)) ::: Someone who is either not jolly or not able is always new.",
                "gram": "∀x((¬Blue(x)∨¬Serious(x))) ::: Someone who is either not jolly or not able is always new."
            }
        ],
        "answer": "B",
        "grammar_answer": "A",
        "manual_prog": {
            "First-Order-Logic Rules": "¬Bewildered(abel) ::: Abel is not bewildered.\nCultural(aaron) ::: Aaron is cultural.\nCultural(seymour) ::: Seymour is cultural.\nAble(abel) ::: Abel is able.\nJolly(maurice) ::: Maurice is jolly.\nBewildered(cara) ::: Cara is bewildered.\nCultural(maurice) ::: Maurice is cultural.\nCultural(abel) ::: Abel is cultural.\n¬Jolly(algernon) ::: Algernon is not jolly.\n¬New(algernon) ::: Algernon is not new.\nBewildered(seymour) ::: Seymour is bewildered.\nNew(maurice) ::: Maurice is new.\n((¬Jolly(algernon) ∨ Able(maurice))) → (Cultural(cara)) ::: If Algernon is not jolly or Maurice is able, then Cara is cultural.\n(∃x (Bewildered(x) ∧ ¬Octagonal(x))) → (Jolly(algernon)) ::: If there is at least one people who is both bewildered and not octagonal, then Algernon is jolly.\n(∀x (¬New(x))) → (Bewildered(x) ∧ Cultural(x)) ::: Someone who is not new is always both bewildered and cultural.\n(Bewildered(abel)) ↔ (¬Jolly(algernon)) ::: If Abel is bewildered, then Algernon is not jolly, and vice versa.\n(∃x (¬New(x))) → (¬Jolly(lesley) ∧ Octagonal(lesley)) ::: If there is someone who is not new, then Lesley is not jolly and Lesley is octagonal.\n((Jolly(x) ∧ ¬Bewildered(x))) ↔ (¬Cultural(x)) ::: If someone is both jolly and not bewildered, then he is not cultural.\n(∃x (New(x) ∨ ¬Able(x))) → (¬Cultural(cara)) ::: If there is someone who is either new or not able, then Cara is not cultural.\n((¬Bewildered(x) ∧ Able(x))) ↔ (Jolly(x)) ::: Someone being neither bewildered nor able is equivalent to being jolly.\n((Octagonal(x) ∧ ¬Cultural(x))) ↔ ((Jolly(x) ∧ Bewildered(x))) ::: If someone is octagonal and not cultural, then he is both jolly and bewildered, and vice versa.\n(∃x (¬Bewildered(x))) → (Jolly(cara)) ::: If there is someone who is not bewildered, then Cara is jolly.\n(∀x ((¬Jolly(x) ∨ ¬Able(x))) → (New(x))) ::: Someone who is either not jolly or not able is always new.\n(∃x (Bewildered(x))) → (¬Cultural(lesley) ∧ Octagonal(seymour)) ::: If there is at least one people who is bewildered, then Lesley is not cultural and Seymour is octagonal.\n",
            "First-Order-Logic Question": "¬Cultural(algernon) ::: Algernon is not cultural."
        },
        "fixed": true
    },
    {
        "id": 143,
        "raw_prog": {
            "First-Order-Logic Rules": "¬Bewildered(abel) ::: Abel is not bewildered.\nCultural(aaron) ::: Aaron is cultural.\nCultural(seymour) ::: Seymour is cultural.\nAble(abel) ::: Abel is able.\nJolly(maurice) ::: Maurice is jolly.\nBewildered(cara) ::: Cara is bewildered.\nCultural(maurice) ::: Maurice is cultural.\nCultural(abel) ::: Abel is cultural.\n¬Jolly(algernon) ::: Algernon is not jolly.\n¬New(algernon) ::: Algernon is not new.\nBewildered(seymour) ::: Seymour is bewildered.\nNew(maurice) ::: Maurice is new.\n((¬Jolly(algernon) ∨ Able(maurice))) → (Cultural(cara)) ::: If Algernon is not jolly or Maurice is able, then Cara is cultural.\n(∃x (Bewildered(x) ∧ ¬Octagonal(x))) → (Jolly(algernon)) ::: If there is at least one people who is both bewildered and not octagonal, then Algernon is jolly.\n(∀x (¬New(x))) ↔ (Bewildered(x) ∧ Cultural(x)) ::: Someone who is not new is always both bewildered and cultural.\n((Bewildered(abel))) ↔ (¬Jolly(algernon)) ::: If Abel is bewildered, then Algernon is not jolly, and vice versa.\n(∃x (¬New(x))) → (¬Jolly(lesley) ∧ Octagonal(lesley)) ::: If there is someone who is not new, then Lesley is not jolly and Lesley is octagonal.\n((Jolly(x) ∧ ¬Bewildered(x))) ↔ (¬Cultural(x)) ::: Someone being both jolly and not bewildered, then he is not cultural.\n(∃x (New(x) ∨ ¬Able(x))) → (¬Cultural(cara)) ::: If there is someone who is either new or not able, then Cara is not cultural.\n((¬Bewildered(x) ∧ ¬Able(x))) ↔ (Jolly(x)) ::: Someone being neither bewildered nor able is equivalent to being jolly.\n((Octagonal(x) ∧ ¬Cultural(x))) ↔ (Jolly(x) ∧ Bewildered(x)) ::: If someone is octagonal and not cultural, then he is both jolly and bewildered, and vice versa.\n(∃x (¬Bewildered(x))) → (Jolly(cara)) ::: If there is someone who is not bewildered, then Cara is jolly.\n(∀x ((¬Jolly(x) ∨ ¬Able(x))) → (New(x)) ::: Someone who is either not jolly or not able is always new.\n(∃x (Bewildered(x))) → (¬Cultural(lesley) ∧ Octagonal(seymour)) ::: If there is at least one people who is bewildered, then Lesley is not cultural and Seymour is octagonal.\n",
            "First-Order-Logic Question": "¬Octagonal(maurice) ::: Maurice is not octagonal."
        },
        "gram_prog": {
            "First-Order-Logic Rules": "¬Bewildered(abel) ::: Abel is not bewildered.\nCultural(aaron) ::: Aaron is cultural.\nCultural(seymour) ::: Seymour is cultural.\nAble(abel) ::: Abel is able.\nJolly(maurice) ::: Maurice is jolly.\nBewildered(cara) ::: Cara is bewildered.\nCultural(maurice) ::: Maurice is cultural.\nCultural(abel) ::: Abel is cultural.\n¬Jolly(algernon) ::: Algernon is not jolly.\n¬New(algernon) ::: Algernon is not new.\nBewildered(seymour) ::: Seymour is bewildered.\nNew(maurice) ::: Maurice is new.\n((¬Jolly(algernon) ∨ Able(maurice))) → (Cultural(cara)) ::: If Algernon is not jolly or Maurice is able, then Cara is cultural.\n(∃x (Bewildered(x) ∧ ¬Octagonal(x))) → (Jolly(algernon)) ::: If there is at least one people who is both bewildered and not octagonal, then Algernon is jolly.\n(∀x (¬New(x))) ↔ (Bewildered(x) ∧ Cultural(x)) ::: Someone who is not new is always both bewildered and cultural.\n((Bewildered(abel))) ↔ (¬Jolly(algernon)) ::: If Abel is bewildered, then Algernon is not jolly, and vice versa.\n(∃x (¬New(x))) → (¬Jolly(lesley) ∧ Octagonal(lesley)) ::: If there is someone who is not new, then Lesley is not jolly and Lesley is octagonal.\n((Jolly(x) ∧ ¬Bewildered(x))) ↔ (¬Cultural(x)) ::: Someone being both jolly and not bewildered, then he is not cultural.\n(∃x (New(x) ∨ ¬Able(x))) → (¬Cultural(cara)) ::: If there is someone who is either new or not able, then Cara is not cultural.\n((¬Bewildered(x) ∧ ¬Able(x))) ↔ (Jolly(x)) ::: Someone being neither bewildered nor able is equivalent to being jolly.\n((Octagonal(x) ∧ ¬Cultural(x))) ↔ (Jolly(x) ∧ Bewildered(x)) ::: If someone is octagonal and not cultural, then he is both jolly and bewildered, and vice versa.\n(∃x (¬Bewildered(x))) → (Jolly(cara)) ::: If there is someone who is not bewildered, then Cara is jolly.\n∀x((¬Blue(x)∨¬Serious(x))) ::: Someone who is either not jolly or not able is always new.\n(∃x (Bewildered(x))) → (¬Cultural(lesley) ∧ Octagonal(seymour)) ::: If there is at least one people who is bewildered, then Lesley is not cultural and Seymour is octagonal.\n",
            "First-Order-Logic Question": "¬Octagonal(maurice) ::: Maurice is not octagonal."
        },
        "diff": [
            {
                "raw": "(∀x ((¬Jolly(x) ∨ ¬Able(x))) → (New(x)) ::: Someone who is either not jolly or not able is always new.",
                "gram": "∀x((¬Blue(x)∨¬Serious(x))) ::: Someone who is either not jolly or not able is always new."
            }
        ],
        "answer": "C",
        "grammar_answer": "A",
        "manual_prog": {
            "First-Order-Logic Rules": "¬Bewildered(abel) ::: Abel is not bewildered.\nCultural(aaron) ::: Aaron is cultural.\nCultural(seymour) ::: Seymour is cultural.\nAble(abel) ::: Abel is able.\nJolly(maurice) ::: Maurice is jolly.\nBewildered(cara) ::: Cara is bewildered.\nCultural(maurice) ::: Maurice is cultural.\nCultural(abel) ::: Abel is cultural.\n¬Jolly(algernon) ::: Algernon is not jolly.\n¬New(algernon) ::: Algernon is not new.\nBewildered(seymour) ::: Seymour is bewildered.\nNew(maurice) ::: Maurice is new.\n((¬Jolly(algernon) ∨ Able(maurice))) → (Cultural(cara)) ::: If Algernon is not jolly or Maurice is able, then Cara is cultural.\n(∃x (Bewildered(x) ∧ ¬Octagonal(x))) → (Jolly(algernon)) ::: If there is at least one people who is both bewildered and not octagonal, then Algernon is jolly.\n(∀x (¬New(x))) ↔ (Bewildered(x) ∧ Cultural(x)) ::: Someone who is not new is always both bewildered and cultural.\n((Bewildered(abel))) ↔ (¬Jolly(algernon)) ::: If Abel is bewildered, then Algernon is not jolly, and vice versa.\n(∃x (¬New(x))) → (¬Jolly(lesley) ∧ Octagonal(lesley)) ::: If there is someone who is not new, then Lesley is not jolly and Lesley is octagonal.\n((Jolly(x) ∧ ¬Bewildered(x))) ↔ (¬Cultural(x)) ::: Someone being both jolly and not bewildered, then he is not cultural.\n(∃x (New(x) ∨ ¬Able(x))) → (¬Cultural(cara)) ::: If there is someone who is either new or not able, then Cara is not cultural.\n((¬Bewildered(x) ∧ ¬Able(x))) ↔ (Jolly(x)) ::: Someone being neither bewildered nor able is equivalent to being jolly.\n((Octagonal(x) ∧ ¬Cultural(x))) ↔ (Jolly(x) ∧ Bewildered(x)) ::: If someone is octagonal and not cultural, then he is both jolly and bewildered, and vice versa.\n(∃x (¬Bewildered(x))) → (Jolly(cara)) ::: If there is someone who is not bewildered, then Cara is jolly.\n(∀x ((¬Jolly(x) ∨ ¬Able(x))) → (New(x))) ::: Someone who is either not jolly or not able is always new.\n(∃x (Bewildered(x))) → (¬Cultural(lesley) ∧ Octagonal(seymour)) ::: If there is at least one people who is bewildered, then Lesley is not cultural and Seymour is octagonal.\n",
            "First-Order-Logic Question": "¬Octagonal(maurice) ::: Maurice is not octagonal."
        },
        "fixed": true
    },
    {
        "id": 146,
        "raw_prog": {
            "First-Order-Logic Rules": "¬Bewildered(abel) ::: Abel is not bewildered.\nCultural(aaron) ::: Aaron is cultural.\nCultural(seymour) ::: Seymour is cultural.\nAble(abel) ::: Abel is able.\nJolly(maurice) ::: Maurice is jolly.\nBewildered(cara) ::: Cara is bewildered.\nCultural(maurice) ::: Maurice is cultural.\nCultural(abel) ::: Abel is cultural.\n¬Jolly(algernon) ::: Algernon is not jolly.\n¬New(algernon) ::: Algernon is not new.\nBewildered(seymour) ::: Seymour is bewildered.\nNew(maurice) ::: Maurice is new.\n((¬Jolly(algernon) ∨ Able(maurice))) → (Cultural(cara)) ::: If Algernon is not jolly or Maurice is able, then Cara is cultural.\n(∃x (Bewildered(x) ∧ ¬Octagonal(x))) → (Jolly(algernon)) ::: If there is at least one people who is both bewildered and not octagonal, then Algernon is jolly.\n(∀x (¬New(x))) → (Bewildered(x) ∧ Cultural(x)) ::: Someone who is not new is always both bewildered and cultural.\n((Bewildered(abel))) ↔ (¬Jolly(algernon)) ::: If Abel is bewildered, then Algernon is not jolly, and vice versa.\n(∃x (¬New(x))) → (¬Jolly(lesley) ∧ Octagonal(lesley)) ::: If there is someone who is not new, then Lesley is not jolly and Lesley is octagonal.\n((Jolly(x) ∧ ¬Bewildered(x))) → (¬Cultural(x)) ::: If someone is both jolly and not bewildered, then he is not cultural.\n(∃x (New(x) ∨ ¬Able(x))) → (¬Cultural(cara)) ::: If there is someone who is either new or not able, then Cara is not cultural.\n((¬Bewildered(x) ∧ ¬Able(x))) ↔ (Jolly(x)) ::: Someone being neither bewildered nor able is equivalent to being jolly.\n((Octagonal(x) ∧ ¬Cultural(x))) ↔ ((Jolly(x) ∧ Bewildered(x))) ::: If someone is octagonal and not cultural, then he is both jolly and bewildered, and vice versa.\n(∃x (¬Bewildered(x))) → (Jolly(cara)) ::: If there is someone who is not bewildered, then Cara is jolly.\n(∀x ((¬Jolly(x) ∨ ¬Able(x))) → (New(x)) ::: Someone who is either not jolly or not able is always new.\n(∃x (Bewildered(x))) → (¬Cultural(lesley) ∧ Octagonal(seymour)) ::: If there is at least one people who is bewildered, then Lesley is not cultural and Seymour is octagonal.\n",
            "First-Order-Logic Question": "¬Cultural(abel) ::: Abel is not cultural."
        },
        "gram_prog": {
            "First-Order-Logic Rules": "¬Bewildered(abel) ::: Abel is not bewildered.\nCultural(aaron) ::: Aaron is cultural.\nCultural(seymour) ::: Seymour is cultural.\nAble(abel) ::: Abel is able.\nJolly(maurice) ::: Maurice is jolly.\nBewildered(cara) ::: Cara is bewildered.\nCultural(maurice) ::: Maurice is cultural.\nCultural(abel) ::: Abel is cultural.\n¬Jolly(algernon) ::: Algernon is not jolly.\n¬New(algernon) ::: Algernon is not new.\nBewildered(seymour) ::: Seymour is bewildered.\nNew(maurice) ::: Maurice is new.\n((¬Jolly(algernon) ∨ Able(maurice))) → (Cultural(cara)) ::: If Algernon is not jolly or Maurice is able, then Cara is cultural.\n(∃x (Bewildered(x) ∧ ¬Octagonal(x))) → (Jolly(algernon)) ::: If there is at least one people who is both bewildered and not octagonal, then Algernon is jolly.\n(∀x (¬New(x))) → (Bewildered(x) ∧ Cultural(x)) ::: Someone who is not new is always both bewildered and cultural.\n((Bewildered(abel))) ↔ (¬Jolly(algernon)) ::: If Abel is bewildered, then Algernon is not jolly, and vice versa.\n(∃x (¬New(x))) → (¬Jolly(lesley) ∧ Octagonal(lesley)) ::: If there is someone who is not new, then Lesley is not jolly and Lesley is octagonal.\n((Jolly(x) ∧ ¬Bewildered(x))) → (¬Cultural(x)) ::: If someone is both jolly and not bewildered, then he is not cultural.\n(∃x (New(x) ∨ ¬Able(x))) → (¬Cultural(cara)) ::: If there is someone who is either new or not able, then Cara is not cultural.\n((¬Bewildered(x) ∧ ¬Able(x))) ↔ (Jolly(x)) ::: Someone being neither bewildered nor able is equivalent to being jolly.\n((Octagonal(x) ∧ ¬Cultural(x))) ↔ ((Jolly(x) ∧ Bewildered(x))) ::: If someone is octagonal and not cultural, then he is both jolly and bewildered, and vice versa.\n(∃x (¬Bewildered(x))) → (Jolly(cara)) ::: If there is someone who is not bewildered, then Cara is jolly.\n∀x((¬Blue(x)∨¬Serious(x))) ::: Someone who is either not jolly or not able is always new.\n(∃x (Bewildered(x))) → (¬Cultural(lesley) ∧ Octagonal(seymour)) ::: If there is at least one people who is bewildered, then Lesley is not cultural and Seymour is octagonal.\n",
            "First-Order-Logic Question": "¬Cultural(abel) ::: Abel is not cultural."
        },
        "diff": [
            {
                "raw": "(∀x ((¬Jolly(x) ∨ ¬Able(x))) → (New(x)) ::: Someone who is either not jolly or not able is always new.",
                "gram": "∀x((¬Blue(x)∨¬Serious(x))) ::: Someone who is either not jolly or not able is always new."
            }
        ],
        "answer": "B",
        "grammar_answer": "A",
        "manual_prog": {
            "First-Order-Logic Rules": "¬Bewildered(abel) ::: Abel is not bewildered.\nCultural(aaron) ::: Aaron is cultural.\nCultural(seymour) ::: Seymour is cultural.\nAble(abel) ::: Abel is able.\nJolly(maurice) ::: Maurice is jolly.\nBewildered(cara) ::: Cara is bewildered.\nCultural(maurice) ::: Maurice is cultural.\nCultural(abel) ::: Abel is cultural.\n¬Jolly(algernon) ::: Algernon is not jolly.\n¬New(algernon) ::: Algernon is not new.\nBewildered(seymour) ::: Seymour is bewildered.\nNew(maurice) ::: Maurice is new.\n((¬Jolly(algernon) ∨ Able(maurice))) → (Cultural(cara)) ::: If Algernon is not jolly or Maurice is able, then Cara is cultural.\n(∃x (Bewildered(x) ∧ ¬Octagonal(x))) → (Jolly(algernon)) ::: If there is at least one people who is both bewildered and not octagonal, then Algernon is jolly.\n(∀x (¬New(x))) → (Bewildered(x) ∧ Cultural(x)) ::: Someone who is not new is always both bewildered and cultural.\n((Bewildered(abel))) ↔ (¬Jolly(algernon)) ::: If Abel is bewildered, then Algernon is not jolly, and vice versa.\n(∃x (¬New(x))) → (¬Jolly(lesley) ∧ Octagonal(lesley)) ::: If there is someone who is not new, then Lesley is not jolly and Lesley is octagonal.\n((Jolly(x) ∧ ¬Bewildered(x))) → (¬Cultural(x)) ::: If someone is both jolly and not bewildered, then he is not cultural.\n(∃x (New(x) ∨ ¬Able(x))) → (¬Cultural(cara)) ::: If there is someone who is either new or not able, then Cara is not cultural.\n((¬Bewildered(x) ∧ ¬Able(x))) ↔ (Jolly(x)) ::: Someone being neither bewildered nor able is equivalent to being jolly.\n((Octagonal(x) ∧ ¬Cultural(x))) ↔ ((Jolly(x) ∧ Bewildered(x))) ::: If someone is octagonal and not cultural, then he is both jolly and bewildered, and vice versa.\n(∃x (¬Bewildered(x))) → (Jolly(cara)) ::: If there is someone who is not bewildered, then Cara is jolly.\n(∀x ((¬Jolly(x) ∨ ¬Able(x))) → (New(x))) ::: Someone who is either not jolly or not able is always new.\n(∃x (Bewildered(x))) → (¬Cultural(lesley) ∧ Octagonal(seymour)) ::: If there is at least one people who is bewildered, then Lesley is not cultural and Seymour is octagonal.\n",
            "First-Order-Logic Question": "¬Cultural(abel) ::: Abel is not cultural."
        },
        "fixed": true
    },
    {
        "id": 218,
        "raw_prog": {
            "First-Order-Logic Rules": "¬Soft(gregory) ::: Gregory is not soft.\n¬Significant(max) ::: Max is not significant.\nHollow(max) ::: Max is hollow.\n¬Significant(conrad) ::: Conrad is not significant.\n¬Significant(adler) ::: Adler is not significant.\nCombative(lamont) ::: Lamont is combative.\n¬Precious(max) ::: Max is not precious.\nHollow(cary) ::: Cary is hollow.\n¬Combative(adler) ::: Adler is not combative.\nSignificant(cary) ::: Cary is significant.\nSignificant(seymour) ::: Seymour is significant.\n¬Fearless(conrad) ::: Conrad is not fearless.\n(∀x ((Precious(x) ∧ ¬Significant(x)) ↔ (¬Soft(x))) ::: If someone is precious and not significant, then he is not soft, and vice versa.\n(∀x ((Fearless(x) ∧ ¬Precious(x)) ↔ Significant(x))) ::: Someone being both fearless and not precious is equivalent to being significant.\n(∀x (Significant(x)) ↔ (¬Fearless(x))) ::: Someone who is significant is always not fearless.\n(∀x (¬Precious(x)) → (¬Hollow(x) ∧ ¬Soft(x))) ::: If someone is not precious, then he is neither hollow nor soft.\n(∀x ((Combative(x) ∧ Fearless(x)) ↔ (Significant(x) ∧ ¬Precious(x)))) ::: Someone being both combative and fearless is equivalent to being significant and not precious.\n(∀x ((¬Soft(x) ∨ ¬Significant(x)) → Hollow(x))) ::: If someone is not soft or not significant, then he is hollow.\n(¬Soft(seymour)) ↔ (¬Combative(max) ∧ Hollow(gregory)) ::: Seymour being not soft is equivalent to Max being not combative and Gregory being hollow.\n(¬Precious(adler)) ↔ (Soft(lamont)) ::: Adler is not precious if and only if Lamont is soft.\n(∀x (¬Significant(x)) → Hollow(x)) ::: All not significant people are hollow.\n(∀x (Fearless(x)) → (¬Significant(x))) ::: If someone is fearless, then he is not significant.\n(Hollow(adler)) → (¬Fearless(adler) ∧ ¬Soft(lamont)) ::: If Adler is hollow, then Adler is not fearless and Lamont is not soft.\n(¬Hollow(lamont)) ↔ (Significant(max)) ::: Lamont is not hollow if and only if Max is significant.\n",
            "First-Order-Logic Question": "¬Soft(conrad) ::: Conrad is not soft."
        },
        "gram_prog": {
            "First-Order-Logic Rules": "¬Soft(gregory) ::: Gregory is not soft.\n¬Significant(max) ::: Max is not significant.\nHollow(max) ::: Max is hollow.\n¬Significant(conrad) ::: Conrad is not significant.\n¬Significant(adler) ::: Adler is not significant.\nCombative(lamont) ::: Lamont is combative.\n¬Precious(max) ::: Max is not precious.\nHollow(cary) ::: Cary is hollow.\n¬Combative(adler) ::: Adler is not combative.\nSignificant(cary) ::: Cary is significant.\nSignificant(seymour) ::: Seymour is significant.\n¬Fearless(conrad) ::: Conrad is not fearless.\n∀x((Precious(x)∧¬Significant(x))) ::: If someone is precious and not significant, then he is not soft, and vice versa.\n(∀x ((Fearless(x) ∧ ¬Precious(x)) ↔ Significant(x))) ::: Someone being both fearless and not precious is equivalent to being significant.\n(∀x (Significant(x)) ↔ (¬Fearless(x))) ::: Someone who is significant is always not fearless.\n(∀x (¬Precious(x)) → (¬Hollow(x) ∧ ¬Soft(x))) ::: If someone is not precious, then he is neither hollow nor soft.\n(∀x ((Combative(x) ∧ Fearless(x)) ↔ (Significant(x) ∧ ¬Precious(x)))) ::: Someone being both combative and fearless is equivalent to being significant and not precious.\n(∀x ((¬Soft(x) ∨ ¬Significant(x)) → Hollow(x))) ::: If someone is not soft or not significant, then he is hollow.\n(¬Soft(seymour)) ↔ (¬Combative(max) ∧ Hollow(gregory)) ::: Seymour being not soft is equivalent to Max being not combative and Gregory being hollow.\n(¬Precious(adler)) ↔ (Soft(lamont)) ::: Adler is not precious if and only if Lamont is soft.\n(∀x (¬Significant(x)) → Hollow(x)) ::: All not significant people are hollow.\n(∀x (Fearless(x)) → (¬Significant(x))) ::: If someone is fearless, then he is not significant.\n(Hollow(adler)) → (¬Fearless(adler) ∧ ¬Soft(lamont)) ::: If Adler is hollow, then Adler is not fearless and Lamont is not soft.\n(¬Hollow(lamont)) ↔ (Significant(max)) ::: Lamont is not hollow if and only if Max is significant.\n",
            "First-Order-Logic Question": "¬Soft(conrad) ::: Conrad is not soft."
        },
        "diff": [
            {
                "raw": "(∀x ((Precious(x) ∧ ¬Significant(x)) ↔ (¬Soft(x))) ::: If someone is precious and not significant, then he is not soft, and vice versa.",
                "gram": "∀x((Precious(x)∧¬Significant(x))) ::: If someone is precious and not significant, then he is not soft, and vice versa."
            }
        ],
        "answer": "C",
        "grammar_answer": "A",
        "manual_prog": {
            "First-Order-Logic Rules": "¬Soft(gregory) ::: Gregory is not soft.\n¬Significant(max) ::: Max is not significant.\nHollow(max) ::: Max is hollow.\n¬Significant(conrad) ::: Conrad is not significant.\n¬Significant(adler) ::: Adler is not significant.\nCombative(lamont) ::: Lamont is combative.\n¬Precious(max) ::: Max is not precious.\nHollow(cary) ::: Cary is hollow.\n¬Combative(adler) ::: Adler is not combative.\nSignificant(cary) ::: Cary is significant.\nSignificant(seymour) ::: Seymour is significant.\n¬Fearless(conrad) ::: Conrad is not fearless.\n(∀x ((Precious(x) ∧ ¬Significant(x)) ↔ (¬Soft(x)))) ::: If someone is precious and not significant, then he is not soft, and vice versa.\n(∀x ((Fearless(x) ∧ ¬Precious(x)) ↔ Significant(x))) ::: Someone being both fearless and not precious is equivalent to being significant.\n(∀x (Significant(x)) ↔ (¬Fearless(x))) ::: Someone who is significant is always not fearless.\n(∀x (¬Precious(x)) → (¬Hollow(x) ∧ ¬Soft(x))) ::: If someone is not precious, then he is neither hollow nor soft.\n(∀x ((Combative(x) ∧ Fearless(x)) ↔ (Significant(x) ∧ ¬Precious(x)))) ::: Someone being both combative and fearless is equivalent to being significant and not precious.\n(∀x ((¬Soft(x) ∨ ¬Significant(x)) → Hollow(x))) ::: If someone is not soft or not significant, then he is hollow.\n(¬Soft(seymour)) ↔ (¬Combative(max) ∧ Hollow(gregory)) ::: Seymour being not soft is equivalent to Max being not combative and Gregory being hollow.\n(¬Precious(adler)) ↔ (Soft(lamont)) ::: Adler is not precious if and only if Lamont is soft.\n(∀x (¬Significant(x)) → Hollow(x)) ::: All not significant people are hollow.\n(∀x (Fearless(x)) → (¬Significant(x))) ::: If someone is fearless, then he is not significant.\n(Hollow(adler)) → (¬Fearless(adler) ∧ ¬Soft(lamont)) ::: If Adler is hollow, then Adler is not fearless and Lamont is not soft.\n(¬Hollow(lamont)) ↔ (Significant(max)) ::: Lamont is not hollow if and only if Max is significant.\n",
            "First-Order-Logic Question": "¬Soft(conrad) ::: Conrad is not soft."
        },
        "fixed": true
    },
    {
        "id": 246,
        "raw_prog": {
            "First-Order-Logic Rules": "¬Civil(juliana) ::: Juliana is not civil.\n¬Average(juliana) ::: Juliana is not average.\n¬Octagonal(lamont) ::: Lamont is not octagonal.\nSeveral(janine) ::: Janine is several.\nHollow(eli) ::: Eli is hollow.\n¬Hollow(janine) ::: Janine is not hollow.\n¬Average(juliana) ::: Juliana is not average.\n¬Fair(juliana) ::: Juliana is not fair.\nSeveral(eli) ::: Eli is several.\nHollow(christina) ::: Christina is hollow.\nCivil(janine) ::: Janine is civil.\nHollow(lamont) ::: Lamont is hollow.\n(Civil(lamont) → (Fair(eli) ∧ Average(juliana))) ::: It can be concluded that Eli is fair and Juliana is average once knowing that Lamont is civil.\n(¬Hollow(luka)) → (Fair(juliana)) ::: If Luka is not hollow, then Juliana is fair.\n(∀x ((Several(x) ∧ ¬Hollow(x)) ↔ (¬Civil(x) ∧ ¬Average(x)))) ::: Someone being both several and not hollow is equivalent to being not civil and not average.\n(∃x (Civil(x) ∨ Average(x))) → (¬Octagonal(luka)) ::: If there is at least one people who is civil or average, then Luka is not octagonal.\n(∃x (Average(x))) → (Octagonal(janine) ∧ Several(juliana)) ::: If there is at least one people who is average, then Janine is octagonal and Juliana is several.\n(∃x ((Octagonal(x) ∧ Hollow(x))) → (¬Average(luka) ∧ ¬Civil(janine))) ::: If there is someone who is both octagonal and hollow, then Luka is not average and Janine is not civil.\n(Civil(janine) → (Fair(luka))) ::: It can be concluded that Luka is fair once knowing that Janine is civil.\n((Octagonal(x) ∧ Civil(x)) ↔ (¬Average(x))) ::: Someone is octagonal and civil if and only if he is not average.\n(¬Fair(lamont)) → (Several(lamont) ∧ Octagonal(eli)) ::: If Lamont is not fair, then Lamont is several and Eli is octagonal.\n(∀x ((Hollow(x) ∨ ¬Fair(x)) → (¬Several(x))) ::: Someone who is either hollow or not fair is always not several.\n((¬Octagonal(lamont)) ↔ (Civil(lamont))) ::: Lamont is not octagonal if and only if Lamont is civil.\n(∃x (Hollow(x))) → (¬Average(janine) ∧ ¬Civil(christina)) ::: If there is someone who is hollow, then Janine is not average and Christina is not civil.\n",
            "First-Order-Logic Question": "¬Civil(luka) ::: Luka is not civil."
        },
        "gram_prog": {
            "First-Order-Logic Rules": "¬Civil(juliana) ::: Juliana is not civil.\n¬Average(juliana) ::: Juliana is not average.\n¬Octagonal(lamont) ::: Lamont is not octagonal.\nSeveral(janine) ::: Janine is several.\nHollow(eli) ::: Eli is hollow.\n¬Hollow(janine) ::: Janine is not hollow.\n¬Average(juliana) ::: Juliana is not average.\n¬Fair(juliana) ::: Juliana is not fair.\nSeveral(eli) ::: Eli is several.\nHollow(christina) ::: Christina is hollow.\nCivil(janine) ::: Janine is civil.\nHollow(lamont) ::: Lamont is hollow.\n(Civil(lamont) → (Fair(eli) ∧ Average(juliana))) ::: It can be concluded that Eli is fair and Juliana is average once knowing that Lamont is civil.\n(¬Hollow(luka)) → (Fair(juliana)) ::: If Luka is not hollow, then Juliana is fair.\n(∀x ((Several(x) ∧ ¬Hollow(x)) ↔ (¬Civil(x) ∧ ¬Average(x)))) ::: Someone being both several and not hollow is equivalent to being not civil and not average.\n(∃x (Civil(x) ∨ Average(x))) → (¬Octagonal(luka)) ::: If there is at least one people who is civil or average, then Luka is not octagonal.\n(∃x (Average(x))) → (Octagonal(janine) ∧ Several(juliana)) ::: If there is at least one people who is average, then Janine is octagonal and Juliana is several.\n(∃x ((Octagonal(x) ∧ Hollow(x))) → (¬Average(luka) ∧ ¬Civil(janine))) ::: If there is someone who is both octagonal and hollow, then Luka is not average and Janine is not civil.\n(Civil(janine) → (Fair(luka))) ::: It can be concluded that Luka is fair once knowing that Janine is civil.\n((Octagonal(x) ∧ Civil(x)) ↔ (¬Average(x))) ::: Someone is octagonal and civil if and only if he is not average.\n(¬Fair(lamont)) → (Several(lamont) ∧ Octagonal(eli)) ::: If Lamont is not fair, then Lamont is several and Eli is octagonal.\n∀x((Blue(x)∨¬Fresh(x))) ::: Someone who is either hollow or not fair is always not several.\n((¬Octagonal(lamont)) ↔ (Civil(lamont))) ::: Lamont is not octagonal if and only if Lamont is civil.\n(∃x (Hollow(x))) → (¬Average(janine) ∧ ¬Civil(christina)) ::: If there is someone who is hollow, then Janine is not average and Christina is not civil.\n",
            "First-Order-Logic Question": "¬Civil(luka) ::: Luka is not civil."
        },
        "diff": [
            {
                "raw": "(∀x ((Hollow(x) ∨ ¬Fair(x)) → (¬Several(x))) ::: Someone who is either hollow or not fair is always not several.",
                "gram": "∀x((Blue(x)∨¬Fresh(x))) ::: Someone who is either hollow or not fair is always not several."
            }
        ],
        "answer": "B",
        "grammar_answer": "A",
        "manual_prog": {
            "First-Order-Logic Rules": "¬Civil(juliana) ::: Juliana is not civil.\n¬Average(juliana) ::: Juliana is not average.\n¬Octagonal(lamont) ::: Lamont is not octagonal.\nSeveral(janine) ::: Janine is several.\nHollow(eli) ::: Eli is hollow.\n¬Hollow(janine) ::: Janine is not hollow.\n¬Average(juliana) ::: Juliana is not average.\n¬Fair(juliana) ::: Juliana is not fair.\nSeveral(eli) ::: Eli is several.\nHollow(christina) ::: Christina is hollow.\nCivil(janine) ::: Janine is civil.\nHollow(lamont) ::: Lamont is hollow.\n(Civil(lamont) → (Fair(eli) ∧ Average(juliana))) ::: It can be concluded that Eli is fair and Juliana is average once knowing that Lamont is civil.\n(¬Hollow(luka)) → (Fair(juliana)) ::: If Luka is not hollow, then Juliana is fair.\n(∀x ((Several(x) ∧ ¬Hollow(x)) ↔ (¬Civil(x) ∧ ¬Average(x)))) ::: Someone being both several and not hollow is equivalent to being not civil and not average.\n(∃x (Civil(x) ∨ Average(x))) → (¬Octagonal(luka)) ::: If there is at least one people who is civil or average, then Luka is not octagonal.\n(∃x (Average(x))) → (Octagonal(janine) ∧ Several(juliana)) ::: If there is at least one people who is average, then Janine is octagonal and Juliana is several.\n(∃x ((Octagonal(x) ∧ Hollow(x))) → (¬Average(luka) ∧ ¬Civil(janine))) ::: If there is someone who is both octagonal and hollow, then Luka is not average and Janine is not civil.\n(Civil(janine) → (Fair(luka))) ::: It can be concluded that Luka is fair once knowing that Janine is civil.\n((Octagonal(x) ∧ Civil(x)) ↔ (¬Average(x))) ::: Someone is octagonal and civil if and only if he is not average.\n(¬Fair(lamont)) → (Several(lamont) ∧ Octagonal(eli)) ::: If Lamont is not fair, then Lamont is several and Eli is octagonal.\n(∀x ((Hollow(x) ∨ ¬Fair(x)) → (¬Several(x)))) ::: Someone who is either hollow or not fair is always not several.\n((¬Octagonal(lamont)) ↔ (Civil(lamont))) ::: Lamont is not octagonal if and only if Lamont is civil.\n(∃x (Hollow(x))) → (¬Average(janine) ∧ ¬Civil(christina)) ::: If there is someone who is hollow, then Janine is not average and Christina is not civil.\n",
            "First-Order-Logic Question": "¬Civil(luka) ::: Luka is not civil."
        },
        "fixed": true
    },
    {
        "id": 250,
        "raw_prog": {
            "First-Order-Logic Rules": "¬Average(eli) ::: Eli is not average.\n¬Civil(juliana) ::: Juliana is not civil.\n¬Octagonal(lamont) ::: Lamont is not octagonal.\nSeveral(janine) ::: Janine is several.\nHollow(eli) ::: Eli is hollow.\n¬Hollow(janine) ::: Janine is not hollow.\n¬Average(juliana) ::: Juliana is not average.\n¬Fair(juliana) ::: Juliana is not fair.\nSeveral(eli) ::: Eli is several.\nHollow(christina) ::: Christina is hollow.\nCivil(janine) ::: Janine is civil.\nHollow(lamont) ::: Lamont is hollow.\n((Civil(lamont) ∧ Fair(juliana)) → (Fair(eli) ∧ Average(juliana))) ::: It can be concluded that Eli is fair and Juliana is average once knowing that Lamont is civil.\n(¬Hollow(luka)) → (Fair(juliana)) ::: If Luka is not hollow, then Juliana is fair.\n(∀x ((Several(x) ∧ ¬Hollow(x)) ↔ (¬Civil(x) ∧ ¬Average(x)))) ::: Someone being both several and not hollow is equivalent to being not civil and not average.\n(∃x (Civil(x) ∨ Average(x))) → (¬Octagonal(luka)) ::: If there is at least one people who is civil or average, then Luka is not octagonal.\n(∃x (Average(x))) → (Octagonal(janine) ∧ Several(juliana)) ::: If there is at least one people who is average, then Janine is octagonal and Juliana is several.\n(∃x ((Octagonal(x) ∧ Hollow(x))) → (¬Average(luka) ∧ ¬Civil(janine))) ::: If there is someone who is both octagonal and hollow, then Luka is not average and Janine is not civil.\n((Civil(janine))) → (Fair(luka)) ::: It can be concluded that Luka is fair once knowing that Janine is civil.\n(∀x ((Octagonal(x) ∧ Civil(x)) ↔ (¬Average(x))) ::: Someone is octagonal and civil if and only if he is not average.\n(¬Fair(lamont)) → (Several(lamont) ∧ Octagonal(eli)) ::: If Lamont is not fair, then Lamont is several and Eli is octagonal.\n(∀x ((Hollow(x) ∨ ¬Fair(x)) → (¬Several(x))) ::: Someone who is either hollow or not fair is always not several.\n(Octagonal(lamont)) ↔ (Civil(lamont)) ::: Lamont is not octagonal if and only if Lamont is civil.\n(∃x (Hollow(x))) → (¬Average(janine) ∧ ¬Civil(christina)) ::: If there is someone who is hollow, then Janine is not average and Christina is not civil.\n",
            "First-Order-Logic Question": "Fair(juliana) ::: Juliana is fair."
        },
        "gram_prog": {
            "First-Order-Logic Rules": "¬Average(eli) ::: Eli is not average.\n¬Civil(juliana) ::: Juliana is not civil.\n¬Octagonal(lamont) ::: Lamont is not octagonal.\nSeveral(janine) ::: Janine is several.\nHollow(eli) ::: Eli is hollow.\n¬Hollow(janine) ::: Janine is not hollow.\n¬Average(juliana) ::: Juliana is not average.\n¬Fair(juliana) ::: Juliana is not fair.\nSeveral(eli) ::: Eli is several.\nHollow(christina) ::: Christina is hollow.\nCivil(janine) ::: Janine is civil.\nHollow(lamont) ::: Lamont is hollow.\n((Civil(lamont) ∧ Fair(juliana)) → (Fair(eli) ∧ Average(juliana))) ::: It can be concluded that Eli is fair and Juliana is average once knowing that Lamont is civil.\n(¬Hollow(luka)) → (Fair(juliana)) ::: If Luka is not hollow, then Juliana is fair.\n(∀x ((Several(x) ∧ ¬Hollow(x)) ↔ (¬Civil(x) ∧ ¬Average(x)))) ::: Someone being both several and not hollow is equivalent to being not civil and not average.\n(∃x (Civil(x) ∨ Average(x))) → (¬Octagonal(luka)) ::: If there is at least one people who is civil or average, then Luka is not octagonal.\n(∃x (Average(x))) → (Octagonal(janine) ∧ Several(juliana)) ::: If there is at least one people who is average, then Janine is octagonal and Juliana is several.\n(∃x ((Octagonal(x) ∧ Hollow(x))) → (¬Average(luka) ∧ ¬Civil(janine))) ::: If there is someone who is both octagonal and hollow, then Luka is not average and Janine is not civil.\n((Civil(janine))) → (Fair(luka)) ::: It can be concluded that Luka is fair once knowing that Janine is civil.\n∀x((Blue(x)∧Concerned(x))) ::: Someone is octagonal and civil if and only if he is not average.\n(¬Fair(lamont)) → (Several(lamont) ∧ Octagonal(eli)) ::: If Lamont is not fair, then Lamont is several and Eli is octagonal.\n∀x((Blue(x)∨¬Fresh(x))) ::: Someone who is either hollow or not fair is always not several.\n(Octagonal(lamont)) ↔ (Civil(lamont)) ::: Lamont is not octagonal if and only if Lamont is civil.\n(∃x (Hollow(x))) → (¬Average(janine) ∧ ¬Civil(christina)) ::: If there is someone who is hollow, then Janine is not average and Christina is not civil.\n",
            "First-Order-Logic Question": "Fair(juliana) ::: Juliana is fair."
        },
        "diff": [
            {
                "raw": "(∀x ((Octagonal(x) ∧ Civil(x)) ↔ (¬Average(x))) ::: Someone is octagonal and civil if and only if he is not average.",
                "gram": "∀x((Blue(x)∧Concerned(x))) ::: Someone is octagonal and civil if and only if he is not average."
            },
            {
                "raw": "(∀x ((Hollow(x) ∨ ¬Fair(x)) → (¬Several(x))) ::: Someone who is either hollow or not fair is always not several.",
                "gram": "∀x((Blue(x)∨¬Fresh(x))) ::: Someone who is either hollow or not fair is always not several."
            }
        ],
        "answer": "B",
        "grammar_answer": "A",
        "manual_prog": {
            "First-Order-Logic Rules": "¬Average(eli) ::: Eli is not average.\n¬Civil(juliana) ::: Juliana is not civil.\n¬Octagonal(lamont) ::: Lamont is not octagonal.\nSeveral(janine) ::: Janine is several.\nHollow(eli) ::: Eli is hollow.\n¬Hollow(janine) ::: Janine is not hollow.\n¬Average(juliana) ::: Juliana is not average.\n¬Fair(juliana) ::: Juliana is not fair.\nSeveral(eli) ::: Eli is several.\nHollow(christina) ::: Christina is hollow.\nCivil(janine) ::: Janine is civil.\nHollow(lamont) ::: Lamont is hollow.\n((Civil(lamont) ∧ Fair(juliana)) → (Fair(eli) ∧ Average(juliana))) ::: It can be concluded that Eli is fair and Juliana is average once knowing that Lamont is civil.\n(¬Hollow(luka)) → (Fair(juliana)) ::: If Luka is not hollow, then Juliana is fair.\n(∀x ((Several(x) ∧ ¬Hollow(x)) ↔ (¬Civil(x) ∧ ¬Average(x)))) ::: Someone being both several and not hollow is equivalent to being not civil and not average.\n(∃x (Civil(x) ∨ Average(x))) → (¬Octagonal(luka)) ::: If there is at least one people who is civil or average, then Luka is not octagonal.\n(∃x (Average(x))) → (Octagonal(janine) ∧ Several(juliana)) ::: If there is at least one people who is average, then Janine is octagonal and Juliana is several.\n(∃x ((Octagonal(x) ∧ Hollow(x))) → (¬Average(luka) ∧ ¬Civil(janine))) ::: If there is someone who is both octagonal and hollow, then Luka is not average and Janine is not civil.\n((Civil(janine))) → (Fair(luka)) ::: It can be concluded that Luka is fair once knowing that Janine is civil.\n(∀x ((Octagonal(x) ∧ Civil(x)) ↔ (¬Average(x)))) ::: Someone is octagonal and civil if and only if he is not average.\n(¬Fair(lamont)) → (Several(lamont) ∧ Octagonal(eli)) ::: If Lamont is not fair, then Lamont is several and Eli is octagonal.\n(∀x ((Hollow(x) ∨ ¬Fair(x)) → (¬Several(x)))) ::: Someone who is either hollow or not fair is always not several.\n(Octagonal(lamont)) ↔ (Civil(lamont)) ::: Lamont is not octagonal if and only if Lamont is civil.\n(∃x (Hollow(x))) → (¬Average(janine) ∧ ¬Civil(christina)) ::: If there is someone who is hollow, then Janine is not average and Christina is not civil.\n",
            "First-Order-Logic Question": "Fair(juliana) ::: Juliana is fair."
        },
        "fixed": true
    },
    {
        "id": 363,
        "raw_prog": {
            "First-Order-Logic Rules": "¬Able(jasper) ::: Jasper is not able.\n¬Frank(jack) ::: Jack is not frank.\nCivil(jasper) ::: Jasper is civil.\n¬Civil(george) ::: George is not civil.\nFrank(burgess) ::: Burgess is frank.\nJolly(roderick) ::: Roderick is jolly.\n¬Civil(myra) ::: Myra is not civil.\nPrecious(roderick) ::: Roderick is precious.\nJolly(jack) ::: Jack is jolly.\n¬Able(burgess) ::: Burgess is not able.\n¬Jolly(miles) ::: Miles is not jolly.\nJolly(jasper) ::: Jasper is jolly.\n((Jolly(burgess))) → ((¬Able(roderick))) ::: It can be concluded that Roderick is not able once knowing that Burgess is jolly.\n(∃x (Able(x) ∧ Jolly(x))) → ((¬Frank(jasper))) ::: If there is someone who is both able and jolly, then Jasper is not frank.\n(∃x (¬Frank(x) ∨ ¬Civil(x))) → ((Able(roderick))) ::: If there is at least one people who is not frank or not civil, then Roderick is able.\n(∃x (Able(x))) → ((¬Frank(george) ∧ ¬Technical(jack))) ::: If there is someone who is able, then George is not frank and Jack is not technical.\n(¬(∃x (¬x))) → ((¬Frank(jack))) ::: If there is nobody who is not, then Jack is not frank.\n(∃x (¬Frank(x) ∨ ¬Precious(x))) → ((¬Able(roderick))) ::: If there is at least one people who is not frank or not precious, then Roderick is not able.\n(∀x (Frank(x))) → ((¬Precious(x) ∧ ¬Civil(x))) ::: If someone is frank, then he is neither precious nor civil.\n((¬Jolly(burgess) ∨ ¬Civil(roderick))) → ((¬Technical(george))) ::: It can be concluded that George is not technical once knowing that Burgess is not jolly or Roderick is not civil.\n(∀x (Precious(x))) ↔ ((¬Frank(x))) ::: If someone is precious, then he is not frank, and vice versa.\n(∀x (x ∨ Technical(x))) → ((¬Jolly(x))) ::: If someone is he or not precious is technical, then he is not jolly.\n(∀x (¬Civil(x) ∧ ¬Jolly(x))) ↔ ((Able(x))) ::: If someone is not civil and not jolly, then he is able, and vice versa.\n((Able(roderick))) → ((Precious(burgess) ∧ ¬Civil(jack))) ::: Roderick being able implies that Burgess is precious and Jack is not civil.\n",
            "First-Order-Logic Question": "¬Technical(burgess) ::: Burgess is not technical."
        },
        "gram_prog": {
            "First-Order-Logic Rules": "¬Able(jasper) ::: Jasper is not able.\n¬Frank(jack) ::: Jack is not frank.\nCivil(jasper) ::: Jasper is civil.\n¬Civil(george) ::: George is not civil.\nFrank(burgess) ::: Burgess is frank.\nJolly(roderick) ::: Roderick is jolly.\n¬Civil(myra) ::: Myra is not civil.\nPrecious(roderick) ::: Roderick is precious.\nJolly(jack) ::: Jack is jolly.\n¬Able(burgess) ::: Burgess is not able.\n¬Jolly(miles) ::: Miles is not jolly.\nJolly(jasper) ::: Jasper is jolly.\n((Jolly(burgess))) → ((¬Able(roderick))) ::: It can be concluded that Roderick is not able once knowing that Burgess is jolly.\n(∃x (Able(x) ∧ Jolly(x))) → ((¬Frank(jasper))) ::: If there is someone who is both able and jolly, then Jasper is not frank.\n(∃x (¬Frank(x) ∨ ¬Civil(x))) → ((Able(roderick))) ::: If there is at least one people who is not frank or not civil, then Roderick is able.\n(∃x (Able(x))) → ((¬Frank(george) ∧ ¬Technical(jack))) ::: If there is someone who is able, then George is not frank and Jack is not technical.\n¬((¬Frank(x))→(¬Able(x))) ::: If there is nobody who is not, then Jack is not frank.\n(∃x (¬Frank(x) ∨ ¬Precious(x))) → ((¬Able(roderick))) ::: If there is at least one people who is not frank or not precious, then Roderick is not able.\n(∀x (Frank(x))) → ((¬Precious(x) ∧ ¬Civil(x))) ::: If someone is frank, then he is neither precious nor civil.\n((¬Jolly(burgess) ∨ ¬Civil(roderick))) → ((¬Technical(george))) ::: It can be concluded that George is not technical once knowing that Burgess is not jolly or Roderick is not civil.\n(∀x (Precious(x))) ↔ ((¬Frank(x))) ::: If someone is precious, then he is not frank, and vice versa.\n∀x((Able(x)∨Frank(x))) ::: If someone is he or not precious is technical, then he is not jolly.\n(∀x (¬Civil(x) ∧ ¬Jolly(x))) ↔ ((Able(x))) ::: If someone is not civil and not jolly, then he is able, and vice versa.\n((Able(roderick))) → ((Precious(burgess) ∧ ¬Civil(jack))) ::: Roderick being able implies that Burgess is precious and Jack is not civil.\n",
            "First-Order-Logic Question": "¬Technical(burgess) ::: Burgess is not technical."
        },
        "diff": [
            {
                "raw": "(¬(∃x (¬x))) → ((¬Frank(jack))) ::: If there is nobody who is not, then Jack is not frank.",
                "gram": "¬((¬Frank(x))→(¬Able(x))) ::: If there is nobody who is not, then Jack is not frank."
            },
            {
                "raw": "(∀x (x ∨ Technical(x))) → ((¬Jolly(x))) ::: If someone is he or not precious is technical, then he is not jolly.",
                "gram": "∀x((Able(x)∨Frank(x))) ::: If someone is he or not precious is technical, then he is not jolly."
            }
        ],
        "answer": "C",
        "grammar_answer": "A",
        "manual_prog": {
            "First-Order-Logic Rules": "¬Able(jasper) ::: Jasper is not able.\n¬Frank(jack) ::: Jack is not frank.\nCivil(jasper) ::: Jasper is civil.\n¬Civil(george) ::: George is not civil.\nFrank(burgess) ::: Burgess is frank.\nJolly(roderick) ::: Roderick is jolly.\n¬Civil(myra) ::: Myra is not civil.\nPrecious(roderick) ::: Roderick is precious.\nJolly(jack) ::: Jack is jolly.\n¬Able(burgess) ::: Burgess is not able.\n¬Jolly(miles) ::: Miles is not jolly.\nJolly(jasper) ::: Jasper is jolly.\n((Jolly(burgess))) → ((¬Able(roderick))) ::: It can be concluded that Roderick is not able once knowing that Burgess is jolly.\n(∃x (Able(x) ∧ Jolly(x))) → ((¬Frank(jasper))) ::: If there is someone who is both able and jolly, then Jasper is not frank.\n(∃x (¬Frank(x) ∨ ¬Civil(x))) → ((Able(roderick))) ::: If there is at least one people who is not frank or not civil, then Roderick is able.\n(∃x (Able(x))) → ((¬Frank(george) ∧ ¬Technical(jack))) ::: If there is someone who is able, then George is not frank and Jack is not technical.\n(∃x ¬Not(x)) → ((¬Frank(jack))) ::: If there is nobody who is not, then Jack is not frank.\n(∃x (¬Frank(x) ∨ ¬Precious(x))) → ((¬Able(roderick))) ::: If there is at least one people who is not frank or not precious, then Roderick is not able.\n(∀x (Frank(x))) → ((¬Precious(x) ∧ ¬Civil(x))) ::: If someone is frank, then he is neither precious nor civil.\n((¬Jolly(burgess) ∨ ¬Civil(roderick))) → ((¬Technical(george))) ::: It can be concluded that George is not technical once knowing that Burgess is not jolly or Roderick is not civil.\n(∀x (Precious(x))) ↔ ((¬Frank(x))) ::: If someone is precious, then he is not frank, and vice versa.\n(∀x Technical(x)) → ((¬Jolly(x))) ::: If someone is he or not precious is technical, then he is not jolly.\n(∀x (¬Civil(x) ∧ ¬Jolly(x))) ↔ ((Able(x))) ::: If someone is not civil and not jolly, then he is able, and vice versa.\n((Able(roderick))) → ((Precious(burgess) ∧ ¬Civil(jack))) ::: Roderick being able implies that Burgess is precious and Jack is not civil.\n",
            "First-Order-Logic Question": "¬Technical(burgess) ::: Burgess is not technical."
        },
        "fixed": true
    },
    {
        "id": 563,
        "raw_prog": {
            "First-Order-Logic Rules": "Aggressive(montague) ::: Montague is aggressive.\nImpossible(ansel) ::: Ansel is impossible.\n¬Wicked(cyril) ::: Cyril is not wicked.\n¬Wicked(ansel) ::: Ansel is not wicked.\nDrab(katelynn) ::: Katelynn is drab.\n¬Drab(montague) ::: Montague is not drab.\n¬Mushy(ansel) ::: Ansel is not mushy.\n¬Wicked(joseph) ::: Joseph is not wicked.\nDrab(olive) ::: Olive is drab.\nBroad-minded(joseph) ::: Joseph is broad-minded.\n¬Drab(ansel) ::: Ansel is not drab.\n¬Wicked(montague) ::: Montague is not wicked.\n((Mushy(montague) ∧ ¬Wicked(katelynn))) → (¬Aggressive(ansel)) ::: Montague being mushy and Katelynn being not wicked imply that Ansel is not aggressive.\n(Broad-minded(joseph)) ↔ (¬Impossible(joseph)) ::: Joseph is broad-minded if and only if Joseph is not impossible.\n(∃x (¬Mushy(x))) → (¬Aggressive(whitney) ∧ Impossible(cyril)) ::: If there is at least one people who is not mushy, then Whitney is not aggressive and Cyril is impossible.\n(∃x (Broad-minded(x) ∨ Impossible(x))) → (Aggressive(olive)) ::: If there is someone who is either broad-minded or impossible, then Olive is aggressive.\n(¬∃x (¬P(x))) → (¬Broad-minded(cyril) ∧ Aggressive(ansel)) ::: If there is nobody who is not, then Cyril is not broad-minded and Ansel is aggressive.\n((Wicked(olive) ∧ Drab(katelynn))) ↔ ((Aggressive(joseph) ∧ ¬Broad-minded(montague))) ::: Olive is wicked and Katelynn is drab if and only if Joseph is aggressive and Montague is not broad-minded.\n(∃x (Mushy(x))) → (Broad-minded(katelynn) ∧ ¬Aggressive(joseph)) ::: If there is at least one people who is mushy, then Katelynn is broad-minded and Joseph is not aggressive.\n((Wicked(olive) ∨ Broad-minded(cyril))) → (Aggressive(katelynn)) ::: Olive being wicked or Cyril being broad-minded implies that Katelynn is aggressive.\n(∃x (Wicked(x) ∧ ¬Mushy(x))) → (¬Drab(montague)) ::: If there is someone who is both wicked and not mushy, then Montague is not drab.\n(¬Impossible(whitney)) → (¬Mushy(cyril) ∧ Broad-minded(joseph)) ::: Whitney being not impossible implies that Cyril is not mushy and Joseph is broad-minded.\n(¬Aggressive(x)) ↔ (¬Impossible(x)) ::: Someone is not aggressive if and only if he is not impossible.\n((Aggressive(x) ∧ ¬Drab(x))) ↔ (¬Impossible(x)) ::: Someone is aggressive and not drab if and only if he is not impossible.\n",
            "First-Order-Logic Question": "Wicked(ansel) ::: Ansel is wicked."
        },
        "gram_prog": {
            "First-Order-Logic Rules": "Aggressive(montague) ::: Montague is aggressive.\nImpossible(ansel) ::: Ansel is impossible.\n¬Wicked(cyril) ::: Cyril is not wicked.\n¬Wicked(ansel) ::: Ansel is not wicked.\nDrab(katelynn) ::: Katelynn is drab.\n¬Drab(montague) ::: Montague is not drab.\n¬Mushy(ansel) ::: Ansel is not mushy.\n¬Wicked(joseph) ::: Joseph is not wicked.\nDrab(olive) ::: Olive is drab.\nBroadMinded(joseph) ::: Joseph is broad-minded.\n¬Drab(ansel) ::: Ansel is not drab.\n¬Wicked(montague) ::: Montague is not wicked.\n((Mushy(montague) ∧ ¬Wicked(katelynn))) → (¬Aggressive(ansel)) ::: Montague being mushy and Katelynn being not wicked imply that Ansel is not aggressive.\n(BroadMinded(joseph)) ↔ (¬Impossible(joseph)) ::: Joseph is broad-minded if and only if Joseph is not impossible.\n(∃x (¬Mushy(x))) → (¬Aggressive(whitney) ∧ Impossible(cyril)) ::: If there is at least one person who is not mushy, then Whitney is not aggressive and Cyril is impossible.\n(∃x (BroadMinded(x) ∨ Impossible(x))) → (Aggressive(olive)) ::: If there is someone who is either broad-minded or impossible, then Olive is aggressive.\n¬(∃x(¬BroadMinded(x))) → (¬Aggressive(x) ∧ Impossible(x)) ::: If there is nobody who is not broad-minded, then Cyril is not broad-minded and Ansel is aggressive.\n((Wicked(olive) ∧ Drab(katelynn))) ↔ ((Aggressive(joseph) ∧ ¬BroadMinded(montague))) ::: Olive is wicked and Katelynn is drab if and only if Joseph is aggressive and Montague is not broad-minded.\n(∃x (Mushy(x))) → (BroadMinded(katelynn) ∧ ¬Aggressive(joseph)) ::: If there is at least one person who is mushy, then Katelynn is broad-minded and Joseph is not aggressive.\n((Wicked(olive) ∨ BroadMinded(cyril))) → (Aggressive(katelynn)) ::: Olive being wicked or Cyril being broad-minded implies that Katelynn is aggressive.\n(∃x (Wicked(x) ∧ ¬Mushy(x))) → (¬Drab(montague)) ::: If there is someone who is both wicked and not mushy, then Montague is not drab.\n(¬Impossible(whitney)) → (¬Mushy(cyril) ∧ BroadMinded(joseph)) ::: Whitney being not impossible implies that Cyril is not mushy and Joseph is broad-minded.\n(¬Aggressive(x)) ↔ (¬Impossible(x)) ::: Someone is not aggressive if and only if he is not impossible.\n((Aggressive(x) ∧ ¬Drab(x))) ↔ (¬Impossible(x)) ::: Someone is aggressive and not drab if and only if he is not impossible.",
            "First-Order-Logic Question": "Wicked(ansel) ::: Ansel is wicked."
        },
        "diff": [],
        "answer": "B",
        "grammar_answer": "A",
        "manual_prog": {
            "First-Order-Logic Rules": "Aggressive(montague) ::: Montague is aggressive.\nImpossible(ansel) ::: Ansel is impossible.\n¬Wicked(cyril) ::: Cyril is not wicked.\n¬Wicked(ansel) ::: Ansel is not wicked.\nDrab(katelynn) ::: Katelynn is drab.\n¬Drab(montague) ::: Montague is not drab.\n¬Mushy(ansel) ::: Ansel is not mushy.\n¬Wicked(joseph) ::: Joseph is not wicked.\nDrab(olive) ::: Olive is drab.\nBroad-minded(joseph) ::: Joseph is broad-minded.\n¬Drab(ansel) ::: Ansel is not drab.\n¬Wicked(montague) ::: Montague is not wicked.\n((Mushy(montague) ∧ ¬Wicked(katelynn))) → (¬Aggressive(ansel)) ::: Montague being mushy and Katelynn being not wicked imply that Ansel is not aggressive.\n(Broad-minded(joseph)) ↔ (¬Impossible(joseph)) ::: Joseph is broad-minded if and only if Joseph is not impossible.\n(∃x (¬Mushy(x))) → (¬Aggressive(whitney) ∧ Impossible(cyril)) ::: If there is at least one people who is not mushy, then Whitney is not aggressive and Cyril is impossible.\n(∃x (Broad-minded(x) ∨ Impossible(x))) → (Aggressive(olive)) ::: If there is someone who is either broad-minded or impossible, then Olive is aggressive.\n(¬∃x (¬P(x))) → (¬Broad-minded(cyril) ∧ Aggressive(ansel)) ::: If there is nobody who is not, then Cyril is not broad-minded and Ansel is aggressive.\n((Wicked(olive) ∧ Drab(katelynn))) ↔ ((Aggressive(joseph) ∧ ¬Broad-minded(montague))) ::: Olive is wicked and Katelynn is drab if and only if Joseph is aggressive and Montague is not broad-minded.\n(∃x (Mushy(x))) → (Broad-minded(katelynn) ∧ ¬Aggressive(joseph)) ::: If there is at least one people who is mushy, then Katelynn is broad-minded and Joseph is not aggressive.\n((Wicked(olive) ∨ Broad-minded(cyril))) → (Aggressive(katelynn)) ::: Olive being wicked or Cyril being broad-minded implies that Katelynn is aggressive.\n(∃x (Wicked(x) ∧ ¬Mushy(x))) → (¬Drab(montague)) ::: If there is someone who is both wicked and not mushy, then Montague is not drab.\n(¬Impossible(whitney)) → (¬Mushy(cyril) ∧ Broad-minded(joseph)) ::: Whitney being not impossible implies that Cyril is not mushy and Joseph is broad-minded.\n(¬Aggressive(x)) ↔ (¬Impossible(x)) ::: Someone is not aggressive if and only if he is not impossible.\n((Aggressive(x) ∧ ¬Drab(x))) ↔ (¬Impossible(x)) ::: Someone is aggressive and not drab if and only if he is not impossible.\n",
            "First-Order-Logic Question": "Wicked(ansel) ::: Ansel is wicked."
        },
        "fixed": true
    },
    {
        "id": 566,
        "raw_prog": {
            "First-Order-Logic Rules": "Aggressive(montague) ::: Montague is aggressive.\nImpossible(ansel) ::: Ansel is impossible.\n¬Wicked(cyril) ::: Cyril is not wicked.\n¬Wicked(ansel) ::: Ansel is not wicked.\nDrab(katelynn) ::: Katelynn is drab.\n¬Drab(montague) ::: Montague is not drab.\n¬Mushy(ansel) ::: Ansel is not mushy.\n¬Wicked(joseph) ::: Joseph is not wicked.\nDrab(olive) ::: Olive is drab.\nBroad-minded(joseph) ::: Joseph is broad-minded.\n¬Drab(ansel) ::: Ansel is not drab.\n¬Wicked(montague) ::: Montague is not wicked.\n((Mushy(montague) ∧ ¬Wicked(katelynn))) → ((¬Aggressive(ansel))) ::: Montague being mushy and Katelynn being not wicked imply that Ansel is not aggressive.\n((Broad-minded(joseph))) ↔ ((¬Impossible(joseph))) ::: Joseph is broad-minded if and only if Joseph is not impossible.\n(∃x (¬Mushy(x))) → ((¬Aggressive(whitney) ∧ Impossible(cyril))) ::: If there is at least one people who is not mushy, then Whitney is not aggressive and Cyril is impossible.\n(∃x (Broad-minded(x) ∨ Impossible(x))) → ((Aggressive(olive))) ::: If there is someone who is either broad-minded or impossible, then Olive is aggressive.\n(¬∃x (¬x)) → ((¬Broad-minded(cyril) ∧ Aggressive(ansel))) ::: If there is nobody who is not, then Cyril is not broad-minded and Ansel is aggressive.\n((Wicked(olive) ∧ Drab(katelynn))) ↔ ((Aggressive(joseph) ∧ ¬Broad-minded(montague))) ::: Olive is wicked and Katelynn is drab if and only if Joseph is aggressive and Montague is not broad-minded.\n(∃x (Mushy(x))) → ((Broad-minded(katelynn) ∧ ¬Aggressive(joseph))) ::: If there is at least one people who is mushy, then Katelynn is broad-minded and Joseph is not aggressive.\n((Wicked(olive) ∨ Broad-minded(cyril))) → ((Aggressive(katelynn))) ::: Olive being wicked or Cyril being broad-minded implies that Katelynn is aggressive.\n(∃x (Wicked(x) ∧ ¬Mushy(x))) → ((¬Drab(montague))) ::: If there is someone who is both wicked and not mushy, then Montague is not drab.\n(¬Impossible(whitney)) → ((¬Mushy(cyril) ∧ Broad-minded(joseph))) ::: Whitney being not impossible implies that Cyril is not mushy and Joseph is broad-minded.\n((¬Aggressive(x))) ↔ ((¬Impossible(x))) ::: Someone is not aggressive if and only if he is not impossible.\n((Aggressive(x) ∧ ¬Drab(x))) ↔ ((¬Impossible(x))) ::: Someone is aggressive and not drab if and only if he is not impossible.\n",
            "First-Order-Logic Question": "Impossible(whitney) ::: Whitney is impossible."
        },
        "gram_prog": {
            "First-Order-Logic Rules": "Aggressive(montague) ::: Montague is aggressive.\nImpossible(ansel) ::: Ansel is impossible.\n¬Wicked(cyril) ::: Cyril is not wicked.\n¬Wicked(ansel) ::: Ansel is not wicked.\nDrab(katelynn) ::: Katelynn is drab.\n¬Drab(montague) ::: Montague is not drab.\n¬Mushy(ansel) ::: Ansel is not mushy.\n¬Wicked(joseph) ::: Joseph is not wicked.\nDrab(olive) ::: Olive is drab.\nBroadMinded(joseph) ::: Joseph is broad-minded.\n¬Drab(ansel) ::: Ansel is not drab.\n¬Wicked(montague) ::: Montague is not wicked.\n((Mushy(montague) ∧ ¬Wicked(katelynn))) → (¬Aggressive(ansel)) ::: Montague being mushy and Katelynn being not wicked imply that Ansel is not aggressive.\n((BroadMinded(joseph))) ↔ (¬Impossible(joseph)) ::: Joseph is broad-minded if and only if Joseph is not impossible.\n(∃x (¬Mushy(x))) → (¬Aggressive(whitney) ∧ Impossible(cyril)) ::: If there is at least one person who is not mushy, then Whitney is not aggressive and Cyril is impossible.\n(∃x (BroadMinded(x) ∨ Impossible(x))) → (Aggressive(olive)) ::: If there is someone who is either broad-minded or impossible, then Olive is aggressive.\n¬(∃x((¬BroadMinded(x)∧Aggressive(x)))) ::: If there is nobody who is not, then Cyril is not broad-minded and Ansel is aggressive.\n((Wicked(olive) ∧ Drab(katelynn))) ↔ (Aggressive(joseph) ∧ ¬BroadMinded(montague)) ::: Olive is wicked and Katelynn is drab if and only if Joseph is aggressive and Montague is not broad-minded.\n(∃x (Mushy(x))) → (BroadMinded(katelynn) ∧ ¬Aggressive(joseph)) ::: If there is at least one person who is mushy, then Katelynn is broad-minded and Joseph is not aggressive.\n((Wicked(olive) ∨ BroadMinded(cyril))) → (Aggressive(katelynn)) ::: Olive being wicked or Cyril being broad-minded implies that Katelynn is aggressive.\n(∃x (Wicked(x) ∧ ¬Mushy(x))) → (¬Drab(montague)) ::: If there is someone who is both wicked and not mushy, then Montague is not drab.\n(¬Impossible(whitney)) → (¬Mushy(cyril) ∧ BroadMinded(joseph)) ::: Whitney being not impossible implies that Cyril is not mushy and Joseph is broad-minded.\n((¬Aggressive(x))) ↔ (¬Impossible(x)) ::: Someone is not aggressive if and only if he is not impossible.\n((Aggressive(x) ∧ ¬Drab(x))) ↔ (¬Impossible(x)) ::: Someone is aggressive and not drab if and only if he is not impossible.",
            "First-Order-Logic Question": "Impossible(whitney) ::: Whitney is impossible."
        },
        "diff": [],
        "answer": "B",
        "grammar_answer": "A",
        "manual_prog": {
            "First-Order-Logic Rules": "Aggressive(montague) ::: Montague is aggressive.\nImpossible(ansel) ::: Ansel is impossible.\n¬Wicked(cyril) ::: Cyril is not wicked.\n¬Wicked(ansel) ::: Ansel is not wicked.\nDrab(katelynn) ::: Katelynn is drab.\n¬Drab(montague) ::: Montague is not drab.\n¬Mushy(ansel) ::: Ansel is not mushy.\n¬Wicked(joseph) ::: Joseph is not wicked.\nDrab(olive) ::: Olive is drab.\nBroad-minded(joseph) ::: Joseph is broad-minded.\n¬Drab(ansel) ::: Ansel is not drab.\n¬Wicked(montague) ::: Montague is not wicked.\n((Mushy(montague) ∧ ¬Wicked(katelynn))) → ((¬Aggressive(ansel))) ::: Montague being mushy and Katelynn being not wicked imply that Ansel is not aggressive.\n((Broad-minded(joseph))) ↔ ((¬Impossible(joseph))) ::: Joseph is broad-minded if and only if Joseph is not impossible.\n(∃x (¬Mushy(x))) → ((¬Aggressive(whitney) ∧ Impossible(cyril))) ::: If there is at least one people who is not mushy, then Whitney is not aggressive and Cyril is impossible.\n(∃x (Broad-minded(x) ∨ Impossible(x))) → ((Aggressive(olive))) ::: If there is someone who is either broad-minded or impossible, then Olive is aggressive.\n(¬∃x (¬x)) → ((¬Broad-minded(cyril) ∧ Aggressive(ansel))) ::: If there is nobody who is not, then Cyril is not broad-minded and Ansel is aggressive.\n((Wicked(olive) ∧ Drab(katelynn))) ↔ ((Aggressive(joseph) ∧ ¬Broad-minded(montague))) ::: Olive is wicked and Katelynn is drab if and only if Joseph is aggressive and Montague is not broad-minded.\n(∃x (Mushy(x))) → ((Broad-minded(katelynn) ∧ ¬Aggressive(joseph))) ::: If there is at least one people who is mushy, then Katelynn is broad-minded and Joseph is not aggressive.\n((Wicked(olive) ∨ Broad-minded(cyril))) → ((Aggressive(katelynn))) ::: Olive being wicked or Cyril being broad-minded implies that Katelynn is aggressive.\n(∃x (Wicked(x) ∧ ¬Mushy(x))) → ((¬Drab(montague))) ::: If there is someone who is both wicked and not mushy, then Montague is not drab.\n(¬Impossible(whitney)) → ((¬Mushy(cyril) ∧ Broad-minded(joseph))) ::: Whitney being not impossible implies that Cyril is not mushy and Joseph is broad-minded.\n((¬Aggressive(x))) ↔ ((¬Impossible(x))) ::: Someone is not aggressive if and only if he is not impossible.\n((Aggressive(x) ∧ ¬Drab(x))) ↔ ((¬Impossible(x))) ::: Someone is aggressive and not drab if and only if he is not impossible.\n",
            "First-Order-Logic Question": "Impossible(whitney) ::: Whitney is impossible."
        },
        "fixed": true
    },
    {
        "id": 592,
        "raw_prog": {
            "First-Order-Logic Rules": "¬Hard(max) ::: Max is not hard.\n¬Average(noel) ::: Noel is not average.\n¬Jolly(roderick) ::: Roderick is not jolly.\nAverage(roderick) ::: Roderick is average.\n¬Several(cara) ::: Cara is not several.\nAverage(cara) ::: Cara is average.\nHard(keith) ::: Keith is hard.\nHard(jack) ::: Jack is hard.\nSeveral(noel) ::: Noel is several.\nGiant(jack) ::: Jack is giant.\n¬Giant(roderick) ::: Roderick is not giant.\nJolly(rose) ::: Rose is jolly.\n(∀x (¬Several(x))) → (∀x (¬Old(x) ∧ ¬Hard(x))) ::: As long as someone is not several, he is not old and not hard.\n(∃x (Hard(x) ∨ ¬Old(x))) → ((¬Average(max) ∧ Jolly(rose))) ::: If there is at least one people who is either hard or not old, then Max is not average and Rose is jolly.\n(∃x (Old(x) ∧ Hard(x))) → (Giant(noel)) ::: If there is someone who is both old and hard, then Noel is giant.\n(∃x (Old(x) ∨ ¬Jolly(x))) → (Several(rose)) ::: If there is at least one people who is old or not jolly, then Rose is several.\n(∃x (Jolly(x))) → ((Average(cara) ∧ ¬Hard(keith))) ::: If there is at least one people who is jolly, then Cara is average and Keith is not hard.\n(∀x (Old(x))) ↔ (∀x (¬Hard(x))) ::: If someone is old, then he is not hard, and vice versa.\n(Jack is not several) ↔ (Cara is not old) ::: Jack is not several if and only if Cara is not old.\n(∀x (Old(x) ∧ ¬Several(x))) → (∀x (¬Hard(x) ∧ ¬Jolly(x))) ::: As long as someone is old and not several, he is not hard and not jolly.\n(∀x (¬Hard(x) ∧ ¬Old(x))) ↔ (∀x (¬Giant(x))) ::: Someone being neither hard nor old is equivalent to being not giant.\n(∀x (Old(x) ∧ ¬Jolly(x))) ↔ (∀x (Average(x))) ::: If someone is old and not jolly, then he is average, and vice versa.\n(∀x (¬Average(x))) → (∀x (¬Old(x))) ::: If someone is not average, then he is not old.\n(∃x (Giant(x))) → ((¬Hard(max) ∧ Old(jack))) ::: If there is someone who is giant, then Max is not hard and Jack is old.\n",
            "First-Order-Logic Question": "¬Hard(noel) ::: Noel is not hard."
        },
        "gram_prog": {
            "First-Order-Logic Rules": "¬Hard(max) ::: Max is not hard.\n¬Average(noel) ::: Noel is not average.\n¬Jolly(roderick) ::: Roderick is not jolly.\nAverage(roderick) ::: Roderick is average.\n¬Several(cara) ::: Cara is not several.\nAverage(cara) ::: Cara is average.\nHard(keith) ::: Keith is hard.\nHard(jack) ::: Jack is hard.\nSeveral(noel) ::: Noel is several.\nGiant(jack) ::: Jack is giant.\n¬Giant(roderick) ::: Roderick is not giant.\nJolly(rose) ::: Rose is jolly.\n(∀x (¬Several(x))) → (∀x (¬Old(x) ∧ ¬Hard(x))) ::: As long as someone is not several, he is not old and not hard.\n(∃x (Hard(x) ∨ ¬Old(x))) → ((¬Average(max) ∧ Jolly(rose))) ::: If there is at least one people who is either hard or not old, then Max is not average and Rose is jolly.\n(∃x (Old(x) ∧ Hard(x))) → (Giant(noel)) ::: If there is someone who is both old and hard, then Noel is giant.\n(∃x (Old(x) ∨ ¬Jolly(x))) → (Several(rose)) ::: If there is at least one people who is old or not jolly, then Rose is several.\n(∃x (Jolly(x))) → ((Average(cara) ∧ ¬Hard(keith))) ::: If there is at least one people who is jolly, then Cara is average and Keith is not hard.\n(∀x (Old(x))) ↔ (∀x (¬Hard(x))) ::: If someone is old, then he is not hard, and vice versa.\n¬(Concerned(x)→Serious(x)) ::: Jack is not several if and only if Cara is not old.\n(∀x (Old(x) ∧ ¬Several(x))) → (∀x (¬Hard(x) ∧ ¬Jolly(x))) ::: As long as someone is old and not several, he is not hard and not jolly.\n(∀x (¬Hard(x) ∧ ¬Old(x))) ↔ (∀x (¬Giant(x))) ::: Someone being neither hard nor old is equivalent to being not giant.\n(∀x (Old(x) ∧ ¬Jolly(x))) ↔ (∀x (Average(x))) ::: If someone is old and not jolly, then he is average, and vice versa.\n(∀x (¬Average(x))) → (∀x (¬Old(x))) ::: If someone is not average, then he is not old.\n(∃x (Giant(x))) → ((¬Hard(max) ∧ Old(jack))) ::: If there is someone who is giant, then Max is not hard and Jack is old.\n",
            "First-Order-Logic Question": "¬Hard(noel) ::: Noel is not hard."
        },
        "diff": [
            {
                "raw": "(Jack is not several) ↔ (Cara is not old) ::: Jack is not several if and only if Cara is not old.",
                "gram": "¬(Concerned(x)→Serious(x)) ::: Jack is not several if and only if Cara is not old."
            }
        ],
        "answer": "C",
        "grammar_answer": "A",
        "manual_prog": {
            "First-Order-Logic Rules": "¬Hard(max) ::: Max is not hard.\n¬Average(noel) ::: Noel is not average.\n¬Jolly(roderick) ::: Roderick is not jolly.\nAverage(roderick) ::: Roderick is average.\n¬Several(cara) ::: Cara is not several.\nAverage(cara) ::: Cara is average.\nHard(keith) ::: Keith is hard.\nHard(jack) ::: Jack is hard.\nSeveral(noel) ::: Noel is several.\nGiant(jack) ::: Jack is giant.\n¬Giant(roderick) ::: Roderick is not giant.\nJolly(rose) ::: Rose is jolly.\n(∀x (¬Several(x))) → (∀x (¬Old(x) ∧ ¬Hard(x))) ::: As long as someone is not several, he is not old and not hard.\n(∃x (Hard(x) ∨ ¬Old(x))) → ((¬Average(max) ∧ Jolly(rose))) ::: If there is at least one people who is either hard or not old, then Max is not average and Rose is jolly.\n(∃x (Old(x) ∧ Hard(x))) → (Giant(noel)) ::: If there is someone who is both old and hard, then Noel is giant.\n(∃x (Old(x) ∨ ¬Jolly(x))) → (Several(rose)) ::: If there is at least one people who is old or not jolly, then Rose is several.\n(∃x (Jolly(x))) → ((Average(cara) ∧ ¬Hard(keith))) ::: If there is at least one people who is jolly, then Cara is average and Keith is not hard.\n(∀x (Old(x))) ↔ (∀x (¬Hard(x))) ::: If someone is old, then he is not hard, and vice versa.\n¬Several(jack) ↔ ¬Cold(cara) ::: Jack is not several if and only if Cara is not old.\n(∀x (Old(x) ∧ ¬Several(x))) → (∀x (¬Hard(x) ∧ ¬Jolly(x))) ::: As long as someone is old and not several, he is not hard and not jolly.\n(∀x (¬Hard(x) ∧ ¬Old(x))) ↔ (∀x (¬Giant(x))) ::: Someone being neither hard nor old is equivalent to being not giant.\n(∀x (Old(x) ∧ ¬Jolly(x))) ↔ (∀x (Average(x))) ::: If someone is old and not jolly, then he is average, and vice versa.\n(∀x (¬Average(x))) → (∀x (¬Old(x))) ::: If someone is not average, then he is not old.\n(∃x (Giant(x))) → ((¬Hard(max) ∧ Old(jack))) ::: If there is someone who is giant, then Max is not hard and Jack is old.\n",
            "First-Order-Logic Question": "¬Hard(noel) ::: Noel is not hard."
        },
        "fixed": true
    },
    {
        "id": 598,
        "raw_prog": {
            "First-Order-Logic Rules": "¬Hard(max) ::: Max is not hard.\n¬Average(noel) ::: Noel is not average.\n¬Jolly(roderick) ::: Roderick is not jolly.\nAverage(roderick) ::: Roderick is average.\n¬Several(cara) ::: Cara is not several.\nAverage(cara) ::: Cara is average.\nHard(keith) ::: Keith is hard.\nHard(jack) ::: Jack is hard.\nSeveral(noel) ::: Noel is several.\nGiant(jack) ::: Jack is giant.\n¬Giant(roderick) ::: Roderick is not giant.\nJolly(rose) ::: Rose is jolly.\n(∀x (¬Several(x))) → (∀x (¬Old(x) ∧ ¬Hard(x))) ::: As long as someone is not several, he is not old and not hard.\n(∃x (Hard(x) ∨ ¬Old(x))) → ((¬Average(max) ∧ Jolly(rose))) ::: If there is at least one people who is either hard or not old, then Max is not average and Rose is jolly.\n(∃x (Old(x) ∧ Hard(x))) → (Giant(noel)) ::: If there is someone who is both old and hard, then Noel is giant.\n(∃x (Old(x) ∨ ¬Jolly(x))) → (Several(rose)) ::: If there is at least one people who is old or not jolly, then Rose is several.\n(∃x (Jolly(x))) → ((Average(cara) ∧ ¬Hard(keith))) ::: If there is at least one people who is jolly, then Cara is average and Keith is not hard.\n(∀x (Old(x))) ↔ (∀x (¬Hard(x))) ::: If someone is old, then he is not hard, and vice versa.\n(Jack is not several) ↔ (Cara is not old) ::: Jack is not several if and only if Cara is not old.\n(∀x (Old(x) ∧ ¬Several(x))) → (∀x (¬Hard(x) ∧ ¬Jolly(x))) ::: As long as someone is old and not several, he is not hard and not jolly.\n(∀x (¬Hard(x) ∧ ¬Old(x))) ↔ (∀x (¬Giant(x))) ::: Someone being neither hard nor old is equivalent to being not giant.\n(∀x (Old(x) ∧ ¬Jolly(x))) ↔ (∀x (Average(x))) ::: If someone is old and not jolly, then he is average, and vice versa.\n(∀x (¬Average(x))) → (∀x (¬Old(x))) ::: If someone is not average, then he is not old.\n(∃x (Giant(x))) → ((¬Hard(max) ∧ Old(jack))) ::: If there is someone who is giant, then Max is not hard and Jack is old.\n",
            "First-Order-Logic Question": "Several(cara) ::: Cara is several."
        },
        "gram_prog": {
            "First-Order-Logic Rules": "¬Hard(max) ::: Max is not hard.\n¬Average(noel) ::: Noel is not average.\n¬Jolly(roderick) ::: Roderick is not jolly.\nAverage(roderick) ::: Roderick is average.\n¬Several(cara) ::: Cara is not several.\nAverage(cara) ::: Cara is average.\nHard(keith) ::: Keith is hard.\nHard(jack) ::: Jack is hard.\nSeveral(noel) ::: Noel is several.\nGiant(jack) ::: Jack is giant.\n¬Giant(roderick) ::: Roderick is not giant.\nJolly(rose) ::: Rose is jolly.\n(∀x (¬Several(x))) → (∀x (¬Old(x) ∧ ¬Hard(x))) ::: As long as someone is not several, he is not old and not hard.\n(∃x (Hard(x) ∨ ¬Old(x))) → ((¬Average(max) ∧ Jolly(rose))) ::: If there is at least one people who is either hard or not old, then Max is not average and Rose is jolly.\n(∃x (Old(x) ∧ Hard(x))) → (Giant(noel)) ::: If there is someone who is both old and hard, then Noel is giant.\n(∃x (Old(x) ∨ ¬Jolly(x))) → (Several(rose)) ::: If there is at least one people who is old or not jolly, then Rose is several.\n(∃x (Jolly(x))) → ((Average(cara) ∧ ¬Hard(keith))) ::: If there is at least one people who is jolly, then Cara is average and Keith is not hard.\n(∀x (Old(x))) ↔ (∀x (¬Hard(x))) ::: If someone is old, then he is not hard, and vice versa.\n¬(Concerned(x)→Serious(x)) ::: Jack is not several if and only if Cara is not old.\n(∀x (Old(x) ∧ ¬Several(x))) → (∀x (¬Hard(x) ∧ ¬Jolly(x))) ::: As long as someone is old and not several, he is not hard and not jolly.\n(∀x (¬Hard(x) ∧ ¬Old(x))) ↔ (∀x (¬Giant(x))) ::: Someone being neither hard nor old is equivalent to being not giant.\n(∀x (Old(x) ∧ ¬Jolly(x))) ↔ (∀x (Average(x))) ::: If someone is old and not jolly, then he is average, and vice versa.\n(∀x (¬Average(x))) → (∀x (¬Old(x))) ::: If someone is not average, then he is not old.\n(∃x (Giant(x))) → ((¬Hard(max) ∧ Old(jack))) ::: If there is someone who is giant, then Max is not hard and Jack is old.\n",
            "First-Order-Logic Question": "Several(cara) ::: Cara is several."
        },
        "diff": [
            {
                "raw": "(Jack is not several) ↔ (Cara is not old) ::: Jack is not several if and only if Cara is not old.",
                "gram": "¬(Concerned(x)→Serious(x)) ::: Jack is not several if and only if Cara is not old."
            }
        ],
        "answer": "B",
        "grammar_answer": "A",
        "manual_prog": {
            "First-Order-Logic Rules": "¬Hard(max) ::: Max is not hard.\n¬Average(noel) ::: Noel is not average.\n¬Jolly(roderick) ::: Roderick is not jolly.\nAverage(roderick) ::: Roderick is average.\n¬Several(cara) ::: Cara is not several.\nAverage(cara) ::: Cara is average.\nHard(keith) ::: Keith is hard.\nHard(jack) ::: Jack is hard.\nSeveral(noel) ::: Noel is several.\nGiant(jack) ::: Jack is giant.\n¬Giant(roderick) ::: Roderick is not giant.\nJolly(rose) ::: Rose is jolly.\n(∀x (¬Several(x))) → (∀x (¬Old(x) ∧ ¬Hard(x))) ::: As long as someone is not several, he is not old and not hard.\n(∃x (Hard(x) ∨ ¬Old(x))) → ((¬Average(max) ∧ Jolly(rose))) ::: If there is at least one people who is either hard or not old, then Max is not average and Rose is jolly.\n(∃x (Old(x) ∧ Hard(x))) → (Giant(noel)) ::: If there is someone who is both old and hard, then Noel is giant.\n(∃x (Old(x) ∨ ¬Jolly(x))) → (Several(rose)) ::: If there is at least one people who is old or not jolly, then Rose is several.\n(∃x (Jolly(x))) → ((Average(cara) ∧ ¬Hard(keith))) ::: If there is at least one people who is jolly, then Cara is average and Keith is not hard.\n(∀x (Old(x))) ↔ (∀x (¬Hard(x))) ::: If someone is old, then he is not hard, and vice versa.\n¬Several(jack) ↔ ¬Cold(cara) ::: Jack is not several if and only if Cara is not old.\n(∀x (Old(x) ∧ ¬Several(x))) → (∀x (¬Hard(x) ∧ ¬Jolly(x))) ::: As long as someone is old and not several, he is not hard and not jolly.\n(∀x (¬Hard(x) ∧ ¬Old(x))) ↔ (∀x (¬Giant(x))) ::: Someone being neither hard nor old is equivalent to being not giant.\n(∀x (Old(x) ∧ ¬Jolly(x))) ↔ (∀x (Average(x))) ::: If someone is old and not jolly, then he is average, and vice versa.\n(∀x (¬Average(x))) → (∀x (¬Old(x))) ::: If someone is not average, then he is not old.\n(∃x (Giant(x))) → ((¬Hard(max) ∧ Old(jack))) ::: If there is someone who is giant, then Max is not hard and Jack is old.\n",
            "First-Order-Logic Question": "Several(cara) ::: Cara is several."
        },
        "fixed": true
    },
    {
        "id": 695,
        "raw_prog": {
            "First-Order-Logic Rules": "Alert(tristin) ::: Tristin is alert.\n¬Substantial(tristin) ::: Tristin is not substantial.\n¬Alert(sandra) ::: Sandra is not alert.\nAlert(barnaby) ::: Barnaby is alert.\n¬Energetic(barnaby) ::: Barnaby is not energetic.\n¬Energetic(tristin) ::: Tristin is not energetic.\nWonderful(noel) ::: Noel is wonderful.\n¬Fair(tristin) ::: Tristin is not fair.\nFair(barnaby) ::: Barnaby is fair.\n¬Alert(noel) ::: Noel is not alert.\n¬Fancy(cara) ::: Cara is not fancy.\n¬Energetic(adler) ::: Adler is not energetic.\n(∃x (¬Substantial(x))) → ((Alert(adler) ∧ ¬Wonderful(blaine))) ::: If there is someone who is not substantial, then Adler is alert and Blaine is not wonderful.\n(Substantial(sandra)) ↔ ((¬Energetic(noel) ∧ Fancy(sandra))) ::: Sandra being substantial is equivalent to Noel being not energetic and Sandra being fancy.\n((Substantial(x) ∧ ¬Fair(x))) ↔ ((¬Energetic(x))) ::: If someone is substantial and not fair, then he is not energetic, and vice versa.\n(∃x (Wonderful(x) ∧ Energetic(x))) → ((Fair(sandra) ∧ ¬Substantial(tristin))) ::: If there is someone who is both wonderful and energetic, then Sandra is fair and Tristin is not substantial.\n(¬Fair(x)) → (Wonderful(x)) ::: If someone is not fair, then he is wonderful.\n(Fancy(cara)) → (Sandra is fancy) ::: It can be concluded that Sandra is fancy once knowing that Cara is fair.\n((¬Substantial(x) ∧ Fair(x))) → (¬Fancy(x)) ::: If someone who is not substantial is also fair, then he is not fancy.\n(∀x (Wonderful(x))) → (Substantial(x)) ::: All wonderful people are substantial.\n(¬Fair(adler)) → ((Alert(cara) ∧ ¬Wonderful(cara))) ::: Adler being not fair implies that Cara is alert and Cara is not wonderful.\n((Fancy(tristin) ∧ Wonderful(adler))) → ((¬Energetic(cara) ∧ Alert(adler))) ::: If Tristin is fancy and Adler is wonderful, then Cara is not energetic and Adler is alert.\n((Substantial(x) ∧ ¬Fair(x))) → (¬Wonderful(x)) ::: Someone who is both substantial and not fair is always not wonderful.\n(¬Fancy(x)) → (¬Alert(x)) ::: If someone is not fancy, then he is not alert.\n",
            "First-Order-Logic Question": "¬Substantial(barnaby) ::: Barnaby is not substantial."
        },
        "gram_prog": {
            "First-Order-Logic Rules": "Alert(tristin) ::: Tristin is alert.\n¬Substantial(tristin) ::: Tristin is not substantial.\n¬Alert(sandra) ::: Sandra is not alert.\nAlert(barnaby) ::: Barnaby is alert.\n¬Energetic(barnaby) ::: Barnaby is not energetic.\n¬Energetic(tristin) ::: Tristin is not energetic.\nWonderful(noel) ::: Noel is wonderful.\n¬Fair(tristin) ::: Tristin is not fair.\nFair(barnaby) ::: Barnaby is fair.\n¬Alert(noel) ::: Noel is not alert.\n¬Fancy(cara) ::: Cara is not fancy.\n¬Energetic(adler) ::: Adler is not energetic.\n(∃x (¬Substantial(x))) → ((Alert(adler) ∧ ¬Wonderful(blaine))) ::: If there is someone who is not substantial, then Adler is alert and Blaine is not wonderful.\n(Substantial(sandra)) ↔ ((¬Energetic(noel) ∧ Fancy(sandra))) ::: Sandra being substantial is equivalent to Noel being not energetic and Sandra being fancy.\n((Substantial(x) ∧ ¬Fair(x))) ↔ ((¬Energetic(x))) ::: If someone is substantial and not fair, then he is not energetic, and vice versa.\n(∃x (Wonderful(x) ∧ Energetic(x))) → ((Fair(sandra) ∧ ¬Substantial(tristin))) ::: If there is someone who is both wonderful and energetic, then Sandra is fair and Tristin is not substantial.\n(¬Fair(x)) → (Wonderful(x)) ::: If someone is not fair, then he is wonderful.\nFancy(x)→(Substantial(x)) ::: It can be concluded that Sandra is fancy once knowing that Cara is fair.\n((¬Substantial(x) ∧ Fair(x))) → (¬Fancy(x)) ::: If someone who is not substantial is also fair, then he is not fancy.\n(∀x (Wonderful(x))) → (Substantial(x)) ::: All wonderful people are substantial.\n(¬Fair(adler)) → ((Alert(cara) ∧ ¬Wonderful(cara))) ::: Adler being not fair implies that Cara is alert and Cara is not wonderful.\n((Fancy(tristin) ∧ Wonderful(adler))) → ((¬Energetic(cara) ∧ Alert(adler))) ::: If Tristin is fancy and Adler is wonderful, then Cara is not energetic and Adler is alert.\n((Substantial(x) ∧ ¬Fair(x))) → (¬Wonderful(x)) ::: Someone who is both substantial and not fair is always not wonderful.\n(¬Fancy(x)) → (¬Alert(x)) ::: If someone is not fancy, then he is not alert.\n",
            "First-Order-Logic Question": "¬Substantial(barnaby) ::: Barnaby is not substantial."
        },
        "diff": [
            {
                "raw": "(Fancy(cara)) → (Sandra is fancy) ::: It can be concluded that Sandra is fancy once knowing that Cara is fair.",
                "gram": "Fancy(x)→(Substantial(x)) ::: It can be concluded that Sandra is fancy once knowing that Cara is fair."
            }
        ],
        "answer": "B",
        "grammar_answer": "A",
        "manual_prog": {
            "First-Order-Logic Rules": "Alert(tristin) ::: Tristin is alert.\n¬Substantial(tristin) ::: Tristin is not substantial.\n¬Alert(sandra) ::: Sandra is not alert.\nAlert(barnaby) ::: Barnaby is alert.\n¬Energetic(barnaby) ::: Barnaby is not energetic.\n¬Energetic(tristin) ::: Tristin is not energetic.\nWonderful(noel) ::: Noel is wonderful.\n¬Fair(tristin) ::: Tristin is not fair.\nFair(barnaby) ::: Barnaby is fair.\n¬Alert(noel) ::: Noel is not alert.\n¬Fancy(cara) ::: Cara is not fancy.\n¬Energetic(adler) ::: Adler is not energetic.\n(∃x (¬Substantial(x))) → ((Alert(adler) ∧ ¬Wonderful(blaine))) ::: If there is someone who is not substantial, then Adler is alert and Blaine is not wonderful.\n(Substantial(sandra)) ↔ ((¬Energetic(noel) ∧ Fancy(sandra))) ::: Sandra being substantial is equivalent to Noel being not energetic and Sandra being fancy.\n((Substantial(x) ∧ ¬Fair(x))) ↔ ((¬Energetic(x))) ::: If someone is substantial and not fair, then he is not energetic, and vice versa.\n(∃x (Wonderful(x) ∧ Energetic(x))) → ((Fair(sandra) ∧ ¬Substantial(tristin))) ::: If there is someone who is both wonderful and energetic, then Sandra is fair and Tristin is not substantial.\n(¬Fair(x)) → (Wonderful(x)) ::: If someone is not fair, then he is wonderful.\n(Fancy(cara)) → (Fancy(sandra)) ::: It can be concluded that Sandra is fancy once knowing that Cara is fair.\n((¬Substantial(x) ∧ Fair(x))) → (¬Fancy(x)) ::: If someone who is not substantial is also fair, then he is not fancy.\n(∀x (Wonderful(x))) → (Substantial(x)) ::: All wonderful people are substantial.\n(¬Fair(adler)) → ((Alert(cara) ∧ ¬Wonderful(cara))) ::: Adler being not fair implies that Cara is alert and Cara is not wonderful.\n((Fancy(tristin) ∧ Wonderful(adler))) → ((¬Energetic(cara) ∧ Alert(adler))) ::: If Tristin is fancy and Adler is wonderful, then Cara is not energetic and Adler is alert.\n((Substantial(x) ∧ ¬Fair(x))) → (¬Wonderful(x)) ::: Someone who is both substantial and not fair is always not wonderful.\n(¬Fancy(x)) → (¬Alert(x)) ::: If someone is not fancy, then he is not alert.\n",
            "First-Order-Logic Question": "¬Substantial(barnaby) ::: Barnaby is not substantial."
        },
        "fixed": true
    },
    {
        "id": 735,
        "raw_prog": {
            "First-Order-Logic Rules": "¬Energetic(lesley) ::: Lesley is not energetic.\nCrowded(lesley) ::: Lesley is crowded.\nFaithful(max) ::: Max is faithful.\n¬Faithful(dan) ::: Dan is not faithful.\n¬Energetic(clarence) ::: Clarence is not energetic.\nWonderful(cara) ::: Cara is wonderful.\nAngry(clarence) ::: Clarence is angry.\nLong(max) ::: Max is long.\n¬Angry(christina) ::: Christina is not angry.\nEnergetic(cara) ::: Cara is energetic.\nLong(cara) ::: Cara is long.\n¬Long(christina) ::: Christina is not long.\n((∃x (¬Long(x)))) → (Wonderful(christina)) ::: If there is someone who is not long, then Christina is wonderful.\n((Crowded(x) ∧ ¬Angry(x))) → (¬Long(x)) ::: If someone is both crowded and not angry, then he is not long.\n((∃x (Long(x)))) → ((¬Crowded(max) ∧ ¬Angry(cara))) ::: If there is someone who is long, then Max is not crowded and Cara is not angry.\n((¬Faithful(lesley))) ↔ ((Energetic(dan) ∧ ¬Crowded(lesley))) ::: Lesley being not faithful is equivalent to Dan being energetic and Lesley being not crowded.\n((∃x (Wonderful(x)))) → (¬Energetic(dan)) ::: If there is someone who is wonderful, then Dan is not energetic.\n((¬Wonderful(lesley) ∨ Angry(clarence))) → (¬Long(dan)) ::: Lesley being not wonderful or Clarence being angry implies that Dan is not long.\n(∀x ((Faithful(x) ∨ ¬Wonderful(x))) → (¬Long(x))) ::: If someone is faithful or not wonderful, then he is not long.\n((Angry(x) ∧ Faithful(x))) → (Energetic(x)) ::: If someone who is angry is also faithful, then he is energetic.\n((¬Crowded(christina))) → (Energetic(christina)) ::: Christina being not crowded implies that Christina is energetic.\n((¬Long(x))) → (Energetic(x) ∧ ¬Wonderful(x)) ::: If someone is not long, then he is both energetic and not wonderful.\n(∀x ((¬Energetic(x) ∧ ¬Wonderful(x))) ↔ (Long(x)) ::: Someone being neither energetic nor wonderful is equivalent to being long.\n(∀x ((Long(x) ∧ ¬Crowded(x))) ↔ (¬Faithful(x) ∧ ¬Angry(x))) ::: Someone being both long and not crowded is equivalent to being not faithful and not angry.\n",
            "First-Order-Logic Question": "Angry(cara) ::: Cara is angry."
        },
        "gram_prog": {
            "First-Order-Logic Rules": "¬Energetic(lesley) ::: Lesley is not energetic.\nCrowded(lesley) ::: Lesley is crowded.\nFaithful(max) ::: Max is faithful.\n¬Faithful(dan) ::: Dan is not faithful.\n¬Energetic(clarence) ::: Clarence is not energetic.\nWonderful(cara) ::: Cara is wonderful.\nAngry(clarence) ::: Clarence is angry.\nLong(max) ::: Max is long.\n¬Angry(christina) ::: Christina is not angry.\nEnergetic(cara) ::: Cara is energetic.\nLong(cara) ::: Cara is long.\n¬Long(christina) ::: Christina is not long.\n((∃x (¬Long(x)))) → (Wonderful(christina)) ::: If there is someone who is not long, then Christina is wonderful.\n((Crowded(x) ∧ ¬Angry(x))) → (¬Long(x)) ::: If someone is both crowded and not angry, then he is not long.\n((∃x (Long(x)))) → ((¬Crowded(max) ∧ ¬Angry(cara))) ::: If there is someone who is long, then Max is not crowded and Cara is not angry.\n((¬Faithful(lesley))) ↔ ((Energetic(dan) ∧ ¬Crowded(lesley))) ::: Lesley being not faithful is equivalent to Dan being energetic and Lesley being not crowded.\n((∃x (Wonderful(x)))) → (¬Energetic(dan)) ::: If there is someone who is wonderful, then Dan is not energetic.\n((¬Wonderful(lesley) ∨ Angry(clarence))) → (¬Long(dan)) ::: Lesley being not wonderful or Clarence being angry implies that Dan is not long.\n(∀x ((Faithful(x) ∨ ¬Wonderful(x))) → (¬Long(x))) ::: If someone is faithful or not wonderful, then he is not long.\n((Angry(x) ∧ Faithful(x))) → (Energetic(x)) ::: If someone who is angry is also faithful, then he is energetic.\n((¬Crowded(christina))) → (Energetic(christina)) ::: Christina being not crowded implies that Christina is energetic.\n((¬Long(x))) → (Energetic(x) ∧ ¬Wonderful(x)) ::: If someone is not long, then he is both energetic and not wonderful.\n¬Entire(x)→(Serious(x)∨Fresh(x)) ::: Someone being neither energetic nor wonderful is equivalent to being long.\n(∀x ((Long(x) ∧ ¬Crowded(x))) ↔ (¬Faithful(x) ∧ ¬Angry(x))) ::: Someone being both long and not crowded is equivalent to being not faithful and not angry.\n",
            "First-Order-Logic Question": "Angry(cara) ::: Cara is angry."
        },
        "diff": [
            {
                "raw": "(∀x ((¬Energetic(x) ∧ ¬Wonderful(x))) ↔ (Long(x)) ::: Someone being neither energetic nor wonderful is equivalent to being long.",
                "gram": "¬Entire(x)→(Serious(x)∨Fresh(x)) ::: Someone being neither energetic nor wonderful is equivalent to being long."
            }
        ],
        "answer": "B",
        "grammar_answer": "A",
        "manual_prog": {
            "First-Order-Logic Rules": "¬Energetic(lesley) ::: Lesley is not energetic.\nCrowded(lesley) ::: Lesley is crowded.\nFaithful(max) ::: Max is faithful.\n¬Faithful(dan) ::: Dan is not faithful.\n¬Energetic(clarence) ::: Clarence is not energetic.\nWonderful(cara) ::: Cara is wonderful.\nAngry(clarence) ::: Clarence is angry.\nLong(max) ::: Max is long.\n¬Angry(christina) ::: Christina is not angry.\nEnergetic(cara) ::: Cara is energetic.\nLong(cara) ::: Cara is long.\n¬Long(christina) ::: Christina is not long.\n((∃x (¬Long(x)))) → (Wonderful(christina)) ::: If there is someone who is not long, then Christina is wonderful.\n((Crowded(x) ∧ ¬Angry(x))) → (¬Long(x)) ::: If someone is both crowded and not angry, then he is not long.\n((∃x (Long(x)))) → ((¬Crowded(max) ∧ ¬Angry(cara))) ::: If there is someone who is long, then Max is not crowded and Cara is not angry.\n((¬Faithful(lesley))) ↔ ((Energetic(dan) ∧ ¬Crowded(lesley))) ::: Lesley being not faithful is equivalent to Dan being energetic and Lesley being not crowded.\n((∃x (Wonderful(x)))) → (¬Energetic(dan)) ::: If there is someone who is wonderful, then Dan is not energetic.\n((¬Wonderful(lesley) ∨ Angry(clarence))) → (¬Long(dan)) ::: Lesley being not wonderful or Clarence being angry implies that Dan is not long.\n(∀x ((Faithful(x) ∨ ¬Wonderful(x))) → (¬Long(x))) ::: If someone is faithful or not wonderful, then he is not long.\n((Angry(x) ∧ Faithful(x))) → (Energetic(x)) ::: If someone who is angry is also faithful, then he is energetic.\n((¬Crowded(christina))) → (Energetic(christina)) ::: Christina being not crowded implies that Christina is energetic.\n((¬Long(x))) → (Energetic(x) ∧ ¬Wonderful(x)) ::: If someone is not long, then he is both energetic and not wonderful.\n(∀x ((¬Energetic(x) ∧ ¬Wonderful(x))) ↔ (Long(x))) ::: Someone being neither energetic nor wonderful is equivalent to being long.\n(∀x ((Long(x) ∧ ¬Crowded(x))) ↔ (¬Faithful(x) ∧ ¬Angry(x))) ::: Someone being both long and not crowded is equivalent to being not faithful and not angry.\n",
            "First-Order-Logic Question": "Angry(cara) ::: Cara is angry."
        },
        "fixed": true
    },
    {
        "id": 803,
        "raw_prog": {
            "First-Order-Logic Rules": "¬Zany(dan) ::: Dan is not zany.\n¬Sour(kenyon) ::: Kenyon is not sour.\nAggressive(terry) ::: Terry is aggressive.\nZany(lesley) ::: Lesley is zany.\nAggressive(kenyon) ::: Kenyon is aggressive.\n¬Comfortable(melvin) ::: Melvin is not comfortable.\nHappy(melvin) ::: Melvin is happy.\nHappy(kenyon) ::: Kenyon is happy.\nComfortable(dan) ::: Dan is comfortable.\nZany(christopher) ::: Christopher is zany.\n¬Sour(terry) ::: Terry is not sour.\n¬Comfortable(christopher) ::: Christopher is not comfortable.\n((Bad(terry))) → ((Zany(melvin))) ::: If Terry is bad, then Melvin is zany.\n(∀x (¬Bad(x) ∨ ¬Aggressive(x))) → (∀x (Sour(x))) ::: If someone is not bad or not aggressive, then he is sour.\n((Aggressive(melvin) ∨ ¬Bad(melvin))) → ((¬Comfortable(terry))) ::: If Melvin is aggressive or Melvin is not bad, then Terry is not comfortable.\n(∀x (Aggressive(x))) ↔ (∀x (Zany(x))) ::: If someone is aggressive, then he is zany, and vice versa.\n((Comfortable(melvin) ∧ ¬Bad(melvin))) → ((Aggressive(graciela))) ::: If Melvin is comfortable and Melvin is not bad, then Graciela is aggressive.\n(Aggressive(lesley)) ↔ ((¬Happy(christopher) ∧ ¬Comfortable(kenyon))) ::: Lesley is aggressive if and only if Christopher is not happy and Kenyon is not comfortable.\n(∀x ((¬Bad(x) ∨ Happy(x))) → (¬Aggressive(x))) ::: If someone is he or not bad is happy, then he is not aggressive.\n(∃x ((¬Comfortable(x) ∧ ¬Happy(x))) → ((¬Aggressive(terry) ∧ Sour(terry))) ::: If there is someone who is neither comfortable nor happy, then Terry is not aggressive and Terry is sour.\n(∀x ((¬Zany(x) ∨ Happy(x))) → (¬Comfortable(x))) ::: If someone is he or not zany is happy, then he is not comfortable.\n(∀x ((Sour(x) ∧ ¬Comfortable(x))) ↔ (Zany(x))) ::: If someone is sour and not comfortable, then he is zany, and vice versa.\n((Comfortable(x) ∧ ¬Aggressive(x))) → ((Sour(x) ∧ ¬Bad(x))) ::: Someone who is comfortable and not aggressive is always sour and not bad.\n(∃x (¬Happy(x))) → ((¬Bad(melvin))) ::: If there is at least one people who is not happy, then Melvin is not bad.\n",
            "First-Order-Logic Question": "¬Bad(lesley) ::: Lesley is not bad."
        },
        "gram_prog": {
            "First-Order-Logic Rules": "¬Zany(dan) ::: Dan is not zany.\n¬Sour(kenyon) ::: Kenyon is not sour.\nAggressive(terry) ::: Terry is aggressive.\nZany(lesley) ::: Lesley is zany.\nAggressive(kenyon) ::: Kenyon is aggressive.\n¬Comfortable(melvin) ::: Melvin is not comfortable.\nHappy(melvin) ::: Melvin is happy.\nHappy(kenyon) ::: Kenyon is happy.\nComfortable(dan) ::: Dan is comfortable.\nZany(christopher) ::: Christopher is zany.\n¬Sour(terry) ::: Terry is not sour.\n¬Comfortable(christopher) ::: Christopher is not comfortable.\n((Bad(terry))) → ((Zany(melvin))) ::: If Terry is bad, then Melvin is zany.\n(∀x (¬Bad(x) ∨ ¬Aggressive(x))) → (∀x (Sour(x))) ::: If someone is not bad or not aggressive, then he is sour.\n((Aggressive(melvin) ∨ ¬Bad(melvin))) → ((¬Comfortable(terry))) ::: If Melvin is aggressive or Melvin is not bad, then Terry is not comfortable.\n(∀x (Aggressive(x))) ↔ (∀x (Zany(x))) ::: If someone is aggressive, then he is zany, and vice versa.\n((Comfortable(melvin) ∧ ¬Bad(melvin))) → ((Aggressive(graciela))) ::: If Melvin is comfortable and Melvin is not bad, then Graciela is aggressive.\n(Aggressive(lesley)) ↔ ((¬Happy(christopher) ∧ ¬Comfortable(kenyon))) ::: Lesley is aggressive if and only if Christopher is not happy and Kenyon is not comfortable.\n(∀x ((¬Bad(x) ∨ Happy(x))) → (¬Aggressive(x))) ::: If someone is he or not bad is happy, then he is not aggressive.\n¬Comfortable(x)∧¬Happy(x)→¬Aggressive(x)∧Sour(x) ::: If there is someone who is neither comfortable nor happy, then Terry is not aggressive and Terry is sour.\n(∀x ((¬Zany(x) ∨ Happy(x))) → (¬Comfortable(x))) ::: If someone is he or not zany is happy, then he is not comfortable.\n(∀x ((Sour(x) ∧ ¬Comfortable(x))) ↔ (Zany(x))) ::: If someone is sour and not comfortable, then he is zany, and vice versa.\n((Comfortable(x) ∧ ¬Aggressive(x))) → ((Sour(x) ∧ ¬Bad(x))) ::: Someone who is comfortable and not aggressive is always sour and not bad.\n(∃x (¬Happy(x))) → ((¬Bad(melvin))) ::: If there is at least one people who is not happy, then Melvin is not bad.\n",
            "First-Order-Logic Question": "¬Bad(lesley) ::: Lesley is not bad."
        },
        "diff": [
            {
                "raw": "(∃x ((¬Comfortable(x) ∧ ¬Happy(x))) → ((¬Aggressive(terry) ∧ Sour(terry))) ::: If there is someone who is neither comfortable nor happy, then Terry is not aggressive and Terry is sour.",
                "gram": "¬Comfortable(x)∧¬Happy(x)→¬Aggressive(x)∧Sour(x) ::: If there is someone who is neither comfortable nor happy, then Terry is not aggressive and Terry is sour."
            }
        ],
        "answer": "C",
        "grammar_answer": "A",
        "manual_prog": {
            "First-Order-Logic Rules": "¬Zany(dan) ::: Dan is not zany.\n¬Sour(kenyon) ::: Kenyon is not sour.\nAggressive(terry) ::: Terry is aggressive.\nZany(lesley) ::: Lesley is zany.\nAggressive(kenyon) ::: Kenyon is aggressive.\n¬Comfortable(melvin) ::: Melvin is not comfortable.\nHappy(melvin) ::: Melvin is happy.\nHappy(kenyon) ::: Kenyon is happy.\nComfortable(dan) ::: Dan is comfortable.\nZany(christopher) ::: Christopher is zany.\n¬Sour(terry) ::: Terry is not sour.\n¬Comfortable(christopher) ::: Christopher is not comfortable.\n((Bad(terry))) → ((Zany(melvin))) ::: If Terry is bad, then Melvin is zany.\n(∀x (¬Bad(x) ∨ ¬Aggressive(x))) → (∀x (Sour(x))) ::: If someone is not bad or not aggressive, then he is sour.\n((Aggressive(melvin) ∨ ¬Bad(melvin))) → ((¬Comfortable(terry))) ::: If Melvin is aggressive or Melvin is not bad, then Terry is not comfortable.\n(∀x (Aggressive(x))) ↔ (∀x (Zany(x))) ::: If someone is aggressive, then he is zany, and vice versa.\n((Comfortable(melvin) ∧ ¬Bad(melvin))) → ((Aggressive(graciela))) ::: If Melvin is comfortable and Melvin is not bad, then Graciela is aggressive.\n(Aggressive(lesley)) ↔ ((¬Happy(christopher) ∧ ¬Comfortable(kenyon))) ::: Lesley is aggressive if and only if Christopher is not happy and Kenyon is not comfortable.\n(∀x ((¬Bad(x) ∨ Happy(x))) → (¬Aggressive(x))) ::: If someone is he or not bad is happy, then he is not aggressive.\n(∃x ((¬Comfortable(x) ∧ ¬Happy(x))) → ((¬Aggressive(terry) ∧ Sour(terry)))) ::: If there is someone who is neither comfortable nor happy, then Terry is not aggressive and Terry is sour.\n(∀x ((¬Zany(x) ∨ Happy(x))) → (¬Comfortable(x))) ::: If someone is he or not zany is happy, then he is not comfortable.\n(∀x ((Sour(x) ∧ ¬Comfortable(x))) ↔ (Zany(x))) ::: If someone is sour and not comfortable, then he is zany, and vice versa.\n((Comfortable(x) ∧ ¬Aggressive(x))) → ((Sour(x) ∧ ¬Bad(x))) ::: Someone who is comfortable and not aggressive is always sour and not bad.\n(∃x (¬Happy(x))) → ((¬Bad(melvin))) ::: If there is at least one people who is not happy, then Melvin is not bad.\n",
            "First-Order-Logic Question": "¬Bad(lesley) ::: Lesley is not bad."
        },
        "fixed": true
    },
    {
        "id": 808,
        "raw_prog": {
            "First-Order-Logic Rules": "¬Zany(dan) ::: Dan is not zany.\n¬Sour(kenyon) ::: Kenyon is not sour.\nAggressive(terry) ::: Terry is aggressive.\nZany(lesley) ::: Lesley is zany.\nAggressive(kenyon) ::: Kenyon is aggressive.\n¬Comfortable(melvin) ::: Melvin is not comfortable.\nHappy(melvin) ::: Melvin is happy.\nHappy(kenyon) ::: Kenyon is happy.\nComfortable(dan) ::: Dan is comfortable.\nZany(christopher) ::: Christopher is zany.\n¬Sour(terry) ::: Terry is not sour.\n¬Comfortable(christopher) ::: Christopher is not comfortable.\n((Bad(terry))) → ((Zany(melvin))) ::: If Terry is bad, then Melvin is zany.\n(∀x (¬Bad(x) ∨ ¬Aggressive(x))) → (∀x (Sour(x))) ::: If someone is not bad or not aggressive, then he is sour.\n((Aggressive(melvin) ∨ ¬Bad(melvin))) → ((¬Comfortable(terry))) ::: If Melvin is aggressive or Melvin is not bad, then Terry is not comfortable.\n(∀x (Aggressive(x))) ↔ (∀x (Zany(x))) ::: If someone is aggressive, then he is zany, and vice versa.\n((Comfortable(melvin) ∧ ¬Bad(melvin))) → ((Aggressive(graciela))) ::: If Melvin is comfortable and Melvin is not bad, then Graciela is aggressive.\n(Aggressive(lesley)) ↔ ((¬Happy(christopher) ∧ ¬Comfortable(kenyon))) ::: Lesley is aggressive if and only if Christopher is not happy and Kenyon is not comfortable.\n(∀x ((¬Bad(x) ∨ Happy(x))) → (¬Aggressive(x))) ::: If someone is he or not bad is happy, then he is not aggressive.\n(∃x ((¬Comfortable(x) ∧ ¬Happy(x))) → ((¬Aggressive(terry) ∧ Sour(terry))) ::: If there is someone who is neither comfortable nor happy, then Terry is not aggressive and Terry is sour.\n(∀x ((¬Zany(x) ∨ Happy(x))) → (¬Comfortable(x))) ::: If someone is he or not zany is happy, then he is not comfortable.\n(∀x ((Sour(x) ∧ ¬Comfortable(x))) ↔ (Zany(x))) ::: If someone is sour and not comfortable, then he is zany, and vice versa.\n(∀x ((Comfortable(x) ∧ ¬Aggressive(x))) ↔ (Sour(x) ∧ ¬Bad(x))) ::: Someone who is comfortable and not aggressive is always sour and not bad.\n(∃x (¬Happy(x))) → (¬Bad(melvin)) ::: If there is at least one people who is not happy, then Melvin is not bad.\n",
            "First-Order-Logic Question": "¬Bad(terry) ::: Terry is not bad."
        },
        "gram_prog": {
            "First-Order-Logic Rules": "¬Zany(dan) ::: Dan is not zany.\n¬Sour(kenyon) ::: Kenyon is not sour.\nAggressive(terry) ::: Terry is aggressive.\nZany(lesley) ::: Lesley is zany.\nAggressive(kenyon) ::: Kenyon is aggressive.\n¬Comfortable(melvin) ::: Melvin is not comfortable.\nHappy(melvin) ::: Melvin is happy.\nHappy(kenyon) ::: Kenyon is happy.\nComfortable(dan) ::: Dan is comfortable.\nZany(christopher) ::: Christopher is zany.\n¬Sour(terry) ::: Terry is not sour.\n¬Comfortable(christopher) ::: Christopher is not comfortable.\n((Bad(terry))) → ((Zany(melvin))) ::: If Terry is bad, then Melvin is zany.\n(∀x (¬Bad(x) ∨ ¬Aggressive(x))) → (∀x (Sour(x))) ::: If someone is not bad or not aggressive, then he is sour.\n((Aggressive(melvin) ∨ ¬Bad(melvin))) → ((¬Comfortable(terry))) ::: If Melvin is aggressive or Melvin is not bad, then Terry is not comfortable.\n(∀x (Aggressive(x))) ↔ (∀x (Zany(x))) ::: If someone is aggressive, then he is zany, and vice versa.\n((Comfortable(melvin) ∧ ¬Bad(melvin))) → ((Aggressive(graciela))) ::: If Melvin is comfortable and Melvin is not bad, then Graciela is aggressive.\n(Aggressive(lesley)) ↔ ((¬Happy(christopher) ∧ ¬Comfortable(kenyon))) ::: Lesley is aggressive if and only if Christopher is not happy and Kenyon is not comfortable.\n(∀x ((¬Bad(x) ∨ Happy(x))) → (¬Aggressive(x))) ::: If someone is he or not bad is happy, then he is not aggressive.\n¬Comfortable(x)∧¬Happy(x)→¬Aggressive(x)∧Sour(x) ::: If there is someone who is neither comfortable nor happy, then Terry is not aggressive and Terry is sour.\n(∀x ((¬Zany(x) ∨ Happy(x))) → (¬Comfortable(x))) ::: If someone is he or not zany is happy, then he is not comfortable.\n(∀x ((Sour(x) ∧ ¬Comfortable(x))) ↔ (Zany(x))) ::: If someone is sour and not comfortable, then he is zany, and vice versa.\n(∀x ((Comfortable(x) ∧ ¬Aggressive(x))) ↔ (Sour(x) ∧ ¬Bad(x))) ::: Someone who is comfortable and not aggressive is always sour and not bad.\n(∃x (¬Happy(x))) → (¬Bad(melvin)) ::: If there is at least one people who is not happy, then Melvin is not bad.\n",
            "First-Order-Logic Question": "¬Bad(terry) ::: Terry is not bad."
        },
        "diff": [
            {
                "raw": "(∃x ((¬Comfortable(x) ∧ ¬Happy(x))) → ((¬Aggressive(terry) ∧ Sour(terry))) ::: If there is someone who is neither comfortable nor happy, then Terry is not aggressive and Terry is sour.",
                "gram": "¬Comfortable(x)∧¬Happy(x)→¬Aggressive(x)∧Sour(x) ::: If there is someone who is neither comfortable nor happy, then Terry is not aggressive and Terry is sour."
            }
        ],
        "answer": "C",
        "grammar_answer": "A",
        "manual_prog": {
            "First-Order-Logic Rules": "¬Zany(dan) ::: Dan is not zany.\n¬Sour(kenyon) ::: Kenyon is not sour.\nAggressive(terry) ::: Terry is aggressive.\nZany(lesley) ::: Lesley is zany.\nAggressive(kenyon) ::: Kenyon is aggressive.\n¬Comfortable(melvin) ::: Melvin is not comfortable.\nHappy(melvin) ::: Melvin is happy.\nHappy(kenyon) ::: Kenyon is happy.\nComfortable(dan) ::: Dan is comfortable.\nZany(christopher) ::: Christopher is zany.\n¬Sour(terry) ::: Terry is not sour.\n¬Comfortable(christopher) ::: Christopher is not comfortable.\n((Bad(terry))) → ((Zany(melvin))) ::: If Terry is bad, then Melvin is zany.\n(∀x (¬Bad(x) ∨ ¬Aggressive(x))) → (∀x (Sour(x))) ::: If someone is not bad or not aggressive, then he is sour.\n((Aggressive(melvin) ∨ ¬Bad(melvin))) → ((¬Comfortable(terry))) ::: If Melvin is aggressive or Melvin is not bad, then Terry is not comfortable.\n(∀x (Aggressive(x))) ↔ (∀x (Zany(x))) ::: If someone is aggressive, then he is zany, and vice versa.\n((Comfortable(melvin) ∧ ¬Bad(melvin))) → ((Aggressive(graciela))) ::: If Melvin is comfortable and Melvin is not bad, then Graciela is aggressive.\n(Aggressive(lesley)) ↔ ((¬Happy(christopher) ∧ ¬Comfortable(kenyon))) ::: Lesley is aggressive if and only if Christopher is not happy and Kenyon is not comfortable.\n(∀x ((¬Bad(x) ∨ Happy(x))) → (¬Aggressive(x))) ::: If someone is he or not bad is happy, then he is not aggressive.\n(∃x ((¬Comfortable(x) ∧ ¬Happy(x))) → ((¬Aggressive(terry) ∧ Sour(terry)))) ::: If there is someone who is neither comfortable nor happy, then Terry is not aggressive and Terry is sour.\n(∀x ((¬Zany(x) ∨ Happy(x))) → (¬Comfortable(x))) ::: If someone is he or not zany is happy, then he is not comfortable.\n(∀x ((Sour(x) ∧ ¬Comfortable(x))) ↔ (Zany(x))) ::: If someone is sour and not comfortable, then he is zany, and vice versa.\n(∀x ((Comfortable(x) ∧ ¬Aggressive(x))) ↔ (Sour(x) ∧ ¬Bad(x))) ::: Someone who is comfortable and not aggressive is always sour and not bad.\n(∃x (¬Happy(x))) → (¬Bad(melvin)) ::: If there is at least one people who is not happy, then Melvin is not bad.\n",
            "First-Order-Logic Question": "¬Bad(terry) ::: Terry is not bad."
        },
        "fixed": true
    },
    {
        "id": 1033,
        "raw_prog": {
            "First-Order-Logic Rules": "Fat(tristan) ::: Tristan is fat.\n¬Straightforward(tristan) ::: Tristan is not straightforward.\n¬Hard(tristan) ::: Tristan is not hard.\n¬Hard(halsey) ::: Halsey is not hard.\nStraightforward(lewis) ::: Lewis is straightforward.\n¬Fat(noel) ::: Noel is not fat.\n¬Shiny(tristan) ::: Tristan is not shiny.\n¬Dry(lewis) ::: Lewis is not dry.\nZany(tristan) ::: Tristan is zany.\nDry(noel) ::: Noel is dry.\nShiny(noel) ::: Noel is shiny.\nShiny(lewis) ::: Lewis is shiny.\n(∀x ((¬Straightforward(x)) ∨ (¬Fat(x)))) → (Shiny(noel)) ::: If all people are not straightforward or not fat, then Noel is shiny.\n(∀x (Hard(x))) ↔ (Straightforward(x)) ::: Someone being hard is equivalent to being straightforward.\n(∀x ((Fat(x) ∧ ¬Dry(x))) ↔ (Shiny(x)) ::: Someone being both fat and not dry is equivalent to being shiny.\n(∀x (¬Dry(x))) ↔ (Hard(x)) ::: Someone is not dry if and only if he is hard.\n(∃x ((Dry(x)) ∧ (Hard(x)))) → (Fat(lewis)) ::: If there is someone who is both dry and hard, then Lewis is fat.\n(∃x ((¬Straightforward(x)) ∨ (¬Shiny(x)))) → (Fat(tristan)) ::: If there is at least one people who is not straightforward or not shiny, then Tristan is fat.\n(∀x ((Hard(x)) ∨ (Straightforward(x))) → (¬Zany(x))) ::: If someone is hard or he is straightforward, then he is not zany.\n(¬Dry(miles)) ↔ (¬Straightforward(lewis)) ::: Miles is not dry if and only if Lewis is not straightforward.\n(¬Zany(tristan)) ↔ (¬Dry(lewis)) ::: If Tristan is not zany, then Lewis is not dry, and vice versa.\n(∀x ((Zany(x) ∧ (¬Shiny(x)))) → (Fat(x))) ::: If someone is both zany and not shiny, then he is fat.\n(∀x ((Fat(x) ∧ (¬Shiny(x)))) → ((¬Straightforward(x)) ∧ (¬Dry(x))) ::: Someone who is fat and not shiny is always not straightforward and not dry.\n(¬Hard(miles)) ↔ (Dry(miles)) ::: Miles being not hard is equivalent to Miles being dry.\n",
            "First-Order-Logic Question": "Fat(miles) ::: Miles is fat."
        },
        "gram_prog": {
            "First-Order-Logic Rules": "Fat(tristan) ::: Tristan is fat.\n¬Straightforward(tristan) ::: Tristan is not straightforward.\n¬Hard(tristan) ::: Tristan is not hard.\n¬Hard(halsey) ::: Halsey is not hard.\nStraightforward(lewis) ::: Lewis is straightforward.\n¬Fat(noel) ::: Noel is not fat.\n¬Shiny(tristan) ::: Tristan is not shiny.\n¬Dry(lewis) ::: Lewis is not dry.\nZany(tristan) ::: Tristan is zany.\nDry(noel) ::: Noel is dry.\nShiny(noel) ::: Noel is shiny.\nShiny(lewis) ::: Lewis is shiny.\n(∀x ((¬Straightforward(x)) ∨ (¬Fat(x)))) → (Shiny(noel)) ::: If all people are not straightforward or not fat, then Noel is shiny.\n(∀x (Hard(x))) ↔ (Straightforward(x)) ::: Someone being hard is equivalent to being straightforward.\n∀x((Fat(x)∧¬Dry(x))) ::: Someone being both fat and not dry is equivalent to being shiny.\n(∀x (¬Dry(x))) ↔ (Hard(x)) ::: Someone is not dry if and only if he is hard.\n(∃x ((Dry(x)) ∧ (Hard(x)))) → (Fat(lewis)) ::: If there is someone who is both dry and hard, then Lewis is fat.\n(∃x ((¬Straightforward(x)) ∨ (¬Shiny(x)))) → (Fat(tristan)) ::: If there is at least one people who is not straightforward or not shiny, then Tristan is fat.\n(∀x ((Hard(x)) ∨ (Straightforward(x))) → (¬Zany(x))) ::: If someone is hard or he is straightforward, then he is not zany.\n(¬Dry(miles)) ↔ (¬Straightforward(lewis)) ::: Miles is not dry if and only if Lewis is not straightforward.\n(¬Zany(tristan)) ↔ (¬Dry(lewis)) ::: If Tristan is not zany, then Lewis is not dry, and vice versa.\n(∀x ((Zany(x) ∧ (¬Shiny(x)))) → (Fat(x))) ::: If someone is both zany and not shiny, then he is fat.\n∀x((Fat(x)∧¬Shiny(x))) ::: Someone who is fat and not shiny is always not straightforward and not dry.\n(¬Hard(miles)) ↔ (Dry(miles)) ::: Miles being not hard is equivalent to Miles being dry.\n",
            "First-Order-Logic Question": "Fat(miles) ::: Miles is fat."
        },
        "diff": [
            {
                "raw": "(∀x ((Fat(x) ∧ ¬Dry(x))) ↔ (Shiny(x)) ::: Someone being both fat and not dry is equivalent to being shiny.",
                "gram": "∀x((Fat(x)∧¬Dry(x))) ::: Someone being both fat and not dry is equivalent to being shiny."
            },
            {
                "raw": "(∀x ((Fat(x) ∧ (¬Shiny(x)))) → ((¬Straightforward(x)) ∧ (¬Dry(x))) ::: Someone who is fat and not shiny is always not straightforward and not dry.",
                "gram": "∀x((Fat(x)∧¬Shiny(x))) ::: Someone who is fat and not shiny is always not straightforward and not dry."
            }
        ],
        "answer": "C",
        "grammar_answer": "A",
        "manual_prog": {
            "First-Order-Logic Rules": "Fat(tristan) ::: Tristan is fat.\n¬Straightforward(tristan) ::: Tristan is not straightforward.\n¬Hard(tristan) ::: Tristan is not hard.\n¬Hard(halsey) ::: Halsey is not hard.\nStraightforward(lewis) ::: Lewis is straightforward.\n¬Fat(noel) ::: Noel is not fat.\n¬Shiny(tristan) ::: Tristan is not shiny.\n¬Dry(lewis) ::: Lewis is not dry.\nZany(tristan) ::: Tristan is zany.\nDry(noel) ::: Noel is dry.\nShiny(noel) ::: Noel is shiny.\nShiny(lewis) ::: Lewis is shiny.\n(∀x ((¬Straightforward(x)) ∨ (¬Fat(x)))) → (Shiny(noel)) ::: If all people are not straightforward or not fat, then Noel is shiny.\n(∀x (Hard(x))) ↔ (Straightforward(x)) ::: Someone being hard is equivalent to being straightforward.\n(∀x ((Fat(x) ∧ ¬Dry(x))) ↔ (Shiny(x))) ::: Someone being both fat and not dry is equivalent to being shiny.\n(∀x (¬Dry(x))) ↔ (Hard(x)) ::: Someone is not dry if and only if he is hard.\n(∃x ((Dry(x)) ∧ (Hard(x)))) → (Fat(lewis)) ::: If there is someone who is both dry and hard, then Lewis is fat.\n(∃x ((¬Straightforward(x)) ∨ (¬Shiny(x)))) → (Fat(tristan)) ::: If there is at least one people who is not straightforward or not shiny, then Tristan is fat.\n(∀x ((Hard(x)) ∨ (Straightforward(x))) → (¬Zany(x))) ::: If someone is hard or he is straightforward, then he is not zany.\n(¬Dry(miles)) ↔ (¬Straightforward(lewis)) ::: Miles is not dry if and only if Lewis is not straightforward.\n(¬Zany(tristan)) ↔ (¬Dry(lewis)) ::: If Tristan is not zany, then Lewis is not dry, and vice versa.\n(∀x ((Zany(x) ∧ (¬Shiny(x)))) → (Fat(x))) ::: If someone is both zany and not shiny, then he is fat.\n(∀x ((Fat(x) ∧ (¬Shiny(x)))) → ((¬Straightforward(x)) ∧ (¬Dry(x)))) ::: Someone who is fat and not shiny is always not straightforward and not dry.\n(¬Hard(miles)) ↔ (Dry(miles)) ::: Miles being not hard is equivalent to Miles being dry.\n",
            "First-Order-Logic Question": "Fat(miles) ::: Miles is fat."
        },
        "fixed": true
    },
    {
        "id": 1091,
        "raw_prog": {
            "First-Order-Logic Rules": "¬Crowded(howard) ::: Howard is not crowded.\nPutrid(tyra) ::: Tyra is putrid.\n¬Bewildered(rosa) ::: Rosa is not bewildered.\n¬Bewildered(howard) ::: Howard is not bewildered.\n¬Putrid(rosa) ::: Rosa is not putrid.\nStrong(godfrey) ::: Godfrey is strong.\nJolly(adam) ::: Adam is jolly.\nCrowded(kenyon) ::: Kenyon is crowded.\n¬Lovely(rose) ::: Rose is not lovely.\n¬Strong(rose) ::: Rose is not strong.\n¬Lovely(tyra) ::: Tyra is not lovely.\nStrong(rosa) ::: Rosa is strong.\n((¬Putrid(x))) ↔ ((¬Lovely(x))) ::: Someone is not putrid if and only if he is not lovely.\n(∀x ((¬Putrid(x)) ∨ (¬Strong(x)))) → (¬Bewildered(x)) ::: Someone who is eithor not putrid or not strong is always not bewildered.\n(∀x ((Strong(x) ∧ ¬Bewildered(x)))) → (Putrid(x)) ::: If someone is both strong and not bewildered, then he is putrid.\n(∀x ((Jolly(x) ∧ Putrid(x)))) → (Lovely(x)) ::: Someone who is both jolly and putrid is always lovely.\n(∀x ((Lovely(x) ∧ ¬Crowded(x)))) ↔ ((Bewildered(x) ∧ Putrid(x))) ::: Someone being both lovely and not crowded is equivalent to being bewildered and putrid.\n(∃x ((Bewildered(x) ∧ ¬Lovely(x)))) → (Jolly(howard)) ::: If there is at least one people who is both bewildered and not lovely, then Howard is jolly.\n((¬Lovely(x))) ↔ ((Bewildered(x))) ::: Someone is not lovely if and only if he is bewildered.\n(∃x ((Lovely(x) ∨ ¬Strong(x)))) → (¬Crowded(godfrey)) ::: If there is at least one people who is lovely or not strong, then Godfrey is not crowded.\n(∀x ((Jolly(x) ∨ ¬Putrid(x))) → (Lovely(x)) ::: If someone is jolly or not putrid, then he is lovely.\n((¬Jolly(howard) ∧ Putrid(howard))) → (¬Bewildered(kenyon)) ::: If Howard is not jolly and Howard is putrid, then Kenyon is not bewildered.\n(∀x ((¬Crowded(x) ∧ ¬Jolly(x))) → ((Putrid(x) ∧ ¬Strong(x))) ::: If someone is not crowded and not jolly, then he is putrid and not strong.\n(∀x (Putrid(x))) → (Jolly(x)) ::: All putrid people are jolly.\n",
            "First-Order-Logic Question": "Bewildered(godfrey) ::: Godfrey is bewildered."
        },
        "gram_prog": {
            "First-Order-Logic Rules": "¬Crowded(howard) ::: Howard is not crowded.\nPutrid(tyra) ::: Tyra is putrid.\n¬Bewildered(rosa) ::: Rosa is not bewildered.\n¬Bewildered(howard) ::: Howard is not bewildered.\n¬Putrid(rosa) ::: Rosa is not putrid.\nStrong(godfrey) ::: Godfrey is strong.\nJolly(adam) ::: Adam is jolly.\nCrowded(kenyon) ::: Kenyon is crowded.\n¬Lovely(rose) ::: Rose is not lovely.\n¬Strong(rose) ::: Rose is not strong.\n¬Lovely(tyra) ::: Tyra is not lovely.\nStrong(rosa) ::: Rosa is strong.\n((¬Putrid(x))) ↔ ((¬Lovely(x))) ::: Someone is not putrid if and only if he is not lovely.\n(∀x ((¬Putrid(x)) ∨ (¬Strong(x)))) → (¬Bewildered(x)) ::: Someone who is eithor not putrid or not strong is always not bewildered.\n(∀x ((Strong(x) ∧ ¬Bewildered(x)))) → (Putrid(x)) ::: If someone is both strong and not bewildered, then he is putrid.\n(∀x ((Jolly(x) ∧ Putrid(x)))) → (Lovely(x)) ::: Someone who is both jolly and putrid is always lovely.\n(∀x ((Lovely(x) ∧ ¬Crowded(x)))) ↔ ((Bewildered(x) ∧ Putrid(x))) ::: Someone being both lovely and not crowded is equivalent to being bewildered and putrid.\n(∃x ((Bewildered(x) ∧ ¬Lovely(x)))) → (Jolly(howard)) ::: If there is at least one people who is both bewildered and not lovely, then Howard is jolly.\n((¬Lovely(x))) ↔ ((Bewildered(x))) ::: Someone is not lovely if and only if he is bewildered.\n(∃x ((Lovely(x) ∨ ¬Strong(x)))) → (¬Crowded(godfrey)) ::: If there is at least one people who is lovely or not strong, then Godfrey is not crowded.\n∀x((Jolly(x)∨¬Putrid(x))) ::: If someone is jolly or not putrid, then he is lovely.\n((¬Jolly(howard) ∧ Putrid(howard))) → (¬Bewildered(kenyon)) ::: If Howard is not jolly and Howard is putrid, then Kenyon is not bewildered.\n∀x((¬Crowded(x)∧¬Jolly(x))) ::: If someone is not crowded and not jolly, then he is putrid and not strong.\n(∀x (Putrid(x))) → (Jolly(x)) ::: All putrid people are jolly.\n",
            "First-Order-Logic Question": "Bewildered(godfrey) ::: Godfrey is bewildered."
        },
        "diff": [
            {
                "raw": "(∀x ((Jolly(x) ∨ ¬Putrid(x))) → (Lovely(x)) ::: If someone is jolly or not putrid, then he is lovely.",
                "gram": "∀x((Jolly(x)∨¬Putrid(x))) ::: If someone is jolly or not putrid, then he is lovely."
            },
            {
                "raw": "(∀x ((¬Crowded(x) ∧ ¬Jolly(x))) → ((Putrid(x) ∧ ¬Strong(x))) ::: If someone is not crowded and not jolly, then he is putrid and not strong.",
                "gram": "∀x((¬Crowded(x)∧¬Jolly(x))) ::: If someone is not crowded and not jolly, then he is putrid and not strong."
            }
        ],
        "answer": "C",
        "grammar_answer": "A",
        "manual_prog": {
            "First-Order-Logic Rules": "¬Crowded(howard) ::: Howard is not crowded.\nPutrid(tyra) ::: Tyra is putrid.\n¬Bewildered(rosa) ::: Rosa is not bewildered.\n¬Bewildered(howard) ::: Howard is not bewildered.\n¬Putrid(rosa) ::: Rosa is not putrid.\nStrong(godfrey) ::: Godfrey is strong.\nJolly(adam) ::: Adam is jolly.\nCrowded(kenyon) ::: Kenyon is crowded.\n¬Lovely(rose) ::: Rose is not lovely.\n¬Strong(rose) ::: Rose is not strong.\n¬Lovely(tyra) ::: Tyra is not lovely.\nStrong(rosa) ::: Rosa is strong.\n((¬Putrid(x))) ↔ ((¬Lovely(x))) ::: Someone is not putrid if and only if he is not lovely.\n(∀x ((¬Putrid(x)) ∨ (¬Strong(x)))) → (¬Bewildered(x)) ::: Someone who is eithor not putrid or not strong is always not bewildered.\n(∀x ((Strong(x) ∧ ¬Bewildered(x)))) → (Putrid(x)) ::: If someone is both strong and not bewildered, then he is putrid.\n(∀x ((Jolly(x) ∧ Putrid(x)))) → (Lovely(x)) ::: Someone who is both jolly and putrid is always lovely.\n(∀x ((Lovely(x) ∧ ¬Crowded(x)))) ↔ ((Bewildered(x) ∧ Putrid(x))) ::: Someone being both lovely and not crowded is equivalent to being bewildered and putrid.\n(∃x ((Bewildered(x) ∧ ¬Lovely(x)))) → (Jolly(howard)) ::: If there is at least one people who is both bewildered and not lovely, then Howard is jolly.\n((¬Lovely(x))) ↔ ((Bewildered(x))) ::: Someone is not lovely if and only if he is bewildered.\n(∃x ((Lovely(x) ∨ ¬Strong(x)))) → (¬Crowded(godfrey)) ::: If there is at least one people who is lovely or not strong, then Godfrey is not crowded.\n(∀x ((Jolly(x) ∨ ¬Putrid(x))) → (Lovely(x))) ::: If someone is jolly or not putrid, then he is lovely.\n((¬Jolly(howard) ∧ Putrid(howard))) → (¬Bewildered(kenyon)) ::: If Howard is not jolly and Howard is putrid, then Kenyon is not bewildered.\n(∀x ((¬Crowded(x) ∧ ¬Jolly(x))) → ((Putrid(x) ∧ ¬Strong(x)))) ::: If someone is not crowded and not jolly, then he is putrid and not strong.\n(∀x (Putrid(x))) → (Jolly(x)) ::: All putrid people are jolly.\n",
            "First-Order-Logic Question": "Bewildered(godfrey) ::: Godfrey is bewildered."
        },
        "fixed": true
    },
    {
        "id": 1100,
        "raw_prog": {
            "First-Order-Logic Rules": "Poor(ansel) ::: Ansel is poor.\n¬Decent(ansel) ::: Ansel is not decent.\nStubborn(desiree) ::: Desiree is stubborn.\nDecent(maurice) ::: Maurice is decent.\nStubborn(ansel) ::: Ansel is stubborn.\nStrong(rose) ::: Rose is strong.\n¬Able(montague) ::: Montague is not able.\nAble(joseph) ::: Joseph is able.\n¬Decent(joseph) ::: Joseph is not decent.\nFancy(maurice) ::: Maurice is fancy.\nFancy(seymour) ::: Seymour is fancy.\nDecent(desiree) ::: Desiree is decent.\n(Rational(fancy(x) ∧ ¬Stubborn(x))) ↔ (¬Able(x)) ::: Someone is fancy and not stubborn if and only if he is not able.\n((¬Poor(maurice) ∧ Decent(joseph))) → ((¬Strong(montague) ∧ ¬Fancy(rose))) ::: Maurice being not poor and Joseph being decent imply that Montague is not strong and Rose is not fancy.\n(∃x (Stubborn(x) ∧ ¬Able(x))) → ((¬Decent(montague))) ::: If there is someone who is both stubborn and not able, then Montague is not decent.\n(∀x (¬Stubborn(x))) → (Poor(x)) ::: Someone who is not stubborn is always poor.\n(∃x (Fancy(x) ∧ ¬Stubborn(x))) → ((¬Poor(ansel))) ::: If there is someone who is both fancy and not stubborn, then Ansel is not poor.\n(Rational(able(x) ∧ ¬Strong(x))) ↔ (Poor(x) ∧ ¬Stubborn(x)) ::: Someone being both able and not strong is equivalent to being poor and not stubborn.\n((¬Strong(desiree))) → ((¬Fancy(maurice) ∧ ¬Decent(montague))) ::: If Desiree is not strong, then Maurice is not fancy and Montague is not decent.\n(∃x (Decent(x) ∨ Poor(x))) → ((Stubborn(ansel) ∧ Fancy(ansel))) ::: If there is at least one people who is either decent or poor, then Ansel is stubborn and Ansel is fancy.\n(∀x (Stubborn(x) ∧ ¬Poor(x))) → (Decent(x)) ::: If someone who is stubborn is also not poor, then he is decent.\n(Decent(maurice)) → (Strong(desiree)) ::: If Maurice is decent, then Desiree is strong.\n(∀x (Stubborn(x) ∧ ¬Decent(x))) → (Strong(x)) ::: Someone who is both stubborn and not decent is always strong.\n(∃x (Strong(x))) → ((¬Fancy(ansel) ∧ ¬Stubborn(seymour))) ::: If there is someone who is strong, then Ansel is not fancy and Seymour is not stubborn.\n",
            "First-Order-Logic Question": "¬Decent(rose) ::: Rose is not decent."
        },
        "gram_prog": {
            "First-Order-Logic Rules": "Poor(ansel) ::: Ansel is poor.\n¬Decent(ansel) ::: Ansel is not decent.\nStubborn(desiree) ::: Desiree is stubborn.\nDecent(maurice) ::: Maurice is decent.\nStubborn(ansel) ::: Ansel is stubborn.\nStrong(rose) ::: Rose is strong.\n¬Able(montague) ::: Montague is not able.\nAble(joseph) ::: Joseph is able.\n¬Decent(joseph) ::: Joseph is not decent.\nFancy(maurice) ::: Maurice is fancy.\nFancy(seymour) ::: Seymour is fancy.\nDecent(desiree) ::: Desiree is decent.\n¬(Poor(x)→Decent(x))↔(¬Able(x)) ::: Someone is fancy and not stubborn if and only if he is not able.\n((¬Poor(maurice) ∧ Decent(joseph))) → ((¬Strong(montague) ∧ ¬Fancy(rose))) ::: Maurice being not poor and Joseph being decent imply that Montague is not strong and Rose is not fancy.\n(∃x (Stubborn(x) ∧ ¬Able(x))) → ((¬Decent(montague))) ::: If there is someone who is both stubborn and not able, then Montague is not decent.\n(∀x (¬Stubborn(x))) → (Poor(x)) ::: Someone who is not stubborn is always poor.\n(∃x (Fancy(x) ∧ ¬Stubborn(x))) → ((¬Poor(ansel))) ::: If there is someone who is both fancy and not stubborn, then Ansel is not poor.\n¬(Poor(x)→Stubborn(x))↔(Strong(x)→Able(x)) ::: Someone being both able and not strong is equivalent to being poor and not stubborn.\n((¬Strong(desiree))) → ((¬Fancy(maurice) ∧ ¬Decent(montague))) ::: If Desiree is not strong, then Maurice is not fancy and Montague is not decent.\n(∃x (Decent(x) ∨ Poor(x))) → ((Stubborn(ansel) ∧ Fancy(ansel))) ::: If there is at least one people who is either decent or poor, then Ansel is stubborn and Ansel is fancy.\n(∀x (Stubborn(x) ∧ ¬Poor(x))) → (Decent(x)) ::: If someone who is stubborn is also not poor, then he is decent.\n(Decent(maurice)) → (Strong(desiree)) ::: If Maurice is decent, then Desiree is strong.\n(∀x (Stubborn(x) ∧ ¬Decent(x))) → (Strong(x)) ::: Someone who is both stubborn and not decent is always strong.\n(∃x (Strong(x))) → ((¬Fancy(ansel) ∧ ¬Stubborn(seymour))) ::: If there is someone who is strong, then Ansel is not fancy and Seymour is not stubborn.\n",
            "First-Order-Logic Question": "¬Decent(rose) ::: Rose is not decent."
        },
        "diff": [
            {
                "raw": "(Rational(fancy(x) ∧ ¬Stubborn(x))) ↔ (¬Able(x)) ::: Someone is fancy and not stubborn if and only if he is not able.",
                "gram": "¬(Poor(x)→Decent(x))↔(¬Able(x)) ::: Someone is fancy and not stubborn if and only if he is not able."
            },
            {
                "raw": "(Rational(able(x) ∧ ¬Strong(x))) ↔ (Poor(x) ∧ ¬Stubborn(x)) ::: Someone being both able and not strong is equivalent to being poor and not stubborn.",
                "gram": "¬(Poor(x)→Stubborn(x))↔(Strong(x)→Able(x)) ::: Someone being both able and not strong is equivalent to being poor and not stubborn."
            }
        ],
        "answer": "C",
        "grammar_answer": "A",
        "manual_prog": {
            "First-Order-Logic Rules": "Poor(ansel) ::: Ansel is poor.\n¬Decent(ansel) ::: Ansel is not decent.\nStubborn(desiree) ::: Desiree is stubborn.\nDecent(maurice) ::: Maurice is decent.\nStubborn(ansel) ::: Ansel is stubborn.\nStrong(rose) ::: Rose is strong.\n¬Able(montague) ::: Montague is not able.\nAble(joseph) ::: Joseph is able.\n¬Decent(joseph) ::: Joseph is not decent.\nFancy(maurice) ::: Maurice is fancy.\nFancy(seymour) ::: Seymour is fancy.\nDecent(desiree) ::: Desiree is decent.\n(Rational(x) ∧ Fancy(x) ∧ ¬Stubborn(x)) ↔ (¬Able(x)) ::: Someone is fancy and not stubborn if and only if he is not able.\n((¬Poor(maurice) ∧ Decent(joseph))) → ((¬Strong(montague) ∧ ¬Fancy(rose))) ::: Maurice being not poor and Joseph being decent imply that Montague is not strong and Rose is not fancy.\n(∃x (Stubborn(x) ∧ ¬Able(x))) → ((¬Decent(montague))) ::: If there is someone who is both stubborn and not able, then Montague is not decent.\n(∀x (¬Stubborn(x))) → (Poor(x)) ::: Someone who is not stubborn is always poor.\n(∃x (Fancy(x) ∧ ¬Stubborn(x))) → ((¬Poor(ansel))) ::: If there is someone who is both fancy and not stubborn, then Ansel is not poor.\n(Rational(x) ∧ Able(x) ∧ ¬Strong(x)) ↔ (Poor(x) ∧ ¬Stubborn(x)) ::: Someone being both able and not strong is equivalent to being poor and not stubborn.\n((¬Strong(desiree))) → ((¬Fancy(maurice) ∧ ¬Decent(montague))) ::: If Desiree is not strong, then Maurice is not fancy and Montague is not decent.\n(∃x (Decent(x) ∨ Poor(x))) → ((Stubborn(ansel) ∧ Fancy(ansel))) ::: If there is at least one people who is either decent or poor, then Ansel is stubborn and Ansel is fancy.\n(∀x (Stubborn(x) ∧ ¬Poor(x))) → (Decent(x)) ::: If someone who is stubborn is also not poor, then he is decent.\n(Decent(maurice)) → (Strong(desiree)) ::: If Maurice is decent, then Desiree is strong.\n(∀x (Stubborn(x) ∧ ¬Decent(x))) → (Strong(x)) ::: Someone who is both stubborn and not decent is always strong.\n(∃x (Strong(x))) → ((¬Fancy(ansel) ∧ ¬Stubborn(seymour))) ::: If there is someone who is strong, then Ansel is not fancy and Seymour is not stubborn.\n",
            "First-Order-Logic Question": "¬Decent(rose) ::: Rose is not decent."
        },
        "fixed": true
    },
    {
        "id": 1103,
        "raw_prog": {
            "First-Order-Logic Rules": "Poor(ansel) ::: Ansel is poor.\n¬Decent(ansel) ::: Ansel is not decent.\nStubborn(desiree) ::: Desiree is stubborn.\nDecent(maurice) ::: Maurice is decent.\nStubborn(ansel) ::: Ansel is stubborn.\nStrong(rose) ::: Rose is strong.\n¬Able(montague) ::: Montague is not able.\nAble(joseph) ::: Joseph is able.\n¬Decent(joseph) ::: Joseph is not decent.\nFancy(maurice) ::: Maurice is fancy.\nFancy(seymour) ::: Seymour is fancy.\nDecent(desiree) ::: Desiree is decent.\n(Rational(fancy(x) ∧ ¬Stubborn(x))) ↔ (¬Able(x)) ::: Someone is fancy and not stubborn if and only if he is not able.\n((¬Poor(maurice) ∧ Decent(joseph))) → ((¬Strong(montague) ∧ ¬Fancy(rose))) ::: Maurice being not poor and Joseph being decent imply that Montague is not strong and Rose is not fancy.\n(∃x (Stubborn(x) ∧ ¬Able(x))) → ((¬Decent(montague))) ::: If there is someone who is both stubborn and not able, then Montague is not decent.\n(∀x (¬Stubborn(x))) → (Poor(x)) ::: Someone who is not stubborn is always poor.\n(∃x (Fancy(x) ∧ ¬Stubborn(x))) → ((¬Poor(ansel))) ::: If there is someone who is both fancy and not stubborn, then Ansel is not poor.\n(Rational(able(x) ∧ ¬Strong(x))) ↔ (Poor(x) ∧ ¬Stubborn(x)) ::: Someone being both able and not strong is equivalent to being poor and not stubborn.\n((¬Strong(desiree))) → ((¬Fancy(maurice) ∧ ¬Decent(montague))) ::: If Desiree is not strong, then Maurice is not fancy and Montague is not decent.\n(∃x (Decent(x) ∨ Poor(x))) → ((Stubborn(ansel) ∧ Fancy(ansel))) ::: If there is at least one people who is either decent or poor, then Ansel is stubborn and Ansel is fancy.\n(∀x (Stubborn(x) ∧ ¬Poor(x))) → (Decent(x)) ::: If someone who is stubborn is also not poor, then he is decent.\n((Decent(maurice))) → ((Strong(desiree))) ::: If Maurice is decent, then Desiree is strong.\n(∀x (Stubborn(x) ∧ ¬Decent(x))) → (Strong(x)) ::: Someone who is both stubborn and not decent is always strong.\n(∃x (Strong(x))) → ((¬Fancy(ansel) ∧ ¬Stubborn(seymour))) ::: If there is someone who is strong, then Ansel is not fancy and Seymour is not stubborn.\n",
            "First-Order-Logic Question": "Poor(maurice) ::: Maurice is poor."
        },
        "gram_prog": {
            "First-Order-Logic Rules": "Poor(ansel) ::: Ansel is poor.\n¬Decent(ansel) ::: Ansel is not decent.\nStubborn(desiree) ::: Desiree is stubborn.\nDecent(maurice) ::: Maurice is decent.\nStubborn(ansel) ::: Ansel is stubborn.\nStrong(rose) ::: Rose is strong.\n¬Able(montague) ::: Montague is not able.\nAble(joseph) ::: Joseph is able.\n¬Decent(joseph) ::: Joseph is not decent.\nFancy(maurice) ::: Maurice is fancy.\nFancy(seymour) ::: Seymour is fancy.\nDecent(desiree) ::: Desiree is decent.\n¬(Poor(x)→Decent(x))↔(¬Able(x)) ::: Someone is fancy and not stubborn if and only if he is not able.\n((¬Poor(maurice) ∧ Decent(joseph))) → ((¬Strong(montague) ∧ ¬Fancy(rose))) ::: Maurice being not poor and Joseph being decent imply that Montague is not strong and Rose is not fancy.\n(∃x (Stubborn(x) ∧ ¬Able(x))) → ((¬Decent(montague))) ::: If there is someone who is both stubborn and not able, then Montague is not decent.\n(∀x (¬Stubborn(x))) → (Poor(x)) ::: Someone who is not stubborn is always poor.\n(∃x (Fancy(x) ∧ ¬Stubborn(x))) → ((¬Poor(ansel))) ::: If there is someone who is both fancy and not stubborn, then Ansel is not poor.\n¬(Poor(x)→Stubborn(x))↔(Strong(x)→Able(x)) ::: Someone being both able and not strong is equivalent to being poor and not stubborn.\n((¬Strong(desiree))) → ((¬Fancy(maurice) ∧ ¬Decent(montague))) ::: If Desiree is not strong, then Maurice is not fancy and Montague is not decent.\n(∃x (Decent(x) ∨ Poor(x))) → ((Stubborn(ansel) ∧ Fancy(ansel))) ::: If there is at least one people who is either decent or poor, then Ansel is stubborn and Ansel is fancy.\n(∀x (Stubborn(x) ∧ ¬Poor(x))) → (Decent(x)) ::: If someone who is stubborn is also not poor, then he is decent.\n((Decent(maurice))) → ((Strong(desiree))) ::: If Maurice is decent, then Desiree is strong.\n(∀x (Stubborn(x) ∧ ¬Decent(x))) → (Strong(x)) ::: Someone who is both stubborn and not decent is always strong.\n(∃x (Strong(x))) → ((¬Fancy(ansel) ∧ ¬Stubborn(seymour))) ::: If there is someone who is strong, then Ansel is not fancy and Seymour is not stubborn.\n",
            "First-Order-Logic Question": "Poor(maurice) ::: Maurice is poor."
        },
        "diff": [
            {
                "raw": "(Rational(fancy(x) ∧ ¬Stubborn(x))) ↔ (¬Able(x)) ::: Someone is fancy and not stubborn if and only if he is not able.",
                "gram": "¬(Poor(x)→Decent(x))↔(¬Able(x)) ::: Someone is fancy and not stubborn if and only if he is not able."
            },
            {
                "raw": "(Rational(able(x) ∧ ¬Strong(x))) ↔ (Poor(x) ∧ ¬Stubborn(x)) ::: Someone being both able and not strong is equivalent to being poor and not stubborn.",
                "gram": "¬(Poor(x)→Stubborn(x))↔(Strong(x)→Able(x)) ::: Someone being both able and not strong is equivalent to being poor and not stubborn."
            }
        ],
        "answer": "C",
        "grammar_answer": "A",
        "manual_prog": {
            "First-Order-Logic Rules": "Poor(ansel) ::: Ansel is poor.\n¬Decent(ansel) ::: Ansel is not decent.\nStubborn(desiree) ::: Desiree is stubborn.\nDecent(maurice) ::: Maurice is decent.\nStubborn(ansel) ::: Ansel is stubborn.\nStrong(rose) ::: Rose is strong.\n¬Able(montague) ::: Montague is not able.\nAble(joseph) ::: Joseph is able.\n¬Decent(joseph) ::: Joseph is not decent.\nFancy(maurice) ::: Maurice is fancy.\nFancy(seymour) ::: Seymour is fancy.\nDecent(desiree) ::: Desiree is decent.\n(Rational(x) ∧ Fancy(x) ∧ ¬Stubborn(x)) ↔ (¬Able(x)) ::: Someone is fancy and not stubborn if and only if he is not able.\n((¬Poor(maurice) ∧ Decent(joseph))) → ((¬Strong(montague) ∧ ¬Fancy(rose))) ::: Maurice being not poor and Joseph being decent imply that Montague is not strong and Rose is not fancy.\n(∃x (Stubborn(x) ∧ ¬Able(x))) → ((¬Decent(montague))) ::: If there is someone who is both stubborn and not able, then Montague is not decent.\n(∀x (¬Stubborn(x))) → (Poor(x)) ::: Someone who is not stubborn is always poor.\n(∃x (Fancy(x) ∧ ¬Stubborn(x))) → ((¬Poor(ansel))) ::: If there is someone who is both fancy and not stubborn, then Ansel is not poor.\n(Rational(x) ∧ Able(x) ∧ ¬Strong(x)) ↔ (Poor(x) ∧ ¬Stubborn(x)) ::: Someone being both able and not strong is equivalent to being poor and not stubborn.\n((¬Strong(desiree))) → ((¬Fancy(maurice) ∧ ¬Decent(montague))) ::: If Desiree is not strong, then Maurice is not fancy and Montague is not decent.\n(∃x (Decent(x) ∨ Poor(x))) → ((Stubborn(ansel) ∧ Fancy(ansel))) ::: If there is at least one people who is either decent or poor, then Ansel is stubborn and Ansel is fancy.\n(∀x (Stubborn(x) ∧ ¬Poor(x))) → (Decent(x)) ::: If someone who is stubborn is also not poor, then he is decent.\n((Decent(maurice))) → ((Strong(desiree))) ::: If Maurice is decent, then Desiree is strong.\n(∀x (Stubborn(x) ∧ ¬Decent(x))) → (Strong(x)) ::: Someone who is both stubborn and not decent is always strong.\n(∃x (Strong(x))) → ((¬Fancy(ansel) ∧ ¬Stubborn(seymour))) ::: If there is someone who is strong, then Ansel is not fancy and Seymour is not stubborn.\n",
            "First-Order-Logic Question": "Poor(maurice) ::: Maurice is poor."
        },
        "fixed": true
    },
    {
        "id": 1131,
        "raw_prog": {
            "First-Order-Logic Rules": "¬Different(brandi) ::: Brandi is not different.\nAlert(julie) ::: Julie is alert.\nLong(leroy) ::: Leroy is long.\n¬Poised(leroy) ::: Leroy is not poised.\nLong(julie) ::: Julie is long.\nPoised(tristan) ::: Tristan is poised.\n¬Faithful(cyril) ::: Cyril is not faithful.\n¬Different(tristan) ::: Tristan is not different.\n¬Different(cyril) ::: Cyril is not different.\nLong(cyril) ::: Cyril is long.\nLong(brandi) ::: Brandi is long.\nPoised(shane) ::: Shane is poised.\n(∀x (Faithful(x) ∨ ¬Poised(x))) → (∀x (¬Short(x))) ::: Someone who is eithor faithful or not poised is always not short.\n(∀x ((¬Faithful(x)) ↔ (¬Different(x)))) ::: If someone is not faithful, then he is not different, and vice versa.\n(∃x (Short(x) ∨ ¬Different(x))) → ((Alert(julie) ∧ Faithful(cyril))) ::: If there is at least one people who is either short or not different, then Julie is alert and Cyril is faithful.\n(Alert(x)) ↔ (Poised(x)) ::: Someone is alert if and only if he is poised.\n((¬Poised(julie) ∨ Different(tristan))) → (Long(leroy)) ::: If Julie is not poised or Tristan is different, then Leroy is long.\n(∀x (Short(x))) ↔ (Faithful(x)) ::: If someone is short, then he is faithful, and vice versa.\n((Alert(brandi) ∨ Short(cyril))) → (¬Poised(cyril)) ::: If Brandi is alert or Cyril is short, then Cyril is not poised.\n(∃x (Alert(x) ∨ ¬Poised(x))) → (¬Long(shane)) ::: If there is at least one people who is alert or not poised, then Shane is not long.\n(∀x ((¬Poised(x) ∧ ¬Short(x))) → (¬Alert(x))) ::: If someone is neither poised nor short, then he is not alert.\n(∀x (Alert(x))) → ((¬Different(neal) ∧ Faithful(julie))) ::: If everyone is alert, then Neal is not different and Julie is faithful.\n(∀x ((¬Faithful(x)) → (Alert(x))) ::: If someone is not faithful, then he is alert.\n(∀x ((Different(x) ∨ ¬Long(x)) → (Alert(x))) ::: If someone is he or not long is not different, then he is alert.\n",
            "First-Order-Logic Question": "Different(julie) ::: Julie is different."
        },
        "gram_prog": {
            "First-Order-Logic Rules": "¬Different(brandi) ::: Brandi is not different.\nAlert(julie) ::: Julie is alert.\nLong(leroy) ::: Leroy is long.\n¬Poised(leroy) ::: Leroy is not poised.\nLong(julie) ::: Julie is long.\nPoised(tristan) ::: Tristan is poised.\n¬Faithful(cyril) ::: Cyril is not faithful.\n¬Different(tristan) ::: Tristan is not different.\n¬Different(cyril) ::: Cyril is not different.\nLong(cyril) ::: Cyril is long.\nLong(brandi) ::: Brandi is long.\nPoised(shane) ::: Shane is poised.\n(∀x (Faithful(x) ∨ ¬Poised(x))) → (∀x (¬Short(x))) ::: Someone who is eithor faithful or not poised is always not short.\n(∀x ((¬Faithful(x)) ↔ (¬Different(x)))) ::: If someone is not faithful, then he is not different, and vice versa.\n(∃x (Short(x) ∨ ¬Different(x))) → ((Alert(julie) ∧ Faithful(cyril))) ::: If there is at least one people who is either short or not different, then Julie is alert and Cyril is faithful.\n(Alert(x)) ↔ (Poised(x)) ::: Someone is alert if and only if he is poised.\n((¬Poised(julie) ∨ Different(tristan))) → (Long(leroy)) ::: If Julie is not poised or Tristan is different, then Leroy is long.\n(∀x (Short(x))) ↔ (Faithful(x)) ::: If someone is short, then he is faithful, and vice versa.\n((Alert(brandi) ∨ Short(cyril))) → (¬Poised(cyril)) ::: If Brandi is alert or Cyril is short, then Cyril is not poised.\n(∃x (Alert(x) ∨ ¬Poised(x))) → (¬Long(shane)) ::: If there is at least one people who is alert or not poised, then Shane is not long.\n(∀x ((¬Poised(x) ∧ ¬Short(x))) → (¬Alert(x))) ::: If someone is neither poised nor short, then he is not alert.\n(∀x (Alert(x))) → ((¬Different(neal) ∧ Faithful(julie))) ::: If everyone is alert, then Neal is not different and Julie is faithful.\n∀x((¬Faithful(x))→Alert(x)) ::: If someone is not faithful, then he is alert.\n∀x((Different(x)∨¬Long(x))) ::: If someone is he or not long is not different, then he is alert.\n",
            "First-Order-Logic Question": "Different(julie) ::: Julie is different."
        },
        "diff": [
            {
                "raw": "(∀x ((Different(x) ∨ ¬Long(x)) → (Alert(x))) ::: If someone is he or not long is not different, then he is alert.",
                "gram": "∀x((Different(x)∨¬Long(x))) ::: If someone is he or not long is not different, then he is alert."
            }
        ],
        "answer": "C",
        "grammar_answer": "A",
        "manual_prog": {
            "First-Order-Logic Rules": "¬Different(brandi) ::: Brandi is not different.\nAlert(julie) ::: Julie is alert.\nLong(leroy) ::: Leroy is long.\n¬Poised(leroy) ::: Leroy is not poised.\nLong(julie) ::: Julie is long.\nPoised(tristan) ::: Tristan is poised.\n¬Faithful(cyril) ::: Cyril is not faithful.\n¬Different(tristan) ::: Tristan is not different.\n¬Different(cyril) ::: Cyril is not different.\nLong(cyril) ::: Cyril is long.\nLong(brandi) ::: Brandi is long.\nPoised(shane) ::: Shane is poised.\n(∀x (Faithful(x) ∨ ¬Poised(x))) → (∀x (¬Short(x))) ::: Someone who is eithor faithful or not poised is always not short.\n(∀x ((¬Faithful(x)) ↔ (¬Different(x)))) ::: If someone is not faithful, then he is not different, and vice versa.\n(∃x (Short(x) ∨ ¬Different(x))) → ((Alert(julie) ∧ Faithful(cyril))) ::: If there is at least one people who is either short or not different, then Julie is alert and Cyril is faithful.\n(Alert(x)) ↔ (Poised(x)) ::: Someone is alert if and only if he is poised.\n((¬Poised(julie) ∨ Different(tristan))) → (Long(leroy)) ::: If Julie is not poised or Tristan is different, then Leroy is long.\n(∀x (Short(x))) ↔ (Faithful(x)) ::: If someone is short, then he is faithful, and vice versa.\n((Alert(brandi) ∨ Short(cyril))) → (¬Poised(cyril)) ::: If Brandi is alert or Cyril is short, then Cyril is not poised.\n(∃x (Alert(x) ∨ ¬Poised(x))) → (¬Long(shane)) ::: If there is at least one people who is alert or not poised, then Shane is not long.\n(∀x ((¬Poised(x) ∧ ¬Short(x))) → (¬Alert(x))) ::: If someone is neither poised nor short, then he is not alert.\n(∀x (Alert(x))) → ((¬Different(neal) ∧ Faithful(julie))) ::: If everyone is alert, then Neal is not different and Julie is faithful.\n(∀x ((¬Faithful(x)) → (Alert(x))) ::: If someone is not faithful, then he is alert.\n(∀x ((Different(x) ∨ ¬Long(x)) → (Alert(x)))) ::: If someone is he or not long is not different, then he is alert.\n",
            "First-Order-Logic Question": "Different(julie) ::: Julie is different."
        },
        "fixed": true
    },
    {
        "id": 1137,
        "raw_prog": {
            "First-Order-Logic Rules": "¬Different(brandi) ::: Brandi is not different.\nAlert(julie) ::: Julie is alert.\nLong(leroy) ::: Leroy is long.\n¬Poised(leroy) ::: Leroy is not poised.\nLong(julie) ::: Julie is long.\nPoised(tristan) ::: Tristan is poised.\n¬Faithful(cyril) ::: Cyril is not faithful.\n¬Different(tristan) ::: Tristan is not different.\n¬Different(cyril) ::: Cyril is not different.\nLong(cyril) ::: Cyril is long.\nLong(brandi) ::: Brandi is long.\nPoised(shane) ::: Shane is poised.\n(∀x (Faithful(x) ∨ ¬Poised(x))) → (∀x (¬Short(x))) ::: Someone who is eithor faithful or not poised is always not short.\n(∀x ((¬Faithful(x)) ↔ (¬Different(x)))) ::: If someone is not faithful, then he is not different, and vice versa.\n(∃x (Short(x) ∨ ¬Different(x))) → ((Alert(julie) ∧ Faithful(cyril))) ::: If there is at least one people who is either short or not different, then Julie is alert and Cyril is faithful.\n(Alert(x)) ↔ (Poised(x)) ::: Someone is alert if and only if he is poised.\n((¬Poised(julie) ∨ Different(tristan))) → (Long(leroy)) ::: If Julie is not poised or Tristan is different, then Leroy is long.\n(∀x (Short(x))) ↔ (Faithful(x)) ::: If someone is short, then he is faithful, and vice versa.\n((Alert(brandi) ∨ Short(cyril))) → (¬Poised(cyril)) ::: If Brandi is alert or Cyril is short, then Cyril is not poised.\n(∃x (Alert(x) ∨ ¬Poised(x))) → (¬Long(shane)) ::: If there is at least one people who is alert or not poised, then Shane is not long.\n(∀x ((¬Poised(x) ∧ ¬Short(x))) → (¬Alert(x))) ::: If someone is neither poised nor short, then he is not alert.\n(∀x (Alert(x))) → (¬Different(neal) ∧ Faithful(julie)) ::: If everyone is alert, then Neal is not different and Julie is faithful.\n(∀x ((¬Faithful(x)) → (Alert(x))) ::: If someone is not faithful, then he is alert.\n(∀x ((Long(x) ∨ ¬Different(x)) → (Alert(x))) ::: If someone is he or not long is not different, then he is alert.\n",
            "First-Order-Logic Question": "¬Long(cyril) ::: Cyril is not long."
        },
        "gram_prog": {
            "First-Order-Logic Rules": "¬Different(brandi) ::: Brandi is not different.\nAlert(julie) ::: Julie is alert.\nLong(leroy) ::: Leroy is long.\n¬Poised(leroy) ::: Leroy is not poised.\nLong(julie) ::: Julie is long.\nPoised(tristan) ::: Tristan is poised.\n¬Faithful(cyril) ::: Cyril is not faithful.\n¬Different(tristan) ::: Tristan is not different.\n¬Different(cyril) ::: Cyril is not different.\nLong(cyril) ::: Cyril is long.\nLong(brandi) ::: Brandi is long.\nPoised(shane) ::: Shane is poised.\n(∀x (Faithful(x) ∨ ¬Poised(x))) → (∀x (¬Short(x))) ::: Someone who is eithor faithful or not poised is always not short.\n(∀x ((¬Faithful(x)) ↔ (¬Different(x)))) ::: If someone is not faithful, then he is not different, and vice versa.\n(∃x (Short(x) ∨ ¬Different(x))) → ((Alert(julie) ∧ Faithful(cyril))) ::: If there is at least one people who is either short or not different, then Julie is alert and Cyril is faithful.\n(Alert(x)) ↔ (Poised(x)) ::: Someone is alert if and only if he is poised.\n((¬Poised(julie) ∨ Different(tristan))) → (Long(leroy)) ::: If Julie is not poised or Tristan is different, then Leroy is long.\n(∀x (Short(x))) ↔ (Faithful(x)) ::: If someone is short, then he is faithful, and vice versa.\n((Alert(brandi) ∨ Short(cyril))) → (¬Poised(cyril)) ::: If Brandi is alert or Cyril is short, then Cyril is not poised.\n(∃x (Alert(x) ∨ ¬Poised(x))) → (¬Long(shane)) ::: If there is at least one people who is alert or not poised, then Shane is not long.\n(∀x ((¬Poised(x) ∧ ¬Short(x))) → (¬Alert(x))) ::: If someone is neither poised nor short, then he is not alert.\n(∀x (Alert(x))) → (¬Different(neal) ∧ Faithful(julie)) ::: If everyone is alert, then Neal is not different and Julie is faithful.\n∀x((¬Faithful(x))→Alert(x)) ::: If someone is not faithful, then he is alert.\n∀x((Long(x)∨¬Different(x))) ::: If someone is he or not long is not different, then he is alert.\n",
            "First-Order-Logic Question": "¬Long(cyril) ::: Cyril is not long."
        },
        "diff": [
            {
                "raw": "(∀x ((Long(x) ∨ ¬Different(x)) → (Alert(x))) ::: If someone is he or not long is not different, then he is alert.",
                "gram": "∀x((Long(x)∨¬Different(x))) ::: If someone is he or not long is not different, then he is alert."
            }
        ],
        "answer": "B",
        "grammar_answer": "A",
        "manual_prog": {
            "First-Order-Logic Rules": "¬Different(brandi) ::: Brandi is not different.\nAlert(julie) ::: Julie is alert.\nLong(leroy) ::: Leroy is long.\n¬Poised(leroy) ::: Leroy is not poised.\nLong(julie) ::: Julie is long.\nPoised(tristan) ::: Tristan is poised.\n¬Faithful(cyril) ::: Cyril is not faithful.\n¬Different(tristan) ::: Tristan is not different.\n¬Different(cyril) ::: Cyril is not different.\nLong(cyril) ::: Cyril is long.\nLong(brandi) ::: Brandi is long.\nPoised(shane) ::: Shane is poised.\n(∀x (Faithful(x) ∨ ¬Poised(x))) → (∀x (¬Short(x))) ::: Someone who is eithor faithful or not poised is always not short.\n(∀x ((¬Faithful(x)) ↔ (¬Different(x)))) ::: If someone is not faithful, then he is not different, and vice versa.\n(∃x (Short(x) ∨ ¬Different(x))) → ((Alert(julie) ∧ Faithful(cyril))) ::: If there is at least one people who is either short or not different, then Julie is alert and Cyril is faithful.\n(Alert(x)) ↔ (Poised(x)) ::: Someone is alert if and only if he is poised.\n((¬Poised(julie) ∨ Different(tristan))) → (Long(leroy)) ::: If Julie is not poised or Tristan is different, then Leroy is long.\n(∀x (Short(x))) ↔ (Faithful(x)) ::: If someone is short, then he is faithful, and vice versa.\n((Alert(brandi) ∨ Short(cyril))) → (¬Poised(cyril)) ::: If Brandi is alert or Cyril is short, then Cyril is not poised.\n(∃x (Alert(x) ∨ ¬Poised(x))) → (¬Long(shane)) ::: If there is at least one people who is alert or not poised, then Shane is not long.\n(∀x ((¬Poised(x) ∧ ¬Short(x))) → (¬Alert(x))) ::: If someone is neither poised nor short, then he is not alert.\n(∀x (Alert(x))) → (¬Different(neal) ∧ Faithful(julie)) ::: If everyone is alert, then Neal is not different and Julie is faithful.\n(∀x ((¬Faithful(x)) → (Alert(x))) ::: If someone is not faithful, then he is alert.\n(∀x ((Long(x) ∨ ¬Different(x)) → (Alert(x)))) ::: If someone is he or not long is not different, then he is alert.\n",
            "First-Order-Logic Question": "¬Long(cyril) ::: Cyril is not long."
        },
        "fixed": true
    },
    {
        "id": 1155,
        "raw_prog": {
            "First-Order-Logic Rules": "¬Wonderful(neal) ::: Neal is not wonderful.\nFat(janine) ::: Janine is fat.\nCultural(tyra) ::: Tyra is cultural.\nJittery(lewis) ::: Lewis is jittery.\nJittery(george) ::: George is jittery.\n¬Able(neal) ::: Neal is not able.\nExpensive(neal) ::: Neal is expensive.\nFat(george) ::: George is fat.\n¬Expensive(tyra) ::: Tyra is not expensive.\nAble(clarence) ::: Clarence is able.\n¬Fat(clarence) ::: Clarence is not fat.\n¬Jittery(neal) ::: Neal is not jittery.\n(∀x ((Able(x) ∧ Fat(x))) → (¬Expensive(x)) ::: If someone who is able is also fat, then he is not expensive.\n(∃x ((Jittery(x) ∨ Expensive(x))) → (¬Cultural(george))) ::: If there is at least one people who is jittery or expensive, then George is not cultural.\n(Expensive(neal)) → ((¬Jittery(tyra) ∧ Wonderful(janine))) ::: Neal being expensive implies that Tyra is not jittery and Janine is wonderful.\n(¬Wonderful(neal)) ↔ (Able(janine)) ::: If Neal is not wonderful, then Janine is able, and vice versa.\n(∃x (¬Able(x))) → ((¬Wonderful(barry) ∧ ¬Jittery(clarence))) ::: If there is at least one people who is not able, then Barry is not wonderful and Clarence is not jittery.\n(∀x (Fat(x))) ↔ (¬Jittery(x)) ::: Someone is fat if and only if he is not jittery.\n(¬Expensive(lewis)) → ((¬Wonderful(tyra) ∧ ¬Cultural(neal))) ::: It can be concluded that Tyra is not wonderful and Neal is not cultural once knowing that Lewis is not expensive.\n(∃x (Able(x))) → (¬Expensive(clarence)) ::: If there is someone who is able, then Clarence is not expensive.\n(∀x ((¬Cultural(x) ∧ Wonderful(x))) → (Jittery(x))) ::: If someone who is not cultural is also wonderful, then he is jittery.\n(¬Cultural(george)) → (Jittery(lewis)) ::: It can be concluded that George is not cultural once knowing that Lewis is jittery.\n(∃x (¬Jittery(x))) → (Expensive(clarence) ∧ Cultural(neal)) ::: If there is at least one people who is not jittery, then Clarence is expensive and Neal is cultural.\n(∀x ((¬Cultural(x) ∧ ¬Able(x))) ↔ (¬Expensive(x)) ::: Someone being neither cultural nor able is equivalent to being not expensive.\n",
            "First-Order-Logic Question": "Cultural(george) ::: George is cultural."
        },
        "gram_prog": {
            "First-Order-Logic Rules": "¬Wonderful(neal) ::: Neal is not wonderful.\nFat(janine) ::: Janine is fat.\nCultural(tyra) ::: Tyra is cultural.\nJittery(lewis) ::: Lewis is jittery.\nJittery(george) ::: George is jittery.\n¬Able(neal) ::: Neal is not able.\nExpensive(neal) ::: Neal is expensive.\nFat(george) ::: George is fat.\n¬Expensive(tyra) ::: Tyra is not expensive.\nAble(clarence) ::: Clarence is able.\n¬Fat(clarence) ::: Clarence is not fat.\n¬Jittery(neal) ::: Neal is not jittery.\n∀x((Wonderful(x)→Cultural(x))) ::: If someone who is able is also fat, then he is not expensive.\n(∃x ((Jittery(x) ∨ Expensive(x))) → (¬Cultural(george))) ::: If there is at least one people who is jittery or expensive, then George is not cultural.\n(Expensive(neal)) → ((¬Jittery(tyra) ∧ Wonderful(janine))) ::: Neal being expensive implies that Tyra is not jittery and Janine is wonderful.\n(¬Wonderful(neal)) ↔ (Able(janine)) ::: If Neal is not wonderful, then Janine is able, and vice versa.\n(∃x (¬Able(x))) → ((¬Wonderful(barry) ∧ ¬Jittery(clarence))) ::: If there is at least one people who is not able, then Barry is not wonderful and Clarence is not jittery.\n(∀x (Fat(x))) ↔ (¬Jittery(x)) ::: Someone is fat if and only if he is not jittery.\n(¬Expensive(lewis)) → ((¬Wonderful(tyra) ∧ ¬Cultural(neal))) ::: It can be concluded that Tyra is not wonderful and Neal is not cultural once knowing that Lewis is not expensive.\n(∃x (Able(x))) → (¬Expensive(clarence)) ::: If there is someone who is able, then Clarence is not expensive.\n(∀x ((¬Cultural(x) ∧ Wonderful(x))) → (Jittery(x))) ::: If someone who is not cultural is also wonderful, then he is jittery.\n(¬Cultural(george)) → (Jittery(lewis)) ::: It can be concluded that George is not cultural once knowing that Lewis is jittery.\n(∃x (¬Jittery(x))) → (Expensive(clarence) ∧ Cultural(neal)) ::: If there is at least one people who is not jittery, then Clarence is expensive and Neal is cultural.\n¬Cultural(x)∧¬Able(x)↔¬Expensive(x) ::: Someone being neither cultural nor able is equivalent to being not expensive.\n",
            "First-Order-Logic Question": "Cultural(george) ::: George is cultural."
        },
        "diff": [
            {
                "raw": "(∀x ((Able(x) ∧ Fat(x))) → (¬Expensive(x)) ::: If someone who is able is also fat, then he is not expensive.",
                "gram": "∀x((Wonderful(x)→Cultural(x))) ::: If someone who is able is also fat, then he is not expensive."
            },
            {
                "raw": "(∀x ((¬Cultural(x) ∧ ¬Able(x))) ↔ (¬Expensive(x)) ::: Someone being neither cultural nor able is equivalent to being not expensive.",
                "gram": "¬Cultural(x)∧¬Able(x)↔¬Expensive(x) ::: Someone being neither cultural nor able is equivalent to being not expensive."
            }
        ],
        "answer": "B",
        "grammar_answer": "A",
        "manual_prog": {
            "First-Order-Logic Rules": "¬Wonderful(neal) ::: Neal is not wonderful.\nFat(janine) ::: Janine is fat.\nCultural(tyra) ::: Tyra is cultural.\nJittery(lewis) ::: Lewis is jittery.\nJittery(george) ::: George is jittery.\n¬Able(neal) ::: Neal is not able.\nExpensive(neal) ::: Neal is expensive.\nFat(george) ::: George is fat.\n¬Expensive(tyra) ::: Tyra is not expensive.\nAble(clarence) ::: Clarence is able.\n¬Fat(clarence) ::: Clarence is not fat.\n¬Jittery(neal) ::: Neal is not jittery.\n(∀x ((Able(x) ∧ Fat(x))) → (¬Expensive(x))) ::: If someone who is able is also fat, then he is not expensive.\n(∃x ((Jittery(x) ∨ Expensive(x))) → (¬Cultural(george))) ::: If there is at least one people who is jittery or expensive, then George is not cultural.\n(Expensive(neal)) → ((¬Jittery(tyra) ∧ Wonderful(janine))) ::: Neal being expensive implies that Tyra is not jittery and Janine is wonderful.\n(¬Wonderful(neal)) ↔ (Able(janine)) ::: If Neal is not wonderful, then Janine is able, and vice versa.\n(∃x (¬Able(x))) → ((¬Wonderful(barry) ∧ ¬Jittery(clarence))) ::: If there is at least one people who is not able, then Barry is not wonderful and Clarence is not jittery.\n(∀x (Fat(x))) ↔ (¬Jittery(x)) ::: Someone is fat if and only if he is not jittery.\n(¬Expensive(lewis)) → ((¬Wonderful(tyra) ∧ ¬Cultural(neal))) ::: It can be concluded that Tyra is not wonderful and Neal is not cultural once knowing that Lewis is not expensive.\n(∃x (Able(x))) → (¬Expensive(clarence)) ::: If there is someone who is able, then Clarence is not expensive.\n(∀x ((¬Cultural(x) ∧ Wonderful(x))) → (Jittery(x))) ::: If someone who is not cultural is also wonderful, then he is jittery.\n(¬Cultural(george)) → (Jittery(lewis)) ::: It can be concluded that George is not cultural once knowing that Lewis is jittery.\n(∃x (¬Jittery(x))) → (Expensive(clarence) ∧ Cultural(neal)) ::: If there is at least one people who is not jittery, then Clarence is expensive and Neal is cultural.\n(∀x ((¬Cultural(x) ∧ ¬Able(x))) ↔ (¬Expensive(x))) ::: Someone being neither cultural nor able is equivalent to being not expensive.\n",
            "First-Order-Logic Question": "Cultural(george) ::: George is cultural."
        },
        "fixed": true
    },
    {
        "id": 1160,
        "raw_prog": {
            "First-Order-Logic Rules": "¬Wonderful(neal) ::: Neal is not wonderful.\nFat(janine) ::: Janine is fat.\nCultural(tyra) ::: Tyra is cultural.\nJittery(lewis) ::: Lewis is jittery.\nJittery(george) ::: George is jittery.\n¬Able(neal) ::: Neal is not able.\nExpensive(neal) ::: Neal is expensive.\nFat(george) ::: George is fat.\n¬Expensive(tyra) ::: Tyra is not expensive.\nAble(clarence) ::: Clarence is able.\n¬Fat(clarence) ::: Clarence is not fat.\n¬Jittery(neal) ::: Neal is not jittery.\n(∀x ((Able(x) ∧ Fat(x))) → (¬Expensive(x)) ::: If someone who is able is also fat, then he is not expensive.\n(∃x (Jittery(x) ∨ Expensive(x))) → (¬Cultural(george)) ::: If there is at least one people who is jittery or expensive, then George is not cultural.\n(Expensive(neal)) → ((¬Jittery(tyra) ∧ Wonderful(janine))) ::: Neal being expensive implies that Tyra is not jittery and Janine is wonderful.\n(¬Wonderful(neal)) ↔ (Able(janine)) ::: If Neal is not wonderful, then Janine is able, and vice versa.\n(∃x (¬Able(x))) → (¬Wonderful(barry) ∧ ¬Jittery(clarence)) ::: If there is at least one people who is not able, then Barry is not wonderful and Clarence is not jittery.\n(∀x (Fat(x))) ↔ (¬Jittery(x)) ::: Someone is fat if and only if he is not jittery.\n(¬Expensive(lewis)) → (¬Cultural(tyra) ∧ ¬Wonderful(neal)) ::: It can be concluded that Tyra is not wonderful and Neal is not cultural once knowing that Lewis is not expensive.\n(∃x (Able(x))) → (¬Expensive(clarence)) ::: If there is someone who is able, then Clarence is not expensive.\n(∀x ((¬Cultural(x) ∧ Wonderful(x))) → (Jittery(x))) ::: If someone who is not cultural is also wonderful, then he is jittery.\n(¬Cultural(george)) → (Jittery(lewis)) ::: It can be concluded that George is not cultural once knowing that Lewis is jittery.\n(∃x (¬Jittery(x))) → (Expensive(clarence) ∧ Cultural(neal)) ::: If there is at least one people who is not jittery, then Clarence is expensive and Neal is cultural.\n(¬Cultural(x) ∧ ¬Able(x)) ↔ (¬Expensive(x)) ::: Someone being neither cultural nor able is equivalent to being not expensive.\n",
            "First-Order-Logic Question": "Jittery(tyra) ::: Tyra is jittery."
        },
        "gram_prog": {
            "First-Order-Logic Rules": "¬Wonderful(neal) ::: Neal is not wonderful.\nFat(janine) ::: Janine is fat.\nCultural(tyra) ::: Tyra is cultural.\nJittery(lewis) ::: Lewis is jittery.\nJittery(george) ::: George is jittery.\n¬Able(neal) ::: Neal is not able.\nExpensive(neal) ::: Neal is expensive.\nFat(george) ::: George is fat.\n¬Expensive(tyra) ::: Tyra is not expensive.\nAble(clarence) ::: Clarence is able.\n¬Fat(clarence) ::: Clarence is not fat.\n¬Jittery(neal) ::: Neal is not jittery.\n¬(Accurate(x)→Fresh(x)) ::: If someone who is able is also fat, then he is not expensive.\n(∃x (Jittery(x) ∨ Expensive(x))) → (¬Cultural(george)) ::: If there is at least one people who is jittery or expensive, then George is not cultural.\n(Expensive(neal)) → ((¬Jittery(tyra) ∧ Wonderful(janine))) ::: Neal being expensive implies that Tyra is not jittery and Janine is wonderful.\n(¬Wonderful(neal)) ↔ (Able(janine)) ::: If Neal is not wonderful, then Janine is able, and vice versa.\n(∃x (¬Able(x))) → (¬Wonderful(barry) ∧ ¬Jittery(clarence)) ::: If there is at least one people who is not able, then Barry is not wonderful and Clarence is not jittery.\n(∀x (Fat(x))) ↔ (¬Jittery(x)) ::: Someone is fat if and only if he is not jittery.\n(¬Expensive(lewis)) → (¬Cultural(tyra) ∧ ¬Wonderful(neal)) ::: It can be concluded that Tyra is not wonderful and Neal is not cultural once knowing that Lewis is not expensive.\n(∃x (Able(x))) → (¬Expensive(clarence)) ::: If there is someone who is able, then Clarence is not expensive.\n(∀x ((¬Cultural(x) ∧ Wonderful(x))) → (Jittery(x))) ::: If someone who is not cultural is also wonderful, then he is jittery.\n(¬Cultural(george)) → (Jittery(lewis)) ::: It can be concluded that George is not cultural once knowing that Lewis is jittery.\n(∃x (¬Jittery(x))) → (Expensive(clarence) ∧ Cultural(neal)) ::: If there is at least one people who is not jittery, then Clarence is expensive and Neal is cultural.\n(¬Cultural(x) ∧ ¬Able(x)) ↔ (¬Expensive(x)) ::: Someone being neither cultural nor able is equivalent to being not expensive.\n",
            "First-Order-Logic Question": "Jittery(tyra) ::: Tyra is jittery."
        },
        "diff": [
            {
                "raw": "(∀x ((Able(x) ∧ Fat(x))) → (¬Expensive(x)) ::: If someone who is able is also fat, then he is not expensive.",
                "gram": "¬(Accurate(x)→Fresh(x)) ::: If someone who is able is also fat, then he is not expensive."
            }
        ],
        "answer": "B",
        "grammar_answer": "A",
        "manual_prog": {
            "First-Order-Logic Rules": "¬Wonderful(neal) ::: Neal is not wonderful.\nFat(janine) ::: Janine is fat.\nCultural(tyra) ::: Tyra is cultural.\nJittery(lewis) ::: Lewis is jittery.\nJittery(george) ::: George is jittery.\n¬Able(neal) ::: Neal is not able.\nExpensive(neal) ::: Neal is expensive.\nFat(george) ::: George is fat.\n¬Expensive(tyra) ::: Tyra is not expensive.\nAble(clarence) ::: Clarence is able.\n¬Fat(clarence) ::: Clarence is not fat.\n¬Jittery(neal) ::: Neal is not jittery.\n(∀x ((Able(x) ∧ Fat(x))) → (¬Expensive(x))) ::: If someone who is able is also fat, then he is not expensive.\n(∃x (Jittery(x) ∨ Expensive(x))) → (¬Cultural(george)) ::: If there is at least one people who is jittery or expensive, then George is not cultural.\n(Expensive(neal)) → ((¬Jittery(tyra) ∧ Wonderful(janine))) ::: Neal being expensive implies that Tyra is not jittery and Janine is wonderful.\n(¬Wonderful(neal)) ↔ (Able(janine)) ::: If Neal is not wonderful, then Janine is able, and vice versa.\n(∃x (¬Able(x))) → (¬Wonderful(barry) ∧ ¬Jittery(clarence)) ::: If there is at least one people who is not able, then Barry is not wonderful and Clarence is not jittery.\n(∀x (Fat(x))) ↔ (¬Jittery(x)) ::: Someone is fat if and only if he is not jittery.\n(¬Expensive(lewis)) → (¬Cultural(tyra) ∧ ¬Wonderful(neal)) ::: It can be concluded that Tyra is not wonderful and Neal is not cultural once knowing that Lewis is not expensive.\n(∃x (Able(x))) → (¬Expensive(clarence)) ::: If there is someone who is able, then Clarence is not expensive.\n(∀x ((¬Cultural(x) ∧ Wonderful(x))) → (Jittery(x))) ::: If someone who is not cultural is also wonderful, then he is jittery.\n(¬Cultural(george)) → (Jittery(lewis)) ::: It can be concluded that George is not cultural once knowing that Lewis is jittery.\n(∃x (¬Jittery(x))) → (Expensive(clarence) ∧ Cultural(neal)) ::: If there is at least one people who is not jittery, then Clarence is expensive and Neal is cultural.\n(¬Cultural(x) ∧ ¬Able(x)) ↔ (¬Expensive(x)) ::: Someone being neither cultural nor able is equivalent to being not expensive.\n",
            "First-Order-Logic Question": "Jittery(tyra) ::: Tyra is jittery."
        },
        "fixed": true
    },
    {
        "id": 1351,
        "raw_prog": {
            "First-Order-Logic Rules": "¬New(howard) ::: Howard is not new.\nNew(cara) ::: Cara is new.\n¬Granite(howard) ::: Howard is not granite.\n¬Granite(luka) ::: Luka is not granite.\nComfortable(christopher) ::: Christopher is comfortable.\n¬Soft(blaine) ::: Blaine is not soft.\n¬Cheap(blaine) ::: Blaine is not cheap.\nComfortable(luka) ::: Luka is comfortable.\nShiny(algernon) ::: Algernon is shiny.\nSoft(howard) ::: Howard is soft.\nShiny(cara) ::: Cara is shiny.\nGranite(cara) ::: Cara is granite.\n((¬Cheap(algernon)) ↔ (¬Comfortable(howard))) ::: Algernon is not cheap if and only if Howard is not comfortable.\n((Cheap(x) ∧ Comfortable(x)) ↔ Soft(x)) ::: Someone is cheap and comfortable if and only if he is soft.\n((Comfortable(x) ∨ New(x)) ↔ (¬Cheap(x) ∧ ¬Granite(x))) ::: Someone who is comfortable or new is always not cheap and not granite.\n((Soft(x)) → (Comfortable(x) ∧ Cheap(x))) ::: As long as someone is soft, he is comfortable and cheap.\n((Shiny(cara)) ↔ ((¬New(cara)) ∧ Comfortable(cara))) ::: Cara is shiny if and only if Cara is not new and Cara is comfortable.\n((¬Soft(christopher)) → ((¬Comfortable(graciela) ∧ Cheap(graciela))) ∨ ((¬Cheap(graciela) ∧ Comfortable(graciela))) ::: If Christopher is not soft, then Graciela is not comfortable and Graciela is cheap, and vice versa.\n((¬New(x) ∧ ¬Soft(x)) ↔ (Shiny(x) ∧ Comfortable(x))) ::: Someone being neither new nor soft is equivalent to being shiny and comfortable.\n((Soft(x)) → (New(howard))) ::: If there is someone who is soft, then Howard is new.\n((Shiny(howard))) → ((¬Soft(howard))) ::: It can be concluded that Howard is not soft and Christopher is new once knowing that Howard is shiny.\n((Cheap(graciela) ∧ ¬Soft(christopher)) → (¬New(cara))) ::: If Graciela is cheap and Christopher is not soft, then Cara is not new.\n((¬New(graciela)) ↔ (¬Granite(howard))) ::: Graciela being not new is equivalent to Howard being not granite.\n(∃x (Soft(x) ∧ ¬Comfortable(x))) → (Granite(blaine)) ::: If there is at least one people who is both soft and not comfortable, then Blaine is granite.\n",
            "First-Order-Logic Question": "New(graciela) ::: Graciela is new."
        },
        "gram_prog": {
            "First-Order-Logic Rules": "¬New(howard) ::: Howard is not new.\nNew(cara) ::: Cara is new.\n¬Granite(howard) ::: Howard is not granite.\n¬Granite(luka) ::: Luka is not granite.\nComfortable(christopher) ::: Christopher is comfortable.\n¬Soft(blaine) ::: Blaine is not soft.\n¬Cheap(blaine) ::: Blaine is not cheap.\nComfortable(luka) ::: Luka is comfortable.\nShiny(algernon) ::: Algernon is shiny.\nSoft(howard) ::: Howard is soft.\nShiny(cara) ::: Cara is shiny.\nGranite(cara) ::: Cara is granite.\n((¬Cheap(algernon)) ↔ (¬Comfortable(howard))) ::: Algernon is not cheap if and only if Howard is not comfortable.\n((Cheap(x) ∧ Comfortable(x)) ↔ Soft(x)) ::: Someone is cheap and comfortable if and only if he is soft.\n((Comfortable(x) ∨ New(x)) ↔ (¬Cheap(x) ∧ ¬Granite(x))) ::: Someone who is comfortable or new is always not cheap and not granite.\n((Soft(x)) → (Comfortable(x) ∧ Cheap(x))) ::: As long as someone is soft, he is comfortable and cheap.\n((Shiny(cara)) ↔ ((¬New(cara)) ∧ Comfortable(cara))) ::: Cara is shiny if and only if Cara is not new and Cara is comfortable.\n¬Serious(x)→((¬Fresh(x))) ::: If Christopher is not soft, then Graciela is not comfortable and Graciela is cheap, and vice versa.\n((¬New(x) ∧ ¬Soft(x)) ↔ (Shiny(x) ∧ Comfortable(x))) ::: Someone being neither new nor soft is equivalent to being shiny and comfortable.\n((Soft(x)) → (New(howard))) ::: If there is someone who is soft, then Howard is new.\n((Shiny(howard))) → ((¬Soft(howard))) ::: It can be concluded that Howard is not soft and Christopher is new once knowing that Howard is shiny.\n((Cheap(graciela) ∧ ¬Soft(christopher)) → (¬New(cara))) ::: If Graciela is cheap and Christopher is not soft, then Cara is not new.\n((¬New(graciela)) ↔ (¬Granite(howard))) ::: Graciela being not new is equivalent to Howard being not granite.\n(∃x (Soft(x) ∧ ¬Comfortable(x))) → (Granite(blaine)) ::: If there is at least one people who is both soft and not comfortable, then Blaine is granite.\n",
            "First-Order-Logic Question": "New(graciela) ::: Graciela is new."
        },
        "diff": [
            {
                "raw": "((¬Soft(christopher)) → ((¬Comfortable(graciela) ∧ Cheap(graciela))) ∨ ((¬Cheap(graciela) ∧ Comfortable(graciela))) ::: If Christopher is not soft, then Graciela is not comfortable and Graciela is cheap, and vice versa.",
                "gram": "¬Serious(x)→((¬Fresh(x))) ::: If Christopher is not soft, then Graciela is not comfortable and Graciela is cheap, and vice versa."
            }
        ],
        "answer": "B",
        "grammar_answer": "A",
        "manual_prog": {
            "First-Order-Logic Rules": "¬New(howard) ::: Howard is not new.\nNew(cara) ::: Cara is new.\n¬Granite(howard) ::: Howard is not granite.\n¬Granite(luka) ::: Luka is not granite.\nComfortable(christopher) ::: Christopher is comfortable.\n¬Soft(blaine) ::: Blaine is not soft.\n¬Cheap(blaine) ::: Blaine is not cheap.\nComfortable(luka) ::: Luka is comfortable.\nShiny(algernon) ::: Algernon is shiny.\nSoft(howard) ::: Howard is soft.\nShiny(cara) ::: Cara is shiny.\nGranite(cara) ::: Cara is granite.\n((¬Cheap(algernon)) ↔ (¬Comfortable(howard))) ::: Algernon is not cheap if and only if Howard is not comfortable.\n((Cheap(x) ∧ Comfortable(x)) ↔ Soft(x)) ::: Someone is cheap and comfortable if and only if he is soft.\n((Comfortable(x) ∨ New(x)) ↔ (¬Cheap(x) ∧ ¬Granite(x))) ::: Someone who is comfortable or new is always not cheap and not granite.\n((Soft(x)) → (Comfortable(x) ∧ Cheap(x))) ::: As long as someone is soft, he is comfortable and cheap.\n((Shiny(cara)) ↔ ((¬New(cara)) ∧ Comfortable(cara))) ::: Cara is shiny if and only if Cara is not new and Cara is comfortable.\n((¬Soft(christopher)) → ((¬Comfortable(graciela) ∧ Cheap(graciela))) ∨ ((¬Cheap(graciela) ∧ Comfortable(graciela)))) ::: If Christopher is not soft, then Graciela is not comfortable and Graciela is cheap, and vice versa.\n((¬New(x) ∧ ¬Soft(x)) ↔ (Shiny(x) ∧ Comfortable(x))) ::: Someone being neither new nor soft is equivalent to being shiny and comfortable.\n((Soft(x)) → (New(howard))) ::: If there is someone who is soft, then Howard is new.\n((Shiny(howard))) → ((¬Soft(howard))) ::: It can be concluded that Howard is not soft and Christopher is new once knowing that Howard is shiny.\n((Cheap(graciela) ∧ ¬Soft(christopher)) → (¬New(cara))) ::: If Graciela is cheap and Christopher is not soft, then Cara is not new.\n((¬New(graciela)) ↔ (¬Granite(howard))) ::: Graciela being not new is equivalent to Howard being not granite.\n(∃x (Soft(x) ∧ ¬Comfortable(x))) → (Granite(blaine)) ::: If there is at least one people who is both soft and not comfortable, then Blaine is granite.\n",
            "First-Order-Logic Question": "New(graciela) ::: Graciela is new."
        },
        "fixed": true
    },
    {
        "id": 1358,
        "raw_prog": {
            "First-Order-Logic Rules": "¬New(howard) ::: Howard is not new.\nNew(cara) ::: Cara is new.\n¬Granite(howard) ::: Howard is not granite.\n¬Granite(luka) ::: Luka is not granite.\nComfortable(christopher) ::: Christopher is comfortable.\n¬Soft(blaine) ::: Blaine is not soft.\n¬Cheap(blaine) ::: Blaine is not cheap.\nComfortable(luka) ::: Luka is comfortable.\nShiny(algernon) ::: Algernon is shiny.\nSoft(howard) ::: Howard is soft.\nShiny(cara) ::: Cara is shiny.\nGranite(cara) ::: Cara is granite.\n((¬Cheap(algernon))) ↔ ((¬Comfortable(howard))) ::: Algernon is not cheap if and only if Howard is not comfortable.\n(∀x (Cheap(x) ∧ Comfortable(x))) ↔ (∀x (Soft(x))) ::: Someone is cheap and comfortable if and only if he is soft.\n(∀x (Comfortable(x) ∨ New(x))) → (∀x (¬Cheap(x) ∧ ¬Granite(x))) ::: Someone who is comfortable or new is always not cheap and not granite.\n(∀x (Soft(x))) → (∀x (Comfortable(x) ∧ Cheap(x))) ::: As long as someone is soft, he is comfortable and cheap.\n((Shiny(cara))) ↔ ((¬New(cara) ∧ Comfortable(cara))) ::: Cara is shiny if and only if Cara is not new and Cara is comfortable.\n((¬Soft(christopher))) → ((¬Comfortable(graciela) ∧ Cheap(graciela))) ::: If Christopher is not soft, then Graciela is not comfortable and Graciela is cheap, and vice versa.\n(∀x (¬New(x) ∧ ¬Soft(x))) ↔ (∀x (Shiny(x) ∧ Comfortable(x))) ::: Someone being neither new nor soft is equivalent to being shiny and comfortable.\n(∃x (Soft(x))) → (New(howard)) ::: If there is someone who is soft, then Howard is new.\n((Shiny(howard))) → ((¬Soft(howard) ∧ New(christopher))) ::: It can be concluded that Howard is not soft and Christopher is new once knowing that Howard is shiny.\n((Cheap(graciela) ∧ ¬Soft(christopher)) → (¬New(cara)) ::: If Graciela is cheap and Christopher is not soft, then Cara is not new.\n((¬New(graciela))) ↔ ((¬Granite(howard))) ::: Graciela being not new is equivalent to Howard being not granite.\n(∃x (Soft(x) ∧ ¬Comfortable(x))) → (Granite(blaine)) ::: If there is at least one people who is both soft and not comfortable, then Blaine is granite.\n",
            "First-Order-Logic Question": "Soft(cara) ::: Cara is soft."
        },
        "gram_prog": {
            "First-Order-Logic Rules": "¬New(howard) ::: Howard is not new.\nNew(cara) ::: Cara is new.\n¬Granite(howard) ::: Howard is not granite.\n¬Granite(luka) ::: Luka is not granite.\nComfortable(christopher) ::: Christopher is comfortable.\n¬Soft(blaine) ::: Blaine is not soft.\n¬Cheap(blaine) ::: Blaine is not cheap.\nComfortable(luka) ::: Luka is comfortable.\nShiny(algernon) ::: Algernon is shiny.\nSoft(howard) ::: Howard is soft.\nShiny(cara) ::: Cara is shiny.\nGranite(cara) ::: Cara is granite.\n((¬Cheap(algernon))) ↔ ((¬Comfortable(howard))) ::: Algernon is not cheap if and only if Howard is not comfortable.\n(∀x (Cheap(x) ∧ Comfortable(x))) ↔ (∀x (Soft(x))) ::: Someone is cheap and comfortable if and only if he is soft.\n(∀x (Comfortable(x) ∨ New(x))) → (∀x (¬Cheap(x) ∧ ¬Granite(x))) ::: Someone who is comfortable or new is always not cheap and not granite.\n(∀x (Soft(x))) → (∀x (Comfortable(x) ∧ Cheap(x))) ::: As long as someone is soft, he is comfortable and cheap.\n((Shiny(cara))) ↔ ((¬New(cara) ∧ Comfortable(cara))) ::: Cara is shiny if and only if Cara is not new and Cara is comfortable.\n((¬Soft(christopher))) → ((¬Comfortable(graciela) ∧ Cheap(graciela))) ::: If Christopher is not soft, then Graciela is not comfortable and Graciela is cheap, and vice versa.\n(∀x (¬New(x) ∧ ¬Soft(x))) ↔ (∀x (Shiny(x) ∧ Comfortable(x))) ::: Someone being neither new nor soft is equivalent to being shiny and comfortable.\n(∃x (Soft(x))) → (New(howard)) ::: If there is someone who is soft, then Howard is new.\n((Shiny(howard))) → ((¬Soft(howard) ∧ New(christopher))) ::: It can be concluded that Howard is not soft and Christopher is new once knowing that Howard is shiny.\n¬(Fresh(x)→(Serious(x))) ::: If Graciela is cheap and Christopher is not soft, then Cara is not new.\n((¬New(graciela))) ↔ ((¬Granite(howard))) ::: Graciela being not new is equivalent to Howard being not granite.\n(∃x (Soft(x) ∧ ¬Comfortable(x))) → (Granite(blaine)) ::: If there is at least one people who is both soft and not comfortable, then Blaine is granite.\n",
            "First-Order-Logic Question": "Soft(cara) ::: Cara is soft."
        },
        "diff": [
            {
                "raw": "((Cheap(graciela) ∧ ¬Soft(christopher)) → (¬New(cara)) ::: If Graciela is cheap and Christopher is not soft, then Cara is not new.",
                "gram": "¬(Fresh(x)→(Serious(x))) ::: If Graciela is cheap and Christopher is not soft, then Cara is not new."
            }
        ],
        "answer": "B",
        "grammar_answer": "A",
        "manual_prog": {
            "First-Order-Logic Rules": "¬New(howard) ::: Howard is not new.\nNew(cara) ::: Cara is new.\n¬Granite(howard) ::: Howard is not granite.\n¬Granite(luka) ::: Luka is not granite.\nComfortable(christopher) ::: Christopher is comfortable.\n¬Soft(blaine) ::: Blaine is not soft.\n¬Cheap(blaine) ::: Blaine is not cheap.\nComfortable(luka) ::: Luka is comfortable.\nShiny(algernon) ::: Algernon is shiny.\nSoft(howard) ::: Howard is soft.\nShiny(cara) ::: Cara is shiny.\nGranite(cara) ::: Cara is granite.\n((¬Cheap(algernon))) ↔ ((¬Comfortable(howard))) ::: Algernon is not cheap if and only if Howard is not comfortable.\n(∀x (Cheap(x) ∧ Comfortable(x))) ↔ (∀x (Soft(x))) ::: Someone is cheap and comfortable if and only if he is soft.\n(∀x (Comfortable(x) ∨ New(x))) → (∀x (¬Cheap(x) ∧ ¬Granite(x))) ::: Someone who is comfortable or new is always not cheap and not granite.\n(∀x (Soft(x))) → (∀x (Comfortable(x) ∧ Cheap(x))) ::: As long as someone is soft, he is comfortable and cheap.\n((Shiny(cara))) ↔ ((¬New(cara) ∧ Comfortable(cara))) ::: Cara is shiny if and only if Cara is not new and Cara is comfortable.\n((¬Soft(christopher))) → ((¬Comfortable(graciela) ∧ Cheap(graciela))) ::: If Christopher is not soft, then Graciela is not comfortable and Graciela is cheap, and vice versa.\n(∀x (¬New(x) ∧ ¬Soft(x))) ↔ (∀x (Shiny(x) ∧ Comfortable(x))) ::: Someone being neither new nor soft is equivalent to being shiny and comfortable.\n(∃x (Soft(x))) → (New(howard)) ::: If there is someone who is soft, then Howard is new.\n((Shiny(howard))) → ((¬Soft(howard) ∧ New(christopher))) ::: It can be concluded that Howard is not soft and Christopher is new once knowing that Howard is shiny.\n((Cheap(graciela) ∧ ¬Soft(christopher)) → (¬New(cara))) ::: If Graciela is cheap and Christopher is not soft, then Cara is not new.\n((¬New(graciela))) ↔ ((¬Granite(howard))) ::: Graciela being not new is equivalent to Howard being not granite.\n(∃x (Soft(x) ∧ ¬Comfortable(x))) → (Granite(blaine)) ::: If there is at least one people who is both soft and not comfortable, then Blaine is granite.\n",
            "First-Order-Logic Question": "Soft(cara) ::: Cara is soft."
        },
        "fixed": true
    },
    {
        "id": 1397,
        "raw_prog": {
            "First-Order-Logic Rules": "¬Substantial(tristin) ::: Tristin is not substantial.\nFancy(julie) ::: Julie is fancy.\nHappy(jasper) ::: Jasper is happy.\nFancy(george) ::: George is fancy.\n¬Happy(lyndon) ::: Lyndon is not happy.\nFancy(jasper) ::: Jasper is fancy.\nSubstantial(george) ::: George is substantial.\nPoor(lyndon) ::: Lyndon is poor.\n¬Fancy(tristin) ::: Tristin is not fancy.\nHappy(george) ::: George is happy.\nJittery(george) ::: George is jittery.\nJittery(julie) ::: Julie is jittery.\n((Substantial(george))) → ((¬Poor(tristin))) ::: It can be concluded that Tristin is not poor once knowing that George is substantial.\n(∀x ((Poor(x) ∧ ¬New(x)) ↔ (¬Happy(x))) ::: Someone is poor and not new if and only if he is not happy.\n(∃x (¬New(x))) → ((¬Jittery(dan) ∧ Fancy(lyndon))) ::: If there is someone who is not new, then Dan is not jittery and Lyndon is fancy.\n((¬Poor(jack) ∨ ¬Substantial(dan))) → ((¬Fancy(tristin))) ::: Jack being not poor or Dan being not substantial implies that Tristin is not fancy.\n(∀x (Fancy(x))) → (Jittery(x)) ::: If someone is fancy, then he is jittery.\n(∃x (¬Substantial(x))) → ((Jittery(jasper) ∧ ¬New(jasper))) ::: If there is someone who is not substantial, then Jasper is jittery and Jasper is not new.\n(∀x ((¬Fancy(x) ∧ ¬Substantial(x)) ↔ ¬New(x))) ::: Someone is not fancy and not substantial if and only if he is not new.\n((New(jack) ∨ Fancy(jasper))) → ((¬Poor(lyndon))) ::: Jack being new or Jasper being fancy implies that Lyndon is not poor.\n(∃x ((¬Happy(x)) ∧ (¬Poor(x)))) → (Fancy(george)) ::: If there is at least one people who is neither happy nor poor, then George is fancy.\n((¬Fancy(lyndon) ∧ ¬New(tristin))) → (Poor(george)) ::: It can be concluded that George is poor once knowing that Lyndon is not fancy and Tristin is not new.\n((Fancy(tristin))) ↔ (Happy(julie)) ::: Tristin is fancy if and only if Julie is happy.\n(∃x ((Jittery(x) ∧ Happy(x))) → (¬Fancy(x))) ::: If someone is both jittery and happy, then he is not fancy.\n",
            "First-Order-Logic Question": "¬Poor(jasper) ::: Jasper is not poor."
        },
        "gram_prog": {
            "First-Order-Logic Rules": "¬Substantial(tristin) ::: Tristin is not substantial.\nFancy(julie) ::: Julie is fancy.\nHappy(jasper) ::: Jasper is happy.\nFancy(george) ::: George is fancy.\n¬Happy(lyndon) ::: Lyndon is not happy.\nFancy(jasper) ::: Jasper is fancy.\nSubstantial(george) ::: George is substantial.\nPoor(lyndon) ::: Lyndon is poor.\n¬Fancy(tristin) ::: Tristin is not fancy.\nHappy(george) ::: George is happy.\nJittery(george) ::: George is jittery.\nJittery(julie) ::: Julie is jittery.\n((Substantial(george))) → ((¬Poor(tristin))) ::: It can be concluded that Tristin is not poor once knowing that George is substantial.\n∀x((Serious(x)→Fresh(x))) ::: Someone is poor and not new if and only if he is not happy.\n(∃x (¬New(x))) → ((¬Jittery(dan) ∧ Fancy(lyndon))) ::: If there is someone who is not new, then Dan is not jittery and Lyndon is fancy.\n((¬Poor(jack) ∨ ¬Substantial(dan))) → ((¬Fancy(tristin))) ::: Jack being not poor or Dan being not substantial implies that Tristin is not fancy.\n(∀x (Fancy(x))) → (Jittery(x)) ::: If someone is fancy, then he is jittery.\n(∃x (¬Substantial(x))) → ((Jittery(jasper) ∧ ¬New(jasper))) ::: If there is someone who is not substantial, then Jasper is jittery and Jasper is not new.\n(∀x ((¬Fancy(x) ∧ ¬Substantial(x)) ↔ ¬New(x))) ::: Someone is not fancy and not substantial if and only if he is not new.\n((New(jack) ∨ Fancy(jasper))) → ((¬Poor(lyndon))) ::: Jack being new or Jasper being fancy implies that Lyndon is not poor.\n(∃x ((¬Happy(x)) ∧ (¬Poor(x)))) → (Fancy(george)) ::: If there is at least one people who is neither happy nor poor, then George is fancy.\n((¬Fancy(lyndon) ∧ ¬New(tristin))) → (Poor(george)) ::: It can be concluded that George is poor once knowing that Lyndon is not fancy and Tristin is not new.\n((Fancy(tristin))) ↔ (Happy(julie)) ::: Tristin is fancy if and only if Julie is happy.\n(∃x ((Jittery(x) ∧ Happy(x))) → (¬Fancy(x))) ::: If someone is both jittery and happy, then he is not fancy.\n",
            "First-Order-Logic Question": "¬Poor(jasper) ::: Jasper is not poor."
        },
        "diff": [
            {
                "raw": "(∀x ((Poor(x) ∧ ¬New(x)) ↔ (¬Happy(x))) ::: Someone is poor and not new if and only if he is not happy.",
                "gram": "∀x((Serious(x)→Fresh(x))) ::: Someone is poor and not new if and only if he is not happy."
            }
        ],
        "answer": "C",
        "grammar_answer": "A",
        "manual_prog": {
            "First-Order-Logic Rules": "¬Substantial(tristin) ::: Tristin is not substantial.\nFancy(julie) ::: Julie is fancy.\nHappy(jasper) ::: Jasper is happy.\nFancy(george) ::: George is fancy.\n¬Happy(lyndon) ::: Lyndon is not happy.\nFancy(jasper) ::: Jasper is fancy.\nSubstantial(george) ::: George is substantial.\nPoor(lyndon) ::: Lyndon is poor.\n¬Fancy(tristin) ::: Tristin is not fancy.\nHappy(george) ::: George is happy.\nJittery(george) ::: George is jittery.\nJittery(julie) ::: Julie is jittery.\n((Substantial(george))) → ((¬Poor(tristin))) ::: It can be concluded that Tristin is not poor once knowing that George is substantial.\n(∀x ((Poor(x) ∧ ¬New(x)) ↔ (¬Happy(x)))) ::: Someone is poor and not new if and only if he is not happy.\n(∃x (¬New(x))) → ((¬Jittery(dan) ∧ Fancy(lyndon))) ::: If there is someone who is not new, then Dan is not jittery and Lyndon is fancy.\n((¬Poor(jack) ∨ ¬Substantial(dan))) → ((¬Fancy(tristin))) ::: Jack being not poor or Dan being not substantial implies that Tristin is not fancy.\n(∀x (Fancy(x))) → (Jittery(x)) ::: If someone is fancy, then he is jittery.\n(∃x (¬Substantial(x))) → ((Jittery(jasper) ∧ ¬New(jasper))) ::: If there is someone who is not substantial, then Jasper is jittery and Jasper is not new.\n(∀x ((¬Fancy(x) ∧ ¬Substantial(x)) ↔ ¬New(x))) ::: Someone is not fancy and not substantial if and only if he is not new.\n((New(jack) ∨ Fancy(jasper))) → ((¬Poor(lyndon))) ::: Jack being new or Jasper being fancy implies that Lyndon is not poor.\n(∃x ((¬Happy(x)) ∧ (¬Poor(x)))) → (Fancy(george)) ::: If there is at least one people who is neither happy nor poor, then George is fancy.\n((¬Fancy(lyndon) ∧ ¬New(tristin))) → (Poor(george)) ::: It can be concluded that George is poor once knowing that Lyndon is not fancy and Tristin is not new.\n((Fancy(tristin))) ↔ (Happy(julie)) ::: Tristin is fancy if and only if Julie is happy.\n(∃x ((Jittery(x) ∧ Happy(x))) → (¬Fancy(x))) ::: If someone is both jittery and happy, then he is not fancy.\n",
            "First-Order-Logic Question": "¬Poor(jasper) ::: Jasper is not poor."
        },
        "fixed": true
    },
    {
        "id": 138,
        "raw_prog": {
            "First-Order-Logic Rules": "¬Bewildered(abel) ::: Abel is not bewildered.\nCultural(aaron) ::: Aaron is cultural.\nCultural(seymour) ::: Seymour is cultural.\nAble(abel) ::: Abel is able.\nJolly(maurice) ::: Maurice is jolly.\nBewildered(cara) ::: Cara is bewildered.\nCultural(maurice) ::: Maurice is cultural.\nCultural(abel) ::: Abel is cultural.\n¬Jolly(algernon) ::: Algernon is not jolly.\n¬New(algernon) ::: Algernon is not new.\nBewildered(seymour) ::: Seymour is bewildered.\nNew(maurice) ::: Maurice is new.\n((¬Jolly(algernon) ∨ Able(maurice))) → (Cultural(cara)) ::: If Algernon is not jolly or Maurice is able, then Cara is cultural.\n(∃x (Bewildered(x) ∧ ¬Octagonal(x))) → (Jolly(algernon)) ::: If there is at least one people who is both bewildered and not octagonal, then Algernon is jolly.\n(∀x (¬New(x))) → (Bewildered(x) ∧ Cultural(x)) ::: Someone who is not new is always both bewildered and cultural.\n((Bewildered(abel))) ↔ (¬Jolly(algernon)) ::: If Abel is bewildered, then Algernon is not jolly, and vice versa.\n(∃x (¬New(x))) → (¬Jolly(lesley) ∧ Octagonal(lesley)) ::: If there is someone who is not new, then Lesley is not jolly and Lesley is octagonal.\n((Jolly(x) ∧ ¬Bewildered(x))) ↔ (¬Cultural(x)) ::: If someone is both jolly and not bewildered, then he is not cultural.\n(∃x (New(x) ∨ ¬Able(x))) → (¬Cultural(cara)) ::: If there is someone who is either new or not able, then Cara is not cultural.\n((¬Bewildered(x) ∧ ¬Able(x))) ↔ (Jolly(x)) ::: Someone being neither bewildered nor able is equivalent to being jolly.\n((Octagonal(x) ∧ ¬Cultural(x))) ↔ (Jolly(x) ∧ Bewildered(x)) ::: If someone is octagonal and not cultural, then he is both jolly and bewildered, and vice versa.\n(∃x (¬Bewildered(x))) → (Jolly(cara)) ::: If there is someone who is not bewildered, then Cara is jolly.\n(∀x ((¬Jolly(x) ∨ ¬Able(x))) → (New(x)) ::: Someone who is either not jolly or not able is always new.\n(∃x (Bewildered(x))) → (¬Cultural(lesley) ∧ Octagonal(seymour)) ::: If there is at least one people who is bewildered, then Lesley is not cultural and Seymour is octagonal.\n",
            "First-Order-Logic Question": "Able(seymour) ::: Seymour is able."
        },
        "gram_prog": {
            "First-Order-Logic Rules": "¬Bewildered(abel) ::: Abel is not bewildered.\nCultural(aaron) ::: Aaron is cultural.\nCultural(seymour) ::: Seymour is cultural.\nAble(abel) ::: Abel is able.\nJolly(maurice) ::: Maurice is jolly.\nBewildered(cara) ::: Cara is bewildered.\nCultural(maurice) ::: Maurice is cultural.\nCultural(abel) ::: Abel is cultural.\n¬Jolly(algernon) ::: Algernon is not jolly.\n¬New(algernon) ::: Algernon is not new.\nBewildered(seymour) ::: Seymour is bewildered.\nNew(maurice) ::: Maurice is new.\n((¬Jolly(algernon) ∨ Able(maurice))) → (Cultural(cara)) ::: If Algernon is not jolly or Maurice is able, then Cara is cultural.\n(∃x (Bewildered(x) ∧ ¬Octagonal(x))) → (Jolly(algernon)) ::: If there is at least one people who is both bewildered and not octagonal, then Algernon is jolly.\n(∀x (¬New(x))) → (Bewildered(x) ∧ Cultural(x)) ::: Someone who is not new is always both bewildered and cultural.\n((Bewildered(abel))) ↔ (¬Jolly(algernon)) ::: If Abel is bewildered, then Algernon is not jolly, and vice versa.\n(∃x (¬New(x))) → (¬Jolly(lesley) ∧ Octagonal(lesley)) ::: If there is someone who is not new, then Lesley is not jolly and Lesley is octagonal.\n((Jolly(x) ∧ ¬Bewildered(x))) ↔ (¬Cultural(x)) ::: If someone is both jolly and not bewildered, then he is not cultural.\n(∃x (New(x) ∨ ¬Able(x))) → (¬Cultural(cara)) ::: If there is someone who is either new or not able, then Cara is not cultural.\n((¬Bewildered(x) ∧ ¬Able(x))) ↔ (Jolly(x)) ::: Someone being neither bewildered nor able is equivalent to being jolly.\n((Octagonal(x) ∧ ¬Cultural(x))) ↔ (Jolly(x) ∧ Bewildered(x)) ::: If someone is octagonal and not cultural, then he is both jolly and bewildered, and vice versa.\n(∃x (¬Bewildered(x))) → (Jolly(cara)) ::: If there is someone who is not bewildered, then Cara is jolly.\n∀x((¬Jolly(x)∨¬Able(x))) ::: Someone who is either not jolly or not able is always new.\n(∃x (Bewildered(x))) → (¬Cultural(lesley) ∧ Octagonal(seymour)) ::: If there is at least one people who is bewildered, then Lesley is not cultural and Seymour is octagonal.\n",
            "First-Order-Logic Question": "Able(seymour) ::: Seymour is able."
        },
        "diff": [
            {
                "raw": "(∀x ((¬Jolly(x) ∨ ¬Able(x))) → (New(x)) ::: Someone who is either not jolly or not able is always new.",
                "gram": "∀x((¬Jolly(x)∨¬Able(x))) ::: Someone who is either not jolly or not able is always new."
            }
        ],
        "answer": "C",
        "grammar_answer": "A",
        "manual_prog": {
            "First-Order-Logic Rules": "¬Bewildered(abel) ::: Abel is not bewildered.\nCultural(aaron) ::: Aaron is cultural.\nCultural(seymour) ::: Seymour is cultural.\nAble(abel) ::: Abel is able.\nJolly(maurice) ::: Maurice is jolly.\nBewildered(cara) ::: Cara is bewildered.\nCultural(maurice) ::: Maurice is cultural.\nCultural(abel) ::: Abel is cultural.\n¬Jolly(algernon) ::: Algernon is not jolly.\n¬New(algernon) ::: Algernon is not new.\nBewildered(seymour) ::: Seymour is bewildered.\nNew(maurice) ::: Maurice is new.\n((¬Jolly(algernon) ∨ Able(maurice))) → (Cultural(cara)) ::: If Algernon is not jolly or Maurice is able, then Cara is cultural.\n(∃x (Bewildered(x) ∧ ¬Octagonal(x))) → (Jolly(algernon)) ::: If there is at least one people who is both bewildered and not octagonal, then Algernon is jolly.\n(∀x (¬New(x))) → (Bewildered(x) ∧ Cultural(x)) ::: Someone who is not new is always both bewildered and cultural.\n((Bewildered(abel))) ↔ (¬Jolly(algernon)) ::: If Abel is bewildered, then Algernon is not jolly, and vice versa.\n(∃x (¬New(x))) → (¬Jolly(lesley) ∧ Octagonal(lesley)) ::: If there is someone who is not new, then Lesley is not jolly and Lesley is octagonal.\n((Jolly(x) ∧ ¬Bewildered(x))) ↔ (¬Cultural(x)) ::: If someone is both jolly and not bewildered, then he is not cultural.\n(∃x (New(x) ∨ ¬Able(x))) → (¬Cultural(cara)) ::: If there is someone who is either new or not able, then Cara is not cultural.\n((¬Bewildered(x) ∧ ¬Able(x))) ↔ (Jolly(x)) ::: Someone being neither bewildered nor able is equivalent to being jolly.\n((Octagonal(x) ∧ ¬Cultural(x))) ↔ (Jolly(x) ∧ Bewildered(x)) ::: If someone is octagonal and not cultural, then he is both jolly and bewildered, and vice versa.\n(∃x (¬Bewildered(x))) → (Jolly(cara)) ::: If there is someone who is not bewildered, then Cara is jolly.\n(∀x ((¬Jolly(x) ∨ ¬Able(x))) → (New(x))) ::: Someone who is either not jolly or not able is always new.\n(∃x (Bewildered(x))) → (¬Cultural(lesley) ∧ Octagonal(seymour)) ::: If there is at least one people who is bewildered, then Lesley is not cultural and Seymour is octagonal.\n",
            "First-Order-Logic Question": "Able(seymour) ::: Seymour is able."
        },
        "fixed": true
    },
    {
        "id": 144,
        "raw_prog": {
            "First-Order-Logic Rules": "¬Able(abel) ::: Abel is not able.\nCultural(aaron) ::: Aaron is cultural.\nCultural(seymour) ::: Seymour is cultural.\nAble(abel) ::: Abel is able.\nJolly(maurice) ::: Maurice is jolly.\nBewildered(cara) ::: Cara is bewildered.\nCultural(maurice) ::: Maurice is cultural.\nCultural(abel) ::: Abel is cultural.\n¬Jolly(algernon) ::: Algernon is not jolly.\n¬New(algernon) ::: Algernon is not new.\nBewildered(seymour) ::: Seymour is bewildered.\nNew(maurice) ::: Maurice is new.\n((¬Jolly(algernon) ∨ Able(maurice))) → (Cultural(cara)) ::: If Algernon is not jolly or Maurice is able, then Cara is cultural.\n(∃x (Bewildered(x) ∧ ¬Octagonal(x))) → (Jolly(algernon)) ::: If there is at least one people who is both bewildered and not octagonal, then Algernon is jolly.\n(∀x (¬New(x))) → (Bewildered(x) ∧ Cultural(x)) ::: Someone who is not new is always both bewildered and cultural.\n((Bewildered(abel))) ↔ (¬Jolly(algernon)) ::: If Abel is bewildered, then Algernon is not jolly, and vice versa.\n(∃x (¬New(x))) → (¬Jolly(lesley) ∧ Octagonal(lesley)) ::: If there is someone who is not new, then Lesley is not jolly and Lesley is octagonal.\n((Jolly(x) ∧ ¬Bewildered(x))) → (¬Cultural(x)) ::: If someone is both jolly and not bewildered, then he is not cultural.\n(∃x (New(x) ∨ ¬Able(x))) → (¬Cultural(cara)) ::: If there is someone who is either new or not able, then Cara is not cultural.\n((¬Bewildered(x) ∧ ¬Able(x))) ↔ (Jolly(x)) ::: Someone being neither bewildered nor able is equivalent to being jolly.\n((Octagonal(x) ∧ ¬Cultural(x))) ↔ ((Jolly(x) ∧ Bewildered(x))) ::: If someone is octagonal and not cultural, then he is both jolly and bewildered, and vice versa.\n(∃x (¬Bewildered(x))) → (Jolly(cara)) ::: If there is someone who is not bewildered, then Cara is jolly.\n(∀x ((¬Jolly(x) ∨ ¬Able(x))) → (New(x)) ::: Someone who is either not jolly or not able is always new.\n(∃x (Bewildered(x))) → (¬Cultural(lesley) ∧ Octagonal(seymour)) ::: If there is at least one people who is bewildered, then Lesley is not cultural and Seymour is octagonal.\n",
            "First-Order-Logic Question": "¬Able(abel) ::: Abel is not able."
        },
        "gram_prog": {
            "First-Order-Logic Rules": "¬Able(abel) ::: Abel is not able.\nCultural(aaron) ::: Aaron is cultural.\nCultural(seymour) ::: Seymour is cultural.\nAble(abel) ::: Abel is able.\nJolly(maurice) ::: Maurice is jolly.\nBewildered(cara) ::: Cara is bewildered.\nCultural(maurice) ::: Maurice is cultural.\nCultural(abel) ::: Abel is cultural.\n¬Jolly(algernon) ::: Algernon is not jolly.\n¬New(algernon) ::: Algernon is not new.\nBewildered(seymour) ::: Seymour is bewildered.\nNew(maurice) ::: Maurice is new.\n((¬Jolly(algernon) ∨ Able(maurice))) → (Cultural(cara)) ::: If Algernon is not jolly or Maurice is able, then Cara is cultural.\n(∃x (Bewildered(x) ∧ ¬Octagonal(x))) → (Jolly(algernon)) ::: If there is at least one people who is both bewildered and not octagonal, then Algernon is jolly.\n(∀x (¬New(x))) → (Bewildered(x) ∧ Cultural(x)) ::: Someone who is not new is always both bewildered and cultural.\n((Bewildered(abel))) ↔ (¬Jolly(algernon)) ::: If Abel is bewildered, then Algernon is not jolly, and vice versa.\n(∃x (¬New(x))) → (¬Jolly(lesley) ∧ Octagonal(lesley)) ::: If there is someone who is not new, then Lesley is not jolly and Lesley is octagonal.\n((Jolly(x) ∧ ¬Bewildered(x))) → (¬Cultural(x)) ::: If someone is both jolly and not bewildered, then he is not cultural.\n(∃x (New(x) ∨ ¬Able(x))) → (¬Cultural(cara)) ::: If there is someone who is either new or not able, then Cara is not cultural.\n((¬Bewildered(x) ∧ ¬Able(x))) ↔ (Jolly(x)) ::: Someone being neither bewildered nor able is equivalent to being jolly.\n((Octagonal(x) ∧ ¬Cultural(x))) ↔ ((Jolly(x) ∧ Bewildered(x))) ::: If someone is octagonal and not cultural, then he is both jolly and bewildered, and vice versa.\n(∃x (¬Bewildered(x))) → (Jolly(cara)) ::: If there is someone who is not bewildered, then Cara is jolly.\n∀x((¬Blue(x)∨¬Serious(x))) ::: Someone who is either not jolly or not able is always new.\n(∃x (Bewildered(x))) → (¬Cultural(lesley) ∧ Octagonal(seymour)) ::: If there is at least one people who is bewildered, then Lesley is not cultural and Seymour is octagonal.\n",
            "First-Order-Logic Question": "¬Able(abel) ::: Abel is not able."
        },
        "diff": [
            {
                "raw": "(∀x ((¬Jolly(x) ∨ ¬Able(x))) → (New(x)) ::: Someone who is either not jolly or not able is always new.",
                "gram": "∀x((¬Blue(x)∨¬Serious(x))) ::: Someone who is either not jolly or not able is always new."
            }
        ],
        "answer": "B",
        "grammar_answer": "A",
        "manual_prog": {
            "First-Order-Logic Rules": "¬Able(abel) ::: Abel is not able.\nCultural(aaron) ::: Aaron is cultural.\nCultural(seymour) ::: Seymour is cultural.\nAble(abel) ::: Abel is able.\nJolly(maurice) ::: Maurice is jolly.\nBewildered(cara) ::: Cara is bewildered.\nCultural(maurice) ::: Maurice is cultural.\nCultural(abel) ::: Abel is cultural.\n¬Jolly(algernon) ::: Algernon is not jolly.\n¬New(algernon) ::: Algernon is not new.\nBewildered(seymour) ::: Seymour is bewildered.\nNew(maurice) ::: Maurice is new.\n((¬Jolly(algernon) ∨ Able(maurice))) → (Cultural(cara)) ::: If Algernon is not jolly or Maurice is able, then Cara is cultural.\n(∃x (Bewildered(x) ∧ ¬Octagonal(x))) → (Jolly(algernon)) ::: If there is at least one people who is both bewildered and not octagonal, then Algernon is jolly.\n(∀x (¬New(x))) → (Bewildered(x) ∧ Cultural(x)) ::: Someone who is not new is always both bewildered and cultural.\n((Bewildered(abel))) ↔ (¬Jolly(algernon)) ::: If Abel is bewildered, then Algernon is not jolly, and vice versa.\n(∃x (¬New(x))) → (¬Jolly(lesley) ∧ Octagonal(lesley)) ::: If there is someone who is not new, then Lesley is not jolly and Lesley is octagonal.\n((Jolly(x) ∧ ¬Bewildered(x))) → (¬Cultural(x)) ::: If someone is both jolly and not bewildered, then he is not cultural.\n(∃x (New(x) ∨ ¬Able(x))) → (¬Cultural(cara)) ::: If there is someone who is either new or not able, then Cara is not cultural.\n((¬Bewildered(x) ∧ ¬Able(x))) ↔ (Jolly(x)) ::: Someone being neither bewildered nor able is equivalent to being jolly.\n((Octagonal(x) ∧ ¬Cultural(x))) ↔ ((Jolly(x) ∧ Bewildered(x))) ::: If someone is octagonal and not cultural, then he is both jolly and bewildered, and vice versa.\n(∃x (¬Bewildered(x))) → (Jolly(cara)) ::: If there is someone who is not bewildered, then Cara is jolly.\n(∀x ((¬Jolly(x) ∨ ¬Able(x))) → (New(x))) ::: Someone who is either not jolly or not able is always new.\n(∃x (Bewildered(x))) → (¬Cultural(lesley) ∧ Octagonal(seymour)) ::: If there is at least one people who is bewildered, then Lesley is not cultural and Seymour is octagonal.\n",
            "First-Order-Logic Question": "¬Able(abel) ::: Abel is not able."
        },
        "fixed": true
    },
    {
        "id": 147,
        "raw_prog": {
            "First-Order-Logic Rules": "¬Bewildered(abel) ::: Abel is not bewildered.\nCultural(aaron) ::: Aaron is cultural.\nCultural(seymour) ::: Seymour is cultural.\nAble(abel) ::: Abel is able.\nJolly(maurice) ::: Maurice is jolly.\nBewildered(cara) ::: Cara is bewildered.\nCultural(maurice) ::: Maurice is cultural.\nCultural(abel) ::: Abel is cultural.\n¬Jolly(algernon) ::: Algernon is not jolly.\n¬New(algernon) ::: Algernon is not new.\nBewildered(seymour) ::: Seymour is bewildered.\nNew(maurice) ::: Maurice is new.\n((¬Jolly(algernon) ∨ Able(maurice))) → (Cultural(cara)) ::: If Algernon is not jolly or Maurice is able, then Cara is cultural.\n(∃x (Bewildered(x) ∧ ¬Octagonal(x))) → (Jolly(algernon)) ::: If there is at least one people who is both bewildered and not octagonal, then Algernon is jolly.\n(∀x (¬New(x))) → (Bewildered(x) ∧ Cultural(x)) ::: Someone who is not new is always both bewildered and cultural.\n((Bewildered(abel))) ↔ (¬Jolly(algernon)) ::: If Abel is bewildered, then Algernon is not jolly, and vice versa.\n(∃x (¬New(x))) → (¬Jolly(lesley) ∧ Octagonal(lesley)) ::: If there is someone who is not new, then Lesley is not jolly and Lesley is octagonal.\n(∀x (Jolly(x) ∧ ¬Bewildered(x))) → (¬Cultural(x)) ::: Someone being both jolly and not bewildered, then he is not cultural.\n(∃x (New(x) ∨ ¬Able(x))) → (¬Cultural(cara)) ::: If there is someone who is either new or not able, then Cara is not cultural.\n((¬Bewildered(x) ∧ ¬Able(x))) ↔ (Jolly(x)) ::: Someone being neither bewildered nor able is equivalent to being jolly.\n((Octagonal(x) ∧ ¬Cultural(x))) ↔ (Jolly(x) ∧ Bewildered(x)) ::: If someone is octagonal and not cultural, then he is both jolly and bewildered, and vice versa.\n(∃x (¬Bewildered(x))) → (Jolly(cara)) ::: If there is someone who is not bewildered, then Cara is jolly.\n(∀x ((¬Jolly(x) ∨ ¬Able(x))) → (New(x)) ::: Someone who is either not jolly or not able is always new.\n(∃x (Bewildered(x))) → (¬Cultural(lesley) ∧ Octagonal(seymour)) ::: If there is at least one people who is bewildered, then Lesley is not cultural and Seymour is octagonal.\n",
            "First-Order-Logic Question": "¬Jolly(aaron) ::: Aaron is not jolly."
        },
        "gram_prog": {
            "First-Order-Logic Rules": "¬Bewildered(abel) ::: Abel is not bewildered.\nCultural(aaron) ::: Aaron is cultural.\nCultural(seymour) ::: Seymour is cultural.\nAble(abel) ::: Abel is able.\nJolly(maurice) ::: Maurice is jolly.\nBewildered(cara) ::: Cara is bewildered.\nCultural(maurice) ::: Maurice is cultural.\nCultural(abel) ::: Abel is cultural.\n¬Jolly(algernon) ::: Algernon is not jolly.\n¬New(algernon) ::: Algernon is not new.\nBewildered(seymour) ::: Seymour is bewildered.\nNew(maurice) ::: Maurice is new.\n((¬Jolly(algernon) ∨ Able(maurice))) → (Cultural(cara)) ::: If Algernon is not jolly or Maurice is able, then Cara is cultural.\n(∃x (Bewildered(x) ∧ ¬Octagonal(x))) → (Jolly(algernon)) ::: If there is at least one people who is both bewildered and not octagonal, then Algernon is jolly.\n(∀x (¬New(x))) → (Bewildered(x) ∧ Cultural(x)) ::: Someone who is not new is always both bewildered and cultural.\n((Bewildered(abel))) ↔ (¬Jolly(algernon)) ::: If Abel is bewildered, then Algernon is not jolly, and vice versa.\n(∃x (¬New(x))) → (¬Jolly(lesley) ∧ Octagonal(lesley)) ::: If there is someone who is not new, then Lesley is not jolly and Lesley is octagonal.\n(∀x (Jolly(x) ∧ ¬Bewildered(x))) → (¬Cultural(x)) ::: Someone being both jolly and not bewildered, then he is not cultural.\n(∃x (New(x) ∨ ¬Able(x))) → (¬Cultural(cara)) ::: If there is someone who is either new or not able, then Cara is not cultural.\n((¬Bewildered(x) ∧ ¬Able(x))) ↔ (Jolly(x)) ::: Someone being neither bewildered nor able is equivalent to being jolly.\n((Octagonal(x) ∧ ¬Cultural(x))) ↔ (Jolly(x) ∧ Bewildered(x)) ::: If someone is octagonal and not cultural, then he is both jolly and bewildered, and vice versa.\n(∃x (¬Bewildered(x))) → (Jolly(cara)) ::: If there is someone who is not bewildered, then Cara is jolly.\n∀x((¬Jolly(x)∨¬Able(x))) ::: Someone who is either not jolly or not able is always new.\n(∃x (Bewildered(x))) → (¬Cultural(lesley) ∧ Octagonal(seymour)) ::: If there is at least one people who is bewildered, then Lesley is not cultural and Seymour is octagonal.\n",
            "First-Order-Logic Question": "¬Jolly(aaron) ::: Aaron is not jolly."
        },
        "diff": [
            {
                "raw": "(∀x ((¬Jolly(x) ∨ ¬Able(x))) → (New(x)) ::: Someone who is either not jolly or not able is always new.",
                "gram": "∀x((¬Jolly(x)∨¬Able(x))) ::: Someone who is either not jolly or not able is always new."
            }
        ],
        "answer": "C",
        "grammar_answer": "A",
        "manual_prog": {
            "First-Order-Logic Rules": "¬Bewildered(abel) ::: Abel is not bewildered.\nCultural(aaron) ::: Aaron is cultural.\nCultural(seymour) ::: Seymour is cultural.\nAble(abel) ::: Abel is able.\nJolly(maurice) ::: Maurice is jolly.\nBewildered(cara) ::: Cara is bewildered.\nCultural(maurice) ::: Maurice is cultural.\nCultural(abel) ::: Abel is cultural.\n¬Jolly(algernon) ::: Algernon is not jolly.\n¬New(algernon) ::: Algernon is not new.\nBewildered(seymour) ::: Seymour is bewildered.\nNew(maurice) ::: Maurice is new.\n((¬Jolly(algernon) ∨ Able(maurice))) → (Cultural(cara)) ::: If Algernon is not jolly or Maurice is able, then Cara is cultural.\n(∃x (Bewildered(x) ∧ ¬Octagonal(x))) → (Jolly(algernon)) ::: If there is at least one people who is both bewildered and not octagonal, then Algernon is jolly.\n(∀x (¬New(x))) → (Bewildered(x) ∧ Cultural(x)) ::: Someone who is not new is always both bewildered and cultural.\n((Bewildered(abel))) ↔ (¬Jolly(algernon)) ::: If Abel is bewildered, then Algernon is not jolly, and vice versa.\n(∃x (¬New(x))) → (¬Jolly(lesley) ∧ Octagonal(lesley)) ::: If there is someone who is not new, then Lesley is not jolly and Lesley is octagonal.\n(∀x (Jolly(x) ∧ ¬Bewildered(x))) → (¬Cultural(x)) ::: Someone being both jolly and not bewildered, then he is not cultural.\n(∃x (New(x) ∨ ¬Able(x))) → (¬Cultural(cara)) ::: If there is someone who is either new or not able, then Cara is not cultural.\n((¬Bewildered(x) ∧ ¬Able(x))) ↔ (Jolly(x)) ::: Someone being neither bewildered nor able is equivalent to being jolly.\n((Octagonal(x) ∧ ¬Cultural(x))) ↔ (Jolly(x) ∧ Bewildered(x)) ::: If someone is octagonal and not cultural, then he is both jolly and bewildered, and vice versa.\n(∃x (¬Bewildered(x))) → (Jolly(cara)) ::: If there is someone who is not bewildered, then Cara is jolly.\n(∀x ((¬Jolly(x) ∨ ¬Able(x))) → (New(x))) ::: Someone who is either not jolly or not able is always new.\n(∃x (Bewildered(x))) → (¬Cultural(lesley) ∧ Octagonal(seymour)) ::: If there is at least one people who is bewildered, then Lesley is not cultural and Seymour is octagonal.\n",
            "First-Order-Logic Question": "¬Jolly(aaron) ::: Aaron is not jolly."
        },
        "fixed": true
    },
    {
        "id": 206,
        "raw_prog": {
            "First-Order-Logic Rules": "Lovely(clarence) ::: Clarence is lovely.\n¬Shiny(katelynn) ::: Katelynn is not shiny.\n¬Shiny(seymour) ::: Seymour is not shiny.\nSouthern(katelynn) ::: Katelynn is southern.\n¬Creative(clarence) ::: Clarence is not creative.\n¬Lovely(seymour) ::: Seymour is not lovely.\n¬Cultural(brandi) ::: Brandi is not cultural.\n¬Lovely(lyndon) ::: Lyndon is not lovely.\nCultural(seymour) ::: Seymour is cultural.\nShiny(luka) ::: Luka is shiny.\nCultural(katelynn) ::: Katelynn is cultural.\n¬Creative(lyndon) ::: Lyndon is not creative.\n((∀x (Aware(x) ∧ Harsh(x))) → (∀x (¬Obedient(x) ∧ Successful(x))) ::: Someone who is aware and harsh is always not obedient and successful.\n((Successful(calvert))) ↔ ((Shiny(culbert) ∧ Ugly(kirby))) ::: If Calvert is successful, then Culbert is shiny and Kirby is ugly, and vice versa.\n((Aware(calvert) ∨ ¬Ugly(jarvis))) → ((Shiny(culbert))) ::: It can be concluded that Culbert is shiny once knowing that Calvert is aware or Jarvis is not ugly.\n(∀x (Obedient(x) ∧ Shiny(x))) ↔ (∀x (¬Aware(x))) ::: If someone is obedient and shiny, then he is not aware, and vice versa.\n(∀x (Ugly(x))) ↔ (∀x (Shiny(x))) ::: Someone being ugly is equivalent to being shiny.\n(∀x (Aware(x) ∨ ¬Ugly(x))) → (∀x (¬Harsh(x))) ::: If someone is aware or he is not ugly, then he is not harsh.\n((Harsh(kirby) ∨ Shiny(calvert))) → ((¬Ugly(jarvis))) ::: If Kirby is harsh or Calvert is shiny, then Jarvis is not ugly.\n(∀x (¬Aware(x) ∧ Successful(x))) → (∀x (Harsh(x))) ::: Someone who is both not aware and successful is always harsh.\n(∀x (¬Shiny(x))) → (∀x (Successful(x))) ::: Someone who is not shiny is always successful.\n(∀x (Shiny(x))) ↔ (∀x (Aware(x))) ::: If someone is shiny, then he is aware, and vice versa.\n(∀x (Obedient(x) ∧ ¬Shiny(x))) → (∀x (Harsh(x))) ::: Someone who is both obedient and not shiny is always harsh.\n(∃x (Harsh(x) ∧ Aware(x))) → ((¬Obedient(jarvis))) ::: If there is at least one people who is both harsh and aware, then Jarvis is not obedient.\n",
            "First-Order-Logic Question": "Lovely(seymour) ::: Seymour is lovely."
        },
        "gram_prog": {
            "First-Order-Logic Rules": "Lovely(clarence) ::: Clarence is lovely.\n¬Shiny(katelynn) ::: Katelynn is not shiny.\n¬Shiny(seymour) ::: Seymour is not shiny.\nSouthern(katelynn) ::: Katelynn is southern.\n¬Creative(clarence) ::: Clarence is not creative.\n¬Lovely(seymour) ::: Seymour is not lovely.\n¬Cultural(brandi) ::: Brandi is not cultural.\n¬Lovely(lyndon) ::: Lyndon is not lovely.\nCultural(seymour) ::: Seymour is cultural.\nShiny(luka) ::: Luka is shiny.\nCultural(katelynn) ::: Katelynn is cultural.\n¬Creative(lyndon) ::: Lyndon is not creative.\n∀x((Lovely(x)∧Shiny(x))) ::: Someone who is aware and harsh is always not obedient and successful.\n((Successful(calvert))) ↔ ((Shiny(culbert) ∧ Ugly(kirby))) ::: If Calvert is successful, then Culbert is shiny and Kirby is ugly, and vice versa.\n((Aware(calvert) ∨ ¬Ugly(jarvis))) → ((Shiny(culbert))) ::: It can be concluded that Culbert is shiny once knowing that Calvert is aware or Jarvis is not ugly.\n(∀x (Obedient(x) ∧ Shiny(x))) ↔ (∀x (¬Aware(x))) ::: If someone is obedient and shiny, then he is not aware, and vice versa.\n(∀x (Ugly(x))) ↔ (∀x (Shiny(x))) ::: Someone being ugly is equivalent to being shiny.\n(∀x (Aware(x) ∨ ¬Ugly(x))) → (∀x (¬Harsh(x))) ::: If someone is aware or he is not ugly, then he is not harsh.\n((Harsh(kirby) ∨ Shiny(calvert))) → ((¬Ugly(jarvis))) ::: If Kirby is harsh or Calvert is shiny, then Jarvis is not ugly.\n(∀x (¬Aware(x) ∧ Successful(x))) → (∀x (Harsh(x))) ::: Someone who is both not aware and successful is always harsh.\n(∀x (¬Shiny(x))) → (∀x (Successful(x))) ::: Someone who is not shiny is always successful.\n(∀x (Shiny(x))) ↔ (∀x (Aware(x))) ::: If someone is shiny, then he is aware, and vice versa.\n(∀x (Obedient(x) ∧ ¬Shiny(x))) → (∀x (Harsh(x))) ::: Someone who is both obedient and not shiny is always harsh.\n(∃x (Harsh(x) ∧ Aware(x))) → ((¬Obedient(jarvis))) ::: If there is at least one people who is both harsh and aware, then Jarvis is not obedient.\n",
            "First-Order-Logic Question": "Lovely(seymour) ::: Seymour is lovely."
        },
        "diff": [
            {
                "raw": "((∀x (Aware(x) ∧ Harsh(x))) → (∀x (¬Obedient(x) ∧ Successful(x))) ::: Someone who is aware and harsh is always not obedient and successful.",
                "gram": "∀x((Lovely(x)∧Shiny(x))) ::: Someone who is aware and harsh is always not obedient and successful."
            }
        ],
        "answer": "B",
        "grammar_answer": "A",
        "manual_prog": {
            "First-Order-Logic Rules": "Lovely(clarence) ::: Clarence is lovely.\n¬Shiny(katelynn) ::: Katelynn is not shiny.\n¬Shiny(seymour) ::: Seymour is not shiny.\nSouthern(katelynn) ::: Katelynn is southern.\n¬Creative(clarence) ::: Clarence is not creative.\n¬Lovely(seymour) ::: Seymour is not lovely.\n¬Cultural(brandi) ::: Brandi is not cultural.\n¬Lovely(lyndon) ::: Lyndon is not lovely.\nCultural(seymour) ::: Seymour is cultural.\nShiny(luka) ::: Luka is shiny.\nCultural(katelynn) ::: Katelynn is cultural.\n¬Creative(lyndon) ::: Lyndon is not creative.\n((∀x (Aware(x) ∧ Harsh(x))) → (∀x (¬Obedient(x) ∧ Successful(x)))) ::: Someone who is aware and harsh is always not obedient and successful.\n((Successful(calvert))) ↔ ((Shiny(culbert) ∧ Ugly(kirby))) ::: If Calvert is successful, then Culbert is shiny and Kirby is ugly, and vice versa.\n((Aware(calvert) ∨ ¬Ugly(jarvis))) → ((Shiny(culbert))) ::: It can be concluded that Culbert is shiny once knowing that Calvert is aware or Jarvis is not ugly.\n(∀x (Obedient(x) ∧ Shiny(x))) ↔ (∀x (¬Aware(x))) ::: If someone is obedient and shiny, then he is not aware, and vice versa.\n(∀x (Ugly(x))) ↔ (∀x (Shiny(x))) ::: Someone being ugly is equivalent to being shiny.\n(∀x (Aware(x) ∨ ¬Ugly(x))) → (∀x (¬Harsh(x))) ::: If someone is aware or he is not ugly, then he is not harsh.\n((Harsh(kirby) ∨ Shiny(calvert))) → ((¬Ugly(jarvis))) ::: If Kirby is harsh or Calvert is shiny, then Jarvis is not ugly.\n(∀x (¬Aware(x) ∧ Successful(x))) → (∀x (Harsh(x))) ::: Someone who is both not aware and successful is always harsh.\n(∀x (¬Shiny(x))) → (∀x (Successful(x))) ::: Someone who is not shiny is always successful.\n(∀x (Shiny(x))) ↔ (∀x (Aware(x))) ::: If someone is shiny, then he is aware, and vice versa.\n(∀x (Obedient(x) ∧ ¬Shiny(x))) → (∀x (Harsh(x))) ::: Someone who is both obedient and not shiny is always harsh.\n(∃x (Harsh(x) ∧ Aware(x))) → ((¬Obedient(jarvis))) ::: If there is at least one people who is both harsh and aware, then Jarvis is not obedient.\n",
            "First-Order-Logic Question": "Lovely(seymour) ::: Seymour is lovely."
        },
        "fixed": true
    },
    {
        "id": 222,
        "raw_prog": {
            "First-Order-Logic Rules": "¬Soft(gregory) ::: Gregory is not soft.\n¬Significant(max) ::: Max is not significant.\nHollow(max) ::: Max is hollow.\n¬Significant(conrad) ::: Conrad is not significant.\n¬Significant(adler) ::: Adler is not significant.\nCombative(lamont) ::: Lamont is combative.\n¬Precious(max) ::: Max is not precious.\nHollow(cary) ::: Cary is hollow.\n¬Combative(adler) ::: Adler is not combative.\nSignificant(cary) ::: Cary is significant.\nSignificant(seymour) ::: Seymour is significant.\n¬Fearless(conrad) ::: Conrad is not fearless.\n(∀x ((Precious(x) ∧ ¬Significant(x)) ↔ (¬Soft(x))) ::: If someone is precious and not significant, then he is not soft, and vice versa.\n(∀x ((Fearless(x) ∧ ¬Precious(x)) ↔ (Significant(x))) ::: Someone being both fearless and not precious is equivalent to being significant.\n(∀x (Significant(x))) → (∀x (¬Fearless(x))) ::: Someone who is significant is always not fearless.\n(∀x (¬Precious(x))) → ((¬Hollow(x) ∧ ¬Soft(x))) ::: If someone is not precious, then he is neither hollow nor soft.\n(∀x ((Combative(x) ∧ Fearless(x)) ↔ (Significant(x) ∧ ¬Precious(x)))) ::: Someone being both combative and fearless is equivalent to being significant and not precious.\n(∀x ((¬Soft(x) ∨ ¬Significant(x)) → (Hollow(x)))) ::: If someone is not soft or not significant, then he is hollow.\n((¬Soft(seymour))) ↔ ((¬Combative(max) ∧ Hollow(gregory))) ::: Seymour being not soft is equivalent to Max being not combative and Gregory being hollow.\n(¬Precious(adler)) ↔ (Soft(lamont)) ::: Adler is not precious if and only if Lamont is soft.\n(∀x (¬Significant(x))) → (Hollow(x)) ::: All not significant people are hollow.\n(∃x (Fearless(x))) → (¬Significant(x)) ::: If someone is fearless, then he is not significant.\n((Hollow(adler))) → ((¬Fearless(adler) ∧ ¬Soft(lamont))) ::: If Adler is hollow, then Adler is not fearless and Lamont is not soft.\n((¬Hollow(lamont))) ↔ (Significant(max)) ::: Lamont is not hollow if and only if Max is significant.\n",
            "First-Order-Logic Question": "¬Combative(lamont) ::: Lamont is not combative."
        },
        "gram_prog": {
            "First-Order-Logic Rules": "¬Soft(gregory) ::: Gregory is not soft.\n¬Significant(max) ::: Max is not significant.\nHollow(max) ::: Max is hollow.\n¬Significant(conrad) ::: Conrad is not significant.\n¬Significant(adler) ::: Adler is not significant.\nCombative(lamont) ::: Lamont is combative.\n¬Precious(max) ::: Max is not precious.\nHollow(cary) ::: Cary is hollow.\n¬Combative(adler) ::: Adler is not combative.\nSignificant(cary) ::: Cary is significant.\nSignificant(seymour) ::: Seymour is significant.\n¬Fearless(conrad) ::: Conrad is not fearless.\n∀x((Precious(x)∧¬Significant(x))) ::: If someone is precious and not significant, then he is not soft, and vice versa.\n∀x((Soft(x)∧¬Precious(x))) ::: Someone being both fearless and not precious is equivalent to being significant.\n(∀x (Significant(x))) → (∀x (¬Fearless(x))) ::: Someone who is significant is always not fearless.\n(∀x (¬Precious(x))) → ((¬Hollow(x) ∧ ¬Soft(x))) ::: If someone is not precious, then he is neither hollow nor soft.\n(∀x ((Combative(x) ∧ Fearless(x)) ↔ (Significant(x) ∧ ¬Precious(x)))) ::: Someone being both combative and fearless is equivalent to being significant and not precious.\n(∀x ((¬Soft(x) ∨ ¬Significant(x)) → (Hollow(x)))) ::: If someone is not soft or not significant, then he is hollow.\n((¬Soft(seymour))) ↔ ((¬Combative(max) ∧ Hollow(gregory))) ::: Seymour being not soft is equivalent to Max being not combative and Gregory being hollow.\n(¬Precious(adler)) ↔ (Soft(lamont)) ::: Adler is not precious if and only if Lamont is soft.\n(∀x (¬Significant(x))) → (Hollow(x)) ::: All not significant people are hollow.\n(∃x (Fearless(x))) → (¬Significant(x)) ::: If someone is fearless, then he is not significant.\n((Hollow(adler))) → ((¬Fearless(adler) ∧ ¬Soft(lamont))) ::: If Adler is hollow, then Adler is not fearless and Lamont is not soft.\n((¬Hollow(lamont))) ↔ (Significant(max)) ::: Lamont is not hollow if and only if Max is significant.\n",
            "First-Order-Logic Question": "¬Combative(lamont) ::: Lamont is not combative."
        },
        "diff": [
            {
                "raw": "(∀x ((Precious(x) ∧ ¬Significant(x)) ↔ (¬Soft(x))) ::: If someone is precious and not significant, then he is not soft, and vice versa.",
                "gram": "∀x((Precious(x)∧¬Significant(x))) ::: If someone is precious and not significant, then he is not soft, and vice versa."
            },
            {
                "raw": "(∀x ((Fearless(x) ∧ ¬Precious(x)) ↔ (Significant(x))) ::: Someone being both fearless and not precious is equivalent to being significant.",
                "gram": "∀x((Soft(x)∧¬Precious(x))) ::: Someone being both fearless and not precious is equivalent to being significant."
            }
        ],
        "answer": "B",
        "grammar_answer": "A",
        "manual_prog": {
            "First-Order-Logic Rules": "¬Soft(gregory) ::: Gregory is not soft.\n¬Significant(max) ::: Max is not significant.\nHollow(max) ::: Max is hollow.\n¬Significant(conrad) ::: Conrad is not significant.\n¬Significant(adler) ::: Adler is not significant.\nCombative(lamont) ::: Lamont is combative.\n¬Precious(max) ::: Max is not precious.\nHollow(cary) ::: Cary is hollow.\n¬Combative(adler) ::: Adler is not combative.\nSignificant(cary) ::: Cary is significant.\nSignificant(seymour) ::: Seymour is significant.\n¬Fearless(conrad) ::: Conrad is not fearless.\n(∀x ((Precious(x) ∧ ¬Significant(x)) ↔ (¬Soft(x)))) ::: If someone is precious and not significant, then he is not soft, and vice versa.\n(∀x ((Fearless(x) ∧ ¬Precious(x)) ↔ (Significant(x)))) ::: Someone being both fearless and not precious is equivalent to being significant.\n(∀x (Significant(x))) → (∀x (¬Fearless(x))) ::: Someone who is significant is always not fearless.\n(∀x (¬Precious(x))) → ((¬Hollow(x) ∧ ¬Soft(x))) ::: If someone is not precious, then he is neither hollow nor soft.\n(∀x ((Combative(x) ∧ Fearless(x)) ↔ (Significant(x) ∧ ¬Precious(x)))) ::: Someone being both combative and fearless is equivalent to being significant and not precious.\n(∀x ((¬Soft(x) ∨ ¬Significant(x)) → (Hollow(x)))) ::: If someone is not soft or not significant, then he is hollow.\n((¬Soft(seymour))) ↔ ((¬Combative(max) ∧ Hollow(gregory))) ::: Seymour being not soft is equivalent to Max being not combative and Gregory being hollow.\n(¬Precious(adler)) ↔ (Soft(lamont)) ::: Adler is not precious if and only if Lamont is soft.\n(∀x (¬Significant(x))) → (Hollow(x)) ::: All not significant people are hollow.\n(∃x (Fearless(x))) → (¬Significant(x)) ::: If someone is fearless, then he is not significant.\n((Hollow(adler))) → ((¬Fearless(adler) ∧ ¬Soft(lamont))) ::: If Adler is hollow, then Adler is not fearless and Lamont is not soft.\n((¬Hollow(lamont))) ↔ (Significant(max)) ::: Lamont is not hollow if and only if Max is significant.\n",
            "First-Order-Logic Question": "¬Combative(lamont) ::: Lamont is not combative."
        },
        "fixed": true
    },
    {
        "id": 252,
        "raw_prog": {
            "First-Order-Logic Rules": "¬Average(eli) ::: Eli is not average.\n¬Civil(juliana) ::: Juliana is not civil.\n¬Octagonal(lamont) ::: Lamont is not octagonal.\nSeveral(janine) ::: Janine is several.\nHollow(eli) ::: Eli is hollow.\n¬Hollow(janine) ::: Janine is not hollow.\n¬Average(juliana) ::: Juliana is not average.\n¬Fair(juliana) ::: Juliana is not fair.\nSeveral(eli) ::: Eli is several.\nHollow(christina) ::: Christina is hollow.\nCivil(janine) ::: Janine is civil.\nHollow(lamont) ::: Lamont is hollow.\n((Civil(lamont)) → ((Fair(eli) ∧ Average(juliana))) ::: It can be concluded that Eli is fair and Juliana is average once knowing that Lamont is civil.\n(¬Hollow(luka)) → (Fair(juliana)) ::: If Luka is not hollow, then Juliana is fair.\n(∀x ((Several(x) ∧ ¬Hollow(x))) ↔ (¬Civil(x) ∧ ¬Average(x))) ::: Someone being both several and not hollow is equivalent to being not civil and not average.\n(∃x (Civil(x) ∨ Average(x))) → (¬Octagonal(luka)) ::: If there is at least one people who is civil or average, then Luka is not octagonal.\n(∃x (Average(x))) → ((Octagonal(janine) ∧ Several(juliana))) ::: If there is at least one people who is average, then Janine is octagonal and Juliana is several.\n(∃x ((Octagonal(x) ∧ Hollow(x)))) → ((¬Average(luka) ∧ ¬Civil(janine))) ::: If there is someone who is both octagonal and hollow, then Luka is not average and Janine is not civil.\n((Civil(janine))) → (Fair(luka)) ::: It can be concluded that Luka is fair once knowing that Janine is civil.\n(∀x ((Octagonal(x) ∧ Civil(x))) ↔ (¬Average(x))) ::: Someone is octagonal and civil if and only if he is not average.\n(¬Fair(lamont)) → ((Several(lamont) ∧ Octagonal(eli))) ::: If Lamont is not fair, then Lamont is several and Eli is octagonal.\n(∀x ((Hollow(x) ∨ ¬Fair(x))) → (¬Several(x))) ::: Someone who is either hollow or not fair is always not several.\n(∀x ((¬Octagonal(x)) ↔ (Civil(x))) ::: Lamont is not octagonal if and only if Lamont is civil.\n(∃x (Hollow(x))) → ((¬Average(janine) ∧ ¬Civil(christina))) ::: If there is someone who is hollow, then Janine is not average and Christina is not civil.\n",
            "First-Order-Logic Question": "Hollow(juliana) ::: Juliana is hollow."
        },
        "gram_prog": {
            "First-Order-Logic Rules": "¬Average(eli) ::: Eli is not average.\n¬Civil(juliana) ::: Juliana is not civil.\n¬Octagonal(lamont) ::: Lamont is not octagonal.\nSeveral(janine) ::: Janine is several.\nHollow(eli) ::: Eli is hollow.\n¬Hollow(janine) ::: Janine is not hollow.\n¬Average(juliana) ::: Juliana is not average.\n¬Fair(juliana) ::: Juliana is not fair.\nSeveral(eli) ::: Eli is several.\nHollow(christina) ::: Christina is hollow.\nCivil(janine) ::: Janine is civil.\nHollow(lamont) ::: Lamont is hollow.\nConcerned(x)→((Fresh(x))) ::: It can be concluded that Eli is fair and Juliana is average once knowing that Lamont is civil.\n(¬Hollow(luka)) → (Fair(juliana)) ::: If Luka is not hollow, then Juliana is fair.\n(∀x ((Several(x) ∧ ¬Hollow(x))) ↔ (¬Civil(x) ∧ ¬Average(x))) ::: Someone being both several and not hollow is equivalent to being not civil and not average.\n(∃x (Civil(x) ∨ Average(x))) → (¬Octagonal(luka)) ::: If there is at least one people who is civil or average, then Luka is not octagonal.\n(∃x (Average(x))) → ((Octagonal(janine) ∧ Several(juliana))) ::: If there is at least one people who is average, then Janine is octagonal and Juliana is several.\n(∃x ((Octagonal(x) ∧ Hollow(x)))) → ((¬Average(luka) ∧ ¬Civil(janine))) ::: If there is someone who is both octagonal and hollow, then Luka is not average and Janine is not civil.\n((Civil(janine))) → (Fair(luka)) ::: It can be concluded that Luka is fair once knowing that Janine is civil.\n(∀x ((Octagonal(x) ∧ Civil(x))) ↔ (¬Average(x))) ::: Someone is octagonal and civil if and only if he is not average.\n(¬Fair(lamont)) → ((Several(lamont) ∧ Octagonal(eli))) ::: If Lamont is not fair, then Lamont is several and Eli is octagonal.\n(∀x ((Hollow(x) ∨ ¬Fair(x))) → (¬Several(x))) ::: Someone who is either hollow or not fair is always not several.\n¬(Blue(x)→Concerned(x)) ::: Lamont is not octagonal if and only if Lamont is civil.\n(∃x (Hollow(x))) → ((¬Average(janine) ∧ ¬Civil(christina))) ::: If there is someone who is hollow, then Janine is not average and Christina is not civil.\n",
            "First-Order-Logic Question": "Hollow(juliana) ::: Juliana is hollow."
        },
        "diff": [
            {
                "raw": "((Civil(lamont)) → ((Fair(eli) ∧ Average(juliana))) ::: It can be concluded that Eli is fair and Juliana is average once knowing that Lamont is civil.",
                "gram": "Concerned(x)→((Fresh(x))) ::: It can be concluded that Eli is fair and Juliana is average once knowing that Lamont is civil."
            },
            {
                "raw": "(∀x ((¬Octagonal(x)) ↔ (Civil(x))) ::: Lamont is not octagonal if and only if Lamont is civil.",
                "gram": "¬(Blue(x)→Concerned(x)) ::: Lamont is not octagonal if and only if Lamont is civil."
            }
        ],
        "answer": "B",
        "grammar_answer": "A",
        "manual_prog": {
            "First-Order-Logic Rules": "¬Average(eli) ::: Eli is not average.\n¬Civil(juliana) ::: Juliana is not civil.\n¬Octagonal(lamont) ::: Lamont is not octagonal.\nSeveral(janine) ::: Janine is several.\nHollow(eli) ::: Eli is hollow.\n¬Hollow(janine) ::: Janine is not hollow.\n¬Average(juliana) ::: Juliana is not average.\n¬Fair(juliana) ::: Juliana is not fair.\nSeveral(eli) ::: Eli is several.\nHollow(christina) ::: Christina is hollow.\nCivil(janine) ::: Janine is civil.\nHollow(lamont) ::: Lamont is hollow.\n((Civil(lamont)) → ((Fair(eli) ∧ Average(juliana)))) ::: It can be concluded that Eli is fair and Juliana is average once knowing that Lamont is civil.\n(¬Hollow(luka)) → (Fair(juliana)) ::: If Luka is not hollow, then Juliana is fair.\n(∀x ((Several(x) ∧ ¬Hollow(x))) ↔ (¬Civil(x) ∧ ¬Average(x))) ::: Someone being both several and not hollow is equivalent to being not civil and not average.\n(∃x (Civil(x) ∨ Average(x))) → (¬Octagonal(luka)) ::: If there is at least one people who is civil or average, then Luka is not octagonal.\n(∃x (Average(x))) → ((Octagonal(janine) ∧ Several(juliana))) ::: If there is at least one people who is average, then Janine is octagonal and Juliana is several.\n(∃x ((Octagonal(x) ∧ Hollow(x)))) → ((¬Average(luka) ∧ ¬Civil(janine))) ::: If there is someone who is both octagonal and hollow, then Luka is not average and Janine is not civil.\n((Civil(janine))) → (Fair(luka)) ::: It can be concluded that Luka is fair once knowing that Janine is civil.\n(∀x ((Octagonal(x) ∧ Civil(x))) ↔ (¬Average(x))) ::: Someone is octagonal and civil if and only if he is not average.\n(¬Fair(lamont)) → ((Several(lamont) ∧ Octagonal(eli))) ::: If Lamont is not fair, then Lamont is several and Eli is octagonal.\n(∀x ((Hollow(x) ∨ ¬Fair(x))) → (¬Several(x))) ::: Someone who is either hollow or not fair is always not several.\n(∀x ((¬Octagonal(x)) ↔ (Civil(x)))) ::: Lamont is not octagonal if and only if Lamont is civil.\n(∃x (Hollow(x))) → ((¬Average(janine) ∧ ¬Civil(christina))) ::: If there is someone who is hollow, then Janine is not average and Christina is not civil.\n",
            "First-Order-Logic Question": "Hollow(juliana) ::: Juliana is hollow."
        },
        "fixed": true
    },
    {
        "id": 390,
        "raw_prog": {
            "First-Order-Logic Rules": "¬Technical(cyril) ::: Cyril is not technical.\n¬Alert(max) ::: Max is not alert.\nImpossible(barry) ::: Barry is impossible.\nLovely(max) ::: Max is lovely.\nImpossible(cyril) ::: Cyril is impossible.\n¬Attractive(cyril) ::: Cyril is not attractive.\nTechnical(shane) ::: Shane is technical.\n¬Lovely(tristan) ::: Tristan is not lovely.\nAlert(lamont) ::: Lamont is alert.\n¬Impossible(max) ::: Max is not impossible.\nAttractive(lamont) ::: Lamont is attractive.\n¬Technical(max) ::: Max is not technical.\n((∃x (Attractive(x) ∨ Concerned(x))) → ((Impossible(lesley) ∧ Alert(cyril))) ::: If there is someone who is either attractive or careful, then Lesley is impossible and Cyril is alert.\n((Lovely(x) ∧ Alert(x))) → (Attractive(x)) ::: If someone is both lovely and alert, then he is attractive.\n((Impossible(x) ∧ ¬Concerned(x))) → (¬Technical(x) ∧ ¬Alert(x)) ::: If someone is impossible and not careful, then he is not technical and not alert.\n((¬Lovely(x) ∧ Impossible(x))) → (Attractive(x)) ::: If someone who is not lovely is also impossible, then he is attractive.\n((Concerned(x) ∧ ¬Impossible(x))) → (¬Attractive(shane) ∧ Technical(lamont)) ::: If there is someone who is both careful and not impossible, then Shane is not attractive and Lamont is technical.\n((Impossible(lamont))) ↔ (Attractive(max) ∧ ¬Lovely(barry)) ::: Lamont being impossible is equivalent to Max being attractive and Barry being not lovely.\n((Attractive(x) ∨ Lovely(x))) → (Impossible(x)) ::: Someone who is either attractive or lovely is always impossible.\n((Attractive(shane) ∨ ¬Alert(shane))) → (Impossible(shane)) ::: If Shane is attractive or Shane is not alert, then Shane is impossible.\n((Impossible(max) ∧ Attractive(barry))) ↔ (Concerned(tristan) ∧ Alert(max)) ::: Max being impossible and Barry being attractive are equivalent to Tristan being careful and Max being alert.\n((Attractive(max))) ↔ (¬Concerned(tristan)) ::: Max being attractive is equivalent to Tristan being not careful.\n((¬Alert(x) ∨ ¬Technical(x))) → (Impossible(tristan)) ::: If there is someone who is either not alert or not technical, then Tristan is impossible.\n((¬Concerned(x))) → (Attractive(lesley) ∧ Impossible(lamont)) ::: If there is someone who is not careful, then Lesley is attractive and Lamont is impossible.\n",
            "First-Order-Logic Question": "Impossible(shane) ::: Shane is impossible."
        },
        "gram_prog": {
            "First-Order-Logic Rules": "¬Technical(cyril) ::: Cyril is not technical.\n¬Alert(max) ::: Max is not alert.\nImpossible(barry) ::: Barry is impossible.\nLovely(max) ::: Max is lovely.\nImpossible(cyril) ::: Cyril is impossible.\n¬Attractive(cyril) ::: Cyril is not attractive.\nTechnical(shane) ::: Shane is technical.\n¬Lovely(tristan) ::: Tristan is not lovely.\nAlert(lamont) ::: Lamont is alert.\n¬Impossible(max) ::: Max is not impossible.\nAttractive(lamont) ::: Lamont is attractive.\n¬Technical(max) ::: Max is not technical.\n(((Serious(x)))) ::: If there is someone who is either attractive or careful, then Lesley is impossible and Cyril is alert.\n((Lovely(x) ∧ Alert(x))) → (Attractive(x)) ::: If someone is both lovely and alert, then he is attractive.\n((Impossible(x) ∧ ¬Concerned(x))) → (¬Technical(x) ∧ ¬Alert(x)) ::: If someone is impossible and not careful, then he is not technical and not alert.\n((¬Lovely(x) ∧ Impossible(x))) → (Attractive(x)) ::: If someone who is not lovely is also impossible, then he is attractive.\n((Concerned(x) ∧ ¬Impossible(x))) → (¬Attractive(shane) ∧ Technical(lamont)) ::: If there is someone who is both careful and not impossible, then Shane is not attractive and Lamont is technical.\n((Impossible(lamont))) ↔ (Attractive(max) ∧ ¬Lovely(barry)) ::: Lamont being impossible is equivalent to Max being attractive and Barry being not lovely.\n((Attractive(x) ∨ Lovely(x))) → (Impossible(x)) ::: Someone who is either attractive or lovely is always impossible.\n((Attractive(shane) ∨ ¬Alert(shane))) → (Impossible(shane)) ::: If Shane is attractive or Shane is not alert, then Shane is impossible.\n((Impossible(max) ∧ Attractive(barry))) ↔ (Concerned(tristan) ∧ Alert(max)) ::: Max being impossible and Barry being attractive are equivalent to Tristan being careful and Max being alert.\n((Attractive(max))) ↔ (¬Concerned(tristan)) ::: Max being attractive is equivalent to Tristan being not careful.\n((¬Alert(x) ∨ ¬Technical(x))) → (Impossible(tristan)) ::: If there is someone who is either not alert or not technical, then Tristan is impossible.\n((¬Concerned(x))) → (Attractive(lesley) ∧ Impossible(lamont)) ::: If there is someone who is not careful, then Lesley is attractive and Lamont is impossible.\n",
            "First-Order-Logic Question": "Impossible(shane) ::: Shane is impossible."
        },
        "diff": [
            {
                "raw": "((∃x (Attractive(x) ∨ Concerned(x))) → ((Impossible(lesley) ∧ Alert(cyril))) ::: If there is someone who is either attractive or careful, then Lesley is impossible and Cyril is alert.",
                "gram": "(((Serious(x)))) ::: If there is someone who is either attractive or careful, then Lesley is impossible and Cyril is alert."
            }
        ],
        "answer": "C",
        "grammar_answer": "A",
        "manual_prog": {
            "First-Order-Logic Rules": "¬Technical(cyril) ::: Cyril is not technical.\n¬Alert(max) ::: Max is not alert.\nImpossible(barry) ::: Barry is impossible.\nLovely(max) ::: Max is lovely.\nImpossible(cyril) ::: Cyril is impossible.\n¬Attractive(cyril) ::: Cyril is not attractive.\nTechnical(shane) ::: Shane is technical.\n¬Lovely(tristan) ::: Tristan is not lovely.\nAlert(lamont) ::: Lamont is alert.\n¬Impossible(max) ::: Max is not impossible.\nAttractive(lamont) ::: Lamont is attractive.\n¬Technical(max) ::: Max is not technical.\n((∃x (Attractive(x) ∨ Concerned(x))) → ((Impossible(lesley) ∧ Alert(cyril)))) ::: If there is someone who is either attractive or careful, then Lesley is impossible and Cyril is alert.\n((Lovely(x) ∧ Alert(x))) → (Attractive(x)) ::: If someone is both lovely and alert, then he is attractive.\n((Impossible(x) ∧ ¬Concerned(x))) → (¬Technical(x) ∧ ¬Alert(x)) ::: If someone is impossible and not careful, then he is not technical and not alert.\n((¬Lovely(x) ∧ Impossible(x))) → (Attractive(x)) ::: If someone who is not lovely is also impossible, then he is attractive.\n((Concerned(x) ∧ ¬Impossible(x))) → (¬Attractive(shane) ∧ Technical(lamont)) ::: If there is someone who is both careful and not impossible, then Shane is not attractive and Lamont is technical.\n((Impossible(lamont))) ↔ (Attractive(max) ∧ ¬Lovely(barry)) ::: Lamont being impossible is equivalent to Max being attractive and Barry being not lovely.\n((Attractive(x) ∨ Lovely(x))) → (Impossible(x)) ::: Someone who is either attractive or lovely is always impossible.\n((Attractive(shane) ∨ ¬Alert(shane))) → (Impossible(shane)) ::: If Shane is attractive or Shane is not alert, then Shane is impossible.\n((Impossible(max) ∧ Attractive(barry))) ↔ (Concerned(tristan) ∧ Alert(max)) ::: Max being impossible and Barry being attractive are equivalent to Tristan being careful and Max being alert.\n((Attractive(max))) ↔ (¬Concerned(tristan)) ::: Max being attractive is equivalent to Tristan being not careful.\n((¬Alert(x) ∨ ¬Technical(x))) → (Impossible(tristan)) ::: If there is someone who is either not alert or not technical, then Tristan is impossible.\n((¬Concerned(x))) → (Attractive(lesley) ∧ Impossible(lamont)) ::: If there is someone who is not careful, then Lesley is attractive and Lamont is impossible.\n",
            "First-Order-Logic Question": "Impossible(shane) ::: Shane is impossible."
        },
        "fixed": true
    },
    {
        "id": 396,
        "raw_prog": {
            "First-Order-Logic Rules": "¬Technical(cyril) ::: Cyril is not technical.\n¬Alert(max) ::: Max is not alert.\nImpossible(barry) ::: Barry is impossible.\nLovely(max) ::: Max is lovely.\nImpossible(cyril) ::: Cyril is impossible.\n¬Attractive(cyril) ::: Cyril is not attractive.\nTechnical(shane) ::: Shane is technical.\n¬Lovely(tristan) ::: Tristan is not lovely.\n¬Alert(lamont) ::: Lamont is not alert.\n¬Impossible(max) ::: Max is not impossible.\nAttractive(lamont) ::: Lamont is attractive.\n¬Technical(max) ::: Max is not technical.\n((∃x (Attractive(x) ∨ Concerned(x))) → ((Impossible(lesley) ∧ Alert(cyril))) ::: If there is someone who is either attractive or careful, then Lesley is impossible and Cyril is alert.\n((Lovely(x) ∧ Alert(x))) → (Attractive(x)) ::: If someone is both lovely and alert, then he is attractive.\n((Impossible(x) ∧ ¬Concerned(x))) → (¬Technical(x) ∧ ¬Alert(x)) ::: If someone is impossible and not careful, then he is not technical and not alert.\n((¬Lovely(x) ∧ Impossible(x))) → (Attractive(x)) ::: If someone who is not lovely is also impossible, then he is attractive.\n((Concerned(x) ∧ ¬Impossible(x))) → (¬Attractive(shane) ∧ Technical(lamont)) ::: If there is someone who is both careful and not impossible, then Shane is not attractive and Lamont is technical.\n((Impossible(lamont))) ↔ (Attractive(max) ∧ ¬Lovely(barry)) ::: Lamont being impossible is equivalent to Max being attractive and Barry being not lovely.\n((Attractive(x) ∨ Lovely(x))) → (Impossible(x)) ::: Someone who is either attractive or lovely is always impossible.\n((Attractive(shane) ∨ ¬Alert(shane))) → (Impossible(shane)) ::: If Shane is attractive or Shane is not alert, then Shane is impossible.\n((Impossible(max) ∧ Attractive(barry))) ↔ (Concerned(tristan) ∧ Alert(max)) ::: Max being impossible and Barry being attractive are equivalent to Tristan being careful and Max being alert.\n((Attractive(max))) ↔ (¬Concerned(tristan)) ::: Max being attractive is equivalent to Tristan being not careful.\n((¬Alert(x) ∨ ¬Technical(x))) → (Impossible(tristan)) ::: If there is someone who is either not alert or not technical, then Tristan is impossible.\n((¬Concerned(x))) → (Attractive(lesley) ∧ Impossible(lamont)) ::: If there is someone who is not careful, then Lesley is attractive and Lamont is impossible.\n",
            "First-Order-Logic Question": "Technical(barry) ::: Barry is technical."
        },
        "gram_prog": {
            "First-Order-Logic Rules": "¬Technical(cyril) ::: Cyril is not technical.\n¬Alert(max) ::: Max is not alert.\nImpossible(barry) ::: Barry is impossible.\nLovely(max) ::: Max is lovely.\nImpossible(cyril) ::: Cyril is impossible.\n¬Attractive(cyril) ::: Cyril is not attractive.\nTechnical(shane) ::: Shane is technical.\n¬Lovely(tristan) ::: Tristan is not lovely.\n¬Alert(lamont) ::: Lamont is not alert.\n¬Impossible(max) ::: Max is not impossible.\nAttractive(lamont) ::: Lamont is attractive.\n¬Technical(max) ::: Max is not technical.\n(((Serious(x)))) ::: If there is someone who is either attractive or careful, then Lesley is impossible and Cyril is alert.\n((Lovely(x) ∧ Alert(x))) → (Attractive(x)) ::: If someone is both lovely and alert, then he is attractive.\n((Impossible(x) ∧ ¬Concerned(x))) → (¬Technical(x) ∧ ¬Alert(x)) ::: If someone is impossible and not careful, then he is not technical and not alert.\n((¬Lovely(x) ∧ Impossible(x))) → (Attractive(x)) ::: If someone who is not lovely is also impossible, then he is attractive.\n((Concerned(x) ∧ ¬Impossible(x))) → (¬Attractive(shane) ∧ Technical(lamont)) ::: If there is someone who is both careful and not impossible, then Shane is not attractive and Lamont is technical.\n((Impossible(lamont))) ↔ (Attractive(max) ∧ ¬Lovely(barry)) ::: Lamont being impossible is equivalent to Max being attractive and Barry being not lovely.\n((Attractive(x) ∨ Lovely(x))) → (Impossible(x)) ::: Someone who is either attractive or lovely is always impossible.\n((Attractive(shane) ∨ ¬Alert(shane))) → (Impossible(shane)) ::: If Shane is attractive or Shane is not alert, then Shane is impossible.\n((Impossible(max) ∧ Attractive(barry))) ↔ (Concerned(tristan) ∧ Alert(max)) ::: Max being impossible and Barry being attractive are equivalent to Tristan being careful and Max being alert.\n((Attractive(max))) ↔ (¬Concerned(tristan)) ::: Max being attractive is equivalent to Tristan being not careful.\n((¬Alert(x) ∨ ¬Technical(x))) → (Impossible(tristan)) ::: If there is someone who is either not alert or not technical, then Tristan is impossible.\n((¬Concerned(x))) → (Attractive(lesley) ∧ Impossible(lamont)) ::: If there is someone who is not careful, then Lesley is attractive and Lamont is impossible.\n",
            "First-Order-Logic Question": "Technical(barry) ::: Barry is technical."
        },
        "diff": [
            {
                "raw": "((∃x (Attractive(x) ∨ Concerned(x))) → ((Impossible(lesley) ∧ Alert(cyril))) ::: If there is someone who is either attractive or careful, then Lesley is impossible and Cyril is alert.",
                "gram": "(((Serious(x)))) ::: If there is someone who is either attractive or careful, then Lesley is impossible and Cyril is alert."
            }
        ],
        "answer": "C",
        "grammar_answer": "A",
        "manual_prog": {
            "First-Order-Logic Rules": "¬Technical(cyril) ::: Cyril is not technical.\n¬Alert(max) ::: Max is not alert.\nImpossible(barry) ::: Barry is impossible.\nLovely(max) ::: Max is lovely.\nImpossible(cyril) ::: Cyril is impossible.\n¬Attractive(cyril) ::: Cyril is not attractive.\nTechnical(shane) ::: Shane is technical.\n¬Lovely(tristan) ::: Tristan is not lovely.\n¬Alert(lamont) ::: Lamont is not alert.\n¬Impossible(max) ::: Max is not impossible.\nAttractive(lamont) ::: Lamont is attractive.\n¬Technical(max) ::: Max is not technical.\n((∃x (Attractive(x) ∨ Concerned(x))) → ((Impossible(lesley) ∧ Alert(cyril)))) ::: If there is someone who is either attractive or careful, then Lesley is impossible and Cyril is alert.\n((Lovely(x) ∧ Alert(x))) → (Attractive(x)) ::: If someone is both lovely and alert, then he is attractive.\n((Impossible(x) ∧ ¬Concerned(x))) → (¬Technical(x) ∧ ¬Alert(x)) ::: If someone is impossible and not careful, then he is not technical and not alert.\n((¬Lovely(x) ∧ Impossible(x))) → (Attractive(x)) ::: If someone who is not lovely is also impossible, then he is attractive.\n((Concerned(x) ∧ ¬Impossible(x))) → (¬Attractive(shane) ∧ Technical(lamont)) ::: If there is someone who is both careful and not impossible, then Shane is not attractive and Lamont is technical.\n((Impossible(lamont))) ↔ (Attractive(max) ∧ ¬Lovely(barry)) ::: Lamont being impossible is equivalent to Max being attractive and Barry being not lovely.\n((Attractive(x) ∨ Lovely(x))) → (Impossible(x)) ::: Someone who is either attractive or lovely is always impossible.\n((Attractive(shane) ∨ ¬Alert(shane))) → (Impossible(shane)) ::: If Shane is attractive or Shane is not alert, then Shane is impossible.\n((Impossible(max) ∧ Attractive(barry))) ↔ (Concerned(tristan) ∧ Alert(max)) ::: Max being impossible and Barry being attractive are equivalent to Tristan being careful and Max being alert.\n((Attractive(max))) ↔ (¬Concerned(tristan)) ::: Max being attractive is equivalent to Tristan being not careful.\n((¬Alert(x) ∨ ¬Technical(x))) → (Impossible(tristan)) ::: If there is someone who is either not alert or not technical, then Tristan is impossible.\n((¬Concerned(x))) → (Attractive(lesley) ∧ Impossible(lamont)) ::: If there is someone who is not careful, then Lesley is attractive and Lamont is impossible.\n",
            "First-Order-Logic Question": "Technical(barry) ::: Barry is technical."
        },
        "fixed": true
    },
    {
        "id": 675,
        "raw_prog": {
            "First-Order-Logic Rules": "Sparkling(rolf) ::: Rolf is sparkling.\n¬Civil(broderick) ::: Broderick is not civil.\nSparkling(lamont) ::: Lamont is sparkling.\nLong(rolf) ::: Rolf is long.\n¬Poor(owen) ::: Owen is not poor.\n¬Technical(myra) ::: Myra is not technical.\n¬Poor(rolf) ::: Rolf is not poor.\n¬Civil(myra) ::: Myra is not civil.\n¬Cheap(lamont) ::: Lamont is not cheap.\n¬Cheap(montague) ::: Montague is not cheap.\n¬Poor(montague) ::: Montague is not poor.\n¬Sparkling(broderick) ::: Broderick is not sparkling.\n(∀x ((¬Sparkling(x) ∧ ¬Civil(x)) ↔ (Long(x) ∧ ¬Cheap(x)))) ::: Someone being neither sparkling nor civil is equivalent to being long and not cheap.\n(∀x (Poor(x) ∨ ¬Poor(x)) → (Cheap(x))) ::: If someone is or or not poor, then he is cheap.\n(∃x (¬Cheap(x))) → ((Civil(myra) ∧ Poor(montague))) ::: If there is at least one people who is not cheap, then Myra is civil and Montague is poor.\n(∀x (Poor(x))) → (Long(montague)) ::: If everyone is poor, then Montague is long.\n(¬Cheap(leroy)) ↔ (¬Technical(leroy)) ::: If Leroy is not cheap, then Leroy is not technical, and vice versa.\n(∃x (Poor(x) ∨ ¬Technical(x))) → (Long(rolf)) ::: If there is someone who is either poor or not technical, then Rolf is long.\n(∀x ((Technical(x) ∧ ¬Cheap(x)) → (¬Long(x) ∧ ¬Poor(x)))) ::: As long as someone is technical and not cheap, he is not long and not poor.\n(Poor(rolf)) → ((Cheap(lamont) ∧ ¬Civil(lamont))) ∧ (¬Poor(rolf)) → ((¬Cheap(lamont) ∨ Civil(lamont))) ::: If Rolf is poor, then Lamont is cheap and Lamont is not civil, and vice versa.\n(∃x (Sparkling(x) ∨ Poor(x))) → (¬Long(leroy)) ::: If there is someone who is either sparkling or poor, then Leroy is not long.\n(∀x ((Cheap(x) ∨ ¬Sparkling(x))) → (¬Long(broderick))) ::: If all people are cheap or not sparkling, then Broderick is not long.\n(Cheap(myra)) → (Poor(rolf)) ∧ (¬Cheap(myra)) → (¬Poor(rolf) ::: If Myra is cheap, then Rolf is poor, and vice versa.\n(¬Long(leroy)) → (Poor(leroy) ∧ ¬Technical(broderick)) ∧ (¬¬Long(leroy)) → (¬Poor(leroy) ∨ Technical(broderick)) ::: If Leroy is not long, then Leroy is poor and Broderick is not technical, and vice versa.\n",
            "First-Order-Logic Question": "¬Technical(montague) ::: Montague is not technical."
        },
        "gram_prog": {
            "First-Order-Logic Rules": "Sparkling(rolf) ::: Rolf is sparkling.\n¬Civil(broderick) ::: Broderick is not civil.\nSparkling(lamont) ::: Lamont is sparkling.\nLong(rolf) ::: Rolf is long.\n¬Poor(owen) ::: Owen is not poor.\n¬Technical(myra) ::: Myra is not technical.\n¬Poor(rolf) ::: Rolf is not poor.\n¬Civil(myra) ::: Myra is not civil.\n¬Cheap(lamont) ::: Lamont is not cheap.\n¬Cheap(montague) ::: Montague is not cheap.\n¬Poor(montague) ::: Montague is not poor.\n¬Sparkling(broderick) ::: Broderick is not sparkling.\n(∀x ((¬Sparkling(x) ∧ ¬Civil(x)) ↔ (Long(x) ∧ ¬Cheap(x)))) ::: Someone being neither sparkling nor civil is equivalent to being long and not cheap.\n(∀x (Poor(x) ∨ ¬Poor(x)) → (Cheap(x))) ::: If someone is or or not poor, then he is cheap.\n(∃x (¬Cheap(x))) → ((Civil(myra) ∧ Poor(montague))) ::: If there is at least one people who is not cheap, then Myra is civil and Montague is poor.\n(∀x (Poor(x))) → (Long(montague)) ::: If everyone is poor, then Montague is long.\n(¬Cheap(leroy)) ↔ (¬Technical(leroy)) ::: If Leroy is not cheap, then Leroy is not technical, and vice versa.\n(∃x (Poor(x) ∨ ¬Technical(x))) → (Long(rolf)) ::: If there is someone who is either poor or not technical, then Rolf is long.\n(∀x ((Technical(x) ∧ ¬Cheap(x)) → (¬Long(x) ∧ ¬Poor(x)))) ::: As long as someone is technical and not cheap, he is not long and not poor.\n(Poor(rolf)) → ((Cheap(lamont) ∧ ¬Civil(lamont))) ∧ (¬Poor(rolf)) → ((¬Cheap(lamont) ∨ Civil(lamont))) ::: If Rolf is poor, then Lamont is cheap and Lamont is not civil, and vice versa.\n(∃x (Sparkling(x) ∨ Poor(x))) → (¬Long(leroy)) ::: If there is someone who is either sparkling or poor, then Leroy is not long.\n(∀x ((Cheap(x) ∨ ¬Sparkling(x))) → (¬Long(broderick))) ::: If all people are cheap or not sparkling, then Broderick is not long.\nCheap(x)→(Poor(x))∧¬Cheap(x)→¬Poor(x) ::: If Myra is cheap, then Rolf is poor, and vice versa.\n¬Long(x)→(Poor(x)∧¬Technical(y)) ::: If Leroy is not long, then Leroy is poor and Broderick is not technical, and vice versa.\n",
            "First-Order-Logic Question": "¬Technical(montague) ::: Montague is not technical."
        },
        "diff": [
            {
                "raw": "(Cheap(myra)) → (Poor(rolf)) ∧ (¬Cheap(myra)) → (¬Poor(rolf) ::: If Myra is cheap, then Rolf is poor, and vice versa.",
                "gram": "Cheap(x)→(Poor(x))∧¬Cheap(x)→¬Poor(x) ::: If Myra is cheap, then Rolf is poor, and vice versa."
            },
            {
                "raw": "(¬Long(leroy)) → (Poor(leroy) ∧ ¬Technical(broderick)) ∧ (¬¬Long(leroy)) → (¬Poor(leroy) ∨ Technical(broderick)) ::: If Leroy is not long, then Leroy is poor and Broderick is not technical, and vice versa.",
                "gram": "¬Long(x)→(Poor(x)∧¬Technical(y)) ::: If Leroy is not long, then Leroy is poor and Broderick is not technical, and vice versa."
            }
        ],
        "answer": "C",
        "grammar_answer": "A",
        "manual_prog": {
            "First-Order-Logic Rules": "Sparkling(rolf) ::: Rolf is sparkling.\n¬Civil(broderick) ::: Broderick is not civil.\nSparkling(lamont) ::: Lamont is sparkling.\nLong(rolf) ::: Rolf is long.\n¬Poor(owen) ::: Owen is not poor.\n¬Technical(myra) ::: Myra is not technical.\n¬Poor(rolf) ::: Rolf is not poor.\n¬Civil(myra) ::: Myra is not civil.\n¬Cheap(lamont) ::: Lamont is not cheap.\n¬Cheap(montague) ::: Montague is not cheap.\n¬Poor(montague) ::: Montague is not poor.\n¬Sparkling(broderick) ::: Broderick is not sparkling.\n(∀x ((¬Sparkling(x) ∧ ¬Civil(x)) ↔ (Long(x) ∧ ¬Cheap(x)))) ::: Someone being neither sparkling nor civil is equivalent to being long and not cheap.\n(∀x (Poor(x) ∨ ¬Poor(x)) → (Cheap(x))) ::: If someone is or or not poor, then he is cheap.\n(∃x (¬Cheap(x))) → ((Civil(myra) ∧ Poor(montague))) ::: If there is at least one people who is not cheap, then Myra is civil and Montague is poor.\n(∀x (Poor(x))) → (Long(montague)) ::: If everyone is poor, then Montague is long.\n(¬Cheap(leroy)) ↔ (¬Technical(leroy)) ::: If Leroy is not cheap, then Leroy is not technical, and vice versa.\n(∃x (Poor(x) ∨ ¬Technical(x))) → (Long(rolf)) ::: If there is someone who is either poor or not technical, then Rolf is long.\n(∀x ((Technical(x) ∧ ¬Cheap(x)) → (¬Long(x) ∧ ¬Poor(x)))) ::: As long as someone is technical and not cheap, he is not long and not poor.\n(Poor(rolf)) → ((Cheap(lamont) ∧ ¬Civil(lamont))) ∧ (¬Poor(rolf)) → ((¬Cheap(lamont) ∨ Civil(lamont))) ::: If Rolf is poor, then Lamont is cheap and Lamont is not civil, and vice versa.\n(∃x (Sparkling(x) ∨ Poor(x))) → (¬Long(leroy)) ::: If there is someone who is either sparkling or poor, then Leroy is not long.\n(∀x ((Cheap(x) ∨ ¬Sparkling(x))) → (¬Long(broderick))) ::: If all people are cheap or not sparkling, then Broderick is not long.\n(Cheap(myra)) → (Poor(rolf)) ∧ (¬Cheap(myra)) → (¬Poor(rolf)) ::: If Myra is cheap, then Rolf is poor, and vice versa.\n(¬Long(leroy)) → (Poor(leroy) ∧ ¬Technical(broderick)) ∧ (¬(¬Long(leroy))) → (¬Poor(leroy) ∨ Technical(broderick)) ::: If Leroy is not long, then Leroy is poor and Broderick is not technical, and vice versa.\n",
            "First-Order-Logic Question": "¬Technical(montague) ::: Montague is not technical."
        },
        "fixed": true
    },
    {
        "id": 805,
        "raw_prog": {
            "First-Order-Logic Rules": "¬Zany(dan) ::: Dan is not zany.\n¬Sour(kenyon) ::: Kenyon is not sour.\nAggressive(terry) ::: Terry is aggressive.\nZany(lesley) ::: Lesley is zany.\nAggressive(kenyon) ::: Kenyon is aggressive.\n¬Comfortable(melvin) ::: Melvin is not comfortable.\nHappy(melvin) ::: Melvin is happy.\nHappy(kenyon) ::: Kenyon is happy.\nComfortable(dan) ::: Dan is comfortable.\nZany(christopher) ::: Christopher is zany.\n¬Sour(terry) ::: Terry is not sour.\n¬Comfortable(christopher) ::: Christopher is not comfortable.\n((Bad(terry))) → ((Zany(melvin))) ::: If Terry is bad, then Melvin is zany.\n(∀x (¬Bad(x) ∨ ¬Aggressive(x))) → (∀x (Sour(x))) ::: If someone is not bad or not aggressive, then he is sour.\n((Aggressive(melvin) ∨ ¬Bad(melvin))) → ((¬Comfortable(terry))) ::: If Melvin is aggressive or Melvin is not bad, then Terry is not comfortable.\n(∀x (Aggressive(x))) ↔ (∀x (Zany(x))) ::: If someone is aggressive, then he is zany, and vice versa.\n((Comfortable(melvin) ∧ ¬Bad(melvin))) → ((Aggressive(graciela))) ::: If Melvin is comfortable and Melvin is not bad, then Graciela is aggressive.\n(Aggressive(lesley)) ↔ ((¬Happy(christopher) ∧ ¬Comfortable(kenyon))) ::: Lesley is aggressive if and only if Christopher is not happy and Kenyon is not comfortable.\n(∀x ((¬Bad(x) ∨ Happy(x))) → (¬Aggressive(x))) ::: If someone is he or not bad is happy, then he is not aggressive.\n(∃x ((¬Comfortable(x) ∧ ¬Happy(x))) → ((¬Aggressive(terry) ∧ Sour(terry))) ::: If there is someone who is neither comfortable nor happy, then Terry is not aggressive and Terry is sour.\n(∀x ((¬Zany(x) ∨ Happy(x))) → (¬Comfortable(x))) ::: If someone is he or not zany is happy, then he is not comfortable.\n(∀x ((Sour(x) ∧ ¬Comfortable(x))) ↔ (Zany(x))) ::: If someone is sour and not comfortable, then he is zany, and vice versa.\n(∀x ((Comfortable(x) ∧ ¬Aggressive(x))) ↔ (Sour(x) ∧ ¬Bad(x))) ::: Someone who is comfortable and not aggressive is always sour and not bad.\n(∃x (¬Happy(x))) → (¬Bad(melvin)) ::: If there is at least one people who is not happy, then Melvin is not bad.\n",
            "First-Order-Logic Question": "¬Aggressive(lesley) ::: Lesley is not aggressive."
        },
        "gram_prog": {
            "First-Order-Logic Rules": "¬Zany(dan) ::: Dan is not zany.\n¬Sour(kenyon) ::: Kenyon is not sour.\nAggressive(terry) ::: Terry is aggressive.\nZany(lesley) ::: Lesley is zany.\nAggressive(kenyon) ::: Kenyon is aggressive.\n¬Comfortable(melvin) ::: Melvin is not comfortable.\nHappy(melvin) ::: Melvin is happy.\nHappy(kenyon) ::: Kenyon is happy.\nComfortable(dan) ::: Dan is comfortable.\nZany(christopher) ::: Christopher is zany.\n¬Sour(terry) ::: Terry is not sour.\n¬Comfortable(christopher) ::: Christopher is not comfortable.\n((Bad(terry))) → ((Zany(melvin))) ::: If Terry is bad, then Melvin is zany.\n(∀x (¬Bad(x) ∨ ¬Aggressive(x))) → (∀x (Sour(x))) ::: If someone is not bad or not aggressive, then he is sour.\n((Aggressive(melvin) ∨ ¬Bad(melvin))) → ((¬Comfortable(terry))) ::: If Melvin is aggressive or Melvin is not bad, then Terry is not comfortable.\n(∀x (Aggressive(x))) ↔ (∀x (Zany(x))) ::: If someone is aggressive, then he is zany, and vice versa.\n((Comfortable(melvin) ∧ ¬Bad(melvin))) → ((Aggressive(graciela))) ::: If Melvin is comfortable and Melvin is not bad, then Graciela is aggressive.\n(Aggressive(lesley)) ↔ ((¬Happy(christopher) ∧ ¬Comfortable(kenyon))) ::: Lesley is aggressive if and only if Christopher is not happy and Kenyon is not comfortable.\n(∀x ((¬Bad(x) ∨ Happy(x))) → (¬Aggressive(x))) ::: If someone is he or not bad is happy, then he is not aggressive.\n¬Comfortable(x)∧¬Happy(x)→¬Aggressive(x)∧Sour(x) ::: If there is someone who is neither comfortable nor happy, then Terry is not aggressive and Terry is sour.\n(∀x ((¬Zany(x) ∨ Happy(x))) → (¬Comfortable(x))) ::: If someone is he or not zany is happy, then he is not comfortable.\n(∀x ((Sour(x) ∧ ¬Comfortable(x))) ↔ (Zany(x))) ::: If someone is sour and not comfortable, then he is zany, and vice versa.\n(∀x ((Comfortable(x) ∧ ¬Aggressive(x))) ↔ (Sour(x) ∧ ¬Bad(x))) ::: Someone who is comfortable and not aggressive is always sour and not bad.\n(∃x (¬Happy(x))) → (¬Bad(melvin)) ::: If there is at least one people who is not happy, then Melvin is not bad.\n",
            "First-Order-Logic Question": "¬Aggressive(lesley) ::: Lesley is not aggressive."
        },
        "diff": [
            {
                "raw": "(∃x ((¬Comfortable(x) ∧ ¬Happy(x))) → ((¬Aggressive(terry) ∧ Sour(terry))) ::: If there is someone who is neither comfortable nor happy, then Terry is not aggressive and Terry is sour.",
                "gram": "¬Comfortable(x)∧¬Happy(x)→¬Aggressive(x)∧Sour(x) ::: If there is someone who is neither comfortable nor happy, then Terry is not aggressive and Terry is sour."
            }
        ],
        "answer": "B",
        "grammar_answer": "A",
        "manual_prog": {
            "First-Order-Logic Rules": "¬Zany(dan) ::: Dan is not zany.\n¬Sour(kenyon) ::: Kenyon is not sour.\nAggressive(terry) ::: Terry is aggressive.\nZany(lesley) ::: Lesley is zany.\nAggressive(kenyon) ::: Kenyon is aggressive.\n¬Comfortable(melvin) ::: Melvin is not comfortable.\nHappy(melvin) ::: Melvin is happy.\nHappy(kenyon) ::: Kenyon is happy.\nComfortable(dan) ::: Dan is comfortable.\nZany(christopher) ::: Christopher is zany.\n¬Sour(terry) ::: Terry is not sour.\n¬Comfortable(christopher) ::: Christopher is not comfortable.\n((Bad(terry))) → ((Zany(melvin))) ::: If Terry is bad, then Melvin is zany.\n(∀x (¬Bad(x) ∨ ¬Aggressive(x))) → (∀x (Sour(x))) ::: If someone is not bad or not aggressive, then he is sour.\n((Aggressive(melvin) ∨ ¬Bad(melvin))) → ((¬Comfortable(terry))) ::: If Melvin is aggressive or Melvin is not bad, then Terry is not comfortable.\n(∀x (Aggressive(x))) ↔ (∀x (Zany(x))) ::: If someone is aggressive, then he is zany, and vice versa.\n((Comfortable(melvin) ∧ ¬Bad(melvin))) → ((Aggressive(graciela))) ::: If Melvin is comfortable and Melvin is not bad, then Graciela is aggressive.\n(Aggressive(lesley)) ↔ ((¬Happy(christopher) ∧ ¬Comfortable(kenyon))) ::: Lesley is aggressive if and only if Christopher is not happy and Kenyon is not comfortable.\n(∀x ((¬Bad(x) ∨ Happy(x))) → (¬Aggressive(x))) ::: If someone is he or not bad is happy, then he is not aggressive.\n(∃x ((¬Comfortable(x) ∧ ¬Happy(x))) → ((¬Aggressive(terry) ∧ Sour(terry)))) ::: If there is someone who is neither comfortable nor happy, then Terry is not aggressive and Terry is sour.\n(∀x ((¬Zany(x) ∨ Happy(x))) → (¬Comfortable(x))) ::: If someone is he or not zany is happy, then he is not comfortable.\n(∀x ((Sour(x) ∧ ¬Comfortable(x))) ↔ (Zany(x))) ::: If someone is sour and not comfortable, then he is zany, and vice versa.\n(∀x ((Comfortable(x) ∧ ¬Aggressive(x))) ↔ (Sour(x) ∧ ¬Bad(x))) ::: Someone who is comfortable and not aggressive is always sour and not bad.\n(∃x (¬Happy(x))) → (¬Bad(melvin)) ::: If there is at least one people who is not happy, then Melvin is not bad.\n",
            "First-Order-Logic Question": "¬Aggressive(lesley) ::: Lesley is not aggressive."
        },
        "fixed": true
    },
    {
        "id": 834,
        "raw_prog": {
            "First-Order-Logic Rules": "¬Straightforward(blaine) ::: Blaine is straightforward.\nFrank(aldrich) ::: Aldrich is frank.\n¬Straightforward(aldrich) ::: Aldrich is not straightforward.\n¬Busy(brandi) ::: Brandi is not busy.\nGleaming(aldrich) ::: Aldrich is gleaming.\nBusy(aldrich) ::: Aldrich is busy.\n¬Frank(barry) ::: Barry is not frank.\nBusy(cyril) ::: Cyril is busy.\n¬Busy(barry) ::: Barry is not busy.\nPoised(brandi) ::: Brandi is poised.\n¬Poised(aldrich) ::: Aldrich is not poised.\nEnergetic(cyril) ::: Cyril is energetic.\n((¬Busy(cyril)) ∨ Gleaming(barry)) → Frank(brandi) ::: It can be concluded that Brandi is frank once knowing that Cyril is not busy or Barry is gleaming.\n((Poised(x) ∧ ¬Busy(x))) ↔ Energetic(x) ::: Someone being both poised and not busy is equivalent to being energetic.\n(∃x (¬Straightforward(x))) → ((¬Busy(barry) ∧ Gleaming(cyril))) ::: If there is at least one people who is not straightforward, then Barry is not busy and Cyril is gleaming.\n((Gleaming(x) ∨ Poised(x))) → ¬Busy(x) ::: Someone who is either gleaming or poised is always not busy.\n(¬Straightforward(burgess)) → Energetic(blaine) ::: Burgess being not straightforward implies that Blaine is energetic.\n((Straightforward(x) ∧ Poised(x))) → (Busy(x) ∧ ¬Energetic(x)) ::: If someone is straightforward and poised, then he is busy and not energetic.\n((¬Busy(x)) ∨ (¬Energetic(x))) → (Gleaming(x) ∧ ¬Frank(x)) ::: As long as someone is either not busy or not energetic, he is gleaming and not frank.\n((¬Busy(blaine)) ∧ Poised(burgess)) → Gleaming(cyril) ::: It can be concluded that Cyril is gleaming once knowing that Blaine is not busy and Burgess is poised.\n((¬Poised(aldrich)) ∨ Straightforward(burgess)) → Energetic(aldrich) ::: It can be concluded that Aldrich is energetic once knowing that Aldrich is not poised or Burgess is straightforward.\n(∃x (¬Gleaming(x))) → ¬Frank(burgess) ::: If there is someone who is not gleaming, then Burgess is not frank.\n((¬Gleaming(cyril))) ↔ ((¬Poised(burgess) ∧ Frank(burgess))) ::: Cyril is not gleaming if and only if Burgess is not poised and Burgess is frank.\n((Poised(barry) ∨ Frank(cyril)) → Busy(blaine) ::: Barry being poised or Cyril being frank implies that Blaine is busy.\n",
            "First-Order-Logic Question": "Busy(brandi) ::: Brandi is busy."
        },
        "gram_prog": {
            "First-Order-Logic Rules": "¬Straightforward(blaine) ::: Blaine is straightforward.\nFrank(aldrich) ::: Aldrich is frank.\n¬Straightforward(aldrich) ::: Aldrich is not straightforward.\n¬Busy(brandi) ::: Brandi is not busy.\nGleaming(aldrich) ::: Aldrich is gleaming.\nBusy(aldrich) ::: Aldrich is busy.\n¬Frank(barry) ::: Barry is not frank.\nBusy(cyril) ::: Cyril is busy.\n¬Busy(barry) ::: Barry is not busy.\nPoised(brandi) ::: Brandi is poised.\n¬Poised(aldrich) ::: Aldrich is not poised.\nEnergetic(cyril) ::: Cyril is energetic.\n((¬Busy(cyril)) ∨ Gleaming(barry)) → Frank(brandi) ::: It can be concluded that Brandi is frank once knowing that Cyril is not busy or Barry is gleaming.\n((Poised(x) ∧ ¬Busy(x))) ↔ Energetic(x) ::: Someone being both poised and not busy is equivalent to being energetic.\n(∃x (¬Straightforward(x))) → ((¬Busy(barry) ∧ Gleaming(cyril))) ::: If there is at least one people who is not straightforward, then Barry is not busy and Cyril is gleaming.\n((Gleaming(x) ∨ Poised(x))) → ¬Busy(x) ::: Someone who is either gleaming or poised is always not busy.\n(¬Straightforward(burgess)) → Energetic(blaine) ::: Burgess being not straightforward implies that Blaine is energetic.\n((Straightforward(x) ∧ Poised(x))) → (Busy(x) ∧ ¬Energetic(x)) ::: If someone is straightforward and poised, then he is busy and not energetic.\n((¬Busy(x)) ∨ (¬Energetic(x))) → (Gleaming(x) ∧ ¬Frank(x)) ::: As long as someone is either not busy or not energetic, he is gleaming and not frank.\n((¬Busy(blaine)) ∧ Poised(burgess)) → Gleaming(cyril) ::: It can be concluded that Cyril is gleaming once knowing that Blaine is not busy and Burgess is poised.\n((¬Poised(aldrich)) ∨ Straightforward(burgess)) → Energetic(aldrich) ::: It can be concluded that Aldrich is energetic once knowing that Aldrich is not poised or Burgess is straightforward.\n(∃x (¬Gleaming(x))) → ¬Frank(burgess) ::: If there is someone who is not gleaming, then Burgess is not frank.\n((¬Gleaming(cyril))) ↔ ((¬Poised(burgess) ∧ Frank(burgess))) ::: Cyril is not gleaming if and only if Burgess is not poised and Burgess is frank.\n¬(Serious(x)→Fresh(x))∨(Entire(x)→Accurate(x)) ::: Barry being poised or Cyril being frank implies that Blaine is busy.\n",
            "First-Order-Logic Question": "Busy(brandi) ::: Brandi is busy."
        },
        "diff": [
            {
                "raw": "((Poised(barry) ∨ Frank(cyril)) → Busy(blaine) ::: Barry being poised or Cyril being frank implies that Blaine is busy.",
                "gram": "¬(Serious(x)→Fresh(x))∨(Entire(x)→Accurate(x)) ::: Barry being poised or Cyril being frank implies that Blaine is busy."
            }
        ],
        "answer": "B",
        "grammar_answer": "A",
        "manual_prog": {
            "First-Order-Logic Rules": "¬Straightforward(blaine) ::: Blaine is straightforward.\nFrank(aldrich) ::: Aldrich is frank.\n¬Straightforward(aldrich) ::: Aldrich is not straightforward.\n¬Busy(brandi) ::: Brandi is not busy.\nGleaming(aldrich) ::: Aldrich is gleaming.\nBusy(aldrich) ::: Aldrich is busy.\n¬Frank(barry) ::: Barry is not frank.\nBusy(cyril) ::: Cyril is busy.\n¬Busy(barry) ::: Barry is not busy.\nPoised(brandi) ::: Brandi is poised.\n¬Poised(aldrich) ::: Aldrich is not poised.\nEnergetic(cyril) ::: Cyril is energetic.\n((¬Busy(cyril)) ∨ Gleaming(barry)) → Frank(brandi) ::: It can be concluded that Brandi is frank once knowing that Cyril is not busy or Barry is gleaming.\n((Poised(x) ∧ ¬Busy(x))) ↔ Energetic(x) ::: Someone being both poised and not busy is equivalent to being energetic.\n(∃x (¬Straightforward(x))) → ((¬Busy(barry) ∧ Gleaming(cyril))) ::: If there is at least one people who is not straightforward, then Barry is not busy and Cyril is gleaming.\n((Gleaming(x) ∨ Poised(x))) → ¬Busy(x) ::: Someone who is either gleaming or poised is always not busy.\n(¬Straightforward(burgess)) → Energetic(blaine) ::: Burgess being not straightforward implies that Blaine is energetic.\n((Straightforward(x) ∧ Poised(x))) → (Busy(x) ∧ ¬Energetic(x)) ::: If someone is straightforward and poised, then he is busy and not energetic.\n((¬Busy(x)) ∨ (¬Energetic(x))) → (Gleaming(x) ∧ ¬Frank(x)) ::: As long as someone is either not busy or not energetic, he is gleaming and not frank.\n((¬Busy(blaine)) ∧ Poised(burgess)) → Gleaming(cyril) ::: It can be concluded that Cyril is gleaming once knowing that Blaine is not busy and Burgess is poised.\n((¬Poised(aldrich)) ∨ Straightforward(burgess)) → Energetic(aldrich) ::: It can be concluded that Aldrich is energetic once knowing that Aldrich is not poised or Burgess is straightforward.\n(∃x (¬Gleaming(x))) → ¬Frank(burgess) ::: If there is someone who is not gleaming, then Burgess is not frank.\n((¬Gleaming(cyril))) ↔ ((¬Poised(burgess) ∧ Frank(burgess))) ::: Cyril is not gleaming if and only if Burgess is not poised and Burgess is frank.\n((Poised(barry) ∨ Frank(cyril)) → Busy(blaine)) ::: Barry being poised or Cyril being frank implies that Blaine is busy.\n",
            "First-Order-Logic Question": "Busy(brandi) ::: Brandi is busy."
        },
        "fixed": true
    },
    {
        "id": 1022,
        "raw_prog": {
            "First-Order-Logic Rules": "Fat(tristan) ::: Tristan is fat.\n¬Straightforward(tristan) ::: Tristan is not straightforward.\n¬Hard(tristan) ::: Tristan is not hard.\n¬Hard(halsey) ::: Halsey is not hard.\nStraightforward(lewis) ::: Lewis is straightforward.\n¬Fat(noel) ::: Noel is not fat.\n¬Shiny(tristan) ::: Tristan is not shiny.\n¬Dry(lewis) ::: Lewis is not dry.\nZany(tristan) ::: Tristan is zany.\nDry(noel) ::: Noel is dry.\nShiny(noel) ::: Noel is shiny.\nShiny(lewis) ::: Lewis is shiny.\n(∀x ((¬Straightforward(x) ∨ ¬Fat(x)))) → (Shiny(noel)) ::: If all people are not straightforward or not fat, then Noel is shiny.\n(∀x (Hard(x))) ↔ (Straightforward(x)) ::: Someone being hard is equivalent to being straightforward.\n(∀x ((Fat(x) ∧ ¬Dry(x)))) ↔ (Shiny(x)) ::: Someone being both fat and not dry is equivalent to being shiny.\n(∀x (¬Dry(x))) ↔ (Hard(x)) ::: Someone is not dry if and only if he is hard.\n(∃x (Dry(x) ∧ Hard(x))) → (Fat(lewis)) ::: If there is someone who is both dry and hard, then Lewis is fat.\n(∃x ((¬Straightforward(x) ∨ ¬Shiny(x))) → (Fat(tristan)) ::: If there is at least one people who is not straightforward or not shiny, then Tristan is fat.\n(∀x ((Hard(x) ∨ Straightforward(x))) → (¬Zany(x))) ::: If someone is hard or he is straightforward, then he is not zany.\n(¬Dry(miles)) ↔ (¬Straightforward(lewis)) ::: Miles is not dry if and only if Lewis is not straightforward.\n(¬Zany(tristan)) ↔ (¬Dry(lewis)) ::: If Tristan is not zany, then Lewis is not dry, and vice versa.\n(∀x ((Zany(x) ∧ ¬Shiny(x))) → (Fat(x))) ::: If someone is both zany and not shiny, then he is fat.\n(∀x ((Fat(x) ∧ ¬Shiny(x))) → (¬Straightforward(x) ∧ ¬Dry(x))) ::: Someone who is fat and not shiny is always not straightforward and not dry.\n(¬Hard(miles)) ↔ (Dry(miles)) ::: Miles being not hard is equivalent to Miles being dry.\n",
            "First-Order-Logic Question": "¬Hard(noel) ::: Noel is not hard."
        },
        "gram_prog": {
            "First-Order-Logic Rules": "Fat(tristan) ::: Tristan is fat.\n¬Straightforward(tristan) ::: Tristan is not straightforward.\n¬Hard(tristan) ::: Tristan is not hard.\n¬Hard(halsey) ::: Halsey is not hard.\nStraightforward(lewis) ::: Lewis is straightforward.\n¬Fat(noel) ::: Noel is not fat.\n¬Shiny(tristan) ::: Tristan is not shiny.\n¬Dry(lewis) ::: Lewis is not dry.\nZany(tristan) ::: Tristan is zany.\nDry(noel) ::: Noel is dry.\nShiny(noel) ::: Noel is shiny.\nShiny(lewis) ::: Lewis is shiny.\n(∀x ((¬Straightforward(x) ∨ ¬Fat(x)))) → (Shiny(noel)) ::: If all people are not straightforward or not fat, then Noel is shiny.\n(∀x (Hard(x))) ↔ (Straightforward(x)) ::: Someone being hard is equivalent to being straightforward.\n(∀x ((Fat(x) ∧ ¬Dry(x)))) ↔ (Shiny(x)) ::: Someone being both fat and not dry is equivalent to being shiny.\n(∀x (¬Dry(x))) ↔ (Hard(x)) ::: Someone is not dry if and only if he is hard.\n(∃x (Dry(x) ∧ Hard(x))) → (Fat(lewis)) ::: If there is someone who is both dry and hard, then Lewis is fat.\n¬(Serious(x)∨Fresh(x))→Fresh(x) ::: If there is at least one people who is not straightforward or not shiny, then Tristan is fat.\n(∀x ((Hard(x) ∨ Straightforward(x))) → (¬Zany(x))) ::: If someone is hard or he is straightforward, then he is not zany.\n(¬Dry(miles)) ↔ (¬Straightforward(lewis)) ::: Miles is not dry if and only if Lewis is not straightforward.\n(¬Zany(tristan)) ↔ (¬Dry(lewis)) ::: If Tristan is not zany, then Lewis is not dry, and vice versa.\n(∀x ((Zany(x) ∧ ¬Shiny(x))) → (Fat(x))) ::: If someone is both zany and not shiny, then he is fat.\n(∀x ((Fat(x) ∧ ¬Shiny(x))) → (¬Straightforward(x) ∧ ¬Dry(x))) ::: Someone who is fat and not shiny is always not straightforward and not dry.\n(¬Hard(miles)) ↔ (Dry(miles)) ::: Miles being not hard is equivalent to Miles being dry.\n",
            "First-Order-Logic Question": "¬Hard(noel) ::: Noel is not hard."
        },
        "diff": [
            {
                "raw": "(∃x ((¬Straightforward(x) ∨ ¬Shiny(x))) → (Fat(tristan)) ::: If there is at least one people who is not straightforward or not shiny, then Tristan is fat.",
                "gram": "¬(Serious(x)∨Fresh(x))→Fresh(x) ::: If there is at least one people who is not straightforward or not shiny, then Tristan is fat."
            }
        ],
        "answer": "B",
        "grammar_answer": "A",
        "manual_prog": {
            "First-Order-Logic Rules": "Fat(tristan) ::: Tristan is fat.\n¬Straightforward(tristan) ::: Tristan is not straightforward.\n¬Hard(tristan) ::: Tristan is not hard.\n¬Hard(halsey) ::: Halsey is not hard.\nStraightforward(lewis) ::: Lewis is straightforward.\n¬Fat(noel) ::: Noel is not fat.\n¬Shiny(tristan) ::: Tristan is not shiny.\n¬Dry(lewis) ::: Lewis is not dry.\nZany(tristan) ::: Tristan is zany.\nDry(noel) ::: Noel is dry.\nShiny(noel) ::: Noel is shiny.\nShiny(lewis) ::: Lewis is shiny.\n(∀x ((¬Straightforward(x) ∨ ¬Fat(x)))) → (Shiny(noel)) ::: If all people are not straightforward or not fat, then Noel is shiny.\n(∀x (Hard(x))) ↔ (Straightforward(x)) ::: Someone being hard is equivalent to being straightforward.\n(∀x ((Fat(x) ∧ ¬Dry(x)))) ↔ (Shiny(x)) ::: Someone being both fat and not dry is equivalent to being shiny.\n(∀x (¬Dry(x))) ↔ (Hard(x)) ::: Someone is not dry if and only if he is hard.\n(∃x (Dry(x) ∧ Hard(x))) → (Fat(lewis)) ::: If there is someone who is both dry and hard, then Lewis is fat.\n(∃x ((¬Straightforward(x) ∨ ¬Shiny(x))) → (Fat(tristan))) ::: If there is at least one people who is not straightforward or not shiny, then Tristan is fat.\n(∀x ((Hard(x) ∨ Straightforward(x))) → (¬Zany(x))) ::: If someone is hard or he is straightforward, then he is not zany.\n(¬Dry(miles)) ↔ (¬Straightforward(lewis)) ::: Miles is not dry if and only if Lewis is not straightforward.\n(¬Zany(tristan)) ↔ (¬Dry(lewis)) ::: If Tristan is not zany, then Lewis is not dry, and vice versa.\n(∀x ((Zany(x) ∧ ¬Shiny(x))) → (Fat(x))) ::: If someone is both zany and not shiny, then he is fat.\n(∀x ((Fat(x) ∧ ¬Shiny(x))) → (¬Straightforward(x) ∧ ¬Dry(x))) ::: Someone who is fat and not shiny is always not straightforward and not dry.\n(¬Hard(miles)) ↔ (Dry(miles)) ::: Miles being not hard is equivalent to Miles being dry.\n",
            "First-Order-Logic Question": "¬Hard(noel) ::: Noel is not hard."
        },
        "fixed": true
    },
    {
        "id": 1068,
        "raw_prog": {
            "First-Order-Logic Rules": "¬Wonderful(cara) ::: Cara is not wonderful.\n¬Emotional(burgess) ::: Burgess is not emotional.\n¬Awful(howard) ::: Howard is not awful.\nAwful(conrad) ::: Conrad is awful.\n¬Wonderful(burgess) ::: Burgess is not wonderful.\nWonderful(howard) ::: Howard is wonderful.\nDry(kayleigh) ::: Kayleigh is dry.\n¬Wonderful(tyra) ::: Tyra is not wonderful.\nDry(howard) ::: Howard is dry.\nDrab(kayleigh) ::: Kayleigh is drab.\nEmotional(howard) ::: Howard is emotional.\nDry(tyra) ::: Tyra is dry.\n(¬Emotional(conrad)) ↔ (Drab(tyra)) ::: If Conrad is not emotional, then Tyra is drab, and vice versa.\n(¬Wonderful(x)) ↔ (¬Emotional(x)) ::: Someone being not wonderful is equivalent to being not emotional.\n((¬Emotional(kayleigh)) ∨ (¬Dry(cara))) → (Drab(conrad)) ::: Kayleigh being not emotional or Cara being not dry implies that Conrad is drab.\n(∃x (Drab(x) ∧ ¬Awful(x))) → (¬Wonderful(tyra)) ::: If there is at least one people who is both drab and not awful, then Tyra is not wonderful.\n((Wonderful(x) ∨ Emotional(x))) → ((¬Awful(x) ∧ ¬Drab(x))) ::: As long as someone is either wonderful or emotional, he is not awful and not drab.\n(∃x (Drab(x) ∨ ¬Dry(x))) → (Wonderful(tyra) ∧ Emotional(howard)) ::: If there is someone who is either drab or not dry, then Tyra is wonderful and Howard is emotional.\n(∀x (Drab(x) ∨ ¬Wonderful(x))) → (Emotional(howard)) ::: If everyone is drab or not wonderful, then Howard is emotional.\n(∃x (Awful(x))) → (Emotional(kayleigh) ∧ Wonderful(burgess)) ::: If there is someone who is awful, then Kayleigh is emotional and Burgess is wonderful.\n((¬Dry(kayleigh)) ↔ (Mushy(cara) ∧ Awful(broderick))) ::: Kayleigh is not dry if and only if Cara is mushy and Broderick is awful.\n(Dry(burgess)) ↔ (¬Awful(kayleigh)) ::: Burgess being dry is equivalent to Kayleigh being not awful.\n((Emotional(tyra)) → (¬Mushy(kayleigh) ∧ ¬Awful(conrad))) ::: If Tyra is emotional, then Kayleigh is not mushy and Conrad is not awful, and vice versa.\n((¬Wonderful(tyra) ∧ Drab(broderick)) → (Dry(burgess)) ::: If Tyra is not wonderful and Broderick is drab, then Burgess is dry.\n",
            "First-Order-Logic Question": "¬Drab(conrad) ::: Conrad is not drab."
        },
        "gram_prog": {
            "First-Order-Logic Rules": "¬Wonderful(cara) ::: Cara is not wonderful.\n¬Emotional(burgess) ::: Burgess is not emotional.\n¬Awful(howard) ::: Howard is not awful.\nAwful(conrad) ::: Conrad is awful.\n¬Wonderful(burgess) ::: Burgess is not wonderful.\nWonderful(howard) ::: Howard is wonderful.\nDry(kayleigh) ::: Kayleigh is dry.\n¬Wonderful(tyra) ::: Tyra is not wonderful.\nDry(howard) ::: Howard is dry.\nDrab(kayleigh) ::: Kayleigh is drab.\nEmotional(howard) ::: Howard is emotional.\nDry(tyra) ::: Tyra is dry.\n(¬Emotional(conrad)) ↔ (Drab(tyra)) ::: If Conrad is not emotional, then Tyra is drab, and vice versa.\n(¬Wonderful(x)) ↔ (¬Emotional(x)) ::: Someone being not wonderful is equivalent to being not emotional.\n((¬Emotional(kayleigh)) ∨ (¬Dry(cara))) → (Drab(conrad)) ::: Kayleigh being not emotional or Cara being not dry implies that Conrad is drab.\n(∃x (Drab(x) ∧ ¬Awful(x))) → (¬Wonderful(tyra)) ::: If there is at least one people who is both drab and not awful, then Tyra is not wonderful.\n((Wonderful(x) ∨ Emotional(x))) → ((¬Awful(x) ∧ ¬Drab(x))) ::: As long as someone is either wonderful or emotional, he is not awful and not drab.\n(∃x (Drab(x) ∨ ¬Dry(x))) → (Wonderful(tyra) ∧ Emotional(howard)) ::: If there is someone who is either drab or not dry, then Tyra is wonderful and Howard is emotional.\n(∀x (Drab(x) ∨ ¬Wonderful(x))) → (Emotional(howard)) ::: If everyone is drab or not wonderful, then Howard is emotional.\n(∃x (Awful(x))) → (Emotional(kayleigh) ∧ Wonderful(burgess)) ::: If there is someone who is awful, then Kayleigh is emotional and Burgess is wonderful.\n((¬Dry(kayleigh)) ↔ (Mushy(cara) ∧ Awful(broderick))) ::: Kayleigh is not dry if and only if Cara is mushy and Broderick is awful.\n(Dry(burgess)) ↔ (¬Awful(kayleigh)) ::: Burgess being dry is equivalent to Kayleigh being not awful.\n((Emotional(tyra)) → (¬Mushy(kayleigh) ∧ ¬Awful(conrad))) ::: If Tyra is emotional, then Kayleigh is not mushy and Conrad is not awful, and vice versa.\n¬(Serious(x)→Fresh(x))→(Entire(x)) ::: If Tyra is not wonderful and Broderick is drab, then Burgess is dry.\n",
            "First-Order-Logic Question": "¬Drab(conrad) ::: Conrad is not drab."
        },
        "diff": [
            {
                "raw": "((¬Wonderful(tyra) ∧ Drab(broderick)) → (Dry(burgess)) ::: If Tyra is not wonderful and Broderick is drab, then Burgess is dry.",
                "gram": "¬(Serious(x)→Fresh(x))→(Entire(x)) ::: If Tyra is not wonderful and Broderick is drab, then Burgess is dry."
            }
        ],
        "answer": "C",
        "grammar_answer": "A",
        "manual_prog": {
            "First-Order-Logic Rules": "¬Wonderful(cara) ::: Cara is not wonderful.\n¬Emotional(burgess) ::: Burgess is not emotional.\n¬Awful(howard) ::: Howard is not awful.\nAwful(conrad) ::: Conrad is awful.\n¬Wonderful(burgess) ::: Burgess is not wonderful.\nWonderful(howard) ::: Howard is wonderful.\nDry(kayleigh) ::: Kayleigh is dry.\n¬Wonderful(tyra) ::: Tyra is not wonderful.\nDry(howard) ::: Howard is dry.\nDrab(kayleigh) ::: Kayleigh is drab.\nEmotional(howard) ::: Howard is emotional.\nDry(tyra) ::: Tyra is dry.\n(¬Emotional(conrad)) ↔ (Drab(tyra)) ::: If Conrad is not emotional, then Tyra is drab, and vice versa.\n(¬Wonderful(x)) ↔ (¬Emotional(x)) ::: Someone being not wonderful is equivalent to being not emotional.\n((¬Emotional(kayleigh)) ∨ (¬Dry(cara))) → (Drab(conrad)) ::: Kayleigh being not emotional or Cara being not dry implies that Conrad is drab.\n(∃x (Drab(x) ∧ ¬Awful(x))) → (¬Wonderful(tyra)) ::: If there is at least one people who is both drab and not awful, then Tyra is not wonderful.\n((Wonderful(x) ∨ Emotional(x))) → ((¬Awful(x) ∧ ¬Drab(x))) ::: As long as someone is either wonderful or emotional, he is not awful and not drab.\n(∃x (Drab(x) ∨ ¬Dry(x))) → (Wonderful(tyra) ∧ Emotional(howard)) ::: If there is someone who is either drab or not dry, then Tyra is wonderful and Howard is emotional.\n(∀x (Drab(x) ∨ ¬Wonderful(x))) → (Emotional(howard)) ::: If everyone is drab or not wonderful, then Howard is emotional.\n(∃x (Awful(x))) → (Emotional(kayleigh) ∧ Wonderful(burgess)) ::: If there is someone who is awful, then Kayleigh is emotional and Burgess is wonderful.\n((¬Dry(kayleigh)) ↔ (Mushy(cara) ∧ Awful(broderick))) ::: Kayleigh is not dry if and only if Cara is mushy and Broderick is awful.\n(Dry(burgess)) ↔ (¬Awful(kayleigh)) ::: Burgess being dry is equivalent to Kayleigh being not awful.\n((Emotional(tyra)) → (¬Mushy(kayleigh) ∧ ¬Awful(conrad))) ::: If Tyra is emotional, then Kayleigh is not mushy and Conrad is not awful, and vice versa.\n((¬Wonderful(tyra) ∧ Drab(broderick)) → (Dry(burgess))) ::: If Tyra is not wonderful and Broderick is drab, then Burgess is dry.\n",
            "First-Order-Logic Question": "¬Drab(conrad) ::: Conrad is not drab."
        },
        "fixed": true
    },
    {
        "id": 1159,
        "raw_prog": {
            "First-Order-Logic Rules": "¬Wonderful(neal) ::: Neal is not wonderful.\nFat(janine) ::: Janine is fat.\nCultural(tyra) ::: Tyra is cultural.\nJittery(lewis) ::: Lewis is jittery.\nJittery(george) ::: George is jittery.\n¬Able(neal) ::: Neal is not able.\nExpensive(neal) ::: Neal is expensive.\nFat(george) ::: George is fat.\n¬Expensive(tyra) ::: Tyra is not expensive.\nAble(clarence) ::: Clarence is able.\n¬Fat(clarence) ::: Clarence is not fat.\n¬Jittery(neal) ::: Neal is not jittery.\n(∀x ((Able(x) ∧ Fat(x))) → (¬Expensive(x)) ::: If someone who is able is also fat, then he is not expensive.\n(∃x (Jittery(x) ∨ Expensive(x))) → (¬Cultural(george)) ::: If there is at least one people who is jittery or expensive, then George is not cultural.\n(Expensive(neal)) → ((¬Jittery(tyra) ∧ Wonderful(janine))) ::: Neal being expensive implies that Tyra is not jittery and Janine is wonderful.\n(¬Wonderful(neal)) ↔ (Able(janine)) ::: If Neal is not wonderful, then Janine is able, and vice versa.\n(∃x (¬Able(x))) → (¬Wonderful(barry) ∧ ¬Jittery(clarence)) ::: If there is at least one people who is not able, then Barry is not wonderful and Clarence is not jittery.\n(∀x (Fat(x))) ↔ (¬Jittery(x)) ::: Someone is fat if and only if he is not jittery.\n(¬Expensive(lewis)) → (¬Cultural(tyra) ∧ ¬Wonderful(neal)) ::: It can be concluded that Tyra is not wonderful and Neal is not cultural once knowing that Lewis is not expensive.\n(∃x (Able(x))) → (¬Expensive(clarence)) ::: If there is someone who is able, then Clarence is not expensive.\n(∀x (¬Cultural(x) ∧ Wonderful(x))) → (Jittery(x)) ::: If someone who is not cultural is also wonderful, then he is jittery.\n(¬Cultural(george)) → (Jittery(lewis)) ::: It can be concluded that George is not cultural once knowing that Lewis is jittery.\n(∃x (¬Jittery(x))) → (Expensive(clarence) ∧ Cultural(neal)) ::: If there is at least one people who is not jittery, then Clarence is expensive and Neal is cultural.\n(∀x (¬Cultural(x) ∧ ¬Able(x))) ↔ (¬Expensive(x)) ::: Someone being neither cultural nor able is equivalent to being not expensive.\n",
            "First-Order-Logic Question": "Cultural(barry) ::: Barry is cultural."
        },
        "gram_prog": {
            "First-Order-Logic Rules": "¬Wonderful(neal) ::: Neal is not wonderful.\nFat(janine) ::: Janine is fat.\nCultural(tyra) ::: Tyra is cultural.\nJittery(lewis) ::: Lewis is jittery.\nJittery(george) ::: George is jittery.\n¬Able(neal) ::: Neal is not able.\nExpensive(neal) ::: Neal is expensive.\nFat(george) ::: George is fat.\n¬Expensive(tyra) ::: Tyra is not expensive.\nAble(clarence) ::: Clarence is able.\n¬Fat(clarence) ::: Clarence is not fat.\n¬Jittery(neal) ::: Neal is not jittery.\n∀x((Accurate(x)→Fresh(x))) ::: If someone who is able is also fat, then he is not expensive.\n(∃x (Jittery(x) ∨ Expensive(x))) → (¬Cultural(george)) ::: If there is at least one people who is jittery or expensive, then George is not cultural.\n(Expensive(neal)) → ((¬Jittery(tyra) ∧ Wonderful(janine))) ::: Neal being expensive implies that Tyra is not jittery and Janine is wonderful.\n(¬Wonderful(neal)) ↔ (Able(janine)) ::: If Neal is not wonderful, then Janine is able, and vice versa.\n(∃x (¬Able(x))) → (¬Wonderful(barry) ∧ ¬Jittery(clarence)) ::: If there is at least one people who is not able, then Barry is not wonderful and Clarence is not jittery.\n(∀x (Fat(x))) ↔ (¬Jittery(x)) ::: Someone is fat if and only if he is not jittery.\n(¬Expensive(lewis)) → (¬Cultural(tyra) ∧ ¬Wonderful(neal)) ::: It can be concluded that Tyra is not wonderful and Neal is not cultural once knowing that Lewis is not expensive.\n(∃x (Able(x))) → (¬Expensive(clarence)) ::: If there is someone who is able, then Clarence is not expensive.\n(∀x (¬Cultural(x) ∧ Wonderful(x))) → (Jittery(x)) ::: If someone who is not cultural is also wonderful, then he is jittery.\n(¬Cultural(george)) → (Jittery(lewis)) ::: It can be concluded that George is not cultural once knowing that Lewis is jittery.\n(∃x (¬Jittery(x))) → (Expensive(clarence) ∧ Cultural(neal)) ::: If there is at least one people who is not jittery, then Clarence is expensive and Neal is cultural.\n(∀x (¬Cultural(x) ∧ ¬Able(x))) ↔ (¬Expensive(x)) ::: Someone being neither cultural nor able is equivalent to being not expensive.\n",
            "First-Order-Logic Question": "Cultural(barry) ::: Barry is cultural."
        },
        "diff": [
            {
                "raw": "(∀x ((Able(x) ∧ Fat(x))) → (¬Expensive(x)) ::: If someone who is able is also fat, then he is not expensive.",
                "gram": "∀x((Accurate(x)→Fresh(x))) ::: If someone who is able is also fat, then he is not expensive."
            }
        ],
        "answer": "C",
        "grammar_answer": "A",
        "manual_prog": {
            "First-Order-Logic Rules": "¬Wonderful(neal) ::: Neal is not wonderful.\nFat(janine) ::: Janine is fat.\nCultural(tyra) ::: Tyra is cultural.\nJittery(lewis) ::: Lewis is jittery.\nJittery(george) ::: George is jittery.\n¬Able(neal) ::: Neal is not able.\nExpensive(neal) ::: Neal is expensive.\nFat(george) ::: George is fat.\n¬Expensive(tyra) ::: Tyra is not expensive.\nAble(clarence) ::: Clarence is able.\n¬Fat(clarence) ::: Clarence is not fat.\n¬Jittery(neal) ::: Neal is not jittery.\n(∀x ((Able(x) ∧ Fat(x))) → (¬Expensive(x))) ::: If someone who is able is also fat, then he is not expensive.\n(∃x (Jittery(x) ∨ Expensive(x))) → (¬Cultural(george)) ::: If there is at least one people who is jittery or expensive, then George is not cultural.\n(Expensive(neal)) → ((¬Jittery(tyra) ∧ Wonderful(janine))) ::: Neal being expensive implies that Tyra is not jittery and Janine is wonderful.\n(¬Wonderful(neal)) ↔ (Able(janine)) ::: If Neal is not wonderful, then Janine is able, and vice versa.\n(∃x (¬Able(x))) → (¬Wonderful(barry) ∧ ¬Jittery(clarence)) ::: If there is at least one people who is not able, then Barry is not wonderful and Clarence is not jittery.\n(∀x (Fat(x))) ↔ (¬Jittery(x)) ::: Someone is fat if and only if he is not jittery.\n(¬Expensive(lewis)) → (¬Cultural(tyra) ∧ ¬Wonderful(neal)) ::: It can be concluded that Tyra is not wonderful and Neal is not cultural once knowing that Lewis is not expensive.\n(∃x (Able(x))) → (¬Expensive(clarence)) ::: If there is someone who is able, then Clarence is not expensive.\n(∀x (¬Cultural(x) ∧ Wonderful(x))) → (Jittery(x)) ::: If someone who is not cultural is also wonderful, then he is jittery.\n(¬Cultural(george)) → (Jittery(lewis)) ::: It can be concluded that George is not cultural once knowing that Lewis is jittery.\n(∃x (¬Jittery(x))) → (Expensive(clarence) ∧ Cultural(neal)) ::: If there is at least one people who is not jittery, then Clarence is expensive and Neal is cultural.\n(∀x (¬Cultural(x) ∧ ¬Able(x))) ↔ (¬Expensive(x)) ::: Someone being neither cultural nor able is equivalent to being not expensive.\n",
            "First-Order-Logic Question": "Cultural(barry) ::: Barry is cultural."
        },
        "fixed": true
    },
    {
        "id": 1164,
        "raw_prog": {
            "First-Order-Logic Rules": "¬Wonderful(neal) ::: Neal is not wonderful.\nFat(janine) ::: Janine is fat.\nCultural(tyra) ::: Tyra is cultural.\nJittery(lewis) ::: Lewis is jittery.\nJittery(george) ::: George is jittery.\n¬Able(neal) ::: Neal is not able.\nExpensive(neal) ::: Neal is expensive.\nFat(george) ::: George is fat.\n¬Expensive(tyra) ::: Tyra is not expensive.\nAble(clarence) ::: Clarence is able.\n¬Fat(clarence) ::: Clarence is not fat.\n¬Jittery(neal) ::: Neal is not jittery.\n(∀x ((Able(x) ∧ Fat(x))) → (¬Expensive(x)) ::: If someone who is able is also fat, then he is not expensive.\n(∃x (Jittery(x) ∨ Expensive(x))) → (¬Cultural(george)) ::: If there is at least one people who is jittery or expensive, then George is not cultural.\n(Expensive(neal)) → (¬Jittery(tyra) ∧ Wonderful(janine)) ::: Neal being expensive implies that Tyra is not jittery and Janine is wonderful.\n(¬Wonderful(neal)) ↔ (Able(janine)) ::: If Neal is not wonderful, then Janine is able, and vice versa.\n(∃x (¬Able(x))) → (¬Wonderful(barry) ∧ ¬Jittery(clarence)) ::: If there is at least one people who is not able, then Barry is not wonderful and Clarence is not jittery.\n(∀x (Fat(x))) ↔ (¬Jittery(x)) ::: Someone is fat if and only if he is not jittery.\n(¬Expensive(lewis)) → (¬Cultural(tyra) ∧ ¬Wonderful(neal)) ::: It can be concluded that Tyra is not wonderful and Neal is not cultural once knowing that Lewis is not expensive.\n(∃x (Able(x))) → (¬Expensive(clarence)) ::: If there is someone who is able, then Clarence is not expensive.\n(∀x ((¬Cultural(x) ∧ Wonderful(x))) → (Jittery(x))) ::: If someone who is not cultural is also wonderful, then he is jittery.\n(¬Cultural(george)) → (Jittery(lewis)) ::: It can be concluded that George is not cultural once knowing that Lewis is jittery.\n(∃x (¬Jittery(x))) → (Expensive(clarence) ∧ Cultural(neal)) ::: If there is at least one people who is not jittery, then Clarence is expensive and Neal is cultural.\n(∀x ((¬Cultural(x) ∧ ¬Able(x))) ↔ (¬Expensive(x)) ::: Someone being neither cultural nor able is equivalent to being not expensive.\n",
            "First-Order-Logic Question": "Fat(barry) ::: Barry is fat."
        },
        "gram_prog": {
            "First-Order-Logic Rules": "¬Wonderful(neal) ::: Neal is not wonderful.\nFat(janine) ::: Janine is fat.\nCultural(tyra) ::: Tyra is cultural.\nJittery(lewis) ::: Lewis is jittery.\nJittery(george) ::: George is jittery.\n¬Able(neal) ::: Neal is not able.\nExpensive(neal) ::: Neal is expensive.\nFat(george) ::: George is fat.\n¬Expensive(tyra) ::: Tyra is not expensive.\nAble(clarence) ::: Clarence is able.\n¬Fat(clarence) ::: Clarence is not fat.\n¬Jittery(neal) ::: Neal is not jittery.\n∀x((Wonderful(x)→Cultural(x))) ::: If someone who is able is also fat, then he is not expensive.\n(∃x (Jittery(x) ∨ Expensive(x))) → (¬Cultural(george)) ::: If there is at least one people who is jittery or expensive, then George is not cultural.\n(Expensive(neal)) → (¬Jittery(tyra) ∧ Wonderful(janine)) ::: Neal being expensive implies that Tyra is not jittery and Janine is wonderful.\n(¬Wonderful(neal)) ↔ (Able(janine)) ::: If Neal is not wonderful, then Janine is able, and vice versa.\n(∃x (¬Able(x))) → (¬Wonderful(barry) ∧ ¬Jittery(clarence)) ::: If there is at least one people who is not able, then Barry is not wonderful and Clarence is not jittery.\n(∀x (Fat(x))) ↔ (¬Jittery(x)) ::: Someone is fat if and only if he is not jittery.\n(¬Expensive(lewis)) → (¬Cultural(tyra) ∧ ¬Wonderful(neal)) ::: It can be concluded that Tyra is not wonderful and Neal is not cultural once knowing that Lewis is not expensive.\n(∃x (Able(x))) → (¬Expensive(clarence)) ::: If there is someone who is able, then Clarence is not expensive.\n(∀x ((¬Cultural(x) ∧ Wonderful(x))) → (Jittery(x))) ::: If someone who is not cultural is also wonderful, then he is jittery.\n(¬Cultural(george)) → (Jittery(lewis)) ::: It can be concluded that George is not cultural once knowing that Lewis is jittery.\n(∃x (¬Jittery(x))) → (Expensive(clarence) ∧ Cultural(neal)) ::: If there is at least one people who is not jittery, then Clarence is expensive and Neal is cultural.\n¬Cultural(x)∧¬Able(x)↔¬Expensive(x) ::: Someone being neither cultural nor able is equivalent to being not expensive.\n",
            "First-Order-Logic Question": "Fat(barry) ::: Barry is fat."
        },
        "diff": [
            {
                "raw": "(∀x ((Able(x) ∧ Fat(x))) → (¬Expensive(x)) ::: If someone who is able is also fat, then he is not expensive.",
                "gram": "∀x((Wonderful(x)→Cultural(x))) ::: If someone who is able is also fat, then he is not expensive."
            },
            {
                "raw": "(∀x ((¬Cultural(x) ∧ ¬Able(x))) ↔ (¬Expensive(x)) ::: Someone being neither cultural nor able is equivalent to being not expensive.",
                "gram": "¬Cultural(x)∧¬Able(x)↔¬Expensive(x) ::: Someone being neither cultural nor able is equivalent to being not expensive."
            }
        ],
        "answer": "C",
        "grammar_answer": "A",
        "manual_prog": {
            "First-Order-Logic Rules": "¬Wonderful(neal) ::: Neal is not wonderful.\nFat(janine) ::: Janine is fat.\nCultural(tyra) ::: Tyra is cultural.\nJittery(lewis) ::: Lewis is jittery.\nJittery(george) ::: George is jittery.\n¬Able(neal) ::: Neal is not able.\nExpensive(neal) ::: Neal is expensive.\nFat(george) ::: George is fat.\n¬Expensive(tyra) ::: Tyra is not expensive.\nAble(clarence) ::: Clarence is able.\n¬Fat(clarence) ::: Clarence is not fat.\n¬Jittery(neal) ::: Neal is not jittery.\n(∀x ((Able(x) ∧ Fat(x))) → (¬Expensive(x))) ::: If someone who is able is also fat, then he is not expensive.\n(∃x (Jittery(x) ∨ Expensive(x))) → (¬Cultural(george)) ::: If there is at least one people who is jittery or expensive, then George is not cultural.\n(Expensive(neal)) → (¬Jittery(tyra) ∧ Wonderful(janine)) ::: Neal being expensive implies that Tyra is not jittery and Janine is wonderful.\n(¬Wonderful(neal)) ↔ (Able(janine)) ::: If Neal is not wonderful, then Janine is able, and vice versa.\n(∃x (¬Able(x))) → (¬Wonderful(barry) ∧ ¬Jittery(clarence)) ::: If there is at least one people who is not able, then Barry is not wonderful and Clarence is not jittery.\n(∀x (Fat(x))) ↔ (¬Jittery(x)) ::: Someone is fat if and only if he is not jittery.\n(¬Expensive(lewis)) → (¬Cultural(tyra) ∧ ¬Wonderful(neal)) ::: It can be concluded that Tyra is not wonderful and Neal is not cultural once knowing that Lewis is not expensive.\n(∃x (Able(x))) → (¬Expensive(clarence)) ::: If there is someone who is able, then Clarence is not expensive.\n(∀x ((¬Cultural(x) ∧ Wonderful(x))) → (Jittery(x))) ::: If someone who is not cultural is also wonderful, then he is jittery.\n(¬Cultural(george)) → (Jittery(lewis)) ::: It can be concluded that George is not cultural once knowing that Lewis is jittery.\n(∃x (¬Jittery(x))) → (Expensive(clarence) ∧ Cultural(neal)) ::: If there is at least one people who is not jittery, then Clarence is expensive and Neal is cultural.\n(∀x ((¬Cultural(x) ∧ ¬Able(x))) ↔ (¬Expensive(x))) ::: Someone being neither cultural nor able is equivalent to being not expensive.\n",
            "First-Order-Logic Question": "Fat(barry) ::: Barry is fat."
        },
        "fixed": true
    },
    {
        "id": 1205,
        "raw_prog": {
            "First-Order-Logic Rules": "¬Several(rolf) ::: Rolf is not several.\n¬Precious(sigmund) ::: Sigmund is not precious.\nPrecious(godwin) ::: Godwin is precious.\nFearless(sigmund) ::: Sigmund is fearless.\nPrecious(rolf) ::: Rolf is precious.\n¬Stubborn(rose) ::: Rose is not stubborn.\nJittery(conrad) ::: Conrad is jittery.\n¬Fearless(brandi) ::: Brandi is not fearless.\n¬Sour(brandi) ::: Brandi is not sour.\nJittery(rolf) ::: Rolf is jittery.\nStubborn(owen) ::: Owen is stubborn.\n¬Fearless(godwin) ::: Godwin is not fearless.\n(∀x (¬¬x)) → (¬Jittery(godwin)) ::: If there is nobody who is not, then Godwin is not jittery.\n(∃x (Several(x) ∨ ¬Sour(x))) → (¬Stubborn(brandi)) ::: If there is someone who is either several or not sour, then Brandi is not stubborn.\n(∃x (¬Sour(x))) → (¬Stubborn(owen) ∧ ¬Several(conrad)) ::: If there is at least one people who is not sour, then Owen is not stubborn and Conrad is not several.\n(∀x (Several(x) → ¬Sour(x))) → (Stubborn(x)) ::: If someone who is several is also not sour, then he is stubborn.\n(∃x (Sour(x) ∨ Jittery(x))) → (¬Several(brandi) ∧ Stubborn(conrad)) ::: If there is at least one people who is either sour or jittery, then Brandi is not several and Conrad is stubborn.\n(¬Fearless(rolf)) → (¬Jittery(conrad)) ::: If Rolf is not fearless, then Conrad is not jittery.\n(¬Precious(godwin)) → (Jittery(godwin) ∧ ¬Fearless(owen)) ::: It can be concluded that Godwin is jittery and Owen is not fearless once knowing that Godwin is not precious.\n(¬Jittery(sigmund) ∧ ¬Several(sigmund)) → (Precious(sigmund)) ::: It can be concluded that Sigmund is precious once knowing that Godwin is not jittery and Sigmund is not several.\n((Several(rolf) ∨ Fearless(brandi))) → (¬Precious(brandi)) ::: If Rolf is several or Brandi is fearless, then Brandi is not precious.\n(¬Jittery(godwin) ∧ Several(conrad)) → (Sour(owen)) ::: If Godwin is not jittery and Conrad is several, then Owen is sour.\n(∀x (Precious(x))) → (¬Several(x)) ::: Someone who is precious is always not several.\n(¬Fearless(godwin)) ↔ (Several(brandi)) ::: If Godwin is not fearless, then Brandi is several, and vice versa.\n",
            "First-Order-Logic Question": "Fearless(owen) ::: Owen is fearless."
        },
        "gram_prog": {
            "First-Order-Logic Rules": "¬Several(rolf) ::: Rolf is not several.\n¬Precious(sigmund) ::: Sigmund is not precious.\nPrecious(godwin) ::: Godwin is precious.\nFearless(sigmund) ::: Sigmund is fearless.\nPrecious(rolf) ::: Rolf is precious.\n¬Stubborn(rose) ::: Rose is not stubborn.\nJittery(conrad) ::: Conrad is jittery.\n¬Fearless(brandi) ::: Brandi is not fearless.\n¬Sour(brandi) ::: Brandi is not sour.\nJittery(rolf) ::: Rolf is jittery.\nStubborn(owen) ::: Owen is stubborn.\n¬Fearless(godwin) ::: Godwin is not fearless.\n¬¬(¬(¬(¬Serious(x)))) ::: If there is nobody who is not, then Godwin is not jittery.\n(∃x (Several(x) ∨ ¬Sour(x))) → (¬Stubborn(brandi)) ::: If there is someone who is either several or not sour, then Brandi is not stubborn.\n(∃x (¬Sour(x))) → (¬Stubborn(owen) ∧ ¬Several(conrad)) ::: If there is at least one people who is not sour, then Owen is not stubborn and Conrad is not several.\n(∀x (Several(x) → ¬Sour(x))) → (Stubborn(x)) ::: If someone who is several is also not sour, then he is stubborn.\n(∃x (Sour(x) ∨ Jittery(x))) → (¬Several(brandi) ∧ Stubborn(conrad)) ::: If there is at least one people who is either sour or jittery, then Brandi is not several and Conrad is stubborn.\n(¬Fearless(rolf)) → (¬Jittery(conrad)) ::: If Rolf is not fearless, then Conrad is not jittery.\n(¬Precious(godwin)) → (Jittery(godwin) ∧ ¬Fearless(owen)) ::: It can be concluded that Godwin is jittery and Owen is not fearless once knowing that Godwin is not precious.\n(¬Jittery(sigmund) ∧ ¬Several(sigmund)) → (Precious(sigmund)) ::: It can be concluded that Sigmund is precious once knowing that Godwin is not jittery and Sigmund is not several.\n((Several(rolf) ∨ Fearless(brandi))) → (¬Precious(brandi)) ::: If Rolf is several or Brandi is fearless, then Brandi is not precious.\n(¬Jittery(godwin) ∧ Several(conrad)) → (Sour(owen)) ::: If Godwin is not jittery and Conrad is several, then Owen is sour.\n(∀x (Precious(x))) → (¬Several(x)) ::: Someone who is precious is always not several.\n(¬Fearless(godwin)) ↔ (Several(brandi)) ::: If Godwin is not fearless, then Brandi is several, and vice versa.\n",
            "First-Order-Logic Question": "Fearless(owen) ::: Owen is fearless."
        },
        "diff": [
            {
                "raw": "(∀x (¬¬x)) → (¬Jittery(godwin)) ::: If there is nobody who is not, then Godwin is not jittery.",
                "gram": "¬¬(¬(¬(¬Serious(x)))) ::: If there is nobody who is not, then Godwin is not jittery."
            }
        ],
        "answer": "C",
        "grammar_answer": "A",
        "manual_prog": {
            "First-Order-Logic Rules": "¬Several(rolf) ::: Rolf is not several.\n¬Precious(sigmund) ::: Sigmund is not precious.\nPrecious(godwin) ::: Godwin is precious.\nFearless(sigmund) ::: Sigmund is fearless.\nPrecious(rolf) ::: Rolf is precious.\n¬Stubborn(rose) ::: Rose is not stubborn.\nJittery(conrad) ::: Conrad is jittery.\n¬Fearless(brandi) ::: Brandi is not fearless.\n¬Sour(brandi) ::: Brandi is not sour.\nJittery(rolf) ::: Rolf is jittery.\nStubborn(owen) ::: Owen is stubborn.\n¬Fearless(godwin) ::: Godwin is not fearless.\n(¬Jittery(godwin)) ::: If there is nobody who is not, then Godwin is not jittery.\n(∃x (Several(x) ∨ ¬Sour(x))) → (¬Stubborn(brandi)) ::: If there is someone who is either several or not sour, then Brandi is not stubborn.\n(∃x (¬Sour(x))) → (¬Stubborn(owen) ∧ ¬Several(conrad)) ::: If there is at least one people who is not sour, then Owen is not stubborn and Conrad is not several.\n(∀x (Several(x) → ¬Sour(x))) → (Stubborn(x)) ::: If someone who is several is also not sour, then he is stubborn.\n(∃x (Sour(x) ∨ Jittery(x))) → (¬Several(brandi) ∧ Stubborn(conrad)) ::: If there is at least one people who is either sour or jittery, then Brandi is not several and Conrad is stubborn.\n(¬Fearless(rolf)) → (¬Jittery(conrad)) ::: If Rolf is not fearless, then Conrad is not jittery.\n(¬Precious(godwin)) → (Jittery(godwin) ∧ ¬Fearless(owen)) ::: It can be concluded that Godwin is jittery and Owen is not fearless once knowing that Godwin is not precious.\n(¬Jittery(sigmund) ∧ ¬Several(sigmund)) → (Precious(sigmund)) ::: It can be concluded that Sigmund is precious once knowing that Godwin is not jittery and Sigmund is not several.\n((Several(rolf) ∨ Fearless(brandi))) → (¬Precious(brandi)) ::: If Rolf is several or Brandi is fearless, then Brandi is not precious.\n(¬Jittery(godwin) ∧ Several(conrad)) → (Sour(owen)) ::: If Godwin is not jittery and Conrad is several, then Owen is sour.\n(∀x (Precious(x))) → (¬Several(x)) ::: Someone who is precious is always not several.\n(¬Fearless(godwin)) ↔ (Several(brandi)) ::: If Godwin is not fearless, then Brandi is several, and vice versa.\n",
            "First-Order-Logic Question": "Fearless(owen) ::: Owen is fearless."
        },
        "fixed": true
    },
    {
        "id": 1451,
        "raw_prog": {
            "First-Order-Logic Rules": "Former(lowell) ::: Lowell is former.\nBored(lowell) ::: Lowell is bored.\n¬Immediate(lowell) ::: Lowell is not immediate.\n¬Bored(whitney) ::: Whitney is not bored.\n¬Expensive(ansel) ::: Ansel is not expensive.\nExpensive(dan) ::: Dan is expensive.\nFormer(whitney) ::: Whitney is former.\n¬Bored(benedict) ::: Benedict is not bored.\n¬Expensive(whitney) ::: Whitney is not expensive.\nBored(sigmund) ::: Sigmund is bored.\nExpensive(benedict) ::: Benedict is expensive.\n¬Granite(sigmund) ::: Sigmund is not granite.\n(∀x (Expensive(x))) → (¬Former(x)) ::: All expensive people are not former.\n(¬Bored(x)) ↔ (Former(x)) ::: Someone being bored is equivalent to being former.\n(¬Bored(lowell) ∧ ¬Putrid(benedict)) → (Granite(lowell)) ::: If Lowell is not bored and Benedict is not putrid, then Lowell is granite.\n(¬Former(whitney)) → (Granite(dan)) ::: If Whitney is not former, then Dan is granite.\n((¬Expensive(dan) ∧ ¬Former(dan))) → ((Bored(ansel) ∧ Immediate(lowell)) ∨ (Immediate(lowell))) ∧ ((Bored(ansel) ∧ Immediate(lowell)) → ((¬Expensive(dan) ∧ ¬Former(dan))) ::: If Dan is not expensive and Dan is not former, then Ansel is bored and Lowell is immediate, and vice versa.\n(∀x (Immediate(x))) → ((¬Expensive(benedict) ∧ Granite(dan))) ::: If all people are immediate, then Benedict is not expensive and Dan is granite.\n(∀x (Bored(x) ∨ Immediate(x))) → (¬Granite(x)) ::: If someone is bored or immediate, then he is not granite.\n((¬Bored(whitney) ∨ ¬Expensive(dan))) → (Granite(sigmund)) ::: If Whitney is not bored or Dan is not expensive, then Sigmund is granite.\n(Granite(x) ∧ Former(x)) ↔ (Immediate(x)) ::: If someone is granite and former, then he is immediate, and vice versa.\n(∃x (¬Expensive(x))) → (Granite(benedict) ∧ ¬Immediate(sigmund)) ::: If there is someone who is not expensive, then Benedict is granite and Sigmund is not immediate.\n(Granite(dan)) ↔ ((¬Expensive(dan) ∧ Immediate(whitney))) ::: Dan being granite is equivalent to Dan being not expensive and Whitney being immediate.\n",
            "First-Order-Logic Question": "Immediate(gregory) ::: Gregory is immediate."
        },
        "gram_prog": {
            "First-Order-Logic Rules": "Former(lowell) ::: Lowell is former.\nBored(lowell) ::: Lowell is bored.\n¬Immediate(lowell) ::: Lowell is not immediate.\n¬Bored(whitney) ::: Whitney is not bored.\n¬Expensive(ansel) ::: Ansel is not expensive.\nExpensive(dan) ::: Dan is expensive.\nFormer(whitney) ::: Whitney is former.\n¬Bored(benedict) ::: Benedict is not bored.\n¬Expensive(whitney) ::: Whitney is not expensive.\nBored(sigmund) ::: Sigmund is bored.\nExpensive(benedict) ::: Benedict is expensive.\n¬Granite(sigmund) ::: Sigmund is not granite.\n(∀x (Expensive(x))) → (¬Former(x)) ::: All expensive people are not former.\n(¬Bored(x)) ↔ (Former(x)) ::: Someone being bored is equivalent to being former.\n(¬Bored(lowell) ∧ ¬Putrid(benedict)) → (Granite(lowell)) ::: If Lowell is not bored and Benedict is not putrid, then Lowell is granite.\n(¬Former(whitney)) → (Granite(dan)) ::: If Whitney is not former, then Dan is granite.\n¬(Blue(x)→Serious(x))→((Blue(x))) ::: If Dan is not expensive and Dan is not former, then Ansel is bored and Lowell is immediate, and vice versa.\n(∀x (Immediate(x))) → ((¬Expensive(benedict) ∧ Granite(dan))) ::: If all people are immediate, then Benedict is not expensive and Dan is granite.\n(∀x (Bored(x) ∨ Immediate(x))) → (¬Granite(x)) ::: If someone is bored or immediate, then he is not granite.\n((¬Bored(whitney) ∨ ¬Expensive(dan))) → (Granite(sigmund)) ::: If Whitney is not bored or Dan is not expensive, then Sigmund is granite.\n(Granite(x) ∧ Former(x)) ↔ (Immediate(x)) ::: If someone is granite and former, then he is immediate, and vice versa.\n(∃x (¬Expensive(x))) → (Granite(benedict) ∧ ¬Immediate(sigmund)) ::: If there is someone who is not expensive, then Benedict is granite and Sigmund is not immediate.\n(Granite(dan)) ↔ ((¬Expensive(dan) ∧ Immediate(whitney))) ::: Dan being granite is equivalent to Dan being not expensive and Whitney being immediate.\n",
            "First-Order-Logic Question": "Immediate(gregory) ::: Gregory is immediate."
        },
        "diff": [
            {
                "raw": "((¬Expensive(dan) ∧ ¬Former(dan))) → ((Bored(ansel) ∧ Immediate(lowell)) ∨ (Immediate(lowell))) ∧ ((Bored(ansel) ∧ Immediate(lowell)) → ((¬Expensive(dan) ∧ ¬Former(dan))) ::: If Dan is not expensive and Dan is not former, then Ansel is bored and Lowell is immediate, and vice versa.",
                "gram": "¬(Blue(x)→Serious(x))→((Blue(x))) ::: If Dan is not expensive and Dan is not former, then Ansel is bored and Lowell is immediate, and vice versa."
            }
        ],
        "answer": "C",
        "grammar_answer": "A",
        "manual_prog": {
            "First-Order-Logic Rules": "Former(lowell) ::: Lowell is former.\nBored(lowell) ::: Lowell is bored.\n¬Immediate(lowell) ::: Lowell is not immediate.\n¬Bored(whitney) ::: Whitney is not bored.\n¬Expensive(ansel) ::: Ansel is not expensive.\nExpensive(dan) ::: Dan is expensive.\nFormer(whitney) ::: Whitney is former.\n¬Bored(benedict) ::: Benedict is not bored.\n¬Expensive(whitney) ::: Whitney is not expensive.\nBored(sigmund) ::: Sigmund is bored.\nExpensive(benedict) ::: Benedict is expensive.\n¬Granite(sigmund) ::: Sigmund is not granite.\n(∀x (Expensive(x))) → (¬Former(x)) ::: All expensive people are not former.\n(¬Bored(x)) ↔ (Former(x)) ::: Someone being bored is equivalent to being former.\n(¬Bored(lowell) ∧ ¬Putrid(benedict)) → (Granite(lowell)) ::: If Lowell is not bored and Benedict is not putrid, then Lowell is granite.\n(¬Former(whitney)) → (Granite(dan)) ::: If Whitney is not former, then Dan is granite.\n((¬Expensive(dan) ∧ ¬Former(dan))) → ((Bored(ansel) ∧ Immediate(lowell)) ∨ (Immediate(lowell))) ∧ ((Bored(ansel) ∧ Immediate(lowell)) → ((¬Expensive(dan) ∧ ¬Former(dan)))) ::: If Dan is not expensive and Dan is not former, then Ansel is bored and Lowell is immediate, and vice versa.\n(∀x (Immediate(x))) → ((¬Expensive(benedict) ∧ Granite(dan))) ::: If all people are immediate, then Benedict is not expensive and Dan is granite.\n(∀x (Bored(x) ∨ Immediate(x))) → (¬Granite(x)) ::: If someone is bored or immediate, then he is not granite.\n((¬Bored(whitney) ∨ ¬Expensive(dan))) → (Granite(sigmund)) ::: If Whitney is not bored or Dan is not expensive, then Sigmund is granite.\n(Granite(x) ∧ Former(x)) ↔ (Immediate(x)) ::: If someone is granite and former, then he is immediate, and vice versa.\n(∃x (¬Expensive(x))) → (Granite(benedict) ∧ ¬Immediate(sigmund)) ::: If there is someone who is not expensive, then Benedict is granite and Sigmund is not immediate.\n(Granite(dan)) ↔ ((¬Expensive(dan) ∧ Immediate(whitney))) ::: Dan being granite is equivalent to Dan being not expensive and Whitney being immediate.\n",
            "First-Order-Logic Question": "Immediate(gregory) ::: Gregory is immediate."
        },
        "fixed": true
    },
    {
        "id": 1487,
        "raw_prog": {
            "First-Order-Logic Rules": "¬Combative(barrett) ::: Barrett is not combative.\n¬Recent(abel) ::: Abel is not recent.\n¬Combative(montague) ::: Montague is not combative.\nOld(montague) ::: Montague is old.\nDifferent(barrett) ::: Barrett is different.\nDifferent(montague) ::: Montague is different.\nBored(dan) ::: Dan is bored.\nRecent(ansel) ::: Ansel is recent.\n¬Bewildered(barrett) ::: Barrett is not bewildered.\n¬Bored(godfrey) ::: Godfrey is not bored.\n¬Bored(abel) ::: Abel is not bored.\nCombative(abel) ::: Abel is combative.\n(∀x (Bored(x) ∧ ¬Old(x))) ↔ (Bewildered(x)) ::: Someone is bored and not old if and only if he is bewildered.\n(∀x (Combative(x))) → (∀x (¬Bewildered(x))) ::: If someone is combative, then he is not bewildered.\n((Recent(dan)) → ((Old(abel) ∧ Combative(bret))) ↔ ((Old(abel) ∧ Combative(bret))) ::: If Dan is recent, then Abel is old and Bret is combative, and vice versa.\n((¬Combative(x) ∧ Old(x))) → (¬Different(x)) ::: If someone who is not combative is also old, then he is not different.\n(∃x (Bored(x))) → ((Old(ansel) ∧ ¬Combative(barrett))) ::: If there is someone who is bored, then Ansel is old and Barrett is not combative.\n((¬Bored(dan) ∧ Old(godfrey))) → (Different(barrett)) ::: If Dan is not bored and Godfrey is old, then Barrett is different.\n(∃x (Recent(x) ∨ ¬Bored(x))) → (Combative(montague) ∧ Different(dan)) ::: If there is at least one people who is either recent or not bored, then Montague is combative and Dan is different.\n(∃x (¬Combative(x) ∧ ¬Recent(x))) → (¬Bored(ansel)) ::: If there is at least one people who is neither combative nor recent, then Ansel is not bored.\n(∃x (¬Recent(x))) → (Old(godfrey)) ::: If there is someone who is not recent, then Godfrey is old.\n(∃x (Bored(x) ∨ ¬Recent(x))) → (¬Old(godfrey)) ::: If there is at least one people who is bored or not recent, then Godfrey is not old.\n((Old(abel) ∨ ¬Recent(dan))) → (Different(barrett)) ::: Abel being old or Dan being not recent implies that Barrett is different.\n",
            "First-Order-Logic Question": "Old(bret) ::: Bret is old."
        },
        "gram_prog": {
            "First-Order-Logic Rules": "¬Combative(barrett) ::: Barrett is not combative.\n¬Recent(abel) ::: Abel is not recent.\n¬Combative(montague) ::: Montague is not combative.\nOld(montague) ::: Montague is old.\nDifferent(barrett) ::: Barrett is different.\nDifferent(montague) ::: Montague is different.\nBored(dan) ::: Dan is bored.\nRecent(ansel) ::: Ansel is recent.\n¬Bewildered(barrett) ::: Barrett is not bewildered.\n¬Bored(godfrey) ::: Godfrey is not bored.\n¬Bored(abel) ::: Abel is not bored.\nCombative(abel) ::: Abel is combative.\n(∀x (Bored(x) ∧ ¬Old(x))) ↔ (Bewildered(x)) ::: Someone is bored and not old if and only if he is bewildered.\n(∀x (Combative(x))) → (∀x (¬Bewildered(x))) ::: If someone is combative, then he is not bewildered.\n(((Serious(x)))) ::: If Dan is recent, then Abel is old and Bret is combative, and vice versa.\n((¬Combative(x) ∧ Old(x))) → (¬Different(x)) ::: If someone who is not combative is also old, then he is not different.\n(∃x (Bored(x))) → ((Old(ansel) ∧ ¬Combative(barrett))) ::: If there is someone who is bored, then Ansel is old and Barrett is not combative.\n((¬Bored(dan) ∧ Old(godfrey))) → (Different(barrett)) ::: If Dan is not bored and Godfrey is old, then Barrett is different.\n(∃x (Recent(x) ∨ ¬Bored(x))) → (Combative(montague) ∧ Different(dan)) ::: If there is at least one people who is either recent or not bored, then Montague is combative and Dan is different.\n(∃x (¬Combative(x) ∧ ¬Recent(x))) → (¬Bored(ansel)) ::: If there is at least one people who is neither combative nor recent, then Ansel is not bored.\n(∃x (¬Recent(x))) → (Old(godfrey)) ::: If there is someone who is not recent, then Godfrey is old.\n(∃x (Bored(x) ∨ ¬Recent(x))) → (¬Old(godfrey)) ::: If there is at least one people who is bored or not recent, then Godfrey is not old.\n((Old(abel) ∨ ¬Recent(dan))) → (Different(barrett)) ::: Abel being old or Dan being not recent implies that Barrett is different.\n",
            "First-Order-Logic Question": "Old(bret) ::: Bret is old."
        },
        "diff": [
            {
                "raw": "((Recent(dan)) → ((Old(abel) ∧ Combative(bret))) ↔ ((Old(abel) ∧ Combative(bret))) ::: If Dan is recent, then Abel is old and Bret is combative, and vice versa.",
                "gram": "(((Serious(x)))) ::: If Dan is recent, then Abel is old and Bret is combative, and vice versa."
            }
        ],
        "answer": "C",
        "grammar_answer": "A",
        "manual_prog": {
            "First-Order-Logic Rules": "¬Combative(barrett) ::: Barrett is not combative.\n¬Recent(abel) ::: Abel is not recent.\n¬Combative(montague) ::: Montague is not combative.\nOld(montague) ::: Montague is old.\nDifferent(barrett) ::: Barrett is different.\nDifferent(montague) ::: Montague is different.\nBored(dan) ::: Dan is bored.\nRecent(ansel) ::: Ansel is recent.\n¬Bewildered(barrett) ::: Barrett is not bewildered.\n¬Bored(godfrey) ::: Godfrey is not bored.\n¬Bored(abel) ::: Abel is not bored.\nCombative(abel) ::: Abel is combative.\n(∀x (Bored(x) ∧ ¬Old(x))) ↔ (Bewildered(x)) ::: Someone is bored and not old if and only if he is bewildered.\n(∀x (Combative(x))) → (∀x (¬Bewildered(x))) ::: If someone is combative, then he is not bewildered.\n((Recent(dan)) → ((Old(abel) ∧ Combative(bret))) ↔ ((Old(abel) ∧ Combative(bret)))) ::: If Dan is recent, then Abel is old and Bret is combative, and vice versa.\n((¬Combative(x) ∧ Old(x))) → (¬Different(x)) ::: If someone who is not combative is also old, then he is not different.\n(∃x (Bored(x))) → ((Old(ansel) ∧ ¬Combative(barrett))) ::: If there is someone who is bored, then Ansel is old and Barrett is not combative.\n((¬Bored(dan) ∧ Old(godfrey))) → (Different(barrett)) ::: If Dan is not bored and Godfrey is old, then Barrett is different.\n(∃x (Recent(x) ∨ ¬Bored(x))) → (Combative(montague) ∧ Different(dan)) ::: If there is at least one people who is either recent or not bored, then Montague is combative and Dan is different.\n(∃x (¬Combative(x) ∧ ¬Recent(x))) → (¬Bored(ansel)) ::: If there is at least one people who is neither combative nor recent, then Ansel is not bored.\n(∃x (¬Recent(x))) → (Old(godfrey)) ::: If there is someone who is not recent, then Godfrey is old.\n(∃x (Bored(x) ∨ ¬Recent(x))) → (¬Old(godfrey)) ::: If there is at least one people who is bored or not recent, then Godfrey is not old.\n((Old(abel) ∨ ¬Recent(dan))) → (Different(barrett)) ::: Abel being old or Dan being not recent implies that Barrett is different.\n",
            "First-Order-Logic Question": "Old(bret) ::: Bret is old."
        },
        "fixed": true
    }
]