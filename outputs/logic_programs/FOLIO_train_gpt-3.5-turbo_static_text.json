[
  {
    "id": 1131,
    "context": [
      "All people who regularly drink coffee are dependent on caffeine.",
      "People either regularly drink coffee or joke about being addicted to caffeine.",
      "No one who jokes about being addicted to caffeine is unaware that caffeine is a drug.",
      "Rina is either a student and unaware that caffeine is a drug, or neither a student nor unaware that caffeine is a drug.",
      "If Rina is not a person dependent on caffeine and a student, then Rina is either a person dependent on caffeine and a student, or neither a person dependent on caffeine nor a student. "
    ],
    "question": "Rina is a person who jokes about being addicted to caffeine or unaware that caffeine is a drug.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nDependent(x) ::: x is a person dependent on caffeine.\nDrinks(x) ::: x regularly drinks coffee.\nJokes(x) ::: x jokes about being addicted to caffeine.\nUnaware(x) ::: x is unaware that caffeine is a drug.\nStudent(x) ::: x is a student.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Drinks(x) → Dependent(x)) ::: All people who regularly drink coffee are dependent on caffeine.\n∀x (Drinks(x) ⊕ Jokes(x)) ::: People either regularly drink coffee or joke about being addicted to caffeine.\n∀x (Jokes(x) → ¬Unaware(x)) ::: No one who jokes about being addicted to caffeine is unaware that caffeine is a drug. \n(Student(rina) ∧ Unaware(rina)) ⊕ ¬(Student(rina) ∨ Unaware(rina)) ::: Rina is either a student and unaware that caffeine is a drug, or neither a student nor unaware that caffeine is a drug. \n¬(Dependent(rina) ∧ Student(rina)) → (Dependent(rina) ∧ Student(rina)) ⊕ ¬(Dependent(rina) ∨ Student(rina)) ::: If Rina is not a person dependent on caffeine and a student, then Rina is either a person dependent on caffeine and a student, or neither a person dependent on caffeine nor a student.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nJokes(rina) ∨ Unaware(rina) ::: Rina is a person who jokes about being addicted to caffeine or unaware that caffeine is a drug.\n\"\"\""
    ]
  },
  {
    "id": 1132,
    "context": [
      "All people who regularly drink coffee are dependent on caffeine.",
      "People either regularly drink coffee or joke about being addicted to caffeine.",
      "No one who jokes about being addicted to caffeine is unaware that caffeine is a drug.",
      "Rina is either a student and unaware that caffeine is a drug, or neither a student nor unaware that caffeine is a drug.",
      "If Rina is not a person dependent on caffeine and a student, then Rina is either a person dependent on caffeine and a student, or neither a person dependent on caffeine nor a student. "
    ],
    "question": "Rina is either a person who jokes about being addicted to caffeine or is unaware that caffeine is a drug.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n```\nDependent(x) ::: x is a person dependent on caffeine.\nDrinks(x) ::: x regularly drinks coffee.\nJokes(x) ::: x jokes about being addicted to caffeine.\nUnaware(x) ::: x is unaware that caffeine is a drug.\nStudent(x) ::: x is a student.\n```\nFirst-Order-Logic Premises:\n```\n∀x (Drinks(x) → Dependent(x)) ::: All people who regularly drink coffee are dependent on caffeine.\n∀x (Drinks(x) ⊕ Jokes(x)) ::: People either regularly drink coffee or joke about being addicted to caffeine.\n∀x (Jokes(x) → ¬Unaware(x)) ::: No one who jokes about being addicted to caffeine is unaware that caffeine is a drug. \n(Student(rina) ∧ Unaware(rina)) ⊕ ¬(Student(rina) ∨ Unaware(rina)) ::: Rina is either a student and unaware that caffeine is a drug, or neither a student nor unaware that caffeine is a drug. \n¬(Dependent(rina) ∧ Student(rina)) → (Dependent(rina) ∧ Student(rina)) ⊕ ¬(Dependent(rina) ∨ Student(rina)) ::: If Rina is not a person dependent on caffeine and a student, then Rina is either a person dependent on caffeine and a student, or neither a person dependent on caffeine nor a student.\n```\nFirst-Order-Logic Question:\n```\nJokes(rina) ⊕ Unaware(rina) ::: Rina is either a person who jokes about being addicted to caffeine or is unaware that caffeine is a drug.\n```"
    ]
  },
  {
    "id": 1133,
    "context": [
      "All people who regularly drink coffee are dependent on caffeine.",
      "People either regularly drink coffee or joke about being addicted to caffeine.",
      "No one who jokes about being addicted to caffeine is unaware that caffeine is a drug.",
      "Rina is either a student and unaware that caffeine is a drug, or neither a student nor unaware that caffeine is a drug.",
      "If Rina is not a person dependent on caffeine and a student, then Rina is either a person dependent on caffeine and a student, or neither a person dependent on caffeine nor a student. "
    ],
    "question": "Rina is either a person who regularly drinks coffee or a person who is unaware that caffeine is a drug.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nDependent(x) ::: x is a person dependent on caffeine.\nDrinks(x) ::: x regularly drinks coffee.\nJokes(x) ::: x jokes about being addicted to caffeine.\nUnaware(x) ::: x is unaware that caffeine is a drug.\nStudent(x) ::: x is a student.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Drinks(x) → Dependent(x)) ::: All people who regularly drink coffee are dependent on caffeine.\n∀x (Drinks(x) ⊕ Jokes(x)) ::: People either regularly drink coffee or joke about being addicted to caffeine.\n∀x (Jokes(x) → ¬Unaware(x)) ::: No one who jokes about being addicted to caffeine is unaware that caffeine is a drug. \n(Student(rina) ∧ Unaware(rina)) ⊕ ¬(Student(rina) ∨ Unaware(rina)) ::: Rina is either a student and unaware that caffeine is a drug, or neither a student nor unaware that caffeine is a drug. \n¬(Dependent(rina) ∧ Student(rina)) → (Dependent(rina) ∧ Student(rina)) ⊕ ¬(Dependent(rina) ∨ Student(rina)) ::: If Rina is not a person dependent on caffeine and a student, then Rina is either a person dependent on caffeine and a student, or neither a person dependent on caffeine nor a student.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nDrinks(rina) ⊕ Unaware(rina) ::: Rina is either a person who regularly drinks coffee or a person who is unaware that caffeine is a drug.\n\"\"\""
    ]
  },
  {
    "id": 1134,
    "context": [
      "All people who regularly drink coffee are dependent on caffeine.",
      "People either regularly drink coffee or joke about being addicted to caffeine.",
      "No one who jokes about being addicted to caffeine is unaware that caffeine is a drug.",
      "Rina is either a student and unaware that caffeine is a drug, or neither a student nor unaware that caffeine is a drug.",
      "If Rina is not a person dependent on caffeine and a student, then Rina is either a person dependent on caffeine and a student, or neither a person dependent on caffeine nor a student. "
    ],
    "question": "If Rina is either a person who jokes about being addicted to caffeine and a person who is unaware that caffeine is a drug, or neither a person who jokes about being addicted to caffeine nor a person who is unaware that caffeine is a drug, then Rina jokes about being addicted to caffeine and regularly drinks coffee.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nDependent(x) ::: x is a person dependent on caffeine.\nDrinks(x) ::: x regularly drinks coffee.\nJokes(x) ::: x jokes about being addicted to caffeine.\nUnaware(x) ::: x is unaware that caffeine is a drug.\nStudent(x) ::: x is a student.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Drinks(x) → Dependent(x)) ::: All people who regularly drink coffee are dependent on caffeine.\n∀x (Drinks(x) ⊕ Jokes(x)) ::: People either regularly drink coffee or joke about being addicted to caffeine.\n∀x (Jokes(x) → ¬Unaware(x)) ::: No one who jokes about being addicted to caffeine is unaware that caffeine is a drug. \n(Student(rina) ∧ Unaware(rina)) ⊕ ¬(Student(rina) ∨ Unaware(rina)) ::: Rina is either a student and unaware that caffeine is a drug, or neither a student nor unaware that caffeine is a drug. \n¬(Dependent(rina) ∧ Student(rina)) → (Dependent(rina) ∧ Student(rina)) ⊕ ¬(Dependent(rina) ∨ Student(rina)) ::: If Rina is not a person dependent on caffeine and a student, then Rina is either a person dependent on caffeine and a student, or neither a person dependent on caffeine nor a student.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n((Jokes(rina) ∧ Unaware(rina)) ∨ ¬(Jokes(rina) ∨ Unaware(rina))) → (Jokes(rina) ∧ Drinks(rina)) ::: If Rina is either a person who jokes about being addicted to caffeine and a person who is unaware that caffeine is a drug, or neither a person who jokes about being addicted to caffeine nor a person who is unaware that caffeine is a drug, then Rina jokes about being addicted to caffeine and regularly drinks coffee.\n\"\"\""
    ]
  },
  {
    "id": 20,
    "context": [
      "Miroslav Venhoda was a Czech choral conductor who specialized in the performance of Renaissance and Baroque music.",
      "Any choral conductor is a musician.",
      "Some musicians love music.",
      "Miroslav Venhoda published a book in 1946 called Method of Studying Gregorian Chant."
    ],
    "question": "Miroslav Venhoda loved music.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n```\nCzech(x) ::: x is a Czech person.\nChoralConductor(x) ::: x is a choral conductor.\nMusician(x) ::: x is a musician.\nLove(x, y) ::: x loves y.\nAuthor(x, y) ::: x is the author of y.\nBook(x) ::: x is a book.\nPublish(x, y) ::: x is published in year y.\nSpecialize(x, y) ::: x specializes in y.\n```\nFirst-Order-Logic Premises:\n```\nCzech(miroslav) ∧ ChoralConductor(miroslav) ∧ Specialize(miroslav, renaissance) ∧ Specialize(miroslav, baroque) ::: Miroslav Venhoda was a Czech choral conductor who specialized in the performance of Renaissance and Baroque music.\n∀x (ChoralConductor(x) → Musician(x)) ::: Any choral conductor is a musician.\n∃x (Musician(x) ∧ Love(x, music)) ::: Some musicians love music.\nBook(methodOfStudyingGregorianChant) ∧ Author(miroslav, methodOfStudyingGregorianChant) ∧ Publish(methodOfStudyingGregorianChant, year1946) ::: Miroslav Venhoda published a book in 1946 called Method of Studying Gregorian Chant.\n```\nFirst-Order-Logic Question:\n```\nLove(miroslav, music) ::: Miroslav Venhoda loved music.\n```"
    ]
  },
  {
    "id": 21,
    "context": [
      "Miroslav Venhoda was a Czech choral conductor who specialized in the performance of Renaissance and Baroque music.",
      "Any choral conductor is a musician.",
      "Some musicians love music.",
      "Miroslav Venhoda published a book in 1946 called Method of Studying Gregorian Chant."
    ],
    "question": "A Czech person wrote a book in 1946.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nCzech(x) ::: x is a Czech person.\nChoralConductor(x) ::: x is a choral conductor.\nMusician(x) ::: x is a musician.\nLove(x, y) ::: x loves y.\nAuthor(x, y) ::: x is the author of y.\nBook(x) ::: x is a book.\nPublish(x, y) ::: x is published in year y.\nSpecialize(x, y) ::: x specializes in y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nCzech(miroslav) ∧ ChoralConductor(miroslav) ∧ Specialize(miroslav, renaissance) ∧ Specialize(miroslav, baroque) ::: Miroslav Venhoda was a Czech choral conductor who specialized in the performance of Renaissance and Baroque music.\n∀x (ChoralConductor(x) → Musician(x)) ::: Any choral conductor is a musician.\n∃x (Musician(x) ∧ Love(x, music)) ::: Some musicians love music.\nBook(methodOfStudyingGregorianChant) ∧ Author(miroslav, methodOfStudyingGregorianChant) ∧ Publish(methodOfStudyingGregorianChant, year1946) ::: Miroslav Venhoda published a book in 1946 called Method of Studying Gregorian Chant.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n∃x (Czech(x) ∧ Author(x, book) ∧ Publish(book, year1946)) ::: A Czech person wrote a book in 1946.\n\"\"\""
    ]
  },
  {
    "id": 22,
    "context": [
      "Miroslav Venhoda was a Czech choral conductor who specialized in the performance of Renaissance and Baroque music.",
      "Any choral conductor is a musician.",
      "Some musicians love music.",
      "Miroslav Venhoda published a book in 1946 called Method of Studying Gregorian Chant."
    ],
    "question": "No choral conductor specialized in the performance of Renaissance.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nCzech(x) ::: x is a Czech person.\nChoralConductor(x) ::: x is a choral conductor.\nMusician(x) ::: x is a musician.\nLove(x, y) ::: x loves y.\nAuthor(x, y) ::: x is the author of y.\nBook(x) ::: x is a book.\nPublish(x, y) ::: x is published in year y.\nSpecialize(x, y) ::: x specializes in y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nCzech(miroslav) ∧ ChoralConductor(miroslav) ∧ Specialize(miroslav, renaissance) ∧ Specialize(miroslav, baroque) ::: Miroslav Venhoda was a Czech choral conductor who specialized in the performance of Renaissance and Baroque music.\n∀x (ChoralConductor(x) → Musician(x)) ::: Any choral conductor is a musician.\n∃x (Musician(x) ∧ Love(x, music)) ::: Some musicians love music.\nBook(methodOfStudyingGregorianChant) ∧ Author(miroslav, methodOfStudyingGregorianChant) ∧ Publish(methodOfStudyingGregorianChant, year1946) ::: Miroslav Venhoda published a book in 1946 called Method of Studying Gregorian Chant.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬∃x (ChoralConductor(x) ∧ Specialize(x, renaissance)) ::: No choral conductor specialized in the performance of Renaissance.\n\"\"\""
    ]
  },
  {
    "id": 1341,
    "context": [
      "All eels are fish. ",
      "No fish are plants. ",
      "A thing is either a plant or animal.",
      "Nothing that breathes is paper. ",
      "All animals breathe.",
      "If a sea eel is either an eel or a plant, then a sea eel is an eel or an animal."
    ],
    "question": "Sea eel is an eel.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nEel(x) ::: x is an eel.\nFish(x) ::: x is a fish.\nPlant(x) ::: x is a plant.\nAnimal(x) ::: x is an animal.\nBreathes(x) ::: x breathes.\nPaper(x) ::: x is paper.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Eel(x) → Fish(x)) ::: All eels are fish.\n∀x (Fish(x) → ¬Plant(x)) ::: No fish are plants.\n∀x ((Plant(x) ∨ Animal(x))) ::: A thing is either a plant or animal.\n∀x (Breathes(x) → ¬Paper(x)) ::: Nothing that breathes is paper.\n∀x (Animal(x) → Breathes(x)) ::: All animals breathe.\n(Eel(seaEel) ∨ Plant(seaEel)) → (Eel(seaEel) ∨ Animal(seaEel)) ::: If a sea eel is either an eel or a plant, then a sea eel is an eel or an animal.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nEel(seaEel) ::: Sea eel is an eel.\n\"\"\""
    ]
  },
  {
    "id": 1342,
    "context": [
      "All eels are fish. ",
      "No fish are plants. ",
      "A thing is either a plant or animal.",
      "Nothing that breathes is paper. ",
      "All animals breathe.",
      "If a sea eel is either an eel or a plant, then a sea eel is an eel or an animal."
    ],
    "question": "Sea eel is a paper.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nEel(x) ::: x is an eel.\nFish(x) ::: x is a fish.\nPlant(x) ::: x is a plant.\nAnimal(x) ::: x is an animal.\nBreathes(x) ::: x breathes.\nPaper(x) ::: x is paper.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Eel(x) → Fish(x)) ::: All eels are fish.\n∀x (Fish(x) → ¬Plant(x)) ::: No fish are plants.\n∀x ((Plant(x) ∨ Animal(x))) ::: A thing is either a plant or animal.\n∀x (Breathes(x) → ¬Paper(x)) ::: Nothing that breathes is paper.\n∀x (Animal(x) → Breathes(x)) ::: All animals breathe.\n(Eel(seaEel) ∨ Plant(seaEel)) → (Eel(seaEel) ∨ Animal(seaEel)) ::: If a sea eel is either an eel or a plant, then a sea eel is an eel or an animal.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬Paper(seaEel) ::: Sea eel is a paper.\n\"\"\""
    ]
  },
  {
    "id": 1343,
    "context": [
      "All eels are fish. ",
      "No fish are plants. ",
      "A thing is either a plant or animal.",
      "Nothing that breathes is paper. ",
      "All animals breathe.",
      "If a sea eel is either an eel or a plant, then a sea eel is an eel or an animal."
    ],
    "question": "Sea eel breathes or is a paper.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nEel(x) ::: x is an eel.\nFish(x) ::: x is a fish.\nPlant(x) ::: x is a plant.\nAnimal(x) ::: x is an animal.\nBreathes(x) ::: x breathes.\nPaper(x) ::: x is paper.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Eel(x) → Fish(x)) ::: All eels are fish.\n∀x (Fish(x) → ¬Plant(x)) ::: No fish are plants.\n∀x ((Plant(x) ∨ Animal(x))) ::: A thing is either a plant or animal.\n∀x (Breathes(x) → ¬Paper(x)) ::: Nothing that breathes is paper.\n∀x (Animal(x) → Breathes(x)) ::: All animals breathe.\n(Eel(seaEel) ∨ Plant(seaEel)) → (Eel(seaEel) ∨ Animal(seaEel)) ::: If a sea eel is either an eel or a plant, then a sea eel is an eel or an animal.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nBreathes(seaEel) ∨ Paper(seaEel) ::: Sea eel breathes or is a paper.\n\"\"\""
    ]
  },
  {
    "id": 393,
    "context": [
      "The Blake McFall Company Building is a commercial warehouse listed on the National Register of Historic Places.",
      "The Blake McFall Company Building was added to the National Register of Historic Places in 1990.",
      "The Emmet Building is a five-story building in Portland, Oregon.",
      "The Emmet Building was built in 1915.",
      "The Emmet Building is another name for the Blake McFall Company Building.",
      "John works at the Emmet Building."
    ],
    "question": "A five-story building is built in 1915.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nCommercialWarehouse(x) ::: x is a commercial warehouse.\nHistoricPlace(x) ::: x is listed on the National Register of Historic Places.\nAddedToRegister(x, y) ::: x was added to the National Register of Historic Places in year y.\nBuilding(x) ::: x is a building.\nFiveStoryBuilding(x) ::: x is a five-story building.\nLocation(x, y) ::: x is located in y.\nBuiltIn(x, y) ::: x was built in year y.\nWorksAt(x, y) ::: x works at building y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nCommercialWarehouse(blakeMcFall) ∧ HistoricPlace(blakeMcFall) ∧ AddedToRegister(blakeMcFall, year1990) ::: The Blake McFall Company Building is a commercial warehouse listed on the National Register of Historic Places and was added to the National Register of Historic Places in 1990.\nBuilding(emmet) ∧ FiveStoryBuilding(emmet) ∧ Location(emmet, portland) ∧ BuiltIn(emmet, year1915) ::: The Emmet Building is a five-story building in Portland, Oregon and was built in 1915.\nEmmet(blakeMcFall) ::: The Emmet Building is another name for the Blake McFall Company Building.\nWorksAt(john, emmet) ::: John works at the Emmet Building.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nFiveStoryBuilding(x) ∧ BuiltIn(x, year1915) ::: A five-story building is built in 1915.\n\"\"\""
    ]
  },
  {
    "id": 394,
    "context": [
      "The Blake McFall Company Building is a commercial warehouse listed on the National Register of Historic Places.",
      "The Blake McFall Company Building was added to the National Register of Historic Places in 1990.",
      "The Emmet Building is a five-story building in Portland, Oregon.",
      "The Emmet Building was built in 1915.",
      "The Emmet Building is another name for the Blake McFall Company Building.",
      "John works at the Emmet Building."
    ],
    "question": "The Blake McFall Company Building is located in Portland, Oregon.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nCommercialWarehouse(x) ::: x is a commercial warehouse.\nHistoricPlace(x) ::: x is listed on the National Register of Historic Places.\nAddedToRegister(x, y) ::: x was added to the National Register of Historic Places in year y.\nBuilding(x) ::: x is a building.\nFiveStoryBuilding(x) ::: x is a five-story building.\nLocation(x, y) ::: x is located in y.\nName(x, y) ::: x is another name for y.\nWorksAt(x, y) ::: x works at y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nCommercialWarehouse(blakeMcFall) ∧ HistoricPlace(blakeMcFall) ∧ AddedToRegister(blakeMcFall, year1990) ::: The Blake McFall Company Building is a commercial warehouse listed on the National Register of Historic Places and was added in 1990.\nBuilding(emmet) ∧ FiveStoryBuilding(emmet) ∧ Location(emmet, portland) ∧ Built(emmet, year1915) ::: The Emmet Building is a five-story building in Portland, Oregon and was built in 1915.\nName(emmet, blakeMcFall) ::: The Emmet Building is another name for the Blake McFall Company Building.\nWorksAt(john, emmet) ::: John works at the Emmet Building.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nLocation(blakeMcFall, portland) ::: The Blake McFall Company Building is located in Portland, Oregon.\n\"\"\""
    ]
  },
  {
    "id": 395,
    "context": [
      "The Blake McFall Company Building is a commercial warehouse listed on the National Register of Historic Places.",
      "The Blake McFall Company Building was added to the National Register of Historic Places in 1990.",
      "The Emmet Building is a five-story building in Portland, Oregon.",
      "The Emmet Building was built in 1915.",
      "The Emmet Building is another name for the Blake McFall Company Building.",
      "John works at the Emmet Building."
    ],
    "question": "John started his current job in 1990.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nCommercialWarehouse(x) ::: x is a commercial warehouse.\nHistoricPlace(x) ::: x is listed on the National Register of Historic Places.\nAddedToRegister(x, y) ::: x was added to the National Register of Historic Places in year y.\nBuilding(x) ::: x is a building.\nStory(x, y) ::: x has y stories.\nLocatedIn(x, y) ::: x is located in y.\nName(x, y) ::: x is another name for y.\nWorksAt(x, y) ::: x works at y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nCommercialWarehouse(blakeMcFall) ∧ HistoricPlace(blakeMcFall) ∧ AddedToRegister(blakeMcFall, year1990) ::: The Blake McFall Company Building is a commercial warehouse listed on the National Register of Historic Places and was added to the National Register of Historic Places in 1990.\nBuilding(emmet) ∧ Story(emmet, 5) ∧ LocatedIn(emmet, portland) ∧ AddedToRegister(emmet, year1915) ∧ Name(emmet, blakeMcFall) ::: The Emmet Building is a five-story building in Portland, Oregon, built in 1915, and another name for the Blake McFall Company Building.\nWorksAt(john, emmet) ::: John works at the Emmet Building.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nStartedJob(john, year1990) ::: John started his current job in 1990.\n\"\"\""
    ]
  },
  {
    "id": 640,
    "context": [
      "William Dickinson was a British politician who sat in the House of Commons",
      "William Dickinson attended Westminster school for high school and then the University of Edinburgh.",
      "The University of Edinburgh is a university located in the United Kingdom.",
      "William Dickinson supported the Portland Whigs.",
      "People who supported the Portland Whigs did not get a seat in the Parliament."
    ],
    "question": "William Dickinson did not get a seat in the Parliament.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nBritish(x) ::: x is a British person.\nPolitician(x) ::: x is a politician.\nSitInHouseOfCommons(x) ::: x sat in the House of Commons.\nAttendSchool(x, y) ::: x attended school y.\nUniversity(x) ::: x is a university.\nLocatedIn(x, y) ::: x is located in y.\nSupport(x, y) ::: x supported y.\nPortlandWhigs(x) ::: x supported the Portland Whigs.\nGetSeatInParliament(x) ::: x got a seat in the Parliament.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nBritish(william) ∧ Politician(william) ∧ SitInHouseOfCommons(william) ::: William Dickinson was a British politician who sat in the House of Commons.\nAttendSchool(william, westminsterSchool) ∧ AttendSchool(william, universityOfEdinburgh) ::: William Dickinson attended Westminster school for high school and then the University of Edinburgh.\nUniversity(universityOfEdinburgh) ∧ LocatedIn(universityOfEdinburgh, unitedKingdom) ::: The University of Edinburgh is a university located in the United Kingdom.\nSupport(william, portlandWhigs) ::: William Dickinson supported the Portland Whigs.\n∀x (Support(x, portlandWhigs) → ¬GetSeatInParliament(x)) ::: People who supported the Portland Whigs did not get a seat in the Parliament.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬GetSeatInParliament(william) ::: William Dickinson did not get a seat in the Parliament.\n\"\"\""
    ]
  },
  {
    "id": 641,
    "context": [
      "William Dickinson was a British politician who sat in the House of Commons",
      "William Dickinson attended Westminster school for high school and then the University of Edinburgh.",
      "The University of Edinburgh is a university located in the United Kingdom.",
      "William Dickinson supported the Portland Whigs.",
      "People who supported the Portland Whigs did not get a seat in the Parliament."
    ],
    "question": "William Dickinson went to schools located in the United Kingdom for both high school and university.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nBritish(x) ::: x is British.\nPolitician(x) ::: x is a politician.\nHouseOfCommons(x) ::: x sat in the House of Commons.\nAttendSchool(x, y) ::: x attended school y.\nHighSchool(x) ::: x attended high school.\nUniversity(x) ::: x attended university.\nLocatedIn(x, y) ::: x is located in y.\nSupport(x, y) ::: x supported y.\nPortlandWhigs(x) ::: x supported the Portland Whigs.\nGetSeat(x, y) ::: x got a seat in y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nBritish(william) ∧ Politician(william) ∧ HouseOfCommons(william) ::: William Dickinson was a British politician who sat in the House of Commons.\nAttendSchool(william, westminsterSchool) ∧ AttendSchool(william, universityOfEdinburgh) ∧ LocatedIn(universityOfEdinburgh, unitedKingdom) ::: William Dickinson attended Westminster school for high school and then the University of Edinburgh. The University of Edinburgh is a university located in the United Kingdom.\n∀x (Support(x, portlandWhigs) → ¬GetSeat(x, parliament)) ::: People who supported the Portland Whigs did not get a seat in the Parliament.\nSupport(william, portlandWhigs) ::: William Dickinson supported the Portland Whigs.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nAttendSchool(william, westminsterSchool) ∧ LocatedIn(westminsterSchool, unitedKingdom) ∧ AttendSchool(william, universityOfEdinburgh) ∧ LocatedIn(universityOfEdinburgh, unitedKingdom) ::: William Dickinson went to schools located in the United Kingdom for both high school and university.\n\"\"\""
    ]
  },
  {
    "id": 642,
    "context": [
      "William Dickinson was a British politician who sat in the House of Commons",
      "William Dickinson attended Westminster school for high school and then the University of Edinburgh.",
      "The University of Edinburgh is a university located in the United Kingdom.",
      "William Dickinson supported the Portland Whigs.",
      "People who supported the Portland Whigs did not get a seat in the Parliament."
    ],
    "question": "William Dickinson attended university in the United Kingdom.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nBritish(x) ::: x is a British person.\nPolitician(x) ::: x is a politician.\nHouseOfCommons(x) ::: x sat in the House of Commons.\nAttend(x, y) ::: x attended y.\nSchool(x) ::: x is a school.\nUniversity(x) ::: x is a university.\nLocatedIn(x, y) ::: x is located in y.\nSupport(x, y) ::: x supported y.\nPortlandWhigs(x) ::: x supported the Portland Whigs.\nGetSeat(x, y) ::: x got a seat in y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nBritish(william) ∧ Politician(william) ∧ HouseOfCommons(william) ::: William Dickinson was a British politician who sat in the House of Commons.\nAttend(william, westminsterSchool) ∧ Attend(william, universityOfEdinburgh) ∧ School(westminsterSchool) ∧ University(universityOfEdinburgh) ::: William Dickinson attended Westminster school for high school and then the University of Edinburgh.\nUniversity(universityOfEdinburgh) ∧ LocatedIn(universityOfEdinburgh, unitedKingdom) ::: The University of Edinburgh is a university located in the United Kingdom.\nSupport(william, portlandWhigs) ::: William Dickinson supported the Portland Whigs.\n∀x (Support(x, portlandWhigs) → ¬GetSeat(x, parliament)) ::: People who supported the Portland Whigs did not get a seat in the Parliament.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n∃x (Attend(william, x) ∧ University(x) ∧ LocatedIn(x, unitedKingdom)) ::: William Dickinson attended university in the United Kingdom.\n\"\"\""
    ]
  },
  {
    "id": 643,
    "context": [
      "William Dickinson was a British politician who sat in the House of Commons",
      "William Dickinson attended Westminster school for high school and then the University of Edinburgh.",
      "The University of Edinburgh is a university located in the United Kingdom.",
      "William Dickinson supported the Portland Whigs.",
      "People who supported the Portland Whigs did not get a seat in the Parliament."
    ],
    "question": "William Dickinson sat in the House of Commons.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nBritish(x) ::: x is a British person.\nPolitician(x) ::: x is a politician.\nSit(x, y) ::: x sat in y.\nAttend(x, y) ::: x attended y.\nSchool(x) ::: x is a school.\nUniversity(x) ::: x is a university.\nLocatedIn(x, y) ::: x is located in y.\nSupport(x, y) ::: x supported y.\nWhigs(x) ::: x is a member of the Portland Whigs.\nGetSeat(x) ::: x got a seat in the Parliament.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nBritish(william) ∧ Politician(william) ∧ Sit(william, houseOfCommons) ::: William Dickinson was a British politician who sat in the House of Commons.\nAttend(william, westminsterSchool) ∧ Attend(william, universityOfEdinburgh) ::: William Dickinson attended Westminster school for high school and then the University of Edinburgh.\nUniversity(universityOfEdinburgh) ∧ LocatedIn(universityOfEdinburgh, unitedKingdom) ::: The University of Edinburgh is a university located in the United Kingdom.\nSupport(william, portlandWhigs) ::: William Dickinson supported the Portland Whigs.\n∀x (Support(x, portlandWhigs) → ¬GetSeat(x)) ::: People who supported the Portland Whigs did not get a seat in the Parliament.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nSit(william, houseOfCommons) ::: William Dickinson sat in the House of Commons.\n\"\"\""
    ]
  },
  {
    "id": 695,
    "context": [
      "LanguageA is a universal language",
      "If a universal language exists, then for every two people if they both know the same universal language they can communicate.",
      "Katya cannot communicate with Danil.",
      "Katya knows LanguageA. "
    ],
    "question": "Danil knows LanguageA.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nUniversal(x) ::: x is a universal language.\nKnows(x, y) ::: x knows y.\nCommunicate(x, y) ::: x can communicate with y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nUniversal(languageA) ::: LanguageA is a universal language.\n∀x ∀y ((Universal(z) → (Knows(x, z) ∧ Knows(y, z)) → Communicate(x, y))) ::: If a universal language exists, then for every two people if they both know the same universal language they can communicate.\n¬Communicate(katya, danil) ::: Katya cannot communicate with Danil.\nKnows(katya, languageA) ::: Katya knows LanguageA.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nKnows(danil, languageA) ::: Danil knows LanguageA.\n\"\"\""
    ]
  },
  {
    "id": 1197,
    "context": [
      "All customers who are subscribed to AMC List are available to watch 3 movies every week without any additional fees. ",
      "Some customers go to cinemas every week",
      "Customers either subscribe to AMC service or HBO service. ",
      "Customers who prefer TV series more and will not watch TV series in cinemas.",
      "All customers who subscribe to HBO services prefer TV series to movies. ",
      "James watches TV series in cinemas. "
    ],
    "question": "James goes to cinemas every week.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nSubscribedAMC(x) ::: x is a customer subscribed to AMC List.\nWatchMovies(x, y) ::: x is available to watch y movies every week without any additional fees.\nGoToCinemas(x) ::: x goes to cinemas every week.\nSubscribeAMC(x) ::: x subscribes to AMC service.\nSubscribeHBO(x) ::: x subscribes to HBO service.\nPreferTVSeries(x) ::: x prefers TV series to movies.\nWatchTVSeriesInCinemas(x) ::: x watches TV series in cinemas.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (SubscribedAMC(x) → WatchMovies(x, 3)) ::: All customers who are subscribed to AMC List are available to watch 3 movies every week without any additional fees.\n∃x GoToCinemas(x) ::: Some customers go to cinemas every week.\n∀x (SubscribeAMC(x) ⊕ SubscribeHBO(x)) ::: Customers either subscribe to AMC service or HBO service.\n∀x (PreferTVSeries(x) ∧ ¬WatchTVSeriesInCinemas(x)) ::: Customers who prefer TV series more and will not watch TV series in cinemas.\n∀x (SubscribeHBO(x) → PreferTVSeries(x)) ::: All customers who subscribe to HBO services prefer TV series to movies.\nWatchTVSeriesInCinemas(james) ::: James watches TV series in cinemas.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nGoToCinemas(james) ::: James goes to cinemas every week.\n\"\"\""
    ]
  },
  {
    "id": 1198,
    "context": [
      "All customers who are subscribed to AMC List are available to watch 3 movies every week without any additional fees. ",
      "Some customers go to cinemas every week",
      "Customers either subscribe to AMC service or HBO service. ",
      "Customers who prefer TV series more and will not watch TV series in cinemas.",
      "All customers who subscribe to HBO services prefer TV series to movies. ",
      "James watches TV series in cinemas. "
    ],
    "question": "James does not go to cinemas every week.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nSubscribedToAMCList(x) ::: x is a customer subscribed to AMC List.\nWatchMovies(x, y) ::: x watches y movies every week without any additional fees.\nGoToCinemas(x) ::: x goes to cinemas every week.\nSubscribeToAMC(x) ::: x subscribes to AMC service.\nSubscribeToHBO(x) ::: x subscribes to HBO service.\nPreferTVSeries(x) ::: x prefers TV series to movies.\nWatchTVSeriesInCinemas(x) ::: x watches TV series in cinemas.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (SubscribedToAMCList(x) → WatchMovies(x, 3)) ::: All customers who are subscribed to AMC List are available to watch 3 movies every week without any additional fees.\n∃x GoToCinemas(x) ::: Some customers go to cinemas every week.\n∀x (SubscribeToAMC(x) ⊕ SubscribeToHBO(x)) ::: Customers either subscribe to AMC service or HBO service.\n∀x (PreferTVSeries(x) ∧ ¬WatchTVSeriesInCinemas(x)) ::: Customers who prefer TV series more and will not watch TV series in cinemas.\n∀x (SubscribeToHBO(x) → PreferTVSeries(x)) ::: All customers who subscribe to HBO services prefer TV series to movies.\nWatchTVSeriesInCinemas(james) ::: James watches TV series in cinemas.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬GoToCinemas(james) ::: James does not go to cinemas every week.\n\"\"\""
    ]
  },
  {
    "id": 1199,
    "context": [
      "All customers who are subscribed to AMC List are available to watch 3 movies every week without any additional fees. ",
      "Some customers go to cinemas every week",
      "Customers either subscribe to AMC service or HBO service. ",
      "Customers who prefer TV series more and will not watch TV series in cinemas.",
      "All customers who subscribe to HBO services prefer TV series to movies. ",
      "James watches TV series in cinemas. "
    ],
    "question": "James goes to cinemas every week or watches 3 movies every week without any additional fees.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nSubscribedAMC(x) ::: x is a customer subscribed to AMC List.\nAvailable(x) ::: x is available to watch 3 movies every week without any additional fees.\nGoToCinema(x) ::: x goes to cinemas every week.\nSubscribeAMC(x) ::: x subscribes to AMC service.\nSubscribeHBO(x) ::: x subscribes to HBO service.\nPreferTVSeries(x) ::: x prefers TV series to movies.\nWatchTVSeries(x) ::: x watches TV series.\nWatchMovies(x) ::: x watches movies.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (SubscribedAMC(x) → Available(x)) ::: All customers who are subscribed to AMC List are available to watch 3 movies every week without any additional fees.\n∃x (GoToCinema(x)) ::: Some customers go to cinemas every week.\n∀x (SubscribeAMC(x) ⊕ SubscribeHBO(x)) ::: Customers either subscribe to AMC service or HBO service.\n∀x (PreferTVSeries(x) ∧ ¬WatchTVSeries(x)) ::: Customers who prefer TV series more and will not watch TV series in cinemas.\n∀x (SubscribeHBO(x) → PreferTVSeries(x)) ::: All customers who subscribe to HBO services prefer TV series to movies.\nWatchTVSeries(james) ::: James watches TV series in cinemas.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nGoToCinema(james) ∨ Available(james) ::: James goes to cinemas every week or watches 3 movies every week without any additional fees.\n\"\"\""
    ]
  },
  {
    "id": 1200,
    "context": [
      "All customers who are subscribed to AMC List are available to watch 3 movies every week without any additional fees. ",
      "Some customers go to cinemas every week",
      "Customers either subscribe to AMC service or HBO service. ",
      "Customers who prefer TV series more and will not watch TV series in cinemas.",
      "All customers who subscribe to HBO services prefer TV series to movies. ",
      "James watches TV series in cinemas. "
    ],
    "question": "If James does not both go to cinemas every week and subscribe to HBO service, then James is either available to watch 3 movies every week without any additional fees or he prefers TV more.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nSubscribedAMC(x) ::: x is a customer subscribed to AMC List.\nWatchMovies(x, y) ::: x is available to watch y movies every week without any additional fees.\nGoToCinemas(x) ::: x goes to cinemas every week.\nSubscribeAMC(x) ::: x subscribes to AMC service.\nSubscribeHBO(x) ::: x subscribes to HBO service.\nPreferTVSeries(x) ::: x prefers TV series to movies.\nWatchTVSeriesInCinemas(x) ::: x watches TV series in cinemas.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (SubscribedAMC(x) → WatchMovies(x, 3)) ::: All customers who are subscribed to AMC List are available to watch 3 movies every week without any additional fees.\n∃x GoToCinemas(x) ::: Some customers go to cinemas every week.\n∀x (SubscribeAMC(x) ⊕ SubscribeHBO(x)) ::: Customers either subscribe to AMC service or HBO service.\n∀x (PreferTVSeries(x) ∧ ¬WatchTVSeriesInCinemas(x)) ::: Customers who prefer TV series more and will not watch TV series in cinemas.\n∀x (SubscribeHBO(x) → PreferTVSeries(x)) ::: All customers who subscribe to HBO services prefer TV series to movies.\nWatchTVSeriesInCinemas(james) ::: James watches TV series in cinemas.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬(GoToCinemas(james) ∧ SubscribeHBO(james)) → (WatchMovies(james, 3) ∨ PreferTVSeries(james)) ::: If James does not both go to cinemas every week and subscribe to HBO service, then James is either available to watch 3 movies every week without any additional fees or he prefers TV more.\n\"\"\""
    ]
  },
  {
    "id": 1201,
    "context": [
      "All customers who are subscribed to AMC List are available to watch 3 movies every week without any additional fees. ",
      "Some customers go to cinemas every week",
      "Customers either subscribe to AMC service or HBO service. ",
      "Customers who prefer TV series more and will not watch TV series in cinemas.",
      "All customers who subscribe to HBO services prefer TV series to movies. ",
      "James watches TV series in cinemas. "
    ],
    "question": "If James is available to watch 3 movies every week without any additional fees and he watches TV series in cinemas, then he goes to cinemas every week and prefers TV series more.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nSubscribedToAMC(x) ::: x is a customer subscribed to AMC List.\nAvailableToWatch3Movies(x) ::: x is available to watch 3 movies every week without any additional fees.\nGoToCinemas(x) ::: x goes to cinemas every week.\nSubscribeToAMC(x) ::: x subscribes to AMC service.\nSubscribeToHBO(x) ::: x subscribes to HBO service.\nPreferTVSeries(x) ::: x prefers TV series to movies.\nWatchTVSeriesInCinemas(x) ::: x watches TV series in cinemas.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (SubscribedToAMC(x) → AvailableToWatch3Movies(x)) ::: All customers who are subscribed to AMC List are available to watch 3 movies every week without any additional fees.\n∃x (GoToCinemas(x)) ::: Some customers go to cinemas every week.\n∀x (SubscribeToAMC(x) ⊕ SubscribeToHBO(x)) ::: Customers either subscribe to AMC service or HBO service.\n∀x (PreferTVSeries(x) ∧ ¬WatchTVSeriesInCinemas(x)) ::: Customers who prefer TV series more and will not watch TV series in cinemas.\n∀x (SubscribeToHBO(x) → PreferTVSeries(x)) ::: All customers who subscribe to HBO services prefer TV series to movies.\nWatchTVSeriesInCinemas(james) ::: James watches TV series in cinemas.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n(AvailableToWatch3Movies(james) ∧ WatchTVSeriesInCinemas(james)) → (GoToCinemas(james) ∧ PreferTVSeries(james)) ::: If James is available to watch 3 movies every week without any additional fees and he watches TV series in cinemas, then he goes to cinemas every week and prefers TV series more.\n\"\"\""
    ]
  },
  {
    "id": 553,
    "context": [
      "A La Liga soccer team ranks higher than another if it receives more points.",
      "If two La Liga soccer teams recieve the same points, the team which recieves more points from the games between the two teams ranks higher.",
      "Real Madrid and Barcelona are both La Liga soccer teams.",
      "In La Liga 2021-2022, Real Madrid recieves 86 points and Barcelon recieves 73 points.",
      "In La Liga 2021-2022, Real Madrid and Barcelona both recieve 3 points from the games between them."
    ],
    "question": "In La Liga 2021-2022, Real Madrid ranks higher than Barcelona.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nTeam(x) ::: x is a La Liga soccer team.\nHigher(x, y) ::: x ranks higher than y.\nPoints(x, y) ::: x receives y points.\nGames(x, y, z) ::: x receives y points from games with team z.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x ∀y (Points(x, y) → Higher(x, y)) ::: A La Liga soccer team ranks higher than another if it receives more points.\n∀x ∀y ((Points(x, y) ∧ Points(y, x)) → Higher(x, y)) ::: If two La Liga soccer teams receive the same points, the team which receives more points from the games between the two teams ranks higher.\nTeam(realMadrid) ∧ Team(barcelona) ::: Real Madrid and Barcelona are both La Liga soccer teams.\nPoints(realMadrid, 86) ∧ Points(barcelona, 73) ::: In La Liga 2021-2022, Real Madrid receives 86 points and Barcelona receives 73 points.\nGames(realMadrid, 3, barcelona) ∧ Games(barcelona, 3, realMadrid) ::: In La Liga 2021-2022, Real Madrid and Barcelona both receive 3 points from the games between them.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nHigher(realMadrid, barcelona) ::: In La Liga 2021-2022, Real Madrid ranks higher than Barcelona.\n\"\"\""
    ]
  },
  {
    "id": 554,
    "context": [
      "A La Liga soccer team ranks higher than another if it receives more points.",
      "If two La Liga soccer teams recieve the same points, the team which recieves more points from the games between the two teams ranks higher.",
      "Real Madrid and Barcelona are both La Liga soccer teams.",
      "In La Liga 2021-2022, Real Madrid recieves 86 points and Barcelon recieves 73 points.",
      "In La Liga 2021-2022, Real Madrid and Barcelona both recieve 3 points from the games between them."
    ],
    "question": "In La Liga 2021-2022, Barcelona ranks higher than Real Madrid.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nTeam(x) ::: x is a La Liga soccer team.\nHigher(x, y) ::: x ranks higher than y.\nPoints(x, y) ::: x receives y points.\nGames(x, y, z) ::: x receives y points from games with team z.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x ∀y (Points(x, y) → Higher(x, y)) ::: A La Liga soccer team ranks higher than another if it receives more points.\n∀x ∀y ((Points(x, y) ∧ Points(y, x)) → Higher(x, y)) ::: If two La Liga soccer teams receive the same points, the team which receives more points from the games between the two teams ranks higher.\nTeam(realMadrid) ∧ Team(barcelona) ::: Real Madrid and Barcelona are both La Liga soccer teams.\nPoints(realMadrid, 86) ∧ Points(barcelona, 73) ::: In La Liga 2021-2022, Real Madrid receives 86 points and Barcelona receives 73 points.\nGames(realMadrid, 3, barcelona) ∧ Games(barcelona, 3, realMadrid) ::: In La Liga 2021-2022, Real Madrid and Barcelona both receive 3 points from the games between them.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nHigher(barcelona, realMadrid) ::: In La Liga 2021-2022, Barcelona ranks higher than Real Madrid.\n\"\"\""
    ]
  },
  {
    "id": 250,
    "context": [
      "Lawton Park is a neighbourhood in Seattle. ",
      "All citizens of Lawton Park use the zip code 98199. ",
      "Tom is a citizen of Lawton Park.",
      "Daniel uses the zip code 98199. "
    ],
    "question": "Tom uses the zip code 98199.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nNeighbourhood(x) ::: x is a neighbourhood.\nUseZipCode(x, y) ::: x uses the zip code y.\nCitizen(x) ::: x is a citizen.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nNeighbourhood(lawtonPark) ∧ UseZipCode(lawtonPark, 98199) ::: Lawton Park is a neighbourhood in Seattle.\n∀x (Citizen(x) → UseZipCode(x, 98199)) ::: All citizens of Lawton Park use the zip code 98199.\nCitizen(tom) ∧ Citizen(daniel) ∧ Citizen(tom) ∧ Citizen(daniel) ∧ UseZipCode(daniel, 98199) ::: Tom is a citizen of Lawton Park. Daniel uses the zip code 98199.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nUseZipCode(tom, 98199) ::: Tom uses the zip code 98199.\n\"\"\""
    ]
  },
  {
    "id": 251,
    "context": [
      "Lawton Park is a neighbourhood in Seattle. ",
      "All citizens of Lawton Park use the zip code 98199. ",
      "Tom is a citizen of Lawton Park.",
      "Daniel uses the zip code 98199. "
    ],
    "question": "Tom doesn't use the zip code 98199.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nNeighbourhood(x) ::: x is a neighbourhood.\nUseZipCode(x, y) ::: x uses the zip code y.\nCitizen(x) ::: x is a citizen.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nNeighbourhood(lawtonPark) ∧ UseZipCode(lawtonPark, 98199) ::: Lawton Park is a neighbourhood in Seattle.\n∀x (Citizen(x) → UseZipCode(x, 98199)) ::: All citizens of Lawton Park use the zip code 98199.\nCitizen(tom) ∧ Citizen(daniel) ∧ UseZipCode(daniel, 98199) ::: Tom is a citizen of Lawton Park. Daniel uses the zip code 98199.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬UseZipCode(tom, 98199) ::: Tom doesn't use the zip code 98199.\n\"\"\""
    ]
  },
  {
    "id": 252,
    "context": [
      "Lawton Park is a neighbourhood in Seattle. ",
      "All citizens of Lawton Park use the zip code 98199. ",
      "Tom is a citizen of Lawton Park.",
      "Daniel uses the zip code 98199. "
    ],
    "question": "Tom is a citizen of Washington.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nNeighbourhood(x) ::: x is a neighbourhood.\nUseZipCode(x, y) ::: x uses the zip code y.\nCitizen(x) ::: x is a citizen.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nNeighbourhood(lawtonPark) ∧ Neighbourhood(seattle) ::: Lawton Park is a neighbourhood in Seattle.\n∀x (Citizen(x) → UseZipCode(x, 98199)) ::: All citizens of Lawton Park use the zip code 98199.\nCitizen(tom) ∧ Citizen(daniel) ∧ UseZipCode(daniel, 98199) ::: Tom is a citizen of Lawton Park. Daniel uses the zip code 98199.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬Citizen(tom) ::: Tom is a citizen of Washington.\n\"\"\""
    ]
  },
  {
    "id": 253,
    "context": [
      "Lawton Park is a neighbourhood in Seattle. ",
      "All citizens of Lawton Park use the zip code 98199. ",
      "Tom is a citizen of Lawton Park.",
      "Daniel uses the zip code 98199. "
    ],
    "question": "Daniel is a citizen of Lawton Park.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nNeighbourhood(x) ::: x is a neighbourhood.\nUseZipCode(x, y) ::: x uses the zip code y.\nCitizen(x) ::: x is a citizen.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nNeighbourhood(lawtonPark) ∧ UseZipCode(lawtonPark, 98199) ::: Lawton Park is a neighbourhood in Seattle.\n∀x (Citizen(x) → UseZipCode(x, 98199)) ::: All citizens of Lawton Park use the zip code 98199.\nCitizen(tom) ∧ Citizen(daniel) ::: Tom is a citizen of Lawton Park. Daniel is a citizen of Lawton Park.\nUseZipCode(daniel, 98199) ::: Daniel uses the zip code 98199.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nCitizen(daniel) ::: Daniel is a citizen of Lawton Park.\n\"\"\""
    ]
  },
  {
    "id": 262,
    "context": [
      "If a legislator is found guilty of stealing government funds, they will be suspended from office.",
      "Tiffany T. Alston was a legislator in Maryland's House of Delegates from 2011 to 2013.",
      "Tiffany T. Alston was found guilty of stealing government funds in 2012."
    ],
    "question": "Tiffany T. Alston was suspended from the Maryland House of Delegates.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nLegislator(x) ::: x is a legislator.\nSteals(x, y) ::: x steals y.\nGovernmentFunds(x) ::: x is government funds.\nSuspended(x) ::: x is suspended from office.\nIn(x, y) ::: x is in y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Legislator(x) ∧ Steals(x, GovernmentFunds) → Suspended(x)) ::: If a legislator is found guilty of stealing government funds, they will be suspended from office.\nIn(tiffany, marylandHouseOfDelegates) ∧ Legislator(tiffany) ∧ (2011 <= From(tiffany) <= 2013) ::: Tiffany T. Alston was a legislator in Maryland's House of Delegates from 2011 to 2013.\nSteals(tiffany, governmentFunds) ∧ (2012 = Year(tiffany)) ::: Tiffany T. Alston was found guilty of stealing government funds in 2012.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nSuspended(tiffany) ::: Tiffany T. Alston was suspended from the Maryland House of Delegates.\n\"\"\""
    ]
  },
  {
    "id": 263,
    "context": [
      "If a legislator is found guilty of stealing government funds, they will be suspended from office.",
      "Tiffany T. Alston was a legislator in Maryland's House of Delegates from 2011 to 2013.",
      "Tiffany T. Alston was found guilty of stealing government funds in 2012."
    ],
    "question": "Tiffany T. Alston was not suspended from the Maryland House of Delegates.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nLegislator(x) ::: x is a legislator.\nStealing(x, y) ::: x is found guilty of stealing y.\nSuspended(x) ::: x is suspended from office.\nIn(x, y) ::: x is in y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Legislator(x) ∧ Stealing(x, governmentFunds) → Suspended(x)) ::: If a legislator is found guilty of stealing government funds, they will be suspended from office.\nLegislator(tiffany) ∧ In(tiffany, marylandHouseOfDelegates) ∧ In(tiffany, 2011, 2013) ::: Tiffany T. Alston was a legislator in Maryland's House of Delegates from 2011 to 2013.\nStealing(tiffany, governmentFunds) ∧ In(tiffany, 2012) ::: Tiffany T. Alston was found guilty of stealing government funds in 2012.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬Suspended(tiffany) ::: Tiffany T. Alston was not suspended from the Maryland House of Delegates.\n\"\"\""
    ]
  },
  {
    "id": 264,
    "context": [
      "If a legislator is found guilty of stealing government funds, they will be suspended from office.",
      "Tiffany T. Alston was a legislator in Maryland's House of Delegates from 2011 to 2013.",
      "Tiffany T. Alston was found guilty of stealing government funds in 2012."
    ],
    "question": "Tiffany T. Alston went to prison for stealing government funds.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nLegislator(x) ::: x is a legislator.\nStealing(x) ::: x is guilty of stealing government funds.\nSuspended(x) ::: x is suspended from office.\nMarylandHouseOfDelegates(x) ::: x is a member of Maryland's House of Delegates.\nFromTo(x, y, z) ::: x is in position y from year z.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Legislator(x) ∧ Stealing(x) → Suspended(x)) ::: If a legislator is found guilty of stealing government funds, they will be suspended from office.\nLegislator(tiffany) ∧ MarylandHouseOfDelegates(tiffany) ∧ FromTo(tiffany, MarylandHouseOfDelegates, 2011) ∧ FromTo(tiffany, MarylandHouseOfDelegates, 2013) ::: Tiffany T. Alston was a legislator in Maryland's House of Delegates from 2011 to 2013.\nStealing(tiffany) ∧ FromTo(tiffany, MarylandHouseOfDelegates, 2012) ::: Tiffany T. Alston was found guilty of stealing government funds in 2012.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n∃x (Stealing(x) ∧ FromTo(x, MarylandHouseOfDelegates, 2012)) ::: Tiffany T. Alston went to prison for stealing government funds.\n\"\"\""
    ]
  },
  {
    "id": 494,
    "context": [
      "Some fish may sting.",
      "Stonefish is a fish.",
      "It stings to step on a stonefish.",
      "Stonefish stings cause death if not treated.",
      "To treat stonefish stings, apply heat to the affected area or use an antivenom."
    ],
    "question": "If you step on a stonefish and don’t use an antivenom, it will cause death.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nSting(x) ::: x may sting.\nFish(x) ::: x is a fish.\nStonefish(x) ::: x is a stonefish.\nStepOn(x) ::: x is stepped on.\nCauseDeath(x) ::: x causes death.\nTreat(x) ::: x is treated.\nApplyHeat(x) ::: x is heat applied to the affected area.\nUseAntivenom(x) ::: x is an antivenom used.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∃x (Fish(x) ∧ Sting(x)) ::: Some fish may sting.\nStonefish(stonefish) ∧ Fish(stonefish) ::: Stonefish is a fish.\nStepOn(steppedOn, stonefish) ∧ Sting(stonefish) ::: It stings to step on a stonefish.\nStonefish(stonefish) ∧ Sting(stonefish) ∧ ¬Treat(stonefish) → CauseDeath(stonefish) ::: Stonefish stings cause death if not treated.\n∀x (Stonefish(x) ∧ Sting(x) ∧ ¬Treat(x)) → (ApplyHeat(x) ∨ UseAntivenom(x)) ::: To treat stonefish stings, apply heat to the affected area or use an antivenom.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nStepOn(steppedOn, stonefish) ∧ ¬UseAntivenom(stonefish) → CauseDeath(stonefish) ::: If you step on a stonefish and don’t use an antivenom, it will cause death.\n\"\"\""
    ]
  },
  {
    "id": 495,
    "context": [
      "Some fish may sting.",
      "Stonefish is a fish.",
      "It stings to step on a stonefish.",
      "Stonefish stings cause death if not treated.",
      "To treat stonefish stings, apply heat to the affected area or use an antivenom."
    ],
    "question": "Stings of some fish can cause death if not treated.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nFish(x) ::: x is a fish.\nSting(x) ::: x may sting.\nStonefish(x) ::: x is a stonefish.\nStepOn(x) ::: it stings to step on x.\nCauseDeath(x) ::: x causes death if not treated.\nTreat(x, y) ::: to treat x, apply y.\nApplyHeat(x) ::: apply heat to x.\nUseAntivenom(x) ::: use an antivenom for x.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∃x (Fish(x) ∧ Sting(x)) ::: Some fish may sting.\nFish(stonefish) ∧ Stonefish(stonefish) ::: Stonefish is a fish.\nStepOn(stonefish) → Sting(stonefish) ::: It stings to step on a stonefish.\nStonefish(stings) ∧ CauseDeath(stings) ∧ ¬Treat(stings, _) ::: Stonefish stings cause death if not treated.\n∀x (Stonefish(x) ∧ CauseDeath(x) ∧ ¬Treat(x, _)) → (ApplyHeat(x) ∨ UseAntivenom(x)) ::: To treat stonefish stings, apply heat to the affected area or use an antivenom.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n∃x (Fish(x) ∧ Sting(x) ∧ CauseDeath(x) ∧ ¬Treat(x, _)) ::: Stings of some fish can cause death if not treated.\n\"\"\""
    ]
  },
  {
    "id": 496,
    "context": [
      "Some fish may sting.",
      "Stonefish is a fish.",
      "It stings to step on a stonefish.",
      "Stonefish stings cause death if not treated.",
      "To treat stonefish stings, apply heat to the affected area or use an antivenom."
    ],
    "question": "If you step on a stonefish and apply heat to the affected area, stings will cause death.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nSting(x) ::: x may sting.\nFish(x) ::: x is a fish.\nStonefish(x) ::: x is a stonefish.\nStepOn(x) ::: x is stepped on.\nCauseDeath(x) ::: x causes death.\nTreat(x, y) ::: x is treated with y.\nApplyHeat(x) ::: x is applied heat to the affected area.\nUseAntivenom(x) ::: x uses an antivenom.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∃x (Fish(x) ∧ Sting(x)) ::: Some fish may sting.\nStonefish(stonefish) ∧ Fish(stonefish) ::: Stonefish is a fish.\nStepOn(steppedOn, stonefish) ∧ Sting(stonefish) ::: It stings to step on a stonefish.\n∀x (Stonefish(x) ∧ Sting(x) → CauseDeath(x) ∧ ¬Treat(x, treated)) ::: Stonefish stings cause death if not treated.\n∀x (Stonefish(x) ∧ Sting(x) → Treat(x, applyHeat) ∨ Treat(x, useAntivenom)) ::: To treat stonefish stings, apply heat to the affected area or use an antivenom.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nStepOn(steppedOn, stonefish) ∧ ApplyHeat(steppedOn) → CauseDeath(stonefish) ::: If you step on a stonefish and apply heat to the affected area, stings will cause death.\n\"\"\""
    ]
  },
  {
    "id": 1178,
    "context": [
      "Some monitors produced by LG have a type-c port.",
      "If the monitor has a type-c port, then it is not produced by AOC.",
      "All monitors in the library are produced by AOC. ",
      "L-2021 is either in the library or has a type-c port.",
      "L-2021 is either produced by AOC and produced by LG, or neither produced by AOC nor produced by LG."
    ],
    "question": "L-2021 is in the library.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nHasTypeC(x) ::: x has a type-c port.\nProducedByLG(x) ::: x is produced by LG.\nProducedByAOC(x) ::: x is produced by AOC.\nInLibrary(x) ::: x is in the library.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∃x (ProducedByLG(x) ∧ HasTypeC(x)) ::: Some monitors produced by LG have a type-c port.\n∀x (HasTypeC(x) → ¬ProducedByAOC(x)) ::: If the monitor has a type-c port, then it is not produced by AOC.\n∀x (InLibrary(x) → ProducedByAOC(x)) ::: All monitors in the library are produced by AOC.\n(InLibrary(L-2021) ∨ HasTypeC(L-2021)) ::: L-2021 is either in the library or has a type-c port.\n¬((ProducedByAOC(L-2021) ∧ ProducedByLG(L-2021)) → (ProducedByAOC(L-2021) ∨ ProducedByLG(L-2021))) ::: L-2021 is either produced by AOC and produced by LG, or neither produced by AOC nor produced by LG.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nInLibrary(L-2021) ::: L-2021 is in the library.\n\"\"\""
    ]
  },
  {
    "id": 1179,
    "context": [
      "Some monitors produced by LG have a type-c port.",
      "If the monitor has a type-c port, then it is not produced by AOC.",
      "All monitors in the library are produced by AOC. ",
      "L-2021 is either in the library or has a type-c port.",
      "L-2021 is either produced by AOC and produced by LG, or neither produced by AOC nor produced by LG."
    ],
    "question": "L-2021 is either in the library or produced by LG.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nHasTypeC(x) ::: x has a type-c port.\nProducedByLG(x) ::: x is produced by LG.\nProducedByAOC(x) ::: x is produced by AOC.\nInLibrary(x) ::: x is in the library.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∃x (ProducedByLG(x) ∧ HasTypeC(x)) ::: Some monitors produced by LG have a type-c port.\n∀x (HasTypeC(x) → ¬ProducedByAOC(x)) ::: If the monitor has a type-c port, then it is not produced by AOC.\n∀x (InLibrary(x) → ProducedByAOC(x)) ::: All monitors in the library are produced by AOC.\n(InLibrary(L-2021) ∨ HasTypeC(L-2021)) ::: L-2021 is either in the library or has a type-c port.\n¬((ProducedByAOC(L-2021) ∧ ProducedByLG(L-2021)) → (ProducedByAOC(L-2021) ∨ ProducedByLG(L-2021))) ::: L-2021 is either produced by AOC and produced by LG, or neither produced by AOC nor produced by LG.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nInLibrary(L-2021) ∨ ProducedByLG(L-2021) ::: L-2021 is either in the library or produced by LG.\n\"\"\""
    ]
  },
  {
    "id": 1180,
    "context": [
      "Some monitors produced by LG have a type-c port.",
      "If the monitor has a type-c port, then it is not produced by AOC.",
      "All monitors in the library are produced by AOC. ",
      "L-2021 is either in the library or has a type-c port.",
      "L-2021 is either produced by AOC and produced by LG, or neither produced by AOC nor produced by LG."
    ],
    "question": "L-2021 either has a type-c port or is produced by LG.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nHasTypeC(x) ::: x has a type-c port.\nProducedByLG(x) ::: x is produced by LG.\nProducedByAOC(x) ::: x is produced by AOC.\nInLibrary(x) ::: x is in the library.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∃x (ProducedByLG(x) ∧ HasTypeC(x)) ::: Some monitors produced by LG have a type-c port.\n∀x (HasTypeC(x) → ¬ProducedByAOC(x)) ::: If the monitor has a type-c port, then it is not produced by AOC.\n∀x (InLibrary(x) → ProducedByAOC(x)) ::: All monitors in the library are produced by AOC.\n(InLibrary(L-2021) ∨ HasTypeC(L-2021)) ::: L-2021 is either in the library or has a type-c port.\n¬((ProducedByAOC(L-2021) ∧ ProducedByLG(L-2021)) → (ProducedByAOC(L-2021) ∨ ProducedByLG(L-2021))) ::: L-2021 is either produced by AOC and produced by LG, or neither produced by AOC nor produced by LG.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nHasTypeC(L-2021) ∨ ProducedByLG(L-2021) ::: L-2021 either has a type-c port or is produced by LG.\n\"\"\""
    ]
  },
  {
    "id": 1181,
    "context": [
      "Some monitors produced by LG have a type-c port.",
      "If the monitor has a type-c port, then it is not produced by AOC.",
      "All monitors in the library are produced by AOC. ",
      "L-2021 is either in the library or has a type-c port.",
      "L-2021 is either produced by AOC and produced by LG, or neither produced by AOC nor produced by LG."
    ],
    "question": "If L-2021 is either in the library and produced by LG, or neither in the library nor produced by LG,  then L-2021 neither has a type-c port nor is produced by LG.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nHasTypeC(x) ::: x has a type-c port.\nProducedByLG(x) ::: x is produced by LG.\nProducedByAOC(x) ::: x is produced by AOC.\nInLibrary(x) ::: x is in the library.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∃x (ProducedByLG(x) ∧ HasTypeC(x)) ::: Some monitors produced by LG have a type-c port.\n∀x (HasTypeC(x) → ¬ProducedByAOC(x)) ::: If the monitor has a type-c port, then it is not produced by AOC.\n∀x (InLibrary(x) → ProducedByAOC(x)) ::: All monitors in the library are produced by AOC.\n(InLibrary(L-2021) ∨ HasTypeC(L-2021)) ::: L-2021 is either in the library or has a type-c port.\n(InLibrary(L-2021) ∧ ProducedByAOC(L-2021)) ⊕ ¬(ProducedByAOC(L-2021) ∧ ProducedByLG(L-2021)) ::: L-2021 is either produced by AOC and produced by LG, or neither produced by AOC nor produced by LG.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n((InLibrary(L-2021) ∧ ProducedByLG(L-2021)) ⊕ ¬(InLibrary(L-2021) ∨ ProducedByLG(L-2021))) → (¬HasTypeC(L-2021) ∧ ¬ProducedByLG(L-2021)) ::: If L-2021 is either in the library and produced by LG, or neither in the library nor produced by LG, then L-2021 neither has a type-c port nor is produced by LG.\n\"\"\""
    ]
  },
  {
    "id": 1182,
    "context": [
      "Some monitors produced by LG have a type-c port.",
      "If the monitor has a type-c port, then it is not produced by AOC.",
      "All monitors in the library are produced by AOC. ",
      "L-2021 is either in the library or has a type-c port.",
      "L-2021 is either produced by AOC and produced by LG, or neither produced by AOC nor produced by LG."
    ],
    "question": "If L-2021 is either produced by LG and produced by AOC or neither produced by LG nor produced by AOC,  then L-2021 is either in the library or produced by LG.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nHasTypeC(x) ::: x has a type-c port.\nProducedByLG(x) ::: x is produced by LG.\nProducedByAOC(x) ::: x is produced by AOC.\nInLibrary(x) ::: x is in the library.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∃x (Monitors(x) ∧ ProducedByLG(x) ∧ HasTypeC(x)) ::: Some monitors produced by LG have a type-c port.\n∀x (HasTypeC(x) → ¬ProducedByAOC(x)) ::: If the monitor has a type-c port, then it is not produced by AOC.\n∀x (Monitors(x) → ProducedByAOC(x)) ::: All monitors in the library are produced by AOC.\n(InLibrary(L-2021) ∨ HasTypeC(L-2021)) ::: L-2021 is either in the library or has a type-c port.\n(InLibrary(L-2021) ⊕ ProducedByAOC(L-2021) ∧ ProducedByLG(L-2021)) ::: L-2021 is either produced by AOC and produced by LG, or neither produced by AOC nor produced by LG.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n((ProducedByLG(L-2021) ∧ ProducedByAOC(L-2021)) ∨ ¬(ProducedByLG(L-2021) ∨ ProducedByAOC(L-2021))) → (InLibrary(L-2021) ∨ ProducedByLG(L-2021)) ::: If L-2021 is either produced by LG and produced by AOC or neither produced by LG nor produced by AOC, then L-2021 is either in the library or produced by LG.\n\"\"\""
    ]
  },
  {
    "id": 1010,
    "context": [
      "People eat meat regularly or are vegetation.",
      "If people eat meat regularly, then they enjoy eating hamburgers and steaks.",
      "All people who are vegetarian are conscious of the environment or their health.",
      "If people are conscious about the environment or their health, then they do not go to fast food places often.",
      "If people have busy schedules without time to cook, then they go to fast food places often.",
      "If Jeremy does not both go to fast food places often and is conscious about the environment or their health, then he goes to fast food places often."
    ],
    "question": "Jeremy has a busy schedule without time to cook.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nEatMeat(x) ::: x eats meat regularly.\nVegetarian(x) ::: x is a vegetarian.\nEnjoy(x, y) ::: x enjoys eating y.\nConscious(x) ::: x is conscious of the environment or their health.\nFastFood(x) ::: x goes to fast food places often.\nBusy(x) ::: x has a busy schedule without time to cook.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (EatMeat(x) ∨ Vegetarian(x)) ::: People eat meat regularly or are vegetarian.\n∀x (EatMeat(x) → (Enjoy(x, hamburgers) ∧ Enjoy(x, steaks))) ::: If people eat meat regularly, then they enjoy eating hamburgers and steaks.\n∀x (Vegetarian(x) → (Conscious(x))) ::: All people who are vegetarian are conscious of the environment or their health.\n∀x (Conscious(x) → ¬FastFood(x)) ::: If people are conscious about the environment or their health, then they do not go to fast food places often.\n∀x (Busy(x) → FastFood(x)) ::: If people have busy schedules without time to cook, then they go to fast food places often.\n¬(FastFood(jeremy) ∧ Conscious(jeremy)) → FastFood(jeremy) ::: If Jeremy does not both go to fast food places often and is conscious about the environment or their health, then he goes to fast food places often.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nBusy(jeremy) ::: Jeremy has a busy schedule without time to cook.\n\"\"\""
    ]
  },
  {
    "id": 1011,
    "context": [
      "People eat meat regularly or are vegetation.",
      "If people eat meat regularly, then they enjoy eating hamburgers and steaks.",
      "All people who are vegetarian are conscious of the environment or their health.",
      "If people are conscious about the environment or their health, then they do not go to fast food places often.",
      "If people have busy schedules without time to cook, then they go to fast food places often.",
      "If Jeremy does not both go to fast food places often and is conscious about the environment or their health, then he goes to fast food places often."
    ],
    "question": "Jeremy has a busy schedule without time to cook or enjoy eating hamburgers and steaks.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nEatMeat(x) ::: x eats meat regularly.\nVegetarian(x) ::: x is a vegetarian.\nEnjoy(x, y) ::: x enjoys eating y.\nConscious(x) ::: x is conscious of the environment or their health.\nFastFood(x) ::: x goes to fast food places often.\nBusy(x) ::: x has a busy schedule without time to cook.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (EatMeat(x) ∨ Vegetarian(x)) ::: People eat meat regularly or are vegetarian.\n∀x (EatMeat(x) → (Enjoy(x, hamburgers) ∧ Enjoy(x, steaks))) ::: If people eat meat regularly, then they enjoy eating hamburgers and steaks.\n∀x (Vegetarian(x) → (Conscious(x) ∨ Conscious(x))) ::: All people who are vegetarian are conscious of the environment or their health.\n∀x ((Conscious(x) ∨ Conscious(x)) → ¬FastFood(x)) ::: If people are conscious about the environment or their health, then they do not go to fast food places often.\n∀x ((Busy(x) ∧ ¬Cook(x)) → FastFood(x)) ::: If people have busy schedules without time to cook, then they go to fast food places often.\n¬(FastFood(jeremy) ∧ Conscious(jeremy)) → FastFood(jeremy) ::: If Jeremy does not both go to fast food places often and is conscious about the environment or their health, then he goes to fast food places often.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n(Busy(jeremy) ∧ ¬Cook(jeremy)) ∨ (Enjoy(jeremy, hamburgers) ∧ Enjoy(jeremy, steaks)) ::: Jeremy has a busy schedule without time to cook or enjoy eating hamburgers and steaks.\n\"\"\""
    ]
  },
  {
    "id": 1012,
    "context": [
      "People eat meat regularly or are vegetation.",
      "If people eat meat regularly, then they enjoy eating hamburgers and steaks.",
      "All people who are vegetarian are conscious of the environment or their health.",
      "If people are conscious about the environment or their health, then they do not go to fast food places often.",
      "If people have busy schedules without time to cook, then they go to fast food places often.",
      "If Jeremy does not both go to fast food places often and is conscious about the environment or their health, then he goes to fast food places often."
    ],
    "question": "If Jeremy has a busy schedule without time to cook or enjoy eating hamburgers and steaks, then Jeremy neither has a busy schedule without having time to cook nor enjoys eating hamburgers and steaks.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nEatMeat(x) ::: x eats meat regularly.\nVegetarian(x) ::: x is a vegetarian.\nEnjoy(x, y) ::: x enjoys eating y.\nConscious(x) ::: x is conscious of the environment or their health.\nFastFood(x) ::: x goes to fast food places often.\nBusy(x) ::: x has a busy schedule without time to cook.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (EatMeat(x) ∨ Vegetarian(x)) ::: People eat meat regularly or are vegetarian.\n∀x (EatMeat(x) → (Enjoy(x, hamburgers) ∧ Enjoy(x, steaks))) ::: If people eat meat regularly, then they enjoy eating hamburgers and steaks.\n∀x (Vegetarian(x) → (Conscious(x) ∨ Conscious(x))) ::: All people who are vegetarian are conscious of the environment or their health.\n∀x ((Conscious(x) ∨ Conscious(x)) → ¬FastFood(x)) ::: If people are conscious about the environment or their health, then they do not go to fast food places often.\n∀x ((Busy(x) → FastFood(x)) → FastFood(x)) ::: If people have busy schedules without time to cook, then they go to fast food places often.\n¬(FastFood(jeremy) ∧ Conscious(jeremy)) → FastFood(jeremy) ::: If Jeremy does not both go to fast food places often and is conscious about the environment or their health, then he goes to fast food places often.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n(Busy(jeremy) ∨ Enjoy(jeremy, hamburgers) ∧ Enjoy(jeremy, steaks)) → ¬(Busy(jeremy) ∧ Enjoy(jeremy, hamburgers) ∧ Enjoy(jeremy, steaks)) ::: If Jeremy has a busy schedule without time to cook or enjoy eating hamburgers and steaks, then Jeremy neither has a busy schedule without having time to cook nor enjoys eating hamburgers and steaks.\n\"\"\""
    ]
  },
  {
    "id": 521,
    "context": [
      "Sam is doing a project.",
      "A project is written either in Rust or in Python.",
      "If Sam does a project written in Python, he will not use a Mac.",
      "Sam is using a Mac.",
      "If Sam uses a Mac, he will play a song.",
      "If a song is not \"Perfect\", Sam will never play it."
    ],
    "question": "The project Sam is doing is written in Rust.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nDoing(x) ::: x is doing a project.\nWrittenIn(x, y) ::: x is written in language y.\nUse(x, y) ::: x uses device y.\nPlay(x) ::: x plays a song.\nSong(x) ::: x is a song.\nNever(x, y) ::: x never does y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nDoing(sam) ::: Sam is doing a project.\n∀x (Doing(x) → (WrittenIn(x, rust) ∨ WrittenIn(x, python))) ::: A project is written either in Rust or in Python.\n(WrittenIn(sam, python) → ¬Use(sam, mac)) ::: If Sam does a project written in Python, he will not use a Mac.\nUse(sam, mac) ::: Sam is using a Mac.\n(Use(sam, mac) → Play(sam)) ::: If Sam uses a Mac, he will play a song.\n∀x (Song(x) ∧ ¬(x = perfect) → Never(sam, x)) ::: If a song is not \"Perfect\", Sam will never play it.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nWrittenIn(sam, rust) ::: The project Sam is doing is written in Rust.\n\"\"\""
    ]
  },
  {
    "id": 522,
    "context": [
      "Sam is doing a project.",
      "A project is written either in Rust or in Python.",
      "If Sam does a project written in Python, he will not use a Mac.",
      "Sam is using a Mac.",
      "If Sam uses a Mac, he will play a song.",
      "If a song is not \"Perfect\", Sam will never play it."
    ],
    "question": "The song Sam is playing is \"Perfect\".",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nDoing(x) ::: x is doing a project.\nWrittenIn(x, y) ::: x is written in y.\nUse(x, y) ::: x uses y.\nPlay(x) ::: x plays a song.\nSong(x) ::: x is a song.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nDoing(sam) ::: Sam is doing a project.\n∀x (Project(x) → (WrittenIn(x, rust) ∨ WrittenIn(x, python))) ::: A project is written either in Rust or in Python.\n(WrittenIn(sam, python) → ¬Use(sam, mac)) ::: If Sam does a project written in Python, he will not use a Mac.\nUse(sam, mac) ::: Sam is using a Mac.\n(Use(sam, mac) → Play(sam)) ::: If Sam uses a Mac, he will play a song.\n¬Song(perfect) → ¬Play(sam) ::: If a song is not \"Perfect\", Sam will never play it.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nPlay(sam) ∧ Song(perfect) ::: The song Sam is playing is \"Perfect\".\n\"\"\""
    ]
  },
  {
    "id": 523,
    "context": [
      "Sam is doing a project.",
      "A project is written either in Rust or in Python.",
      "If Sam does a project written in Python, he will not use a Mac.",
      "Sam is using a Mac.",
      "If Sam uses a Mac, he will play a song.",
      "If a song is not \"Perfect\", Sam will never play it."
    ],
    "question": "If a song is \"Perfect\", Sam will play it.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nDoing(x) ::: x is doing a project.\nWrittenIn(x, y) ::: x is written in language y.\nUse(x, y) ::: x uses device y.\nPlay(x) ::: x plays a song.\nSong(x) ::: x is a song.\nPerfect(x) ::: x is the song \"Perfect\".\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nDoing(sam) ::: Sam is doing a project.\n∀x (Project(x) → (WrittenIn(x, rust) ∨ WrittenIn(x, python))) ::: A project is written either in Rust or in Python.\n(WrittenIn(sam, python) → ¬Use(sam, mac)) ::: If Sam does a project written in Python, he will not use a Mac.\nUse(sam, mac) ::: Sam is using a Mac.\n(Use(sam, mac) → Play(sam)) ::: If Sam uses a Mac, he will play a song.\n¬Perfect(song) → ¬Play(song) ::: If a song is not \"Perfect\", Sam will never play it.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nPerfect(song) → Play(song) ::: If a song is \"Perfect\", Sam will play it.\n\"\"\""
    ]
  },
  {
    "id": 703,
    "context": [
      "All rabbits have fur",
      "Some pets are rabbits."
    ],
    "question": "Some pets do not have fur.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nRabbit(x) ::: x is a rabbit.\nHasFur(x) ::: x has fur.\nPet(x) ::: x is a pet.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Rabbit(x) → HasFur(x)) ::: All rabbits have fur.\n∃x (Pet(x) ∧ Rabbit(x)) ::: Some pets are rabbits.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n∃x (Pet(x) ∧ ¬HasFur(x)) ::: Some pets do not have fur.\n\"\"\""
    ]
  },
  {
    "id": 1390,
    "context": [
      "All video applications are software.",
      "All YouTube-related applications are video applications. ",
      "An APP is either related to YouTube or Instagram.",
      "All Instagram is entertainment. ",
      "All software is programmed. ",
      "All entertainments are interesting.",
      "If something is interesting, then it is good.",
      "TikTok is not good."
    ],
    "question": "Tiktok is a program.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nVideoApp(x) ::: x is a video application.\nSoftware(x) ::: x is software.\nYouTubeApp(x) ::: x is a YouTube-related application.\nInstagramApp(x) ::: x is an Instagram-related application.\nApp(x) ::: x is an APP.\nInstagram(x) ::: x is Instagram.\nEntertainment(x) ::: x is entertainment.\nProgrammed(x) ::: x is programmed.\nInteresting(x) ::: x is interesting.\nGood(x) ::: x is good.\nTikTok(x) ::: x is TikTok.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (VideoApp(x) → Software(x)) ::: All video applications are software.\n∀x (YouTubeApp(x) → VideoApp(x)) ::: All YouTube-related applications are video applications.\n∀x (App(x) → (YouTubeApp(x) ∨ InstagramApp(x))) ::: An APP is either related to YouTube or Instagram.\n∀x (Instagram(x) → Entertainment(x)) ::: All Instagram is entertainment.\n∀x (Software(x) → Programmed(x)) ::: All software is programmed.\n∀x (Entertainment(x) → Interesting(x)) ::: All entertainments are interesting.\n∀x (Interesting(x) → Good(x)) ::: If something is interesting, then it is good.\n¬Good(TikTok) ::: TikTok is not good.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nProgrammed(TikTok) ::: Tiktok is a program.\n\"\"\""
    ]
  },
  {
    "id": 1391,
    "context": [
      "All video applications are software.",
      "All YouTube-related applications are video applications. ",
      "An APP is either related to YouTube or Instagram.",
      "All Instagram is entertainment. ",
      "All software is programmed. ",
      "All entertainments are interesting.",
      "If something is interesting, then it is good.",
      "TikTok is not good."
    ],
    "question": "Tiktok is either good or a program.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nVideoApp(x) ::: x is a video application.\nSoftware(x) ::: x is software.\nYouTubeApp(x) ::: x is a YouTube-related application.\nAPP(x) ::: x is an APP.\nInstagramApp(x) ::: x is related to Instagram.\nInstagram(x) ::: x is Instagram.\nEntertainment(x) ::: x is entertainment.\nProgrammed(x) ::: x is programmed.\nInteresting(x) ::: x is interesting.\nGood(x) ::: x is good.\nTikTok(x) ::: x is TikTok.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (VideoApp(x) → Software(x)) ::: All video applications are software.\n∀x (YouTubeApp(x) → VideoApp(x)) ::: All YouTube-related applications are video applications.\n∀x (APP(x) → (YouTubeApp(x) ∨ InstagramApp(x))) ::: An APP is either related to YouTube or Instagram.\n∀x (Instagram(x) → Entertainment(x)) ::: All Instagram is entertainment.\n∀x (Software(x) → Programmed(x)) ::: All software is programmed.\n∀x (Entertainment(x) → Interesting(x)) ::: All entertainments are interesting.\n∀x (Interesting(x) → Good(x)) ::: If something is interesting, then it is good.\n¬Good(TikTok) ::: TikTok is not good.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nGood(TikTok) ∨ Programmed(TikTok) ::: Tiktok is either good or a program.\n\"\"\""
    ]
  },
  {
    "id": 1392,
    "context": [
      "All video applications are software.",
      "All YouTube-related applications are video applications. ",
      "An APP is either related to YouTube or Instagram.",
      "All Instagram is entertainment. ",
      "All software is programmed. ",
      "All entertainments are interesting.",
      "If something is interesting, then it is good.",
      "TikTok is not good."
    ],
    "question": "Tiktok is not both related to youtube and a program.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nVideoApp(x) ::: x is a video application.\nSoftware(x) ::: x is software.\nYouTubeApp(x) ::: x is a YouTube-related application.\nInstagramApp(x) ::: x is an Instagram-related application.\nApp(x) ::: x is an APP.\nRelatedTo(x, y) ::: x is related to y.\nInstagram(x) ::: x is Instagram.\nEntertainment(x) ::: x is entertainment.\nProgrammed(x) ::: x is programmed.\nInteresting(x) ::: x is interesting.\nGood(x) ::: x is good.\nTikTok(x) ::: x is TikTok.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (VideoApp(x) → Software(x)) ::: All video applications are software.\n∀x (YouTubeApp(x) → VideoApp(x)) ::: All YouTube-related applications are video applications.\n∀x (App(x) → (RelatedTo(x, YouTube) ∨ RelatedTo(x, Instagram))) ::: An APP is either related to YouTube or Instagram.\n∀x (InstagramApp(x) → Instagram(x)) ::: All Instagram-related applications are related to Instagram.\n∀x (Instagram(x) → Entertainment(x)) ::: All Instagram is entertainment.\n∀x (Software(x) → Programmed(x)) ::: All software is programmed.\n∀x (Entertainment(x) → Interesting(x)) ::: All entertainments are interesting.\n∀x (Interesting(x) → Good(x)) ::: If something is interesting, then it is good.\n¬Good(TikTok) ::: TikTok is not good.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬(RelatedTo(TikTok, YouTube) ∧ Programmed(TikTok)) ::: Tiktok is not both related to youtube and a program.\n\"\"\""
    ]
  },
  {
    "id": 1393,
    "context": [
      "All video applications are software.",
      "All YouTube-related applications are video applications. ",
      "An APP is either related to YouTube or Instagram.",
      "All Instagram is entertainment. ",
      "All software is programmed. ",
      "All entertainments are interesting.",
      "If something is interesting, then it is good.",
      "TikTok is not good."
    ],
    "question": "Tiktok is either related to youtube or a program.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nVideoApp(x) ::: x is a video application.\nSoftware(x) ::: x is software.\nYouTubeApp(x) ::: x is a YouTube-related application.\nInstagramApp(x) ::: x is an Instagram-related application.\nApp(x) ::: x is an APP.\nRelatedTo(x, y) ::: x is related to y.\nInstagram(x) ::: x is Instagram.\nEntertainment(x) ::: x is entertainment.\nProgrammed(x) ::: x is programmed.\nInteresting(x) ::: x is interesting.\nGood(x) ::: x is good.\nTikTok(x) ::: x is TikTok.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (VideoApp(x) → Software(x)) ::: All video applications are software.\n∀x (YouTubeApp(x) → VideoApp(x)) ::: All YouTube-related applications are video applications.\n∀x (App(x) → (RelatedTo(x, YouTube) ∨ RelatedTo(x, Instagram))) ::: An APP is either related to YouTube or Instagram.\n∀x (InstagramApp(x) → Instagram(x)) ::: All Instagram-related applications are related to Instagram.\n∀x (Instagram(x) → Entertainment(x)) ::: All Instagram is entertainment.\n∀x (Software(x) → Programmed(x)) ::: All software is programmed.\n∀x (Entertainment(x) → Interesting(x)) ::: All entertainments are interesting.\n∀x (Interesting(x) → Good(x)) ::: If something is interesting, then it is good.\n¬Good(TikTok) ::: TikTok is not good.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nRelatedTo(TikTok, YouTube) ∨ Programmed(TikTok) ::: Tiktok is either related to youtube or a program.\n\"\"\""
    ]
  },
  {
    "id": 317,
    "context": [
      "Ordinary is an unincorporated community.",
      "Located within Elliot County, Ordinary is on Kentucky Route 32.",
      "Ordinary is located northwest of Sandy Hook."
    ],
    "question": "There are no unincorporated communities along Kentucky Route 32.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nCommunity(x) ::: x is a community.\nUnincorporated(x) ::: x is an unincorporated community.\nLocatedIn(x, y) ::: x is located within y.\nOn(x, y) ::: x is on y.\nNorthwestOf(x, y) ::: x is located northwest of y.\nRoute(x) ::: x is a route.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nUnincorporated(ordinary) ::: Ordinary is an unincorporated community.\nLocatedIn(ordinary, elliotCounty) ∧ On(ordinary, kentuckyRoute32) ::: Located within Elliot County, Ordinary is on Kentucky Route 32.\nNorthwestOf(ordinary, sandyHook) ::: Ordinary is located northwest of Sandy Hook.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬∃x (Unincorporated(x) ∧ On(x, kentuckyRoute32)) ::: There are no unincorporated communities along Kentucky Route 32.\n\"\"\""
    ]
  },
  {
    "id": 318,
    "context": [
      "Ordinary is an unincorporated community.",
      "Located within Elliot County, Ordinary is on Kentucky Route 32.",
      "Ordinary is located northwest of Sandy Hook."
    ],
    "question": "There is an unincorporated community in Elliot County.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nUnincorporated(x) ::: x is an unincorporated community.\nLocatedIn(x, y) ::: x is located within y.\nOnRoute(x, y) ::: x is on route y.\nLocatedNorthwestOf(x, y) ::: x is located northwest of y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nUnincorporated(ordinary) ::: Ordinary is an unincorporated community.\nLocatedIn(ordinary, elliotCounty) ∧ OnRoute(ordinary, kentuckyRoute32) ::: Located within Elliot County, Ordinary is on Kentucky Route 32.\nLocatedNorthwestOf(ordinary, sandyHook) ::: Ordinary is located northwest of Sandy Hook.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n∃x (Unincorporated(x) ∧ LocatedIn(x, elliotCounty)) ::: There is an unincorporated community in Elliot County.\n\"\"\""
    ]
  },
  {
    "id": 926,
    "context": [
      "All young adults go on a diet.",
      "All college students are young adults.",
      "All Yale students are college students.",
      "Someone is either a Yale student or a Harvard student.",
      "All Harvard students are diligent.",
      "If Susan is a Harvard student, then she is a young adult.",
      "If Susan is a Yale student, then she does not go on a diet."
    ],
    "question": "Susan is a college student.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nYoungAdult(x) ::: x is a young adult.\nDiet(x) ::: x goes on a diet.\nCollegeStudent(x) ::: x is a college student.\nYaleStudent(x) ::: x is a Yale student.\nHarvardStudent(x) ::: x is a Harvard student.\nDiligent(x) ::: x is diligent.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (YoungAdult(x) → Diet(x)) ::: All young adults go on a diet.\n∀x (CollegeStudent(x) → YoungAdult(x)) ::: All college students are young adults.\n∀x (YaleStudent(x) → CollegeStudent(x)) ::: All Yale students are college students.\n∃x (YaleStudent(x) ∨ HarvardStudent(x)) ::: Someone is either a Yale student or a Harvard student.\n∀x (HarvardStudent(x) → Diligent(x)) ::: All Harvard students are diligent.\n(HarvardStudent(susan) → YoungAdult(susan)) ::: If Susan is a Harvard student, then she is a young adult.\n(YaleStudent(susan) → ¬Diet(susan)) ::: If Susan is a Yale student, then she does not go on a diet.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nCollegeStudent(susan) ::: Susan is a college student.\n\"\"\""
    ]
  },
  {
    "id": 927,
    "context": [
      "All young adults go on a diet.",
      "All college students are young adults.",
      "All Yale students are college students.",
      "Someone is either a Yale student or a Harvard student.",
      "All Harvard students are diligent.",
      "If Susan is a Harvard student, then she is a young adult.",
      "If Susan is a Yale student, then she does not go on a diet."
    ],
    "question": "Susan goes on a diet and is diligent.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nYoungAdult(x) ::: x is a young adult.\nDiet(x) ::: x goes on a diet.\nCollegeStudent(x) ::: x is a college student.\nYaleStudent(x) ::: x is a Yale student.\nHarvardStudent(x) ::: x is a Harvard student.\nDiligent(x) ::: x is diligent.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (YoungAdult(x) → Diet(x)) ::: All young adults go on a diet.\n∀x (CollegeStudent(x) → YoungAdult(x)) ::: All college students are young adults.\n∀x (YaleStudent(x) → CollegeStudent(x)) ::: All Yale students are college students.\n∃x (YaleStudent(x) ∨ HarvardStudent(x)) ::: Someone is either a Yale student or a Harvard student.\n∀x (HarvardStudent(x) → Diligent(x)) ::: All Harvard students are diligent.\n(HarvardStudent(susan) → YoungAdult(susan)) ::: If Susan is a Harvard student, then she is a young adult.\n(YaleStudent(susan) → ¬Diet(susan)) ::: If Susan is a Yale student, then she does not go on a diet.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nDiet(susan) ∧ Diligent(susan) ::: Susan goes on a diet and is diligent.\n\"\"\""
    ]
  },
  {
    "id": 928,
    "context": [
      "All young adults go on a diet.",
      "All college students are young adults.",
      "All Yale students are college students.",
      "Someone is either a Yale student or a Harvard student.",
      "All Harvard students are diligent.",
      "If Susan is a Harvard student, then she is a young adult.",
      "If Susan is a Yale student, then she does not go on a diet."
    ],
    "question": "Susan does not go on a diet and is diligent.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nYoungAdult(x) ::: x is a young adult.\nDiet(x) ::: x goes on a diet.\nCollegeStudent(x) ::: x is a college student.\nYaleStudent(x) ::: x is a Yale student.\nHarvardStudent(x) ::: x is a Harvard student.\nDiligent(x) ::: x is diligent.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (YoungAdult(x) → Diet(x)) ::: All young adults go on a diet.\n∀x (CollegeStudent(x) → YoungAdult(x)) ::: All college students are young adults.\n∀x (YaleStudent(x) → CollegeStudent(x)) ::: All Yale students are college students.\n∃x (YaleStudent(x) ∨ HarvardStudent(x)) ::: Someone is either a Yale student or a Harvard student.\n∀x (HarvardStudent(x) → Diligent(x)) ::: All Harvard students are diligent.\n(HarvardStudent(susan) → YoungAdult(susan)) ::: If Susan is a Harvard student, then she is a young adult.\n(YaleStudent(susan) → ¬Diet(susan)) ::: If Susan is a Yale student, then she does not go on a diet.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬Diet(susan) ∧ Diligent(susan) ::: Susan does not go on a diet and is diligent.\n\"\"\""
    ]
  },
  {
    "id": 432,
    "context": [
      "Vic DiCara plays guitar and bass.",
      "The only style of music Vic DiCara plays is punk music.",
      "Vic DiCara played in the band Inside Out."
    ],
    "question": "Inside Out was a punk band.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nPlays(x, y) ::: x plays y.\nStyle(x, y) ::: x plays only y.\nBand(x) ::: x is a band.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nPlays(vic, guitar) ∧ Plays(vic, bass) ::: Vic DiCara plays guitar and bass.\n∀x (Style(vic, x) ↔ x = punk) ::: The only style of music Vic DiCara plays is punk music.\nPlays(vic, insideOut) ::: Vic DiCara played in the band Inside Out.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n∃x (Band(x) ∧ x = insideOut ∧ Style(x, punk)) ::: Inside Out was a punk band.\n\"\"\""
    ]
  },
  {
    "id": 433,
    "context": [
      "Vic DiCara plays guitar and bass.",
      "The only style of music Vic DiCara plays is punk music.",
      "Vic DiCara played in the band Inside Out."
    ],
    "question": "A musician of Inside Out plays bass.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nPlays(x, y) ::: x plays y.\nStyle(x, y) ::: x plays music of style y.\nBandMember(x, y) ::: x is a member of band y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nPlays(vicDiCara, guitar) ∧ Plays(vicDiCara, bass) ::: Vic DiCara plays guitar and bass.\n∀x (Style(vicDiCara, punk)) ::: The only style of music Vic DiCara plays is punk music.\nBandMember(vicDiCara, insideOut) ::: Vic DiCara played in the band Inside Out.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n∃x (BandMember(x, insideOut) ∧ Plays(x, bass)) ::: A musician of Inside Out plays bass.\n\"\"\""
    ]
  },
  {
    "id": 918,
    "context": [
      "All athletes are good at sports.",
      "All Olympic gold medal winners are good athletes.",
      "No scientists are good at sports.",
      "All Nobel laureates are scientists.",
      "Amy is good at sports or Amy is an Olympic gold medal winner.",
      "If Amy is not a Nobel laureate, then Amy is not an Olympic gold medal winner."
    ],
    "question": "Amy is an athlete.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nAthlete(x) ::: x is an athlete.\nGoodAtSports(x) ::: x is good at sports.\nOlympicWinner(x) ::: x is an Olympic gold medal winner.\nScientist(x) ::: x is a scientist.\nNobelLaureate(x) ::: x is a Nobel laureate.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Athlete(x) → GoodAtSports(x)) ::: All athletes are good at sports.\n∀x (OlympicWinner(x) → Athlete(x)) ::: All Olympic gold medal winners are good athletes.\n∀x (Scientist(x) → ¬GoodAtSports(x)) ::: No scientists are good at sports.\n∀x (NobelLaureate(x) → Scientist(x)) ::: All Nobel laureates are scientists.\n(GoodAtSports(amy) ∨ OlympicWinner(amy)) ::: Amy is good at sports or Amy is an Olympic gold medal winner.\n¬NobelLaureate(amy) → ¬OlympicWinner(amy) ::: If Amy is not a Nobel laureate, then Amy is not an Olympic gold medal winner.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nAthlete(amy) ::: Amy is an athlete.\n\"\"\""
    ]
  },
  {
    "id": 919,
    "context": [
      "All athletes are good at sports.",
      "All Olympic gold medal winners are good athletes.",
      "No scientists are good at sports.",
      "All Nobel laureates are scientists.",
      "Amy is good at sports or Amy is an Olympic gold medal winner.",
      "If Amy is not a Nobel laureate, then Amy is not an Olympic gold medal winner."
    ],
    "question": "Amy is neither a scientist nor an Olympic gold medal winner.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nAthlete(x) ::: x is an athlete.\nGoodAtSports(x) ::: x is good at sports.\nOlympicWinner(x) ::: x is an Olympic gold medal winner.\nScientist(x) ::: x is a scientist.\nNobelLaureate(x) ::: x is a Nobel laureate.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Athlete(x) → GoodAtSports(x)) ::: All athletes are good at sports.\n∀x (OlympicWinner(x) → Athlete(x)) ::: All Olympic gold medal winners are good athletes.\n∀x (Scientist(x) → ¬GoodAtSports(x)) ::: No scientists are good at sports.\n∀x (NobelLaureate(x) → Scientist(x)) ::: All Nobel laureates are scientists.\nGoodAtSports(amy) ∨ OlympicWinner(amy) ::: Amy is good at sports or Amy is an Olympic gold medal winner.\n¬NobelLaureate(amy) → ¬OlympicWinner(amy) ::: If Amy is not a Nobel laureate, then Amy is not an Olympic gold medal winner.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬(Scientist(amy) ∨ OlympicWinner(amy)) ::: Amy is neither a scientist nor an Olympic gold medal winner.\n\"\"\""
    ]
  },
  {
    "id": 920,
    "context": [
      "All athletes are good at sports.",
      "All Olympic gold medal winners are good athletes.",
      "No scientists are good at sports.",
      "All Nobel laureates are scientists.",
      "Amy is good at sports or Amy is an Olympic gold medal winner.",
      "If Amy is not a Nobel laureate, then Amy is not an Olympic gold medal winner."
    ],
    "question": "If Amy is not an Olympic gold medal winner, then Amy is a Nobel laureate.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nAthlete(x) ::: x is an athlete.\nGoodAtSports(x) ::: x is good at sports.\nOlympicWinner(x) ::: x is an Olympic gold medal winner.\nScientist(x) ::: x is a scientist.\nNobelLaureate(x) ::: x is a Nobel laureate.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Athlete(x) → GoodAtSports(x)) ::: All athletes are good at sports.\n∀x (OlympicWinner(x) → Athlete(x)) ::: All Olympic gold medal winners are good athletes.\n∀x (Scientist(x) → ¬GoodAtSports(x)) ::: No scientists are good at sports.\n∀x (NobelLaureate(x) → Scientist(x)) ::: All Nobel laureates are scientists.\n(GoodAtSports(amy) ∨ OlympicWinner(amy)) ::: Amy is good at sports or Amy is an Olympic gold medal winner.\n¬NobelLaureate(amy) → ¬OlympicWinner(amy) ::: If Amy is not a Nobel laureate, then Amy is not an Olympic gold medal winner.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬OlympicWinner(amy) → NobelLaureate(amy) ::: If Amy is not an Olympic gold medal winner, then Amy is a Nobel laureate.\n\"\"\""
    ]
  },
  {
    "id": 1147,
    "context": [
      "All fruits with the color red contain a large amount of vitamin C.",
      "All apples are fruits with the color red.",
      "All fruits containing a large amount of vitamin C are beneficial to people. ",
      "No fruits that are beneficial to people are on a warning list.",
      "If K is not beneficial to people and also not an apple, then it is a fruit with the color red."
    ],
    "question": "K is an apple.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nRed(x) ::: x is a fruit with the color red.\nVitaminC(x) ::: x contains a large amount of vitamin C.\nBeneficial(x) ::: x is beneficial to people.\nApple(x) ::: x is an apple.\nOnWarningList(x) ::: x is on a warning list.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Red(x) → VitaminC(x)) ::: All fruits with the color red contain a large amount of vitamin C.\n∀x (Apple(x) → Red(x)) ::: All apples are fruits with the color red.\n∀x (VitaminC(x) → Beneficial(x)) ::: All fruits containing a large amount of vitamin C are beneficial to people.\n∀x (Beneficial(x) → ¬OnWarningList(x)) ::: No fruits that are beneficial to people are on a warning list.\n¬(Beneficial(K) ∧ ¬Apple(K)) → Red(K) ::: If K is not beneficial to people and also not an apple, then it is a fruit with the color red.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nApple(K) ::: K is an apple.\n\"\"\""
    ]
  },
  {
    "id": 1148,
    "context": [
      "All fruits with the color red contain a large amount of vitamin C.",
      "All apples are fruits with the color red.",
      "All fruits containing a large amount of vitamin C are beneficial to people. ",
      "No fruits that are beneficial to people are on a warning list.",
      "If K is not beneficial to people and also not an apple, then it is a fruit with the color red."
    ],
    "question": "K either contains a large amount of vitamin C or is on a warning list.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nRed(x) ::: x is a fruit with the color red.\nVitaminC(x) ::: x contains a large amount of vitamin C.\nBeneficial(x) ::: x is beneficial to people.\nApple(x) ::: x is an apple.\nOnWarningList(x) ::: x is on a warning list.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Red(x) → VitaminC(x)) ::: All fruits with the color red contain a large amount of vitamin C.\n∀x (Apple(x) → Red(x)) ::: All apples are fruits with the color red.\n∀x (VitaminC(x) → Beneficial(x)) ::: All fruits containing a large amount of vitamin C are beneficial to people.\n∀x (Beneficial(x) → ¬OnWarningList(x)) ::: No fruits that are beneficial to people are on a warning list.\n¬(Beneficial(K) ∧ ¬Apple(K)) → (Red(K)) ::: If K is not beneficial to people and also not an apple, then it is a fruit with the color red.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nVitaminC(K) ∨ OnWarningList(K) ::: K either contains a large amount of vitamin C or is on a warning list.\n\"\"\""
    ]
  },
  {
    "id": 1149,
    "context": [
      "All fruits with the color red contain a large amount of vitamin C.",
      "All apples are fruits with the color red.",
      "All fruits containing a large amount of vitamin C are beneficial to people. ",
      "No fruits that are beneficial to people are on a warning list.",
      "If K is not beneficial to people and also not an apple, then it is a fruit with the color red."
    ],
    "question": "K is either on a warning list or with the color red.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nContainsVitaminC(x) ::: x contains a large amount of vitamin C.\nRed(x) ::: x is red in color.\nApple(x) ::: x is an apple.\nBeneficial(x) ::: x is beneficial to people.\nOnWarningList(x) ::: x is on a warning list.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Red(x) → ContainsVitaminC(x)) ::: All fruits with the color red contain a large amount of vitamin C.\n∀x (Apple(x) → Red(x)) ::: All apples are fruits with the color red.\n∀x (ContainsVitaminC(x) → Beneficial(x)) ::: All fruits containing a large amount of vitamin C are beneficial to people.\n∀x (Beneficial(x) → ¬OnWarningList(x)) ::: No fruits that are beneficial to people are on a warning list.\n¬(Beneficial(K) ∧ ¬Apple(K)) → Red(K) ::: If K is not beneficial to people and also not an apple, then it is a fruit with the color red.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nOnWarningList(K) ∨ Red(K) ::: K is either on a warning list or with the color red.\n\"\"\""
    ]
  },
  {
    "id": 1150,
    "context": [
      "All fruits with the color red contain a large amount of vitamin C.",
      "All apples are fruits with the color red.",
      "All fruits containing a large amount of vitamin C are beneficial to people. ",
      "No fruits that are beneficial to people are on a warning list.",
      "If K is not beneficial to people and also not an apple, then it is a fruit with the color red."
    ],
    "question": "If K is either beneficial to people or on a warning list, then it is not red.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nRed(x) ::: x is a fruit with the color red.\nVitaminC(x) ::: x contains a large amount of vitamin C.\nApple(x) ::: x is an apple.\nBeneficial(x) ::: x is beneficial to people.\nOnWarningList(x) ::: x is on a warning list.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Red(x) → VitaminC(x)) ::: All fruits with the color red contain a large amount of vitamin C.\n∀x (Apple(x) → Red(x)) ::: All apples are fruits with the color red.\n∀x (VitaminC(x) → Beneficial(x)) ::: All fruits containing a large amount of vitamin C are beneficial to people.\n∀x (Beneficial(x) → ¬OnWarningList(x)) ::: No fruits that are beneficial to people are on a warning list.\n¬(Beneficial(K) ∧ Apple(K)) → (Red(K)) ::: If K is not beneficial to people and also not an apple, then it is a fruit with the color red.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n(Beneficial(K) ∨ OnWarningList(K)) → ¬Red(K) ::: If K is either beneficial to people or on a warning list, then it is not red.\n\"\"\""
    ]
  },
  {
    "id": 1151,
    "context": [
      "All fruits with the color red contain a large amount of vitamin C.",
      "All apples are fruits with the color red.",
      "All fruits containing a large amount of vitamin C are beneficial to people. ",
      "No fruits that are beneficial to people are on a warning list.",
      "If K is not beneficial to people and also not an apple, then it is a fruit with the color red."
    ],
    "question": "If K is either on a warning list or with the color red, then it is not beneficial to people and does not contain a large amount of vitamin C.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nContainsVitaminC(x) ::: x contains a large amount of vitamin C.\nRed(x) ::: x is a fruit with the color red.\nApple(x) ::: x is an apple.\nBeneficial(x) ::: x is beneficial to people.\nOnWarningList(x) ::: x is on a warning list.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Red(x) → ContainsVitaminC(x)) ::: All fruits with the color red contain a large amount of vitamin C.\n∀x (Apple(x) → Red(x)) ::: All apples are fruits with the color red.\n∀x (ContainsVitaminC(x) → Beneficial(x)) ::: All fruits containing a large amount of vitamin C are beneficial to people.\n∀x (Beneficial(x) → ¬OnWarningList(x)) ::: No fruits that are beneficial to people are on a warning list.\n¬(Beneficial(K) ∧ Apple(K)) → (Red(K) ∧ ¬Beneficial(K) ∧ ¬ContainsVitaminC(K)) ::: If K is not beneficial to people and also not an apple, then it is a fruit with the color red.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n(OnWarningList(K) ∨ Red(K)) → (¬Beneficial(K) ∧ ¬ContainsVitaminC(K)) ::: If K is either on a warning list or with the color red, then it is not beneficial to people and does not contain a large amount of vitamin C.\n\"\"\""
    ]
  },
  {
    "id": 1207,
    "context": [
      "Everyone working at Meta has a high income. ",
      "If a person has a high income, then he/she will not take a bus to their destination.",
      "People will either take a bus or drive to their destination. ",
      "Everyone who has a car will choose to drive to their destination. ",
      "No students drive to their destination. ",
      "James has a car or works at Meta."
    ],
    "question": "James has a high income.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nWorksAt(x, y) ::: x works at y.\nHighIncome(x) ::: x has a high income.\nTakesBus(x) ::: x takes a bus to their destination.\nDrives(x) ::: x drives to their destination.\nHasCar(x) ::: x has a car.\nStudent(x) ::: x is a student.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (WorksAt(x, Meta) → HighIncome(x)) ::: Everyone working at Meta has a high income.\n∀x (HighIncome(x) → ¬TakesBus(x)) ::: If a person has a high income, then he/she will not take a bus to their destination.\n∀x (TakesBus(x) ⊕ Drives(x)) ::: People will either take a bus or drive to their destination.\n∀x (HasCar(x) → Drives(x)) ::: Everyone who has a car will choose to drive to their destination.\n∀x (Student(x) → ¬Drives(x)) ::: No students drive to their destination.\nHasCar(james) ∨ WorksAt(james, Meta) ::: James has a car or works at Meta.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nHighIncome(james) ::: James has a high income.\n\"\"\""
    ]
  },
  {
    "id": 1208,
    "context": [
      "Everyone working at Meta has a high income. ",
      "If a person has a high income, then he/she will not take a bus to their destination.",
      "People will either take a bus or drive to their destination. ",
      "Everyone who has a car will choose to drive to their destination. ",
      "No students drive to their destination. ",
      "James has a car or works at Meta."
    ],
    "question": "James does not have a high income.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nWorksAt(x, y) ::: x works at y.\nHighIncome(x) ::: x has a high income.\nTakesBus(x) ::: x takes a bus to their destination.\nDrives(x) ::: x drives to their destination.\nHasCar(x) ::: x has a car.\nStudent(x) ::: x is a student.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (WorksAt(x, Meta) → HighIncome(x)) ::: Everyone working at Meta has a high income.\n∀x (HighIncome(x) → ¬TakesBus(x)) ::: If a person has a high income, then he/she will not take a bus to their destination.\n∀x (TakesBus(x) ⊕ Drives(x)) ::: People will either take a bus or drive to their destination.\n∀x (HasCar(x) → Drives(x)) ::: Everyone who has a car will choose to drive to their destination.\n∀x (Student(x) → ¬Drives(x)) ::: No students drive to their destination.\nHasCar(james) ∨ WorksAt(james, Meta) ::: James has a car or works at Meta.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬HighIncome(james) ::: James does not have a high income.\n\"\"\""
    ]
  },
  {
    "id": 1209,
    "context": [
      "Everyone working at Meta has a high income. ",
      "If a person has a high income, then he/she will not take a bus to their destination.",
      "People will either take a bus or drive to their destination. ",
      "Everyone who has a car will choose to drive to their destination. ",
      "No students drive to their destination. ",
      "James has a car or works at Meta."
    ],
    "question": "James is a student.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nWorksAt(x, y) ::: x works at y.\nHighIncome(x) ::: x has a high income.\nTakesBus(x) ::: x takes a bus to their destination.\nDrives(x) ::: x drives to their destination.\nHasCar(x) ::: x has a car.\nStudent(x) ::: x is a student.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (WorksAt(x, Meta) → HighIncome(x)) ::: Everyone working at Meta has a high income.\n∀x (HighIncome(x) → ¬TakesBus(x)) ::: If a person has a high income, then he/she will not take a bus to their destination.\n∀x (TakesBus(x) ⊕ Drives(x)) ::: People will either take a bus or drive to their destination.\n∀x (HasCar(x) → Drives(x)) ::: Everyone who has a car will choose to drive to their destination.\n∀x (Student(x) → ¬Drives(x)) ::: No students drive to their destination.\n(HasCar(james) ∨ WorksAt(james, Meta)) ::: James has a car or works at Meta.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬Student(james) ::: James is not a student.\n\"\"\""
    ]
  },
  {
    "id": 1210,
    "context": [
      "Everyone working at Meta has a high income. ",
      "If a person has a high income, then he/she will not take a bus to their destination.",
      "People will either take a bus or drive to their destination. ",
      "Everyone who has a car will choose to drive to their destination. ",
      "No students drive to their destination. ",
      "James has a car or works at Meta."
    ],
    "question": "James drives to his destination or he is a student.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nWorksAt(x, y) ::: x works at y.\nHighIncome(x) ::: x has a high income.\nTakesBus(x) ::: x takes a bus to their destination.\nDrives(x) ::: x drives to their destination.\nHasCar(x) ::: x has a car.\nStudent(x) ::: x is a student.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (WorksAt(x, Meta) → HighIncome(x)) ::: Everyone working at Meta has a high income.\n∀x (HighIncome(x) → ¬TakesBus(x)) ::: If a person has a high income, then he/she will not take a bus to their destination.\n∀x (TakesBus(x) ⊕ Drives(x)) ::: People will either take a bus or drive to their destination.\n∀x (HasCar(x) → Drives(x)) ::: Everyone who has a car will choose to drive to their destination.\n∀x (Student(x) → ¬Drives(x)) ::: No students drive to their destination.\nHasCar(james) ∨ WorksAt(james, Meta) ::: James has a car or works at Meta.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nDrives(james) ∨ Student(james) ::: James drives to his destination or he is a student.\n\"\"\""
    ]
  },
  {
    "id": 1211,
    "context": [
      "Everyone working at Meta has a high income. ",
      "If a person has a high income, then he/she will not take a bus to their destination.",
      "People will either take a bus or drive to their destination. ",
      "Everyone who has a car will choose to drive to their destination. ",
      "No students drive to their destination. ",
      "James has a car or works at Meta."
    ],
    "question": "James either drives to their destination or is a student.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nWorksAt(x, y) ::: x works at y.\nHighIncome(x) ::: x has a high income.\nTakesBus(x) ::: x takes a bus to their destination.\nDrives(x) ::: x drives to their destination.\nHasCar(x) ::: x has a car.\nStudent(x) ::: x is a student.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (WorksAt(x, Meta) → HighIncome(x)) ::: Everyone working at Meta has a high income.\n∀x (HighIncome(x) → ¬TakesBus(x)) ::: If a person has a high income, then he/she will not take a bus to their destination.\n∀x (TakesBus(x) ⊕ Drives(x)) ::: People will either take a bus or drive to their destination.\n∀x (HasCar(x) → Drives(x)) ::: Everyone who has a car will choose to drive to their destination.\n∀x (Student(x) → ¬Drives(x)) ::: No students drive to their destination.\n(HasCar(james) ∨ WorksAt(james, Meta)) ::: James has a car or works at Meta.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nDrives(james) ⊕ Student(james) ::: James either drives to their destination or is a student.\n\"\"\""
    ]
  },
  {
    "id": 1212,
    "context": [
      "Everyone working at Meta has a high income. ",
      "If a person has a high income, then he/she will not take a bus to their destination.",
      "People will either take a bus or drive to their destination. ",
      "Everyone who has a car will choose to drive to their destination. ",
      "No students drive to their destination. ",
      "James has a car or works at Meta."
    ],
    "question": "If James either drives to his destination or is a student, then he has a high income and is a student.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nWorksAt(x, y) ::: x works at y.\nHighIncome(x) ::: x has a high income.\nTakesBus(x) ::: x takes a bus to their destination.\nDrives(x) ::: x drives to their destination.\nHasCar(x) ::: x has a car.\nStudent(x) ::: x is a student.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (WorksAt(x, Meta) → HighIncome(x)) ::: Everyone working at Meta has a high income.\n∀x (HighIncome(x) → ¬TakesBus(x)) ::: If a person has a high income, then he/she will not take a bus to their destination.\n∀x (TakesBus(x) ⊕ Drives(x)) ::: People will either take a bus or drive to their destination.\n∀x (HasCar(x) → Drives(x)) ::: Everyone who has a car will choose to drive to their destination.\n∀x (Student(x) → ¬Drives(x)) ::: No students drive to their destination.\nHasCar(james) ∨ WorksAt(james, Meta) ::: James has a car or works at Meta.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n(Drives(james) ∨ Student(james)) → (HighIncome(james) ∧ Student(james)) ::: If James either drives to his destination or is a student, then he has a high income and is a student.\n\"\"\""
    ]
  },
  {
    "id": 1202,
    "context": [
      "Students either go to the park or go to the movies. ",
      "No student who enjoys nature has free time during the weekend. ",
      "All students who go to the movies enjoy nature. ",
      "All students who do not have class during the weekend have free time during the weekend. ",
      "All students not in summer camp do not have class during the weekend. ",
      "James does not have class during the weekend."
    ],
    "question": "James is in summer camp.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nStudent(x) ::: x is a student.\nGoToPark(x) ::: x goes to the park.\nGoToMovies(x) ::: x goes to the movies.\nEnjoyNature(x) ::: x enjoys nature.\nFreeTime(x, y) ::: x has free time during y.\nHaveClass(x, y) ::: x has class during y.\nSummerCamp(x) ::: x is in summer camp.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Student(x) → (GoToPark(x) ∨ GoToMovies(x))) ::: Students either go to the park or go to the movies.\n∀x (EnjoyNature(x) → ¬FreeTime(x, weekend)) ::: No student who enjoys nature has free time during the weekend.\n∀x (GoToMovies(x) → EnjoyNature(x)) ::: All students who go to the movies enjoy nature.\n∀x (¬HaveClass(x, weekend) → FreeTime(x, weekend)) ::: All students who do not have class during the weekend have free time during the weekend.\n∀x (¬SummerCamp(x) → ¬HaveClass(x, weekend)) ::: All students not in summer camp do not have class during the weekend.\n¬HaveClass(james, weekend) ::: James does not have class during the weekend.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬SummerCamp(james) ::: James is in summer camp.\n\"\"\""
    ]
  },
  {
    "id": 1203,
    "context": [
      "Students either go to the park or go to the movies. ",
      "No student who enjoys nature has free time during the weekend. ",
      "All students who go to the movies enjoy nature. ",
      "All students who do not have class during the weekend have free time during the weekend. ",
      "All students not in summer camp do not have class during the weekend. ",
      "James does not have class during the weekend."
    ],
    "question": "James goes to the park or is in summer camp.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nGoToPark(x) ::: x goes to the park.\nGoToMovies(x) ::: x goes to the movies.\nEnjoyNature(x) ::: x enjoys nature.\nFreeTime(x, y) ::: x has free time during y.\nHasClass(x, y) ::: x has class during y.\nSummerCamp(x) ::: x is in summer camp.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (GoToPark(x) ∨ GoToMovies(x)) ::: Students either go to the park or go to the movies.\n∀x (EnjoyNature(x) → ¬FreeTime(x, weekend)) ::: No student who enjoys nature has free time during the weekend.\n∀x (GoToMovies(x) → EnjoyNature(x)) ::: All students who go to the movies enjoy nature.\n∀x (¬HasClass(x, weekend) → FreeTime(x, weekend)) ::: All students who do not have class during the weekend have free time during the weekend.\n∀x (¬SummerCamp(x) → ¬HasClass(x, weekend)) ::: All students not in summer camp do not have class during the weekend.\n¬HasClass(james, weekend) ::: James does not have class during the weekend.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nGoToPark(james) ∨ SummerCamp(james) ::: James goes to the park or is in summer camp.\n\"\"\""
    ]
  },
  {
    "id": 713,
    "context": [
      "No television stars are certified public accountants.",
      "All certified public accountants have good business sense."
    ],
    "question": "All television stars have good business sense.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nTelevisionStar(x) ::: x is a television star.\nCertifiedPublicAccountant(x) ::: x is a certified public accountant.\nGoodBusinessSense(x) ::: x has good business sense.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (TelevisionStar(x) → ¬CertifiedPublicAccountant(x)) ::: No television stars are certified public accountants.\n∀x (CertifiedPublicAccountant(x) → GoodBusinessSense(x)) ::: All certified public accountants have good business sense.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n∀x (TelevisionStar(x) → GoodBusinessSense(x)) ::: All television stars have good business sense.\n\"\"\""
    ]
  },
  {
    "id": 1174,
    "context": [
      "Some students good at math are good at chemistry.",
      "All students good at chemistry enjoy conducting experiments. ",
      "All students that enjoy conducting experiments are good at planning. ",
      "No student good at planning is awarded the Dean's List. ",
      "James is either good at chemistry and awarded the Dean's List, or neither good at chemistry nor awarded the Dean's List."
    ],
    "question": "James is good at planning.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nGoodAtMath(x) ::: x is good at math.\nGoodAtChemistry(x) ::: x is good at chemistry.\nEnjoyConductingExperiments(x) ::: x enjoys conducting experiments.\nGoodAtPlanning(x) ::: x is good at planning.\nAwardedDeansList(x) ::: x is awarded the Dean's List.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∃x (GoodAtMath(x) ∧ GoodAtChemistry(x)) ::: Some students good at math are good at chemistry.\n∀x (GoodAtChemistry(x) → EnjoyConductingExperiments(x)) ::: All students good at chemistry enjoy conducting experiments.\n∀x (EnjoyConductingExperiments(x) → GoodAtPlanning(x)) ::: All students that enjoy conducting experiments are good at planning.\n∀x (GoodAtPlanning(x) → ¬AwardedDeansList(x)) ::: No student good at planning is awarded the Dean's List.\n(GoodAtChemistry(james) ∧ AwardedDeansList(james)) ⊕ ¬(GoodAtChemistry(james) ∨ AwardedDeansList(james)) ::: James is either good at chemistry and awarded the Dean's List, or neither good at chemistry nor awarded the Dean's List.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nGoodAtPlanning(james) ::: James is good at planning.\n\"\"\""
    ]
  },
  {
    "id": 1175,
    "context": [
      "Some students good at math are good at chemistry.",
      "All students good at chemistry enjoy conducting experiments. ",
      "All students that enjoy conducting experiments are good at planning. ",
      "No student good at planning is awarded the Dean's List. ",
      "James is either good at chemistry and awarded the Dean's List, or neither good at chemistry nor awarded the Dean's List."
    ],
    "question": "James is either good at planning or good at math.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nGoodAtMath(x) ::: x is good at math.\nGoodAtChemistry(x) ::: x is good at chemistry.\nEnjoyConductingExperiments(x) ::: x enjoys conducting experiments.\nGoodAtPlanning(x) ::: x is good at planning.\nAwardedDeansList(x) ::: x is awarded the Dean's List.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∃x (GoodAtMath(x) ∧ GoodAtChemistry(x)) ::: Some students good at math are good at chemistry.\n∀x (GoodAtChemistry(x) → EnjoyConductingExperiments(x)) ::: All students good at chemistry enjoy conducting experiments.\n∀x (EnjoyConductingExperiments(x) → GoodAtPlanning(x)) ::: All students that enjoy conducting experiments are good at planning.\n∀x (GoodAtPlanning(x) → ¬AwardedDeansList(x)) ::: No student good at planning is awarded the Dean's List.\n(GoodAtChemistry(james) ∧ AwardedDeansList(james)) ⊕ ¬(GoodAtChemistry(james) ∨ AwardedDeansList(james)) ::: James is either good at chemistry and awarded the Dean's List, or neither good at chemistry nor awarded the Dean's List.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nGoodAtPlanning(james) ∨ GoodAtMath(james) ::: James is either good at planning or good at math.\n\"\"\""
    ]
  },
  {
    "id": 1176,
    "context": [
      "Some students good at math are good at chemistry.",
      "All students good at chemistry enjoy conducting experiments. ",
      "All students that enjoy conducting experiments are good at planning. ",
      "No student good at planning is awarded the Dean's List. ",
      "James is either good at chemistry and awarded the Dean's List, or neither good at chemistry nor awarded the Dean's List."
    ],
    "question": "James is either good at chemistry or good at math.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nGoodAtMath(x) ::: x is good at math.\nGoodAtChemistry(x) ::: x is good at chemistry.\nEnjoyConductingExperiments(x) ::: x enjoys conducting experiments.\nGoodAtPlanning(x) ::: x is good at planning.\nAwardedDeansList(x) ::: x is awarded the Dean's List.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∃x (GoodAtMath(x) ∧ GoodAtChemistry(x)) ::: Some students good at math are good at chemistry.\n∀x (GoodAtChemistry(x) → EnjoyConductingExperiments(x)) ::: All students good at chemistry enjoy conducting experiments.\n∀x (EnjoyConductingExperiments(x) → GoodAtPlanning(x)) ::: All students that enjoy conducting experiments are good at planning.\n∀x (GoodAtPlanning(x) → ¬AwardedDeansList(x)) ::: No student good at planning is awarded the Dean's List.\n(GoodAtChemistry(james) ∧ AwardedDeansList(james)) ⊕ ¬(GoodAtChemistry(james) ∨ AwardedDeansList(james)) ::: James is either good at chemistry and awarded the Dean's List, or neither good at chemistry nor awarded the Dean's List.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nGoodAtChemistry(james) ⊕ GoodAtMath(james) ::: James is either good at chemistry or good at math.\n\"\"\""
    ]
  },
  {
    "id": 1177,
    "context": [
      "Some students good at math are good at chemistry.",
      "All students good at chemistry enjoy conducting experiments. ",
      "All students that enjoy conducting experiments are good at planning. ",
      "No student good at planning is awarded the Dean's List. ",
      "James is either good at chemistry and awarded the Dean's List, or neither good at chemistry nor awarded the Dean's List."
    ],
    "question": "If James is good at Chemistry or gets awarded the Dean's List, then James is either good at planning or good at math.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nGoodAtMath(x) ::: x is good at math.\nGoodAtChemistry(x) ::: x is good at chemistry.\nEnjoyConductingExperiments(x) ::: x enjoys conducting experiments.\nGoodAtPlanning(x) ::: x is good at planning.\nAwardedDeansList(x) ::: x is awarded the Dean's List.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∃x (GoodAtMath(x) ∧ GoodAtChemistry(x)) ::: Some students good at math are good at chemistry.\n∀x (GoodAtChemistry(x) → EnjoyConductingExperiments(x)) ::: All students good at chemistry enjoy conducting experiments.\n∀x (EnjoyConductingExperiments(x) → GoodAtPlanning(x)) ::: All students that enjoy conducting experiments are good at planning.\n∀x (GoodAtPlanning(x) → ¬AwardedDeansList(x)) ::: No student good at planning is awarded the Dean's List.\n(GoodAtChemistry(james) ∧ AwardedDeansList(james)) ⊕ ¬(GoodAtChemistry(james) ∨ AwardedDeansList(james)) ::: James is either good at chemistry and awarded the Dean's List, or neither good at chemistry nor awarded the Dean's List.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n(GoodAtChemistry(james) ∨ AwardedDeansList(james)) → (GoodAtPlanning(james) ∨ GoodAtMath(james)) ::: If James is good at Chemistry or gets awarded the Dean's List, then James is either good at planning or good at math.\n\"\"\""
    ]
  },
  {
    "id": 69,
    "context": [
      "If a Leetcode problem is at the easy level, then its AC rate is lower than 20 percent. ",
      "All Leetcode problems that are recommended to novices are easy. ",
      "A Leetode problem is either easy or hard.",
      "Leetcode problems that are starred by more than 1 thousand users are hard.",
      "2Sum is recommended to novices. ",
      "4Sum is starred by more than 1 thousand users."
    ],
    "question": "2Sum is a Leetcode problem with an easy level.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nEasy(x) ::: x is an easy Leetcode problem.\nACRate(x, y) ::: x has an acceptance rate of y.\nRecommendedToNovices(x) ::: x is recommended to novices.\nHard(x) ::: x is a hard Leetcode problem.\nStarredBy(x, y) ::: x is starred by more than y users.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Easy(x) → ACRate(x, <20)) ::: If a Leetcode problem is at the easy level, then its AC rate is lower than 20 percent.\n∀x (RecommendedToNovices(x) → Easy(x)) ::: All Leetcode problems that are recommended to novices are easy.\nEasy(x) ⊕ Hard(x) ::: A Leetode problem is either easy or hard.\n∀x (StarredBy(x, 1000) → Hard(x)) ::: Leetcode problems that are starred by more than 1 thousand users are hard.\nRecommendedToNovices(2Sum) ::: 2Sum is recommended to novices.\nStarredBy(4Sum, 1000) ::: 4Sum is starred by more than 1 thousand users.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nEasy(2Sum) ::: 2Sum is a Leetcode problem with an easy level.\n\"\"\""
    ]
  },
  {
    "id": 70,
    "context": [
      "If a Leetcode problem is at the easy level, then its AC rate is lower than 20 percent. ",
      "All Leetcode problems that are recommended to novices are easy. ",
      "A Leetode problem is either easy or hard.",
      "Leetcode problems that are starred by more than 1 thousand users are hard.",
      "2Sum is recommended to novices. ",
      "4Sum is starred by more than 1 thousand users."
    ],
    "question": "4Sum is a Leetcode problem recommended to the novice.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nEasy(x) ::: x is an easy Leetcode problem.\nACRate(x, y) ::: x has an acceptance rate of y percent.\nRecommended(x) ::: x is recommended to novices.\nLeetcode(x) ::: x is a Leetcode problem.\nHard(x) ::: x is a hard Leetcode problem.\nStarredBy(x, y) ::: x is starred by y users.\nNovice(x) ::: x is a novice.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Leetcode(x) ∧ Easy(x) → ACRate(x, y) < 20) ::: If a Leetcode problem is at the easy level, then its AC rate is lower than 20 percent.\n∀x (Recommended(x) → Easy(x)) ::: All Leetcode problems that are recommended to novices are easy.\n∀x (Leetcode(x) → (Easy(x) ∨ Hard(x))) ::: A Leetode problem is either easy or hard.\n∀x (StarredBy(x, y) > 1000 → Hard(x)) ::: Leetcode problems that are starred by more than 1 thousand users are hard.\nRecommended(4Sum) ::: 4Sum is recommended to novices.\nStarredBy(4Sum, moreThan1000) ::: 4Sum is starred by more than 1 thousand users.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nRecommended(4Sum) ::: 4Sum is a Leetcode problem recommended to the novice.\n\"\"\""
    ]
  },
  {
    "id": 71,
    "context": [
      "If a Leetcode problem is at the easy level, then its AC rate is lower than 20 percent. ",
      "All Leetcode problems that are recommended to novices are easy. ",
      "A Leetode problem is either easy or hard.",
      "Leetcode problems that are starred by more than 1 thousand users are hard.",
      "2Sum is recommended to novices. ",
      "4Sum is starred by more than 1 thousand users."
    ],
    "question": "2Sum has an AC rate higher than 20 percent.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nEasy(x) ::: x is an easy Leetcode problem.\nACRate(x, y) ::: x has an acceptance rate of y.\nRecommended(x) ::: x is recommended to novices.\nHard(x) ::: x is a hard Leetcode problem.\nStarredBy(x, y) ::: x is starred by more than y users.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Easy(x) → ACRate(x, rate) < 20) ::: If a Leetcode problem is at the easy level, then its AC rate is lower than 20 percent.\n∀x (Recommended(x) → Easy(x)) ::: All Leetcode problems that are recommended to novices are easy.\n∀x (Easy(x) ∨ Hard(x)) ::: A Leetode problem is either easy or hard.\n∀x (StarredBy(x, 1000) → Hard(x)) ::: Leetcode problems that are starred by more than 1 thousand users are hard.\nRecommended(2Sum) ::: 2Sum is recommended to novices.\nStarredBy(4Sum, 1000) ::: 4Sum is starred by more than 1 thousand users.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬(ACRate(2Sum, rate) < 20) ::: 2Sum has an AC rate higher than 20 percent.\n\"\"\""
    ]
  },
  {
    "id": 692,
    "context": [
      "All rental cars cost the renter money.",
      "Whenever Sarah goes to Vermont, Sarah drives there.",
      "For someone who does not own a car to drive somewhere, they must either borrow a car or rent a car.",
      "Sarah doesn’t own a car.",
      "Sarah never borrows a car to go camping.",
      "Sarah is going to go camping in Vermont this weekend.",
      "To go camping somewhere, you must go to that place."
    ],
    "question": "Sarah will spend money this weekend.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nCosts(x, y) ::: x costs the renter y money.\nDrives(x, y) ::: x drives to y.\nOwns(x, y) ::: x owns y.\nBorrows(x, y) ::: x borrows y.\nRents(x, y) ::: x rents y.\nGoTo(x, y) ::: x goes to y.\nCamping(x) ::: x goes camping.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (RentalCar(x) → Costs(x, renter)) ::: All rental cars cost the renter money.\n∀x (Sarah(x) ∧ GoTo(x, vermont) → Drives(x, vermont)) ::: Whenever Sarah goes to Vermont, Sarah drives there.\n∀x (¬Owns(x, car) ∧ Drives(x, y) → (Borrows(x, car) ∨ Rents(x, car))) ::: For someone who does not own a car to drive somewhere, they must either borrow a car or rent a car.\n¬Owns(sarah, car) ::: Sarah doesn’t own a car.\n¬Borrows(sarah, car) ∧ Camping(weekend) ∧ GoTo(sarah, vermont) ∧ GoTo(camping, vermont) ::: Sarah never borrows a car to go camping. Sarah is going to go camping in Vermont this weekend. To go camping somewhere, you must go to that place.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n∃x (Sarah(x) ∧ Costs(x, weekend)) ::: Sarah will spend money this weekend.\n\"\"\""
    ]
  },
  {
    "id": 1013,
    "context": [
      "All people who attend weddings are getting married or have friends who are getting married.",
      "No preteens and other young children are getting married or have friends who are getting married.",
      "If people enjoy celebrating life milestone events with other people, then they attend weddings.",
      "If people are fond of large organized group functions, then they enjoy celebrating life milestone events with other people.",
      "All people who are outgoing and very spirited are fond of large organized group functions.",
      "If Carol is not both a pre-teen or other young child and attends weddings, then Carol is not getting married or has friends who are getting married.  "
    ],
    "question": "Carol is outgoing and very spirited.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nAttend(x) ::: x attends weddings.\nGettingMarried(x) ::: x is getting married.\nHasFriendsGettingMarried(x) ::: x has friends who are getting married.\nPreteen(x) ::: x is a preteen.\nYoungChild(x) ::: x is a young child.\nCelebrateWithOthers(x) ::: x enjoys celebrating life milestone events with other people.\nFondOfLargeFunctions(x) ::: x is fond of large organized group functions.\nOutgoing(x) ::: x is outgoing.\nSpirited(x) ::: x is very spirited.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Attend(x) → (GettingMarried(x) ∨ HasFriendsGettingMarried(x))) ::: All people who attend weddings are getting married or have friends who are getting married.\n¬∃x (Preteen(x) ∨ YoungChild(x)) → ¬(GettingMarried(x) ∨ HasFriendsGettingMarried(x)) ::: No preteens and other young children are getting married or have friends who are getting married.\n∀x (CelebrateWithOthers(x) → Attend(x)) ::: If people enjoy celebrating life milestone events with other people, then they attend weddings.\n∀x (FondOfLargeFunctions(x) → CelebrateWithOthers(x)) ::: If people are fond of large organized group functions, then they enjoy celebrating life milestone events with other people.\n∀x (Outgoing(x) ∧ Spirited(x) → FondOfLargeFunctions(x)) ::: All people who are outgoing and very spirited are fond of large organized group functions.\n¬((Preteen(carol) ∨ YoungChild(carol)) ∧ Attend(carol)) → ¬(GettingMarried(carol) ∨ HasFriendsGettingMarried(carol)) ::: If Carol is not both a pre-teen or other young child and attends weddings, then Carol is not getting married or has friends who are getting married.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nOutgoing(carol) ∧ Spirited(carol) ::: Carol is outgoing and very spirited.\n\"\"\""
    ]
  },
  {
    "id": 1014,
    "context": [
      "All people who attend weddings are getting married or have friends who are getting married.",
      "No preteens and other young children are getting married or have friends who are getting married.",
      "If people enjoy celebrating life milestone events with other people, then they attend weddings.",
      "If people are fond of large organized group functions, then they enjoy celebrating life milestone events with other people.",
      "All people who are outgoing and very spirited are fond of large organized group functions.",
      "If Carol is not both a pre-teen or other young child and attends weddings, then Carol is not getting married or has friends who are getting married.  "
    ],
    "question": "Carol is either a preteen or other young child.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nAttend(x) ::: x attends weddings.\nGettingMarried(x) ::: x is getting married.\nHasFriendsGettingMarried(x) ::: x has friends who are getting married.\nPreteen(x) ::: x is a preteen.\nYoungChild(x) ::: x is a young child.\nCelebrateWithOthers(x) ::: x enjoys celebrating life milestone events with other people.\nFondOfLargeFunctions(x) ::: x is fond of large organized group functions.\nOutgoing(x) ::: x is outgoing.\nSpirited(x) ::: x is very spirited.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Attend(x) → (GettingMarried(x) ∨ HasFriendsGettingMarried(x))) ::: All people who attend weddings are getting married or have friends who are getting married.\n¬∃x (Preteen(x) ∨ YoungChild(x)) (GettingMarried(x) ∨ HasFriendsGettingMarried(x)) ::: No preteens and other young children are getting married or have friends who are getting married.\n∀x (CelebrateWithOthers(x) → Attend(x)) ::: If people enjoy celebrating life milestone events with other people, then they attend weddings.\n∀x (FondOfLargeFunctions(x) → CelebrateWithOthers(x)) ::: If people are fond of large organized group functions, then they enjoy celebrating life milestone events with other people.\n∀x (Outgoing(x) ∧ Spirited(x) → FondOfLargeFunctions(x)) ::: All people who are outgoing and very spirited are fond of large organized group functions.\n¬(Preteen(carol) ∨ YoungChild(carol)) ∧ Attend(carol) → ¬(GettingMarried(carol) ∨ HasFriendsGettingMarried(carol)) ::: If Carol is not both a pre-teen or other young child and attends weddings, then Carol is not getting married or has friends who are getting married.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nPreteen(carol) ∨ YoungChild(carol) ::: Carol is either a preteen or other young child.\n\"\"\""
    ]
  },
  {
    "id": 1015,
    "context": [
      "All people who attend weddings are getting married or have friends who are getting married.",
      "No preteens and other young children are getting married or have friends who are getting married.",
      "If people enjoy celebrating life milestone events with other people, then they attend weddings.",
      "If people are fond of large organized group functions, then they enjoy celebrating life milestone events with other people.",
      "All people who are outgoing and very spirited are fond of large organized group functions.",
      "If Carol is not both a pre-teen or other young child and attends weddings, then Carol is not getting married or has friends who are getting married.  "
    ],
    "question": "Carol neither enjoys celebrating life milestone events with other people nor is outgoing and very spirited.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nAttend(x) ::: x attends weddings.\nGettingMarried(x) ::: x is getting married.\nHasFriendsGettingMarried(x) ::: x has friends who are getting married.\nPreteen(x) ::: x is a preteen.\nYoungChild(x) ::: x is a young child.\nCelebrateWithOthers(x) ::: x enjoys celebrating life milestone events with other people.\nFondOfLargeFunctions(x) ::: x is fond of large organized group functions.\nOutgoing(x) ::: x is outgoing.\nSpirited(x) ::: x is very spirited.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Attend(x) → (GettingMarried(x) ∨ HasFriendsGettingMarried(x))) ::: All people who attend weddings are getting married or have friends who are getting married.\n¬∃x (Preteen(x) ∨ YoungChild(x)) → ¬(GettingMarried(x) ∨ HasFriendsGettingMarried(x)) ::: No preteens and other young children are getting married or have friends who are getting married.\n∀x (CelebrateWithOthers(x) → Attend(x)) ::: If people enjoy celebrating life milestone events with other people, then they attend weddings.\n∀x (FondOfLargeFunctions(x) → CelebrateWithOthers(x)) ::: If people are fond of large organized group functions, then they enjoy celebrating life milestone events with other people.\n∀x (Outgoing(x) ∧ Spirited(x) → FondOfLargeFunctions(x)) ::: All people who are outgoing and very spirited are fond of large organized group functions.\n¬((Preteen(carol) ∨ YoungChild(carol)) ∧ Attend(carol)) → ¬(GettingMarried(carol) ∨ HasFriendsGettingMarried(carol)) ::: If Carol is not both a pre-teen or other young child and attends weddings, then Carol is not getting married or has friends who are getting married.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬(CelebrateWithOthers(carol) ∨ (Outgoing(carol) ∧ Spirited(carol))) ::: Carol neither enjoys celebrating life milestone events with other people nor is outgoing and very spirited.\n\"\"\""
    ]
  },
  {
    "id": 1073,
    "context": [
      "All Republicans are anti-abortion.",
      "Either Republicans or Democrats. ",
      "No Democrats are conservative.",
      "Either conservative or liberal. ",
      "A U.S government official is either conservative or a Republican."
    ],
    "question": "A U.S government official is a Democrat.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nRepublican(x) ::: x is a Republican.\nAntiAbortion(x) ::: x is anti-abortion.\nDemocrat(x) ::: x is a Democrat.\nConservative(x) ::: x is conservative.\nLiberal(x) ::: x is liberal.\nUSGovernmentOfficial(x) ::: x is a U.S government official.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Republican(x) → AntiAbortion(x)) ::: All Republicans are anti-abortion.\nRepublican(x) ∨ Democrat(x) ::: Either Republicans or Democrats.\n∀x (Democrat(x) → ¬Conservative(x)) ::: No Democrats are conservative.\nConservative(x) ∨ Liberal(x) ::: Either conservative or liberal.\nUSGovernmentOfficial(x) → (Conservative(x) ∨ Republican(x)) ::: A U.S government official is either conservative or a Republican.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n∃x (USGovernmentOfficial(x) ∧ Democrat(x)) ::: A U.S government official is a Democrat.\n\"\"\""
    ]
  },
  {
    "id": 1074,
    "context": [
      "All Republicans are anti-abortion.",
      "Either Republicans or Democrats. ",
      "No Democrats are conservative.",
      "Either conservative or liberal. ",
      "A U.S government official is either conservative or a Republican."
    ],
    "question": "A U.S government official is anti-abortion and a liberal.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nRepublican(x) ::: x is a Republican.\nAntiAbortion(x) ::: x is anti-abortion.\nDemocrat(x) ::: x is a Democrat.\nConservative(x) ::: x is conservative.\nLiberal(x) ::: x is liberal.\nUSGovernmentOfficial(x) ::: x is a U.S government official.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Republican(x) → AntiAbortion(x)) ::: All Republicans are anti-abortion.\nRepublican(x) ⊕ Democrat(x) ::: Either Republicans or Democrats.\n∀x (Democrat(x) → ¬Conservative(x)) ::: No Democrats are conservative.\nConservative(x) ⊕ Liberal(x) ::: Either conservative or liberal.\nUSGovernmentOfficial(x) → (Conservative(x) ∨ Republican(x)) ::: A U.S government official is either conservative or a Republican.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nUSGovernmentOfficial(x) ∧ Liberal(x) ∧ AntiAbortion(x) ::: A U.S government official is anti-abortion and a liberal.\n\"\"\""
    ]
  },
  {
    "id": 1075,
    "context": [
      "All Republicans are anti-abortion.",
      "Either Republicans or Democrats. ",
      "No Democrats are conservative.",
      "Either conservative or liberal. ",
      "A U.S government official is either conservative or a Republican."
    ],
    "question": "A U.S government official is either anti-abortion or a liberal.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nRepublican(x) ::: x is a Republican.\nAntiAbortion(x) ::: x is anti-abortion.\nDemocrat(x) ::: x is a Democrat.\nConservative(x) ::: x is conservative.\nLiberal(x) ::: x is liberal.\nUSGovernmentOfficial(x) ::: x is a U.S government official.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Republican(x) → AntiAbortion(x)) ::: All Republicans are anti-abortion.\nRepublican(x) ∨ Democrat(x) ::: Either Republicans or Democrats.\n∀x (Democrat(x) → ¬Conservative(x)) ::: No Democrats are conservative.\nConservative(x) ∨ Liberal(x) ::: Either conservative or liberal.\nUSGovernmentOfficial(x) → (Conservative(x) ∨ Republican(x)) ::: A U.S government official is either conservative or a Republican.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nUSGovernmentOfficial(x) ∧ (AntiAbortion(x) ∨ Liberal(x)) ::: A U.S government official is either anti-abortion or a liberal.\n\"\"\""
    ]
  },
  {
    "id": 1076,
    "context": [
      "All Republicans are anti-abortion.",
      "Either Republicans or Democrats. ",
      "No Democrats are conservative.",
      "Either conservative or liberal. ",
      "A U.S government official is either conservative or a Republican."
    ],
    "question": "If a U.S government official is not anti-abortion and a Republican, then a U.S government official is neither anti-abortion nor a liberal.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nRepublican(x) ::: x is a Republican.\nAntiAbortion(x) ::: x is anti-abortion.\nDemocrat(x) ::: x is a Democrat.\nConservative(x) ::: x is conservative.\nLiberal(x) ::: x is liberal.\nUSGovernmentOfficial(x) ::: x is a U.S government official.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Republican(x) → AntiAbortion(x)) ::: All Republicans are anti-abortion.\nRepublican(x) ∨ Democrat(x) ::: Either Republicans or Democrats.\n∀x (Democrat(x) → ¬Conservative(x)) ::: No Democrats are conservative.\nConservative(x) ∨ Liberal(x) ::: Either conservative or liberal.\n∀x (USGovernmentOfficial(x) → (Conservative(x) ∨ Republican(x))) ::: A U.S government official is either conservative or a Republican.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬(AntiAbortion(x) ∧ Republican(x)) → ¬(AntiAbortion(x) ∨ Liberal(x)) ::: If a U.S government official is not anti-abortion and a Republican, then a U.S government official is neither anti-abortion nor a liberal.\n\"\"\""
    ]
  },
  {
    "id": 1077,
    "context": [
      "All Republicans are anti-abortion.",
      "Either Republicans or Democrats. ",
      "No Democrats are conservative.",
      "Either conservative or liberal. ",
      "A U.S government official is either conservative or a Republican."
    ],
    "question": "If a U.S government official is anti-abortion and a liberal, then a U.S government official is either a Republican or a liberal.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nRepublican(x) ::: x is a Republican.\nAntiAbortion(x) ::: x is anti-abortion.\nDemocrat(x) ::: x is a Democrat.\nConservative(x) ::: x is conservative.\nLiberal(x) ::: x is liberal.\nUSGovernmentOfficial(x) ::: x is a U.S government official.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Republican(x) → AntiAbortion(x)) ::: All Republicans are anti-abortion.\nRepublican(x) ∨ Democrat(x) ::: Either Republicans or Democrats.\n∀x (Democrat(x) → ¬Conservative(x)) ::: No Democrats are conservative.\nConservative(x) ∨ Liberal(x) ::: Either conservative or liberal.\n∀x (USGovernmentOfficial(x) → (Conservative(x) ∨ Republican(x))) ::: A U.S government official is either conservative or a Republican.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n(USGovernmentOfficial(x) ∧ AntiAbortion(x) ∧ Liberal(x)) → ((Republican(x) ∨ Liberal(x))) ::: If a U.S government official is anti-abortion and a liberal, then a U.S government official is either a Republican or a liberal.\n\"\"\""
    ]
  },
  {
    "id": 1078,
    "context": [
      "All Republicans are anti-abortion.",
      "Either Republicans or Democrats. ",
      "No Democrats are conservative.",
      "Either conservative or liberal. ",
      "A U.S government official is either conservative or a Republican."
    ],
    "question": "If a U.S government official is either a conservative or anti-abortion, then a U.S government official is either a conservative and a liberal or neither a conservative nor a liberal.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nRepublican(x) ::: x is a Republican.\nAntiAbortion(x) ::: x is anti-abortion.\nDemocrat(x) ::: x is a Democrat.\nConservative(x) ::: x is conservative.\nLiberal(x) ::: x is liberal.\nUSGovernmentOfficial(x) ::: x is a U.S government official.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Republican(x) → AntiAbortion(x)) ::: All Republicans are anti-abortion.\nRepublican(x) ∨ Democrat(x) ::: Either Republicans or Democrats.\n∀x (Democrat(x) → ¬Conservative(x)) ::: No Democrats are conservative.\nConservative(x) ∨ Liberal(x) ::: Either conservative or liberal.\n∀x (USGovernmentOfficial(x) → (Conservative(x) ∨ Republican(x))) ::: A U.S government official is either conservative or a Republican.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n(USGovernmentOfficial(x) ∧ (Conservative(x) ∨ AntiAbortion(x))) → ((Conservative(x) ∧ Liberal(x)) ∨ ¬(Conservative(x) ∨ Liberal(x))) ::: If a U.S government official is either a conservative or anti-abortion, then a U.S government official is either a conservative and a liberal or neither a conservative nor a liberal.\n\"\"\""
    ]
  },
  {
    "id": 1079,
    "context": [
      "All Republicans are anti-abortion.",
      "Either Republicans or Democrats. ",
      "No Democrats are conservative.",
      "Either conservative or liberal. ",
      "A U.S government official is either conservative or a Republican."
    ],
    "question": "If a U.S government official is either a conservative or anti-abortion, then a U.S government official is neither a Democrat or a liberal.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nRepublican(x) ::: x is a Republican.\nAntiAbortion(x) ::: x is anti-abortion.\nDemocrat(x) ::: x is a Democrat.\nConservative(x) ::: x is conservative.\nLiberal(x) ::: x is liberal.\nGovernmentOfficial(x) ::: x is a U.S government official.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Republican(x) → AntiAbortion(x)) ::: All Republicans are anti-abortion.\nRepublican(x) ∨ Democrat(x) ::: Either Republicans or Democrats.\n∀x (Democrat(x) → ¬Conservative(x)) ::: No Democrats are conservative.\nConservative(x) ∨ Liberal(x) ::: Either conservative or liberal.\n∀x (GovernmentOfficial(x) → (Conservative(x) ∨ Republican(x))) ::: A U.S government official is either conservative or a Republican.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n(Conservative(x) ∨ AntiAbortion(x)) → ¬(Democrat(x) ∨ Liberal(x)) ::: If a U.S government official is either a conservative or anti-abortion, then a U.S government official is neither a Democrat nor a liberal.\n\"\"\""
    ]
  },
  {
    "id": 1080,
    "context": [
      "All Republicans are anti-abortion.",
      "Either Republicans or Democrats. ",
      "No Democrats are conservative.",
      "Either conservative or liberal. ",
      "A U.S government official is either conservative or a Republican."
    ],
    "question": "If an U.S government official is anti-abortion or a liberal, then a U.S government official is either anti-abortion or a liberal.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nRepublican(x) ::: x is a Republican.\nAntiAbortion(x) ::: x is anti-abortion.\nDemocrat(x) ::: x is a Democrat.\nConservative(x) ::: x is conservative.\nLiberal(x) ::: x is liberal.\nGovernmentOfficial(x) ::: x is a U.S government official.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Republican(x) → AntiAbortion(x)) ::: All Republicans are anti-abortion.\nRepublican(x) ∨ Democrat(x) ::: Either Republicans or Democrats.\n∀x (Democrat(x) → ¬Conservative(x)) ::: No Democrats are conservative.\nConservative(x) ∨ Liberal(x) ::: Either conservative or liberal.\nGovernmentOfficial(x) → (Conservative(x) ∨ Republican(x)) ::: A U.S government official is either conservative or a Republican.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n(GovernmentOfficial(x) ∧ (AntiAbortion(x) ∨ Liberal(x))) → (AntiAbortion(x) ∨ Liberal(x)) ::: If a U.S government official is anti-abortion or a liberal, then a U.S government official is either anti-abortion or a liberal.\n\"\"\""
    ]
  },
  {
    "id": 714,
    "context": [
      "All advocates of high tariff rates are Republicans.",
      "Some Republicans are not conservatives."
    ],
    "question": "Some conservatives are advocates of high tariff rates.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nAdvocate(x) ::: x is an advocate of high tariff rates.\nRepublican(x) ::: x is a Republican.\nConservative(x) ::: x is a conservative.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Advocate(x) → Republican(x)) ::: All advocates of high tariff rates are Republicans.\n∃x (Republican(x) ∧ ¬Conservative(x)) ::: Some Republicans are not conservatives.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n∃x (Conservative(x) ∧ Advocate(x)) ::: Some conservatives are advocates of high tariff rates.\n\"\"\""
    ]
  },
  {
    "id": 886,
    "context": [
      "No athletes are slow runners. ",
      "All professional basketball players are athletes. ",
      "All NBA players are professional basketball players. ",
      "All Knicks players are NBA players. ",
      "Jim is either not a professional basketball player or not a slow runner. "
    ],
    "question": "Jim is a Knicks player.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nAthlete(x) ::: x is an athlete.\nSlowRunner(x) ::: x is a slow runner.\nBasketballPlayer(x) ::: x is a basketball player.\nProfessional(x) ::: x is a professional.\nNBAPlayer(x) ::: x is an NBA player.\nKnicksPlayer(x) ::: x is a Knicks player.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Athlete(x) → ¬SlowRunner(x)) ::: No athletes are slow runners.\n∀x (Professional(x) → Athlete(x)) ::: All professional basketball players are athletes.\n∀x (NBAPlayer(x) → Professional(x)) ::: All NBA players are professional basketball players.\n∀x (KnicksPlayer(x) → NBAPlayer(x)) ::: All Knicks players are NBA players.\n¬Professional(jim) ∨ ¬SlowRunner(jim) ::: Jim is either not a professional basketball player or not a slow runner.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nKnicksPlayer(jim) ::: Jim is a Knicks player.\n\"\"\""
    ]
  },
  {
    "id": 887,
    "context": [
      "No athletes are slow runners. ",
      "All professional basketball players are athletes. ",
      "All NBA players are professional basketball players. ",
      "All Knicks players are NBA players. ",
      "Jim is either not a professional basketball player or not a slow runner. "
    ],
    "question": "Jim is not a Knicks player.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nAthlete(x) ::: x is an athlete.\nSlowRunner(x) ::: x is a slow runner.\nBasketballPlayer(x) ::: x is a basketball player.\nProfessional(x) ::: x is a professional.\nNBAPlayer(x) ::: x is an NBA player.\nKnicksPlayer(x) ::: x is a Knicks player.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Athlete(x) → ¬SlowRunner(x)) ::: No athletes are slow runners.\n∀x (Professional(x) → Athlete(x)) ::: All professional basketball players are athletes.\n∀x (NBAPlayer(x) → Professional(x)) ::: All NBA players are professional basketball players.\n∀x (KnicksPlayer(x) → NBAPlayer(x)) ::: All Knicks players are NBA players.\n¬Professional(jim) ∨ ¬SlowRunner(jim) ::: Jim is either not a professional basketball player or not a slow runner.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬KnicksPlayer(jim) ::: Jim is not a Knicks player.\n\"\"\""
    ]
  },
  {
    "id": 888,
    "context": [
      "No athletes are slow runners. ",
      "All professional basketball players are athletes. ",
      "All NBA players are professional basketball players. ",
      "All Knicks players are NBA players. ",
      "Jim is either not a professional basketball player or not a slow runner. "
    ],
    "question": "Jim is an athlete.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nAthlete(x) ::: x is an athlete.\nSlowRunner(x) ::: x is a slow runner.\nBasketballPlayer(x) ::: x is a basketball player.\nProfessional(x) ::: x is a professional.\nNBAPlayer(x) ::: x is an NBA player.\nKnicksPlayer(x) ::: x is a Knicks player.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Athlete(x) → ¬SlowRunner(x)) ::: No athletes are slow runners.\n∀x (Professional(x) → Athlete(x)) ::: All professional basketball players are athletes.\n∀x (NBAPlayer(x) → Professional(x)) ::: All NBA players are professional basketball players.\n∀x (KnicksPlayer(x) → NBAPlayer(x)) ::: All Knicks players are NBA players.\n¬Professional(jim) ∨ ¬SlowRunner(jim) ::: Jim is either not a professional basketball player or not a slow runner.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nAthlete(jim) ::: Jim is an athlete.\n\"\"\""
    ]
  },
  {
    "id": 915,
    "context": [
      "All kids love animals.",
      "All toddlers are kids.",
      "If someone loves animals, then they are not bad.",
      "All pirates are bad.",
      "If Nancy is not a pirate, then Nancy loves animals.",
      "If Nancy is not a toddler, then Nancy is bad."
    ],
    "question": "Nancy is a pirate.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nLove(x, y) ::: x loves y.\nKid(x) ::: x is a kid.\nToddler(x) ::: x is a toddler.\nBad(x) ::: x is bad.\nPirate(x) ::: x is a pirate.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Kid(x) → Love(x, animals)) ::: All kids love animals.\n∀x (Toddler(x) → Kid(x)) ::: All toddlers are kids.\n∀x (Love(x, animals) → ¬Bad(x)) ::: If someone loves animals, then they are not bad.\n∀x (Pirate(x) → Bad(x)) ::: All pirates are bad.\n¬Pirate(nancy) → Love(nancy, animals) ::: If Nancy is not a pirate, then Nancy loves animals.\n¬Toddler(nancy) → Bad(nancy) ::: If Nancy is not a toddler, then Nancy is bad.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nPirate(nancy) ::: Nancy is a pirate.\n\"\"\""
    ]
  },
  {
    "id": 916,
    "context": [
      "All kids love animals.",
      "All toddlers are kids.",
      "If someone loves animals, then they are not bad.",
      "All pirates are bad.",
      "If Nancy is not a pirate, then Nancy loves animals.",
      "If Nancy is not a toddler, then Nancy is bad."
    ],
    "question": "Nancy is not a pirate or a toddler.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nLove(x, y) ::: x loves y.\nKid(x) ::: x is a kid.\nToddler(x) ::: x is a toddler.\nBad(x) ::: x is bad.\nPirate(x) ::: x is a pirate.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Kid(x) → Love(x, animals)) ::: All kids love animals.\n∀x (Toddler(x) → Kid(x)) ::: All toddlers are kids.\n∀x (Love(x, animals) → ¬Bad(x)) ::: If someone loves animals, then they are not bad.\n∀x (Pirate(x) → Bad(x)) ::: All pirates are bad.\n¬Pirate(nancy) → Love(nancy, animals) ::: If Nancy is not a pirate, then Nancy loves animals.\n¬Toddler(nancy) → Bad(nancy) ::: If Nancy is not a toddler, then Nancy is bad.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬Pirate(nancy) ∨ ¬Toddler(nancy) ::: Nancy is not a pirate or a toddler.\n\"\"\""
    ]
  },
  {
    "id": 917,
    "context": [
      "All kids love animals.",
      "All toddlers are kids.",
      "If someone loves animals, then they are not bad.",
      "All pirates are bad.",
      "If Nancy is not a pirate, then Nancy loves animals.",
      "If Nancy is not a toddler, then Nancy is bad."
    ],
    "question": "If Nancy is not a pirate or a toddler, then she loves animals and is a kid.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nLove(x, y) ::: x loves y.\nKid(x) ::: x is a kid.\nToddler(x) ::: x is a toddler.\nBad(x) ::: x is bad.\nPirate(x) ::: x is a pirate.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Kid(x) → Love(x, animals)) ::: All kids love animals.\n∀x (Toddler(x) → Kid(x)) ::: All toddlers are kids.\n∀x (Love(x, animals) → ¬Bad(x)) ::: If someone loves animals, then they are not bad.\n∀x (Pirate(x) → Bad(x)) ::: All pirates are bad.\n¬Pirate(nancy) → Love(nancy, animals) ::: If Nancy is not a pirate, then Nancy loves animals.\n¬Toddler(nancy) → Bad(nancy) ::: If Nancy is not a toddler, then Nancy is bad.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n(¬Pirate(nancy) ∨ ¬Toddler(nancy)) → (Love(nancy, animals) ∧ Kid(nancy)) ::: If Nancy is not a pirate or a toddler, then she loves animals and is a kid.\n\"\"\""
    ]
  },
  {
    "id": 202,
    "context": [
      "Lana Wilson directed After Tiller, The Departure, and Miss Americana.",
      "If a film is directedy by a person, the person is a filmmaker.",
      "After Tiller is a documentary.",
      "The documentary is a type of films.",
      "Lana Wilson is from Kirkland.",
      "Kirkland is a US city.",
      "If a person is from a city in a country, the person is from the country.",
      "After Tiller is nominated for the Independent Spirit Award for Best Documentary."
    ],
    "question": "Lana Wilson is a US filmmaker.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nDirectedBy(x, y) ::: x directed y.\nFilmmaker(x) ::: x is a filmmaker.\nFilm(x) ::: x is a film.\nDocumentary(x) ::: x is a documentary.\nTypeOf(x, y) ::: x is a type of y.\nFrom(x, y) ::: x is from y.\nCity(x) ::: x is a city.\nCountry(x) ::: x is a country.\nNominatedFor(x, y) ::: x is nominated for y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nDirectedBy(lanaWilson, afterTiller) ∧ DirectedBy(lanaWilson, theDeparture) ∧ DirectedBy(lanaWilson, missAmericana) ::: Lana Wilson directed After Tiller, The Departure, and Miss Americana.\n∀x (DirectedBy(x, y) → Filmmaker(x)) ::: If a film is directed by a person, the person is a filmmaker.\nDocumentary(afterTiller) ::: After Tiller is a documentary.\n∀x (Documentary(x) → TypeOf(x, film)) ::: The documentary is a type of films.\nFrom(lanaWilson, kirkland) ∧ City(kirkland) ::: Lana Wilson is from Kirkland.\nCity(kirkland) ∧ Country(us) ∧ From(lanaWilson, kirkland) → From(lanaWilson, us) ::: Kirkland is a US city.\nNominatedFor(afterTiller, independentSpiritAwardForBestDocumentary) ::: After Tiller is nominated for the Independent Spirit Award for Best Documentary.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nFilmmaker(lanaWilson) ∧ From(lanaWilson, us) ::: Lana Wilson is a US filmmaker.\n\"\"\""
    ]
  },
  {
    "id": 203,
    "context": [
      "Lana Wilson directed After Tiller, The Departure, and Miss Americana.",
      "If a film is directedy by a person, the person is a filmmaker.",
      "After Tiller is a documentary.",
      "The documentary is a type of films.",
      "Lana Wilson is from Kirkland.",
      "Kirkland is a US city.",
      "If a person is from a city in a country, the person is from the country.",
      "After Tiller is nominated for the Independent Spirit Award for Best Documentary."
    ],
    "question": "Miss Americana is not directed by a filmmaker from Kirkland.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nDirectedBy(x, y) ::: x directed y.\nFilmmaker(x) ::: x is a filmmaker.\nFilm(x) ::: x is a film.\nDocumentary(x) ::: x is a documentary.\nTypeOf(x, y) ::: x is a type of y.\nFrom(x, y) ::: x is from y.\nCity(x) ::: x is a city.\nCountry(x) ::: x is a country.\nNominatedFor(x, y) ::: x is nominated for y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nDirectedBy(lanaWilson, afterTiller) ∧ DirectedBy(lanaWilson, theDeparture) ∧ DirectedBy(lanaWilson, missAmericana) ::: Lana Wilson directed After Tiller, The Departure, and Miss Americana.\n∀x (DirectedBy(x, y) → Filmmaker(x)) ::: If a film is directed by a person, the person is a filmmaker.\nDocumentary(afterTiller) ::: After Tiller is a documentary.\n∀x (Documentary(x) → TypeOf(x, film)) ::: The documentary is a type of films.\nFrom(lanaWilson, kirkland) ::: Lana Wilson is from Kirkland.\nCity(kirkland) ∧ From(kirkland, US) ::: Kirkland is a US city.\n∀x (From(x, city) → From(x, country)) ::: If a person is from a city in a country, the person is from the country.\nNominatedFor(afterTiller, independentSpiritAwardForBestDocumentary) ::: After Tiller is nominated for the Independent Spirit Award for Best Documentary.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬DirectedBy(x, missAmericana) ∧ From(x, kirkland) ∧ Filmmaker(x) ::: Miss Americana is not directed by a filmmaker from Kirkland.\n\"\"\""
    ]
  },
  {
    "id": 204,
    "context": [
      "Lana Wilson directed After Tiller, The Departure, and Miss Americana.",
      "If a film is directedy by a person, the person is a filmmaker.",
      "After Tiller is a documentary.",
      "The documentary is a type of films.",
      "Lana Wilson is from Kirkland.",
      "Kirkland is a US city.",
      "If a person is from a city in a country, the person is from the country.",
      "After Tiller is nominated for the Independent Spirit Award for Best Documentary."
    ],
    "question": "Lana Wilson has won the Independent Spirit Award.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nDirectedBy(x, y) ::: x directed the film y.\nFilmmaker(x) ::: x is a filmmaker.\nFilm(x) ::: x is a film.\nDocumentary(x) ::: x is a documentary.\nTypeOf(x, y) ::: x is a type of y.\nFrom(x, y) ::: x is from y.\nCity(x) ::: x is a city.\nCountry(x) ::: x is a country.\nNominatedFor(x, y) ::: x is nominated for the award y.\nWon(x, y) ::: x won the award y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nDirectedBy(lanaWilson, afterTiller) ∧ DirectedBy(lanaWilson, theDeparture) ∧ DirectedBy(lanaWilson, missAmericana) ::: Lana Wilson directed After Tiller, The Departure, and Miss Americana.\n∀x (DirectedBy(x, y) → Filmmaker(x)) ::: If a film is directed by a person, the person is a filmmaker.\nDocumentary(afterTiller) ::: After Tiller is a documentary.\n∀x (Documentary(x) → TypeOf(x, film)) ::: The documentary is a type of films.\nFrom(lanaWilson, kirkland) ::: Lana Wilson is from Kirkland.\nCity(kirkland) ∧ From(kirkland, US) ::: Kirkland is a US city.\n∀x (From(x, city) → From(x, country)) ::: If a person is from a city in a country, the person is from the country.\nNominatedFor(afterTiller, independentSpiritAwardForBestDocumentary) ::: After Tiller is nominated for the Independent Spirit Award for Best Documentary.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n∃x (Won(lanaWilson, independentSpiritAwardForBestDocumentary)) ::: Lana Wilson has won the Independent Spirit Award."
    ]
  },
  {
    "id": 730,
    "context": [
      "All bears in zoos are not wild. ",
      "Some bears are in zoos. "
    ],
    "question": "Not all bears are wild.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nBear(x) ::: x is a bear.\nZoo(x) ::: x is in a zoo.\nWild(x) ::: x is wild.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Bear(x) ∧ Zoo(x) → ¬Wild(x)) ::: All bears in zoos are not wild.\n∃x (Bear(x) ∧ Zoo(x)) ::: Some bears are in zoos.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n∃x (Bear(x) ∧ Wild(x)) ::: Not all bears are wild.\n\"\"\""
    ]
  },
  {
    "id": 166,
    "context": [
      "If a person is the leader of a country for life, that person is in a monarchy. ",
      "Leaders are either a king or a queen.",
      "Queens are female.",
      "Kings are male. ",
      "Elizabeth is a queen.",
      "Elizabeth is a leader"
    ],
    "question": "Elizabeth is a king.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nLeader(x) ::: x is a leader.\nMonarchy(x) ::: x is in a monarchy.\nKing(x) ::: x is a king.\nQueen(x) ::: x is a queen.\nFemale(x) ::: x is female.\nMale(x) ::: x is male.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Leader(x) ∧ CountryForLife(x) → Monarchy(x)) ::: If a person is the leader of a country for life, that person is in a monarchy.\n∀x (Leader(x) → King(x) ∨ Queen(x)) ::: Leaders are either a king or a queen.\n∀x (Queen(x) → Female(x)) ::: Queens are female.\n∀x (King(x) → Male(x)) ::: Kings are male.\nQueen(elizabeth) ::: Elizabeth is a queen.\nLeader(elizabeth) ::: Elizabeth is a leader.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬King(elizabeth) ::: Elizabeth is a king.\n\"\"\""
    ]
  },
  {
    "id": 167,
    "context": [
      "If a person is the leader of a country for life, that person is in a monarchy. ",
      "Leaders are either a king or a queen.",
      "Queens are female.",
      "Kings are male. ",
      "Elizabeth is a queen.",
      "Elizabeth is a leader"
    ],
    "question": "Elizabeth is in a monarchy.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nLeader(x) ::: x is a leader.\nMonarchy(x) ::: x is in a monarchy.\nKing(x) ::: x is a king.\nQueen(x) ::: x is a queen.\nFemale(x) ::: x is female.\nMale(x) ::: x is male.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Leader(x) ∧ CountryForLife(x) → Monarchy(x)) ::: If a person is the leader of a country for life, that person is in a monarchy.\n∀x (Leader(x) → King(x) ∨ Queen(x)) ::: Leaders are either a king or a queen.\n∀x (Queen(x) → Female(x)) ::: Queens are female.\n∀x (King(x) → Male(x)) ::: Kings are male.\nQueen(elizabeth) ::: Elizabeth is a queen.\nLeader(elizabeth) ::: Elizabeth is a leader.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nMonarchy(elizabeth) ::: Elizabeth is in a monarchy.\n\"\"\""
    ]
  },
  {
    "id": 168,
    "context": [
      "If a person is the leader of a country for life, that person is in a monarchy. ",
      "Leaders are either a king or a queen.",
      "Queens are female.",
      "Kings are male. ",
      "Elizabeth is a queen.",
      "Elizabeth is a leader"
    ],
    "question": "Elizabeth is a leader of a country.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nLeader(x) ::: x is a leader.\nCountry(x) ::: x is a country.\nMonarchy(x) ::: x is in a monarchy.\nKing(x) ::: x is a king.\nQueen(x) ::: x is a queen.\nFemale(x) ::: x is female.\nMale(x) ::: x is male.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Leader(x) ∧ Country(x) → Monarchy(x)) ::: If a person is the leader of a country for life, that person is in a monarchy.\n∀x (Leader(x) → King(x) ∨ Queen(x)) ::: Leaders are either a king or a queen.\n∀x (Queen(x) → Female(x)) ::: Queens are female.\n∀x (King(x) → Male(x)) ::: Kings are male.\nQueen(elizabeth) ::: Elizabeth is a queen.\nLeader(elizabeth) ::: Elizabeth is a leader.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nLeader(elizabeth) ::: Elizabeth is a leader of a country.\n\"\"\""
    ]
  },
  {
    "id": 981,
    "context": [
      "If people make their own matcha teas every morning with ceremonial-grade matcha powder, then they do not wake up late and start their schedules past noon regularly.",
      "If people live in California and attend yoga classes regularly, then they make their own matcha teas every morning with ceremonial-grade matcha powder.",
      "If people work in the entertainment industry as high-profile celebrities, then they wake up late and start their schedules past noon regularly.",
      "If people do not have regular 9-5 jobs, then they work in the entertainment industry as high-profile celebrities.",
      "All people who prefer working at home over going to the office every day do not have regular 9-5 jobs.",
      "Clay either both prefers to work at home over going to the office every day and makes his own matcha teas every morning with ceremonial-grade matcha powder, or he neither prefers to work at home over going to the office every day nor makes his own matcha teas every morning with ceremonial-grade matcha powder."
    ],
    "question": "Clay does not have a regular 9-5 job.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nMakeTea(x) ::: x makes their own matcha teas every morning with ceremonial-grade matcha powder.\nWakeUpLate(x) ::: x wakes up late and starts their schedules past noon regularly.\nLiveInCalifornia(x) ::: x lives in California.\nAttendYoga(x) ::: x attends yoga classes regularly.\nWorkInEntertainment(x) ::: x works in the entertainment industry as high-profile celebrities.\nHaveJob(x) ::: x has a regular 9-5 job.\nPreferWorkAtHome(x) ::: x prefers working at home over going to the office every day.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (MakeTea(x) → ¬WakeUpLate(x)) ::: If people make their own matcha teas every morning with ceremonial-grade matcha powder, then they do not wake up late and start their schedules past noon regularly.\n∀x ((LiveInCalifornia(x) ∧ AttendYoga(x)) → MakeTea(x)) ::: If people live in California and attend yoga classes regularly, then they make their own matcha teas every morning with ceremonial-grade matcha powder.\n∀x (WorkInEntertainment(x) → WakeUpLate(x)) ::: If people work in the entertainment industry as high-profile celebrities, then they wake up late and start their schedules past noon regularly.\n∀x (¬HaveJob(x) → WorkInEntertainment(x)) ::: If people do not have regular 9-5 jobs, then they work in the entertainment industry as high-profile celebrities.\n∀x (PreferWorkAtHome(x) → ¬HaveJob(x)) ::: All people who prefer working at home over going to the office every day do not have regular 9-5 jobs.\n(PreferWorkAtHome(clay) ∧ MakeTea(clay)) ⊕ ¬(PreferWorkAtHome(clay) ∨ MakeTea(clay)) ::: Clay either both prefers to work at home over going to the office every day and makes his own matcha teas every morning with ceremonial-grade matcha powder, or he neither prefers to work at home over going to the office every day nor makes his own matcha teas every morning with ceremonial-grade matcha powder.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬HaveJob(clay) ::: Clay does not have a regular 9-5 job.\n\"\"\""
    ]
  },
  {
    "id": 982,
    "context": [
      "If people make their own matcha teas every morning with ceremonial-grade matcha powder, then they do not wake up late and start their schedules past noon regularly.",
      "If people live in California and attend yoga classes regularly, then they make their own matcha teas every morning with ceremonial-grade matcha powder.",
      "If people work in the entertainment industry as high-profile celebrities, then they wake up late and start their schedules past noon regularly.",
      "If people do not have regular 9-5 jobs, then they work in the entertainment industry as high-profile celebrities.",
      "All people who prefer working at home over going to the office every day do not have regular 9-5 jobs.",
      "Clay either both prefers to work at home over going to the office every day and makes his own matcha teas every morning with ceremonial-grade matcha powder, or he neither prefers to work at home over going to the office every day nor makes his own matcha teas every morning with ceremonial-grade matcha powder."
    ],
    "question": "Clay lives in California and attends yoga classes regularly.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nMakeMatcha(x) ::: x makes their own matcha teas every morning with ceremonial-grade matcha powder.\nWakeUpLate(x) ::: x wakes up late and starts their schedules past noon regularly.\nLiveInCalifornia(x) ::: x lives in California.\nAttendYoga(x) ::: x attends yoga classes regularly.\nWorkInEntertainment(x) ::: x works in the entertainment industry as high-profile celebrities.\nHave9To5Job(x) ::: x has a regular 9-5 job.\nPreferWorkAtHome(x) ::: x prefers working at home over going to the office every day.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (MakeMatcha(x) → ¬WakeUpLate(x)) ::: If people make their own matcha teas every morning with ceremonial-grade matcha powder, then they do not wake up late and start their schedules past noon regularly.\n∀x ((LiveInCalifornia(x) ∧ AttendYoga(x)) → MakeMatcha(x)) ::: If people live in California and attend yoga classes regularly, then they make their own matcha teas every morning with ceremonial-grade matcha powder.\n∀x (WorkInEntertainment(x) → WakeUpLate(x)) ::: If people work in the entertainment industry as high-profile celebrities, then they wake up late and start their schedules past noon regularly.\n∀x (¬Have9To5Job(x) → WorkInEntertainment(x)) ::: If people do not have regular 9-5 jobs, then they work in the entertainment industry as high-profile celebrities.\n∀x (PreferWorkAtHome(x) → ¬Have9To5Job(x)) ::: All people who prefer working at home over going to the office every day do not have regular 9-5 jobs.\n(PreferWorkAtHome(clay) ∧ MakeMatcha(clay)) ⊕ ¬(PreferWorkAtHome(clay) ∨ MakeMatcha(clay)) ::: Clay either both prefers to work at home over going to the office every day and makes his own matcha teas every morning with ceremonial-grade matcha powder, or he neither prefers to work at home over going to the office every day nor makes his own matcha teas every morning with ceremonial-grade matcha powder.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nLiveInCalifornia(clay) ∧ AttendYoga(clay) ::: Clay lives in California and attends yoga classes regularly.\n\"\"\""
    ]
  },
  {
    "id": 983,
    "context": [
      "If people make their own matcha teas every morning with ceremonial-grade matcha powder, then they do not wake up late and start their schedules past noon regularly.",
      "If people live in California and attend yoga classes regularly, then they make their own matcha teas every morning with ceremonial-grade matcha powder.",
      "If people work in the entertainment industry as high-profile celebrities, then they wake up late and start their schedules past noon regularly.",
      "If people do not have regular 9-5 jobs, then they work in the entertainment industry as high-profile celebrities.",
      "All people who prefer working at home over going to the office every day do not have regular 9-5 jobs.",
      "Clay either both prefers to work at home over going to the office every day and makes his own matcha teas every morning with ceremonial-grade matcha powder, or he neither prefers to work at home over going to the office every day nor makes his own matcha teas every morning with ceremonial-grade matcha powder."
    ],
    "question": "Clay neither prefers working at home over going to the office every day nor lives in California and attends yoga classes regularly.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nMakeTea(x) ::: x makes their own matcha teas every morning with ceremonial-grade matcha powder.\nWakeUpLate(x) ::: x wakes up late and starts their schedules past noon regularly.\nLiveInCalifornia(x) ::: x lives in California.\nAttendYoga(x) ::: x attends yoga classes regularly.\nWorkInEntertainment(x) ::: x works in the entertainment industry as high-profile celebrities.\nHaveJob(x) ::: x has a regular 9-5 job.\nPreferWorkAtHome(x) ::: x prefers working at home over going to the office every day.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (MakeTea(x) → ¬WakeUpLate(x)) ::: If people make their own matcha teas every morning with ceremonial-grade matcha powder, then they do not wake up late and start their schedules past noon regularly.\n∀x ((LiveInCalifornia(x) ∧ AttendYoga(x)) → MakeTea(x)) ::: If people live in California and attend yoga classes regularly, then they make their own matcha teas every morning with ceremonial-grade matcha powder.\n∀x (WorkInEntertainment(x) → WakeUpLate(x)) ::: If people work in the entertainment industry as high-profile celebrities, then they wake up late and start their schedules past noon regularly.\n∀x (¬HaveJob(x) → WorkInEntertainment(x)) ::: If people do not have regular 9-5 jobs, then they work in the entertainment industry as high-profile celebrities.\n∀x (PreferWorkAtHome(x) → ¬HaveJob(x)) ::: All people who prefer working at home over going to the office every day do not have regular 9-5 jobs.\n(PreferWorkAtHome(clay) ∧ MakeTea(clay)) ⊕ ¬(PreferWorkAtHome(clay) ∨ MakeTea(clay)) ::: Clay either both prefers to work at home over going to the office every day and makes his own matcha teas every morning with ceremonial-grade matcha powder, or he neither prefers to work at home over going to the office every day nor makes his own matcha teas every morning with ceremonial-grade matcha powder.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬(PreferWorkAtHome(clay) ∨ (LiveInCalifornia(clay) ∧ AttendYoga(clay))) ::: Clay neither prefers working at home over going to the office every day nor lives in California and attends yoga classes regularly.\n\"\"\""
    ]
  },
  {
    "id": 54,
    "context": [
      "Thomas Barber was an English professional footballer.",
      "Thomas Barber played in the Football League for Aston Villa.",
      "Thomas Barber played as a half back and inside left.",
      "Thomas Barber scored the winning goal in the 1913 FA Cup Final."
    ],
    "question": "Thomas Barber played in the Football League for Bolton Wanderers",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nEnglish(x) ::: x is an English person.\nFootballer(x) ::: x is a professional footballer.\nPlayedInLeague(x, y) ::: x played in the Football League for y.\nPlayedPosition(x, y) ::: x played as position y.\nScoredGoal(x, y) ::: x scored the winning goal in the year y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nEnglish(thomas) ∧ Footballer(thomas) ::: Thomas Barber was an English professional footballer.\nPlayedInLeague(thomas, astonVilla) ::: Thomas Barber played in the Football League for Aston Villa.\nPlayedPosition(thomas, halfBack) ∧ PlayedPosition(thomas, insideLeft) ::: Thomas Barber played as a half back and inside left.\nScoredGoal(thomas, 1913) ::: Thomas Barber scored the winning goal in the 1913 FA Cup Final.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nPlayedInLeague(thomas, boltonWanderers) ::: Thomas Barber played in the Football League for Bolton Wanderers.\n\"\"\""
    ]
  },
  {
    "id": 55,
    "context": [
      "Thomas Barber was an English professional footballer.",
      "Thomas Barber played in the Football League for Aston Villa.",
      "Thomas Barber played as a half back and inside left.",
      "Thomas Barber scored the winning goal in the 1913 FA Cup Final."
    ],
    "question": "Thomas Barber played as an inside left.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nEnglish(x) ::: x is English.\nFootballer(x) ::: x is a professional footballer.\nPlayedInLeague(x, y) ::: x played in the Football League for y.\nPlayedPosition(x, y) ::: x played as position y.\nScoredGoal(x, y) ::: x scored the winning goal in the year y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nEnglish(thomas) ∧ Footballer(thomas) ::: Thomas Barber was an English professional footballer.\nPlayedInLeague(thomas, AstonVilla) ::: Thomas Barber played in the Football League for Aston Villa.\nPlayedPosition(thomas, halfback) ∧ PlayedPosition(thomas, insideleft) ::: Thomas Barber played as a half back and inside left.\nScoredGoal(thomas, 1913) ::: Thomas Barber scored the winning goal in the 1913 FA Cup Final.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nPlayedPosition(thomas, insideleft) ::: Thomas Barber played as an inside left.\n\"\"\""
    ]
  },
  {
    "id": 56,
    "context": [
      "Thomas Barber was an English professional footballer.",
      "Thomas Barber played in the Football League for Aston Villa.",
      "Thomas Barber played as a half back and inside left.",
      "Thomas Barber scored the winning goal in the 1913 FA Cup Final."
    ],
    "question": "An English professional footballer scored the winning goal in the 1913 FA Cup Final.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nEnglish(x) ::: x is English.\nFootballer(x) ::: x is a professional footballer.\nPlayedInLeague(x, y) ::: x played in the Football League for y.\nPlayedPosition(x, y) ::: x played as position y.\nScoredGoal(x, y) ::: x scored the winning goal in the year y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nEnglish(thomas) ∧ Footballer(thomas) ::: Thomas Barber was an English professional footballer.\nPlayedInLeague(thomas, astonVilla) ::: Thomas Barber played in the Football League for Aston Villa.\nPlayedPosition(thomas, halfBack) ∧ PlayedPosition(thomas, insideLeft) ::: Thomas Barber played as a half back and inside left.\nScoredGoal(thomas, 1913) ::: Thomas Barber scored the winning goal in the 1913 FA Cup Final.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n∃x (English(x) ∧ Footballer(x) ∧ ScoredGoal(x, 1913)) ::: An English professional footballer scored the winning goal in the 1913 FA Cup Final.\n\"\"\""
    ]
  },
  {
    "id": 467,
    "context": [
      "If people play the instrument in the concert, then he is good at playing this kind of instrument.",
      "Peter plays piano, violin, and saxophone.",
      "Peter was invited to play piano at the concert hall.",
      "Oliver and Peter were both invited to perform in the concert.",
      "Oliver plays a different musical instrument from Peter in the concert."
    ],
    "question": "Oliver plays piano in the concert.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nPlay(x, y) ::: x plays the musical instrument y.\nGoodAtPlaying(x, y) ::: x is good at playing the musical instrument y.\nInvited(x, y) ::: x was invited to perform at the concert y.\nPerform(x, y) ::: x performs in the concert y.\nDifferentInstrument(x, y) ::: x plays a different musical instrument from y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Play(x, y) → GoodAtPlaying(x, y)) ::: If people play the instrument in the concert, then he is good at playing this kind of instrument.\nPlay(peter, piano) ∧ Play(peter, violin) ∧ Play(peter, saxophone) ::: Peter plays piano, violin, and saxophone.\nInvited(peter, concertHall) ∧ Perform(peter, piano) ::: Peter was invited to play piano at the concert hall.\nInvited(oliver, concert) ∧ Perform(oliver, instrument) ∧ DifferentInstrument(oliver, peter) ::: Oliver and Peter were both invited to perform in the concert. Oliver plays a different musical instrument from Peter in the concert.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nPlay(oliver, piano) ::: Oliver plays piano in the concert.\n\"\"\""
    ]
  },
  {
    "id": 468,
    "context": [
      "If people play the instrument in the concert, then he is good at playing this kind of instrument.",
      "Peter plays piano, violin, and saxophone.",
      "Peter was invited to play piano at the concert hall.",
      "Oliver and Peter were both invited to perform in the concert.",
      "Oliver plays a different musical instrument from Peter in the concert."
    ],
    "question": "Oliver plays violin in the concert.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nPlay(x, y) ::: x plays the musical instrument y.\nGoodAtPlaying(x, y) ::: x is good at playing the musical instrument y.\nInvited(x, y) ::: x was invited to perform at the concert y.\nPerform(x, y) ::: x performs in the concert y.\nDifferentInstrument(x, y) ::: x plays a different musical instrument from y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Play(x, y) → GoodAtPlaying(x, y)) ::: If people play the instrument in the concert, then he is good at playing this kind of instrument.\nPlay(peter, piano) ∧ Play(peter, violin) ∧ Play(peter, saxophone) ::: Peter plays piano, violin, and saxophone.\nInvited(peter, concertHall) ∧ Play(peter, piano) ::: Peter was invited to play piano at the concert hall.\nInvited(oliver, concert) ∧ Perform(oliver, concert) ∧ Perform(peter, concert) ::: Oliver and Peter were both invited to perform in the concert.\nPlay(oliver, instrument) ∧ Play(peter, instrument) ∧ DifferentInstrument(oliver, peter) ∧ Perform(oliver, concert) ::: Oliver plays a different musical instrument from Peter in the concert.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nPlay(oliver, violin) ::: Oliver plays violin in the concert.\n\"\"\""
    ]
  },
  {
    "id": 469,
    "context": [
      "If people play the instrument in the concert, then he is good at playing this kind of instrument.",
      "Peter plays piano, violin, and saxophone.",
      "Peter was invited to play piano at the concert hall.",
      "Oliver and Peter were both invited to perform in the concert.",
      "Oliver plays a different musical instrument from Peter in the concert."
    ],
    "question": "Peter is good at playing piano.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nPlay(x, y) ::: x plays the musical instrument y.\nGoodAtPlaying(x, y) ::: x is good at playing the musical instrument y.\nInvited(x, y) ::: x was invited to perform at the concert y.\nPerform(x, y) ::: x performs in the concert y.\nDifferentInstrument(x, y) ::: x plays a different musical instrument from y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x,y (Play(x, y) ∧ Perform(y, concert) → GoodAtPlaying(x, y)) ::: If people play the instrument in the concert, then he is good at playing this kind of instrument.\nPlay(peter, piano) ∧ Play(peter, violin) ∧ Play(peter, saxophone) ::: Peter plays piano, violin, and saxophone.\nInvited(peter, concertHall) ∧ Perform(peter, concertHall) ::: Peter was invited to play piano at the concert hall.\nInvited(oliver, concert) ∧ Perform(oliver, concert) ∧ DifferentInstrument(oliver, peter) ::: Oliver and Peter were both invited to perform in the concert. Oliver plays a different musical instrument from Peter in the concert.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nGoodAtPlaying(peter, piano) ::: Peter is good at playing piano.\n\"\"\""
    ]
  },
  {
    "id": 1312,
    "context": [
      "If something can go underwater, then it enjoys water.",
      "All animals that can swim can go underwater.",
      "Either an animal can swim or it can walk.",
      "Animals that can walk travel on land.",
      "Animals that enjoy water splash water around.",
      "Every animal that travels on land enjoys basking in the sun.",
      "George splashes water around and can swim.",
      "Liam is either an animal that can walk and enjoys water, or is neither an animal that can walk nor enjoys water."
    ],
    "question": "George enjoys basking in the sun.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nGoUnderwater(x) ::: x can go underwater.\nEnjoyWater(x) ::: x enjoys water.\nSwim(x) ::: x can swim.\nWalk(x) ::: x can walk.\nTravelOnLand(x) ::: x travels on land.\nSplashWater(x) ::: x splashes water around.\nBaskSun(x) ::: x enjoys basking in the sun.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (GoUnderwater(x) → EnjoyWater(x)) ::: If something can go underwater, then it enjoys water.\n∀x (Swim(x) → GoUnderwater(x)) ::: All animals that can swim can go underwater.\n∀x (Swim(x) ⊕ Walk(x)) ::: Either an animal can swim or it can walk.\n∀x (Walk(x) → TravelOnLand(x)) ::: Animals that can walk travel on land.\n∀x (EnjoyWater(x) → SplashWater(x)) ::: Animals that enjoy water splash water around.\n∀x (TravelOnLand(x) → BaskSun(x)) ::: Every animal that travels on land enjoys basking in the sun.\nSplashWater(george) ∧ Swim(george) ::: George splashes water around and can swim.\n(Walk(liam) ∧ EnjoyWater(liam)) ⊕ ¬(Walk(liam) ∨ EnjoyWater(liam)) ::: Liam is either an animal that can walk and enjoys water, or is neither an animal that can walk nor enjoys water.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nBaskSun(george) ::: George enjoys basking in the sun.\n\"\"\""
    ]
  },
  {
    "id": 1313,
    "context": [
      "If something can go underwater, then it enjoys water.",
      "All animals that can swim can go underwater.",
      "Either an animal can swim or it can walk.",
      "Animals that can walk travel on land.",
      "Animals that enjoy water splash water around.",
      "Every animal that travels on land enjoys basking in the sun.",
      "George splashes water around and can swim.",
      "Liam is either an animal that can walk and enjoys water, or is neither an animal that can walk nor enjoys water."
    ],
    "question": "Liam enjoys basking in the sun and splashing water around.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nGoUnderwater(x) ::: x can go underwater.\nEnjoyWater(x) ::: x enjoys water.\nAnimal(x) ::: x is an animal.\nSwim(x) ::: x can swim.\nWalk(x) ::: x can walk.\nTravelOnLand(x) ::: x travels on land.\nSplashWater(x) ::: x splashes water around.\nBaskSun(x) ::: x enjoys basking in the sun.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (GoUnderwater(x) → EnjoyWater(x)) ::: If something can go underwater, then it enjoys water.\n∀x (Animal(x) ∧ Swim(x) → GoUnderwater(x)) ::: All animals that can swim can go underwater.\n∀x (Swim(x) ∨ Walk(x)) ::: Either an animal can swim or it can walk.\n∀x (Walk(x) → TravelOnLand(x)) ::: Animals that can walk travel on land.\n∀x (EnjoyWater(x) → SplashWater(x)) ::: Animals that enjoy water splash water around.\n∀x (TravelOnLand(x) → BaskSun(x)) ::: Every animal that travels on land enjoys basking in the sun.\nSplashWater(george) ∧ Swim(george) ::: George splashes water around and can swim.\n(Walk(liam) ∧ EnjoyWater(liam)) ⊕ ¬(Walk(liam) ∨ EnjoyWater(liam)) ::: Liam is either an animal that can walk and enjoys water, or is neither an animal that can walk nor enjoys water.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nBaskSun(liam) ∧ SplashWater(liam) ::: Liam enjoys basking in the sun and splashing water around.\n\"\"\""
    ]
  },
  {
    "id": 1314,
    "context": [
      "If something can go underwater, then it enjoys water.",
      "All animals that can swim can go underwater.",
      "Either an animal can swim or it can walk.",
      "Animals that can walk travel on land.",
      "Animals that enjoy water splash water around.",
      "Every animal that travels on land enjoys basking in the sun.",
      "George splashes water around and can swim.",
      "Liam is either an animal that can walk and enjoys water, or is neither an animal that can walk nor enjoys water."
    ],
    "question": "Liam neither enjoys basking in the sun nor splashing water around.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nGoUnderwater(x) ::: x can go underwater.\nEnjoyWater(x) ::: x enjoys water.\nSwim(x) ::: x can swim.\nWalk(x) ::: x can walk.\nTravelOnLand(x) ::: x travels on land.\nSplashWater(x) ::: x splashes water around.\nBaskSun(x) ::: x enjoys basking in the sun.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (GoUnderwater(x) → EnjoyWater(x)) ::: If something can go underwater, then it enjoys water.\n∀x (Swim(x) → GoUnderwater(x)) ::: All animals that can swim can go underwater.\n∀x (Swim(x) ⊕ Walk(x)) ::: Either an animal can swim or it can walk.\n∀x (Walk(x) → TravelOnLand(x)) ::: Animals that can walk travel on land.\n∀x (EnjoyWater(x) → SplashWater(x)) ::: Animals that enjoy water splash water around.\n∀x (TravelOnLand(x) → BaskSun(x)) ::: Every animal that travels on land enjoys basking in the sun.\nSplashWater(George) ∧ Swim(George) ::: George splashes water around and can swim.\n(Walk(liam) ∧ EnjoyWater(liam)) ⊕ ¬(Walk(liam) ∨ EnjoyWater(liam)) ::: Liam is either an animal that can walk and enjoys water, or is neither an animal that can walk nor enjoys water.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬(BaskSun(liam) ∨ SplashWater(liam)) ::: Liam neither enjoys basking in the sun nor splashing water around.\n\"\"\""
    ]
  },
  {
    "id": 673,
    "context": [
      "Cancer biology is finding genetic alterations that confer selective advantage to cancer cells. ",
      "Cancer researchers have frequently ranked the importance of substitutions to cancer growth by P value.",
      "P values are thresholds for belief, not metrics of effect. "
    ],
    "question": "Cancer researchers tend to use the cancer effect size to determine the relative importance of the genetic alterations that confer selective advantage to cancer cells.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nFind(x, y) ::: x is finding genetic alterations that confer selective advantage to cancer cells.\nRank(x, y, z) ::: x ranks the importance of y to cancer growth by z.\nUse(x, y, z) ::: x uses y to determine the relative importance of z.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nFind(CancerBiology, GeneticAlterations) ::: Cancer biology is finding genetic alterations that confer selective advantage to cancer cells.\nRank(CancerResearchers, Substitutions, PValue) ::: Cancer researchers have frequently ranked the importance of substitutions to cancer growth by P value.\n∀x (Rank(CancerResearchers, y, PValue) → ¬Metrics(y)) ::: P values are thresholds for belief, not metrics of effect.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nUse(CancerResearchers, CancerEffectSize, GeneticAlterations) ::: Cancer researchers tend to use the cancer effect size to determine the relative importance of the genetic alterations that confer selective advantage to cancer cells.\n\"\"\""
    ]
  },
  {
    "id": 674,
    "context": [
      "Cancer biology is finding genetic alterations that confer selective advantage to cancer cells. ",
      "Cancer researchers have frequently ranked the importance of substitutions to cancer growth by P value.",
      "P values are thresholds for belief, not metrics of effect. "
    ],
    "question": "P value represents the selection intensity for somatic variants in cancer cell lineages.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nFind(x, y) ::: x is finding y.\nGeneticAlteration(x, y) ::: x is a genetic alteration that confers selective advantage to cancer cells.\nRank(x, y, z) ::: x ranks the importance of y to z.\nSubstitution(x, y) ::: x is a substitution to y.\nGrowth(x) ::: x is cancer growth.\nPValue(x) ::: x is a P value.\nBelief(x) ::: x is a threshold for belief.\nMetric(x) ::: x is a metric of effect.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nFind(CancerBiology, GeneticAlteration) ::: Cancer biology is finding genetic alterations that confer selective advantage to cancer cells.\n∀x (CancerResearchers(x) → Rank(x, Substitution, Growth)) ::: Cancer researchers have frequently ranked the importance of substitutions to cancer growth by P value.\n∀x (PValue(x) → ¬Metric(x)) ::: P values are thresholds for belief, not metrics of effect.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nPValue(selectionIntensity) ::: P value represents the selection intensity for somatic variants in cancer cell lineages.\n\"\"\""
    ]
  },
  {
    "id": 675,
    "context": [
      "Cancer biology is finding genetic alterations that confer selective advantage to cancer cells. ",
      "Cancer researchers have frequently ranked the importance of substitutions to cancer growth by P value.",
      "P values are thresholds for belief, not metrics of effect. "
    ],
    "question": "Cancer effect size is a metric that is preferred by the majority of cancer researchers.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nFind(x, y) ::: x is finding y.\nGeneticAlterations(x, y) ::: x is genetic alterations that confer selective advantage to cancer cells.\nRank(x, y, z) ::: x ranks the importance of y to z.\nSubstitutions(x, y) ::: x is substitutions to y.\nCancer(x) ::: x is cancer.\nResearcher(x) ::: x is a cancer researcher.\nPValue(x) ::: x is a P value.\nBelief(x) ::: x is a threshold for belief.\nMetric(x) ::: x is a metric of effect.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (CancerBiology(x) → ∃y (GeneticAlterations(x, y))) ::: Cancer biology is finding genetic alterations that confer selective advantage to cancer cells.\n∀x (Researcher(x) ∧ Cancer(x) → ∃y (Rank(x, Substitutions(cancer, y), cancer growth))) ::: Cancer researchers have frequently ranked the importance of substitutions to cancer growth by P value.\n∀x (PValue(x) → Belief(x) ∧ ¬Metric(x)) ::: P values are thresholds for belief, not metrics of effect.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n∃x (Researcher(x) ∧ Cancer(x) ∧ Metric(effectSize) ∧ Prefer(x, effectSize)) ::: Cancer effect size is a metric that is preferred by the majority of cancer researchers.\n\"\"\""
    ]
  },
  {
    "id": 676,
    "context": [
      "Cancer biology is finding genetic alterations that confer selective advantage to cancer cells. ",
      "Cancer researchers have frequently ranked the importance of substitutions to cancer growth by P value.",
      "P values are thresholds for belief, not metrics of effect. "
    ],
    "question": "P value doesn't represent metrics of effect.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nFind(x, y) ::: x is finding y.\nGeneticAlterations(x, y) ::: x is genetic alterations that confer selective advantage to cancer cells.\nRank(x, y, z) ::: x ranks the importance of y to z.\nSubstitutions(x, y) ::: x is substitutions to y.\nCancerGrowth(x) ::: x is cancer growth.\nPValue(x) ::: x is a P value.\nBeliefThreshold(x) ::: x is a threshold for belief.\nEffectMetric(x) ::: x is a metric of effect.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nFind(CancerBiology, GeneticAlterations) ::: Cancer biology is finding genetic alterations that confer selective advantage to cancer cells.\n∀x (CancerResearchers(x) → Rank(x, Substitutions, CancerGrowth)) ::: Cancer researchers have frequently ranked the importance of substitutions to cancer growth by P value.\n∀x (PValue(x) → ¬EffectMetric(x)) ::: P values are thresholds for belief, not metrics of effect.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬EffectMetric(PValue) ::: P value doesn't represent metrics of effect.\n\"\"\""
    ]
  },
  {
    "id": 1407,
    "context": [
      "All dispensable things are environment-friendly. ",
      "All woodware is dispensable.",
      "All paper is woodware. ",
      "No good things are bad. ",
      "All environment-friendly things are good.",
      "A worksheet is either paper or is environment-friendly."
    ],
    "question": "A worksheet is dispensable.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nDispensable(x) ::: x is dispensable.\nEnvironmentFriendly(x) ::: x is environment-friendly.\nWoodware(x) ::: x is woodware.\nPaper(x) ::: x is paper.\nGood(x) ::: x is good.\nBad(x) ::: x is bad.\nWorksheet(x) ::: x is a worksheet.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Dispensable(x) → EnvironmentFriendly(x)) ::: All dispensable things are environment-friendly.\n∀x (Woodware(x) → Dispensable(x)) ::: All woodware is dispensable.\n∀x (Paper(x) → Woodware(x)) ::: All paper is woodware.\n∀x (Good(x) → ¬Bad(x)) ::: No good things are bad.\n∀x (EnvironmentFriendly(x) → Good(x)) ::: All environment-friendly things are good.\n(Paper(worksheet) ∨ EnvironmentFriendly(worksheet)) ::: A worksheet is either paper or is environment-friendly.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nDispensable(worksheet) ::: A worksheet is dispensable.\n\"\"\""
    ]
  },
  {
    "id": 1408,
    "context": [
      "All dispensable things are environment-friendly. ",
      "All woodware is dispensable.",
      "All paper is woodware. ",
      "No good things are bad. ",
      "All environment-friendly things are good.",
      "A worksheet is either paper or is environment-friendly."
    ],
    "question": "A worksheet is not dispensable.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nDispensable(x) ::: x is dispensable.\nEnvironmentFriendly(x) ::: x is environment-friendly.\nWoodware(x) ::: x is woodware.\nPaper(x) ::: x is paper.\nGood(x) ::: x is good.\nBad(x) ::: x is bad.\nWorksheet(x) ::: x is a worksheet.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Dispensable(x) → EnvironmentFriendly(x)) ::: All dispensable things are environment-friendly.\n∀x (Woodware(x) → Dispensable(x)) ::: All woodware is dispensable.\n∀x (Paper(x) → Woodware(x)) ::: All paper is woodware.\n∀x (Good(x) → ¬Bad(x)) ::: No good things are bad.\n∀x (EnvironmentFriendly(x) → Good(x)) ::: All environment-friendly things are good.\nWorksheet(x) ↔ (Paper(x) ∨ EnvironmentFriendly(x)) ::: A worksheet is either paper or is environment-friendly.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬Dispensable(worksheet) ::: A worksheet is not dispensable.\n\"\"\""
    ]
  },
  {
    "id": 1409,
    "context": [
      "All dispensable things are environment-friendly. ",
      "All woodware is dispensable.",
      "All paper is woodware. ",
      "No good things are bad. ",
      "All environment-friendly things are good.",
      "A worksheet is either paper or is environment-friendly."
    ],
    "question": "A worksheet is bad.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nDispensable(x) ::: x is dispensable.\nEnvironmentFriendly(x) ::: x is environment-friendly.\nWoodware(x) ::: x is woodware.\nPaper(x) ::: x is paper.\nGood(x) ::: x is good.\nBad(x) ::: x is bad.\nWorksheet(x) ::: x is a worksheet.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Dispensable(x) → EnvironmentFriendly(x)) ::: All dispensable things are environment-friendly.\n∀x (Woodware(x) → Dispensable(x)) ::: All woodware is dispensable.\n∀x (Paper(x) → Woodware(x)) ::: All paper is woodware.\n∀x (Good(x) → ¬Bad(x)) ::: No good things are bad.\n∀x (EnvironmentFriendly(x) → Good(x)) ::: All environment-friendly things are good.\nWorksheet(x) ↔ (Paper(x) ∨ EnvironmentFriendly(x)) ::: A worksheet is either paper or is environment-friendly.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬Good(worksheet) ::: A worksheet is bad.\n\"\"\""
    ]
  },
  {
    "id": 1410,
    "context": [
      "All dispensable things are environment-friendly. ",
      "All woodware is dispensable.",
      "All paper is woodware. ",
      "No good things are bad. ",
      "All environment-friendly things are good.",
      "A worksheet is either paper or is environment-friendly."
    ],
    "question": "A worksheet is not bad.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nDispensable(x) ::: x is dispensable.\nEnvironmentFriendly(x) ::: x is environment-friendly.\nWoodware(x) ::: x is woodware.\nPaper(x) ::: x is paper.\nGood(x) ::: x is good.\nBad(x) ::: x is bad.\nWorksheet(x) ::: x is a worksheet.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Dispensable(x) → EnvironmentFriendly(x)) ::: All dispensable things are environment-friendly.\n∀x (Woodware(x) → Dispensable(x)) ::: All woodware is dispensable.\n∀x (Paper(x) → Woodware(x)) ::: All paper is woodware.\n∀x (Good(x) → ¬Bad(x)) ::: No good things are bad.\n∀x (EnvironmentFriendly(x) → Good(x)) ::: All environment-friendly things are good.\nWorksheet(x) ↔ (Paper(x) ∨ EnvironmentFriendly(x)) ::: A worksheet is either paper or is environment-friendly.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬Bad(worksheet) ::: A worksheet is not bad.\n\"\"\""
    ]
  },
  {
    "id": 702,
    "context": [
      "No reptile has fur.",
      "All snakes are reptiles."
    ],
    "question": "Some snake has fur.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nReptile(x) ::: x is a reptile.\nFur(x) ::: x has fur.\nSnake(x) ::: x is a snake.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Reptile(x) → ¬Fur(x)) ::: No reptile has fur.\n∀x (Snake(x) → Reptile(x)) ::: All snakes are reptiles.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n∃x (Snake(x) ∧ Fur(x)) ::: Some snake has fur.\n\"\"\""
    ]
  },
  {
    "id": 178,
    "context": [
      "All buildings in New Haven are low. ",
      "All buildings managed by the Yale Housing are located in New Haven. ",
      "All buildings in Manhattans are high. ",
      "All buildings owned by Bloomberg are located in Manhattans. ",
      "All buildings with the Bloomberg logo are owned by Bloomberg. ",
      "Tower A is managed by the Yale Housing.",
      "Tower B is with the Bloomberg logo."
    ],
    "question": "Tower A is low.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nLow(x) ::: x is a low building.\nManagedByYaleHousing(x) ::: x is managed by the Yale Housing.\nLocatedInNewHaven(x) ::: x is located in New Haven.\nHigh(x) ::: x is a high building.\nLocatedInManhattans(x) ::: x is located in Manhattans.\nOwnedByBloomberg(x) ::: x is owned by Bloomberg.\nHasBloombergLogo(x) ::: x has the Bloomberg logo.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Building(x) ∧ LocatedInNewHaven(x) → Low(x)) ::: All buildings in New Haven are low.\n∀x (Building(x) ∧ ManagedByYaleHousing(x) → LocatedInNewHaven(x)) ::: All buildings managed by the Yale Housing are located in New Haven.\n∀x (Building(x) ∧ LocatedInManhattans(x) → High(x)) ::: All buildings in Manhattans are high.\n∀x (Building(x) ∧ OwnedByBloomberg(x) → LocatedInManhattans(x)) ::: All buildings owned by Bloomberg are located in Manhattans.\n∀x (Building(x) ∧ HasBloombergLogo(x) → OwnedByBloomberg(x)) ::: All buildings with the Bloomberg logo are owned by Bloomberg.\nManagedByYaleHousing(towerA) ::: Tower A is managed by the Yale Housing.\nHasBloombergLogo(towerB) ::: Tower B is with the Bloomberg logo.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nLow(towerA) ::: Tower A is low.\n\"\"\""
    ]
  },
  {
    "id": 179,
    "context": [
      "All buildings in New Haven are low. ",
      "All buildings managed by the Yale Housing are located in New Haven. ",
      "All buildings in Manhattans are high. ",
      "All buildings owned by Bloomberg are located in Manhattans. ",
      "All buildings with the Bloomberg logo are owned by Bloomberg. ",
      "Tower A is managed by the Yale Housing.",
      "Tower B is with the Bloomberg logo."
    ],
    "question": "Tower B is not located in Manhattans.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nLow(x) ::: x is a low building.\nManagedByYaleHousing(x) ::: x is managed by the Yale Housing.\nLocatedInNewHaven(x) ::: x is located in New Haven.\nHigh(x) ::: x is a high building.\nLocatedInManhattans(x) ::: x is located in Manhattans.\nOwnedByBloomberg(x) ::: x is owned by Bloomberg.\nHasBloombergLogo(x) ::: x has the Bloomberg logo.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Building(x) ∧ LocatedInNewHaven(x) → Low(x)) ::: All buildings in New Haven are low.\n∀x (Building(x) ∧ ManagedByYaleHousing(x) → LocatedInNewHaven(x)) ::: All buildings managed by the Yale Housing are located in New Haven.\n∀x (Building(x) ∧ LocatedInManhattans(x) → High(x)) ::: All buildings in Manhattans are high.\n∀x (Building(x) ∧ OwnedByBloomberg(x) → LocatedInManhattans(x)) ::: All buildings owned by Bloomberg are located in Manhattans.\n∀x (Building(x) ∧ HasBloombergLogo(x) → OwnedByBloomberg(x)) ::: All buildings with the Bloomberg logo are owned by Bloomberg.\nManagedByYaleHousing(towerA) ::: Tower A is managed by the Yale Housing.\nHasBloombergLogo(towerB) ::: Tower B is with the Bloomberg logo.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬LocatedInManhattans(towerB) ::: Tower B is not located in Manhattans.\n\"\"\""
    ]
  },
  {
    "id": 180,
    "context": [
      "All buildings in New Haven are low. ",
      "All buildings managed by the Yale Housing are located in New Haven. ",
      "All buildings in Manhattans are high. ",
      "All buildings owned by Bloomberg are located in Manhattans. ",
      "All buildings with the Bloomberg logo are owned by Bloomberg. ",
      "Tower A is managed by the Yale Housing.",
      "Tower B is with the Bloomberg logo."
    ],
    "question": "Tower B is located in New Haven.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nLow(x) ::: x is a low building.\nLocatedIn(x, y) ::: x is located in y.\nManagedBy(x, y) ::: x is managed by y.\nHigh(x) ::: x is a high building.\nOwnedBy(x, y) ::: x is owned by y.\nHasLogo(x, y) ::: x has the logo of y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Building(x) ∧ LocatedIn(x, newHaven) → Low(x)) ::: All buildings in New Haven are low.\n∀x (Building(x) ∧ ManagedBy(x, yaleHousing) → LocatedIn(x, newHaven)) ::: All buildings managed by the Yale Housing are located in New Haven.\n∀x (Building(x) ∧ LocatedIn(x, manhattans) → High(x)) ::: All buildings in Manhattans are high.\n∀x (Building(x) ∧ OwnedBy(x, bloomberg) → LocatedIn(x, manhattans)) ::: All buildings owned by Bloomberg are located in Manhattans.\n∀x (Building(x) ∧ HasLogo(x, bloomberg) → OwnedBy(x, bloomberg)) ::: All buildings with the Bloomberg logo are owned by Bloomberg.\nManagedBy(towerA, yaleHousing) ::: Tower A is managed by the Yale Housing.\nHasLogo(towerB, bloomberg) ::: Tower B is with the Bloomberg logo.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nLocatedIn(towerB, newHaven) ::: Tower B is located in New Haven.\n\"\"\""
    ]
  },
  {
    "id": 1309,
    "context": [
      "No cold-blooded animals are birds.",
      "All reptiles are cold-blooded.",
      "Either an animal is a bird or it eats other animals.",
      "If an animal eats other animals, then it is a carnivore.",
      "Ron is neither a cold-blooded animal nor a carnivore.",
      "Henry is neither a carnivore nor a lizard."
    ],
    "question": "Ron is a lizard.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nColdBlooded(x) ::: x is a cold-blooded animal.\nBird(x) ::: x is a bird.\nReptile(x) ::: x is a reptile.\nEatsOtherAnimals(x) ::: x eats other animals.\nCarnivore(x) ::: x is a carnivore.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (ColdBlooded(x) → ¬Bird(x)) ::: No cold-blooded animals are birds.\n∀x (Reptile(x) → ColdBlooded(x)) ::: All reptiles are cold-blooded.\n∀x (Bird(x) ∨ EatsOtherAnimals(x)) ::: Either an animal is a bird or it eats other animals.\n∀x (EatsOtherAnimals(x) → Carnivore(x)) ::: If an animal eats other animals, then it is a carnivore.\n¬(ColdBlooded(ron) ∨ Carnivore(ron)) ::: Ron is neither a cold-blooded animal nor a carnivore.\n¬(Carnivore(henry) ∨ Reptile(henry)) ::: Henry is neither a carnivore nor a lizard.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬Reptile(ron) ::: Ron is a lizard.\n\"\"\""
    ]
  },
  {
    "id": 1310,
    "context": [
      "No cold-blooded animals are birds.",
      "All reptiles are cold-blooded.",
      "Either an animal is a bird or it eats other animals.",
      "If an animal eats other animals, then it is a carnivore.",
      "Ron is neither a cold-blooded animal nor a carnivore.",
      "Henry is neither a carnivore nor a lizard."
    ],
    "question": "Either Henry is a reptile or Ron eats other animals.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nColdBlooded(x) ::: x is a cold-blooded animal.\nBird(x) ::: x is a bird.\nReptile(x) ::: x is a reptile.\nEatsOtherAnimals(x) ::: x eats other animals.\nCarnivore(x) ::: x is a carnivore.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (ColdBlooded(x) → ¬Bird(x)) ::: No cold-blooded animals are birds.\n∀x (Reptile(x) → ColdBlooded(x)) ::: All reptiles are cold-blooded.\n∀x ((Bird(x) ∨ EatsOtherAnimals(x))) ::: Either an animal is a bird or it eats other animals.\n∀x (EatsOtherAnimals(x) → Carnivore(x)) ::: If an animal eats other animals, then it is a carnivore.\n¬(ColdBlooded(ron) ∨ Carnivore(ron)) ::: Ron is neither a cold-blooded animal nor a carnivore.\n¬(Carnivore(henry) ∨ Lizard(henry)) ::: Henry is neither a carnivore nor a lizard.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nReptile(henry) ∨ EatsOtherAnimals(ron) ::: Either Henry is a reptile or Ron eats other animals.\n\"\"\""
    ]
  },
  {
    "id": 1311,
    "context": [
      "No cold-blooded animals are birds.",
      "All reptiles are cold-blooded.",
      "Either an animal is a bird or it eats other animals.",
      "If an animal eats other animals, then it is a carnivore.",
      "Ron is neither a cold-blooded animal nor a carnivore.",
      "Henry is neither a carnivore nor a lizard."
    ],
    "question": "It is not true that Ron is a reptile or that Henry is cold-blooded.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nColdBlooded(x) ::: x is a cold-blooded animal.\nBird(x) ::: x is a bird.\nReptile(x) ::: x is a reptile.\nEatsOtherAnimals(x) ::: x eats other animals.\nCarnivore(x) ::: x is a carnivore.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (ColdBlooded(x) → ¬Bird(x)) ::: No cold-blooded animals are birds.\n∀x (Reptile(x) → ColdBlooded(x)) ::: All reptiles are cold-blooded.\n∀x (Bird(x) ∨ EatsOtherAnimals(x)) ::: Either an animal is a bird or it eats other animals.\n∀x (EatsOtherAnimals(x) → Carnivore(x)) ::: If an animal eats other animals, then it is a carnivore.\n¬(ColdBlooded(ron) ∨ Carnivore(ron)) ::: Ron is neither a cold-blooded animal nor a carnivore.\n¬(Carnivore(henry) ∨ Reptile(henry)) ::: Henry is neither a carnivore nor a lizard.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬(Reptile(ron) ∨ ColdBlooded(henry)) ::: It is not true that Ron is a reptile or that Henry is cold-blooded.\n\"\"\""
    ]
  },
  {
    "id": 222,
    "context": [
      "Ambiortus is a prehistoric bird genus.",
      "Ambiorus Dementjevi is the only known species of Ambiortus.",
      "The Mongol region was where Ambiorus Dementjevi lived.",
      "Yevgeny Kurochkin was the discoverer of Ambiortus."
    ],
    "question": "Yevgeny Kurochkin discovered a new bird genus.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nBirdGenus(x) ::: x is a bird genus.\nSpecies(x) ::: x is a species.\nLives(x, y) ::: x lives in region y.\nDiscoverer(x, y) ::: x is the discoverer of y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nBirdGenus(ambiortus) ∧ Species(ambiorusDementjevi) ∧ Lives(ambiorusDementjevi, mongolRegion) ::: Ambiortus is a prehistoric bird genus. Ambiorus Dementjevi is the only known species of Ambiortus. The Mongol region was where Ambiorus Dementjevi lived.\nDiscoverer(yevgenyKurochkin, ambiortus) ::: Yevgeny Kurochkin was the discoverer of Ambiortus.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n∃x (BirdGenus(x) ∧ Discoverer(yevgenyKurochkin, x)) ::: Yevgeny Kurochkin discovered a new bird genus.\n\"\"\""
    ]
  },
  {
    "id": 223,
    "context": [
      "Ambiortus is a prehistoric bird genus.",
      "Ambiorus Dementjevi is the only known species of Ambiortus.",
      "The Mongol region was where Ambiorus Dementjevi lived.",
      "Yevgeny Kurochkin was the discoverer of Ambiortus."
    ],
    "question": "There is a species of Ambiortus that doesn't live in the Mongol region.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nBirdGenus(x) ::: x is a bird genus.\nSpecies(x) ::: x is a species.\nLivesIn(x, y) ::: x lives in region y.\nDiscoverer(x, y) ::: x is the discoverer of y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nBirdGenus(ambiortus) ∧ Species(ambiorusDementjevi) ∧ LivesIn(ambiorusDementjevi, mongolRegion) ::: Ambiortus is a prehistoric bird genus. Ambiorus Dementjevi is the only known species of Ambiortus. The Mongol region was where Ambiorus Dementjevi lived.\nDiscoverer(yevgenyKurochkin, ambiortus) ::: Yevgeny Kurochkin was the discoverer of Ambiortus.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n∃x (Species(x) ∧ ¬LivesIn(x, mongolRegion)) ::: There is a species of Ambiortus that doesn't live in the Mongol region.\n\"\"\""
    ]
  },
  {
    "id": 224,
    "context": [
      "Ambiortus is a prehistoric bird genus.",
      "Ambiorus Dementjevi is the only known species of Ambiortus.",
      "The Mongol region was where Ambiorus Dementjevi lived.",
      "Yevgeny Kurochkin was the discoverer of Ambiortus."
    ],
    "question": "Yevgeny Kurochkin lived in the Mongol region.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nBirdGenus(x) ::: x is a bird genus.\nSpecies(x) ::: x is a species.\nLives(x, y) ::: x lives in region y.\nDiscoverer(x, y) ::: x is the discoverer of y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nBirdGenus(ambiortus) ∧ Species(ambiorusDementjevi) ∧ Lives(ambiorusDementjevi, mongolRegion) ::: Ambiortus is a prehistoric bird genus. Ambiorus Dementjevi is the only known species of Ambiortus. The Mongol region was where Ambiorus Dementjevi lived.\nDiscoverer(yevgenyKurochkin, ambiortus) ::: Yevgeny Kurochkin was the discoverer of Ambiortus.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nLives(yevgenyKurochkin, mongolRegion) ::: Yevgeny Kurochkin lived in the Mongol region.\n\"\"\""
    ]
  },
  {
    "id": 225,
    "context": [
      "Ambiortus is a prehistoric bird genus.",
      "Ambiorus Dementjevi is the only known species of Ambiortus.",
      "The Mongol region was where Ambiorus Dementjevi lived.",
      "Yevgeny Kurochkin was the discoverer of Ambiortus."
    ],
    "question": "All species of Ambiortus live in the Mongol region.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nBirdGenus(x) ::: x is a bird genus.\nSpecies(x) ::: x is a species.\nLivesIn(x, y) ::: x lives in region y.\nDiscoverer(x, y) ::: x is the discoverer of y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nBirdGenus(ambiortus) ∧ Species(ambiorusDementjevi) ∧ LivesIn(ambiorusDementjevi, mongolRegion) ::: Ambiortus is a prehistoric bird genus. Ambiorus Dementjevi is the only known species of Ambiortus. The Mongol region was where Ambiorus Dementjevi lived.\nDiscoverer(yevgenyKurochkin, ambiortus) ::: Yevgeny Kurochkin was the discoverer of Ambiortus.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n∀x (Species(x) → LivesIn(x, mongolRegion)) ::: All species of Ambiortus live in the Mongol region.\n\"\"\""
    ]
  },
  {
    "id": 1294,
    "context": [
      "Everyone that uses a football can throw a football.",
      "If someone plays football, then they use a football.",
      "Either someone is a football player or a basketball player.",
      "Every basketball player is tall.",
      "Everyone that can throw a football can throw a football with a spiral.",
      "If someone is tall, then they are in shape.",
      "If Jack is neither tall nor a basketball player,  then Jack is neither tall nor can throw a football."
    ],
    "question": "Jack plays football.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nUses(x, y) ::: x uses y.\nThrows(x, y) ::: x throws y.\nPlays(x, y) ::: x plays y.\nTall(x) ::: x is tall.\nBasketballPlayer(x) ::: x is a basketball player.\nFootballPlayer(x) ::: x is a football player.\nInShape(x) ::: x is in shape.\nSpiral(x, y) ::: x throws y with a spiral.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Uses(x, football) → Throws(x, football)) ::: Everyone that uses a football can throw a football.\n∀x (Plays(x, football) → Uses(x, football)) ::: If someone plays football, then they use a football.\nFootballPlayer(x) ∨ BasketballPlayer(x) ::: Either someone is a football player or a basketball player.\n∀x (BasketballPlayer(x) → Tall(x)) ::: Every basketball player is tall.\n∀x (Throws(x, football) → Throws(x, football) ∧ Spiral(x, football)) ::: Everyone that can throw a football can throw a football with a spiral.\n∀x (Tall(x) → InShape(x)) ::: If someone is tall, then they are in shape.\n¬(Tall(jack) ∨ BasketballPlayer(jack)) → ¬(Tall(jack) ∨ Throws(jack, football)) ::: If Jack is neither tall nor a basketball player, then Jack is neither tall nor can throw a football.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nPlays(jack, football) ::: Jack plays football.\n\"\"\""
    ]
  },
  {
    "id": 1295,
    "context": [
      "Everyone that uses a football can throw a football.",
      "If someone plays football, then they use a football.",
      "Either someone is a football player or a basketball player.",
      "Every basketball player is tall.",
      "Everyone that can throw a football can throw a football with a spiral.",
      "If someone is tall, then they are in shape.",
      "If Jack is neither tall nor a basketball player,  then Jack is neither tall nor can throw a football."
    ],
    "question": "Jack is in shape.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nUses(x, y) ::: x uses y.\nThrows(x, y) ::: x throws y.\nPlays(x, y) ::: x plays y.\nFootball(x) ::: x is a football.\nBasketball(x) ::: x is a basketball.\nPlayer(x) ::: x is a player.\nTall(x) ::: x is tall.\nInShape(x) ::: x is in shape.\nSpiral(x, y) ::: x throws y with a spiral.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Uses(x, football) → Throws(x, football)) ::: Everyone that uses a football can throw a football.\n∀x (Plays(x, football) → Uses(x, football)) ::: If someone plays football, then they use a football.\n(Player(x) ∨ Player(y)) ::: Either someone is a football player or a basketball player.\n∀x (Basketball(x) → Tall(x)) ::: Every basketball player is tall.\n∀x (Throws(x, football) → Throws(x, football) ∧ Spiral(x, football)) ::: Everyone that can throw a football can throw a football with a spiral.\n∀x (Tall(x) → InShape(x)) ::: If someone is tall, then they are in shape.\n¬(Tall(jack) ∨ Basketball(jack)) → ¬(Tall(jack) ∨ Throws(jack, football)) ::: If Jack is neither tall nor a basketball player, then Jack is neither tall nor can throw a football.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nInShape(jack) ::: Jack is in shape.\n\"\"\""
    ]
  },
  {
    "id": 1296,
    "context": [
      "Everyone that uses a football can throw a football.",
      "If someone plays football, then they use a football.",
      "Either someone is a football player or a basketball player.",
      "Every basketball player is tall.",
      "Everyone that can throw a football can throw a football with a spiral.",
      "If someone is tall, then they are in shape.",
      "If Jack is neither tall nor a basketball player,  then Jack is neither tall nor can throw a football."
    ],
    "question": "Jack is not in shape.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nUses(x, y) ::: x uses y.\nThrows(x, y) ::: x throws y.\nPlays(x, y) ::: x plays y.\nFootballPlayer(x) ::: x is a football player.\nBasketballPlayer(x) ::: x is a basketball player.\nTall(x) ::: x is tall.\nInShape(x) ::: x is in shape.\nSpiral(x, y) ::: x throws y with a spiral.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Uses(x, football) → Throws(x, football)) ::: Everyone that uses a football can throw a football.\n∀x (Plays(x, football) → Uses(x, football)) ::: If someone plays football, then they use a football.\nPlays(x, football) ⊕ Plays(x, basketball) ::: Either someone is a football player or a basketball player.\n∀x (BasketballPlayer(x) → Tall(x)) ::: Every basketball player is tall.\n∀x (Throws(x, football) → Throws(x, football) ∧ Spiral(x, football)) ::: Everyone that can throw a football can throw a football with a spiral.\n∀x (Tall(x) → InShape(x)) ::: If someone is tall, then they are in shape.\n¬(Tall(jack) ∨ BasketballPlayer(jack)) → ¬(Tall(jack) ∨ Throws(jack, football)) ::: If Jack is neither tall nor a basketball player, then Jack is neither tall nor can throw a football.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬InShape(jack) ::: Jack is not in shape.\n\"\"\""
    ]
  },
  {
    "id": 7,
    "context": [
      "Fort Ticonderoga is the current name for Fort Carillon.",
      "Pierre de Rigaud de Vaudreuil built Fort Carillon.",
      "Fort Carillon was located in New France.",
      "New France is not in Europe."
    ],
    "question": "Pierre de Rigaud de Vaudreuil built a fort in New France.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nCurrentName(x, y) ::: x is the current name for y.\nBuiltBy(x, y) ::: x was built by y.\nLocatedIn(x, y) ::: x is located in y.\nIn(x, y) ::: x is in y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nCurrentName(fortTiconderoga, fortCarillon) ::: Fort Ticonderoga is the current name for Fort Carillon.\nBuiltBy(fortCarillon, pierreDeRigaudDeVaudreuil) ::: Pierre de Rigaud de Vaudreuil built Fort Carillon.\nLocatedIn(fortCarillon, newFrance) ::: Fort Carillon was located in New France.\nIn(newFrance, ¬europe) ::: New France is not in Europe.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n∃x (BuiltBy(x, pierreDeRigaudDeVaudreuil) ∧ LocatedIn(x, newFrance)) ::: Pierre de Rigaud de Vaudreuil built a fort in New France.\n\"\"\""
    ]
  },
  {
    "id": 8,
    "context": [
      "Fort Ticonderoga is the current name for Fort Carillon.",
      "Pierre de Rigaud de Vaudreuil built Fort Carillon.",
      "Fort Carillon was located in New France.",
      "New France is not in Europe."
    ],
    "question": "Pierre de Rigaud de Vaudreuil built a fort in New England.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nCurrentName(x, y) ::: x is the current name for y.\nBuiltBy(x, y) ::: x was built by y.\nLocatedIn(x, y) ::: x is located in y.\nIn(x, y) ::: x is in y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nCurrentName(fortTiconderoga, fortCarillon) ::: Fort Ticonderoga is the current name for Fort Carillon.\nBuiltBy(fortCarillon, pierreDeRigaudDeVaudreuil) ::: Pierre de Rigaud de Vaudreuil built Fort Carillon.\nLocatedIn(fortCarillon, newFrance) ::: Fort Carillon was located in New France.\nIn(newFrance, ¬europe) ::: New France is not in Europe.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n∃x (BuiltBy(x, pierreDeRigaudDeVaudreuil) ∧ LocatedIn(x, newEngland)) ::: Pierre de Rigaud de Vaudreuil built a fort in New England.\n\"\"\""
    ]
  },
  {
    "id": 9,
    "context": [
      "Fort Ticonderoga is the current name for Fort Carillon.",
      "Pierre de Rigaud de Vaudreuil built Fort Carillon.",
      "Fort Carillon was located in New France.",
      "New France is not in Europe."
    ],
    "question": "Fort Carillon was located in Europe.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nCurrentName(x, y) ::: x is the current name for y.\nBuiltBy(x, y) ::: x was built by y.\nLocatedIn(x, y) ::: x is located in y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nCurrentName(fortTiconderoga, fortCarillon) ::: Fort Ticonderoga is the current name for Fort Carillon.\nBuiltBy(fortCarillon, pierreDeRigaudDeVaudreuil) ::: Pierre de Rigaud de Vaudreuil built Fort Carillon.\nLocatedIn(fortCarillon, newFrance) ::: Fort Carillon was located in New France.\n¬LocatedIn(newFrance, europe) ::: New France is not in Europe.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nLocatedIn(fortCarillon, europe) ::: Fort Carillon was located in Europe.\n\"\"\""
    ]
  },
  {
    "id": 845,
    "context": [
      "No soccer players are professional basketball players.",
      "All NBA players are professional basketball players.",
      "All defenders are soccer players.",
      "All centerback players are defenders.",
      "If Stephen Curry is an NBA player or a soccer player, then he is a professional basketball player."
    ],
    "question": "Stephen Curry is an NBA player.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nSoccerPlayer(x) ::: x is a soccer player.\nBasketballPlayer(x) ::: x is a basketball player.\nNBAPlayer(x) ::: x is an NBA player.\nDefender(x) ::: x is a defender.\nCenterback(x) ::: x is a centerback player.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (SoccerPlayer(x) → ¬BasketballPlayer(x)) ::: No soccer players are professional basketball players.\n∀x (NBAPlayer(x) → BasketballPlayer(x)) ::: All NBA players are professional basketball players.\n∀x (Defender(x) → SoccerPlayer(x)) ::: All defenders are soccer players.\n∀x (Centerback(x) → Defender(x)) ::: All centerback players are defenders.\n(NBAPlayer(stephenCurry) ∨ SoccerPlayer(stephenCurry)) → BasketballPlayer(stephenCurry) ::: If Stephen Curry is an NBA player or a soccer player, then he is a professional basketball player.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nNBAPlayer(stephenCurry) ::: Stephen Curry is an NBA player.\n\"\"\""
    ]
  },
  {
    "id": 846,
    "context": [
      "No soccer players are professional basketball players.",
      "All NBA players are professional basketball players.",
      "All defenders are soccer players.",
      "All centerback players are defenders.",
      "If Stephen Curry is an NBA player or a soccer player, then he is a professional basketball player."
    ],
    "question": "Stephen Curry is a centerback player.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nSoccerPlayer(x) ::: x is a soccer player.\nBasketballPlayer(x) ::: x is a basketball player.\nNBAPlayer(x) ::: x is an NBA player.\nDefender(x) ::: x is a defender.\nCenterback(x) ::: x is a centerback player.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (SoccerPlayer(x) → ¬BasketballPlayer(x)) ::: No soccer players are professional basketball players.\n∀x (NBAPlayer(x) → BasketballPlayer(x)) ::: All NBA players are professional basketball players.\n∀x (Defender(x) → SoccerPlayer(x)) ::: All defenders are soccer players.\n∀x (Centerback(x) → Defender(x)) ::: All centerback players are defenders.\n(NBAPlayer(stephenCurry) ∨ SoccerPlayer(stephenCurry)) → BasketballPlayer(stephenCurry) ::: If Stephen Curry is an NBA player or a soccer player, then he is a professional basketball player.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nCenterback(stephenCurry) ::: Stephen Curry is a centerback player.\n\"\"\""
    ]
  },
  {
    "id": 847,
    "context": [
      "No soccer players are professional basketball players.",
      "All NBA players are professional basketball players.",
      "All defenders are soccer players.",
      "All centerback players are defenders.",
      "If Stephen Curry is an NBA player or a soccer player, then he is a professional basketball player."
    ],
    "question": "Stephen Curry is not a centerback player.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nSoccerPlayer(x) ::: x is a soccer player.\nBasketballPlayer(x) ::: x is a basketball player.\nNBAPlayer(x) ::: x is an NBA player.\nDefender(x) ::: x is a defender.\nCenterback(x) ::: x is a centerback player.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (SoccerPlayer(x) → ¬BasketballPlayer(x)) ::: No soccer players are professional basketball players.\n∀x (NBAPlayer(x) → BasketballPlayer(x)) ::: All NBA players are professional basketball players.\n∀x (Defender(x) → SoccerPlayer(x)) ::: All defenders are soccer players.\n∀x (Centerback(x) → Defender(x)) ::: All centerback players are defenders.\n(NBAPlayer(stephenCurry) ∨ SoccerPlayer(stephenCurry)) → BasketballPlayer(stephenCurry) ::: If Stephen Curry is an NBA player or a soccer player, then he is a professional basketball player.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬Centerback(stephenCurry) ::: Stephen Curry is not a centerback player.\n\"\"\""
    ]
  },
  {
    "id": 1420,
    "context": [
      "No songs are visual. ",
      "All folk songs are songs. ",
      "All videos are visual. ",
      "All movies are videos.",
      "All sci-fi movies are movies.",
      "Inception is a sci-fi movie.",
      "Mac is neither a folk song nor a sci-fi movie."
    ],
    "question": "Inception is a folk song.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nVisual(x) ::: x is visual.\nSong(x) ::: x is a song.\nFolkSong(x) ::: x is a folk song.\nVideo(x) ::: x is a video.\nMovie(x) ::: x is a movie.\nSciFiMovie(x) ::: x is a sci-fi movie.\nInception(x) ::: x is Inception.\nMac(x) ::: x is Mac.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Song(x) → ¬Visual(x)) ::: No songs are visual.\n∀x (FolkSong(x) → Song(x)) ::: All folk songs are songs.\n∀x (Video(x) → Visual(x)) ::: All videos are visual.\n∀x (Movie(x) → Video(x)) ::: All movies are videos.\n∀x (SciFiMovie(x) → Movie(x)) ::: All sci-fi movies are movies.\nSciFiMovie(inception) ::: Inception is a sci-fi movie.\n¬(FolkSong(mac) ∨ SciFiMovie(mac)) ::: Mac is neither a folk song nor a sci-fi movie.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬FolkSong(inception) ::: Inception is a folk song.\n\"\"\""
    ]
  },
  {
    "id": 1421,
    "context": [
      "No songs are visual. ",
      "All folk songs are songs. ",
      "All videos are visual. ",
      "All movies are videos.",
      "All sci-fi movies are movies.",
      "Inception is a sci-fi movie.",
      "Mac is neither a folk song nor a sci-fi movie."
    ],
    "question": "Inception is not a folk song.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nVisual(x) ::: x is visual.\nSong(x) ::: x is a song.\nFolkSong(x) ::: x is a folk song.\nVideo(x) ::: x is a video.\nMovie(x) ::: x is a movie.\nSciFiMovie(x) ::: x is a sci-fi movie.\nInception(x) ::: x is Inception.\nMac(x) ::: x is Mac.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Song(x) → ¬Visual(x)) ::: No songs are visual.\n∀x (FolkSong(x) → Song(x)) ::: All folk songs are songs.\n∀x (Video(x) → Visual(x)) ::: All videos are visual.\n∀x (Movie(x) → Video(x)) ::: All movies are videos.\n∀x (SciFiMovie(x) → Movie(x)) ::: All sci-fi movies are movies.\nSciFiMovie(inception) ::: Inception is a sci-fi movie.\n¬(FolkSong(mac) ∨ SciFiMovie(mac)) ::: Mac is neither a folk song nor a sci-fi movie.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬FolkSong(inception) ::: Inception is not a folk song.\n\"\"\""
    ]
  },
  {
    "id": 1422,
    "context": [
      "No songs are visual. ",
      "All folk songs are songs. ",
      "All videos are visual. ",
      "All movies are videos.",
      "All sci-fi movies are movies.",
      "Inception is a sci-fi movie.",
      "Mac is neither a folk song nor a sci-fi movie."
    ],
    "question": "Inception is either a video or a folk song.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nVisual(x) ::: x is visual.\nSong(x) ::: x is a song.\nFolkSong(x) ::: x is a folk song.\nVideo(x) ::: x is a video.\nMovie(x) ::: x is a movie.\nSciFiMovie(x) ::: x is a sci-fi movie.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Song(x) → ¬Visual(x)) ::: No songs are visual.\n∀x (FolkSong(x) → Song(x)) ::: All folk songs are songs.\n∀x (Video(x) → Visual(x)) ::: All videos are visual.\n∀x (Movie(x) → Video(x)) ::: All movies are videos.\n∀x (SciFiMovie(x) → Movie(x)) ::: All sci-fi movies are movies.\nSciFiMovie(inception) ::: Inception is a sci-fi movie.\n¬(FolkSong(mac) ∨ SciFiMovie(mac)) ::: Mac is neither a folk song nor a sci-fi movie.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nVideo(inception) ∨ FolkSong(inception) ::: Inception is either a video or a folk song.\n\"\"\""
    ]
  },
  {
    "id": 1423,
    "context": [
      "No songs are visual. ",
      "All folk songs are songs. ",
      "All videos are visual. ",
      "All movies are videos.",
      "All sci-fi movies are movies.",
      "Inception is a sci-fi movie.",
      "Mac is neither a folk song nor a sci-fi movie."
    ],
    "question": "Mac is a video.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nVisual(x) ::: x is visual.\nSong(x) ::: x is a song.\nFolkSong(x) ::: x is a folk song.\nVideo(x) ::: x is a video.\nMovie(x) ::: x is a movie.\nSciFiMovie(x) ::: x is a sci-fi movie.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n¬∃x (Song(x) ∧ Visual(x)) ::: No songs are visual.\n∀x (FolkSong(x) → Song(x)) ::: All folk songs are songs.\n∀x (Video(x) → Visual(x)) ::: All videos are visual.\n∀x (Movie(x) → Video(x)) ::: All movies are videos.\n∀x (SciFiMovie(x) → Movie(x)) ::: All sci-fi movies are movies.\nSciFiMovie(inception) ::: Inception is a sci-fi movie.\n¬(FolkSong(mac) ∨ SciFiMovie(mac)) ::: Mac is neither a folk song nor a sci-fi movie.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nVideo(mac) ::: Mac is a video.\n\"\"\""
    ]
  },
  {
    "id": 1065,
    "context": [
      "All extroverts are overtly expressive.",
      "People are either extroverts or introverts.",
      "If someone is an introvert, then they are shy and reticent. ",
      "No shy and reticent person likes to talk to strangers.",
      "Jeff is not an extrovert and someone who likes to talk to strangers."
    ],
    "question": "Jeff is a shy and reticent person.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nExtrovert(x) ::: x is an extrovert.\nExpressive(x) ::: x is overtly expressive.\nIntrovert(x) ::: x is an introvert.\nShy(x) ::: x is shy.\nReticent(x) ::: x is reticent.\nLikes(x, y) ::: x likes y.\nTalkToStrangers(x) ::: x likes to talk to strangers.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Extrovert(x) → Expressive(x)) ::: All extroverts are overtly expressive.\n∀x (Extrovert(x) ∨ Introvert(x)) ::: People are either extroverts or introverts.\n∀x (Introvert(x) → (Shy(x) ∧ Reticent(x))) ::: If someone is an introvert, then they are shy and reticent.\n∀x (Shy(x) ∧ Reticent(x) → ¬Likes(x, strangers)) ::: No shy and reticent person likes to talk to strangers.\n¬(Extrovert(jeff) ∧ Likes(jeff, strangers)) ::: Jeff is not an extrovert and someone who likes to talk to strangers.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nShy(jeff) ∧ Reticent(jeff) ::: Jeff is a shy and reticent person.\n\"\"\""
    ]
  },
  {
    "id": 1066,
    "context": [
      "All extroverts are overtly expressive.",
      "People are either extroverts or introverts.",
      "If someone is an introvert, then they are shy and reticent. ",
      "No shy and reticent person likes to talk to strangers.",
      "Jeff is not an extrovert and someone who likes to talk to strangers."
    ],
    "question": "Jeff is overtly expressive and likes to talk to strangers.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nExtrovert(x) ::: x is an extrovert.\nExpressive(x) ::: x is overtly expressive.\nIntrovert(x) ::: x is an introvert.\nShy(x) ::: x is shy.\nReticent(x) ::: x is reticent.\nLikesToTalkToStrangers(x) ::: x likes to talk to strangers.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Extrovert(x) → Expressive(x)) ::: All extroverts are overtly expressive.\n∀x (Extrovert(x) ∨ Introvert(x)) ::: People are either extroverts or introverts.\n∀x (Introvert(x) → (Shy(x) ∧ Reticent(x))) ::: If someone is an introvert, then they are shy and reticent.\n∀x (Shy(x) ∧ Reticent(x) → ¬LikesToTalkToStrangers(x)) ::: No shy and reticent person likes to talk to strangers.\n¬(Extrovert(jeff) ∧ LikesToTalkToStrangers(jeff)) ::: Jeff is not an extrovert and someone who likes to talk to strangers.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nExpressive(jeff) ∧ LikesToTalkToStrangers(jeff) ::: Jeff is overtly expressive and likes to talk to strangers.\n\"\"\""
    ]
  },
  {
    "id": 1067,
    "context": [
      "All extroverts are overtly expressive.",
      "People are either extroverts or introverts.",
      "If someone is an introvert, then they are shy and reticent. ",
      "No shy and reticent person likes to talk to strangers.",
      "Jeff is not an extrovert and someone who likes to talk to strangers."
    ],
    "question": "If Jeff is either overtly expressive and likes to talk to strangers or neither overtly expressive nor likes to talk to strangers, then Jeff is neither an extrovert nor likes to talk to strangers.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nExtrovert(x) ::: x is an extrovert.\nExpressive(x) ::: x is overtly expressive.\nIntrovert(x) ::: x is an introvert.\nShy(x) ::: x is shy.\nReticent(x) ::: x is reticent.\nLikesToTalkToStrangers(x) ::: x likes to talk to strangers.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Extrovert(x) → Expressive(x)) ::: All extroverts are overtly expressive.\n∀x (Extrovert(x) ∨ Introvert(x)) ::: People are either extroverts or introverts.\n∀x (Introvert(x) → (Shy(x) ∧ Reticent(x))) ::: If someone is an introvert, then they are shy and reticent.\n∀x (Shy(x) ∧ Reticent(x) → ¬LikesToTalkToStrangers(x)) ::: No shy and reticent person likes to talk to strangers.\n¬(Extrovert(jeff) ∧ LikesToTalkToStrangers(jeff)) ::: Jeff is not an extrovert and someone who likes to talk to strangers.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬((Expressive(jeff) ∧ LikesToTalkToStrangers(jeff)) ∨ ¬(Expressive(jeff) ∨ LikesToTalkToStrangers(jeff))) ::: If Jeff is either overtly expressive and likes to talk to strangers or neither overtly expressive nor likes to talk to strangers, then Jeff is neither an extrovert nor likes to talk to strangers.\n\"\"\""
    ]
  },
  {
    "id": 1138,
    "context": [
      "No low-scoring players are top players in the league.",
      "Basketball players are either top players in the league or successfully shoot a high percentage of 3-pointers.",
      "All players who successfully shoot a high percentage of 3-pointers are solid at shooting 2-pointers.",
      "No players who are solid at shooting 2-pointers are bad at mid-range shots.",
      "Candace is either a low-scoring player or successfully shoots a high percentage of 3-pointers."
    ],
    "question": "Candace is a top player in the league.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nLowScoring(x) ::: x is a low-scoring player.\nTopPlayer(x) ::: x is a top player in the league.\nBasketballPlayer(x) ::: x is a basketball player.\nShoots3Pointer(x) ::: x successfully shoots a high percentage of 3-pointers.\nSolid2Pointer(x) ::: x is solid at shooting 2-pointers.\nBadMidRange(x) ::: x is bad at mid-range shots.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (LowScoring(x) → ¬TopPlayer(x)) ::: No low-scoring players are top players in the league.\n∀x (BasketballPlayer(x) → (TopPlayer(x) ∨ Shoots3Pointer(x))) ::: Basketball players are either top players in the league or successfully shoot a high percentage of 3-pointers.\n∀x (Shoots3Pointer(x) → Solid2Pointer(x)) ::: All players who successfully shoot a high percentage of 3-pointers are solid at shooting 2-pointers.\n∀x (Solid2Pointer(x) → ¬BadMidRange(x)) ::: No players who are solid at shooting 2-pointers are bad at mid-range shots.\n(LowScoring(candace) ∨ Shoots3Pointer(candace)) ::: Candace is either a low-scoring player or successfully shoots a high percentage of 3-pointers.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nTopPlayer(candace) ::: Candace is a top player in the league.\n\"\"\""
    ]
  },
  {
    "id": 1139,
    "context": [
      "No low-scoring players are top players in the league.",
      "Basketball players are either top players in the league or successfully shoot a high percentage of 3-pointers.",
      "All players who successfully shoot a high percentage of 3-pointers are solid at shooting 2-pointers.",
      "No players who are solid at shooting 2-pointers are bad at mid-range shots.",
      "Candace is either a low-scoring player or successfully shoots a high percentage of 3-pointers."
    ],
    "question": "Candace is bad at mid-range shots.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nLowScoring(x) ::: x is a low-scoring player.\nTopPlayer(x) ::: x is a top player in the league.\nBasketballPlayer(x) ::: x is a basketball player.\nShoots3Pointers(x) ::: x successfully shoots a high percentage of 3-pointers.\nSolid3PointShooter(x) ::: x is solid at shooting 3-pointers.\nSolid2PointShooter(x) ::: x is solid at shooting 2-pointers.\nBadMidRangeShooter(x) ::: x is bad at mid-range shots.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (LowScoring(x) → ¬TopPlayer(x)) ::: No low-scoring players are top players in the league.\n∀x (BasketballPlayer(x) → (TopPlayer(x) ∨ Shoots3Pointers(x))) ::: Basketball players are either top players in the league or successfully shoot a high percentage of 3-pointers.\n∀x (Shoots3Pointers(x) → Solid2PointShooter(x)) ::: All players who successfully shoot a high percentage of 3-pointers are solid at shooting 2-pointers.\n∀x (Solid2PointShooter(x) → ¬BadMidRangeShooter(x)) ::: No players who are solid at shooting 2-pointers are bad at mid-range shots.\n(LowScoring(candace) ∨ Shoots3Pointers(candace)) ::: Candace is either a low-scoring player or successfully shoots a high percentage of 3-pointers.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nBadMidRangeShooter(candace) ::: Candace is bad at mid-range shots.\n\"\"\""
    ]
  },
  {
    "id": 1140,
    "context": [
      "No low-scoring players are top players in the league.",
      "Basketball players are either top players in the league or successfully shoot a high percentage of 3-pointers.",
      "All players who successfully shoot a high percentage of 3-pointers are solid at shooting 2-pointers.",
      "No players who are solid at shooting 2-pointers are bad at mid-range shots.",
      "Candace is either a low-scoring player or successfully shoots a high percentage of 3-pointers."
    ],
    "question": "Candace is solid at shooting 2-pointers or bad at mid-range shots.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nLowScoring(x) ::: x is a low-scoring player.\nTopPlayer(x) ::: x is a top player in the league.\nBasketballPlayer(x) ::: x is a basketball player.\nShoots3Pointers(x) ::: x successfully shoots a high percentage of 3-pointers.\nSolid2Pointers(x) ::: x is solid at shooting 2-pointers.\nBadMidRange(x) ::: x is bad at mid-range shots.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (LowScoring(x) → ¬TopPlayer(x)) ::: No low-scoring players are top players in the league.\n∀x (BasketballPlayer(x) → (TopPlayer(x) ∨ Shoots3Pointers(x))) ::: Basketball players are either top players in the league or successfully shoot a high percentage of 3-pointers.\n∀x (Shoots3Pointers(x) → Solid2Pointers(x)) ::: All players who successfully shoot a high percentage of 3-pointers are solid at shooting 2-pointers.\n∀x (Solid2Pointers(x) → ¬BadMidRange(x)) ::: No players who are solid at shooting 2-pointers are bad at mid-range shots.\n(LowScoring(candace) ∨ Shoots3Pointers(candace)) ::: Candace is either a low-scoring player or successfully shoots a high percentage of 3-pointers.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nSolid2Pointers(candace) ∨ BadMidRange(candace) ::: Candace is solid at shooting 2-pointers or bad at mid-range shots.\n\"\"\""
    ]
  },
  {
    "id": 1141,
    "context": [
      "No low-scoring players are top players in the league.",
      "Basketball players are either top players in the league or successfully shoot a high percentage of 3-pointers.",
      "All players who successfully shoot a high percentage of 3-pointers are solid at shooting 2-pointers.",
      "No players who are solid at shooting 2-pointers are bad at mid-range shots.",
      "Candace is either a low-scoring player or successfully shoots a high percentage of 3-pointers."
    ],
    "question": "Candace is either solid at shooting 2-pointers or bad at mid-range shots.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nLowScoring(x) ::: x is a low-scoring player.\nTopPlayer(x) ::: x is a top player in the league.\nBasketballPlayer(x) ::: x is a basketball player.\nHighPercentage3Pointers(x) ::: x successfully shoots a high percentage of 3-pointers.\nSolid2Pointers(x) ::: x is solid at shooting 2-pointers.\nBadMidRange(x) ::: x is bad at mid-range shots.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (LowScoring(x) → ¬TopPlayer(x)) ::: No low-scoring players are top players in the league.\n∀x (BasketballPlayer(x) → (TopPlayer(x) ∨ HighPercentage3Pointers(x))) ::: Basketball players are either top players in the league or successfully shoot a high percentage of 3-pointers.\n∀x (HighPercentage3Pointers(x) → Solid2Pointers(x)) ::: All players who successfully shoot a high percentage of 3-pointers are solid at shooting 2-pointers.\n∀x (Solid2Pointers(x) → ¬BadMidRange(x)) ::: No players who are solid at shooting 2-pointers are bad at mid-range shots.\n(LowScoring(candace) ∨ HighPercentage3Pointers(candace)) ::: Candace is either a low-scoring player or successfully shoots a high percentage of 3-pointers.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nSolid2Pointers(candace) ∨ BadMidRange(candace) ::: Candace is either solid at shooting 2-pointers or bad at mid-range shots.\n\"\"\""
    ]
  },
  {
    "id": 1142,
    "context": [
      "No low-scoring players are top players in the league.",
      "Basketball players are either top players in the league or successfully shoot a high percentage of 3-pointers.",
      "All players who successfully shoot a high percentage of 3-pointers are solid at shooting 2-pointers.",
      "No players who are solid at shooting 2-pointers are bad at mid-range shots.",
      "Candace is either a low-scoring player or successfully shoots a high percentage of 3-pointers."
    ],
    "question": "Candace is a low-scoring player or bad at mid-range shots.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nLowScoring(x) ::: x is a low-scoring player.\nTopPlayer(x) ::: x is a top player in the league.\nBasketballPlayer(x) ::: x is a basketball player.\nShoots3Pointers(x) ::: x successfully shoots a high percentage of 3-pointers.\nSolid2Pointers(x) ::: x is solid at shooting 2-pointers.\nBadMidRange(x) ::: x is bad at mid-range shots.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (LowScoring(x) → ¬TopPlayer(x)) ::: No low-scoring players are top players in the league.\n∀x (BasketballPlayer(x) → (TopPlayer(x) ∨ Shoots3Pointers(x))) ::: Basketball players are either top players in the league or successfully shoot a high percentage of 3-pointers.\n∀x (Shoots3Pointers(x) → Solid2Pointers(x)) ::: All players who successfully shoot a high percentage of 3-pointers are solid at shooting 2-pointers.\n∀x (Solid2Pointers(x) → ¬BadMidRange(x)) ::: No players who are solid at shooting 2-pointers are bad at mid-range shots.\n(LowScoring(candace) ∨ Shoots3Pointers(candace)) ::: Candace is either a low-scoring player or successfully shoots a high percentage of 3-pointers.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nLowScoring(candace) ∨ BadMidRange(candace) ::: Candace is a low-scoring player or bad at mid-range shots.\n\"\"\""
    ]
  },
  {
    "id": 1143,
    "context": [
      "No low-scoring players are top players in the league.",
      "Basketball players are either top players in the league or successfully shoot a high percentage of 3-pointers.",
      "All players who successfully shoot a high percentage of 3-pointers are solid at shooting 2-pointers.",
      "No players who are solid at shooting 2-pointers are bad at mid-range shots.",
      "Candace is either a low-scoring player or successfully shoots a high percentage of 3-pointers."
    ],
    "question": "Candace is either a low-scoring player or bad at mid-range shots.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nLowScoring(x) ::: x is a low-scoring player.\nTopPlayer(x) ::: x is a top player in the league.\nBasketballPlayer(x) ::: x is a basketball player.\nShootsHighPercentage3Pointers(x) ::: x successfully shoots a high percentage of 3-pointers.\nSolidAtShooting2Pointers(x) ::: x is solid at shooting 2-pointers.\nBadAtMidRangeShots(x) ::: x is bad at mid-range shots.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (LowScoring(x) → ¬TopPlayer(x)) ::: No low-scoring players are top players in the league.\n∀x (BasketballPlayer(x) → (TopPlayer(x) ∨ ShootsHighPercentage3Pointers(x))) ::: Basketball players are either top players in the league or successfully shoot a high percentage of 3-pointers.\n∀x (ShootsHighPercentage3Pointers(x) → SolidAtShooting2Pointers(x)) ::: All players who successfully shoot a high percentage of 3-pointers are solid at shooting 2-pointers.\n∀x (SolidAtShooting2Pointers(x) → ¬BadAtMidRangeShots(x)) ::: No players who are solid at shooting 2-pointers are bad at mid-range shots.\n(LowScoring(candace) ∨ ShootsHighPercentage3Pointers(candace)) ::: Candace is either a low-scoring player or successfully shoots a high percentage of 3-pointers.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nLowScoring(candace) ∨ BadAtMidRangeShots(candace) ::: Candace is either a low-scoring player or bad at mid-range shots.\n\"\"\""
    ]
  },
  {
    "id": 1144,
    "context": [
      "No low-scoring players are top players in the league.",
      "Basketball players are either top players in the league or successfully shoot a high percentage of 3-pointers.",
      "All players who successfully shoot a high percentage of 3-pointers are solid at shooting 2-pointers.",
      "No players who are solid at shooting 2-pointers are bad at mid-range shots.",
      "Candace is either a low-scoring player or successfully shoots a high percentage of 3-pointers."
    ],
    "question": "Candace is either a player who successfully shoots a high percentage of 3-pointers or is bad at mid-range shots.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nLowScoring(x) ::: x is a low-scoring player.\nTopPlayer(x) ::: x is a top player in the league.\nBasketballPlayer(x) ::: x is a basketball player.\nShoots3Pointers(x) ::: x successfully shoots a high percentage of 3-pointers.\nSolid3Pointers(x) ::: x is solid at shooting 2-pointers.\nBadMidRange(x) ::: x is bad at mid-range shots.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (LowScoring(x) → ¬TopPlayer(x)) ::: No low-scoring players are top players in the league.\n∀x (BasketballPlayer(x) → (TopPlayer(x) ∨ Shoots3Pointers(x))) ::: Basketball players are either top players in the league or successfully shoot a high percentage of 3-pointers.\n∀x (Shoots3Pointers(x) → Solid3Pointers(x)) ::: All players who successfully shoot a high percentage of 3-pointers are solid at shooting 2-pointers.\n∀x (Solid3Pointers(x) → ¬BadMidRange(x)) ::: No players who are solid at shooting 2-pointers are bad at mid-range shots.\n(LowScoring(candace) ∨ Shoots3Pointers(candace)) ::: Candace is either a low-scoring player or successfully shoots a high percentage of 3-pointers.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nShoots3Pointers(candace) ∨ BadMidRange(candace) ::: Candace is either a player who successfully shoots a high percentage of 3-pointers or is bad at mid-range shots.\n\"\"\""
    ]
  },
  {
    "id": 1145,
    "context": [
      "No low-scoring players are top players in the league.",
      "Basketball players are either top players in the league or successfully shoot a high percentage of 3-pointers.",
      "All players who successfully shoot a high percentage of 3-pointers are solid at shooting 2-pointers.",
      "No players who are solid at shooting 2-pointers are bad at mid-range shots.",
      "Candace is either a low-scoring player or successfully shoots a high percentage of 3-pointers."
    ],
    "question": "If Candace is not solid at shooting 2-pointers and bad at mid-range shots, then Candace is not solid at shooting 2-pointers and is a player who successfully shoots a high percentage of 3-pointers.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nLowScoring(x) ::: x is a low-scoring player.\nTopPlayer(x) ::: x is a top player in the league.\nBasketballPlayer(x) ::: x is a basketball player.\nHighPercentage3Pointers(x) ::: x successfully shoots a high percentage of 3-pointers.\nSolid3Pointers(x) ::: x is solid at shooting 3-pointers.\nSolid2Pointers(x) ::: x is solid at shooting 2-pointers.\nBadMidRange(x) ::: x is bad at mid-range shots.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (LowScoring(x) → ¬TopPlayer(x)) ::: No low-scoring players are top players in the league.\n∀x (BasketballPlayer(x) → (TopPlayer(x) ∨ HighPercentage3Pointers(x))) ::: Basketball players are either top players in the league or successfully shoot a high percentage of 3-pointers.\n∀x (HighPercentage3Pointers(x) → Solid2Pointers(x)) ::: All players who successfully shoot a high percentage of 3-pointers are solid at shooting 2-pointers.\n∀x (Solid2Pointers(x) → ¬BadMidRange(x)) ::: No players who are solid at shooting 2-pointers are bad at mid-range shots.\n(LowScoring(candace) ∨ HighPercentage3Pointers(candace)) ::: Candace is either a low-scoring player or successfully shoots a high percentage of 3-pointers.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬(Solid2Pointers(candace) ∧ BadMidRange(candace)) → (¬Solid2Pointers(candace) ∧ HighPercentage3Pointers(candace)) ::: If Candace is not solid at shooting 2-pointers and bad at mid-range shots, then Candace is not solid at shooting 2-pointers and is a player who successfully shoots a high percentage of 3-pointers.\n\"\"\""
    ]
  },
  {
    "id": 1146,
    "context": [
      "No low-scoring players are top players in the league.",
      "Basketball players are either top players in the league or successfully shoot a high percentage of 3-pointers.",
      "All players who successfully shoot a high percentage of 3-pointers are solid at shooting 2-pointers.",
      "No players who are solid at shooting 2-pointers are bad at mid-range shots.",
      "Candace is either a low-scoring player or successfully shoots a high percentage of 3-pointers."
    ],
    "question": "If Candace is solid at shooting 2-pointers or successfully shoots a high percentage of 3-pointers, then Candace is a top player in the league and bad at mid-range shots.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nLowScoring(x) ::: x is a low-scoring player.\nTopPlayer(x) ::: x is a top player in the league.\nShoots3Pointers(x) ::: x successfully shoots a high percentage of 3-pointers.\nSolid3Pointers(x) ::: x is solid at shooting 2-pointers.\nBadMidRange(x) ::: x is bad at mid-range shots.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (LowScoring(x) → ¬TopPlayer(x)) ::: No low-scoring players are top players in the league.\n∀x (BasketballPlayer(x) → (TopPlayer(x) ∨ Shoots3Pointers(x))) ::: Basketball players are either top players in the league or successfully shoot a high percentage of 3-pointers.\n∀x (Shoots3Pointers(x) → Solid3Pointers(x)) ::: All players who successfully shoot a high percentage of 3-pointers are solid at shooting 2-pointers.\n∀x (Solid3Pointers(x) → ¬BadMidRange(x)) ::: No players who are solid at shooting 2-pointers are bad at mid-range shots.\n(Candace(x) ∧ LowScoring(x)) ∨ Shoots3Pointers(x) ::: Candace is either a low-scoring player or successfully shoots a high percentage of 3-pointers.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n(Solid3Pointers(candace) ∨ Shoots3Pointers(candace)) → (TopPlayer(candace) ∧ BadMidRange(candace)) ::: If Candace is solid at shooting 2-pointers or successfully shoots a high percentage of 3-pointers, then Candace is a top player in the league and bad at mid-range shots.\n\"\"\""
    ]
  },
  {
    "id": 720,
    "context": [
      "No plants are fungi.",
      "Mushrooms are fungi."
    ],
    "question": "No plants are mushrooms.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nPlant(x) ::: x is a plant.\nFungus(x) ::: x is a fungus.\nMushroom(x) ::: x is a mushroom.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Plant(x) → ¬Fungus(x)) ::: No plants are fungi.\nFungus(mushrooms) ::: Mushrooms are fungi.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬(Plant(x) ∧ Mushroom(x)) ::: No plants are mushrooms.\n\"\"\""
    ]
  },
  {
    "id": 740,
    "context": [
      "No road is clean.",
      "And some streets are roads."
    ],
    "question": "Some streets are clean",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nClean(x) ::: x is clean.\nRoad(x) ::: x is a road.\nStreet(x) ::: x is a street.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Road(x) → ¬Clean(x)) ::: No road is clean.\n∃x (Street(x) ∧ Road(x)) ::: Some streets are roads.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n∃x (Street(x) ∧ Clean(x)) ::: Some streets are clean.\n\"\"\""
    ]
  },
  {
    "id": 632,
    "context": [
      "New York City is on the East Coast. ",
      "Seattle is on the West Coast. ",
      "If a person from a city on the East coast is traveling to a city on the west coast, they will be on a long flight.",
      "Most passengers on flights to Seattle from New York City are not in first class.",
      "People on long flights are uncomfortable unless they're in first class"
    ],
    "question": "Some people flying from New York City to Seattle will be uncomfortable.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nEastCoast(x) ::: x is a city on the East Coast.\nWestCoast(x) ::: x is a city on the West Coast.\nTraveling(x, y) ::: x is traveling to y.\nLongFlight(x) ::: x is on a long flight.\nPassenger(x) ::: x is a passenger.\nFirstClass(x) ::: x is in first class.\nUncomfortable(x) ::: x is uncomfortable.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nEastCoast(newYorkCity) ::: New York City is on the East Coast.\nWestCoast(seattle) ::: Seattle is on the West Coast.\n∀x (EastCoast(x) ∧ WestCoast(y) → LongFlight(x, y)) ::: If a person from a city on the East coast is traveling to a city on the west coast, they will be on a long flight.\n∃x (Passenger(x) ∧ Traveling(x, newYorkCity) ∧ Traveling(x, seattle) ∧ ¬FirstClass(x)) ::: Most passengers on flights to Seattle from New York City are not in first class.\n∀x (LongFlight(x) → (FirstClass(x) ∨ Uncomfortable(x))) ::: People on long flights are uncomfortable unless they're in first class.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n∃x (Passenger(x) ∧ Traveling(x, newYorkCity) ∧ Traveling(x, seattle) ∧ Uncomfortable(x)) ::: Some people flying from New York City to Seattle will be uncomfortable.\n\"\"\""
    ]
  },
  {
    "id": 356,
    "context": [
      "Musicians have very busy lives.",
      "Singh Kaur is a musician and famous.",
      "If a musician is not famous, that musician will not make a lot of money.",
      "A musician can be a singer or a writer."
    ],
    "question": "Singh Kaur makes a lot of money.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nMusician(x) ::: x is a musician.\nBusyLife(x) ::: x has a very busy life.\nFamous(x) ::: x is famous.\nMakeMoney(x) ::: x makes a lot of money.\nSinger(x) ::: x is a singer.\nWriter(x) ::: x is a writer.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Musician(x) → BusyLife(x)) ::: Musicians have very busy lives.\nMusician(singhKaur) ∧ Famous(singhKaur) ::: Singh Kaur is a musician and famous.\n∀x (Musician(x) ∧ ¬Famous(x) → ¬MakeMoney(x)) ::: If a musician is not famous, that musician will not make a lot of money.\n∀x (Musician(x) → (Singer(x) ∨ Writer(x))) ::: A musician can be a singer or a writer.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nMakeMoney(singhKaur) ::: Singh Kaur makes a lot of money.\n\"\"\""
    ]
  },
  {
    "id": 357,
    "context": [
      "Musicians have very busy lives.",
      "Singh Kaur is a musician and famous.",
      "If a musician is not famous, that musician will not make a lot of money.",
      "A musician can be a singer or a writer."
    ],
    "question": "Singh Kaur is a writer.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nMusician(x) ::: x is a musician.\nBusyLife(x) ::: x has a very busy life.\nFamous(x) ::: x is famous.\nMakeMoney(x) ::: x makes a lot of money.\nSinger(x) ::: x is a singer.\nWriter(x) ::: x is a writer.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Musician(x) → BusyLife(x)) ::: Musicians have very busy lives.\nMusician(singhKaur) ∧ Famous(singhKaur) ::: Singh Kaur is a musician and famous.\n∀x (Musician(x) ∧ ¬Famous(x) → ¬MakeMoney(x)) ::: If a musician is not famous, that musician will not make a lot of money.\n∀x (Musician(x) → (Singer(x) ∨ Writer(x))) ::: A musician can be a singer or a writer.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nWriter(singhKaur) ::: Singh Kaur is a writer.\n\"\"\""
    ]
  },
  {
    "id": 358,
    "context": [
      "Musicians have very busy lives.",
      "Singh Kaur is a musician and famous.",
      "If a musician is not famous, that musician will not make a lot of money.",
      "A musician can be a singer or a writer."
    ],
    "question": "Singh Kaur has a very busy life.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nMusician(x) ::: x is a musician.\nBusyLife(x) ::: x has a very busy life.\nFamous(x) ::: x is famous.\nMakeMoney(x) ::: x makes a lot of money.\nSinger(x) ::: x is a singer.\nWriter(x) ::: x is a writer.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Musician(x) → BusyLife(x)) ::: Musicians have very busy lives.\nMusician(singhKaur) ∧ Famous(singhKaur) ::: Singh Kaur is a musician and famous.\n∀x (Musician(x) ∧ ¬Famous(x) → ¬MakeMoney(x)) ::: If a musician is not famous, that musician will not make a lot of money.\n∀x (Musician(x) → (Singer(x) ∨ Writer(x))) ::: A musician can be a singer or a writer.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nBusyLife(singhKaur) ::: Singh Kaur has a very busy life.\n\"\"\""
    ]
  },
  {
    "id": 733,
    "context": [
      "Each building is tall. ",
      "Everything tall has  height."
    ],
    "question": "All buildings are magnificent.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nBuilding(x) ::: x is a building.\nTall(x) ::: x is tall.\nHasHeight(x) ::: x has height.\nMagnificent(x) ::: x is magnificent.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x Tall(x) ::: Each building is tall.\n∀x (Tall(x) → HasHeight(x)) ::: Everything tall has height.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n∀x Magnificent(x) ::: All buildings are magnificent.\n\"\"\""
    ]
  },
  {
    "id": 376,
    "context": [
      "A cat named Garfield, which is the main character of the film Garfield, is orange and fat and likes having lasagna. ",
      "Garfield and Odie, who is another pet of Jon, share the same home. ",
      "Garfield hates Odie.",
      "A pet who hates the pet with whom he shares the same owner is childish and possessive.",
      "Cats are pets. "
    ],
    "question": "The main character of the film Garfield is childish and possessive.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nCat(x) ::: x is a cat.\nMainCharacter(x, y) ::: x is the main character of the film y.\nOrange(x) ::: x is orange.\nFat(x) ::: x is fat.\nLikes(x, y) ::: x likes y.\nPet(x) ::: x is a pet.\nHome(x, y) ::: x shares the same home with y.\nHates(x, y) ::: x hates y.\nChildish(x) ::: x is childish.\nPossessive(x) ::: x is possessive.\nOwner(x, y) ::: x is the owner of y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nCat(garfield) ∧ MainCharacter(garfield, garfield) ∧ Orange(garfield) ∧ Fat(garfield) ∧ Likes(garfield, lasagna) ::: A cat named Garfield, which is the main character of the film Garfield, is orange and fat and likes having lasagna.\nHome(garfield, odie) ∧ Home(odie, jon) ::: Garfield and Odie, who is another pet of Jon, share the same home.\nHates(garfield, odie) ::: Garfield hates Odie.\n∀x (Pet(x) ∧ ∃y (Home(x, y) ∧ Hates(x, y)) → (Childish(x) ∧ Possessive(x))) ::: A pet who hates the pet with whom he shares the same owner is childish and possessive.\n∀x (Cat(x)) ::: Cats are pets.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nChildish(garfield) ∧ Possessive(garfield) ::: The main character of the film Garfield is childish and possessive.\n\"\"\""
    ]
  },
  {
    "id": 1377,
    "context": [
      "All humans eat.",
      "If something eats, then it is not a plant.",
      "A thing is either plant or animal.",
      "All goats are animals.",
      "No dirt is an animal.",
      "Hulu is a goat or a human."
    ],
    "question": "Hulu eats.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nEat(x) ::: x eats.\nPlant(x) ::: x is a plant.\nAnimal(x) ::: x is an animal.\nGoat(x) ::: x is a goat.\nHuman(x) ::: x is a human.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x Eat(x) ::: All humans eat.\n∀x (Eat(x) → ¬Plant(x)) ::: If something eats, then it is not a plant.\n∀x (Plant(x) ∨ Animal(x)) ::: A thing is either plant or animal.\n∀x (Goat(x) → Animal(x)) ::: All goats are animals.\n∀x (Dirt(x) → ¬Animal(x)) ::: No dirt is an animal.\n(Hulu(goat) ∨ Hulu(human)) ::: Hulu is a goat or a human.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nEat(hulu) ::: Hulu eats.\n\"\"\""
    ]
  },
  {
    "id": 1378,
    "context": [
      "All humans eat.",
      "If something eats, then it is not a plant.",
      "A thing is either plant or animal.",
      "All goats are animals.",
      "No dirt is an animal.",
      "Hulu is a goat or a human."
    ],
    "question": "Hulu does not eat.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nEat(x) ::: x eats.\nPlant(x) ::: x is a plant.\nAnimal(x) ::: x is an animal.\nGoat(x) ::: x is a goat.\nHuman(x) ::: x is a human.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x Eat(x) ::: All humans eat.\n∀x (Eat(x) → ¬Plant(x)) ::: If something eats, then it is not a plant.\n∀x (Plant(x) ∨ Animal(x)) ::: A thing is either plant or animal.\n∀x (Goat(x) → Animal(x)) ::: All goats are animals.\n∀x (Dirt(x) → ¬Animal(x)) ::: No dirt is an animal.\n(Goat(hulu) ∨ Human(hulu)) ::: Hulu is a goat or a human.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬Eat(hulu) ::: Hulu does not eat.\n\"\"\""
    ]
  },
  {
    "id": 1379,
    "context": [
      "All humans eat.",
      "If something eats, then it is not a plant.",
      "A thing is either plant or animal.",
      "All goats are animals.",
      "No dirt is an animal.",
      "Hulu is a goat or a human."
    ],
    "question": "Hulu is dirt.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nEat(x) ::: x eats.\nPlant(x) ::: x is a plant.\nAnimal(x) ::: x is an animal.\nGoat(x) ::: x is a goat.\nDirt(x) ::: x is dirt.\nHuman(x) ::: x is a human.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x Eat(x) ::: All humans eat.\n∀x (Eat(x) → ¬Plant(x)) ::: If something eats, then it is not a plant.\n∀x (Plant(x) ∨ Animal(x)) ::: A thing is either a plant or an animal.\n∀x (Goat(x) → Animal(x)) ::: All goats are animals.\n∀x (Dirt(x) → ¬Animal(x)) ::: No dirt is an animal.\n(Hulu(goat) ∨ Human(hulu)) ::: Hulu is a goat or a human.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬Dirt(hulu) ::: Hulu is not dirt.\n\"\"\""
    ]
  },
  {
    "id": 1380,
    "context": [
      "All humans eat.",
      "If something eats, then it is not a plant.",
      "A thing is either plant or animal.",
      "All goats are animals.",
      "No dirt is an animal.",
      "Hulu is a goat or a human."
    ],
    "question": "Hulu is an animal or dirt.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nEat(x) ::: x eats.\nPlant(x) ::: x is a plant.\nAnimal(x) ::: x is an animal.\nGoat(x) ::: x is a goat.\nHuman(x) ::: x is a human.\nDirt(x) ::: x is dirt.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x Eat(x) ::: All humans eat.\n∀x (Eat(x) → ¬Plant(x)) ::: If something eats, then it is not a plant.\n∀x (Plant(x) ∨ Animal(x)) ::: A thing is either a plant or an animal.\n∀x (Goat(x) → Animal(x)) ::: All goats are animals.\n∀x (¬Dirt(x) ∨ ¬Animal(x)) ::: No dirt is an animal.\n(Goat(hulu) ∨ Human(hulu)) ::: Hulu is a goat or a human.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nAnimal(hulu) ∨ Dirt(hulu) ::: Hulu is an animal or dirt.\n\"\"\""
    ]
  },
  {
    "id": 1381,
    "context": [
      "All humans eat.",
      "If something eats, then it is not a plant.",
      "A thing is either plant or animal.",
      "All goats are animals.",
      "No dirt is an animal.",
      "Hulu is a goat or a human."
    ],
    "question": "Hulu is either an animal or dirt.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nEat(x) ::: x eats.\nPlant(x) ::: x is a plant.\nAnimal(x) ::: x is an animal.\nGoat(x) ::: x is a goat.\nHuman(x) ::: x is a human.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x Eat(x) ::: All humans eat.\n∀x (Eat(x) → ¬Plant(x)) ::: If something eats, then it is not a plant.\n∀x (Plant(x) ∨ Animal(x)) ::: A thing is either a plant or an animal.\n∀x (Goat(x) → Animal(x)) ::: All goats are animals.\n∀x (¬Dirt(x) ∨ ¬Animal(x)) ::: No dirt is an animal.\n(Goat(hulu) ∨ Human(hulu)) ::: Hulu is a goat or a human.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nAnimal(hulu) ∨ Dirt(hulu) ::: Hulu is either an animal or dirt.\n\"\"\""
    ]
  },
  {
    "id": 1382,
    "context": [
      "All humans eat.",
      "If something eats, then it is not a plant.",
      "A thing is either plant or animal.",
      "All goats are animals.",
      "No dirt is an animal.",
      "Hulu is a goat or a human."
    ],
    "question": "If Hulu is either an animal or dirt, then Hulu eats and is dirt.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nEat(x) ::: x eats.\nPlant(x) ::: x is a plant.\nAnimal(x) ::: x is an animal.\nGoat(x) ::: x is a goat.\nDirt(x) ::: x is dirt.\nHuman(x) ::: x is a human.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x Eat(x) ::: All humans eat.\n∀x (Eat(x) → ¬Plant(x)) ::: If something eats, then it is not a plant.\n∀x (Plant(x) ⊕ Animal(x)) ::: A thing is either a plant or an animal.\n∀x (Goat(x) → Animal(x)) ::: All goats are animals.\n∀x (Dirt(x) → ¬Animal(x)) ::: No dirt is an animal.\n(Goat(hulu) ∨ Human(hulu)) ::: Hulu is a goat or a human.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n((Animal(hulu) ∨ Dirt(hulu)) → (Eat(hulu) ∧ Dirt(hulu))) ::: If Hulu is either an animal or dirt, then Hulu eats and is dirt.\n\"\"\""
    ]
  },
  {
    "id": 136,
    "context": [
      "A controlled substance is a drug.",
      "There exist both harmful and beneficial controlled substances.",
      "If a child is exposed to a controlled substance, he or she is in chemical endangerment.",
      "Chemical Endangerment is harmful. ",
      "The Controlled Substances Act was an act passed in 1971.",
      "Some Acts prevent harmful things."
    ],
    "question": "The Controlled Substances Act prevents harmful things.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nControlledSubstance(x) ::: x is a controlled substance.\nDrug(x) ::: x is a drug.\nHarmful(x) ::: x is harmful.\nBeneficial(x) ::: x is beneficial.\nExposure(x, y) ::: x is exposed to y.\nChemicalEndangerment(x) ::: x is in chemical endangerment.\nAct(x) ::: x is an act.\nPassed(x, y) ::: x was passed in year y.\nPrevent(x, y) ::: x prevents y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (ControlledSubstance(x) → Drug(x)) ::: A controlled substance is a drug.\n∃x (ControlledSubstance(x) ∧ Harmful(x)) ∧ ∃y (ControlledSubstance(y) ∧ Beneficial(y)) ::: There exist both harmful and beneficial controlled substances.\n∀x (Child(x) ∧ Exposure(x, ControlledSubstance) → ChemicalEndangerment(x)) ::: If a child is exposed to a controlled substance, he or she is in chemical endangerment.\nHarmful(ChemicalEndangerment) ::: Chemical Endangerment is harmful.\nAct(controlledSubstancesAct) ∧ Passed(controlledSubstancesAct, year1971) ::: The Controlled Substances Act was an act passed in 1971.\n∃x (Act(x) ∧ Prevent(x, harmfulThings)) ::: Some Acts prevent harmful things.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nPrevent(controlledSubstancesAct, harmfulThings) ::: The Controlled Substances Act prevents harmful things.\n\"\"\""
    ]
  },
  {
    "id": 137,
    "context": [
      "A controlled substance is a drug.",
      "There exist both harmful and beneficial controlled substances.",
      "If a child is exposed to a controlled substance, he or she is in chemical endangerment.",
      "Chemical Endangerment is harmful. ",
      "The Controlled Substances Act was an act passed in 1971.",
      "Some Acts prevent harmful things."
    ],
    "question": "Some drugs are beneficial.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nControlledSubstance(x) ::: x is a controlled substance.\nDrug(x) ::: x is a drug.\nHarmful(x) ::: x is harmful.\nBeneficial(x) ::: x is beneficial.\nExposure(x, y) ::: x is exposed to y.\nChemicalEndangerment(x) ::: x is in chemical endangerment.\nAct(x) ::: x is an act.\nPassed(x, y) ::: x was passed in year y.\nPrevent(x, y) ::: x prevents y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (ControlledSubstance(x) → Drug(x)) ::: A controlled substance is a drug.\n∃x (ControlledSubstance(x) ∧ Harmful(x)) ∧ ∃y (ControlledSubstance(y) ∧ Beneficial(y)) ::: There exist both harmful and beneficial controlled substances.\n∀x (Child(x) ∧ Exposure(x, ControlledSubstance) → ChemicalEndangerment(x)) ::: If a child is exposed to a controlled substance, he or she is in chemical endangerment.\n∀x (ChemicalEndangerment(x) → Harmful(x)) ::: Chemical Endangerment is harmful.\nAct(controlledSubstancesAct) ∧ Passed(controlledSubstancesAct, year1971) ::: The Controlled Substances Act was an act passed in 1971.\n∃x (Act(x) ∧ Prevent(x, harmfulThings)) ::: Some Acts prevent harmful things.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n∃x (Drug(x) ∧ Beneficial(x)) ::: Some drugs are beneficial.\n\"\"\""
    ]
  },
  {
    "id": 138,
    "context": [
      "A controlled substance is a drug.",
      "There exist both harmful and beneficial controlled substances.",
      "If a child is exposed to a controlled substance, he or she is in chemical endangerment.",
      "Chemical Endangerment is harmful. ",
      "The Controlled Substances Act was an act passed in 1971.",
      "Some Acts prevent harmful things."
    ],
    "question": "A child in chemical endangerment is in harm.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nControlledSubstance(x) ::: x is a controlled substance.\nDrug(x) ::: x is a drug.\nHarmful(x) ::: x is harmful.\nBeneficial(x) ::: x is beneficial.\nExposure(x, y) ::: x is exposed to y.\nChemicalEndangerment(x) ::: x is in chemical endangerment.\nAct(x) ::: x is an act.\nPassed(x, y) ::: x was passed in year y.\nPrevent(x, y) ::: x prevents y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (ControlledSubstance(x) → Drug(x)) ::: A controlled substance is a drug.\n∃x (ControlledSubstance(x) ∧ Harmful(x)) ∧ ∃y (ControlledSubstance(y) ∧ Beneficial(y)) ::: There exist both harmful and beneficial controlled substances.\n∀x (Child(x) ∧ Exposure(x, ControlledSubstance) → ChemicalEndangerment(x)) ::: If a child is exposed to a controlled substance, he or she is in chemical endangerment.\nHarmful(ChemicalEndangerment) ::: Chemical Endangerment is harmful.\nAct(controlledSubstancesAct) ∧ Passed(controlledSubstancesAct, year1971) ::: The Controlled Substances Act was an act passed in 1971.\n∃x (Act(x) ∧ Prevent(x, harmfulThings)) ::: Some Acts prevent harmful things.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nHarmful(ChemicalEndangerment(child)) ::: A child in chemical endangerment is in harm.\n\"\"\""
    ]
  },
  {
    "id": 821,
    "context": [
      "No people who work at corporate jobs are starting a new company.",
      "All entrepreneurs are starting a new company.",
      "All risk-averse people are people who work at corporate jobs.",
      "All people who hate working for others are entrepreneurs.",
      "If Mark Zuckerberg is neither an entrepreneur nor a person who hates working for others, then Mark Zuckerberg is not a risk-averse person."
    ],
    "question": "Mark Zuckerberg is an entrepreneur.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nCorporateJob(x) ::: x works at a corporate job.\nStartCompany(x) ::: x is starting a new company.\nEntrepreneur(x) ::: x is an entrepreneur.\nRiskAverse(x) ::: x is risk-averse.\nHateWorkForOthers(x) ::: x hates working for others.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (CorporateJob(x) → ¬StartCompany(x)) ::: No people who work at corporate jobs are starting a new company.\n∀x (Entrepreneur(x) → StartCompany(x)) ::: All entrepreneurs are starting a new company.\n∀x (RiskAverse(x) → CorporateJob(x)) ::: All risk-averse people are people who work at corporate jobs.\n∀x (HateWorkForOthers(x) → Entrepreneur(x)) ::: All people who hate working for others are entrepreneurs.\n¬(Entrepreneur(markZuckerberg) ∨ HateWorkForOthers(markZuckerberg)) → ¬RiskAverse(markZuckerberg) ::: If Mark Zuckerberg is neither an entrepreneur nor a person who hates working for others, then Mark Zuckerberg is not a risk-averse person.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nEntrepreneur(markZuckerberg) ::: Mark Zuckerberg is an entrepreneur.\n\"\"\""
    ]
  },
  {
    "id": 822,
    "context": [
      "No people who work at corporate jobs are starting a new company.",
      "All entrepreneurs are starting a new company.",
      "All risk-averse people are people who work at corporate jobs.",
      "All people who hate working for others are entrepreneurs.",
      "If Mark Zuckerberg is neither an entrepreneur nor a person who hates working for others, then Mark Zuckerberg is not a risk-averse person."
    ],
    "question": "Mark Zuckerberg is a risk-averse person.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nCorporate(x) ::: x works at corporate jobs.\nStartCompany(x) ::: x is starting a new company.\nEntrepreneur(x) ::: x is an entrepreneur.\nRiskAverse(x) ::: x is risk-averse.\nHateWork(x) ::: x hates working for others.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n¬∃x (Corporate(x) ∧ StartCompany(x)) ::: No people who work at corporate jobs are starting a new company.\n∀x (Entrepreneur(x) → StartCompany(x)) ::: All entrepreneurs are starting a new company.\n∀x (RiskAverse(x) → Corporate(x)) ::: All risk-averse people are people who work at corporate jobs.\n∀x (HateWork(x) → Entrepreneur(x)) ::: All people who hate working for others are entrepreneurs.\n¬(Entrepreneur(markZuckerberg) ∨ HateWork(markZuckerberg)) → ¬RiskAverse(markZuckerberg) ::: If Mark Zuckerberg is neither an entrepreneur nor a person who hates working for others, then Mark Zuckerberg is not a risk-averse person.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nRiskAverse(markZuckerberg) ::: Mark Zuckerberg is a risk-averse person.\n\"\"\""
    ]
  },
  {
    "id": 823,
    "context": [
      "No people who work at corporate jobs are starting a new company.",
      "All entrepreneurs are starting a new company.",
      "All risk-averse people are people who work at corporate jobs.",
      "All people who hate working for others are entrepreneurs.",
      "If Mark Zuckerberg is neither an entrepreneur nor a person who hates working for others, then Mark Zuckerberg is not a risk-averse person."
    ],
    "question": "Mark Zuckerberg is not a risk-averse person.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nCorporateJob(x) ::: x works at a corporate job.\nStartCompany(x) ::: x is starting a new company.\nEntrepreneur(x) ::: x is an entrepreneur.\nRiskAverse(x) ::: x is risk-averse.\nHateWork(x) ::: x hates working for others.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (CorporateJob(x) → ¬StartCompany(x)) ::: No people who work at corporate jobs are starting a new company.\n∀x (Entrepreneur(x) → StartCompany(x)) ::: All entrepreneurs are starting a new company.\n∀x (RiskAverse(x) → CorporateJob(x)) ::: All risk-averse people are people who work at corporate jobs.\n∀x (HateWork(x) → Entrepreneur(x)) ::: All people who hate working for others are entrepreneurs.\n¬(Entrepreneur(markZuckerberg) ∨ HateWork(markZuckerberg)) → ¬RiskAverse(markZuckerberg) ::: If Mark Zuckerberg is neither an entrepreneur nor a person who hates working for others, then Mark Zuckerberg is not a risk-averse person.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬RiskAverse(markZuckerberg) ::: Mark Zuckerberg is not a risk-averse person.\n\"\"\""
    ]
  },
  {
    "id": 573,
    "context": [
      "There are two kitchens in the house: the upstairs kitchen and the downstairs kitchen.",
      "When someone is cooking in the downstairs kitchen, the first floor becomes smokey unless the air conditioner is running.",
      "If the air conditioner is running and someone is cooking in the downstairs kitchen, all the smoke travels to the second floor."
    ],
    "question": "If someone is cooking downstairs, it will always cause the first floor to become smokey.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nKitchen(x) ::: x is a kitchen.\nUpstairs(x) ::: x is the upstairs kitchen.\nDownstairs(x) ::: x is the downstairs kitchen.\nCooking(x) ::: x is cooking.\nSmokey(x) ::: x is smokey.\nAirConditioner(x) ::: x is the air conditioner.\nRunning(x) ::: x is running.\nSmokeTravel(x) ::: x is smoke traveling.\nFirstFloor(x) ::: x is the first floor.\nSecondFloor(x) ::: x is the second floor.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nKitchen(upstairs) ∧ Kitchen(downstairs) ∧ ¬(upstairs = downstairs) ::: There are two kitchens in the house: the upstairs kitchen and the downstairs kitchen.\n∀x (Cooking(downstairs) → (Smokey(firstFloor) ↔ Running(airConditioner))) ::: When someone is cooking in the downstairs kitchen, the first floor becomes smokey unless the air conditioner is running.\n(Running(airConditioner) ∧ Cooking(downstairs)) → SmokeTravel(secondFloor) ::: If the air conditioner is running and someone is cooking in the downstairs kitchen, all the smoke travels to the second floor.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nCooking(downstairs) → Smokey(firstFloor) ::: If someone is cooking downstairs, it will always cause the first floor to become smokey.\n\"\"\""
    ]
  },
  {
    "id": 574,
    "context": [
      "There are two kitchens in the house: the upstairs kitchen and the downstairs kitchen.",
      "When someone is cooking in the downstairs kitchen, the first floor becomes smokey unless the air conditioner is running.",
      "If the air conditioner is running and someone is cooking in the downstairs kitchen, all the smoke travels to the second floor."
    ],
    "question": "If someone is cooking upstairs, the first floor will become smokey.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nKitchen(x) ::: x is a kitchen.\nUpstairs(x) ::: x is the upstairs kitchen.\nDownstairs(x) ::: x is the downstairs kitchen.\nCooking(x) ::: x is cooking.\nSmoke(x) ::: x is smokey.\nAirConditioner(x) ::: x is the air conditioner.\nRunning(x) ::: x is running.\nTravel(x, y) ::: x travels to y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nKitchen(upstairs) ∧ Kitchen(downstairs) ∧ ¬(upstairs = downstairs) ::: There are two kitchens in the house: the upstairs kitchen and the downstairs kitchen.\n∀x (Cooking(downstairs) → (Smoke(firstFloor) ↔ Running(airConditioner))) ::: When someone is cooking in the downstairs kitchen, the first floor becomes smokey unless the air conditioner is running.\n(Running(airConditioner) ∧ Cooking(downstairs)) → Travel(Smoke(firstFloor), secondFloor) ::: If the air conditioner is running and someone is cooking in the downstairs kitchen, all the smoke travels to the second floor.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nCooking(upstairs) → Smoke(firstFloor) ::: If someone is cooking upstairs, the first floor will become smokey.\n\"\"\""
    ]
  },
  {
    "id": 575,
    "context": [
      "There are two kitchens in the house: the upstairs kitchen and the downstairs kitchen.",
      "When someone is cooking in the downstairs kitchen, the first floor becomes smokey unless the air conditioner is running.",
      "If the air conditioner is running and someone is cooking in the downstairs kitchen, all the smoke travels to the second floor."
    ],
    "question": "If someone is cooking downstairs and the air conditioner is running, there will be smoke upstairs.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nKitchen(x) ::: x is a kitchen.\nUpstairs(x) ::: x is the upstairs kitchen.\nDownstairs(x) ::: x is the downstairs kitchen.\nCooking(x) ::: x is cooking.\nSmoke(x) ::: x is smoke.\nAirConditioner(x) ::: x is the air conditioner.\nRunning(x) ::: x is running.\nTravel(x, y) ::: x travels to y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nKitchen(upstairs) ∧ Kitchen(downstairs) ∧ ¬(upstairs = downstairs) ::: There are two kitchens in the house: the upstairs kitchen and the downstairs kitchen.\n∀x (Cooking(x, downstairs) → (Smoke(firstFloor) ↔ Running(airConditioner))) ::: When someone is cooking in the downstairs kitchen, the first floor becomes smokey unless the air conditioner is running.\n(Running(airConditioner) ∧ Cooking(downstairs)) → Travel(Smoke(firstFloor), secondFloor) ::: If the air conditioner is running and someone is cooking in the downstairs kitchen, all the smoke travels to the second floor.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nCooking(downstairs) ∧ Running(airConditioner) → Smoke(upstairs) ::: If someone is cooking downstairs and the air conditioner is running, there will be smoke upstairs.\n\"\"\""
    ]
  },
  {
    "id": 377,
    "context": [
      "New York City is Located in the United States of America.",
      "United States of America is part of North America.",
      "North America is in the western hemisphere of the earth.",
      "New York City is a highly developed city.",
      "If place A is located in place B and place B is located in place C, then place A is located in place C."
    ],
    "question": "A highly developed city is located in the western hemisphere of the earth.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nLocatedIn(x, y) ::: x is located in y.\nPartOf(x, y) ::: x is part of y.\nHighlyDevelopedCity(x) ::: x is a highly developed city.\nInWesternHemisphere(x) ::: x is in the western hemisphere of the earth.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nLocatedIn(newYorkCity, unitedStates) ::: New York City is Located in the United States of America.\nPartOf(unitedStates, northAmerica) ::: United States of America is part of North America.\nPartOf(northAmerica, westernHemisphere) ::: North America is in the western hemisphere of the earth.\nHighlyDevelopedCity(newYorkCity) ::: New York City is a highly developed city.\n∀x ∀y ∀z ((LocatedIn(x, y) ∧ LocatedIn(y, z)) → LocatedIn(x, z)) ::: If place A is located in place B and place B is located in place C, then place A is located in place C.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n∃x (HighlyDevelopedCity(x) ∧ LocatedIn(x, westernHemisphere)) ::: A highly developed city is located in the western hemisphere of the earth.\n\"\"\""
    ]
  },
  {
    "id": 378,
    "context": [
      "New York City is Located in the United States of America.",
      "United States of America is part of North America.",
      "North America is in the western hemisphere of the earth.",
      "New York City is a highly developed city.",
      "If place A is located in place B and place B is located in place C, then place A is located in place C."
    ],
    "question": "USA is not located in western hemisphere of the earth.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nLocatedIn(x, y) ::: x is located in y.\nPartOf(x, y) ::: x is part of y.\nHighlyDeveloped(x) ::: x is a highly developed city.\nInWesternHemisphere(x) ::: x is in the western hemisphere of the earth.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nLocatedIn(newYorkCity, USA) ::: New York City is Located in the United States of America.\nPartOf(USA, northAmerica) ::: United States of America is part of North America.\nPartOf(northAmerica, westernHemisphere) ::: North America is in the western hemisphere of the earth.\nHighlyDeveloped(newYorkCity) ::: New York City is a highly developed city.\n∀x ∀y ∀z ((LocatedIn(x, y) ∧ LocatedIn(y, z)) → LocatedIn(x, z)) ::: If place A is located in place B and place B is located in place C, then place A is located in place C.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬LocatedIn(USA, westernHemisphere) ::: USA is not located in western hemisphere of the earth.\n\"\"\""
    ]
  },
  {
    "id": 379,
    "context": [
      "New York City is Located in the United States of America.",
      "United States of America is part of North America.",
      "North America is in the western hemisphere of the earth.",
      "New York City is a highly developed city.",
      "If place A is located in place B and place B is located in place C, then place A is located in place C."
    ],
    "question": "New York City is located in the New York State.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nLocatedIn(x, y) ::: x is located in y.\nPartOf(x, y) ::: x is part of y.\nHighlyDeveloped(x) ::: x is a highly developed city.\nInWesternHemisphere(x) ::: x is in the western hemisphere of the earth.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nLocatedIn(newYorkCity, unitedStates) ::: New York City is Located in the United States of America.\nPartOf(unitedStates, northAmerica) ::: United States of America is part of North America.\nInWesternHemisphere(northAmerica) ::: North America is in the western hemisphere of the earth.\nHighlyDeveloped(newYorkCity) ::: New York City is a highly developed city.\n∀x ∀y ∀z ((LocatedIn(x, y) ∧ LocatedIn(y, z)) → LocatedIn(x, z)) ::: If place A is located in place B and place B is located in place C, then place A is located in place C.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nLocatedIn(newYorkCity, newYorkState) ::: New York City is located in the New York State.\n\"\"\""
    ]
  },
  {
    "id": 429,
    "context": [
      "Callus 4 is a poem that was written by the ancient Roman writer Catullus.",
      "Callus 4 is a story about the retirement of a well-traveled ship.",
      "There is a strong analogy of human aging in the poem Callus 4.",
      "Callus 4 is written in an unusual iambic trimeter to convey a sense of speed over the waves."
    ],
    "question": "There exists a poem written by an ancient Roman writer with a strong analogy of human aging.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nPoem(x) ::: x is a poem.\nWrittenBy(x, y) ::: x is written by y.\nAbout(x, y) ::: x is about y.\nAnalogy(x, y) ::: x has an analogy of y.\nWrittenIn(x, y) ::: x is written in y.\nConvey(x, y) ::: x conveys a sense of y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nPoem(callus4) ∧ WrittenBy(callus4, catullus) ::: Callus 4 is a poem that was written by the ancient Roman writer Catullus.\nAbout(callus4, retirementOfWellTraveledShip) ::: Callus 4 is a story about the retirement of a well-traveled ship.\nAnalogy(callus4, humanAging) ::: There is a strong analogy of human aging in the poem Callus 4.\nWrittenIn(callus4, iambicTrimeter) ∧ Convey(callus4, speedOverWaves) ::: Callus 4 is written in an unusual iambic trimeter to convey a sense of speed over the waves.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n∃x (Poem(x) ∧ WrittenBy(x, ancientRomanWriter) ∧ Analogy(x, humanAging)) ::: There exists a poem written by an ancient Roman writer with a strong analogy of human aging.\n\"\"\""
    ]
  },
  {
    "id": 430,
    "context": [
      "Callus 4 is a poem that was written by the ancient Roman writer Catullus.",
      "Callus 4 is a story about the retirement of a well-traveled ship.",
      "There is a strong analogy of human aging in the poem Callus 4.",
      "Callus 4 is written in an unusual iambic trimeter to convey a sense of speed over the waves."
    ],
    "question": "There exists a poem written by an ancient Roman writer written in iambic petameter.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nPoem(x) ::: x is a poem.\nWrittenBy(x, y) ::: x was written by y.\nAbout(x, y) ::: x is a story about y.\nAnalogy(x, y) ::: x has an analogy of y.\nWrittenIn(x, y) ::: x is written in y.\nConvey(x, y) ::: x conveys a sense of y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nPoem(callus4) ∧ WrittenBy(callus4, catullus) ::: Callus 4 is a poem that was written by the ancient Roman writer Catullus.\nAbout(callus4, retirementOfWellTraveledShip) ::: Callus 4 is a story about the retirement of a well-traveled ship.\nAnalogy(callus4, humanAging) ::: There is a strong analogy of human aging in the poem Callus 4.\nWrittenIn(callus4, iambicTrimeter) ∧ Convey(callus4, speedOverWaves) ::: Callus 4 is written in an unusual iambic trimeter to convey a sense of speed over the waves.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n∃x (Poem(x) ∧ WrittenBy(x, ancientRomanWriter) ∧ WrittenIn(x, iambicPentameter)) ::: There exists a poem written by an ancient Roman writer written in iambic petameter.\n\"\"\""
    ]
  },
  {
    "id": 431,
    "context": [
      "Callus 4 is a poem that was written by the ancient Roman writer Catullus.",
      "Callus 4 is a story about the retirement of a well-traveled ship.",
      "There is a strong analogy of human aging in the poem Callus 4.",
      "Callus 4 is written in an unusual iambic trimeter to convey a sense of speed over the waves."
    ],
    "question": "Callus 4 is written in an unusual iambic trimeter to convey a strong analogy of human aging.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nPoem(x) ::: x is a poem.\nWrittenBy(x, y) ::: x was written by y.\nStoryAbout(x, y) ::: x is a story about y.\nAnalogyOf(x, y) ::: x has a strong analogy of y.\nWrittenIn(x, y) ::: x is written in y.\nConvey(x, y) ::: x conveys a sense of y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nPoem(callus4) ∧ WrittenBy(callus4, catullus) ::: Callus 4 is a poem that was written by the ancient Roman writer Catullus.\nStoryAbout(callus4, retirementOfWellTraveledShip) ::: Callus 4 is a story about the retirement of a well-traveled ship.\nAnalogyOf(callus4, humanAging) ::: There is a strong analogy of human aging in the poem Callus 4.\nWrittenIn(callus4, iambicTrimeter) ∧ Convey(callus4, speedOverWaves) ::: Callus 4 is written in an unusual iambic trimeter to convey a sense of speed over the waves.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nWrittenIn(callus4, iambicTrimeter) ∧ Convey(callus4, humanAging) ::: Callus 4 is written in an unusual iambic trimeter to convey a strong analogy of human aging.\n\"\"\""
    ]
  },
  {
    "id": 671,
    "context": [
      "Westworld is an American science fiction-thriller TV series.",
      "In 2016, a new television series named Westworld debuted on HBO.",
      "The TV series Westworld is adapted from the original film in 1973, which was written and directed by Michael Crichton.",
      "The 1973 film Westworld is about robots that malfunction and begin killing the human visitors."
    ],
    "question": "Michael Crichton has directed a film about robots.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nAmerican(x) ::: x is American.\nTVSeries(x) ::: x is a TV series.\nScienceFictionThriller(x) ::: x is a science fiction-thriller.\nDebut(x, y) ::: x debuted in year y.\nAdaptedFrom(x, y) ::: x is adapted from y.\nFilm(x) ::: x is a film.\nWrite(x, y) ::: x is written by y.\nDirect(x, y) ::: x is directed by y.\nAbout(x, y) ::: x is about y.\nMalfunction(x) ::: x malfunctioned.\nKill(x, y) ::: x killed y.\nHuman(x) ::: x is a human.\nVisitor(x) ::: x is a visitor.\nRobot(x) ::: x is a robot.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nAmerican(westworld) ∧ TVSeries(westworld) ∧ ScienceFictionThriller(westworld) ::: Westworld is an American science fiction-thriller TV series.\nDebut(westworld, year2016) ::: In 2016, a new television series named Westworld debuted on HBO.\nAdaptedFrom(westworld, film1973) ∧ Write(film1973, michaelCrichton) ∧ Direct(film1973, michaelCrichton) ::: The TV series Westworld is adapted from the original film in 1973, which was written and directed by Michael Crichton.\nAbout(film1973, malfunction(robot) ∧ Kill(robot, human)) ::: The 1973 film Westworld is about robots that malfunction and begin killing the human visitors.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n∃x (Direct(x, michaelCrichton) ∧ About(x, robots)) ::: Michael Crichton has directed a film about robots.\n\"\"\""
    ]
  },
  {
    "id": 672,
    "context": [
      "Westworld is an American science fiction-thriller TV series.",
      "In 2016, a new television series named Westworld debuted on HBO.",
      "The TV series Westworld is adapted from the original film in 1973, which was written and directed by Michael Crichton.",
      "The 1973 film Westworld is about robots that malfunction and begin killing the human visitors."
    ],
    "question": "An American TV series debuted in 2016.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nAmerican(x) ::: x is an American TV series.\nTVSeries(x) ::: x is a TV series.\nDebut(x, y) ::: x debuted in year y.\nAdaptedFrom(x, y) ::: x is adapted from y.\nFilm(x) ::: x is a film.\nWrittenBy(x, y) ::: x is written by y.\nDirectedBy(x, y) ::: x is directed by y.\nAbout(x, y) ::: x is about y.\nMalfunction(x) ::: x malfunctioned.\nKill(x, y) ::: x killed y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nTVSeries(westworld) ∧ American(westworld) ∧ ScienceFictionThriller(westworld) ::: Westworld is an American science fiction-thriller TV series.\nDebut(westworld, year2016) ∧ TVSeries(westworld) ::: In 2016, a new television series named Westworld debuted on HBO.\nAdaptedFrom(westworld, film1973) ∧ WrittenBy(film1973, michaelCrichton) ∧ DirectedBy(film1973, michaelCrichton) ::: The TV series Westworld is adapted from the original film in 1973, which was written and directed by Michael Crichton.\nFilm(film1973) ∧ About(film1973, malfunctioningRobotsKillingHumans) ::: The 1973 film Westworld is about robots that malfunction and begin killing the human visitors.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n∃x (American(x) ∧ Debut(x, year2016)) ::: An American TV series debuted in 2016.\n\"\"\""
    ]
  },
  {
    "id": 659,
    "context": [
      "The 2008 Summer Olympics were held in Beijing, China.",
      "The 2008 Summer Olympics were the second Summer Olympic Games to be held in a communist state.",
      "China won the most gold medals (48) in the 2008 Summer Olympics.",
      "The United States placed second in the gold medal tally but won the highest number of medals overall (112) in the 2008 Summer Olympics.",
      "The third place in the gold medal tally was achieved by Russia in the 2008 Summer Olympics.",
      "If a country places third in gold medals, then they had fewer gold medals than the team that won the most gold medals.",
      "87 countries won at least one medal during the 2008 Games."
    ],
    "question": "Russia did not win fewer gold medals than China.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nHeldIn(x, y) ::: x was held in y.\nCommunistState(x) ::: x is a communist state.\nWonMostGold(x, y) ::: x won the most gold medals in y.\nPlacedSecondGold(x, y) ::: x placed second in the gold medal tally in y.\nWonMostMedals(x, y) ::: x won the highest number of medals overall in y.\nPlacedThirdGold(x, y) ::: x placed third in the gold medal tally in y.\nWonMedal(x) ::: x won at least one medal.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nHeldIn(2008SummerOlympics, Beijing) ∧ HeldIn(2008SummerOlympics, China) ::: The 2008 Summer Olympics were held in Beijing, China.\nHeldIn(2008SummerOlympics, communistState) ∧ Second(2008SummerOlympics, communistState) ::: The 2008 Summer Olympics were the second Summer Olympic Games to be held in a communist state.\nWonMostGold(China, 2008SummerOlympics) ∧ GoldMedals(China, 48) ::: China won the most gold medals (48) in the 2008 Summer Olympics.\nPlacedSecondGold(UnitedStates, 2008SummerOlympics) ∧ WonMostMedals(UnitedStates, 112) ::: The United States placed second in the gold medal tally but won the highest number of medals overall (112) in the 2008 Summer Olympics.\nPlacedThirdGold(Russia, 2008SummerOlympics) ::: The third place in the gold medal tally was achieved by Russia in the 2008 Summer Olympics.\n∀x (PlacedThirdGold(x, 2008SummerOlympics) → GoldMedals(x, 2008SummerOlympics) < GoldMedals(China, 2008SummerOlympics)) ::: If a country places third in gold medals, then they had fewer gold medals than the team that won the most gold medals.\n∃x (WonMedal(x) ∧ Year(x, 2008)) ∧ NumberCountries(x, 87) ::: 87 countries won at least one medal during the 2008 Games.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬(GoldMedals(Russia, 2008SummerOlympics) < GoldMedals(China, 2008SummerOlympics)) ::: Russia did not win fewer gold medals than China.\n\"\"\""
    ]
  },
  {
    "id": 660,
    "context": [
      "The 2008 Summer Olympics were held in Beijing, China.",
      "The 2008 Summer Olympics were the second Summer Olympic Games to be held in a communist state.",
      "China won the most gold medals (48) in the 2008 Summer Olympics.",
      "The United States placed second in the gold medal tally but won the highest number of medals overall (112) in the 2008 Summer Olympics.",
      "The third place in the gold medal tally was achieved by Russia in the 2008 Summer Olympics.",
      "If a country places third in gold medals, then they had fewer gold medals than the team that won the most gold medals.",
      "87 countries won at least one medal during the 2008 Games."
    ],
    "question": "The United States won fewer gold medals than China.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nHeldIn(x, y) ::: x was held in y.\nCommunistState(x) ::: x is a communist state.\nWonMostGold(x, y) ::: x won the most gold medals in y.\nPlacedSecondGold(x, y) ::: x placed second in the gold medal tally in y.\nWonMostMedals(x, y) ::: x won the highest number of medals overall in y.\nPlacedThirdGold(x, y) ::: x placed third in the gold medal tally in y.\nWonMedal(x) ::: x won at least one medal.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nHeldIn(2008SummerOlympics, Beijing) ∧ HeldIn(2008SummerOlympics, China) ::: The 2008 Summer Olympics were held in Beijing, China.\nHeldIn(2008SummerOlympics, communistState) ∧ Second(2008SummerOlympics, communistState) ::: The 2008 Summer Olympics were the second Summer Olympic Games to be held in a communist state.\nWonMostGold(China, 2008SummerOlympics) ∧ NumberGoldMedals(China, 48) ::: China won the most gold medals (48) in the 2008 Summer Olympics.\nPlacedSecondGold(UnitedStates, 2008SummerOlympics) ∧ WonMostMedals(UnitedStates, 2008SummerOlympics) ∧ NumberTotalMedals(UnitedStates, 112) ::: The United States placed second in the gold medal tally but won the highest number of medals overall (112) in the 2008 Summer Olympics.\nPlacedThirdGold(Russia, 2008SummerOlympics) ::: The third place in the gold medal tally was achieved by Russia in the 2008 Summer Olympics.\n∀x (PlacedThirdGold(x, 2008SummerOlympics) → NumberGoldMedals(x, 2008SummerOlympics) < NumberGoldMedals(China, 2008SummerOlympics)) ::: If a country places third in gold medals, then they had fewer gold medals than the team that won the most gold medals.\n∃x (WonMedal(x) ∧ Year(x, 2008)) ∧ NumberCountries(87) ::: 87 countries won at least one medal during the 2008 Games.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nNumberGoldMedals(UnitedStates, 2008SummerOlympics) < NumberGoldMedals(China, 2008SummerOlympics) ::: The United States won fewer gold medals than China.\n\"\"\""
    ]
  },
  {
    "id": 661,
    "context": [
      "The 2008 Summer Olympics were held in Beijing, China.",
      "The 2008 Summer Olympics were the second Summer Olympic Games to be held in a communist state.",
      "China won the most gold medals (48) in the 2008 Summer Olympics.",
      "The United States placed second in the gold medal tally but won the highest number of medals overall (112) in the 2008 Summer Olympics.",
      "The third place in the gold medal tally was achieved by Russia in the 2008 Summer Olympics.",
      "If a country places third in gold medals, then they had fewer gold medals than the team that won the most gold medals.",
      "87 countries won at least one medal during the 2008 Games."
    ],
    "question": "Russia won fewer gold medals than China.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nHeldIn(x, y) ::: x was held in y.\nCommunistState(x) ::: x is a communist state.\nWonMostGold(x, y) ::: x won the most gold medals in y.\nPlacedSecondGold(x, y) ::: x placed second in the gold medal tally in y.\nWonMostMedals(x, y) ::: x won the highest number of medals overall in y.\nPlacedThirdGold(x, y) ::: x placed third in the gold medal tally in y.\nWonMedal(x) ::: x won at least one medal.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nHeldIn(2008SummerOlympics, Beijing) ∧ HeldIn(2008SummerOlympics, China) ::: The 2008 Summer Olympics were held in Beijing, China.\nHeldIn(2008SummerOlympics, communistState) ∧ Second(2008SummerOlympics, communistState) ::: The 2008 Summer Olympics were the second Summer Olympic Games to be held in a communist state.\nWonMostGold(China, 2008SummerOlympics) ∧ GoldMedals(China, 48) ::: China won the most gold medals (48) in the 2008 Summer Olympics.\nPlacedSecondGold(UnitedStates, 2008SummerOlympics) ∧ WonMostMedals(UnitedStates, 112) ::: The United States placed second in the gold medal tally but won the highest number of medals overall (112) in the 2008 Summer Olympics.\nPlacedThirdGold(Russia, 2008SummerOlympics) ::: The third place in the gold medal tally was achieved by Russia in the 2008 Summer Olympics.\n∀x (PlacedThirdGold(x, 2008SummerOlympics) → GoldMedals(x, 2008SummerOlympics) < GoldMedals(China, 2008SummerOlympics)) ::: If a country places third in gold medals, then they had fewer gold medals than the team that won the most gold medals.\n∃x (WonMedal(x) ∧ Year(x, 2008)) ∧ Number(x) ≥ 1 ::: 87 countries won at least one medal during the 2008 Games.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nGoldMedals(Russia, 2008SummerOlympics) < GoldMedals(China, 2008SummerOlympics) ::: Russia won fewer gold medals than China.\n\"\"\""
    ]
  },
  {
    "id": 78,
    "context": [
      "Xiufeng, Xiangshan, Diecai, Qixing are districts in the city of Guilin.",
      "Yangshuo is not a district in Guilin. "
    ],
    "question": "Xiangshan and Diecai are districts in the same city.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nDistrict(x) ::: x is a district.\nCity(x) ::: x is a city.\nSameCity(x, y) ::: x and y are in the same city.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nDistrict(xiufeng) ∧ District(xiangshan) ∧ District(diecai) ∧ District(qixing) ∧ City(guilin) ::: Xiufeng, Xiangshan, Diecai, Qixing are districts in the city of Guilin.\n¬District(yangshuo) ∧ City(guilin) ::: Yangshuo is not a district in Guilin.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nSameCity(xiangshan, diecai) ::: Xiangshan and Diecai are districts in the same city.\n\"\"\""
    ]
  },
  {
    "id": 79,
    "context": [
      "Xiufeng, Xiangshan, Diecai, Qixing are districts in the city of Guilin.",
      "Yangshuo is not a district in Guilin. "
    ],
    "question": "Xiufeng is in Guilin.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nDistrict(x) ::: x is a district.\nCity(x) ::: x is a city.\nIn(x, y) ::: x is in y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nDistrict(xiufeng) ∧ District(xiangshan) ∧ District(diecai) ∧ District(qixing) ∧ City(guilin) ∧ In(xiufeng, guilin) ∧ In(xiangshan, guilin) ∧ In(diecai, guilin) ∧ In(qixing, guilin) ::: Xiufeng, Xiangshan, Diecai, Qixing are districts in the city of Guilin.\n¬In(yangshuo, guilin) ::: Yangshuo is not a district in Guilin.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nIn(xiufeng, guilin) ::: Xiufeng is in Guilin.\n\"\"\""
    ]
  },
  {
    "id": 80,
    "context": [
      "Xiufeng, Xiangshan, Diecai, Qixing are districts in the city of Guilin.",
      "Yangshuo is not a district in Guilin. "
    ],
    "question": "Kowloon District is in Hong Kong.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nDistrict(x) ::: x is a district.\nCity(x) ::: x is a city.\nIn(x, y) ::: x is in y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nDistrict(xiufeng) ∧ District(xiangshan) ∧ District(diecai) ∧ District(qixing) ∧ City(guilin) ∧ In(xiufeng, guilin) ∧ In(xiangshan, guilin) ∧ In(diecai, guilin) ∧ In(qixing, guilin) ::: Xiufeng, Xiangshan, Diecai, Qixing are districts in the city of Guilin.\n¬District(yangshuo) ∧ City(guilin) ∧ ¬In(yangshuo, guilin) ::: Yangshuo is not a district in Guilin.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬In(kowloon, hongkong) ::: Kowloon District is in Hong Kong.\n\"\"\""
    ]
  },
  {
    "id": 1004,
    "context": [
      "All people who grow their own fresh vegetables in their home garden also have ample space.",
      "If people are young working professionals who live in large cities, then they do not have ample space.",
      "If people order takeout from delivery services often, then they grow their own fresh vegetables in their home garden.",
      "If people enjoy going out often to restaurants with friends, then they order takeout from delivery services often.",
      "If people regularly tout the benefits of homegrown and homecooked meals over fast food, then they enjoy going out often to restaurants with friends. ",
      "Michael grows his own fresh vegetables in his home garden or regularly touts the benefits of homegrown and homecooked meals over fast food."
    ],
    "question": "Michael enjoys going out often to restaurants with friends.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nGrow(x) ::: x grows their own fresh vegetables in their home garden.\nSpace(x) ::: x has ample space.\nYoung(x) ::: x is a young working professional who lives in large cities.\nOrder(x) ::: x orders takeout from delivery services often.\nEnjoy(x, y) ::: x enjoys going out often to restaurants with friends.\nTout(x) ::: x regularly touts the benefits of homegrown and homecooked meals over fast food.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Grow(x) → Space(x)) ::: All people who grow their own fresh vegetables in their home garden also have ample space.\n∀x (Young(x) ∧ Order(x) → ¬Space(x)) ::: If people are young working professionals who live in large cities, then they do not have ample space.\n∀x (Order(x) → Grow(x)) ::: If people order takeout from delivery services often, then they grow their own fresh vegetables in their home garden.\n∀x (Enjoy(x) → Order(x)) ::: If people enjoy going out often to restaurants with friends, then they order takeout from delivery services often.\n∀x (Tout(x) → Enjoy(x)) ::: If people regularly tout the benefits of homegrown and homecooked meals over fast food, then they enjoy going out often to restaurants with friends.\nGrow(michael) ∨ Tout(michael) ::: Michael grows his own fresh vegetables in his home garden or regularly touts the benefits of homegrown and homecooked meals over fast food.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nEnjoy(michael, friends) ::: Michael enjoys going out often to restaurants with friends.\n\"\"\""
    ]
  },
  {
    "id": 1005,
    "context": [
      "All people who grow their own fresh vegetables in their home garden also have ample space.",
      "If people are young working professionals who live in large cities, then they do not have ample space.",
      "If people order takeout from delivery services often, then they grow their own fresh vegetables in their home garden.",
      "If people enjoy going out often to restaurants with friends, then they order takeout from delivery services often.",
      "If people regularly tout the benefits of homegrown and homecooked meals over fast food, then they enjoy going out often to restaurants with friends. ",
      "Michael grows his own fresh vegetables in his home garden or regularly touts the benefits of homegrown and homecooked meals over fast food."
    ],
    "question": "Michael is a young working professional who lives in large cities.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nGrow(x) ::: x grows their own fresh vegetables in their home garden.\nSpace(x) ::: x has ample space.\nYoung(x) ::: x is a young working professional.\nCity(x) ::: x lives in large cities.\nOrder(x) ::: x orders takeout from delivery services often.\nEnjoy(x) ::: x enjoys going out often to restaurants with friends.\nTout(x) ::: x regularly touts the benefits of homegrown and homecooked meals over fast food.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Grow(x) → Space(x)) ::: All people who grow their own fresh vegetables in their home garden also have ample space.\n∀x ((Young(x) ∧ City(x)) → ¬Space(x)) ::: If people are young working professionals who live in large cities, then they do not have ample space.\n∀x (Order(x) → Grow(x)) ::: If people order takeout from delivery services often, then they grow their own fresh vegetables in their home garden.\n∀x (Enjoy(x) → Order(x)) ::: If people enjoy going out often to restaurants with friends, then they order takeout from delivery services often.\n∀x (Tout(x) → Enjoy(x)) ::: If people regularly tout the benefits of homegrown and homecooked meals over fast food, then they enjoy going out often to restaurants with friends.\nGrow(michael) ∨ Tout(michael) ::: Michael grows his own fresh vegetables in his home garden or regularly touts the benefits of homegrown and homecooked meals over fast food.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nYoung(michael) ∧ City(michael) ::: Michael is a young working professional who lives in large cities.\n\"\"\""
    ]
  },
  {
    "id": 1006,
    "context": [
      "All people who grow their own fresh vegetables in their home garden also have ample space.",
      "If people are young working professionals who live in large cities, then they do not have ample space.",
      "If people order takeout from delivery services often, then they grow their own fresh vegetables in their home garden.",
      "If people enjoy going out often to restaurants with friends, then they order takeout from delivery services often.",
      "If people regularly tout the benefits of homegrown and homecooked meals over fast food, then they enjoy going out often to restaurants with friends. ",
      "Michael grows his own fresh vegetables in his home garden or regularly touts the benefits of homegrown and homecooked meals over fast food."
    ],
    "question": "Michael grows his own fresh vegetables in their home garden or is a young working professional who lives in large cities.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nGrowOwnVegetables(x) ::: x grows their own fresh vegetables in their home garden.\nAmpleSpace(x) ::: x has ample space.\nYoungProfessional(x) ::: x is a young working professional who lives in large cities.\nOrderTakeout(x) ::: x orders takeout from delivery services often.\nEnjoyGoingOut(x) ::: x enjoys going out often to restaurants with friends.\nToutBenefits(x) ::: x regularly touts the benefits of homegrown and homecooked meals over fast food.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (GrowOwnVegetables(x) → AmpleSpace(x)) ::: All people who grow their own fresh vegetables in their home garden also have ample space.\n∀x (YoungProfessional(x) ∧ LiveInLargeCities(x) → ¬AmpleSpace(x)) ::: If people are young working professionals who live in large cities, then they do not have ample space.\n∀x (OrderTakeout(x) → GrowOwnVegetables(x)) ::: If people order takeout from delivery services often, then they grow their own fresh vegetables in their home garden.\n∀x (EnjoyGoingOut(x) → OrderTakeout(x)) ::: If people enjoy going out often to restaurants with friends, then they order takeout from delivery services often.\n∀x (ToutBenefits(x) → EnjoyGoingOut(x)) ::: If people regularly tout the benefits of homegrown and homecooked meals over fast food, then they enjoy going out often to restaurants with friends.\nGrowOwnVegetables(michael) ∨ ToutBenefits(michael) ::: Michael grows his own fresh vegetables in his home garden or regularly touts the benefits of homegrown and homecooked meals over fast food.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nGrowOwnVegetables(michael) ∨ YoungProfessional(michael) ∧ LiveInLargeCities(michael) ::: Michael grows his own fresh vegetables in their home garden or is a young working professional who lives in large cities.\n\"\"\""
    ]
  },
  {
    "id": 184,
    "context": [
      "All devices belonging to the company are connected to Google Home. ",
      "All devices belonging to employees are connected to the company's wifi. ",
      "All devices connected to Google Home are controlled by the managers. ",
      "All devices that connect to the company's wifi are easy to operate. ",
      "IPod1 belongs to employees. "
    ],
    "question": "iPod1 is easy to operate.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nBelongsToCompany(x) ::: x belongs to the company.\nConnectedToGoogleHome(x) ::: x is connected to Google Home.\nConnectedToWifi(x) ::: x is connected to the company's wifi.\nControlledByManagers(x) ::: x is controlled by the managers.\nEasyToOperate(x) ::: x is easy to operate.\nEmployee(x) ::: x is an employee.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (BelongsToCompany(x) → ConnectedToGoogleHome(x)) ::: All devices belonging to the company are connected to Google Home.\n∀x (Employee(x) → ConnectedToWifi(x)) ::: All devices belonging to employees are connected to the company's wifi.\n∀x (ConnectedToGoogleHome(x) → ControlledByManagers(x)) ::: All devices connected to Google Home are controlled by the managers.\n∀x (ConnectedToWifi(x) → EasyToOperate(x)) ::: All devices that connect to the company's wifi are easy to operate.\nEmployee(iPod1) ::: IPod1 belongs to employees.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nEasyToOperate(iPod1) ::: iPod1 is easy to operate.\n\"\"\""
    ]
  },
  {
    "id": 185,
    "context": [
      "All devices belonging to the company are connected to Google Home. ",
      "All devices belonging to employees are connected to the company's wifi. ",
      "All devices connected to Google Home are controlled by the managers. ",
      "All devices that connect to the company's wifi are easy to operate. ",
      "IPod1 belongs to employees. "
    ],
    "question": "iPod1 is controlled by managers.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nBelongsToCompany(x) ::: x belongs to the company.\nConnectedToGoogleHome(x) ::: x is connected to Google Home.\nConnectedToWifi(x) ::: x is connected to the company's wifi.\nControlledByManagers(x) ::: x is controlled by the managers.\nEasyToOperate(x) ::: x is easy to operate.\nBelongsToEmployees(x) ::: x belongs to employees.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (BelongsToCompany(x) → ConnectedToGoogleHome(x)) ::: All devices belonging to the company are connected to Google Home.\n∀x (BelongsToEmployees(x) → ConnectedToWifi(x)) ::: All devices belonging to employees are connected to the company's wifi.\n∀x (ConnectedToGoogleHome(x) → ControlledByManagers(x)) ::: All devices connected to Google Home are controlled by the managers.\n∀x (ConnectedToWifi(x) → EasyToOperate(x)) ::: All devices that connect to the company's wifi are easy to operate.\nBelongsToEmployees(iPod1) ::: IPod1 belongs to employees.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nControlledByManagers(iPod1) ::: iPod1 is controlled by managers.\n\"\"\""
    ]
  },
  {
    "id": 186,
    "context": [
      "All devices belonging to the company are connected to Google Home. ",
      "All devices belonging to employees are connected to the company's wifi. ",
      "All devices connected to Google Home are controlled by the managers. ",
      "All devices that connect to the company's wifi are easy to operate. ",
      "IPod1 belongs to employees. "
    ],
    "question": "iPod1 is connected to Google Home.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nBelongsToCompany(x) ::: x belongs to the company.\nConnectedToGoogleHome(x) ::: x is connected to Google Home.\nConnectedToWifi(x) ::: x is connected to the company's wifi.\nControlledByManagers(x) ::: x is controlled by the managers.\nEasyToOperate(x) ::: x is easy to operate.\nBelongsToEmployees(x) ::: x belongs to employees.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (BelongsToCompany(x) → ConnectedToGoogleHome(x)) ::: All devices belonging to the company are connected to Google Home.\n∀x (BelongsToEmployees(x) → ConnectedToWifi(x)) ::: All devices belonging to employees are connected to the company's wifi.\n∀x (ConnectedToGoogleHome(x) → ControlledByManagers(x)) ::: All devices connected to Google Home are controlled by the managers.\n∀x (ConnectedToWifi(x) → EasyToOperate(x)) ::: All devices that connect to the company's wifi are easy to operate.\nBelongsToEmployees(iPod1) ::: IPod1 belongs to employees.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nConnectedToGoogleHome(iPod1) ::: iPod1 is connected to Google Home.\n\"\"\""
    ]
  },
  {
    "id": 1135,
    "context": [
      "No touring musicians are permanent members of an orchestra.",
      "Musicians are either permanent members of an orchestra or have a unique musical voice or style.",
      "All musicians who have a unique musical voice or style are interesting as individual performers.",
      "All musicians who are interesting as individual performers are capable of attracting large audiences.",
      "If Ryan is interesting as an individual performer and has a unique musical voice or style, then Ryan is either a touring soloist musician and capable of attracting large audiences, or neither a touring soloist musician nor capable of attracting large audiences."
    ],
    "question": "Ryan is interesting as an individual performer.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nTouring(x) ::: x is a touring musician.\nPermanent(x) ::: x is a permanent member of an orchestra.\nMusician(x) ::: x is a musician.\nUniqueStyle(x) ::: x has a unique musical voice or style.\nInteresting(x) ::: x is interesting as an individual performer.\nCapable(x) ::: x is capable of attracting large audiences.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Touring(x) → ¬Permanent(x)) ::: No touring musicians are permanent members of an orchestra.\n∀x (Musician(x) → (Permanent(x) ∨ UniqueStyle(x))) ::: Musicians are either permanent members of an orchestra or have a unique musical voice or style.\n∀x (UniqueStyle(x) → Interesting(x)) ::: All musicians who have a unique musical voice or style are interesting as individual performers.\n∀x (Interesting(x) → Capable(x)) ::: All musicians who are interesting as individual performers are capable of attracting large audiences.\n(Interesting(ryan) ∧ UniqueStyle(ryan)) → (Touring(ryan) ∧ Capable(ryan)) ⊕ ¬(Touring(ryan) ∨ Capable(ryan)) ::: If Ryan is interesting as an individual performer and has a unique musical voice or style, then Ryan is either a touring soloist musician and capable of attracting large audiences, or neither a touring soloist musician nor capable of attracting large audiences.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nInteresting(ryan) ::: Ryan is interesting as an individual performer.\n\"\"\""
    ]
  },
  {
    "id": 1136,
    "context": [
      "No touring musicians are permanent members of an orchestra.",
      "Musicians are either permanent members of an orchestra or have a unique musical voice or style.",
      "All musicians who have a unique musical voice or style are interesting as individual performers.",
      "All musicians who are interesting as individual performers are capable of attracting large audiences.",
      "If Ryan is interesting as an individual performer and has a unique musical voice or style, then Ryan is either a touring soloist musician and capable of attracting large audiences, or neither a touring soloist musician nor capable of attracting large audiences."
    ],
    "question": "Ryan is either a permanent member of an orchestra or a touring soloist musician.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nTouring(x) ::: x is a touring musician.\nPermanent(x) ::: x is a permanent member of an orchestra.\nMusicians(x) ::: x is a musician.\nUniqueStyle(x) ::: x has a unique musical voice or style.\nInteresting(x) ::: x is interesting as an individual performer.\nCapable(x) ::: x is capable of attracting large audiences.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Touring(x) → ¬Permanent(x)) ::: No touring musicians are permanent members of an orchestra.\n∀x (Musicians(x) ↔ (Permanent(x) ∨ UniqueStyle(x))) ::: Musicians are either permanent members of an orchestra or have a unique musical voice or style.\n∀x (UniqueStyle(x) → Interesting(x)) ::: All musicians who have a unique musical voice or style are interesting as individual performers.\n∀x (Interesting(x) → Capable(x)) ::: All musicians who are interesting as individual performers are capable of attracting large audiences.\n(Interesting(ryan) ∧ UniqueStyle(ryan)) → (Touring(ryan) ∧ Capable(ryan)) ⊕ ¬(Touring(ryan) ∨ Capable(ryan)) ::: If Ryan is interesting as an individual performer and has a unique musical voice or style, then Ryan is either a touring soloist musician and capable of attracting large audiences, or neither a touring soloist musician nor capable of attracting large audiences.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nPermanent(ryan) ∨ Touring(ryan) ::: Ryan is either a permanent member of an orchestra or a touring soloist musician.\n\"\"\""
    ]
  },
  {
    "id": 1137,
    "context": [
      "No touring musicians are permanent members of an orchestra.",
      "Musicians are either permanent members of an orchestra or have a unique musical voice or style.",
      "All musicians who have a unique musical voice or style are interesting as individual performers.",
      "All musicians who are interesting as individual performers are capable of attracting large audiences.",
      "If Ryan is interesting as an individual performer and has a unique musical voice or style, then Ryan is either a touring soloist musician and capable of attracting large audiences, or neither a touring soloist musician nor capable of attracting large audiences."
    ],
    "question": "Ryan is either a permanent member of an orchestra or has a unique musical voice or style.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nTouring(x) ::: x is a touring musician.\nPermanent(x) ::: x is a permanent member of an orchestra.\nMusicians(x) ::: x is a musician.\nUniqueStyle(x) ::: x has a unique musical voice or style.\nInteresting(x) ::: x is interesting as an individual performer.\nCapable(x) ::: x is capable of attracting large audiences.\nSoloist(x) ::: x is a soloist musician.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Touring(x) → ¬Permanent(x)) ::: No touring musicians are permanent members of an orchestra.\n∀x (Musicians(x) → (Permanent(x) ∨ UniqueStyle(x))) ::: Musicians are either permanent members of an orchestra or have a unique musical voice or style.\n∀x (UniqueStyle(x) → Interesting(x)) ::: All musicians who have a unique musical voice or style are interesting as individual performers.\n∀x (Interesting(x) → Capable(x)) ::: All musicians who are interesting as individual performers are capable of attracting large audiences.\n(Interesting(ryan) ∧ UniqueStyle(ryan)) → (Soloist(ryan) ∧ Capable(ryan)) ⊕ ¬(Soloist(ryan) ∨ Capable(ryan)) ::: If Ryan is interesting as an individual performer and has a unique musical voice or style, then Ryan is either a touring soloist musician and capable of attracting large audiences, or neither a touring soloist musician nor capable of attracting large audiences.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nPermanent(ryan) ∨ UniqueStyle(ryan) ::: Ryan is either a permanent member of an orchestra or has a unique musical voice or style.\n\"\"\""
    ]
  },
  {
    "id": 1411,
    "context": [
      "If someone yells, then they are not cool.",
      "If someone is angry, then they yell.",
      "If someone flies, then they are cool.",
      "Every person that knows magic can fly.",
      "All wizards know magic.",
      "Harry either yells and flies, or neither yells nor flies.",
      "Potter is a wizard and flies."
    ],
    "question": "Harry is cool.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nYells(x) ::: x yells.\nCool(x) ::: x is cool.\nAngry(x) ::: x is angry.\nFlies(x) ::: x flies.\nKnowsMagic(x) ::: x knows magic.\nWizard(x) ::: x is a wizard.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Yells(x) → ¬Cool(x)) ::: If someone yells, then they are not cool.\n∀x (Angry(x) → Yells(x)) ::: If someone is angry, then they yell.\n∀x (Flies(x) → Cool(x)) ::: If someone flies, then they are cool.\n∀x (Person(x) ∧ KnowsMagic(x) → Flies(x)) ::: Every person that knows magic can fly.\n∀x (Wizard(x) → KnowsMagic(x)) ::: All wizards know magic.\n(Yells(harry) ∧ Flies(harry)) ⊕ ¬(Yells(harry) ∨ Flies(harry)) ::: Harry either yells and flies, or neither yells nor flies.\nWizard(potter) ∧ Flies(potter) ::: Potter is a wizard and flies.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nCool(harry) ::: Harry is cool.\n\"\"\""
    ]
  },
  {
    "id": 1412,
    "context": [
      "If someone yells, then they are not cool.",
      "If someone is angry, then they yell.",
      "If someone flies, then they are cool.",
      "Every person that knows magic can fly.",
      "All wizards know magic.",
      "Harry either yells and flies, or neither yells nor flies.",
      "Potter is a wizard and flies."
    ],
    "question": "Harry is not cool.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nYells(x) ::: x yells.\nCool(x) ::: x is cool.\nAngry(x) ::: x is angry.\nFlies(x) ::: x flies.\nMagic(x) ::: x knows magic.\nWizard(x) ::: x is a wizard.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Yells(x) → ¬Cool(x)) ::: If someone yells, then they are not cool.\n∀x (Angry(x) → Yells(x)) ::: If someone is angry, then they yell.\n∀x (Flies(x) → Cool(x)) ::: If someone flies, then they are cool.\n∀x (Magic(x) → Flies(x)) ::: Every person that knows magic can fly.\n∀x (Wizard(x) → Magic(x)) ::: All wizards know magic.\n(Yells(harry) ∧ Flies(harry)) ⊕ ¬(Yells(harry) ∨ Flies(harry)) ::: Harry either yells and flies, or neither yells nor flies.\nWizard(potter) ∧ Flies(potter) ::: Potter is a wizard and flies.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬Cool(harry) ::: Harry is not cool.\n\"\"\""
    ]
  },
  {
    "id": 1413,
    "context": [
      "If someone yells, then they are not cool.",
      "If someone is angry, then they yell.",
      "If someone flies, then they are cool.",
      "Every person that knows magic can fly.",
      "All wizards know magic.",
      "Harry either yells and flies, or neither yells nor flies.",
      "Potter is a wizard and flies."
    ],
    "question": "Harry is a wizard or angry.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nYells(x) ::: x yells.\nCool(x) ::: x is cool.\nAngry(x) ::: x is angry.\nFlies(x) ::: x flies.\nKnowsMagic(x) ::: x knows magic.\nWizard(x) ::: x is a wizard.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nYells(x) → ¬Cool(x) ::: If someone yells, then they are not cool.\nAngry(x) → Yells(x) ::: If someone is angry, then they yell.\nFlies(x) → Cool(x) ::: If someone flies, then they are cool.\n∀x (KnowsMagic(x) → Flies(x)) ::: Every person that knows magic can fly.\n∀x (Wizard(x) → KnowsMagic(x)) ::: All wizards know magic.\n(Yells(harry) ∧ Flies(harry)) ⊕ ¬(Yells(harry) ∨ Flies(harry)) ::: Harry either yells and flies, or neither yells nor flies.\nWizard(potter) ∧ Flies(potter) ::: Potter is a wizard and flies.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nWizard(harry) ∨ Angry(harry) ::: Harry is a wizard or angry.\n\"\"\""
    ]
  },
  {
    "id": 1414,
    "context": [
      "If someone yells, then they are not cool.",
      "If someone is angry, then they yell.",
      "If someone flies, then they are cool.",
      "Every person that knows magic can fly.",
      "All wizards know magic.",
      "Harry either yells and flies, or neither yells nor flies.",
      "Potter is a wizard and flies."
    ],
    "question": "Harry is neither a wizard nor angry.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nYells(x) ::: x yells.\nCool(x) ::: x is cool.\nAngry(x) ::: x is angry.\nFlies(x) ::: x flies.\nKnowsMagic(x) ::: x knows magic.\nWizard(x) ::: x is a wizard.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Yells(x) → ¬Cool(x)) ::: If someone yells, then they are not cool.\n∀x (Angry(x) → Yells(x)) ::: If someone is angry, then they yell.\n∀x (Flies(x) → Cool(x)) ::: If someone flies, then they are cool.\n∀x (Person(x) ∧ KnowsMagic(x) → Flies(x)) ::: Every person that knows magic can fly.\n∀x (Wizard(x) → KnowsMagic(x)) ::: All wizards know magic.\n(Yells(harry) ∧ Flies(harry)) ⊕ ¬(Yells(harry) ∨ Flies(harry)) ::: Harry either yells and flies, or neither yells nor flies.\nWizard(potter) ∧ Flies(potter) ::: Potter is a wizard and flies.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬(Wizard(harry) ∨ Angry(harry)) ::: Harry is neither a wizard nor angry.\n\"\"\""
    ]
  },
  {
    "id": 1253,
    "context": [
      "Products are either produced in China or the US. ",
      "All produced in China are labeled. ",
      "All produced in the US are sold in the US. ",
      "If labeled, then the product is cheaper. ",
      "All sold in the US are sold in Walmart. ",
      "All displayed on the homepage are sold in Walmart. ",
      "No products returned by customers are sold in Walmart. ",
      "G-910 is either displayed on the homepage or cheaper."
    ],
    "question": "G-910 is displayed on the homepage.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nProduced(x, y) ::: Product x is produced in country y.\nLabeled(x) ::: Product x is labeled.\nSold(x, y) ::: Product x is sold in country y.\nCheaper(x) ::: Product x is cheaper.\nSoldInWalmart(x) ::: Product x is sold in Walmart.\nDisplayedOnHomepage(x) ::: Product x is displayed on the homepage.\nReturnedByCustomers(x) ::: Product x is returned by customers.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Produced(x, China) ∨ Produced(x, US)) ::: Products are either produced in China or the US.\n∀x (Produced(x, China) → Labeled(x)) ::: All produced in China are labeled.\n∀x (Produced(x, US) → Sold(x, US)) ::: All produced in the US are sold in the US.\n∀x (Labeled(x) → Cheaper(x)) ::: If labeled, then the product is cheaper.\n∀x (Sold(x, US) → SoldInWalmart(x)) ::: All sold in the US are sold in Walmart.\n∀x (DisplayedOnHomepage(x) → SoldInWalmart(x)) ::: All displayed on the homepage are sold in Walmart.\n∀x (ReturnedByCustomers(x) → ¬SoldInWalmart(x)) ::: No products returned by customers are sold in Walmart.\nDisplayedOnHomepage(G-910) ∨ Cheaper(G-910) ::: G-910 is either displayed on the homepage or cheaper.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nDisplayedOnHomepage(G-910) ::: G-910 is displayed on the homepage.\n\"\"\""
    ]
  },
  {
    "id": 1254,
    "context": [
      "Products are either produced in China or the US. ",
      "All produced in China are labeled. ",
      "All produced in the US are sold in the US. ",
      "If labeled, then the product is cheaper. ",
      "All sold in the US are sold in Walmart. ",
      "All displayed on the homepage are sold in Walmart. ",
      "No products returned by customers are sold in Walmart. ",
      "G-910 is either displayed on the homepage or cheaper."
    ],
    "question": "G-910 is not displayed on the homepage.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nProduced(x, y) ::: Product x is produced in country y.\nLabeled(x) ::: Product x is labeled.\nSold(x, y) ::: Product x is sold in country y.\nCheaper(x) ::: Product x is cheaper.\nSoldInWalmart(x) ::: Product x is sold in Walmart.\nDisplayedOnHomepage(x) ::: Product x is displayed on the homepage.\nReturnedByCustomers(x) ::: Product x is returned by customers.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x ((Produced(x, China) ∨ Produced(x, US))) ::: Products are either produced in China or the US.\n∀x (Produced(x, China) → Labeled(x)) ::: All produced in China are labeled.\n∀x (Produced(x, US) → Sold(x, US)) ::: All produced in the US are sold in the US.\n∀x (Labeled(x) → Cheaper(x)) ::: If labeled, then the product is cheaper.\n∀x (Sold(x, US) → SoldInWalmart(x)) ::: All sold in the US are sold in Walmart.\n∀x (DisplayedOnHomepage(x) → SoldInWalmart(x)) ::: All displayed on the homepage are sold in Walmart.\n∀x (ReturnedByCustomers(x) → ¬SoldInWalmart(x)) ::: No products returned by customers are sold in Walmart.\nDisplayedOnHomepage(G-910) ∨ Cheaper(G-910) ::: G-910 is either displayed on the homepage or cheaper.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬DisplayedOnHomepage(G-910) ::: G-910 is not displayed on the homepage.\n\"\"\""
    ]
  },
  {
    "id": 1255,
    "context": [
      "Products are either produced in China or the US. ",
      "All produced in China are labeled. ",
      "All produced in the US are sold in the US. ",
      "If labeled, then the product is cheaper. ",
      "All sold in the US are sold in Walmart. ",
      "All displayed on the homepage are sold in Walmart. ",
      "No products returned by customers are sold in Walmart. ",
      "G-910 is either displayed on the homepage or cheaper."
    ],
    "question": "G-910 is a product returned by customers.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nProduced(x, y) ::: Product x is produced in country y.\nLabeled(x) ::: Product x is labeled.\nCheaper(x) ::: Product x is cheaper.\nSold(x, y) ::: Product x is sold in country y.\nDisplayed(x) ::: Product x is displayed on the homepage.\nReturned(x) ::: Product x is returned by customers.\nIn(x, y) ::: Product x is in location y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Produced(x, China) ∨ Produced(x, US)) ::: Products are either produced in China or the US.\n∀x (Produced(x, China) → Labeled(x)) ::: All produced in China are labeled.\n∀x (Produced(x, US) → Sold(x, US)) ::: All produced in the US are sold in the US.\n∀x (Labeled(x) → Cheaper(x)) ::: If labeled, then the product is cheaper.\n∀x (Sold(x, US) → In(x, Walmart)) ::: All sold in the US are sold in Walmart.\n∀x (Displayed(x) → In(x, Walmart)) ::: All displayed on the homepage are sold in Walmart.\n∀x (Returned(x) → ¬In(x, Walmart)) ::: No products returned by customers are sold in Walmart.\nDisplayed(G-910) ∨ Cheaper(G-910) ::: G-910 is either displayed on the homepage or cheaper.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nReturned(G-910) ::: G-910 is a product returned by customers.\n\"\"\""
    ]
  },
  {
    "id": 1256,
    "context": [
      "Products are either produced in China or the US. ",
      "All produced in China are labeled. ",
      "All produced in the US are sold in the US. ",
      "If labeled, then the product is cheaper. ",
      "All sold in the US are sold in Walmart. ",
      "All displayed on the homepage are sold in Walmart. ",
      "No products returned by customers are sold in Walmart. ",
      "G-910 is either displayed on the homepage or cheaper."
    ],
    "question": "G-910 is a product returned by customers or sold in Walmart.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nProduced(x, y) ::: x is produced in y.\nLabeled(x) ::: x is labeled.\nCheaper(x) ::: x is cheaper.\nSold(x, y) ::: x is sold in y.\nDisplayed(x) ::: x is displayed on the homepage.\nReturned(x) ::: x is returned by customers.\nIn(x, y) ::: x is in y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Produced(x, China) ∨ Produced(x, US)) ::: Products are either produced in China or the US.\n∀x (Produced(x, China) → Labeled(x)) ::: All produced in China are labeled.\n∀x (Produced(x, US) → Sold(x, US)) ::: All produced in the US are sold in the US.\n∀x (Labeled(x) → Cheaper(x)) ::: If labeled, then the product is cheaper.\n∀x (Sold(x, US) → Sold(x, Walmart)) ::: All sold in the US are sold in Walmart.\n∀x (Displayed(x) → Sold(x, Walmart)) ::: All displayed on the homepage are sold in Walmart.\n¬∃x (Returned(x) ∧ Sold(x, Walmart)) ::: No products returned by customers are sold in Walmart.\nDisplayed(G-910) ∨ Cheaper(G-910) ::: G-910 is either displayed on the homepage or cheaper.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nReturned(G-910) ∨ Sold(G-910, Walmart) ::: G-910 is a product returned by customers or sold in Walmart.\n\"\"\""
    ]
  },
  {
    "id": 1257,
    "context": [
      "Products are either produced in China or the US. ",
      "All produced in China are labeled. ",
      "All produced in the US are sold in the US. ",
      "If labeled, then the product is cheaper. ",
      "All sold in the US are sold in Walmart. ",
      "All displayed on the homepage are sold in Walmart. ",
      "No products returned by customers are sold in Walmart. ",
      "G-910 is either displayed on the homepage or cheaper."
    ],
    "question": "G-910 is either returned by customers or sold in Walmart.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nProduced(x, y) ::: Product x is produced in country y.\nLabeled(x) ::: Product x is labeled.\nSold(x, y) ::: Product x is sold in country y.\nCheaper(x) ::: Product x is cheaper.\nSoldInWalmart(x) ::: Product x is sold in Walmart.\nDisplayedOnHomepage(x) ::: Product x is displayed on the homepage.\nReturnedByCustomers(x) ::: Product x is returned by customers.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Produced(x, China) ∨ Produced(x, US)) ::: Products are either produced in China or the US.\n∀x (Produced(x, China) → Labeled(x)) ::: All produced in China are labeled.\n∀x (Produced(x, US) → Sold(x, US)) ::: All produced in the US are sold in the US.\n∀x (Labeled(x) → Cheaper(x)) ::: If labeled, then the product is cheaper.\n∀x (Sold(x, US) → SoldInWalmart(x)) ::: All sold in the US are sold in Walmart.\n∀x (DisplayedOnHomepage(x) → SoldInWalmart(x)) ::: All displayed on the homepage are sold in Walmart.\n∀x (ReturnedByCustomers(x) → ¬SoldInWalmart(x)) ::: No products returned by customers are sold in Walmart.\nDisplayedOnHomepage(G-910) ∨ Cheaper(G-910) ::: G-910 is either displayed on the homepage or cheaper.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nReturnedByCustomers(G-910) ∨ SoldInWalmart(G-910) ::: G-910 is either returned by customers or sold in Walmart.\n\"\"\""
    ]
  },
  {
    "id": 944,
    "context": [
      "People either order a lot of Amazon packages or are environmentally conscious.",
      "If people order a lot of Amazon packages, then they get a lot of daily mail delivered.",
      "If people are environmentally conscious, then they have solar panels in their homes.",
      "If people get a lot of daily mail delivered, then they are very involved with their neighborhood.",
      "If people have solar panels in their homes, then they save a lot of money.",
      "If Marcy either gets a lot of mail and is very involved with her neighborhood or if she does not order a lot of Amazon packages nor is very involved with her neighborhood, then Marcy does not both get a lot of daily mail and order a lot of Amazon packages. "
    ],
    "question": "Marcy either orders a lot of Amazon packages or saves a lot of money.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nOrder(x) ::: x orders a lot of Amazon packages.\nConscious(x) ::: x is environmentally conscious.\nDeliver(x) ::: x gets a lot of daily mail delivered.\nSolar(x) ::: x has solar panels in their homes.\nInvolved(x) ::: x is very involved with their neighborhood.\nSave(x) ::: x saves a lot of money.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Order(x) ∨ Conscious(x)) ::: People either order a lot of Amazon packages or are environmentally conscious.\n∀x (Order(x) → Deliver(x)) ::: If people order a lot of Amazon packages, then they get a lot of daily mail delivered.\n∀x (Conscious(x) → Solar(x)) ::: If people are environmentally conscious, then they have solar panels in their homes.\n∀x (Deliver(x) → Involved(x)) ::: If people get a lot of daily mail delivered, then they are very involved with their neighborhood.\n∀x (Solar(x) → Save(x)) ::: If people have solar panels in their homes, then they save a lot of money.\n((Deliver(marcy) ∧ Involved(marcy)) ∨ (¬Order(marcy) ∧ ¬Involved(marcy))) → ¬(Deliver(marcy) ∧ Order(marcy)) ::: If Marcy either gets a lot of mail and is very involved with her neighborhood or if she does not order a lot of Amazon packages nor is very involved with her neighborhood, then Marcy does not both get a lot of daily mail and order a lot of Amazon packages.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nOrder(marcy) ∨ Save(marcy) ::: Marcy either orders a lot of Amazon packages or saves a lot of money.\n\"\"\""
    ]
  },
  {
    "id": 945,
    "context": [
      "People either order a lot of Amazon packages or are environmentally conscious.",
      "If people order a lot of Amazon packages, then they get a lot of daily mail delivered.",
      "If people are environmentally conscious, then they have solar panels in their homes.",
      "If people get a lot of daily mail delivered, then they are very involved with their neighborhood.",
      "If people have solar panels in their homes, then they save a lot of money.",
      "If Marcy either gets a lot of mail and is very involved with her neighborhood or if she does not order a lot of Amazon packages nor is very involved with her neighborhood, then Marcy does not both get a lot of daily mail and order a lot of Amazon packages. "
    ],
    "question": "If Marcy is not a person who orders a lot of Amazon packages and is very environmentally conscious, then Taylor is not someone who saves a lot of money and is environmentally conscious.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nOrder(x) ::: x orders a lot of Amazon packages.\nConscious(x) ::: x is environmentally conscious.\nDeliver(x) ::: x gets a lot of daily mail delivered.\nSolar(x) ::: x has solar panels in their homes.\nInvolved(x) ::: x is very involved with their neighborhood.\nSave(x) ::: x saves a lot of money.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Order(x) ⊕ Conscious(x)) ::: People either order a lot of Amazon packages or are environmentally conscious.\nOrder(x) → Deliver(x) ::: If people order a lot of Amazon packages, then they get a lot of daily mail delivered.\nConscious(x) → Solar(x) ::: If people are environmentally conscious, then they have solar panels in their homes.\nDeliver(x) → Involved(x) ::: If people get a lot of daily mail delivered, then they are very involved with their neighborhood.\nSolar(x) → Save(x) ::: If people have solar panels in their homes, then they save a lot of money.\n((Deliver(marcy) ∧ Involved(marcy)) ∨ (¬Order(marcy) ∧ ¬Involved(marcy))) → ¬(Deliver(marcy) ∧ Order(marcy)) ::: If Marcy either gets a lot of mail and is very involved with her neighborhood or if she does not order a lot of Amazon packages nor is very involved with her neighborhood, then Marcy does not both get a lot of daily mail and order a lot of Amazon packages.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬(Order(marcy) ∧ Conscious(marcy)) → ¬(Save(taylor) ∧ Conscious(taylor)) ::: If Marcy is not a person who orders a lot of Amazon packages and is very environmentally conscious, then Taylor is not someone who saves a lot of money and is environmentally conscious.\n\"\"\""
    ]
  },
  {
    "id": 497,
    "context": [
      "Indonesia is a country.",
      "In Indonesia, the prosecutor only personally investigates cases of some special crimes.",
      "Corruption is a type of crime.",
      "Once the police complete investigations of a crime, they hand the evidence to the prosecutor. ",
      "Evidence can be either satisfactory or unsatisfactory.",
      "If the police hand the evidence to the prosecutor and the evidence is satisfactory, the prosecutor will prosecute the offender in an appropriate court."
    ],
    "question": "When the police complete investigations, the prosecutor will prosecute the offender at an appropriate court.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nCountry(x) ::: x is a country.\nInvestigates(x, y) ::: x personally investigates cases of y.\nCrime(x) ::: x is a crime.\nCompleteInvestigations(x, y) ::: x completes investigations of y.\nHand(x, y, z) ::: x hands y to z.\nEvidence(x) ::: x is evidence.\nSatisfactory(x) ::: x is satisfactory.\nProsecute(x, y, z) ::: x prosecutes y in court z.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nCountry(indonesia) ::: Indonesia is a country.\n∀x (Country(indonesia) ∧ Investigates(prosecutor, x) → Crime(x)) ::: In Indonesia, the prosecutor only personally investigates cases of some special crimes.\nCrime(corruption) ::: Corruption is a type of crime.\n∀x (CompleteInvestigations(police, x) → Hand(police, Evidence(x), prosecutor)) ::: Once the police complete investigations of a crime, they hand the evidence to the prosecutor.\n∀x (Evidence(x) → Satisfactory(x) ∨ ¬Satisfactory(x)) ::: Evidence can be either satisfactory or unsatisfactory.\n(Hand(police, Evidence(e), prosecutor) ∧ Satisfactory(Evidence(e))) → Prosecute(prosecutor, offender, court) ::: If the police hand the evidence to the prosecutor and the evidence is satisfactory, the prosecutor will prosecute the offender in an appropriate court.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n∀x (CompleteInvestigations(police, x) → Prosecute(prosecutor, offender, court)) ::: When the police complete investigations, the prosecutor will prosecute the offender at an appropriate court.\n\"\"\""
    ]
  },
  {
    "id": 498,
    "context": [
      "Indonesia is a country.",
      "In Indonesia, the prosecutor only personally investigates cases of some special crimes.",
      "Corruption is a type of crime.",
      "Once the police complete investigations of a crime, they hand the evidence to the prosecutor. ",
      "Evidence can be either satisfactory or unsatisfactory.",
      "If the police hand the evidence to the prosecutor and the evidence is satisfactory, the prosecutor will prosecute the offender in an appropriate court."
    ],
    "question": "In Indonesia, the prosecutor personally investigates cases of corruption.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nCountry(x) ::: x is a country.\nProsecutor(x) ::: x is a prosecutor.\nInvestigates(x, y) ::: x investigates cases of y.\nSpecialCrimes(x) ::: x is a special crime.\nCrime(x) ::: x is a crime.\nCorruption(x) ::: x is corruption.\nPolice(x) ::: x is the police.\nHand(x, y, z) ::: x hands y to z.\nEvidence(x) ::: x is evidence.\nSatisfactory(x) ::: x is satisfactory.\nUnsatisfactory(x) ::: x is unsatisfactory.\nProsecute(x, y, z) ::: x prosecutes y in z.\nAppropriateCourt(x) ::: x is an appropriate court.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nCountry(indonesia) ::: Indonesia is a country.\n∀x (Country(indonesia) ∧ Prosecutor(x) → ∃y (SpecialCrimes(y) ∧ Investigates(x, y))) ::: In Indonesia, the prosecutor only personally investigates cases of some special crimes.\n∀x (Corruption(x) → Crime(x)) ::: Corruption is a type of crime.\n∀x (Police(x) ∧ Crime(y) → Hand(x, Evidence(y), Prosecutor)) ::: Once the police complete investigations of a crime, they hand the evidence to the prosecutor.\n∀x (Evidence(x) → (Satisfactory(x) ∨ Unsatisfactory(x))) ::: Evidence can be either satisfactory or unsatisfactory.\n∀x (Hand(Police, Evidence, Prosecutor) ∧ Satisfactory(Evidence) → Prosecute(Prosecutor, Offender, AppropriateCourt)) ::: If the police hand the evidence to the prosecutor and the evidence is satisfactory, the prosecutor will prosecute the offender in an appropriate court.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nInvestigates(prosecutor, corruption) ::: In Indonesia, the prosecutor personally investigates cases of corruption.\n\"\"\""
    ]
  },
  {
    "id": 499,
    "context": [
      "Indonesia is a country.",
      "In Indonesia, the prosecutor only personally investigates cases of some special crimes.",
      "Corruption is a type of crime.",
      "Once the police complete investigations of a crime, they hand the evidence to the prosecutor. ",
      "Evidence can be either satisfactory or unsatisfactory.",
      "If the police hand the evidence to the prosecutor and the evidence is satisfactory, the prosecutor will prosecute the offender in an appropriate court."
    ],
    "question": "When the police complete investigations, the prosecutor investigates in personally.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nCountry(x) ::: x is a country.\nProsecutor(x) ::: x is a prosecutor.\nInvestigates(x, y) ::: x investigates cases of y.\nCrime(x) ::: x is a crime.\nPolice(x) ::: x is the police.\nHand(x, y, z) ::: x hands y to z.\nEvidence(x) ::: x is evidence.\nSatisfactory(x) ::: x is satisfactory.\nUnsatisfactory(x) ::: x is unsatisfactory.\nProsecute(x, y, z) ::: x prosecutes y in z.\nOffender(x) ::: x is an offender.\nCourt(x) ::: x is a court.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nCountry(indonesia) ::: Indonesia is a country.\n∀x (Country(indonesia) ∧ Prosecutor(x) → ∃y (Crime(y) ∧ Investigates(x, y))) ::: In Indonesia, the prosecutor only personally investigates cases of some special crimes.\nCrime(corruption) ::: Corruption is a type of crime.\n∀x (Police(x) ∧ Crime(y) → ∃z (Hand(x, Evidence(z), Prosecutor(z)))) ::: Once the police complete investigations of a crime, they hand the evidence to the prosecutor.\nEvidence(e) ⊕ Unsatisfactory(e) ::: Evidence can be either satisfactory or unsatisfactory.\n(Hand(Police, Evidence, Prosecutor) ∧ Satisfactory(Evidence)) → Prosecute(Prosecutor, Offender, Court) ::: If the police hand the evidence to the prosecutor and the evidence is satisfactory, the prosecutor will prosecute the offender in an appropriate court.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n∀x (Police(x) → ∃y (Prosecutor(y) ∧ Investigates(y, x))) ::: When the police complete investigations, the prosecutor investigates in personally.\n\"\"\""
    ]
  },
  {
    "id": 901,
    "context": [
      "No watch that is battery-powered is automatic.",
      "All digital watches are battery-powered.",
      "Some mechanical watches are automatic.",
      "All smart watches are digital.",
      "Moonwatch is not a digital watch or an automatic."
    ],
    "question": "Moonwatch is a mechanical watch.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nBatteryPowered(x) ::: x is a battery-powered watch.\nAutomatic(x) ::: x is an automatic watch.\nDigital(x) ::: x is a digital watch.\nMechanical(x) ::: x is a mechanical watch.\nSmart(x) ::: x is a smart watch.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (BatteryPowered(x) → ¬Automatic(x)) ::: No watch that is battery-powered is automatic.\n∀x (Digital(x) → BatteryPowered(x)) ::: All digital watches are battery-powered.\n∃x (Mechanical(x) ∧ Automatic(x)) ::: Some mechanical watches are automatic.\n∀x (Smart(x) → Digital(x)) ::: All smart watches are digital.\n¬(Digital(moonwatch) ∨ Automatic(moonwatch)) ::: Moonwatch is not a digital watch or an automatic.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nMechanical(moonwatch) ::: Moonwatch is a mechanical watch.\n\"\"\""
    ]
  },
  {
    "id": 902,
    "context": [
      "No watch that is battery-powered is automatic.",
      "All digital watches are battery-powered.",
      "Some mechanical watches are automatic.",
      "All smart watches are digital.",
      "Moonwatch is not a digital watch or an automatic."
    ],
    "question": "Moonwatch is a smartwatch and a mechanical watch.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nBatteryPowered(x) ::: x is a battery-powered watch.\nAutomatic(x) ::: x is an automatic watch.\nDigital(x) ::: x is a digital watch.\nMechanical(x) ::: x is a mechanical watch.\nSmart(x) ::: x is a smartwatch.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (BatteryPowered(x) → ¬Automatic(x)) ::: No watch that is battery-powered is automatic.\n∀x (Digital(x) → BatteryPowered(x)) ::: All digital watches are battery-powered.\n∃x (Mechanical(x) ∧ Automatic(x)) ::: Some mechanical watches are automatic.\n∀x (Smart(x) → Digital(x)) ::: All smart watches are digital.\n¬(Digital(moonwatch) ∨ Automatic(moonwatch)) ::: Moonwatch is not a digital watch or an automatic.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nSmart(moonwatch) ∧ Mechanical(moonwatch) ::: Moonwatch is a smartwatch and a mechanical watch.\n\"\"\""
    ]
  },
  {
    "id": 903,
    "context": [
      "No watch that is battery-powered is automatic.",
      "All digital watches are battery-powered.",
      "Some mechanical watches are automatic.",
      "All smart watches are digital.",
      "Moonwatch is not a digital watch or an automatic."
    ],
    "question": "If Moonwatch is a smartwatch and a mechanical watch, then Moonwatch is not a mechanical watch.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nBatteryPowered(x) ::: x is a battery-powered watch.\nAutomatic(x) ::: x is an automatic watch.\nDigital(x) ::: x is a digital watch.\nMechanical(x) ::: x is a mechanical watch.\nSmart(x) ::: x is a smartwatch.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (BatteryPowered(x) → ¬Automatic(x)) ::: No watch that is battery-powered is automatic.\n∀x (Digital(x) → BatteryPowered(x)) ::: All digital watches are battery-powered.\n∃x (Mechanical(x) ∧ Automatic(x)) ::: Some mechanical watches are automatic.\n∀x (Smart(x) → Digital(x)) ::: All smart watches are digital.\n¬(Digital(moonwatch) ∨ Automatic(moonwatch)) ::: Moonwatch is not a digital watch or an automatic.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n(Smart(moonwatch) ∧ Mechanical(moonwatch)) → ¬Mechanical(moonwatch) ::: If Moonwatch is a smartwatch and a mechanical watch, then Moonwatch is not a mechanical watch.\n\"\"\""
    ]
  },
  {
    "id": 904,
    "context": [
      "No watch that is battery-powered is automatic.",
      "All digital watches are battery-powered.",
      "Some mechanical watches are automatic.",
      "All smart watches are digital.",
      "Moonwatch is not a digital watch or an automatic."
    ],
    "question": "If Moonwatch is a mechanical or battery-powered watch, then Moonwatch is not a smartwatch.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nBatteryPowered(x) ::: x is a battery-powered watch.\nAutomatic(x) ::: x is an automatic watch.\nDigital(x) ::: x is a digital watch.\nMechanical(x) ::: x is a mechanical watch.\nSmart(x) ::: x is a smartwatch.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (BatteryPowered(x) → ¬Automatic(x)) ::: No watch that is battery-powered is automatic.\n∀x (Digital(x) → BatteryPowered(x)) ::: All digital watches are battery-powered.\n∃x (Mechanical(x) ∧ Automatic(x)) ::: Some mechanical watches are automatic.\n∀x (Smart(x) → Digital(x)) ::: All smart watches are digital.\n¬(Digital(moonwatch) ∨ Automatic(moonwatch)) ::: Moonwatch is not a digital watch or an automatic.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n(Mechanical(moonwatch) ∨ BatteryPowered(moonwatch)) → ¬Smart(moonwatch) ::: If Moonwatch is a mechanical or battery-powered watch, then Moonwatch is not a smartwatch.\n\"\"\""
    ]
  },
  {
    "id": 701,
    "context": [
      "Effective monetary policy is possible with successful inflation control and a strong national currency.",
      "A country cannot simultaneously regulate the exchange rate and successfully control inflation.",
      "The introduction of an embargo on foreign trade goods in a country leads to a sharp decrease in exports.",
      "If exports fall sharply, the national currency cannot be in this country.",
      "Regulation of the exchange rate is required to have a strong national currency. ",
      "There is an embargo on Russian foreign trade goods."
    ],
    "question": "In Russia, an effective monetary policy is possible.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nEffective(x) ::: x is an effective monetary policy.\nInflationControl(x) ::: x is successful inflation control.\nStrongCurrency(x) ::: x is a strong national currency.\nRegulateExchangeRate(x) ::: x regulates the exchange rate.\nEmbargo(x) ::: x is an embargo on foreign trade goods.\nDecreaseExports(x) ::: x leads to a sharp decrease in exports.\nNationalCurrency(x) ::: x is the national currency.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nEffective(x) ↔ (InflationControl(x) ∧ StrongCurrency(x)) ::: Effective monetary policy is possible with successful inflation control and a strong national currency.\n¬(RegulateExchangeRate(country) ∧ InflationControl(country)) ::: A country cannot simultaneously regulate the exchange rate and successfully control inflation.\nEmbargo(russia) ∧ DecreaseExports(russia) ::: The introduction of an embargo on foreign trade goods in a country leads to a sharp decrease in exports.\nDecreaseExports(country) → ¬NationalCurrency(country) ::: If exports fall sharply, the national currency cannot be in this country.\nStrongCurrency(country) → RegulateExchangeRate(country) ::: Regulation of the exchange rate is required to have a strong national currency.\nEmbargo(russia) ::: There is an embargo on Russian foreign trade goods.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nEffective(russia) ::: In Russia, an effective monetary policy is possible.\n\"\"\""
    ]
  },
  {
    "id": 421,
    "context": [
      "Video Gag is a French television series that airs weekly.",
      "Video Gag airs on the French broadcast channel TF1. ",
      "If viewers send in funny videos to the French broadcast channel, then Video Gag airs them on television.",
      "All videos aired on Video Gag are in French."
    ],
    "question": "Viewers send in funny videos to the French broadcast channel that are in French.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nTVSeries(x) ::: x is a television series.\nWeekly(x) ::: x airs weekly.\nAirOn(x, y) ::: x airs on broadcast channel y.\nSendIn(x, y, z) ::: x sends in y to broadcast channel z.\nFunny(x) ::: x is funny.\nFrench(x) ::: x is in French.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nTVSeries(videoGag) ∧ Weekly(videoGag) ∧ AirOn(videoGag, TF1) ::: Video Gag is a French television series that airs weekly and airs on the French broadcast channel TF1.\n∀x (SendIn(viewers, funnyVideos, frenchBroadcastChannel) → AirOn(videoGag, funnyVideos)) ::: If viewers send in funny videos to the French broadcast channel, then Video Gag airs them on television.\n∀x (AirOn(videoGag, x) → French(x)) ::: All videos aired on Video Gag are in French.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n∃x (SendIn(viewers, x, frenchBroadcastChannel) ∧ French(x)) ::: Viewers send in funny videos to the French broadcast channel that are in French.\n\"\"\""
    ]
  },
  {
    "id": 422,
    "context": [
      "Video Gag is a French television series that airs weekly.",
      "Video Gag airs on the French broadcast channel TF1. ",
      "If viewers send in funny videos to the French broadcast channel, then Video Gag airs them on television.",
      "All videos aired on Video Gag are in French."
    ],
    "question": "Viewers send in funny videos to the French broadcast channel that are in English.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nTVSeries(x) ::: x is a television series.\nWeekly(x) ::: x airs weekly.\nAirOn(x, y) ::: x airs on broadcast channel y.\nSendIn(x, y, z) ::: x sends in z to broadcast channel y.\nFunny(x) ::: x is funny.\nInLanguage(x, y) ::: x is in language y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nTVSeries(videoGag) ∧ Weekly(videoGag) ∧ AirOn(videoGag, TF1) ::: Video Gag is a French television series that airs weekly and airs on the French broadcast channel TF1.\n∀x (SendIn(viewers, TF1, funnyVideos) → AirOn(videoGag, funnyVideos)) ::: If viewers send in funny videos to the French broadcast channel, then Video Gag airs them on television.\n∀x (AirOn(videoGag, x) → InLanguage(x, french)) ::: All videos aired on Video Gag are in French.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n∃x (SendIn(viewers, TF1, funnyVideos) ∧ InLanguage(funnyVideos, english)) ::: Viewers send in funny videos to the French broadcast channel that are in English.\n\"\"\""
    ]
  },
  {
    "id": 1386,
    "context": [
      "All phones are things.",
      "All cellphones are phones. ",
      "All iPhones are cellphones. ",
      "All engineers are workers.",
      "All workers are human. ",
      "Jack is either an engineer or a worker.",
      "Jack is is either a human or a phone."
    ],
    "question": "Jack is a thing.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nThing(x) ::: x is a thing.\nPhone(x) ::: x is a phone.\nCellphone(x) ::: x is a cellphone.\niPhone(x) ::: x is an iPhone.\nEngineer(x) ::: x is an engineer.\nWorker(x) ::: x is a worker.\nHuman(x) ::: x is a human.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Phone(x) → Thing(x)) ::: All phones are things.\n∀x (Cellphone(x) → Phone(x)) ::: All cellphones are phones.\n∀x (iPhone(x) → Cellphone(x)) ::: All iPhones are cellphones.\n∀x (Engineer(x) → Worker(x)) ::: All engineers are workers.\n∀x (Worker(x) → Human(x)) ::: All workers are human.\n(Engineer(jack) ∨ Worker(jack)) ::: Jack is either an engineer or a worker.\n(Human(jack) ∨ Phone(jack)) ::: Jack is either a human or a phone.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nThing(jack) ::: Jack is a thing.\n\"\"\""
    ]
  },
  {
    "id": 1387,
    "context": [
      "All phones are things.",
      "All cellphones are phones. ",
      "All iPhones are cellphones. ",
      "All engineers are workers.",
      "All workers are human. ",
      "Jack is either an engineer or a worker.",
      "Jack is is either a human or a phone."
    ],
    "question": "Jack is not a thing.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nThing(x) ::: x is a thing.\nPhone(x) ::: x is a phone.\nCellphone(x) ::: x is a cellphone.\niPhone(x) ::: x is an iPhone.\nEngineer(x) ::: x is an engineer.\nWorker(x) ::: x is a worker.\nHuman(x) ::: x is a human.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Phone(x) → Thing(x)) ::: All phones are things.\n∀x (Cellphone(x) → Phone(x)) ::: All cellphones are phones.\n∀x (iPhone(x) → Cellphone(x)) ::: All iPhones are cellphones.\n∀x (Engineer(x) → Worker(x)) ::: All engineers are workers.\n∀x (Worker(x) → Human(x)) ::: All workers are human.\n(Engineer(jack) ∨ Worker(jack)) ::: Jack is either an engineer or a worker.\n(Human(jack) ∨ Phone(jack)) ::: Jack is either a human or a phone.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬Thing(jack) ::: Jack is not a thing.\n\"\"\""
    ]
  },
  {
    "id": 1388,
    "context": [
      "All phones are things.",
      "All cellphones are phones. ",
      "All iPhones are cellphones. ",
      "All engineers are workers.",
      "All workers are human. ",
      "Jack is either an engineer or a worker.",
      "Jack is is either a human or a phone."
    ],
    "question": "Jack is a thing and an iPhone.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nThing(x) ::: x is a thing.\nPhone(x) ::: x is a phone.\nCellphone(x) ::: x is a cellphone.\niPhone(x) ::: x is an iPhone.\nEngineer(x) ::: x is an engineer.\nWorker(x) ::: x is a worker.\nHuman(x) ::: x is a human.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Phone(x) → Thing(x)) ::: All phones are things.\n∀x (Cellphone(x) → Phone(x)) ::: All cellphones are phones.\n∀x (iPhone(x) → Cellphone(x)) ::: All iPhones are cellphones.\n∀x (Engineer(x) → Worker(x)) ::: All engineers are workers.\n∀x (Worker(x) → Human(x)) ::: All workers are human.\n(Engineer(jack) ∨ Worker(jack)) ::: Jack is either an engineer or a worker.\n(Human(jack) ∨ Phone(jack)) ::: Jack is either a human or a phone.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nThing(jack) ∧ iPhone(jack) ::: Jack is a thing and an iPhone.\n\"\"\""
    ]
  },
  {
    "id": 1389,
    "context": [
      "All phones are things.",
      "All cellphones are phones. ",
      "All iPhones are cellphones. ",
      "All engineers are workers.",
      "All workers are human. ",
      "Jack is either an engineer or a worker.",
      "Jack is is either a human or a phone."
    ],
    "question": "Jack is not both a thing and an iPhone.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nThing(x) ::: x is a thing.\nPhone(x) ::: x is a phone.\nCellphone(x) ::: x is a cellphone.\niPhone(x) ::: x is an iPhone.\nEngineer(x) ::: x is an engineer.\nWorker(x) ::: x is a worker.\nHuman(x) ::: x is a human.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Phone(x) → Thing(x)) ::: All phones are things.\n∀x (Cellphone(x) → Phone(x)) ::: All cellphones are phones.\n∀x (iPhone(x) → Cellphone(x)) ::: All iPhones are cellphones.\n∀x (Engineer(x) → Worker(x)) ::: All engineers are workers.\n∀x (Worker(x) → Human(x)) ::: All workers are human.\n(Engineer(jack) ∨ Worker(jack)) ::: Jack is either an engineer or a worker.\n(Human(jack) ∨ Phone(jack)) ::: Jack is either a human or a phone.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬(Thing(jack) ∧ iPhone(jack)) ::: Jack is not both a thing and an iPhone.\n\"\"\""
    ]
  },
  {
    "id": 738,
    "context": [
      "All iPhones are electronic.",
      "Some phones are iPhones."
    ],
    "question": "No phones are electronic.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nElectronic(x) ::: x is electronic.\niPhone(x) ::: x is an iPhone.\nPhone(x) ::: x is a phone.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (iPhone(x) → Electronic(x)) ::: All iPhones are electronic.\n∃x (Phone(x) ∧ iPhone(x)) ::: Some phones are iPhones.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬∃x (Phone(x) ∧ Electronic(x)) ::: No phones are electronic.\n\"\"\""
    ]
  },
  {
    "id": 111,
    "context": [
      "Metropolitan Museum of Art is a museum in NYC.",
      "Whitney Museum of American Art is a museum in NYC.",
      "Museum of Modern Art (MoMA) is a museum if NYC. ",
      "Metropolitan Museum of Art includes Bytantine and Islamic Art. ",
      "Whitney Museum of American Art includes American art."
    ],
    "question": "A museum in NYC includes Byzantine and Islamic Art.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nMuseum(x) ::: x is a museum.\nLocatedIn(x, y) ::: x is located in y.\nIncludes(x, y) ::: x includes y.\nArt(x) ::: x is art.\nByzantine(x) ::: x is Byzantine art.\nIslamic(x) ::: x is Islamic art.\nAmerican(x) ::: x is American art.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nMuseum(metropolitanMuseumOfArt) ∧ LocatedIn(metropolitanMuseumOfArt, NYC) ::: Metropolitan Museum of Art is a museum in NYC.\nMuseum(whitneyMuseumOfAmericanArt) ∧ LocatedIn(whitneyMuseumOfAmericanArt, NYC) ::: Whitney Museum of American Art is a museum in NYC.\nMuseum(moma) ∧ LocatedIn(moma, NYC) ::: Museum of Modern Art (MoMA) is a museum in NYC.\nIncludes(metropolitanMuseumOfArt, Byzantine) ∧ Includes(metropolitanMuseumOfArt, Islamic) ::: Metropolitan Museum of Art includes Byzantine and Islamic Art.\nIncludes(whitneyMuseumOfAmericanArt, American) ::: Whitney Museum of American Art includes American art.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n∃x (Museum(x) ∧ LocatedIn(x, NYC) ∧ Includes(x, Byzantine) ∧ Includes(x, Islamic)) ::: A museum in NYC includes Byzantine and Islamic Art.\n\"\"\""
    ]
  },
  {
    "id": 112,
    "context": [
      "Metropolitan Museum of Art is a museum in NYC.",
      "Whitney Museum of American Art is a museum in NYC.",
      "Museum of Modern Art (MoMA) is a museum if NYC. ",
      "Metropolitan Museum of Art includes Bytantine and Islamic Art. ",
      "Whitney Museum of American Art includes American art."
    ],
    "question": "A museum in NYC includes American art.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nMuseum(x) ::: x is a museum.\nIn(x, y) ::: x is in y.\nIncludes(x, y) ::: x includes y.\nArt(x) ::: x is art.\nAmericanArt(x) ::: x is American art.\nByzantineArt(x) ::: x is Byzantine art.\nIslamicArt(x) ::: x is Islamic art.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nMuseum(metropolitanMuseumOfArt) ∧ In(metropolitanMuseumOfArt, NYC) ::: Metropolitan Museum of Art is a museum in NYC.\nMuseum(whitneyMuseumOfAmericanArt) ∧ In(whitneyMuseumOfAmericanArt, NYC) ::: Whitney Museum of American Art is a museum in NYC.\nMuseum(museumOfModernArt) ∧ In(museumOfModernArt, NYC) ::: Museum of Modern Art (MoMA) is a museum if NYC.\nIncludes(metropolitanMuseumOfArt, ByzantineArt) ∧ Includes(metropolitanMuseumOfArt, IslamicArt) ::: Metropolitan Museum of Art includes Byzantine and Islamic Art.\nIncludes(whitneyMuseumOfAmericanArt, AmericanArt) ::: Whitney Museum of American Art includes American art.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n∃x (Museum(x) ∧ In(x, NYC) ∧ Includes(x, AmericanArt)) ::: A museum in NYC includes American art.\n\"\"\""
    ]
  },
  {
    "id": 113,
    "context": [
      "Metropolitan Museum of Art is a museum in NYC.",
      "Whitney Museum of American Art is a museum in NYC.",
      "Museum of Modern Art (MoMA) is a museum if NYC. ",
      "Metropolitan Museum of Art includes Bytantine and Islamic Art. ",
      "Whitney Museum of American Art includes American art."
    ],
    "question": "A museum in NYC includes Greek art.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nMuseum(x) ::: x is a museum.\nIn(x, y) ::: x is in y.\nIncludes(x, y) ::: x includes y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nMuseum(metropolitan) ∧ In(metropolitan, NYC) ::: Metropolitan Museum of Art is a museum in NYC.\nMuseum(whitney) ∧ In(whitney, NYC) ::: Whitney Museum of American Art is a museum in NYC.\nMuseum(moma) ∧ In(moma, NYC) ::: Museum of Modern Art (MoMA) is a museum in NYC.\nIncludes(metropolitan, byzantine) ∧ Includes(metropolitan, islamic) ::: Metropolitan Museum of Art includes Byzantine and Islamic Art.\nIncludes(whitney, american) ::: Whitney Museum of American Art includes American art.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n∃x (Museum(x) ∧ In(x, NYC) ∧ Includes(x, greek)) ::: A museum in NYC includes Greek art.\n\"\"\""
    ]
  },
  {
    "id": 1122,
    "context": [
      "A person either likes eating cheese or is a francophile.",
      "No francophiles are people who like Spain as their favorite country.",
      "A person likes Spain as their favorite country or likes eating cheese.",
      "Benji is not a person who likes eating cheese and a person who studies Spanish.",
      "If Benji is neither a person who studies Spanish nor a person that studies French, then Benji is a person who studies Spanish or a person that studies French."
    ],
    "question": "Benji is a person who likes eating cheese.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nLikesCheese(x) ::: x likes eating cheese.\nFrancophile(x) ::: x is a francophile.\nLikesSpain(x) ::: x likes Spain as their favorite country.\nLikes(x, y) ::: x likes y.\nStudies(x, y) ::: x studies y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (LikesCheese(x) ⊕ Francophile(x)) ::: A person either likes eating cheese or is a francophile.\n∀x (Francophile(x) → ¬Likes(x, Spain)) ::: No francophiles are people who like Spain as their favorite country.\n∀x (Likes(x, Spain) ∨ LikesCheese(x)) ::: A person likes Spain as their favorite country or likes eating cheese.\n¬(LikesCheese(benji) ∧ Studies(benji, spanish)) ::: Benji is not a person who likes eating cheese and a person who studies Spanish.\n¬(Studies(benji, spanish) ∨ Studies(benji, french)) → (Studies(benji, spanish) ∨ Studies(benji, french)) ⊕ ¬(Studies(benji, spanish) ∧ Studies(benji, french)) ::: If Benji is neither a person who studies Spanish nor a person that studies French, then Benji is a person who studies Spanish or a person that studies French.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nLikesCheese(benji) ::: Benji is a person who likes eating cheese.\n\"\"\""
    ]
  },
  {
    "id": 1123,
    "context": [
      "A person either likes eating cheese or is a francophile.",
      "No francophiles are people who like Spain as their favorite country.",
      "A person likes Spain as their favorite country or likes eating cheese.",
      "Benji is not a person who likes eating cheese and a person who studies Spanish.",
      "If Benji is neither a person who studies Spanish nor a person that studies French, then Benji is a person who studies Spanish or a person that studies French."
    ],
    "question": "If Benji is either a person who likes eating cheese or a francophile, then Benji is neither a person who studies Spanish nor a person who studies French.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nLikes(x, y) ::: x likes y.\nFrancophile(x) ::: x is a francophile.\nLikesSpain(x) ::: x likes Spain as their favorite country.\nLikesCheese(x) ::: x likes eating cheese.\nStudies(x, y) ::: x studies y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Likes(x, cheese) ⊕ Francophile(x)) ::: A person either likes eating cheese or is a francophile.\n∀x (Francophile(x) → ¬LikesSpain(x)) ::: No francophiles are people who like Spain as their favorite country.\n∀x (LikesSpain(x) ∨ LikesCheese(x)) ::: A person likes Spain as their favorite country or likes eating cheese.\n¬(LikesCheese(benji) ∧ Studies(benji, spanish)) ::: Benji is not a person who likes eating cheese and a person who studies Spanish.\n¬(Studies(benji, spanish) ∨ Studies(benji, french)) → (Studies(benji, spanish) ∨ Studies(benji, french)) ⊕ ¬(Studies(benji, spanish) ∧ Studies(benji, french)) ::: If Benji is neither a person who studies Spanish nor a person that studies French, then Benji is a person who studies Spanish or a person that studies French.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n(Likes(benji, cheese) ∨ Francophile(benji)) → ¬(Studies(benji, spanish) ∨ Studies(benji, french)) ::: If Benji is either a person who likes eating cheese or a francophile, then Benji is neither a person who studies Spanish nor a person who studies French.\n\"\"\""
    ]
  },
  {
    "id": 1124,
    "context": [
      "A person either likes eating cheese or is a francophile.",
      "No francophiles are people who like Spain as their favorite country.",
      "A person likes Spain as their favorite country or likes eating cheese.",
      "Benji is not a person who likes eating cheese and a person who studies Spanish.",
      "If Benji is neither a person who studies Spanish nor a person that studies French, then Benji is a person who studies Spanish or a person that studies French."
    ],
    "question": "If Benji is a person who likes Spain as their favorite country or studies French, then Benji is either a person who studies Spanish or a person who likes Spain as their favorite country.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nLikesCheese(x) ::: x likes eating cheese.\nFrancophile(x) ::: x is a francophile.\nLikesSpain(x) ::: x likes Spain as their favorite country.\nStudiesSpanish(x) ::: x studies Spanish.\nStudiesFrench(x) ::: x studies French.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (LikesCheese(x) ⊕ Francophile(x)) ::: A person either likes eating cheese or is a francophile.\n∀x (Francophile(x) → ¬LikesSpain(x)) ::: No francophiles are people who like Spain as their favorite country.\n∀x (LikesSpain(x) ⊕ LikesCheese(x)) ::: A person likes Spain as their favorite country or likes eating cheese.\n¬(LikesCheese(benji) ∧ StudiesSpanish(benji)) ::: Benji is not a person who likes eating cheese and a person who studies Spanish.\n¬(StudiesSpanish(benji) ∨ StudiesFrench(benji)) → (StudiesSpanish(benji) ∨ StudiesFrench(benji)) ⊕ ¬(StudiesSpanish(benji) ∧ StudiesFrench(benji)) ::: If Benji is neither a person who studies Spanish nor a person that studies French, then Benji is a person who studies Spanish or a person that studies French.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n(StudiesSpanish(benji) ∨ StudiesFrench(benji)) → (StudiesSpanish(benji) ∨ LikesSpain(benji)) ⊕ (StudiesSpanish(benji) ∧ LikesSpain(benji)) ::: If Benji is a person who likes Spain as their favorite country or studies French, then Benji is either a person who studies Spanish or a person who likes Spain as their favorite country.\n\"\"\""
    ]
  },
  {
    "id": 84,
    "context": [
      "Gasteren is village located in the province of Drenthe.",
      "Drenthe is a Dutch province. ",
      "No cities are villages.",
      "The population of a village in Drenthe was 155 people."
    ],
    "question": "Gasteren is a Dutch village.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nLocatedIn(x, y) ::: x is located in y.\nProvince(x, y) ::: x is a province in y.\nDutch(x) ::: x is Dutch.\nCity(x) ::: x is a city.\nVillage(x) ::: x is a village.\nPopulation(x, y) ::: x has a population of y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nLocatedIn(gasteren, drenthe) ::: Gasteren is a village located in the province of Drenthe.\nProvince(drenthe, netherlands) ::: Drenthe is a Dutch province.\n¬∃x (City(x) ∧ Village(x)) ::: No cities are villages.\nPopulation(villageInDrenthe, 155) ::: The population of a village in Drenthe was 155 people.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nDutch(gasteren) ∧ Village(gasteren) ::: Gasteren is a Dutch village.\n\"\"\""
    ]
  },
  {
    "id": 85,
    "context": [
      "Gasteren is village located in the province of Drenthe.",
      "Drenthe is a Dutch province. ",
      "No cities are villages.",
      "The population of a village in Drenthe was 155 people."
    ],
    "question": "Gasteren is a city.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nLocatedIn(x, y) ::: x is located in y.\nProvince(x, y) ::: x is a province in y.\nCity(x) ::: x is a city.\nVillage(x) ::: x is a village.\nPopulation(x, y) ::: x has a population of y people.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nLocatedIn(gasteren, drenthe) ::: Gasteren is a village located in the province of Drenthe.\nProvince(drenthe, netherlands) ::: Drenthe is a Dutch province.\n¬(City(x) ∧ Village(x)) ::: No cities are villages.\nPopulation(villageInDrenthe, 155) ::: The population of a village in Drenthe was 155 people.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬City(gasteren) ::: Gasteren is a city.\n\"\"\""
    ]
  },
  {
    "id": 86,
    "context": [
      "Gasteren is village located in the province of Drenthe.",
      "Drenthe is a Dutch province. ",
      "No cities are villages.",
      "The population of a village in Drenthe was 155 people."
    ],
    "question": "Gasteren has a population of 155.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nLocatedIn(x, y) ::: x is located in y.\nProvince(x) ::: x is a province.\nVillage(x) ::: x is a village.\nCity(x) ::: x is a city.\nPopulation(x, y) ::: x has a population of y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nLocatedIn(gasteren, drenthe) ::: Gasteren is a village located in the province of Drenthe.\nProvince(drenthe) ∧ LocatedIn(drenthe, netherlands) ::: Drenthe is a Dutch province.\n¬(City(x) ∧ Village(x)) ::: No cities are villages.\nPopulation(villageInDrenthe, 155) ::: The population of a village in Drenthe was 155 people.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nPopulation(gasteren, 155) ::: Gasteren has a population of 155.\n\"\"\""
    ]
  },
  {
    "id": 603,
    "context": [
      "The only types of mammals that lay eggs are platypuses and echidnas.",
      "Platypuses are not hyrax.",
      "Echidnas are not hyrax.",
      "No mammals are invertebrates.",
      "All animals are either vertebrates or invertebrates.",
      "Mammals are animals.",
      "Hyraxes are mammals.",
      "Grebes lay eggs.",
      "Grebes are not platypuses and also not echidnas."
    ],
    "question": "Hyraxes lay eggs.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nLayEggs(x) ::: x lays eggs.\nMammal(x) ::: x is a mammal.\nPlatypus(x) ::: x is a platypus.\nEchidna(x) ::: x is an echidna.\nHyrax(x) ::: x is a hyrax.\nInvertebrate(x) ::: x is an invertebrate.\nAnimal(x) ::: x is an animal.\nVertebrate(x) ::: x is a vertebrate.\nGrebe(x) ::: x is a grebe.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Mammal(x) ∧ LayEggs(x) → (Platypus(x) ∨ Echidna(x))) ::: The only types of mammals that lay eggs are platypuses and echidnas.\n¬Hyrax(platypus) ::: Platypuses are not hyrax.\n¬Hyrax(echidna) ::: Echidnas are not hyrax.\n∀x (Mammal(x) → ¬Invertebrate(x)) ::: No mammals are invertebrates.\n∀x (Animal(x) → (Vertebrate(x) ∨ Invertebrate(x))) ::: All animals are either vertebrates or invertebrates.\n∀x (Mammal(x) → Animal(x)) ::: Mammals are animals.\nMammal(hyrax) ::: Hyraxes are mammals.\nLayEggs(grebe) ::: Grebes lay eggs.\n¬(Grebe(platypus) ∨ Grebe(echidna)) ::: Grebes are not platypuses and also not echidnas.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬LayEggs(hyrax) ::: Hyraxes lay eggs.\n\"\"\""
    ]
  },
  {
    "id": 604,
    "context": [
      "The only types of mammals that lay eggs are platypuses and echidnas.",
      "Platypuses are not hyrax.",
      "Echidnas are not hyrax.",
      "No mammals are invertebrates.",
      "All animals are either vertebrates or invertebrates.",
      "Mammals are animals.",
      "Hyraxes are mammals.",
      "Grebes lay eggs.",
      "Grebes are not platypuses and also not echidnas."
    ],
    "question": "Grebes are not mammals.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nLayEggs(x) ::: x is a mammal that lays eggs.\nPlatypus(x) ::: x is a platypus.\nEchidna(x) ::: x is an echidna.\nHyrax(x) ::: x is a hyrax.\nInvertebrate(x) ::: x is an invertebrate.\nVertebrate(x) ::: x is a vertebrate.\nAnimal(x) ::: x is an animal.\nMammal(x) ::: x is a mammal.\nGrebe(x) ::: x is a grebe.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (LayEggs(x) ↔ (Platypus(x) ∨ Echidna(x))) ::: The only types of mammals that lay eggs are platypuses and echidnas.\n¬Platypus(platypus) ::: Platypuses are not hyrax.\n¬Echidna(echidna) ::: Echidnas are not hyrax.\n¬∃x (Mammal(x) ∧ Invertebrate(x)) ::: No mammals are invertebrates.\n∀x (Animal(x) → (Vertebrate(x) ∨ Invertebrate(x))) ::: All animals are either vertebrates or invertebrates.\n∀x (Mammal(x) → Animal(x)) ::: Mammals are animals.\nMammal(hyrax) ::: Hyraxes are mammals.\nLayEggs(grebe) ::: Grebes lay eggs.\n¬(Platypus(grebe) ∨ Echidna(grebe)) ::: Grebes are not platypuses and also not echidnas.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬Mammal(grebe) ::: Grebes are not mammals.\n\"\"\""
    ]
  },
  {
    "id": 605,
    "context": [
      "The only types of mammals that lay eggs are platypuses and echidnas.",
      "Platypuses are not hyrax.",
      "Echidnas are not hyrax.",
      "No mammals are invertebrates.",
      "All animals are either vertebrates or invertebrates.",
      "Mammals are animals.",
      "Hyraxes are mammals.",
      "Grebes lay eggs.",
      "Grebes are not platypuses and also not echidnas."
    ],
    "question": "Platypuses are vertebrates.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nLayEggs(x) ::: x lays eggs.\nMammal(x) ::: x is a mammal.\nPlatypus(x) ::: x is a platypus.\nEchidna(x) ::: x is an echidna.\nHyrax(x) ::: x is a hyrax.\nInvertebrate(x) ::: x is an invertebrate.\nVertebrate(x) ::: x is a vertebrate.\nAnimal(x) ::: x is an animal.\nGrebe(x) ::: x is a grebe.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Mammal(x) ∧ LayEggs(x) → (Platypus(x) ∨ Echidna(x))) ::: The only types of mammals that lay eggs are platypuses and echidnas.\n¬Hyrax(platypus) ::: Platypuses are not hyrax.\n¬Hyrax(echidna) ::: Echidnas are not hyrax.\n¬∃x (Mammal(x) ∧ Invertebrate(x)) ::: No mammals are invertebrates.\n∀x (Animal(x) → (Vertebrate(x) ∨ Invertebrate(x))) ::: All animals are either vertebrates or invertebrates.\n∀x (Mammal(x) → Animal(x)) ::: Mammals are animals.\nMammal(hyrax) ::: Hyraxes are mammals.\nLayEggs(grebe) ::: Grebes lay eggs.\n¬(Platypus(grebe) ∨ Echidna(grebe)) ::: Grebes are not platypuses and also not echidnas.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nVertebrate(platypus) ::: Platypuses are vertebrates.\n\"\"\""
    ]
  },
  {
    "id": 271,
    "context": [
      "Bobby Flynn is a singer-songwriter. ",
      "Bobby Flynn finished 7th while competing on Australian Idol.",
      "Australian Idol competitors are Australian citizens.",
      "The Omega Three band made a nationwide tour in 2007.",
      "Bobby Flynn is a member of The Omega Three band.",
      "Bobby Flynn was born in Queensland."
    ],
    "question": "Bobby Flynn is an Australian citizen.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nSingerSongwriter(x) ::: x is a singer-songwriter.\nCompetitor(x) ::: x is a competitor.\nAustralian(x) ::: x is an Australian citizen.\nBand(x) ::: x is a band.\nMember(x, y) ::: x is a member of y.\nBornIn(x, y) ::: x was born in y.\nMadeTour(x, y) ::: x made a nationwide tour in year y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nSingerSongwriter(bobbyFlynn) ::: Bobby Flynn is a singer-songwriter.\nCompetitor(bobbyFlynn) ∧ Finished(bobbyFlynn, 7th) ∧ CompetingOn(bobbyFlynn, australianIdol) ::: Bobby Flynn finished 7th while competing on Australian Idol.\n∀x (Competitor(x) → Australian(x)) ::: Australian Idol competitors are Australian citizens.\nBand(theOmegaThree) ∧ MadeTour(theOmegaThree, 2007) ::: The Omega Three band made a nationwide tour in 2007.\nMember(bobbyFlynn, theOmegaThree) ::: Bobby Flynn is a member of The Omega Three band.\nBornIn(bobbyFlynn, queensland) ::: Bobby Flynn was born in Queensland.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nAustralian(bobbyFlynn) ::: Bobby Flynn is an Australian citizen.\n\"\"\""
    ]
  },
  {
    "id": 272,
    "context": [
      "Bobby Flynn is a singer-songwriter. ",
      "Bobby Flynn finished 7th while competing on Australian Idol.",
      "Australian Idol competitors are Australian citizens.",
      "The Omega Three band made a nationwide tour in 2007.",
      "Bobby Flynn is a member of The Omega Three band.",
      "Bobby Flynn was born in Queensland."
    ],
    "question": "Bobby Flynn flew to America in 2007.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nSingerSongwriter(x) ::: x is a singer-songwriter.\nCompetitor(x, y) ::: x competed on y.\nAustralianCitizen(x) ::: x is an Australian citizen.\nBand(x) ::: x is a band.\nMember(x, y) ::: x is a member of y.\nBornIn(x, y) ::: x was born in y.\nTourYear(x, y) ::: x made a nationwide tour in year y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nSingerSongwriter(bobbyFlynn) ::: Bobby Flynn is a singer-songwriter.\nCompetitor(bobbyFlynn, australianIdol) ∧ Finished(bobbyFlynn, 7th) ::: Bobby Flynn finished 7th while competing on Australian Idol.\n∀x (Competitor(x, australianIdol) → AustralianCitizen(x)) ::: Australian Idol competitors are Australian citizens.\nTourYear(theOmegaThree, 2007) ::: The Omega Three band made a nationwide tour in 2007.\nMember(bobbyFlynn, theOmegaThree) ::: Bobby Flynn is a member of The Omega Three band.\nBornIn(bobbyFlynn, queensland) ::: Bobby Flynn was born in Queensland.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n∃x (Member(bobbyFlynn, x) ∧ TourYear(x, 2007)) ::: Bobby Flynn flew to America in 2007.\n\"\"\""
    ]
  },
  {
    "id": 273,
    "context": [
      "Bobby Flynn is a singer-songwriter. ",
      "Bobby Flynn finished 7th while competing on Australian Idol.",
      "Australian Idol competitors are Australian citizens.",
      "The Omega Three band made a nationwide tour in 2007.",
      "Bobby Flynn is a member of The Omega Three band.",
      "Bobby Flynn was born in Queensland."
    ],
    "question": "Bobby Flynn was born in Queens.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nSingerSongwriter(x) ::: x is a singer-songwriter.\nCompetitor(x, y) ::: x competed on y.\nAustralianCitizen(x) ::: x is an Australian citizen.\nBand(x) ::: x is a band.\nMember(x, y) ::: x is a member of y.\nBornIn(x, y) ::: x was born in y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nSingerSongwriter(bobbyFlynn) ::: Bobby Flynn is a singer-songwriter.\nCompetitor(bobbyFlynn, australianIdol) ∧ Finished(bobbyFlynn, 7th) ::: Bobby Flynn finished 7th while competing on Australian Idol.\n∀x (Competitor(x, australianIdol) → AustralianCitizen(x)) ::: Australian Idol competitors are Australian citizens.\nBand(omegaThree) ∧ NationwideTour(omegaThree, year2007) ::: The Omega Three band made a nationwide tour in 2007.\nMember(bobbyFlynn, omegaThree) ::: Bobby Flynn is a member of The Omega Three band.\nBornIn(bobbyFlynn, queensland) ::: Bobby Flynn was born in Queensland.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nBornIn(bobbyFlynn, queens) ::: Bobby Flynn was born in Queens.\n\"\"\""
    ]
  },
  {
    "id": 718,
    "context": [
      "All proteins are organic compounds.",
      "All enzymes are organic compounds."
    ],
    "question": "All enzymes are proteins.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nProtein(x) ::: x is a protein.\nOrganicCompound(x) ::: x is an organic compound.\nEnzyme(x) ::: x is an enzyme.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Protein(x) → OrganicCompound(x)) ::: All proteins are organic compounds.\n∀x (Enzyme(x) → OrganicCompound(x)) ::: All enzymes are organic compounds.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n∀x (Enzyme(x) → Protein(x)) ::: All enzymes are proteins.\n\"\"\""
    ]
  },
  {
    "id": 296,
    "context": [
      "One American screenwriter and producer is Maggie Friedman.",
      "Maggie Friedman was the showrunner and executive producer of the lifetime television series Witches of East End.",
      "Witches of East End is a fantasy-drama series.",
      "Maggie Friedman produced and developed Eastwick.",
      "Eastwick is a series by ABC."
    ],
    "question": "There is a series by ABC that was developed by the showrunner of Witches of East End.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nAmerican(x) ::: x is an American.\nScreenwriter(x) ::: x is a screenwriter.\nProducer(x) ::: x is a producer.\nShowrunner(x) ::: x is a showrunner.\nExecutiveProducer(x) ::: x is an executive producer.\nSeries(x) ::: x is a series.\nFantasyDrama(x) ::: x is a fantasy-drama series.\nDeveloped(x, y) ::: x developed y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∃x (American(x) ∧ Screenwriter(x) ∧ Producer(x) ∧ (x = MaggieFriedman)) ::: One American screenwriter and producer is Maggie Friedman.\nShowrunner(maggie) ∧ ExecutiveProducer(maggie) ∧ Developed(maggie, witchesOfEastEnd) ::: Maggie Friedman was the showrunner and executive producer of the lifetime television series Witches of East End.\nFantasyDrama(witchesOfEastEnd) ::: Witches of East End is a fantasy-drama series.\nProducer(maggie) ∧ Developed(maggie, eastwick) ::: Maggie Friedman produced and developed Eastwick.\nSeries(eastwick) ∧ By(eastwick, abc) ::: Eastwick is a series by ABC.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n∃x (Series(x) ∧ By(x, abc) ∧ ∃y (Showrunner(y) ∧ Developed(y, witchesOfEastEnd) ∧ Developed(y, x))) ::: There is a series by ABC that was developed by the showrunner of Witches of East End.\n\"\"\""
    ]
  },
  {
    "id": 297,
    "context": [
      "One American screenwriter and producer is Maggie Friedman.",
      "Maggie Friedman was the showrunner and executive producer of the lifetime television series Witches of East End.",
      "Witches of East End is a fantasy-drama series.",
      "Maggie Friedman produced and developed Eastwick.",
      "Eastwick is a series by ABC."
    ],
    "question": "There isn't a series by ABC that was developed by the showrunner of Witches of East End.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nAmerican(x) ::: x is an American.\nScreenwriter(x) ::: x is a screenwriter.\nProducer(x) ::: x is a producer.\nShowrunner(x) ::: x is a showrunner.\nExecutiveProducer(x) ::: x is an executive producer.\nSeries(x) ::: x is a series.\nFantasyDrama(x) ::: x is a fantasy-drama series.\nDevelop(x, y) ::: x developed y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nAmerican(maggie) ∧ Screenwriter(maggie) ∧ Producer(maggie) ∧ Showrunner(maggie) ∧ ExecutiveProducer(maggie) ::: One American screenwriter and producer is Maggie Friedman.\nShowrunner(maggie) ∧ ExecutiveProducer(maggie) ∧ Series(witchesOfEastEnd) ∧ FantasyDrama(witchesOfEastEnd) ::: Maggie Friedman was the showrunner and executive producer of the lifetime television series Witches of East End.\nSeries(witchesOfEastEnd) ∧ FantasyDrama(witchesOfEastEnd) ::: Witches of East End is a fantasy-drama series.\nProducer(maggie) ∧ Develop(maggie, eastwick) ::: Maggie Friedman produced and developed Eastwick.\nSeries(eastwick) ∧ By(eastwick, abc) ::: Eastwick is a series by ABC.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬∃x (Series(x) ∧ By(x, abc) ∧ Develop(maggie, witchesOfEastEnd)) ::: There isn't a series by ABC that was developed by the showrunner of Witches of East End.\n\"\"\""
    ]
  },
  {
    "id": 298,
    "context": [
      "One American screenwriter and producer is Maggie Friedman.",
      "Maggie Friedman was the showrunner and executive producer of the lifetime television series Witches of East End.",
      "Witches of East End is a fantasy-drama series.",
      "Maggie Friedman produced and developed Eastwick.",
      "Eastwick is a series by ABC."
    ],
    "question": "Maggie Friedman developed Witches of East End.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nAmerican(x) ::: x is an American.\nScreenwriter(x) ::: x is a screenwriter.\nProducer(x) ::: x is a producer.\nShowrunner(x) ::: x is a showrunner.\nExecutiveProducer(x) ::: x is an executive producer.\nSeries(x) ::: x is a series.\nFantasyDrama(x) ::: x is a fantasy-drama series.\nDeveloped(x, y) ::: x developed y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nAmerican(maggie) ∧ Screenwriter(maggie) ∧ Producer(maggie) ::: One American screenwriter and producer is Maggie Friedman.\nShowrunner(maggie) ∧ ExecutiveProducer(maggie) ∧ Series(witchesOfEastEnd) ∧ Developed(maggie, witchesOfEastEnd) ::: Maggie Friedman was the showrunner and executive producer of the lifetime television series Witches of East End.\nSeries(witchesOfEastEnd) ∧ FantasyDrama(witchesOfEastEnd) ::: Witches of East End is a fantasy-drama series.\nProducer(maggie) ∧ Developed(maggie, eastwick) ::: Maggie Friedman produced and developed Eastwick.\nSeries(eastwick) ∧ By(eastwick, abc) ::: Eastwick is a series by ABC.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nDeveloped(maggie, witchesOfEastEnd) ::: Maggie Friedman developed Witches of East End.\n\"\"\""
    ]
  },
  {
    "id": 359,
    "context": [
      "Evangelos Eleftheriou is a Greek electrical engineer.",
      "Evangelos Eleftheriou worked for IBM in Zurich.",
      "If a company has employees working for them somewhere, then they have an office there.",
      "IBM is a company."
    ],
    "question": "IBM has an office in London or Zurich.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nGreek(x) ::: x is a Greek person.\nEngineer(x) ::: x is an electrical engineer.\nWorkedFor(x, y) ::: x worked for y.\nCompany(x) ::: x is a company.\nHasEmployees(x, y) ::: x has employees working for them somewhere.\nOffice(x, y) ::: x has an office in y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nGreek(evangelos) ∧ Engineer(evangelos) ::: Evangelos Eleftheriou is a Greek electrical engineer.\nWorkedFor(evangelos, IBM) ∧ WorkedForLocation(evangelos, zurich) ::: Evangelos Eleftheriou worked for IBM in Zurich.\n∀x (HasEmployees(x, y) → Office(x, y)) ::: If a company has employees working for them somewhere, then they have an office there.\nCompany(IBM) ::: IBM is a company.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nOffice(IBM, london) ∨ Office(IBM, zurich) ::: IBM has an office in London or Zurich.\n\"\"\""
    ]
  },
  {
    "id": 360,
    "context": [
      "Evangelos Eleftheriou is a Greek electrical engineer.",
      "Evangelos Eleftheriou worked for IBM in Zurich.",
      "If a company has employees working for them somewhere, then they have an office there.",
      "IBM is a company."
    ],
    "question": "No Greeks have worked for IBM.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nGreek(x) ::: x is a Greek person.\nEngineer(x) ::: x is an electrical engineer.\nWorksFor(x, y) ::: x works for company y.\nCompany(x) ::: x is a company.\nHasOffice(x, y) ::: x has an office in location y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nGreek(evangelos) ∧ Engineer(evangelos) ::: Evangelos Eleftheriou is a Greek electrical engineer.\nWorksFor(evangelos, IBM) ::: Evangelos Eleftheriou worked for IBM in Zurich.\n∀x ∃y (WorksFor(x, y) → HasOffice(y, somewhere)) ::: If a company has employees working for them somewhere, then they have an office there.\nCompany(IBM) ::: IBM is a company.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬∃x (Greek(x) ∧ WorksFor(x, IBM)) ::: No Greeks have worked for IBM.\n\"\"\""
    ]
  },
  {
    "id": 434,
    "context": [
      "Before releasing their single, \"Hooray! Hooray! It's a Holi-Holiday!\", Boney M. had had seven consecutive German #1 singles.",
      "\"Hooray! Hooray! It's a Holi-Holiday!\" was a big hit all over Europe.",
      "Nevertheless, \"Hooray! Hooray! It's a Holi-Holiday!\" broke Boney M's streak of consecutive German #1 singles.",
      "A song that peaks below #1 on the german charts is also a song that is not the #1 single"
    ],
    "question": "\"Hooray! Hooray! It's a Holi-Holiday!\" was a #1 hit in Germany.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nHadConsecutiveGerman1Singles(x) ::: x had had seven consecutive German #1 singles.\nBigHit(x) ::: x was a big hit all over Europe.\nPeaksBelow1(x) ::: x peaks below #1 on the German charts.\nIsNot1Single(x) ::: x is not the #1 single.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nHadConsecutiveGerman1Singles(boneyM) ∧ BigHit(holiHoliday) ∧ PeaksBelow1(holiHoliday) ∧ IsNot1Single(holiHoliday) ::: Before releasing their single, \"Hooray! Hooray! It's a Holi-Holiday!\", Boney M. had had seven consecutive German #1 singles. \"Hooray! Hooray! It's a Holi-Holiday!\" was a big hit all over Europe. Nevertheless, \"Hooray! Hooray! It's a Holi-Holiday!\" broke Boney M's streak of consecutive German #1 singles. A song that peaks below #1 on the German charts is also a song that is not the #1 single.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬PeaksBelow1(holiHoliday) ::: \"Hooray! Hooray! It's a Holi-Holiday!\" was a #1 hit in Germany.\n\"\"\""
    ]
  },
  {
    "id": 435,
    "context": [
      "Before releasing their single, \"Hooray! Hooray! It's a Holi-Holiday!\", Boney M. had had seven consecutive German #1 singles.",
      "\"Hooray! Hooray! It's a Holi-Holiday!\" was a big hit all over Europe.",
      "Nevertheless, \"Hooray! Hooray! It's a Holi-Holiday!\" broke Boney M's streak of consecutive German #1 singles.",
      "A song that peaks below #1 on the german charts is also a song that is not the #1 single"
    ],
    "question": "\"Hooray! Hooray! It's a Holi-Holiday!\" peaked below #1 on the German charts.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nHad(x, y) ::: x had y.\nSingle(x) ::: x is a single.\nHit(x) ::: x was a big hit.\nPeaked(x, y) ::: x peaked at position y on the charts.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nHad(boneyM, sevenConsecutiveGerman1Singles) ::: Before releasing their single, \"Hooray! Hooray! It's a Holi-Holiday!\", Boney M. had had seven consecutive German #1 singles.\nHit(holiHoliday) ::: \"Hooray! Hooray! It's a Holi-Holiday!\" was a big hit all over Europe.\n¬Had(boneyM, consecutiveGerman1Singles) ::: Nevertheless, \"Hooray! Hooray! It's a Holi-Holiday!\" broke Boney M's streak of consecutive German #1 singles.\n∀x (Peaked(x, below1) → ¬Peaked(x, 1)) ::: A song that peaks below #1 on the German charts is also a song that is not the #1 single.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nPeaked(holiHoliday, below1) ::: \"Hooray! Hooray! It's a Holi-Holiday!\" peaked below #1 on the German charts.\n\"\"\""
    ]
  },
  {
    "id": 436,
    "context": [
      "Before releasing their single, \"Hooray! Hooray! It's a Holi-Holiday!\", Boney M. had had seven consecutive German #1 singles.",
      "\"Hooray! Hooray! It's a Holi-Holiday!\" was a big hit all over Europe.",
      "Nevertheless, \"Hooray! Hooray! It's a Holi-Holiday!\" broke Boney M's streak of consecutive German #1 singles.",
      "A song that peaks below #1 on the german charts is also a song that is not the #1 single"
    ],
    "question": "\"Hooray! Hooray! It's a Holi-Holiday!\" peaked at #3 on the UK charts.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nHad(x, y) ::: x had y.\nSingle(x) ::: x is a single.\nHit(x) ::: x was a big hit.\nPeaked(x, y) ::: x peaked at position y on the charts.\nGerman(x) ::: x is a German single.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nHad(boneyM, 7) ∧ Single(hoorayHoliHoliday) ∧ Hit(hoorayHoliHoliday) ∧ ¬German(hoorayHoliHoliday) ::: Before releasing their single, \"Hooray! Hooray! It's a Holi-Holiday!\", Boney M. had had seven consecutive German #1 singles.\nHit(hoorayHoliHoliday) ∧ Peaked(hoorayHoliHoliday, #1) ::: \"Hooray! Hooray! It's a Holi-Holiday!\" was a big hit all over Europe.\nHit(hoorayHoliHoliday) ∧ ¬Peaked(hoorayHoliHoliday, #1) ::: Nevertheless, \"Hooray! Hooray! It's a Holi-Holiday!\" broke Boney M's streak of consecutive German #1 singles.\n∀x (Peaked(x, y) → ¬(y = #1)) ::: A song that peaks below #1 on the German charts is also a song that is not the #1 single.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nPeaked(hoorayHoliHoliday, #3) ::: \"Hooray! Hooray! It's a Holi-Holiday!\" peaked at #3 on the UK charts.\n\"\"\""
    ]
  },
  {
    "id": 697,
    "context": [
      "Every chef can cook.",
      "Some people who aren’t chefs can cook.",
      "People who cook can make scrambled eggs and pasta.",
      "If someone can make cookies and muffins, they are a baker.",
      "Bakers who can also make scrambled eggs can make a good breakfast.",
      "Luke can make cookies, scrambled eggs, and muffins, but not pasta."
    ],
    "question": "Luke can make a good breakfast.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nChef(x) ::: x is a chef.\nCook(x) ::: x can cook.\nPerson(x) ::: x is a person.\nMake(x, y) ::: x can make y.\nScrambledEggs(x) ::: x can make scrambled eggs.\nPasta(x) ::: x can make pasta.\nBaker(x) ::: x is a baker.\nCookies(x) ::: x can make cookies.\nMuffins(x) ::: x can make muffins.\nGoodBreakfast(x) ::: x can make a good breakfast.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x Chef(x) → Cook(x) ::: Every chef can cook.\n∃x (Person(x) ∧ ¬Chef(x) ∧ Cook(x)) ::: Some people who aren’t chefs can cook.\n∀x (Cook(x) → (Make(x, scrambledEggs) ∧ Make(x, pasta))) ::: People who cook can make scrambled eggs and pasta.\n∀x ((Make(x, cookies) ∧ Make(x, muffins)) → Baker(x)) ::: If someone can make cookies and muffins, they are a baker.\n∀x ((Baker(x) ∧ Make(x, scrambledEggs)) → GoodBreakfast(x)) ::: Bakers who can also make scrambled eggs can make a good breakfast.\nCookies(luke) ∧ ScrambledEggs(luke) ∧ Muffins(luke) ∧ ¬Pasta(luke) ::: Luke can make cookies, scrambled eggs, and muffins, but not pasta.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nGoodBreakfast(luke) ::: Luke can make a good breakfast.\n\"\"\""
    ]
  },
  {
    "id": 698,
    "context": [
      "Every chef can cook.",
      "Some people who aren’t chefs can cook.",
      "People who cook can make scrambled eggs and pasta.",
      "If someone can make cookies and muffins, they are a baker.",
      "Bakers who can also make scrambled eggs can make a good breakfast.",
      "Luke can make cookies, scrambled eggs, and muffins, but not pasta."
    ],
    "question": "Luke is a chef.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nChef(x) ::: x is a chef.\nCook(x) ::: x can cook.\nPerson(x) ::: x is a person.\nMake(x, y) ::: x can make y.\nScrambledEggs(x) ::: x can make scrambled eggs.\nPasta(x) ::: x can make pasta.\nBaker(x) ::: x is a baker.\nCookies(x) ::: x can make cookies.\nMuffins(x) ::: x can make muffins.\nGoodBreakfast(x) ::: x can make a good breakfast.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Chef(x) → Cook(x)) ::: Every chef can cook.\n∃x (Person(x) ∧ ¬Chef(x) ∧ Cook(x)) ::: Some people who aren’t chefs can cook.\n∀x (Cook(x) → (Make(x, scrambledEggs) ∧ Make(x, pasta))) ::: People who cook can make scrambled eggs and pasta.\n∀x ((Make(x, cookies) ∧ Make(x, muffins)) → Baker(x)) ::: If someone can make cookies and muffins, they are a baker.\n∀x ((Baker(x) ∧ Make(x, scrambledEggs)) → GoodBreakfast(x)) ::: Bakers who can also make scrambled eggs can make a good breakfast.\nCookies(luke) ∧ ScrambledEggs(luke) ∧ Muffins(luke) ∧ ¬Pasta(luke) ::: Luke can make cookies, scrambled eggs, and muffins, but not pasta.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nChef(luke) ::: Luke is a chef.\n\"\"\""
    ]
  },
  {
    "id": 561,
    "context": [
      "ETS develops various standardized tests primarily in the United States for K-12 and higher education. ",
      "ETS administers international tests including the TOEFL, TOEIC, GRE and subject tests in more than 180 countries.",
      "Many of the assessments ETS develops are associated with entry to the US tertiary and quaternary education institutions. ",
      "ETS also develops K-12 statewide assessments used for accountability testing in many states."
    ],
    "question": "ETS develops assessments for K-12 statewide as well as entry to US tertiary and quaternary education institutions.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nDevelops(x, y) ::: x develops y.\nAdministers(x, y) ::: x administers y.\nAssociatedWith(x, y) ::: y is associated with x.\nEducationInstitution(x) ::: x is an education institution.\nAssessments(x) ::: x is an assessment.\nStatewide(x) ::: x is a K-12 statewide assessment.\nEntryToUS(x) ::: x is associated with entry to US tertiary and quaternary education institutions.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nDevelops(ETS, standardizedTests) ∧ Develops(ETS, internationalTests) ∧ Develops(ETS, statewideAssessments) ::: ETS develops various standardized tests primarily in the United States for K-12 and higher education.\nAdministers(ETS, TOEFL) ∧ Administers(ETS, TOEIC) ∧ Administers(ETS, GRE) ∧ Administers(ETS, subjectTests) ::: ETS administers international tests including the TOEFL, TOEIC, GRE and subject tests in more than 180 countries.\n∃x (Assessments(x) ∧ Develops(ETS, x) ∧ AssociatedWith(x, entryToUS)) ::: Many of the assessments ETS develops are associated with entry to the US tertiary and quaternary education institutions.\nDevelops(ETS, statewideAssessments) ∧ AssociatedWith(statewideAssessments, accountabilityTesting) ∧ Administers(ETS, statewideAssessments) ::: ETS also develops K-12 statewide assessments used for accountability testing in many states.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nDevelops(ETS, statewideAssessments) ∧ AssociatedWith(statewideAssessments, entryToUS) ::: ETS develops assessments for K-12 statewide as well as entry to US tertiary and quaternary education institutions.\n\"\"\""
    ]
  },
  {
    "id": 562,
    "context": [
      "ETS develops various standardized tests primarily in the United States for K-12 and higher education. ",
      "ETS administers international tests including the TOEFL, TOEIC, GRE and subject tests in more than 180 countries.",
      "Many of the assessments ETS develops are associated with entry to the US tertiary and quaternary education institutions. ",
      "ETS also develops K-12 statewide assessments used for accountability testing in many states."
    ],
    "question": "ETS doesn't administer tests internationally.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nDevelops(x, y) ::: x develops standardized tests primarily in the United States for y.\nAdministers(x, y) ::: x administers international tests including y.\nAssociatedWith(x, y) ::: x is associated with entry to y.\nDevelops(x, y) ::: x develops K-12 statewide assessments used for accountability testing in y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nDevelops(ETS, K-12) ∧ Develops(ETS, higherEducation) ∧ Develops(ETS, TOEFL) ∧ Develops(ETS, TOEIC) ∧ Develops(ETS, GRE) ∧ Develops(ETS, subjectTests) ::: ETS develops various standardized tests primarily in the United States for K-12 and higher education.\nAdministers(ETS, TOEFL) ∧ Administers(ETS, TOEIC) ∧ Administers(ETS, GRE) ∧ Administers(ETS, subjectTests) ∧ Administers(ETS, moreThan180Countries) ::: ETS administers international tests including the TOEFL, TOEIC, GRE and subject tests in more than 180 countries.\n∀x (Develops(ETS, x) → AssociatedWith(ETS, UStertiaryInstitutions)) ::: Many of the assessments ETS develops are associated with entry to the US tertiary and quaternary education institutions.\nDevelops(ETS, K-12StatewideAssessments) ::: ETS also develops K-12 statewide assessments used for accountability testing in many states.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬Administers(ETS, moreThan180Countries) ::: ETS doesn't administer tests internationally.\n\"\"\""
    ]
  },
  {
    "id": 563,
    "context": [
      "ETS develops various standardized tests primarily in the United States for K-12 and higher education. ",
      "ETS administers international tests including the TOEFL, TOEIC, GRE and subject tests in more than 180 countries.",
      "Many of the assessments ETS develops are associated with entry to the US tertiary and quaternary education institutions. ",
      "ETS also develops K-12 statewide assessments used for accountability testing in many states."
    ],
    "question": "ETS administers international tests including the TOEFL, GRE and subject tests in China.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nDevelops(x, y) ::: x develops standardized tests in y.\nAdministers(x, y) ::: x administers tests in y.\nTest(x) ::: x is a test.\nTOEFL(x) ::: x is the TOEFL test.\nTOEIC(x) ::: x is the TOEIC test.\nGRE(x) ::: x is the GRE test.\nSubjectTest(x) ::: x is a subject test.\nCountry(x) ::: x is a country.\nAssociatedWith(x, y) ::: x is associated with entry to y.\nEducationInstitution(x) ::: x is an education institution.\nState(x) ::: x is a state.\nAccountabilityTesting(x) ::: x is accountability testing.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nDevelops(ETS, US) ∧ Develops(ETS, K-12) ∧ Develops(ETS, statewide) ∧ Develops(ETS, higherEducation) ::: ETS develops various standardized tests primarily in the United States for K-12 and higher education.\nAdministers(ETS, internationalTests) ∧ Administers(ETS, TOEFL) ∧ Administers(ETS, TOEIC) ∧ Administers(ETS, GRE) ∧ Administers(ETS, subjectTests) ∧ Administers(ETS, 180Countries) ::: ETS administers international tests including the TOEFL, TOEIC, GRE and subject tests in more than 180 countries.\n∃x (Develops(ETS, x) ∧ AssociatedWith(ETS, US) ∧ EducationInstitution(x) ∧ (Tertiary(x) ∨ Quaternary(x))) ::: Many of the assessments ETS develops are associated with entry to the US tertiary and quaternary education institutions.\nDevelops(ETS, K-12) ∧ Develops(ETS, statewide) ∧ Administers(ETS, accountabilityTesting) ∧ Administers(ETS, manyStates) ::: ETS also develops K-12 statewide assessments used for accountability testing in many states.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nAdministers(ETS, internationalTests) ∧ Administers(ETS, TOEFL) ∧ Administers(ETS, GRE) ∧ Administers(ETS, subjectTests) ∧ Administers(ETS, China) ::: ETS administers international tests including the TOEFL, GRE and subject tests in China.\n\"\"\""
    ]
  },
  {
    "id": 998,
    "context": [
      "All people who enjoy eating gelato ice cream would enjoy a vacation to Italy.",
      "There are no people who can resist the hallmark delectable drinks and desserts that are famed in Italy.",
      "People either enjoy eating gelato ice cream or love to travel and vacation often.",
      "If people often take study abroad semesters to Europe, then they do not regret their college experiences.",
      "If people love to travel and vacation often, then they often take study abroad semesters to Europe.",
      "Robert either enjoys eating gelato ice cream and loves to travel and vacation often, or he neither enjoys eating gelato ice cream nor loves to travel and vacation often."
    ],
    "question": "Robert can resist the hallmark delectable drinks and desserts that are famed in Italy.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nEnjoyGelato(x) ::: x enjoys eating gelato ice cream.\nVacationToItaly(x) ::: x would enjoy a vacation to Italy.\nResist(x) ::: x can resist the hallmark delectable drinks and desserts that are famed in Italy.\nDelectable(x) ::: x is a hallmark delectable drink or dessert in Italy.\nLoveTravel(x) ::: x loves to travel.\nTravelOften(x) ::: x vacations often.\nStudyAbroad(x) ::: x takes study abroad semesters to Europe.\nRegret(x) ::: x regrets their college experiences.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (EnjoyGelato(x) → VacationToItaly(x)) ::: All people who enjoy eating gelato ice cream would enjoy a vacation to Italy.\n¬∃x (Resist(x) ∧ Delectable(x)) ::: There are no people who can resist the hallmark delectable drinks and desserts that are famed in Italy.\n∀x (EnjoyGelato(x) ⊕ (LoveTravel(x) ∧ TravelOften(x))) ::: People either enjoy eating gelato ice cream or love to travel and vacation often.\n(StudyAbroad(x) → ¬Regret(x)) ::: If people often take study abroad semesters to Europe, then they do not regret their college experiences.\n(LoveTravel(x) ∧ TravelOften(x)) → StudyAbroad(x) ::: If people love to travel and vacation often, then they often take study abroad semesters to Europe.\n(EnjoyGelato(robert) ∧ LoveTravel(robert)) ⊕ ¬(EnjoyGelato(robert) ∨ LoveTravel(robert)) ::: Robert either enjoys eating gelato ice cream and loves to travel and vacation often, or he neither enjoys eating gelato ice cream nor loves to travel and vacation often.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬Resist(robert) ::: Robert can resist the hallmark delectable drinks and desserts that are famed in Italy.\n\"\"\""
    ]
  },
  {
    "id": 999,
    "context": [
      "All people who enjoy eating gelato ice cream would enjoy a vacation to Italy.",
      "There are no people who can resist the hallmark delectable drinks and desserts that are famed in Italy.",
      "People either enjoy eating gelato ice cream or love to travel and vacation often.",
      "If people often take study abroad semesters to Europe, then they do not regret their college experiences.",
      "If people love to travel and vacation often, then they often take study abroad semesters to Europe.",
      "Robert either enjoys eating gelato ice cream and loves to travel and vacation often, or he neither enjoys eating gelato ice cream nor loves to travel and vacation often."
    ],
    "question": "If Robert either would both enjoy a vacation to Italy and regrets his college experiences or neither would enjoy a vacation to Italy nor regrets his college experiences, then Robert would either enjoy a vacation to Italy or, if not, then he can resist the hallmark delectable drinks and desserts that are famed in Italy.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nEnjoyGelato(x) ::: x enjoys eating gelato ice cream.\nEnjoyVacationToItaly(x) ::: x would enjoy a vacation to Italy.\nResist(x) ::: x can resist the hallmark delectable drinks and desserts that are famed in Italy.\nLoveTravel(x) ::: x loves to travel.\nVacationOften(x) ::: x vacations often.\nStudyAbroad(x) ::: x takes study abroad semesters to Europe.\nRegret(x) ::: x regrets their college experiences.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (EnjoyGelato(x) → EnjoyVacationToItaly(x)) ::: All people who enjoy eating gelato ice cream would enjoy a vacation to Italy.\n¬∃x (Resist(x) ∧ HallmarkDelectableDrinksAndDesserts(x)) ::: There are no people who can resist the hallmark delectable drinks and desserts that are famed in Italy.\n∀x (EnjoyGelato(x) ⊕ LoveTravel(x) ∧ VacationOften(x)) ::: People either enjoy eating gelato ice cream or love to travel and vacation often.\n(StudyAbroad(x) → ¬Regret(x)) ::: If people often take study abroad semesters to Europe, then they do not regret their college experiences.\n(LoveTravel(x) ∧ VacationOften(x)) → StudyAbroad(x) ::: If people love to travel and vacation often, then they often take study abroad semesters to Europe.\n(EnjoyGelato(robert) ∧ LoveTravel(robert)) ⊕ ¬(EnjoyGelato(robert) ∨ LoveTravel(robert)) ::: Robert either enjoys eating gelato ice cream and loves to travel and vacation often, or he neither enjoys eating gelato ice cream nor loves to travel and vacation often.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n((EnjoyVacationToItaly(robert) ∧ Regret(robert)) ∨ ¬(EnjoyVacationToItaly(robert) ∨ Regret(robert))) → (EnjoyVacationToItaly(robert) ∨ Resist(robert)) ::: If Robert either would both enjoy a vacation to Italy and regrets his college experiences or neither would enjoy a vacation to Italy nor regrets his college experiences, then Robert would either enjoy a vacation to Italy or, if not, then he can resist the hallmark delectable drinks and desserts that are famed in Italy.\n\"\"\""
    ]
  },
  {
    "id": 1000,
    "context": [
      "All people who enjoy eating gelato ice cream would enjoy a vacation to Italy.",
      "There are no people who can resist the hallmark delectable drinks and desserts that are famed in Italy.",
      "People either enjoy eating gelato ice cream or love to travel and vacation often.",
      "If people often take study abroad semesters to Europe, then they do not regret their college experiences.",
      "If people love to travel and vacation often, then they often take study abroad semesters to Europe.",
      "Robert either enjoys eating gelato ice cream and loves to travel and vacation often, or he neither enjoys eating gelato ice cream nor loves to travel and vacation often."
    ],
    "question": "If Robert is not both a person who can resist the hallmark delectable drinks and desserts that are famed in Italy and regrets his college experiences, then Robert either enjoys eating gelato ice cream or would enjoy a vacation to Italy.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nEnjoyGelato(x) ::: x enjoys eating gelato ice cream.\nEnjoyVacationToItaly(x) ::: x would enjoy a vacation to Italy.\nResist(x) ::: x can resist the hallmark delectable drinks and desserts that are famed in Italy.\nLoveTravel(x) ::: x loves to travel.\nVacationOften(x) ::: x vacations often.\nStudyAbroad(x) ::: x often takes study abroad semesters to Europe.\nRegretCollege(x) ::: x regrets their college experiences.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (EnjoyGelato(x) → EnjoyVacationToItaly(x)) ::: All people who enjoy eating gelato ice cream would enjoy a vacation to Italy.\n¬∃x (Resist(x) ∧ DelectableDrinksAndDesserts(x)) ::: There are no people who can resist the hallmark delectable drinks and desserts that are famed in Italy.\n∀x (EnjoyGelato(x) ⊕ LoveTravel(x) ∧ VacationOften(x)) ::: People either enjoy eating gelato ice cream or love to travel and vacation often.\n(StudyAbroad(x) → ¬RegretCollege(x)) ::: If people often take study abroad semesters to Europe, then they do not regret their college experiences.\n(LoveTravel(x) ∧ VacationOften(x)) → StudyAbroad(x) ::: If people love to travel and vacation often, then they often take study abroad semesters to Europe.\n¬(EnjoyGelato(robert) ∧ LoveTravel(robert)) → (EnjoyGelato(robert) ∨ EnjoyVacationToItaly(robert)) ::: Robert either enjoys eating gelato ice cream and loves to travel and vacation often, or he neither enjoys eating gelato ice cream nor loves to travel and vacation often.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬(Resist(robert) ∧ RegretCollege(robert)) → (EnjoyGelato(robert) ∨ EnjoyVacationToItaly(robert)) ::: If Robert is not both a person who can resist the hallmark delectable drinks and desserts that are famed in Italy and regrets his college experiences, then Robert either enjoys eating gelato ice cream or would enjoy a vacation to Italy.\n\"\"\""
    ]
  },
  {
    "id": 781,
    "context": [
      "To get a student visa, you must be full-time enrolled in an academic program.",
      "Those who are full-time enrolled in an academic program can not work full-time.",
      "Everyone who wants to study abroad needs to have a student visa.",
      "All PhD graduates can work full time. ",
      "If Tom does not want to study abroad, he is full-time enrolled in an educational program."
    ],
    "question": "Tom is a PhD graduate.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nStudentVisa(x) ::: x has a student visa.\nEnrolled(x) ::: x is full-time enrolled in an academic program.\nWorkFullTime(x) ::: x works full-time.\nStudyAbroad(x) ::: x wants to study abroad.\nPhDGraduate(x) ::: x is a PhD graduate.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (StudentVisa(x) → Enrolled(x)) ::: To get a student visa, you must be full-time enrolled in an academic program.\n∀x (Enrolled(x) → ¬WorkFullTime(x)) ::: Those who are full-time enrolled in an academic program can not work full-time.\n∀x (StudyAbroad(x) → StudentVisa(x)) ::: Everyone who wants to study abroad needs to have a student visa.\n∀x (PhDGraduate(x) → WorkFullTime(x)) ::: All PhD graduates can work full time.\n¬StudyAbroad(tom) → Enrolled(tom) ::: If Tom does not want to study abroad, he is full-time enrolled in an educational program.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nPhDGraduate(tom) ::: Tom is a PhD graduate.\n\"\"\""
    ]
  },
  {
    "id": 782,
    "context": [
      "To get a student visa, you must be full-time enrolled in an academic program.",
      "Those who are full-time enrolled in an academic program can not work full-time.",
      "Everyone who wants to study abroad needs to have a student visa.",
      "All PhD graduates can work full time. ",
      "If Tom does not want to study abroad, he is full-time enrolled in an educational program."
    ],
    "question": "Tom is not a PhD graduate.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nStudentVisa(x) ::: x has a student visa.\nEnrolled(x) ::: x is full-time enrolled in an academic program.\nWorkFullTime(x) ::: x works full-time.\nStudyAbroad(x) ::: x wants to study abroad.\nPhDGraduate(x) ::: x is a PhD graduate.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (StudentVisa(x) → Enrolled(x)) ::: To get a student visa, you must be full-time enrolled in an academic program.\n∀x (Enrolled(x) → ¬WorkFullTime(x)) ::: Those who are full-time enrolled in an academic program can not work full-time.\n∀x (StudyAbroad(x) → StudentVisa(x)) ::: Everyone who wants to study abroad needs to have a student visa.\n∀x (PhDGraduate(x) → WorkFullTime(x)) ::: All PhD graduates can work full time.\n¬StudyAbroad(tom) → Enrolled(tom) ::: If Tom does not want to study abroad, he is full-time enrolled in an educational program.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬PhDGraduate(tom) ::: Tom is not a PhD graduate.\n\"\"\""
    ]
  },
  {
    "id": 783,
    "context": [
      "To get a student visa, you must be full-time enrolled in an academic program.",
      "Those who are full-time enrolled in an academic program can not work full-time.",
      "Everyone who wants to study abroad needs to have a student visa.",
      "All PhD graduates can work full time. ",
      "If Tom does not want to study abroad, he is full-time enrolled in an educational program."
    ],
    "question": "Tom wants to study abroad.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nStudentVisa(x) ::: x has a student visa.\nEnrolled(x) ::: x is full-time enrolled in an academic program.\nWorkFullTime(x) ::: x works full-time.\nStudyAbroad(x) ::: x wants to study abroad.\nPhDGraduate(x) ::: x is a PhD graduate.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (StudentVisa(x) → Enrolled(x)) ::: To get a student visa, you must be full-time enrolled in an academic program.\n∀x (Enrolled(x) → ¬WorkFullTime(x)) ::: Those who are full-time enrolled in an academic program cannot work full-time.\n∀x (StudyAbroad(x) → StudentVisa(x)) ::: Everyone who wants to study abroad needs to have a student visa.\n∀x (PhDGraduate(x) → WorkFullTime(x)) ::: All PhD graduates can work full time.\n¬StudyAbroad(tom) → Enrolled(tom) ::: If Tom does not want to study abroad, he is full-time enrolled in an educational program.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nStudyAbroad(tom) ::: Tom wants to study abroad.\n\"\"\""
    ]
  },
  {
    "id": 396,
    "context": [
      "The installment sales method is the approach to recognize revenue under the US GAAP.",
      "In accrual accounting, revenues are recognized when they are realized.",
      "In cash accounting, revenues are recognized when cash is received.",
      "The US GAAP is the accounting standard developed and used by the US Securities and Exchange Commission.",
      "Sally works for the US Securities and Exchange Commission."
    ],
    "question": "Sally's company utilizes the installment sales method.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nRecognizeRevenue(x) ::: x is the approach to recognize revenue.\nUSGAAP(x) ::: x is the US Generally Accepted Accounting Principles.\nAccrualAccounting(x) ::: x is accrual accounting.\nCashAccounting(x) ::: x is cash accounting.\nRealized(x) ::: x is realized.\nReceived(x) ::: x is received.\nAccountingStandard(x) ::: x is an accounting standard.\nDeveloped(x, y) ::: x is developed by y.\nUsedBy(x, y) ::: x is used by y.\nWorksFor(x, y) ::: x works for y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nRecognizeRevenue(installmentSalesMethod) ∧ USGAAP(installmentSalesMethod) ::: The installment sales method is the approach to recognize revenue under the US GAAP.\n∀x (AccrualAccounting(x) → RecognizeRevenue(x) ∧ Realized(x)) ::: In accrual accounting, revenues are recognized when they are realized.\n∀x (CashAccounting(x) → RecognizeRevenue(x) ∧ Received(x)) ::: In cash accounting, revenues are recognized when cash is received.\nAccountingStandard(USGAAP) ∧ Developed(USGAAP, SEC) ∧ UsedBy(USGAAP, SEC) ::: The US GAAP is the accounting standard developed and used by the US Securities and Exchange Commission.\nWorksFor(sally, SEC) ::: Sally works for the US Securities and Exchange Commission.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nUtilizes(sally, installmentSalesMethod) ::: Sally's company utilizes the installment sales method.\n\"\"\""
    ]
  },
  {
    "id": 397,
    "context": [
      "The installment sales method is the approach to recognize revenue under the US GAAP.",
      "In accrual accounting, revenues are recognized when they are realized.",
      "In cash accounting, revenues are recognized when cash is received.",
      "The US GAAP is the accounting standard developed and used by the US Securities and Exchange Commission.",
      "Sally works for the US Securities and Exchange Commission."
    ],
    "question": "The company Sally works for performs accrual accounting.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nRecognizeRevenue(x) ::: x is the approach to recognize revenue.\nUSGAAP(x) ::: x is the US Generally Accepted Accounting Principles.\nAccrualAccounting(x) ::: x is accrual accounting.\nCashAccounting(x) ::: x is cash accounting.\nRealized(x) ::: x is realized.\nReceived(x) ::: x is received.\nWorksFor(x, y) ::: x works for y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nRecognizeRevenue(installmentSalesMethod) ∧ USGAAP(installmentSalesMethod) ::: The installment sales method is the approach to recognize revenue under the US GAAP.\n∀x (AccrualAccounting(x) → Realized(x)) ::: In accrual accounting, revenues are recognized when they are realized.\n∀x (CashAccounting(x) → Received(x)) ::: In cash accounting, revenues are recognized when cash is received.\nUSGAAP(usgaap) ∧ DevelopedBy(usgaap, sec) ∧ WorksFor(sally, sec) ::: The US GAAP is the accounting standard developed and used by the US Securities and Exchange Commission. Sally works for the US Securities and Exchange Commission.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nAccrualAccounting(sec) ::: The company Sally works for performs accrual accounting.\n\"\"\""
    ]
  },
  {
    "id": 398,
    "context": [
      "The installment sales method is the approach to recognize revenue under the US GAAP.",
      "In accrual accounting, revenues are recognized when they are realized.",
      "In cash accounting, revenues are recognized when cash is received.",
      "The US GAAP is the accounting standard developed and used by the US Securities and Exchange Commission.",
      "Sally works for the US Securities and Exchange Commission."
    ],
    "question": "Sally does not work for a company that uses the GAAP.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nRecognizeRevenue(x) ::: x is the approach to recognize revenue.\nUSGAAP(x) ::: x is the US Generally Accepted Accounting Principles.\nAccrualAccounting(x) ::: x is accrual accounting.\nCashAccounting(x) ::: x is cash accounting.\nRealized(x) ::: x is realized.\nReceived(x) ::: x is received.\nAccountingStandard(x) ::: x is an accounting standard.\nDeveloped(x, y) ::: x is developed by y.\nUsedBy(x, y) ::: x is used by y.\nWorksFor(x, y) ::: x works for y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nRecognizeRevenue(installmentSalesMethod) ↔ USGAAP(USGAAP) ::: The installment sales method is the approach to recognize revenue under the US GAAP.\n∀x (AccrualAccounting(x) → Realized(x)) ::: In accrual accounting, revenues are recognized when they are realized.\n∀x (CashAccounting(x) → Received(x)) ::: In cash accounting, revenues are recognized when cash is received.\nAccountingStandard(USGAAP) ∧ Developed(USGAAP, USSEC) ∧ UsedBy(USGAAP, USSEC) ::: The US GAAP is the accounting standard developed and used by the US Securities and Exchange Commission.\nWorksFor(sally, USSEC) ::: Sally works for the US Securities and Exchange Commission.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬WorksFor(sally, x) ∧ UsedBy(USGAAP, x) ::: Sally does not work for a company that uses the GAAP.\n\"\"\""
    ]
  },
  {
    "id": 1216,
    "context": [
      "All people who are respected by others are people who contribute to the country. ",
      "If a person is respected by others, then he/she contributes to the country. ",
      "All people available to have a visit without any fees are those respected by others. ",
      "All Customers who once served in the army are available to have a visit without any fees. ",
      "All people who once were sentenced for thief stayed in prison for some time. ",
      "All people who once stayed in prison for some time have a bad record in the local state. ",
      "James was either once sentenced for thief or stayed in prison for some time. ",
      "James is either with a bad record in the local state or respected by others. "
    ],
    "question": "James contributes to the country.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nRespected(x) ::: x is respected by others.\nContribute(x) ::: x contributes to the country.\nVisitFree(x) ::: x is available to have a visit without any fees.\nServeArmy(x) ::: x once served in the army.\nThief(x) ::: x was once sentenced for thief.\nStayPrison(x) ::: x once stayed in prison for some time.\nBadRecord(x) ::: x has a bad record in the local state.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Respected(x) → Contribute(x)) ::: All people who are respected by others are people who contribute to the country.\n∀x (Respected(x) → Contribute(x)) ::: If a person is respected by others, then he/she contributes to the country.\n∀x (VisitFree(x) → Respected(x)) ::: All people available to have a visit without any fees are those respected by others.\n∀x (ServeArmy(x) → VisitFree(x)) ::: All Customers who once served in the army are available to have a visit without any fees.\n∀x (Thief(x) → StayPrison(x)) ::: All people who once were sentenced for thief stayed in prison for some time.\n∀x (StayPrison(x) → BadRecord(x)) ::: All people who once stayed in prison for some time have a bad record in the local state.\n(Thief(james) ∨ StayPrison(james)) ::: James was either once sentenced for thief or stayed in prison for some time.\n(BadRecord(james) ∨ Respected(james)) ::: James is either with a bad record in the local state or respected by others.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nContribute(james) ::: James contributes to the country.\n\"\"\""
    ]
  },
  {
    "id": 1217,
    "context": [
      "All people who are respected by others are people who contribute to the country. ",
      "If a person is respected by others, then he/she contributes to the country. ",
      "All people available to have a visit without any fees are those respected by others. ",
      "All Customers who once served in the army are available to have a visit without any fees. ",
      "All people who once were sentenced for thief stayed in prison for some time. ",
      "All people who once stayed in prison for some time have a bad record in the local state. ",
      "James was either once sentenced for thief or stayed in prison for some time. ",
      "James is either with a bad record in the local state or respected by others. "
    ],
    "question": "James does not contribute to the country.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nRespected(x) ::: x is respected by others.\nContribute(x) ::: x contributes to the country.\nAvailable(x) ::: x is available to have a visit without any fees.\nServeArmy(x) ::: x once served in the army.\nThief(x) ::: x was once sentenced for thief.\nStayPrison(x) ::: x once stayed in prison for some time.\nBadRecord(x) ::: x has a bad record in the local state.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Respected(x) → Contribute(x)) ::: All people who are respected by others are people who contribute to the country.\n∀x (Respected(x) → Contribute(x)) ::: If a person is respected by others, then he/she contributes to the country.\n∀x (Available(x) → Respected(x)) ::: All people available to have a visit without any fees are those respected by others.\n∀x (ServeArmy(x) → Available(x)) ::: All Customers who once served in the army are available to have a visit without any fees.\n∀x (Thief(x) → StayPrison(x)) ::: All people who once were sentenced for thief stayed in prison for some time.\n∀x (StayPrison(x) → BadRecord(x)) ::: All people who once stayed in prison for some time have a bad record in the local state.\n(Thief(james) ∨ StayPrison(james)) ::: James was either once sentenced for thief or stayed in prison for some time.\n(BadRecord(james) ∨ Respected(james)) ::: James is either with a bad record in the local state or respected by others.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬Contribute(james) ::: James does not contribute to the country.\n\"\"\""
    ]
  },
  {
    "id": 1218,
    "context": [
      "All people who are respected by others are people who contribute to the country. ",
      "If a person is respected by others, then he/she contributes to the country. ",
      "All people available to have a visit without any fees are those respected by others. ",
      "All Customers who once served in the army are available to have a visit without any fees. ",
      "All people who once were sentenced for thief stayed in prison for some time. ",
      "All people who once stayed in prison for some time have a bad record in the local state. ",
      "James was either once sentenced for thief or stayed in prison for some time. ",
      "James is either with a bad record in the local state or respected by others. "
    ],
    "question": "James contributes to the country, and he once served in the army.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nRespected(x) ::: x is respected by others.\nContribute(x) ::: x contributes to the country.\nVisitFree(x) ::: x is available to have a visit without any fees.\nServeArmy(x) ::: x once served in the army.\nThief(x) ::: x was once sentenced for thief.\nStayPrison(x) ::: x once stayed in prison for some time.\nBadRecord(x) ::: x has a bad record in the local state.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Respected(x) → Contribute(x)) ::: All people who are respected by others are people who contribute to the country.\n∀x (Respected(x) → Contribute(x)) ::: If a person is respected by others, then he/she contributes to the country.\n∀x (VisitFree(x) → Respected(x)) ::: All people available to have a visit without any fees are those respected by others.\n∀x (ServeArmy(x) → VisitFree(x)) ::: All Customers who once served in the army are available to have a visit without any fees.\n∀x (Thief(x) → StayPrison(x)) ::: All people who once were sentenced for thief stayed in prison for some time.\n∀x (StayPrison(x) → BadRecord(x)) ::: All people who once stayed in prison for some time have a bad record in the local state.\n(Thief(james) ∨ StayPrison(james)) ::: James was either once sentenced for thief or stayed in prison for some time.\n(BadRecord(james) ∨ Respected(james)) ::: James is either with a bad record in the local state or respected by others.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nContribute(james) ∧ ServeArmy(james) ::: James contributes to the country, and he once served in the army.\n\"\"\""
    ]
  },
  {
    "id": 1219,
    "context": [
      "All people who are respected by others are people who contribute to the country. ",
      "If a person is respected by others, then he/she contributes to the country. ",
      "All people available to have a visit without any fees are those respected by others. ",
      "All Customers who once served in the army are available to have a visit without any fees. ",
      "All people who once were sentenced for thief stayed in prison for some time. ",
      "All people who once stayed in prison for some time have a bad record in the local state. ",
      "James was either once sentenced for thief or stayed in prison for some time. ",
      "James is either with a bad record in the local state or respected by others. "
    ],
    "question": "James did not contribute to the country and did not serve in the army.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nRespected(x) ::: x is respected by others.\nContribute(x) ::: x contributes to the country.\nVisitFree(x) ::: x is available to have a visit without any fees.\nArmy(x) ::: x served in the army.\nThief(x) ::: x was once sentenced for thief.\nStayedInPrison(x) ::: x once stayed in prison for some time.\nBadRecord(x) ::: x has a bad record in the local state.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Respected(x) → Contribute(x)) ::: All people who are respected by others are people who contribute to the country.\n∀x (Respected(x) → Contribute(x)) ::: If a person is respected by others, then he/she contributes to the country.\n∀x (VisitFree(x) → Respected(x)) ::: All people available to have a visit without any fees are those respected by others.\n∀x (Army(x) → VisitFree(x)) ::: All Customers who once served in the army are available to have a visit without any fees.\n∀x (Thief(x) → StayedInPrison(x)) ::: All people who once were sentenced for thief stayed in prison for some time.\n∀x (StayedInPrison(x) → BadRecord(x)) ::: All people who once stayed in prison for some time have a bad record in the local state.\n(Thief(james) ∨ StayedInPrison(james)) ::: James was either once sentenced for thief or stayed in prison for some time.\n(BadRecord(james) ∨ Respected(james)) ::: James is either with a bad record in the local state or respected by others.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬(Contribute(james) ∧ Army(james)) ::: James did not contribute to the country and did not serve in the army.\n\"\"\""
    ]
  },
  {
    "id": 32,
    "context": [
      "The Croton River watershed is the drainage basin of the Croton River.",
      "The Croton River is in southwestern New York.",
      "Water from the Croton River watershed flows to the Bronx.",
      "The Bronx is in New York."
    ],
    "question": "Water from the Croton River watershed flows to somewhere in New York.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nWatershed(x) ::: x is a watershed.\nDrainageBasin(x, y) ::: x is the drainage basin of y.\nRiver(x) ::: x is a river.\nLocation(x, y) ::: x is located in y.\nFlowsTo(x, y) ::: water from x flows to y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nDrainageBasin(crotonRiverWatershed, crotonRiver) ::: The Croton River watershed is the drainage basin of the Croton River.\nLocation(crotonRiver, southwesternNewYork) ::: The Croton River is in southwestern New York.\nFlowsTo(crotonRiverWatershed, bronx) ::: Water from the Croton River watershed flows to the Bronx.\nLocation(bronx, newYork) ::: The Bronx is in New York.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n∃x (FlowsTo(crotonRiverWatershed, x) ∧ Location(x, newYork)) ::: Water from the Croton River watershed flows to somewhere in New York.\n\"\"\""
    ]
  },
  {
    "id": 33,
    "context": [
      "The Croton River watershed is the drainage basin of the Croton River.",
      "The Croton River is in southwestern New York.",
      "Water from the Croton River watershed flows to the Bronx.",
      "The Bronx is in New York."
    ],
    "question": "The Croton River watershed is in the Bronx.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nWatershed(x) ::: x is a watershed.\nRiver(x) ::: x is a river.\nIn(x, y) ::: x is in y.\nFlowsTo(x, y) ::: water from x flows to y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nWatershed(crotonRiver) ∧ River(crotonRiver) ∧ In(crotonRiver, southwesternNewYork) ::: The Croton River is in southwestern New York.\nWatershed(crotonRiverWatershed) ∧ In(crotonRiverWatershed, crotonRiver) ::: The Croton River watershed is the drainage basin of the Croton River.\nFlowsTo(crotonRiverWatershed, bronx) ::: Water from the Croton River watershed flows to the Bronx.\nIn(bronx, newYork) ::: The Bronx is in New York.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nIn(crotonRiverWatershed, bronx) ::: The Croton River watershed is in the Bronx.\n\"\"\""
    ]
  },
  {
    "id": 34,
    "context": [
      "The Croton River watershed is the drainage basin of the Croton River.",
      "The Croton River is in southwestern New York.",
      "Water from the Croton River watershed flows to the Bronx.",
      "The Bronx is in New York."
    ],
    "question": "Water from the Croton River flows to the Bronx.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nWatershed(x) ::: x is a watershed.\nDrainageBasin(x, y) ::: x is the drainage basin of y.\nRiver(x) ::: x is a river.\nLocation(x, y) ::: x is located in y.\nFlowsTo(x, y) ::: water from x flows to y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nDrainageBasin(crotonRiverWatershed, crotonRiver) ::: The Croton River watershed is the drainage basin of the Croton River.\nLocation(crotonRiver, southwesternNewYork) ::: The Croton River is in southwestern New York.\nFlowsTo(crotonRiverWatershed, bronx) ::: Water from the Croton River watershed flows to the Bronx.\nLocation(bronx, newYork) ::: The Bronx is in New York.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nFlowsTo(crotonRiver, bronx) ::: Water from the Croton River flows to the Bronx.\n\"\"\""
    ]
  },
  {
    "id": 710,
    "context": [
      "All nuclear-powered submarines are warships.",
      "No nuclear-powered submarines are commercial vessels."
    ],
    "question": "Some warships are commercial vessels.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nNuclearPowered(x) ::: x is a nuclear-powered submarine.\nWarship(x) ::: x is a warship.\nCommercialVessel(x) ::: x is a commercial vessel.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (NuclearPowered(x) → Warship(x)) ::: All nuclear-powered submarines are warships.\n∀x (NuclearPowered(x) → ¬CommercialVessel(x)) ::: No nuclear-powered submarines are commercial vessels.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n∃x (Warship(x) ∧ CommercialVessel(x)) ::: Some warships are commercial vessels.\n\"\"\""
    ]
  },
  {
    "id": 199,
    "context": [
      "If a album is written by a rock band, then the genre of the album is rock.",
      "If a band writes a album winning an award, then this band wins this award.",
      "Trouble at the Henhouse is an album by The Tragically Hip.",
      "The Tragically Hip is a Canadian rock band.",
      "The song \"Butts Wigglin'\" is in Trouble at the Henhouse.",
      "Trouble at the Henhouse won the Album of the Year award.",
      "A song in Trouble at the Henhouse appeared in a film."
    ],
    "question": "The genre of Trouble at the Henhouse is rock.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nWrites(x, y) ::: x writes the album y.\nGenre(x, y) ::: The genre of album x is y.\nWins(x, y) ::: x wins the award y.\nBand(x) ::: x is a band.\nAlbum(x) ::: x is an album.\nSong(x) ::: x is a song.\nIn(x, y) ::: x is in the album y.\nAppearedInFilm(x) ::: x appeared in a film.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Band(x) ∧ Writes(x, y) → Genre(y, rock)) ::: If a album is written by a rock band, then the genre of the album is rock.\n∀x (Band(x) ∧ Writes(x, y) ∧ Wins(x, z) → Wins(x, z)) ::: If a band writes a album winning an award, then this band wins this award.\nAlbum(troubleAtTheHenhouse) ∧ Writes(theTragicallyHip, troubleAtTheHenhouse) ::: Trouble at the Henhouse is an album by The Tragically Hip.\nBand(theTragicallyHip) ∧ Genre(theTragicallyHip, canadianRock) ::: The Tragically Hip is a Canadian rock band.\nSong(buttsWigglin) ∧ In(buttsWigglin, troubleAtTheHenhouse) ::: The song \"Butts Wigglin'\" is in Trouble at the Henhouse.\nWins(troubleAtTheHenhouse, albumOfTheYear) ::: Trouble at the Henhouse won the Album of the Year award.\n∃x (Song(x) ∧ In(x, troubleAtTheHenhouse) ∧ AppearedInFilm(x)) ::: A song in Trouble at the Henhouse appeared in a film.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nGenre(troubleAtTheHenhouse, rock) ::: The genre of Trouble at the Henhouse is rock.\n\"\"\""
    ]
  },
  {
    "id": 200,
    "context": [
      "If a album is written by a rock band, then the genre of the album is rock.",
      "If a band writes a album winning an award, then this band wins this award.",
      "Trouble at the Henhouse is an album by The Tragically Hip.",
      "The Tragically Hip is a Canadian rock band.",
      "The song \"Butts Wigglin'\" is in Trouble at the Henhouse.",
      "Trouble at the Henhouse won the Album of the Year award.",
      "A song in Trouble at the Henhouse appeared in a film."
    ],
    "question": "A canada rock band didn't win the Album of the Year award.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nWrites(x, y) ::: x writes the album y.\nGenre(x, y) ::: the genre of the album x is y.\nWins(x, y) ::: x wins the award y.\nBand(x) ::: x is a band.\nAlbum(x) ::: x is an album.\nSong(x) ::: x is a song.\nIn(x, y) ::: x is in the album y.\nAward(x) ::: x is an award.\nAppearedInFilm(x) ::: x appeared in a film.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Band(x) ∧ Writes(x, y) → Wins(x, y)) ::: If a band writes an album winning an award, then this band wins this award.\nWrites(troubleAtTheHenhouse, theTragicallyHip) ::: Trouble at the Henhouse is an album by The Tragically Hip.\nBand(theTragicallyHip) ∧ Genre(troubleAtTheHenhouse, rock) ::: The Tragically Hip is a Canadian rock band.\nSong(buttsWigglin) ∧ In(buttsWigglin, troubleAtTheHenhouse) ::: The song \"Butts Wigglin'\" is in Trouble at the Henhouse.\nWins(troubleAtTheHenhouse, albumOfTheYear) ::: Trouble at the Henhouse won the Album of the Year award.\nSong(x) ∧ In(x, troubleAtTheHenhouse) → AppearedInFilm(x) ::: A song in Trouble at the Henhouse appeared in a film.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n∀x (Band(x) ∧ Genre(troubleAtTheHenhouse, rock) → ¬Wins(troubleAtTheHenhouse, albumOfTheYear)) ::: A Canadian rock band didn't win the Album of the Year award.\n\"\"\""
    ]
  },
  {
    "id": 201,
    "context": [
      "If a album is written by a rock band, then the genre of the album is rock.",
      "If a band writes a album winning an award, then this band wins this award.",
      "Trouble at the Henhouse is an album by The Tragically Hip.",
      "The Tragically Hip is a Canadian rock band.",
      "The song \"Butts Wigglin'\" is in Trouble at the Henhouse.",
      "Trouble at the Henhouse won the Album of the Year award.",
      "A song in Trouble at the Henhouse appeared in a film."
    ],
    "question": "\"Butts Wigglin'\" appeared in a film.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nWrittenBy(x, y) ::: x is written by y.\nGenre(x, y) ::: x is of genre y.\nWinsAward(x, y) ::: x wins award y.\nBand(x) ::: x is a band.\nAlbum(x) ::: x is an album.\nSong(x) ::: x is a song.\nInAlbum(x, y) ::: x is in album y.\nFilm(x) ::: x is a film.\nAppearedInFilm(x) ::: x appeared in a film.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (WrittenBy(x, rockBand) → Genre(x, rock)) ::: If an album is written by a rock band, then the genre of the album is rock.\n∀x (Band(x) ∧ Writes(x, album) ∧ WinsAward(x, award) → WinsAward(x, award)) ::: If a band writes an album winning an award, then this band wins this award.\nAlbum(troubleAtTheHenhouse) ∧ WrittenBy(troubleAtTheHenhouse, tragicallyHip) ::: Trouble at the Henhouse is an album by The Tragically Hip.\nBand(tragicallyHip) ∧ Canadian(tragicallyHip) ∧ RockBand(tragicallyHip) ::: The Tragically Hip is a Canadian rock band.\nSong(buttsWigglin) ∧ InAlbum(buttsWigglin, troubleAtTheHenhouse) ::: The song \"Butts Wigglin'\" is in Trouble at the Henhouse.\nWinsAward(troubleAtTheHenhouse, albumOfTheYear) ::: Trouble at the Henhouse won the Album of the Year award.\n∃x (Song(x) ∧ InAlbum(x, troubleAtTheHenhouse) ∧ AppearedInFilm(x)) ::: A song in Trouble at the Henhouse appeared in a film.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nAppearedInFilm(buttsWigglin) ::: \"Butts Wigglin'\" appeared in a film.\n\"\"\""
    ]
  },
  {
    "id": 681,
    "context": [
      "Daniel is a software engineer and he works at Palantir Technologies.",
      "Daniel studied bioengineering during his undergraduate at Rice University.",
      "Daniel’s older sister works at Meta as a technical sourcer. ",
      "Daniel’s dad and older sister both graduated from Stanford University.",
      "Daniel’s dad is a doctor practicing internal medicine at a veteran’s hospital in Minneapolis"
    ],
    "question": "Daniel once applied to Stanford University, but he couldn’t get in even though he has family members who are Stanford alumni.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nEngineer(x) ::: x is a software engineer.\nWorksAt(x, y) ::: x works at y.\nStudy(x, y) ::: x studied y.\nUndergraduateAt(x, y) ::: x studied y during his undergraduate.\nSibling(x, y) ::: x is a sibling of y.\nOlder(x, y) ::: x is older than y.\nWorksAtMeta(x) ::: x works at Meta.\nSourcer(x) ::: x is a technical sourcer.\nGraduatedFrom(x, y) ::: x graduated from y.\nDoctor(x) ::: x is a doctor.\nPracticing(x, y) ::: x is practicing y.\nInternalMedicine(x) ::: x practices internal medicine.\nHospital(x) ::: x is a hospital.\nApplyTo(x, y) ::: x applied to y.\nGetIn(x, y) ::: x got into y.\nAlumniOf(x, y) ::: x is an alumni of y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nEngineer(daniel) ∧ WorksAt(daniel, palantir) ::: Daniel is a software engineer and he works at Palantir Technologies.\nStudy(daniel, bioengineering) ∧ UndergraduateAt(daniel, riceUniversity) ::: Daniel studied bioengineering during his undergraduate at Rice University.\nWorksAt(danielSibling, meta) ∧ Sourcer(danielSibling) ∧ Sibling(danielSibling, daniel) ∧ Older(danielSibling, daniel) ::: Daniel’s older sister works at Meta as a technical sourcer.\nGraduatedFrom(danielDad, stanfordUniversity) ∧ GraduatedFrom(danielSibling, stanfordUniversity) ∧ Sibling(danielSibling, daniel) ::: Daniel’s dad and older sister both graduated from Stanford University.\nDoctor(danielDad) ∧ Practicing(danielDad, internalMedicine) ∧ Hospital(internalMedicineHospital, minneapolis) ::: Daniel’s dad is a doctor practicing internal medicine at a veteran’s hospital in Minneapolis.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nApplyTo(daniel, stanfordUniversity) ∧ ¬GetIn(daniel, stanfordUniversity) ∧ (∃x (GraduatedFrom(x, stanfordUniversity) ∧ Sibling(x, daniel))) ::: Daniel once applied to Stanford University, but he couldn’t get in even though he has family members who are Stanford alumni.\n\"\"\""
    ]
  },
  {
    "id": 682,
    "context": [
      "Daniel is a software engineer and he works at Palantir Technologies.",
      "Daniel studied bioengineering during his undergraduate at Rice University.",
      "Daniel’s older sister works at Meta as a technical sourcer. ",
      "Daniel’s dad and older sister both graduated from Stanford University.",
      "Daniel’s dad is a doctor practicing internal medicine at a veteran’s hospital in Minneapolis"
    ],
    "question": "Daniel studied bioengineering as his major at Rice University.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nSoftwareEngineer(x) ::: x is a software engineer.\nWorksAt(x, y) ::: x works at company y.\nStudied(x, y) ::: x studied subject y.\nOlderSister(x, y) ::: x has an older sister named y.\nWorksAt(x, y) ::: x works at company y.\nGraduatedFrom(x, y) ::: x graduated from university y.\nDoctor(x) ::: x is a doctor.\nPracticing(x, y) ::: x is practicing field y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nSoftwareEngineer(daniel) ∧ WorksAt(daniel, palantirTechnologies) ::: Daniel is a software engineer and he works at Palantir Technologies.\nStudied(daniel, bioengineering) ∧ GraduatedFrom(daniel, riceUniversity) ::: Daniel studied bioengineering during his undergraduate at Rice University.\nWorksAt(olderSister(daniel), meta) ::: Daniel’s older sister works at Meta as a technical sourcer.\nGraduatedFrom(dad(daniel), stanfordUniversity) ∧ GraduatedFrom(olderSister(daniel), stanfordUniversity) ::: Daniel’s dad and older sister both graduated from Stanford University.\nDoctor(dad(daniel)) ∧ Practicing(dad(daniel), internalMedicine) ∧ WorksAt(dad(daniel), veteransHospitalMinneapolis) ::: Daniel’s dad is a doctor practicing internal medicine at a veteran’s hospital in Minneapolis.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nStudied(daniel, bioengineering) ∧ GraduatedFrom(daniel, riceUniversity) ::: Daniel studied bioengineering as his major at Rice University.\n\"\"\""
    ]
  },
  {
    "id": 683,
    "context": [
      "Daniel is a software engineer and he works at Palantir Technologies.",
      "Daniel studied bioengineering during his undergraduate at Rice University.",
      "Daniel’s older sister works at Meta as a technical sourcer. ",
      "Daniel’s dad and older sister both graduated from Stanford University.",
      "Daniel’s dad is a doctor practicing internal medicine at a veteran’s hospital in Minneapolis"
    ],
    "question": "Daniel and his sister grew up in Minneapolis, Minnesota.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nSoftwareEngineer(x) ::: x is a software engineer.\nWorksAt(x, y) ::: x works at company y.\nStudies(x, y) ::: x studied y.\nSibling(x, y) ::: x is a sibling of y.\nGraduatedFrom(x, y) ::: x graduated from university y.\nDoctor(x) ::: x is a doctor.\nPractices(x, y) ::: x practices medicine at location y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nSoftwareEngineer(daniel) ∧ WorksAt(daniel, palantirTechnologies) ::: Daniel is a software engineer and he works at Palantir Technologies.\nStudies(daniel, bioengineering) ∧ GraduatedFrom(daniel, riceUniversity) ::: Daniel studied bioengineering during his undergraduate at Rice University.\nWorksAt(sisterOfDaniel, meta) ∧ Sibling(sisterOfDaniel, daniel) ::: Daniel’s older sister works at Meta as a technical sourcer.\nGraduatedFrom(dadOfDaniel, stanfordUniversity) ∧ GraduatedFrom(sisterOfDaniel, stanfordUniversity) ::: Daniel’s dad and older sister both graduated from Stanford University.\nDoctor(dadOfDaniel) ∧ Practices(dadOfDaniel, internalMedicine) ∧ Practices(dadOfDaniel, veteransHospitalMinneapolis) ::: Daniel’s dad is a doctor practicing internal medicine at a veteran’s hospital in Minneapolis.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nPractices(dadOfDaniel, veteransHospitalMinneapolis) ∧ Practices(sisterOfDaniel, veteransHospitalMinneapolis) ::: Daniel and his sister grew up in Minneapolis, Minnesota.\n\"\"\""
    ]
  },
  {
    "id": 327,
    "context": [
      "All commerical aircraft are produced by either Boeing or Airbus.",
      "All American Airlines jets are commerical aircraft. ",
      "Airbus made more in revenue than Boeing last year."
    ],
    "question": "An American Airlines plane is either a Boeing or Airbus plane.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nProducedBy(x, y) ::: x is produced by y.\nCommercialAircraft(x) ::: x is a commercial aircraft.\nBoeing(x) ::: x is produced by Boeing.\nAirbus(x) ::: x is produced by Airbus.\nAmericanAirlines(x) ::: x is an American Airlines jet.\nMadeMoreInRevenue(x, y) ::: x made more in revenue than y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (CommercialAircraft(x) → (ProducedBy(x, Boeing) ∨ ProducedBy(x, Airbus))) ::: All commercial aircraft are produced by either Boeing or Airbus.\n∀x (AmericanAirlines(x) → CommercialAircraft(x)) ::: All American Airlines jets are commercial aircraft.\nMadeMoreInRevenue(Airbus, Boeing) ::: Airbus made more in revenue than Boeing last year.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nAmericanAirlines(plane) → (Boeing(plane) ∨ Airbus(plane)) ::: An American Airlines plane is either a Boeing or Airbus plane.\n\"\"\""
    ]
  },
  {
    "id": 328,
    "context": [
      "All commerical aircraft are produced by either Boeing or Airbus.",
      "All American Airlines jets are commerical aircraft. ",
      "Airbus made more in revenue than Boeing last year."
    ],
    "question": "There exists a SpaceX commerical aircraft.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nProducedBy(x, y) ::: x is produced by y.\nCommercialAircraft(x) ::: x is a commercial aircraft.\nBoeing(x) ::: x is Boeing.\nAirbus(x) ::: x is Airbus.\nAmericanAirlines(x) ::: x is an American Airlines jet.\nMadeMoreInRevenue(x, y) ::: x made more in revenue than y.\nSpaceX(x) ::: x is SpaceX.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (CommercialAircraft(x) → (ProducedBy(x, Boeing) ∨ ProducedBy(x, Airbus))) ::: All commercial aircraft are produced by either Boeing or Airbus.\n∀x (AmericanAirlines(x) → CommercialAircraft(x)) ::: All American Airlines jets are commercial aircraft.\nMadeMoreInRevenue(Airbus, Boeing) ::: Airbus made more in revenue than Boeing last year.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n∃x (CommercialAircraft(x) ∧ ProducedBy(x, SpaceX)) ::: There exists a SpaceX commercial aircraft.\n\"\"\""
    ]
  },
  {
    "id": 329,
    "context": [
      "All commerical aircraft are produced by either Boeing or Airbus.",
      "All American Airlines jets are commerical aircraft. ",
      "Airbus made more in revenue than Boeing last year."
    ],
    "question": "There does not exist a United Airlines plane produced by Boeing.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nProducedBy(x, y) ::: x is produced by y.\nCommercialAircraft(x) ::: x is a commercial aircraft.\nBoeing(x) ::: x is Boeing.\nAirbus(x) ::: x is Airbus.\nAmericanAirlines(x) ::: x is an American Airlines jet.\nUnitedAirlines(x) ::: x is a United Airlines plane.\nMadeMoreInRevenue(x, y) ::: x made more in revenue than y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (CommercialAircraft(x) → (ProducedBy(x, Boeing) ∨ ProducedBy(x, Airbus))) ::: All commercial aircraft are produced by either Boeing or Airbus.\n∀x (AmericanAirlines(x) → CommercialAircraft(x)) ::: All American Airlines jets are commercial aircraft.\nMadeMoreInRevenue(Airbus, Boeing) ::: Airbus made more in revenue than Boeing last year.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬∃x (UnitedAirlines(x) ∧ ProducedBy(x, Boeing)) ::: There does not exist a United Airlines plane produced by Boeing.\n\"\"\""
    ]
  },
  {
    "id": 330,
    "context": [
      "All commerical aircraft are produced by either Boeing or Airbus.",
      "All American Airlines jets are commerical aircraft. ",
      "Airbus made more in revenue than Boeing last year."
    ],
    "question": "There is a commercial plane made by both Airbus and Boeing.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nCommercialAircraft(x) ::: x is a commercial aircraft.\nProducedBy(x, y) ::: x is produced by y.\nBoeing(x) ::: x is Boeing.\nAirbus(x) ::: x is Airbus.\nAmericanAirlines(x) ::: x is an American Airlines jet.\nMadeMoreInRevenue(x, y) ::: x made more in revenue than y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (CommercialAircraft(x) → (ProducedBy(x, Boeing) ∨ ProducedBy(x, Airbus))) ::: All commercial aircraft are produced by either Boeing or Airbus.\n∀x (AmericanAirlines(x) → CommercialAircraft(x)) ::: All American Airlines jets are commercial aircraft.\nMadeMoreInRevenue(Airbus, Boeing) ::: Airbus made more in revenue than Boeing last year.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n∃x (CommercialAircraft(x) ∧ ProducedBy(x, Boeing) ∧ ProducedBy(x, Airbus)) ::: There is a commercial plane made by both Airbus and Boeing.\n\"\"\""
    ]
  },
  {
    "id": 256,
    "context": [
      "Luzon is an island in the Philippines.",
      "In December 1999, an earthquake struck Luzon.",
      "People died in the December 1999 earthquake in Luzon."
    ],
    "question": "Leyte is an island in the Philippines.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nIsland(x) ::: x is an island.\nEarthquake(x, y) ::: An earthquake occurred in x in year y.\nDie(x, y) ::: People died in the event x in year y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nIsland(luzon) ::: Luzon is an island in the Philippines.\nEarthquake(luzon, 1999) ::: In December 1999, an earthquake struck Luzon.\nDie(earthquakeInLuzon1999, luzon) ::: People died in the December 1999 earthquake in Luzon.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nIsland(leyte) ::: Leyte is an island in the Philippines.\n\"\"\""
    ]
  },
  {
    "id": 257,
    "context": [
      "Luzon is an island in the Philippines.",
      "In December 1999, an earthquake struck Luzon.",
      "People died in the December 1999 earthquake in Luzon."
    ],
    "question": "No one has ever died of an earthquake that struck in the Philippines.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nIsland(x) ::: x is an island.\nStruck(x, y) ::: x was struck by y.\nDied(x, y) ::: x died in event y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nIsland(luzon) ∧ Island(philippines) ∧ Struck(luzon, earthquakeDecember1999) ∧ Died(people, earthquakeDecember1999) ::: Luzon is an island in the Philippines. In December 1999, an earthquake struck Luzon. People died in the December 1999 earthquake in Luzon.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬∃x ∃y (Island(x) ∧ Struck(y, philippines) ∧ Died(x, y)) ::: No one has ever died of an earthquake that struck in the Philippines.\n\"\"\""
    ]
  },
  {
    "id": 258,
    "context": [
      "Luzon is an island in the Philippines.",
      "In December 1999, an earthquake struck Luzon.",
      "People died in the December 1999 earthquake in Luzon."
    ],
    "question": "In 1999, there was at least one earthquake in the Philippines.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nIsland(x) ::: x is an island.\nEarthquake(x) ::: x is an earthquake.\nStruck(x, y) ::: x struck y.\nDied(x, y) ::: x died in y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nIsland(luzon) ∧ Island(philippines) ∧ In(earthquake1999, december1999) ∧ Struck(earthquake1999, luzon) ::: Luzon is an island in the Philippines. In December 1999, an earthquake struck Luzon.\n∃x (Earthquake(x) ∧ Struck(x, luzon) ∧ Died(people, x)) ::: People died in the December 1999 earthquake in Luzon.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n∃x (Earthquake(x) ∧ Struck(x, philippines) ∧ In(x, 1999)) ::: In 1999, there was at least one earthquake in the Philippines.\n\"\"\""
    ]
  },
  {
    "id": 966,
    "context": [
      "People either invest in the public stock market regularly or enjoy gambling regularly.",
      "If people invest in the public stock market regularly, then they read the Wall Street Journal and other newspapers regularly to keep updated on financial metrics.",
      "All people who enjoy gambling regularly spend a lot of money at casinos and other betting games.",
      "People who spend a lot of money at casinos and other betting games visit the Las Vegas Strip regularly.",
      "People who spend a lot of money at casinos and other betting games have a lot of disposable income to spend.",
      "If Matt invests in the public stock market regularly, then Matt neither has a lot of disposable income to spend nor invests in the public stock market regularly. "
    ],
    "question": "Matt reads the Wall Street Journal and other newspapers regularly to keep updated on financial metrics.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nInvest(x) ::: x invests in the public stock market regularly.\nGambling(x) ::: x enjoys gambling regularly.\nReads(x) ::: x reads the Wall Street Journal and other newspapers regularly to keep updated on financial metrics.\nSpendMoney(x) ::: x spends a lot of money at casinos and other betting games.\nVisit(x) ::: x visits the Las Vegas Strip regularly.\nDisposableIncome(x) ::: x has a lot of disposable income to spend.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Invest(x) ⊕ Gambling(x)) ::: People either invest in the public stock market regularly or enjoy gambling regularly.\n∀x (Invest(x) → (Reads(x) ∧ OtherNewspapers(x))) ::: If people invest in the public stock market regularly, then they read the Wall Street Journal and other newspapers regularly to keep updated on financial metrics.\n∀x (Gambling(x) → SpendMoney(x)) ::: All people who enjoy gambling regularly spend a lot of money at casinos and other betting games.\n∀x (SpendMoney(x) → Visit(x)) ::: People who spend a lot of money at casinos and other betting games visit the Las Vegas Strip regularly.\n∀x (SpendMoney(x) → DisposableIncome(x)) ::: People who spend a lot of money at casinos and other betting games have a lot of disposable income to spend.\nInvest(matt) → ¬(DisposableIncome(matt) ∨ Invest(matt)) ::: If Matt invests in the public stock market regularly, then Matt neither has a lot of disposable income to spend nor invests in the public stock market regularly.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nReads(matt) ::: Matt reads the Wall Street Journal and other newspapers regularly to keep updated on financial metrics.\n\"\"\""
    ]
  },
  {
    "id": 967,
    "context": [
      "People either invest in the public stock market regularly or enjoy gambling regularly.",
      "If people invest in the public stock market regularly, then they read the Wall Street Journal and other newspapers regularly to keep updated on financial metrics.",
      "All people who enjoy gambling regularly spend a lot of money at casinos and other betting games.",
      "People who spend a lot of money at casinos and other betting games visit the Las Vegas Strip regularly.",
      "People who spend a lot of money at casinos and other betting games have a lot of disposable income to spend.",
      "If Matt invests in the public stock market regularly, then Matt neither has a lot of disposable income to spend nor invests in the public stock market regularly. "
    ],
    "question": "If Matt is either both a person who has a lot of disposable income to spend and invests in the public stock market regularly, or neither has a lot of disposable income to spend nor invests in the public stock market regularly, then Matt neither visits the Las Vegas Strip regularly nor reads the Wall Street Journal and other newspapers regularly to keep updated on the financial metrics.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nInvests(x) ::: x invests in the public stock market regularly.\nGamble(x) ::: x enjoys gambling regularly.\nReads(x) ::: x reads the Wall Street Journal and other newspapers regularly to keep updated on financial metrics.\nSpend(x) ::: x spends a lot of money at casinos and other betting games.\nVisit(x) ::: x visits the Las Vegas Strip regularly.\nIncome(x) ::: x has a lot of disposable income to spend.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Invests(x) ⊕ Gamble(x)) ::: People either invest in the public stock market regularly or enjoy gambling regularly.\n∀x (Invests(x) → Reads(x)) ::: If people invest in the public stock market regularly, then they read the Wall Street Journal and other newspapers regularly to keep updated on financial metrics.\n∀x (Gamble(x) → Spend(x)) ::: All people who enjoy gambling regularly spend a lot of money at casinos and other betting games.\n∀x (Spend(x) → Visit(x)) ::: People who spend a lot of money at casinos and other betting games visit the Las Vegas Strip regularly.\n∀x (Spend(x) → Income(x)) ::: People who spend a lot of money at casinos and other betting games have a lot of disposable income to spend.\nInvests(matt) → ¬Income(matt) ∧ ¬Invests(matt) ::: If Matt invests in the public stock market regularly, then Matt neither has a lot of disposable income to spend nor invests in the public stock market regularly.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n( Income(matt) ∧ Invests(matt) ) ⊕ ¬( Income(matt) ∨ Invests(matt) ) → ¬( Visit(matt) ∨ Reads(matt) ) ::: If Matt is either both a person who has a lot of disposable income to spend and invests in the public stock market regularly, or neither has a lot of disposable income to spend nor invests in the public stock market regularly, then Matt neither visits the Las Vegas Strip regularly nor reads the Wall Street Journal and other newspapers regularly to keep updated on the financial metrics.\n\"\"\""
    ]
  },
  {
    "id": 968,
    "context": [
      "People either invest in the public stock market regularly or enjoy gambling regularly.",
      "If people invest in the public stock market regularly, then they read the Wall Street Journal and other newspapers regularly to keep updated on financial metrics.",
      "All people who enjoy gambling regularly spend a lot of money at casinos and other betting games.",
      "People who spend a lot of money at casinos and other betting games visit the Las Vegas Strip regularly.",
      "People who spend a lot of money at casinos and other betting games have a lot of disposable income to spend.",
      "If Matt invests in the public stock market regularly, then Matt neither has a lot of disposable income to spend nor invests in the public stock market regularly. "
    ],
    "question": "If Matt is either a person who has a lot of disposable income to spend or reads the Wall Street Journal and other newspapers regularly, then Matt neither has a lot of disposable income to spend nor visits the Las Vegas Strip Regularly.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nInvest(x) ::: x invests in the public stock market regularly.\nGamble(x) ::: x enjoys gambling regularly.\nReads(x) ::: x reads the Wall Street Journal and other newspapers regularly.\nSpend(x) ::: x spends a lot of money at casinos and other betting games.\nVisit(x) ::: x visits the Las Vegas Strip regularly.\nIncome(x) ::: x has a lot of disposable income to spend.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Invest(x) ⊕ Gamble(x)) ::: People either invest in the public stock market regularly or enjoy gambling regularly.\n∀x (Invest(x) → (Reads(x) ∧ OtherNewspapers(x))) ::: If people invest in the public stock market regularly, then they read the Wall Street Journal and other newspapers regularly to keep updated on financial metrics.\n∀x (Gamble(x) → Spend(x)) ::: All people who enjoy gambling regularly spend a lot of money at casinos and other betting games.\n∀x (Spend(x) → Visit(x)) ::: People who spend a lot of money at casinos and other betting games visit the Las Vegas Strip regularly.\n∀x (Spend(x) → Income(x)) ::: People who spend a lot of money at casinos and other betting games have a lot of disposable income to spend.\nInvest(matt) → ¬(Income(matt) ∨ Invest(matt)) ::: If Matt invests in the public stock market regularly, then Matt neither has a lot of disposable income to spend nor invests in the public stock market regularly.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n(Income(matt) ∨ Reads(matt)) → ¬(Income(matt) ∨ Visit(matt)) ::: If Matt is either a person who has a lot of disposable income to spend or reads the Wall Street Journal and other newspapers regularly, then Matt neither has a lot of disposable income to spend nor visits the Las Vegas Strip Regularly.\n\"\"\""
    ]
  },
  {
    "id": 688,
    "context": [
      "All students learning piano can strike the right notes. ",
      "All students who can strike the right note can get the rhythms right. ",
      "If a student can get the rhythms right, he will start working on coordination between the left and the right hands. ",
      "Some students who start working on coordination between the left and the right hands become good at it. The other students find it challenging. ",
      "If John can strike the right notes, get the rhythms right and is good at coordination between right and left hands, then he puts emotions into his playing. ",
      "John is a student learning piano. ",
      "John does not find coordination between the left and the right hands challenging. "
    ],
    "question": "John can get the rhythms right.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nLearningPiano(x) ::: x is a student learning piano.\nStrikeRightNotes(x) ::: x can strike the right notes.\nGetRhythmsRight(x) ::: x can get the rhythms right.\nCoordination(x) ::: x is good at coordination between left and right hands.\nChallenging(x) ::: x finds it challenging.\nPutEmotions(x) ::: x puts emotions into his playing.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (LearningPiano(x) → StrikeRightNotes(x)) ::: All students learning piano can strike the right notes.\n∀x (StrikeRightNotes(x) → GetRhythmsRight(x)) ::: All students who can strike the right note can get the rhythms right.\n∀x (GetRhythmsRight(x) → Coordination(x)) ::: If a student can get the rhythms right, he will start working on coordination between the left and the right hands.\n∃x (Coordination(x) ∧ GoodAt(x)) ∧ ∃y (Coordination(y) ∧ Challenging(y)) ::: Some students who start working on coordination between the left and the right hands become good at it. The other students find it challenging.\n(StrikeRightNotes(john) ∧ GetRhythmsRight(john) ∧ Coordination(john) ∧ PutEmotions(john)) → PutEmotions(john) ::: If John can strike the right notes, get the rhythms right and is good at coordination between right and left hands, then he puts emotions into his playing.\nLearningPiano(john) ::: John is a student learning piano.\n¬Challenging(john) ::: John does not find coordination between the left and the right hands challenging.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nGetRhythmsRight(john) ::: John can get the rhythms right.\n\"\"\""
    ]
  },
  {
    "id": 689,
    "context": [
      "All students learning piano can strike the right notes. ",
      "All students who can strike the right note can get the rhythms right. ",
      "If a student can get the rhythms right, he will start working on coordination between the left and the right hands. ",
      "Some students who start working on coordination between the left and the right hands become good at it. The other students find it challenging. ",
      "If John can strike the right notes, get the rhythms right and is good at coordination between right and left hands, then he puts emotions into his playing. ",
      "John is a student learning piano. ",
      "John does not find coordination between the left and the right hands challenging. "
    ],
    "question": "John does not put emotions into his playing.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nLearningPiano(x) ::: x is a student learning piano.\nStrikeRightNotes(x) ::: x can strike the right notes.\nGetRhythmsRight(x) ::: x can get the rhythms right.\nWorkOnCoordination(x) ::: x starts working on coordination between the left and right hands.\nGoodAtCoordination(x) ::: x is good at coordination between the left and right hands.\nChallenging(x) ::: x finds it challenging.\nPutEmotions(x) ::: x puts emotions into his playing.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (LearningPiano(x) → StrikeRightNotes(x)) ::: All students learning piano can strike the right notes.\n∀x (StrikeRightNotes(x) → GetRhythmsRight(x)) ::: All students who can strike the right note can get the rhythms right.\n∀x (GetRhythmsRight(x) → WorkOnCoordination(x)) ::: If a student can get the rhythms right, he will start working on coordination between the left and the right hands.\n∃x (WorkOnCoordination(x) ∧ GoodAtCoordination(x)) ∨ (WorkOnCoordination(x) ∧ Challenging(x)) ::: Some students who start working on coordination between the left and the right hands become good at it. The other students find it challenging.\n(StrikeRightNotes(john) ∧ GetRhythmsRight(john) ∧ GoodAtCoordination(john)) → PutEmotions(john) ::: If John can strike the right notes, get the rhythms right and is good at coordination between right and left hands, then he puts emotions into his playing.\nLearningPiano(john) ::: John is a student learning piano.\n¬Challenging(john) ::: John does not find coordination between the left and the right hands challenging.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬PutEmotions(john) ::: John does not put emotions into his playing.\n\"\"\""
    ]
  },
  {
    "id": 654,
    "context": [
      "Barbara Ann Marshall is a former swimmer and former world record-holder.",
      "Barbara Ann Marshall participated in the 1972 Summer Olympics.",
      "Barbara Ann Marshall's home country is the United States.",
      "All people who compete in the 1972 Summer Olympics represent their home country.",
      "Barbara Ann Marshall participated in the preliminary heat in the freestyle relay.",
      "Barbara Ann Marshall did not participate in the event final of the 1972 Summer Olympics freestyle relay.",
      "Only relay swimmers who participated in the event final received medals."
    ],
    "question": "Barbara Ann Marshall did not receive medals.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nSwimmer(x) ::: x is a swimmer.\nRecordHolder(x) ::: x is a world record-holder.\nParticipant(x, y) ::: x participated in event y.\nRepresent(x, y) ::: x represents their home country in event y.\nPreliminaryHeat(x, y) ::: x participated in the preliminary heat of event y.\nEventFinal(x, y) ::: x participated in the event final of event y.\nReceiveMedal(x) ::: x received a medal.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nSwimmer(barbara) ∧ RecordHolder(barbara) ::: Barbara Ann Marshall is a former swimmer and former world record-holder.\nParticipant(barbara, summerOlympics1972) ::: Barbara Ann Marshall participated in the 1972 Summer Olympics.\nRepresent(barbara, unitedStates) ::: Barbara Ann Marshall's home country is the United States.\n∀x (Participant(x, summerOlympics1972) → Represent(x, homeCountry(x))) ::: All people who compete in the 1972 Summer Olympics represent their home country.\nParticipant(barbara, freestyleRelay) ∧ PreliminaryHeat(barbara, freestyleRelay) ::: Barbara Ann Marshall participated in the preliminary heat in the freestyle relay.\nParticipant(barbara, freestyleRelay) ∧ ¬EventFinal(barbara, freestyleRelay) ::: Barbara Ann Marshall did not participate in the event final of the 1972 Summer Olympics freestyle relay.\n∀x (RelaySwimmer(x) ∧ EventFinal(x, event) → ReceiveMedal(x)) ::: Only relay swimmers who participated in the event final received medals.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬ReceiveMedal(barbara) ::: Barbara Ann Marshall did not receive medals.\n\"\"\""
    ]
  },
  {
    "id": 655,
    "context": [
      "Barbara Ann Marshall is a former swimmer and former world record-holder.",
      "Barbara Ann Marshall participated in the 1972 Summer Olympics.",
      "Barbara Ann Marshall's home country is the United States.",
      "All people who compete in the 1972 Summer Olympics represent their home country.",
      "Barbara Ann Marshall participated in the preliminary heat in the freestyle relay.",
      "Barbara Ann Marshall did not participate in the event final of the 1972 Summer Olympics freestyle relay.",
      "Only relay swimmers who participated in the event final received medals."
    ],
    "question": "Barbara Ann Marshall represented the United States in the 1972 Summer Olympics.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nSwimmer(x) ::: x is a swimmer.\nRecordHolder(x) ::: x is a world record-holder.\nParticipant(x, y) ::: x participated in event y.\nHomeCountry(x, y) ::: x's home country is y.\nRepresent(x, y) ::: x represents y.\nEvent(x) ::: x is an event.\nPreliminaryHeat(x, y) ::: x participated in the preliminary heat of event y.\nEventFinal(x, y) ::: x participated in the event final of event y.\nReceivedMedal(x) ::: x received a medal.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nSwimmer(barbara) ∧ RecordHolder(barbara) ::: Barbara Ann Marshall is a former swimmer and former world record-holder.\nParticipant(barbara, summerOlympics1972) ::: Barbara Ann Marshall participated in the 1972 Summer Olympics.\nHomeCountry(barbara, unitedStates) ::: Barbara Ann Marshall's home country is the United States.\n∀x (Participant(x, summerOlympics1972) → Represent(x, HomeCountry(x))) ::: All people who compete in the 1972 Summer Olympics represent their home country.\nParticipant(barbara, freestyleRelayPreliminaryHeat) ::: Barbara Ann Marshall participated in the preliminary heat in the freestyle relay.\n¬Participant(barbara, freestyleRelayEventFinal) ::: Barbara Ann Marshall did not participate in the event final of the 1972 Summer Olympics freestyle relay.\n∀x (RelaySwimmer(x) ∧ Participant(x, freestyleRelayEventFinal) → ReceivedMedal(x)) ::: Only relay swimmers who participated in the event final received medals.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nRepresent(barbara, unitedStates) ∧ Participant(barbara, summerOlympics1972) ::: Barbara Ann Marshall represented the United States in the 1972 Summer Olympics.\n\"\"\""
    ]
  },
  {
    "id": 576,
    "context": [
      "A game is played with three stages: red stage, yellow stage, and green stage.",
      "Each player begins at the red stage.",
      "All players must reach the yellow stage before they can reach the green stage.",
      "The yellow stage comes after the red stage.",
      "All players must proceed one stage at a time."
    ],
    "question": "It is possible to move to the green stage without ever reaching the yellow stage.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nGame(x) ::: x is a game.\nStage(x) ::: x is a stage.\nRed(x) ::: x is the red stage.\nYellow(x) ::: x is the yellow stage.\nGreen(x) ::: x is the green stage.\nPlayer(x) ::: x is a player.\nReach(x, y) ::: x reaches stage y.\nProceed(x, y) ::: x proceeds to stage y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nGame(game) ∧ Stage(red) ∧ Stage(yellow) ∧ Stage(green) ∧ ¬(Red(yellow)) ∧ ¬(Yellow(green)) ∧ ¬(Red(green)) ::: A game is played with three stages: red stage, yellow stage, and green stage.\n∀x (Player(x) → Reach(x, red)) ::: Each player begins at the red stage.\n∀x (Player(x) → (Reach(x, yellow) → Reach(x, green))) ::: All players must reach the yellow stage before they can reach the green stage.\n∀x (Red(x) → Yellow(x)) ::: The yellow stage comes after the red stage.\n∀x (Proceed(x, y) → (Stage(x) ∧ Stage(y))) ::: All players must proceed one stage at a time.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n∃x (Proceed(x, green) ∧ ¬Reach(x, yellow)) ::: It is possible to move to the green stage without ever reaching the yellow stage.\n\"\"\""
    ]
  },
  {
    "id": 577,
    "context": [
      "A game is played with three stages: red stage, yellow stage, and green stage.",
      "Each player begins at the red stage.",
      "All players must reach the yellow stage before they can reach the green stage.",
      "The yellow stage comes after the red stage.",
      "All players must proceed one stage at a time."
    ],
    "question": "It is possible to reach the yellow stage without ever reaching the green stage.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nGame(x) ::: x is a game.\nStage(x) ::: x is a stage.\nRed(x) ::: x is the red stage.\nYellow(x) ::: x is the yellow stage.\nGreen(x) ::: x is the green stage.\nPlayer(x) ::: x is a player.\nReach(x, y) ::: x reaches stage y.\nProceed(x, y) ::: x proceeds to stage y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nGame(game) ∧ Stage(red) ∧ Stage(yellow) ∧ Stage(green) ∧ ¬(Red(yellow) ∨ Yellow(red) ∨ Yellow(green) ∨ Green(red) ∨ Green(yellow)) ::: A game is played with three stages: red stage, yellow stage, and green stage.\n∀x (Player(x) → Reach(x, red)) ::: Each player begins at the red stage.\n∀x (Player(x) → (Reach(x, yellow) → Reach(x, green))) ::: All players must reach the yellow stage before they can reach the green stage.\nYellow(yellow) ∧ Red(red) ∧ ¬(Yellow(red) ∨ Green(yellow)) ::: The yellow stage comes after the red stage.\n∀x (Player(x) → ∀y (Proceed(x, y) → (Reach(x, y) ∧ ¬Reach(x, y-1)))) ::: All players must proceed one stage at a time.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n∃x (Reach(x, yellow) ∧ ¬Reach(x, green)) ::: It is possible to reach the yellow stage without ever reaching the green stage.\n\"\"\""
    ]
  },
  {
    "id": 578,
    "context": [
      "A game is played with three stages: red stage, yellow stage, and green stage.",
      "Each player begins at the red stage.",
      "All players must reach the yellow stage before they can reach the green stage.",
      "The yellow stage comes after the red stage.",
      "All players must proceed one stage at a time."
    ],
    "question": "It is possible to complete the game without ever reaching the green stage.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nGame(x) ::: x is a game.\nStage(x) ::: x is a stage.\nRed(x) ::: x is the red stage.\nYellow(x) ::: x is the yellow stage.\nGreen(x) ::: x is the green stage.\nPlayer(x) ::: x is a player.\nBegin(x, y) ::: x begins at stage y.\nReach(x, y) ::: x reaches stage y.\nProceed(x, y) ::: x proceeds to stage y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nGame(game) ∧ Stage(red) ∧ Stage(yellow) ∧ Stage(green) ∧ ¬(Red(yellow) ∨ Red(green) ∨ Yellow(green)) ::: A game is played with three stages: red stage, yellow stage, and green stage.\n∀x (Player(x) → Begin(x, red)) ::: Each player begins at the red stage.\n∀x (Player(x) → (Reach(x, yellow) → Reach(x, green))) ::: All players must reach the yellow stage before they can reach the green stage.\nYellow(yellow) ∧ Red(red) ∧ ¬(Red(yellow)) ::: The yellow stage comes after the red stage.\n∀x (Player(x) → ∀y (Proceed(x, y) → (Reach(x, y+1) ∨ Reach(x, y-1)))) ::: All players must proceed one stage at a time.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n∃x (Player(x) ∧ ¬Reach(x, green)) ::: It is possible to complete the game without ever reaching the green stage.\n\"\"\""
    ]
  },
  {
    "id": 1095,
    "context": [
      "People either value physical touch as an especially important love language or value words of affirmation as an especially important love language.",
      "If a person values physical touch as an especially important love language, then they are good with pets.",
      "No people that are good with pets are scared of animals.",
      "People are either scared of animals or love animals.",
      "Adam is either a person who values physical touch as an especially important love language or a person who loves animals."
    ],
    "question": "Adam is scared of animals.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nValuePhysicalTouch(x) ::: x values physical touch as an especially important love language.\nValueWordsOfAffirmation(x) ::: x values words of affirmation as an especially important love language.\nGoodWithPets(x) ::: x is good with pets.\nScaredOfAnimals(x) ::: x is scared of animals.\nLoveAnimals(x) ::: x loves animals.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (ValuePhysicalTouch(x) ∨ ValueWordsOfAffirmation(x)) ::: People either value physical touch as an especially important love language or value words of affirmation as an especially important love language.\nValuePhysicalTouch(x) → GoodWithPets(x) ::: If a person values physical touch as an especially important love language, then they are good with pets.\n∀x (GoodWithPets(x) → ¬ScaredOfAnimals(x)) ::: No people that are good with pets are scared of animals.\nScaredOfAnimals(x) ∨ LoveAnimals(x) ::: People are either scared of animals or love animals.\nValuePhysicalTouch(adam) ∨ LoveAnimals(adam) ::: Adam is either a person who values physical touch as an especially important love language or a person who loves animals.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nScaredOfAnimals(adam) ::: Adam is scared of animals.\n\"\"\""
    ]
  },
  {
    "id": 1096,
    "context": [
      "People either value physical touch as an especially important love language or value words of affirmation as an especially important love language.",
      "If a person values physical touch as an especially important love language, then they are good with pets.",
      "No people that are good with pets are scared of animals.",
      "People are either scared of animals or love animals.",
      "Adam is either a person who values physical touch as an especially important love language or a person who loves animals."
    ],
    "question": "Adam values words of affirmation as an especially important love language.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nValuePhysicalTouch(x) ::: x values physical touch as an especially important love language.\nValueWordsOfAffirmation(x) ::: x values words of affirmation as an especially important love language.\nGoodWithPets(x) ::: x is good with pets.\nScaredOfAnimals(x) ::: x is scared of animals.\nLoveAnimals(x) ::: x loves animals.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (ValuePhysicalTouch(x) ∨ ValueWordsOfAffirmation(x)) ::: People either value physical touch as an especially important love language or value words of affirmation as an especially important love language.\nValuePhysicalTouch(x) → GoodWithPets(x) ::: If a person values physical touch as an especially important love language, then they are good with pets.\n∀x (GoodWithPets(x) → ¬ScaredOfAnimals(x)) ::: No people that are good with pets are scared of animals.\nScaredOfAnimals(x) ∨ LoveAnimals(x) ::: People are either scared of animals or love animals.\nValuePhysicalTouch(adam) ∨ LoveAnimals(adam) ::: Adam is either a person who values physical touch as an especially important love language or a person who loves animals.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬ValuePhysicalTouch(adam) ::: Adam values words of affirmation as an especially important love language.\n\"\"\""
    ]
  },
  {
    "id": 1097,
    "context": [
      "People either value physical touch as an especially important love language or value words of affirmation as an especially important love language.",
      "If a person values physical touch as an especially important love language, then they are good with pets.",
      "No people that are good with pets are scared of animals.",
      "People are either scared of animals or love animals.",
      "Adam is either a person who values physical touch as an especially important love language or a person who loves animals."
    ],
    "question": "Adam values physical touch as an especially important love language and values words of affirmation as an especially important love language.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nValuePhysicalTouch(x) ::: x values physical touch as an especially important love language.\nValueWordsOfAffirmation(x) ::: x values words of affirmation as an especially important love language.\nGoodWithPets(x) ::: x is good with pets.\nScaredOfAnimals(x) ::: x is scared of animals.\nLoveAnimals(x) ::: x loves animals.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (ValuePhysicalTouch(x) ∨ ValueWordsOfAffirmation(x)) ::: People either value physical touch as an especially important love language or value words of affirmation as an especially important love language.\nValuePhysicalTouch(x) → GoodWithPets(x) ::: If a person values physical touch as an especially important love language, then they are good with pets.\n∀x (GoodWithPets(x) → ¬ScaredOfAnimals(x)) ::: No people that are good with pets are scared of animals.\nScaredOfAnimals(x) ∨ LoveAnimals(x) ::: People are either scared of animals or love animals.\n(ValuePhysicalTouch(adam) ∨ LoveAnimals(adam)) ::: Adam is either a person who values physical touch as an especially important love language or a person who loves animals.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nValuePhysicalTouch(adam) ∧ ValueWordsOfAffirmation(adam) ::: Adam values physical touch as an especially important love language and values words of affirmation as an especially important love language.\n\"\"\""
    ]
  },
  {
    "id": 1098,
    "context": [
      "People either value physical touch as an especially important love language or value words of affirmation as an especially important love language.",
      "If a person values physical touch as an especially important love language, then they are good with pets.",
      "No people that are good with pets are scared of animals.",
      "People are either scared of animals or love animals.",
      "Adam is either a person who values physical touch as an especially important love language or a person who loves animals."
    ],
    "question": "Adam either values physical touch as an especially important love language or values words of affirmation as an especially important love language.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nValuePhysicalTouch(x) ::: x values physical touch as an especially important love language.\nValueWordsOfAffirmation(x) ::: x values words of affirmation as an especially important love language.\nGoodWithPets(x) ::: x is good with pets.\nScaredOfAnimals(x) ::: x is scared of animals.\nLoveAnimals(x) ::: x loves animals.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (ValuePhysicalTouch(x) ∨ ValueWordsOfAffirmation(x)) ::: People either value physical touch as an especially important love language or value words of affirmation as an especially important love language.\nValuePhysicalTouch(x) → GoodWithPets(x) ::: If a person values physical touch as an especially important love language, then they are good with pets.\n∀x (GoodWithPets(x) → ¬ScaredOfAnimals(x)) ::: No people that are good with pets are scared of animals.\nScaredOfAnimals(x) ∨ LoveAnimals(x) ::: People are either scared of animals or love animals.\n(ValuePhysicalTouch(adam) ∨ LoveAnimals(adam)) ::: Adam is either a person who values physical touch as an especially important love language or a person who loves animals.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nValuePhysicalTouch(adam) ∨ ValueWordsOfAffirmation(adam) ::: Adam either values physical touch as an especially important love language or values words of affirmation as an especially important love language.\n\"\"\""
    ]
  },
  {
    "id": 1099,
    "context": [
      "People either value physical touch as an especially important love language or value words of affirmation as an especially important love language.",
      "If a person values physical touch as an especially important love language, then they are good with pets.",
      "No people that are good with pets are scared of animals.",
      "People are either scared of animals or love animals.",
      "Adam is either a person who values physical touch as an especially important love language or a person who loves animals."
    ],
    "question": "If Adam values physical touch as an especially important love language or is good with pets, then Adam values words of affirmation as an especially important love language.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nValuePhysicalTouch(x) ::: x values physical touch as an especially important love language.\nValueWordsOfAffirmation(x) ::: x values words of affirmation as an especially important love language.\nGoodWithPets(x) ::: x is good with pets.\nScaredOfAnimals(x) ::: x is scared of animals.\nLoveAnimals(x) ::: x loves animals.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (ValuePhysicalTouch(x) ∨ ValueWordsOfAffirmation(x)) ::: People either value physical touch as an especially important love language or value words of affirmation as an especially important love language.\nValuePhysicalTouch(x) → GoodWithPets(x) ::: If a person values physical touch as an especially important love language, then they are good with pets.\n∀x (GoodWithPets(x) → ¬ScaredOfAnimals(x)) ::: No people that are good with pets are scared of animals.\nScaredOfAnimals(x) ∨ LoveAnimals(x) ::: People are either scared of animals or love animals.\nValuePhysicalTouch(adam) ∨ LoveAnimals(adam) ::: Adam is either a person who values physical touch as an especially important love language or a person who loves animals.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n(ValuePhysicalTouch(adam) ∨ GoodWithPets(adam)) → ValueWordsOfAffirmation(adam) ::: If Adam values physical touch as an especially important love language or is good with pets, then Adam values words of affirmation as an especially important love language.\n\"\"\""
    ]
  },
  {
    "id": 1282,
    "context": [
      "All birds have wings.",
      "No animal with wings is a reptile.",
      "Some animals that fly are birds.",
      "If something is an iguana, then it is a reptile.",
      "John is neither an iguana nor a bird."
    ],
    "question": "John is a reptile.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nBird(x) ::: x is a bird.\nWings(x) ::: x has wings.\nAnimal(x) ::: x is an animal.\nReptile(x) ::: x is a reptile.\nFly(x) ::: x can fly.\nIguana(x) ::: x is an iguana.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Bird(x) → Wings(x)) ::: All birds have wings.\n∀x (Wings(x) → ¬Reptile(x)) ::: No animal with wings is a reptile.\n∃x (Animal(x) ∧ Fly(x) ∧ Bird(x)) ::: Some animals that fly are birds.\nIguana(x) → Reptile(x) ::: If something is an iguana, then it is a reptile.\n¬(Iguana(john) ∨ Bird(john)) ::: John is neither an iguana nor a bird.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nReptile(john) ::: John is a reptile.\n\"\"\""
    ]
  },
  {
    "id": 1283,
    "context": [
      "All birds have wings.",
      "No animal with wings is a reptile.",
      "Some animals that fly are birds.",
      "If something is an iguana, then it is a reptile.",
      "John is neither an iguana nor a bird."
    ],
    "question": "John is not an iguana and an animal that can fly.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nBird(x) ::: x is a bird.\nWings(x) ::: x has wings.\nAnimal(x) ::: x is an animal.\nReptile(x) ::: x is a reptile.\nFly(x) ::: x can fly.\nIguana(x) ::: x is an iguana.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Bird(x) → Wings(x)) ::: All birds have wings.\n∀x (Wings(x) → ¬Reptile(x)) ::: No animal with wings is a reptile.\n∃x (Fly(x) ∧ Bird(x)) ::: Some animals that fly are birds.\nIguana(x) → Reptile(x) ::: If something is an iguana, then it is a reptile.\n¬(Iguana(john) ∨ Bird(john)) ::: John is neither an iguana nor a bird.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬Iguana(john) ∧ ∃x (Fly(x) ∧ Animal(x)) ::: John is not an iguana and an animal that can fly.\n\"\"\""
    ]
  },
  {
    "id": 1284,
    "context": [
      "All birds have wings.",
      "No animal with wings is a reptile.",
      "Some animals that fly are birds.",
      "If something is an iguana, then it is a reptile.",
      "John is neither an iguana nor a bird."
    ],
    "question": "John is an animal that can fly and a bird.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nBird(x) ::: x is a bird.\nWings(x) ::: x has wings.\nAnimal(x) ::: x is an animal.\nReptile(x) ::: x is a reptile.\nFly(x) ::: x can fly.\nIguana(x) ::: x is an iguana.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Bird(x) → Wings(x)) ::: All birds have wings.\n∀x (Wings(x) → ¬Reptile(x)) ::: No animal with wings is a reptile.\n∃x (Animal(x) ∧ Fly(x) ∧ Bird(x)) ::: Some animals that fly are birds.\nIguana(x) → Reptile(x) ::: If something is an iguana, then it is a reptile.\n¬(Iguana(john) ∨ Bird(john)) ::: John is neither an iguana nor a bird.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nFly(john) ∧ Bird(john) ::: John is an animal that can fly and a bird.\n\"\"\""
    ]
  },
  {
    "id": 87,
    "context": [
      "EndGame is a movie released in 2006.",
      "EndGame was set in Washington.",
      "EndGame was filmed outside of Washington.",
      "Some movies are filmed in New York.",
      "Andy Chang directed EndGame.",
      "Andy Chang is from Hong Kong."
    ],
    "question": "EndGame was filmed in New York.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nMovie(x) ::: x is a movie.\nReleased(x, y) ::: x is released in year y.\nSetIn(x, y) ::: x is set in location y.\nFilmedIn(x, y) ::: x is filmed in location y.\nFilmedOutside(x, y) ::: x is filmed outside of location y.\nFilmedInCity(x, y) ::: x is filmed in city y.\nDirectedBy(x, y) ::: x is directed by person y.\nFrom(x, y) ::: x is from location y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nMovie(endGame) ∧ Released(endGame, year2006) ::: EndGame is a movie released in 2006.\nSetIn(endGame, washington) ::: EndGame was set in Washington.\nFilmedOutside(endGame, washington) ::: EndGame was filmed outside of Washington.\n∃x (Movie(x) ∧ FilmedIn(x, newYork)) ::: Some movies are filmed in New York.\nDirectedBy(endGame, andyChang) ∧ From(andyChang, hongKong) ::: Andy Chang directed EndGame and is from Hong Kong.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nFilmedInCity(endGame, newYork) ::: EndGame was filmed in New York.\n\"\"\""
    ]
  },
  {
    "id": 88,
    "context": [
      "EndGame is a movie released in 2006.",
      "EndGame was set in Washington.",
      "EndGame was filmed outside of Washington.",
      "Some movies are filmed in New York.",
      "Andy Chang directed EndGame.",
      "Andy Chang is from Hong Kong."
    ],
    "question": "EndGame was not directed by someone from Hong Kong.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nMovie(x) ::: x is a movie.\nReleased(x, y) ::: x is released in year y.\nSetIn(x, y) ::: x is set in location y.\nFilmedOutside(x, y) ::: x is filmed outside of location y.\nFilmedIn(x, y) ::: x is filmed in location y.\nDirectedBy(x, y) ::: x is directed by person y.\nFrom(x, y) ::: x is from location y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nMovie(endGame) ∧ Released(endGame, year2006) ::: EndGame is a movie released in 2006.\nSetIn(endGame, washington) ::: EndGame was set in Washington.\nFilmedOutside(endGame, washington) ::: EndGame was filmed outside of Washington.\n∃x (Movie(x) ∧ FilmedIn(x, newYork)) ::: Some movies are filmed in New York.\nDirectedBy(endGame, andyChang) ∧ From(andyChang, hongKong) ::: Andy Chang directed EndGame and is from Hong Kong.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬From(andyChang, hongKong) ::: EndGame was not directed by someone from Hong Kong.\n\"\"\""
    ]
  },
  {
    "id": 89,
    "context": [
      "EndGame is a movie released in 2006.",
      "EndGame was set in Washington.",
      "EndGame was filmed outside of Washington.",
      "Some movies are filmed in New York.",
      "Andy Chang directed EndGame.",
      "Andy Chang is from Hong Kong."
    ],
    "question": "All of Andy Chang's movies are filmed outside of Washington.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nMovie(x) ::: x is a movie.\nReleased(x, y) ::: x is released in year y.\nSetIn(x, y) ::: x is set in location y.\nFilmedIn(x, y) ::: x is filmed in location y.\nDirectedBy(x, y) ::: x is directed by y.\nFrom(x, y) ::: x is from location y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nMovie(endGame) ∧ Released(endGame, year2006) ::: EndGame is a movie released in 2006.\nSetIn(endGame, washington) ::: EndGame was set in Washington.\n¬FilmedIn(endGame, washington) ::: EndGame was filmed outside of Washington.\n∃x (Movie(x) ∧ FilmedIn(x, newYork)) ::: Some movies are filmed in New York.\nDirectedBy(endGame, andyChang) ∧ From(andyChang, hongKong) ::: Andy Chang directed EndGame and is from Hong Kong.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n∀x (DirectedBy(x, andyChang) → ¬FilmedIn(x, washington)) ::: All of Andy Chang's movies are filmed outside of Washington.\n\"\"\""
    ]
  },
  {
    "id": 17,
    "context": [
      "Six, seven and eight are real numbers.",
      "If a real number equals another real number adding one, the first number is larger.",
      "If the number x is larger than number y, then y is not larger than x.",
      "Seven equals six plus one.",
      "Eight equals seven plus one.",
      "Two is positive.",
      "If a number is positive, then the double of it is also positive.",
      "Eight is the double of four.",
      "Four is the double of two."
    ],
    "question": "Eight is larger than seven.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nReal(x) ::: x is a real number.\nEquals(x, y) ::: x equals y.\nLarger(x, y) ::: x is larger than y.\nPositive(x) ::: x is positive.\nDouble(x, y) ::: y is the double of x.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nReal(six) ∧ Real(seven) ∧ Real(eight) ::: Six, seven and eight are real numbers.\n∀x ∀y ((Real(x) ∧ Real(y) ∧ Equals(x, y + 1)) → Larger(x, y)) ::: If a real number equals another real number adding one, the first number is larger.\n∀x ∀y ((Larger(x, y)) → ¬Larger(y, x)) ::: If the number x is larger than number y, then y is not larger than x.\nEquals(seven, six + 1) ∧ Equals(eight, seven + 1) ::: Seven equals six plus one. Eight equals seven plus one.\nPositive(two) ::: Two is positive.\n∀x ((Positive(x)) → Positive(Double(x, y))) ::: If a number is positive, then the double of it is also positive.\nEquals(eight, Double(four, y)) ∧ Equals(four, Double(two, y)) ::: Eight is the double of four. Four is the double of two.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nLarger(eight, seven) ::: Eight is larger than seven.\n\"\"\""
    ]
  },
  {
    "id": 18,
    "context": [
      "Six, seven and eight are real numbers.",
      "If a real number equals another real number adding one, the first number is larger.",
      "If the number x is larger than number y, then y is not larger than x.",
      "Seven equals six plus one.",
      "Eight equals seven plus one.",
      "Two is positive.",
      "If a number is positive, then the double of it is also positive.",
      "Eight is the double of four.",
      "Four is the double of two."
    ],
    "question": "Eight is positive.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nReal(x) ::: x is a real number.\nLarger(x, y) ::: x is larger than y.\nEquals(x, y) ::: x equals y.\nPositive(x) ::: x is positive.\nDouble(x, y) ::: y is the double of x.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nReal(six) ∧ Real(seven) ∧ Real(eight) ::: Six, seven and eight are real numbers.\n∀x ∀y ((Real(x) ∧ Real(y) ∧ Equals(x, y+1)) → Larger(x, y)) ::: If a real number equals another real number adding one, the first number is larger.\n∀x ∀y ((Larger(x, y)) → ¬Larger(y, x)) ::: If the number x is larger than number y, then y is not larger than x.\nEquals(seven, six+1) ∧ Equals(eight, seven+1) ::: Seven equals six plus one. Eight equals seven plus one.\nPositive(two) ::: Two is positive.\n∀x ((Positive(x)) → Positive(Double(x, y))) ::: If a number is positive, then the double of it is also positive.\nEquals(eight, Double(four, y)) ∧ Equals(four, Double(two, y)) ::: Eight is the double of four. Four is the double of two.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nPositive(eight) ::: Eight is positive.\n\"\"\""
    ]
  },
  {
    "id": 19,
    "context": [
      "Six, seven and eight are real numbers.",
      "If a real number equals another real number adding one, the first number is larger.",
      "If the number x is larger than number y, then y is not larger than x.",
      "Seven equals six plus one.",
      "Eight equals seven plus one.",
      "Two is positive.",
      "If a number is positive, then the double of it is also positive.",
      "Eight is the double of four.",
      "Four is the double of two."
    ],
    "question": "Six is larger than seven.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nReal(x) ::: x is a real number.\nLarger(x, y) ::: x is larger than y.\nPositive(x) ::: x is a positive number.\nDouble(x, y) ::: y is the double of x.\nEquals(x, y) ::: x equals y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nReal(six) ∧ Real(seven) ∧ Real(eight) ::: Six, seven and eight are real numbers.\n∀x ∀y ((Real(x) ∧ Real(y) ∧ Equals(x, y+1)) → Larger(x, y)) ::: If a real number equals another real number adding one, the first number is larger.\n∀x ∀y ((Larger(x, y)) → ¬Larger(y, x)) ::: If the number x is larger than number y, then y is not larger than x.\nEquals(seven, six+1) ∧ Equals(eight, seven+1) ::: Seven equals six plus one. Eight equals seven plus one.\nPositive(two) ::: Two is positive.\n∀x ((Positive(x)) → Positive(Double(x, 2x))) ::: If a number is positive, then the double of it is also positive.\nEquals(eight, Double(four, 2)) ∧ Equals(four, Double(two, 2)) ::: Eight is the double of four. Four is the double of two.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nLarger(six, seven) ::: Six is larger than seven.\n\"\"\""
    ]
  },
  {
    "id": 742,
    "context": [
      "A dog never tells the truth.",
      "Some poker players are dogs."
    ],
    "question": "Some poker players never tell the truth.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nTellsTruth(x) ::: x tells the truth.\nDog(x) ::: x is a dog.\nPokerPlayer(x) ::: x is a poker player.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Dog(x) → ¬TellsTruth(x)) ::: A dog never tells the truth.\n∃x (PokerPlayer(x) ∧ Dog(x)) ::: Some poker players are dogs.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n∃x (PokerPlayer(x) ∧ ¬TellsTruth(x)) ::: Some poker players never tell the truth.\n\"\"\""
    ]
  },
  {
    "id": 1383,
    "context": [
      "All Asians are human. ",
      "All Chinese are Asian.",
      "A man is either Chinese or British.",
      "All British are European. ",
      "All Spanish are European. ",
      "No Indian is European. ",
      "Jessee is either both an Indian and a human, or neither an Indian nor a human."
    ],
    "question": "Jesse is Chinese.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nAsian(x) ::: x is Asian.\nHuman(x) ::: x is human.\nChinese(x) ::: x is Chinese.\nBritish(x) ::: x is British.\nEuropean(x) ::: x is European.\nIndian(x) ::: x is Indian.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Asian(x) → Human(x)) ::: All Asians are human.\n∀x (Chinese(x) → Asian(x)) ::: All Chinese are Asian.\n∀x (Man(x) ↔ (Chinese(x) ∨ British(x))) ::: A man is either Chinese or British.\n∀x (British(x) → European(x)) ::: All British are European.\n∀x (Spanish(x) → European(x)) ::: All Spanish are European.\n∀x (Indian(x) → ¬European(x)) ::: No Indian is European.\n(Indian(jessee) ∧ Human(jessee)) ⊕ ¬(Indian(jessee) ∨ Human(jessee)) ::: Jessee is either both an Indian and a human, or neither an Indian nor a human.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nChinese(jessee) ::: Jesse is Chinese.\n\"\"\""
    ]
  },
  {
    "id": 1384,
    "context": [
      "All Asians are human. ",
      "All Chinese are Asian.",
      "A man is either Chinese or British.",
      "All British are European. ",
      "All Spanish are European. ",
      "No Indian is European. ",
      "Jessee is either both an Indian and a human, or neither an Indian nor a human."
    ],
    "question": "Jesse is not Chinese.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nAsian(x) ::: x is Asian.\nHuman(x) ::: x is human.\nChinese(x) ::: x is Chinese.\nBritish(x) ::: x is British.\nEuropean(x) ::: x is European.\nSpanish(x) ::: x is Spanish.\nIndian(x) ::: x is Indian.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Asian(x) → Human(x)) ::: All Asians are human.\n∀x (Chinese(x) → Asian(x)) ::: All Chinese are Asian.\n∀x (Chinese(x) ∨ British(x)) ::: A man is either Chinese or British.\n∀x (British(x) → European(x)) ::: All British are European.\n∀x (Spanish(x) → European(x)) ::: All Spanish are European.\n∀x (Indian(x) → ¬European(x)) ::: No Indian is European.\n(Indian(jessee) ∧ Human(jessee)) ⊕ ¬(Indian(jessee) ∨ Human(jessee)) ::: Jessee is either both an Indian and a human, or neither an Indian nor a human.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬Chinese(jessee) ::: Jesse is not Chinese.\n\"\"\""
    ]
  },
  {
    "id": 1385,
    "context": [
      "All Asians are human. ",
      "All Chinese are Asian.",
      "A man is either Chinese or British.",
      "All British are European. ",
      "All Spanish are European. ",
      "No Indian is European. ",
      "Jessee is either both an Indian and a human, or neither an Indian nor a human."
    ],
    "question": "If Jesse is either an Indian or a Spanish, then Jesse is either both British and European, or neither British nor European.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nAsian(x) ::: x is Asian.\nHuman(x) ::: x is human.\nChinese(x) ::: x is Chinese.\nMan(x) ::: x is a man.\nBritish(x) ::: x is British.\nEuropean(x) ::: x is European.\nSpanish(x) ::: x is Spanish.\nIndian(x) ::: x is Indian.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Asian(x) → Human(x)) ::: All Asians are human.\n∀x (Chinese(x) → Asian(x)) ::: All Chinese are Asian.\nMan(x) ↔ (Chinese(x) ∨ British(x)) ::: A man is either Chinese or British.\n∀x (British(x) → European(x)) ::: All British are European.\n∀x (Spanish(x) → European(x)) ::: All Spanish are European.\n∀x (Indian(x) → ¬European(x)) ::: No Indian is European.\n(Indian(jessee) ∧ Human(jessee)) ⊕ ¬(Indian(jessee) ∨ Human(jessee)) ::: Jessee is either both an Indian and a human, or neither an Indian nor a human.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n(Indian(jessee) ∨ Spanish(jessee)) → (British(jessee) ∧ European(jessee)) ⊕ ¬(British(jessee) ∨ European(jessee)) ::: If Jesse is either an Indian or a Spanish, then Jesse is either both British and European, or neither British nor European.\n\"\"\""
    ]
  },
  {
    "id": 717,
    "context": [
      "No people who never admit a mistake are good teachers.",
      "Some well-informed people are people who never admit a mistake."
    ],
    "question": "Some good teachers are not well-informed people.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nAdmit(x) ::: x admits a mistake.\nGoodTeacher(x) ::: x is a good teacher.\nWellInformed(x) ::: x is well-informed.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (¬Admit(x) → ¬GoodTeacher(x)) ::: No people who never admit a mistake are good teachers.\n∃x (WellInformed(x) ∧ ¬Admit(x)) ::: Some well-informed people are people who never admit a mistake.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n∃x (GoodTeacher(x) ∧ ¬WellInformed(x)) ::: Some good teachers are not well-informed people.\n\"\"\""
    ]
  },
  {
    "id": 72,
    "context": [
      "Philatelic literature is divided into the following categories: Stamp catalogues, Periodicals, Auction catalogues, Books, Bibliographies, and Background Material",
      "Mort is not a Stamp catalogue.",
      "Mort is not a periodical, auction catalogue, bibliography, or background material.",
      "Mort is a piece of Philatelic literature."
    ],
    "question": "Mort is a book",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nStampCatalogue(x) ::: x is a stamp catalogue.\nPeriodical(x) ::: x is a periodical.\nAuctionCatalogue(x) ::: x is an auction catalogue.\nBook(x) ::: x is a book.\nBibliography(x) ::: x is a bibliography.\nBackgroundMaterial(x) ::: x is background material.\nPhilatelicLiterature(x) ::: x is philatelic literature.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (PhilatelicLiterature(x) ↔ StampCatalogue(x) ∨ Periodical(x) ∨ AuctionCatalogue(x) ∨ Book(x) ∨ Bibliography(x) ∨ BackgroundMaterial(x)) ::: Philatelic literature is divided into the following categories: Stamp catalogues, Periodicals, Auction catalogues, Books, Bibliographies, and Background Material.\n¬StampCatalogue(mort) ::: Mort is not a Stamp catalogue.\n¬Periodical(mort) ∧ ¬AuctionCatalogue(mort) ∧ ¬Bibliography(mort) ∧ ¬BackgroundMaterial(mort) ::: Mort is not a periodical, auction catalogue, bibliography, or background material.\nPhilatelicLiterature(mort) ::: Mort is a piece of Philatelic literature.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nBook(mort) ::: Mort is a book.\n\"\"\""
    ]
  },
  {
    "id": 73,
    "context": [
      "Philatelic literature is divided into the following categories: Stamp catalogues, Periodicals, Auction catalogues, Books, Bibliographies, and Background Material",
      "Mort is not a Stamp catalogue.",
      "Mort is not a periodical, auction catalogue, bibliography, or background material.",
      "Mort is a piece of Philatelic literature."
    ],
    "question": "Mort is background material.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nStampCatalogue(x) ::: x is a stamp catalogue.\nPeriodical(x) ::: x is a periodical.\nAuctionCatalogue(x) ::: x is an auction catalogue.\nBook(x) ::: x is a book.\nBibliography(x) ::: x is a bibliography.\nBackgroundMaterial(x) ::: x is background material.\nPhilatelicLiterature(x) ::: x is philatelic literature.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (StampCatalogue(x) ∨ Periodical(x) ∨ AuctionCatalogue(x) ∨ Book(x) ∨ Bibliography(x) ∨ BackgroundMaterial(x) → PhilatelicLiterature(x)) ::: Philatelic literature is divided into the following categories: Stamp catalogues, Periodicals, Auction catalogues, Books, Bibliographies, and Background Material.\n¬StampCatalogue(mort) ::: Mort is not a Stamp catalogue.\n¬Periodical(mort) ∧ ¬AuctionCatalogue(mort) ∧ ¬Bibliography(mort) ∧ ¬BackgroundMaterial(mort) ::: Mort is not a periodical, auction catalogue, bibliography, or background material.\nPhilatelicLiterature(mort) ::: Mort is a piece of Philatelic literature.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nBackgroundMaterial(mort) ::: Mort is background material.\n\"\"\""
    ]
  },
  {
    "id": 74,
    "context": [
      "Philatelic literature is divided into the following categories: Stamp catalogues, Periodicals, Auction catalogues, Books, Bibliographies, and Background Material",
      "Mort is not a Stamp catalogue.",
      "Mort is not a periodical, auction catalogue, bibliography, or background material.",
      "Mort is a piece of Philatelic literature."
    ],
    "question": "Eragon is a piece of Philatelic literature.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nStampCatalogue(x) ::: x is a stamp catalogue.\nPeriodical(x) ::: x is a periodical.\nAuctionCatalogue(x) ::: x is an auction catalogue.\nBook(x) ::: x is a book.\nBibliography(x) ::: x is a bibliography.\nBackgroundMaterial(x) ::: x is background material.\nPhilatelicLiterature(x) ::: x is philatelic literature.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (StampCatalogue(x) ∨ Periodical(x) ∨ AuctionCatalogue(x) ∨ Book(x) ∨ Bibliography(x) ∨ BackgroundMaterial(x)) ::: Philatelic literature is divided into the following categories: Stamp catalogues, Periodicals, Auction catalogues, Books, Bibliographies, and Background Material.\n¬StampCatalogue(mort) ::: Mort is not a Stamp catalogue.\n¬(Periodical(mort) ∨ AuctionCatalogue(mort) ∨ Bibliography(mort) ∨ BackgroundMaterial(mort)) ::: Mort is not a periodical, auction catalogue, bibliography, or background material.\nPhilatelicLiterature(mort) ::: Mort is a piece of Philatelic literature.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nPhilatelicLiterature(eragon) ::: Eragon is a piece of Philatelic literature.\n\"\"\""
    ]
  },
  {
    "id": 280,
    "context": [
      "Adventures of Rusty is a drama film and children's film.",
      "Columbia Pictures produced Adventures of Rusty",
      "Tintin was produced by Paramount.",
      "Tintin is an adventure film."
    ],
    "question": "Columbia pictures produces drama films.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nDramaFilm(x) ::: x is a drama film.\nChildrensFilm(x) ::: x is a children's film.\nProducedBy(x, y) ::: x is produced by y.\nAdventureFilm(x) ::: x is an adventure film.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nDramaFilm(adventuresOfRusty) ∧ ChildrensFilm(adventuresOfRusty) ::: Adventures of Rusty is a drama film and children's film.\nProducedBy(adventuresOfRusty, columbiaPictures) ::: Columbia Pictures produced Adventures of Rusty.\nProducedBy(tintin, paramount) ::: Tintin was produced by Paramount.\nAdventureFilm(tintin) ::: Tintin is an adventure film.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n∃x (DramaFilm(x) ∧ ProducedBy(x, columbiaPictures)) ::: Columbia pictures produces drama films.\n\"\"\""
    ]
  },
  {
    "id": 281,
    "context": [
      "Adventures of Rusty is a drama film and children's film.",
      "Columbia Pictures produced Adventures of Rusty",
      "Tintin was produced by Paramount.",
      "Tintin is an adventure film."
    ],
    "question": "Columbia pictures produces adventure films.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nDramaFilm(x) ::: x is a drama film.\nChildrensFilm(x) ::: x is a children's film.\nProducedBy(x, y) ::: x is produced by y.\nAdventureFilm(x) ::: x is an adventure film.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nDramaFilm(adventuresOfRusty) ∧ ChildrensFilm(adventuresOfRusty) ::: Adventures of Rusty is a drama film and children's film.\nProducedBy(adventuresOfRusty, columbiaPictures) ::: Columbia Pictures produced Adventures of Rusty.\nProducedBy(tintin, paramount) ::: Tintin was produced by Paramount.\nAdventureFilm(tintin) ::: Tintin is an adventure film.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n∃x (AdventureFilm(x) ∧ ProducedBy(x, columbiaPictures)) ::: Columbia pictures produces adventure films.\n\"\"\""
    ]
  },
  {
    "id": 282,
    "context": [
      "Adventures of Rusty is a drama film and children's film.",
      "Columbia Pictures produced Adventures of Rusty",
      "Tintin was produced by Paramount.",
      "Tintin is an adventure film."
    ],
    "question": "Paramount produces children's films.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nDramaFilm(x) ::: x is a drama film.\nChildrensFilm(x) ::: x is a children's film.\nProducedBy(x, y) ::: x is produced by y.\nAdventureFilm(x) ::: x is an adventure film.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nDramaFilm(adventuresOfRusty) ∧ ChildrensFilm(adventuresOfRusty) ::: Adventures of Rusty is a drama film and children's film.\nProducedBy(adventuresOfRusty, columbiaPictures) ::: Columbia Pictures produced Adventures of Rusty.\nProducedBy(tintin, paramount) ::: Tintin was produced by Paramount.\nAdventureFilm(tintin) ::: Tintin is an adventure film.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n∃x (ChildrensFilm(x) ∧ ProducedBy(x, paramount)) ::: Paramount produces children's films.\n\"\"\""
    ]
  },
  {
    "id": 283,
    "context": [
      "Adventures of Rusty is a drama film and children's film.",
      "Columbia Pictures produced Adventures of Rusty",
      "Tintin was produced by Paramount.",
      "Tintin is an adventure film."
    ],
    "question": "Paramount produces adventure films.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nDramaFilm(x) ::: x is a drama film.\nChildrensFilm(x) ::: x is a children's film.\nProducedBy(x, y) ::: x is produced by y.\nAdventureFilm(x) ::: x is an adventure film.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nDramaFilm(adventuresOfRusty) ∧ ChildrensFilm(adventuresOfRusty) ::: Adventures of Rusty is a drama film and children's film.\nProducedBy(adventuresOfRusty, columbiaPictures) ::: Columbia Pictures produced Adventures of Rusty.\nProducedBy(tintin, paramount) ::: Tintin was produced by Paramount.\nAdventureFilm(tintin) ::: Tintin is an adventure film.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n∃x (ProducedBy(x, paramount) ∧ AdventureFilm(x)) ::: Paramount produces adventure films.\n\"\"\""
    ]
  },
  {
    "id": 665,
    "context": [
      "Deng Xiaoping served as the paramount leader of the People's Republic of China (PRC). ",
      "Deng Xiaoping was praised for his reaffirmation of the reform program in his Southern Tour of 1992 as well as the reversion of Hong Kong to Chinese control in 1997 and the return of Macau in 1999.",
      "As the party's Secretary-General under Mao and Vice Premier in he 1950s, Deng Xiaoping presided over the Anti-Rightist Campaign launched by Mao.",
      "Deng Xiaoping became instrumental in China's economic reconstruction following the disastrous Great Leap Forward (1958–1960).",
      "Mao Zedong died in 1976.",
      "After Mao Zedong's death, Deng Xiaoping gradually rose to supreme power."
    ],
    "question": "The paramount leader of the PRC was also the vice premier.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nParamountLeader(x) ::: x served as the paramount leader of the People's Republic of China (PRC).\nReformProgram(x) ::: x reaffirmed the reform program.\nReversion(x) ::: x oversaw the reversion of Hong Kong to Chinese control.\nReturn(x) ::: x oversaw the return of Macau.\nSecretaryGeneral(x) ::: x was the party's Secretary-General under Mao.\nVicePremier(x) ::: x was the Vice Premier.\nPreside(x, y) ::: x presided over y.\nLaunch(x, y) ::: x launched y.\nInstrumental(x, y) ::: x was instrumental in y.\nEconomicReconstruction(x) ::: x was instrumental in China's economic reconstruction.\nDeath(x) ::: x died.\nRiseToPower(x) ::: x gradually rose to supreme power.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nParamountLeader(dengXiaoping) ::: Deng Xiaoping served as the paramount leader of the People's Republic of China (PRC).\nReformProgram(dengXiaoping) ∧ Reversion(dengXiaoping) ∧ Return(dengXiaoping) ::: Deng Xiaoping was praised for his reaffirmation of the reform program in his Southern Tour of 1992 as well as the reversion of Hong Kong to Chinese control in 1997 and the return of Macau in 1999.\nSecretaryGeneral(dengXiaoping) ∧ VicePremier(dengXiaoping) ∧ Launch(dengXiaoping, antiRightistCampaign) ::: As the party's Secretary-General under Mao and Vice Premier in the 1950s, Deng Xiaoping presided over the Anti-Rightist Campaign launched by Mao.\nEconomicReconstruction(dengXiaoping, greatLeapForward) ::: Deng Xiaoping became instrumental in China's economic reconstruction following the disastrous Great Leap Forward (1958–1960).\nDeath(maoZedong) ::: Mao Zedong died in 1976.\nRiseToPower(dengXiaoping) ::: After Mao Zedong's death, Deng Xiaoping gradually rose to supreme power.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n∃x (ParamountLeader(x) ∧ VicePremier(x)) ::: The paramount leader of the PRC was also the vice premier.\n\"\"\""
    ]
  },
  {
    "id": 666,
    "context": [
      "Deng Xiaoping served as the paramount leader of the People's Republic of China (PRC). ",
      "Deng Xiaoping was praised for his reaffirmation of the reform program in his Southern Tour of 1992 as well as the reversion of Hong Kong to Chinese control in 1997 and the return of Macau in 1999.",
      "As the party's Secretary-General under Mao and Vice Premier in he 1950s, Deng Xiaoping presided over the Anti-Rightist Campaign launched by Mao.",
      "Deng Xiaoping became instrumental in China's economic reconstruction following the disastrous Great Leap Forward (1958–1960).",
      "Mao Zedong died in 1976.",
      "After Mao Zedong's death, Deng Xiaoping gradually rose to supreme power."
    ],
    "question": "Deng Xiaoping presided over something launched by someone he was under.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nLeader(x) ::: x is a leader.\nPraisedFor(x, y) ::: x is praised for y.\nReformProgram(x) ::: x is a reform program.\nReversion(x, y) ::: x is a reversion of y.\nControl(x, y) ::: x is in control of y.\nReturn(x, y) ::: x is a return of y.\nInstrumentalIn(x, y) ::: x is instrumental in y.\nEconomicReconstruction(x) ::: x is economic reconstruction.\nDisastrous(x) ::: x is disastrous.\nDeath(x) ::: x is dead.\nRiseToPower(x) ::: x rises to supreme power.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nLeader(dengXiaoping) ∧ Paramount(dengXiaoping, PRC) ::: Deng Xiaoping served as the paramount leader of the People's Republic of China (PRC).\nPraisedFor(dengXiaoping, reaffirmationOfReformProgram) ∧ PraisedFor(dengXiaoping, reversionOfHongKong) ∧ PraisedFor(dengXiaoping, returnOfMacau) ::: Deng Xiaoping was praised for his reaffirmation of the reform program in his Southern Tour of 1992 as well as the reversion of Hong Kong to Chinese control in 1997 and the return of Macau in 1999.\nSecretaryGeneral(dengXiaoping, mao) ∧ VicePremier(dengXiaoping, 1950s) ∧ PresidedOver(dengXiaoping, antiRightistCampaign) ::: As the party's Secretary-General under Mao and Vice Premier in the 1950s, Deng Xiaoping presided over the Anti-Rightist Campaign launched by Mao.\nInstrumentalIn(dengXiaoping, economicReconstruction) ∧ Disastrous(greatLeapForward) ∧ TimePeriod(greatLeapForward, 1958-1960) ::: Deng Xiaoping became instrumental in China's economic reconstruction following the disastrous Great Leap Forward (1958–1960).\nDeath(mao) ∧ TimePeriod(mao, 1976) ::: Mao Zedong died in 1976.\nAfter(mao, dengXiaoping) ∧ GraduallyRiseToPower(dengXiaoping) ::: After Mao Zedong's death, Deng Xiaoping gradually rose to supreme power.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n∃x ∃y (PresidedOver(dengXiaoping, x) ∧ LaunchedBy(y, x) ∧ Under(dengXiaoping, y)) ::: Deng Xiaoping presided over something launched by someone he was under.\n\"\"\""
    ]
  },
  {
    "id": 667,
    "context": [
      "Deng Xiaoping served as the paramount leader of the People's Republic of China (PRC). ",
      "Deng Xiaoping was praised for his reaffirmation of the reform program in his Southern Tour of 1992 as well as the reversion of Hong Kong to Chinese control in 1997 and the return of Macau in 1999.",
      "As the party's Secretary-General under Mao and Vice Premier in he 1950s, Deng Xiaoping presided over the Anti-Rightist Campaign launched by Mao.",
      "Deng Xiaoping became instrumental in China's economic reconstruction following the disastrous Great Leap Forward (1958–1960).",
      "Mao Zedong died in 1976.",
      "After Mao Zedong's death, Deng Xiaoping gradually rose to supreme power."
    ],
    "question": "The person instrumental in china's economic reconstruction gradually rose to supreme power.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nLeader(x) ::: x is a leader.\nPraisedFor(x, y) ::: x is praised for y.\nReformProgram(x) ::: x is a reform program.\nReversion(x) ::: x is a reversion.\nControl(x) ::: x is a control.\nReturn(x) ::: x is a return.\nPresideOver(x, y) ::: x presides over y.\nCampaign(x) ::: x is a campaign.\nLaunch(x, y) ::: x is launched by y.\nInstrumentalIn(x, y) ::: x is instrumental in y.\nEconomicReconstruction(x) ::: x is an economic reconstruction.\nDisastrous(x) ::: x is disastrous.\nDeath(x) ::: x is a death.\nRiseToPower(x, y) ::: x rises to y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nLeader(dengXiaoping) ∧ Paramount(dengXiaoping) ∧ Leader(prc) ::: Deng Xiaoping served as the paramount leader of the People's Republic of China (PRC).\nPraisedFor(dengXiaoping, reformProgram) ∧ PraisedFor(dengXiaoping, reversion) ∧ PraisedFor(dengXiaoping, control) ∧ PraisedFor(dengXiaoping, return) ∧ PraisedFor(dengXiaoping, return) ∧ PraisedFor(dengXiaoping, return) ::: Deng Xiaoping was praised for his reaffirmation of the reform program in his Southern Tour of 1992 as well as the reversion of Hong Kong to Chinese control in 1997 and the return of Macau in 1999.\nSecretaryGeneral(dengXiaoping, mao) ∧ VicePremier(dengXiaoping, 1950s) ∧ PresideOver(dengXiaoping, antiRightistCampaign) ∧ Launch(antiRightistCampaign, mao) ::: As the party's Secretary-General under Mao and Vice Premier in he 1950s, Deng Xiaoping presided over the Anti-Rightist Campaign launched by Mao.\nInstrumentalIn(dengXiaoping, economicReconstruction) ∧ Disastrous(greatLeapForward) ∧ EconomicReconstruction(china) ::: Deng Xiaoping became instrumental in China's economic reconstruction following the disastrous Great Leap Forward (1958–1960).\nDeath(mao) ∧ Year(mao, 1976) ::: Mao Zedong died in 1976.\nRiseToPower(dengXiaoping, supremePower) ∧ Gradual(dengXiaoping) ::: After Mao Zedong's death, Deng Xiaoping gradually rose to supreme power.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nInstrumentalIn(x, china) ∧ RiseToPower(x, supremePower) ::: The person instrumental in China's economic reconstruction gradually rose to supreme power.\n\"\"\""
    ]
  },
  {
    "id": 1052,
    "context": [
      "All imaginative processes are produced in human brains.",
      "All science-fiction is from an imaginative process.",
      "Either science-fiction or fact. ",
      "No facts are proven to be false.",
      "Dune is a science-fiction or proven to be false."
    ],
    "question": "Dune is a fact.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nImaginativeProcess(x) ::: x is an imaginative process.\nBrain(x) ::: x is a human brain.\nScienceFiction(x) ::: x is science-fiction.\nFact(x) ::: x is a fact.\nProvenFalse(x) ::: x is proven to be false.\nDune(x) ::: x is Dune.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (ImaginativeProcess(x) → Brain(x)) ::: All imaginative processes are produced in human brains.\n∀x (ScienceFiction(x) → ImaginativeProcess(x)) ::: All science-fiction is from an imaginative process.\nScienceFiction(x) ⊕ Fact(x) ::: Either science-fiction or fact.\n∀x (Fact(x) → ¬ProvenFalse(x)) ::: No facts are proven to be false.\nScienceFiction(dune) ∨ ProvenFalse(dune) ::: Dune is a science-fiction or proven to be false.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬ScienceFiction(dune) ::: Dune is a fact.\n\"\"\""
    ]
  },
  {
    "id": 1053,
    "context": [
      "All imaginative processes are produced in human brains.",
      "All science-fiction is from an imaginative process.",
      "Either science-fiction or fact. ",
      "No facts are proven to be false.",
      "Dune is a science-fiction or proven to be false."
    ],
    "question": "Dune is produced in human brains and is an imaginative process.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nImaginativeProcess(x) ::: x is an imaginative process.\nProducedIn(x, y) ::: x is produced in y.\nScienceFiction(x) ::: x is science fiction.\nFact(x) ::: x is a fact.\nProvenFalse(x) ::: x is proven to be false.\nDune(x) ::: x is Dune.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (ImaginativeProcess(x) → ProducedIn(x, humanBrains)) ::: All imaginative processes are produced in human brains.\n∀x (ScienceFiction(x) → ImaginativeProcess(x)) ::: All science-fiction is from an imaginative process.\nScienceFiction(x) ⊕ Fact(x) ::: Either science-fiction or fact.\n∀x (Fact(x) → ¬ProvenFalse(x)) ::: No facts are proven to be false.\nScienceFiction(dune) ∨ ProvenFalse(dune) ::: Dune is a science-fiction or proven to be false.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nProducedIn(dune, humanBrains) ∧ ImaginativeProcess(dune) ::: Dune is produced in human brains and is an imaginative process.\n\"\"\""
    ]
  },
  {
    "id": 1054,
    "context": [
      "All imaginative processes are produced in human brains.",
      "All science-fiction is from an imaginative process.",
      "Either science-fiction or fact. ",
      "No facts are proven to be false.",
      "Dune is a science-fiction or proven to be false."
    ],
    "question": "Dune is either produced in human brains or an imaginative process.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nImaginativeProcess(x) ::: x is an imaginative process.\nProducedIn(x, y) ::: x is produced in y.\nScienceFiction(x) ::: x is science-fiction.\nFact(x) ::: x is a fact.\nProvenFalse(x) ::: x is proven to be false.\nDune(x) ::: x is Dune.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (ImaginativeProcess(x) → ProducedIn(x, humanBrains)) ::: All imaginative processes are produced in human brains.\n∀x (ScienceFiction(x) → ImaginativeProcess(x)) ::: All science-fiction is from an imaginative process.\nScienceFiction(x) ∨ Fact(x) ::: Either science-fiction or fact.\n∀x (Fact(x) → ¬ProvenFalse(x)) ::: No facts are proven to be false.\nScienceFiction(dune) ∨ ProvenFalse(dune) ::: Dune is a science-fiction or proven to be false.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nProducedIn(dune, humanBrains) ∨ ImaginativeProcess(dune) ::: Dune is either produced in human brains or an imaginative process.\n\"\"\""
    ]
  },
  {
    "id": 1055,
    "context": [
      "All imaginative processes are produced in human brains.",
      "All science-fiction is from an imaginative process.",
      "Either science-fiction or fact. ",
      "No facts are proven to be false.",
      "Dune is a science-fiction or proven to be false."
    ],
    "question": "Dune is produced in human brains and is science fiction.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nImaginativeProcess(x) ::: x is an imaginative process.\nBrain(x) ::: x is a human brain.\nScienceFiction(x) ::: x is science fiction.\nFact(x) ::: x is a fact.\nProvenFalse(x) ::: x is proven to be false.\nDune(x) ::: x is Dune.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (ImaginativeProcess(x) → Brain(x)) ::: All imaginative processes are produced in human brains.\n∀x (ScienceFiction(x) → ImaginativeProcess(x)) ::: All science-fiction is from an imaginative process.\nScienceFiction(x) ∨ Fact(x) ::: Either science-fiction or fact.\n∀x (Fact(x) → ¬ProvenFalse(x)) ::: No facts are proven to be false.\nScienceFiction(dune) ∨ ProvenFalse(dune) ::: Dune is a science-fiction or proven to be false.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nBrain(dune) ∧ ScienceFiction(dune) ::: Dune is produced in human brains and is science fiction.\n\"\"\""
    ]
  },
  {
    "id": 1056,
    "context": [
      "All imaginative processes are produced in human brains.",
      "All science-fiction is from an imaginative process.",
      "Either science-fiction or fact. ",
      "No facts are proven to be false.",
      "Dune is a science-fiction or proven to be false."
    ],
    "question": "Dune is either produced in human brains or science-fiction.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nImaginative(x) ::: x is an imaginative process.\nBrain(x) ::: x is a human brain.\nScienceFiction(x) ::: x is science-fiction.\nFact(x) ::: x is a fact.\nProvenFalse(x) ::: x is proven to be false.\nDune(x) ::: x is Dune.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Imaginative(x) → Brain(x)) ::: All imaginative processes are produced in human brains.\n∀x (ScienceFiction(x) → Imaginative(x)) ::: All science-fiction is from an imaginative process.\nScienceFiction(x) ∨ Fact(x) ::: Either science-fiction or fact.\n∀x (Fact(x) → ¬ProvenFalse(x)) ::: No facts are proven to be false.\nScienceFiction(dune) ∨ ProvenFalse(dune) ::: Dune is a science-fiction or proven to be false.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nBrain(dune) ∨ ScienceFiction(dune) ::: Dune is either produced in human brains or science-fiction.\n\"\"\""
    ]
  },
  {
    "id": 1057,
    "context": [
      "All imaginative processes are produced in human brains.",
      "All science-fiction is from an imaginative process.",
      "Either science-fiction or fact. ",
      "No facts are proven to be false.",
      "Dune is a science-fiction or proven to be false."
    ],
    "question": "If Dune is produced in human brains and is an imaginative process, then Dune is not produced in human brains and science-fiction.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nImaginativeProcess(x) ::: x is an imaginative process.\nProducedIn(x, y) ::: x is produced in y.\nHumanBrain(x) ::: x is a human brain.\nScienceFiction(x) ::: x is science-fiction.\nFact(x) ::: x is a fact.\nProvenFalse(x) ::: x is proven to be false.\nDune(x) ::: x is Dune.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (ImaginativeProcess(x) → ProducedIn(x, HumanBrain)) ::: All imaginative processes are produced in human brains.\n∀x (ScienceFiction(x) → ImaginativeProcess(x)) ::: All science-fiction is from an imaginative process.\nScienceFiction(x) ⊕ Fact(x) ::: Either science-fiction or fact.\n∀x (Fact(x) → ¬ProvenFalse(x)) ::: No facts are proven to be false.\nScienceFiction(dune) ∨ ProvenFalse(dune) ::: Dune is a science-fiction or proven to be false.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n(ProducedIn(dune, HumanBrain) ∧ ImaginativeProcess(dune)) → ¬(ProducedIn(dune, HumanBrain) ∧ ScienceFiction(dune)) ::: If Dune is produced in human brains and is an imaginative process, then Dune is not produced in human brains and science-fiction.\n\"\"\""
    ]
  },
  {
    "id": 1058,
    "context": [
      "All imaginative processes are produced in human brains.",
      "All science-fiction is from an imaginative process.",
      "Either science-fiction or fact. ",
      "No facts are proven to be false.",
      "Dune is a science-fiction or proven to be false."
    ],
    "question": "If Dune is either a fact and produced in human brains, or neither a fact nor produced in human brains, then Dune is produced in human brains and science-fiction.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nImaginativeProcess(x) ::: x is an imaginative process.\nBrain(x) ::: x is a human brain.\nScienceFiction(x) ::: x is science-fiction.\nFact(x) ::: x is a fact.\nProvenFalse(x) ::: x is proven to be false.\nDune(x) ::: x is Dune.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (ImaginativeProcess(x) → Brain(x)) ::: All imaginative processes are produced in human brains.\n∀x (ScienceFiction(x) → ImaginativeProcess(x)) ::: All science-fiction is from an imaginative process.\nScienceFiction(dune) ⊕ Fact(dune) ::: Either science-fiction or fact.\n∀x (Fact(x) → ¬ProvenFalse(x)) ::: No facts are proven to be false.\nScienceFiction(dune) ∨ ProvenFalse(dune) ::: Dune is a science-fiction or proven to be false.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬((Fact(dune) ∧ Brain(dune)) → (Fact(dune) ∧ Brain(dune)) ⊕ ¬(Fact(dune) ∨ Brain(dune))) ::: If Dune is either a fact and produced in human brains, or neither a fact nor produced in human brains, then Dune is produced in human brains and science-fiction.\n\"\"\""
    ]
  },
  {
    "id": 1059,
    "context": [
      "All imaginative processes are produced in human brains.",
      "All science-fiction is from an imaginative process.",
      "Either science-fiction or fact. ",
      "No facts are proven to be false.",
      "Dune is a science-fiction or proven to be false."
    ],
    "question": "If Dune is science-fiction, then Dune is not produced in human brains and science-fiction.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nImaginativeProcess(x) ::: x is an imaginative process.\nProducedIn(x, y) ::: x is produced in y.\nScienceFiction(x) ::: x is science-fiction.\nFact(x) ::: x is a fact.\nProvenFalse(x) ::: x is proven to be false.\nDune(x) ::: x is Dune.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (ImaginativeProcess(x) → ProducedIn(x, humanBrains)) ::: All imaginative processes are produced in human brains.\n∀x (ScienceFiction(x) → ImaginativeProcess(x)) ::: All science-fiction is from an imaginative process.\nScienceFiction(dune) ⊕ Fact(dune) ::: Either science-fiction or fact.\n∀x (Fact(x) → ¬ProvenFalse(x)) ::: No facts are proven to be false.\nScienceFiction(dune) ∨ ProvenFalse(dune) ::: Dune is a science-fiction or proven to be false.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nScienceFiction(dune) → (¬ProducedIn(dune, humanBrains) ∧ ¬ScienceFiction(dune)) ::: If Dune is science-fiction, then Dune is not produced in human brains and science-fiction.\n\"\"\""
    ]
  },
  {
    "id": 1060,
    "context": [
      "All imaginative processes are produced in human brains.",
      "All science-fiction is from an imaginative process.",
      "Either science-fiction or fact. ",
      "No facts are proven to be false.",
      "Dune is a science-fiction or proven to be false."
    ],
    "question": "If Dune is not produced in human brains and science-fiction, then Dune is neither an imaginative process nor proved to be false.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nImaginativeProcess(x) ::: x is an imaginative process.\nProducedIn(x, y) ::: x is produced in y.\nScienceFiction(x) ::: x is science-fiction.\nFact(x) ::: x is a fact.\nProvenFalse(x) ::: x is proven to be false.\nDune(x) ::: x is Dune.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (ImaginativeProcess(x) → ProducedIn(x, humanBrains)) ::: All imaginative processes are produced in human brains.\n∀x (ScienceFiction(x) → ImaginativeProcess(x)) ::: All science-fiction is from an imaginative process.\nScienceFiction(dune) ⊕ Fact(dune) ::: Either science-fiction or fact.\n∀x (Fact(x) → ¬ProvenFalse(x)) ::: No facts are proven to be false.\nScienceFiction(dune) ∨ ProvenFalse(dune) ::: Dune is a science-fiction or proven to be false.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬(ProducedIn(dune, humanBrains) ∧ ScienceFiction(dune)) → ¬(ImaginativeProcess(dune) ∨ ProvenFalse(dune)) ::: If Dune is not produced in human brains and science-fiction, then Dune is neither an imaginative process nor proved to be false.\n\"\"\""
    ]
  },
  {
    "id": 1061,
    "context": [
      "All imaginative processes are produced in human brains.",
      "All science-fiction is from an imaginative process.",
      "Either science-fiction or fact. ",
      "No facts are proven to be false.",
      "Dune is a science-fiction or proven to be false."
    ],
    "question": "If Dune is not an imaginative process and science-fiction, then Dune is neither produced in human brains nor an imaginative process.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nImaginativeProcess(x) ::: x is an imaginative process.\nBrain(x) ::: x is a human brain.\nScienceFiction(x) ::: x is science-fiction.\nFact(x) ::: x is a fact.\nProvenFalse(x) ::: x is proven to be false.\nDune(x) ::: x is Dune.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (ImaginativeProcess(x) → Brain(x)) ::: All imaginative processes are produced in human brains.\n∀x (ScienceFiction(x) → ImaginativeProcess(x)) ::: All science-fiction is from an imaginative process.\nScienceFiction(x) ⊕ Fact(x) ::: Either science-fiction or fact.\n∀x (Fact(x) → ¬ProvenFalse(x)) ::: No facts are proven to be false.\nScienceFiction(dune) ∨ ProvenFalse(dune) ::: Dune is a science-fiction or proven to be false.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬(ImaginativeProcess(dune) ∧ ScienceFiction(dune)) → ¬(ImaginativeProcess(dune) ∨ Brain(dune)) ::: If Dune is not an imaginative process and science-fiction, then Dune is neither produced in human brains nor an imaginative process.\n\"\"\""
    ]
  },
  {
    "id": 524,
    "context": [
      "An American superhero comes from either DC universe or Marvel universe.",
      "Captain America is a superhero.",
      "Captain America is an American.",
      "Captain America does not come from DC universe.",
      "If a superhero is American, he speaks English.",
      "A superhero speaks English or Spanish."
    ],
    "question": "Captain America does not speak English.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nSuperhero(x) ::: x is a superhero.\nAmerican(x) ::: x is American.\nComesFromDC(x) ::: x comes from DC universe.\nComesFromMarvel(x) ::: x comes from Marvel universe.\nSpeaksEnglish(x) ::: x speaks English.\nSpeaksSpanish(x) ::: x speaks Spanish.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Superhero(x) → (ComesFromDC(x) ∨ ComesFromMarvel(x))) ::: An American superhero comes from either DC universe or Marvel universe.\nSuperhero(captainAmerica) ::: Captain America is a superhero.\nAmerican(captainAmerica) ::: Captain America is an American.\n¬ComesFromDC(captainAmerica) ::: Captain America does not come from DC universe.\n∀x (American(x) → SpeaksEnglish(x)) ::: If a superhero is American, he speaks English.\n∀x (Superhero(x) → (SpeaksEnglish(x) ∨ SpeaksSpanish(x))) ::: A superhero speaks English or Spanish.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬SpeaksEnglish(captainAmerica) ::: Captain America does not speak English.\n\"\"\""
    ]
  },
  {
    "id": 525,
    "context": [
      "An American superhero comes from either DC universe or Marvel universe.",
      "Captain America is a superhero.",
      "Captain America is an American.",
      "Captain America does not come from DC universe.",
      "If a superhero is American, he speaks English.",
      "A superhero speaks English or Spanish."
    ],
    "question": "Captain America comes from Marvel universe.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nSuperhero(x) ::: x is a superhero.\nAmerican(x) ::: x is American.\nDCUniverse(x) ::: x comes from DC universe.\nMarvelUniverse(x) ::: x comes from Marvel universe.\nSpeaks(x, y) ::: x speaks language y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Superhero(x) → (DCUniverse(x) ∨ MarvelUniverse(x))) ::: An American superhero comes from either DC universe or Marvel universe.\nSuperhero(captainAmerica) ::: Captain America is a superhero.\nAmerican(captainAmerica) ::: Captain America is an American.\n¬DCUniverse(captainAmerica) ::: Captain America does not come from DC universe.\n∀x (American(x) → Speaks(x, English)) ::: If a superhero is American, he speaks English.\n∀x (Superhero(x) → (Speaks(x, English) ∨ Speaks(x, Spanish))) ::: A superhero speaks English or Spanish.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nMarvelUniverse(captainAmerica) ::: Captain America comes from Marvel universe.\n\"\"\""
    ]
  },
  {
    "id": 526,
    "context": [
      "An American superhero comes from either DC universe or Marvel universe.",
      "Captain America is a superhero.",
      "Captain America is an American.",
      "Captain America does not come from DC universe.",
      "If a superhero is American, he speaks English.",
      "A superhero speaks English or Spanish."
    ],
    "question": "Captain America speaks Spanish.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nSuperhero(x) ::: x is a superhero.\nAmerican(x) ::: x is American.\nComesFromDC(x) ::: x comes from DC universe.\nComesFromMarvel(x) ::: x comes from Marvel universe.\nSpeaks(x, y) ::: x speaks language y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Superhero(x) → (ComesFromDC(x) ∨ ComesFromMarvel(x))) ::: An American superhero comes from either DC universe or Marvel universe.\nSuperhero(captainAmerica) ::: Captain America is a superhero.\nAmerican(captainAmerica) ::: Captain America is an American.\n¬ComesFromDC(captainAmerica) ::: Captain America does not come from DC universe.\n∀x (American(x) → Speaks(x, english)) ::: If a superhero is American, he speaks English.\n∀x (Superhero(x) → (Speaks(x, english) ∨ Speaks(x, spanish))) ::: A superhero speaks English or Spanish.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nSpeaks(captainAmerica, spanish) ::: Captain America speaks Spanish.\n\"\"\""
    ]
  },
  {
    "id": 229,
    "context": [
      "Robert Zimmer was born in Germany.",
      "Robert Zimmer is an essayist.",
      "Robert Zimmer was born in 1953.",
      "Every essayist is a writer.",
      "Every person born in Germany is German."
    ],
    "question": "Robert Zimmer is German.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nBornIn(x, y) ::: x was born in y.\nEssayist(x) ::: x is an essayist.\nWriter(x) ::: x is a writer.\nGerman(x) ::: x is German.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nBornIn(robert, germany) ::: Robert Zimmer was born in Germany.\nEssayist(robert) ::: Robert Zimmer is an essayist.\nBornIn(robert, year1953) ::: Robert Zimmer was born in 1953.\n∀x (Essayist(x) → Writer(x)) ::: Every essayist is a writer.\n∀x (BornIn(x, germany) → German(x)) ::: Every person born in Germany is German.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nGerman(robert) ::: Robert Zimmer is German.\n\"\"\""
    ]
  },
  {
    "id": 230,
    "context": [
      "Robert Zimmer was born in Germany.",
      "Robert Zimmer is an essayist.",
      "Robert Zimmer was born in 1953.",
      "Every essayist is a writer.",
      "Every person born in Germany is German."
    ],
    "question": "Robert Zimmer is not a writer.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nBornIn(x, y) ::: x was born in y.\nEssayist(x) ::: x is an essayist.\nWriter(x) ::: x is a writer.\nGerman(x) ::: x is German.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nBornIn(robert, germany) ::: Robert Zimmer was born in Germany.\nEssayist(robert) ::: Robert Zimmer is an essayist.\nBornIn(robert, year1953) ::: Robert Zimmer was born in 1953.\n∀x (Essayist(x) → Writer(x)) ::: Every essayist is a writer.\n∀x (BornIn(x, germany) → German(x)) ::: Every person born in Germany is German.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬Writer(robert) ::: Robert Zimmer is not a writer.\n\"\"\""
    ]
  },
  {
    "id": 231,
    "context": [
      "Robert Zimmer was born in Germany.",
      "Robert Zimmer is an essayist.",
      "Robert Zimmer was born in 1953.",
      "Every essayist is a writer.",
      "Every person born in Germany is German."
    ],
    "question": "Robert Zimmer is a biographer.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nBornIn(x, y) ::: x was born in y.\nEssayist(x) ::: x is an essayist.\nWriter(x) ::: x is a writer.\nGerman(x) ::: x is German.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nBornIn(robert, germany) ::: Robert Zimmer was born in Germany.\nEssayist(robert) ::: Robert Zimmer is an essayist.\nBornIn(robert, year1953) ::: Robert Zimmer was born in 1953.\n∀x (Essayist(x) → Writer(x)) ::: Every essayist is a writer.\n∀x (BornIn(x, germany) → German(x)) ::: Every person born in Germany is German.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬Biographer(robert) ::: Robert Zimmer is not a biographer.\n\"\"\""
    ]
  },
  {
    "id": 699,
    "context": [
      "All people who repay their loans on time have a high credit score.",
      "Some people with high credit scores and high salaries are approved for mortgages.",
      "John has a high salary."
    ],
    "question": "If John repays his loans on time, he will be approved for a mortgage.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nRepay(x) ::: x repays their loans on time.\nHighCreditScore(x) ::: x has a high credit score.\nApproved(x) ::: x is approved for a mortgage.\nHighSalary(x) ::: x has a high salary.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Repay(x) → HighCreditScore(x)) ::: All people who repay their loans on time have a high credit score.\n∃x (HighCreditScore(x) ∧ HighSalary(x) ∧ Approved(x)) ::: Some people with high credit scores and high salaries are approved for mortgages.\nHighSalary(john) ::: John has a high salary.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nRepay(john) → Approved(john) ::: If John repays his loans on time, he will be approved for a mortgage.\n\"\"\""
    ]
  },
  {
    "id": 912,
    "context": [
      "All students are members of the university.",
      "All graduate students are students.",
      "All PhD students are graduate students.",
      "Some PhD students have high IQs.",
      "If John is not a PhD student, then he is not a member of the university.",
      "If John has a high IQ, then he is a PhD student or a graduate student."
    ],
    "question": "John has a high IQ.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nStudent(x) ::: x is a student.\nMember(x) ::: x is a member of the university.\nGraduateStudent(x) ::: x is a graduate student.\nPhDStudent(x) ::: x is a PhD student.\nHighIQ(x) ::: x has a high IQ.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Student(x) → Member(x)) ::: All students are members of the university.\n∀x (GraduateStudent(x) → Student(x)) ::: All graduate students are students.\n∀x (PhDStudent(x) → GraduateStudent(x)) ::: All PhD students are graduate students.\n∃x (PhDStudent(x) ∧ HighIQ(x)) ::: Some PhD students have high IQs.\n¬PhDStudent(john) → ¬Member(john) ::: If John is not a PhD student, then he is not a member of the university.\nHighIQ(john) → (PhDStudent(john) ∨ GraduateStudent(john)) ::: If John has a high IQ, then he is a PhD student or a graduate student.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nHighIQ(john) ::: John has a high IQ.\n\"\"\""
    ]
  },
  {
    "id": 913,
    "context": [
      "All students are members of the university.",
      "All graduate students are students.",
      "All PhD students are graduate students.",
      "Some PhD students have high IQs.",
      "If John is not a PhD student, then he is not a member of the university.",
      "If John has a high IQ, then he is a PhD student or a graduate student."
    ],
    "question": "John does not have a high IQ.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nStudent(x) ::: x is a student.\nMember(x) ::: x is a member of the university.\nGraduateStudent(x) ::: x is a graduate student.\nPhDStudent(x) ::: x is a PhD student.\nHighIQ(x) ::: x has a high IQ.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Student(x) → Member(x)) ::: All students are members of the university.\n∀x (GraduateStudent(x) → Student(x)) ::: All graduate students are students.\n∀x (PhDStudent(x) → GraduateStudent(x)) ::: All PhD students are graduate students.\n∃x (PhDStudent(x) ∧ HighIQ(x)) ::: Some PhD students have high IQs.\n¬PhDStudent(john) → ¬Member(john) ::: If John is not a PhD student, then he is not a member of the university.\nHighIQ(john) → (PhDStudent(john) ∨ GraduateStudent(john)) ::: If John has a high IQ, then he is a PhD student or a graduate student.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬HighIQ(john) ::: John does not have a high IQ.\n\"\"\""
    ]
  },
  {
    "id": 914,
    "context": [
      "All students are members of the university.",
      "All graduate students are students.",
      "All PhD students are graduate students.",
      "Some PhD students have high IQs.",
      "If John is not a PhD student, then he is not a member of the university.",
      "If John has a high IQ, then he is a PhD student or a graduate student."
    ],
    "question": "John is a PhD student.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nStudent(x) ::: x is a student.\nMember(x) ::: x is a member of the university.\nGraduateStudent(x) ::: x is a graduate student.\nPhDStudent(x) ::: x is a PhD student.\nHighIQ(x) ::: x has a high IQ.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Student(x) → Member(x)) ::: All students are members of the university.\n∀x (GraduateStudent(x) → Student(x)) ::: All graduate students are students.\n∀x (PhDStudent(x) → GraduateStudent(x)) ::: All PhD students are graduate students.\n∃x (PhDStudent(x) ∧ HighIQ(x)) ::: Some PhD students have high IQs.\n¬PhDStudent(john) → ¬Member(john) ::: If John is not a PhD student, then he is not a member of the university.\nHighIQ(john) → (PhDStudent(john) ∨ GraduateStudent(john)) ::: If John has a high IQ, then he is a PhD student or a graduate student.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nPhDStudent(john) ::: John is a PhD student.\n\"\"\""
    ]
  },
  {
    "id": 476,
    "context": [
      "Belgium, France and Germany are European countries.",
      "Paris is the capital of France.",
      "The Eiffel Tower is one of the main tourist attractions located in Paris.",
      "Some people who live in Belgium speak French.",
      "If John goes to Europe, he will see some tourist attractions.",
      "John speaks French."
    ],
    "question": "If John goes to Europe, he will see the Eiffel Tower.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nEuropean(x) ::: x is a European country.\nCapital(x, y) ::: y is the capital of x.\nTouristAttraction(x) ::: x is a tourist attraction.\nLocatedIn(x, y) ::: x is located in y.\nSpeak(x, y) ::: x speaks language y.\nGoTo(x, y) ::: x goes to location y.\nSee(x, y) ::: x sees y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nEuropean(belgium) ∧ European(france) ∧ European(germany) ::: Belgium, France and Germany are European countries.\nCapital(france, paris) ::: Paris is the capital of France.\nTouristAttraction(eiffelTower) ∧ LocatedIn(eiffelTower, paris) ::: The Eiffel Tower is one of the main tourist attractions located in Paris.\n∃x (Speak(x, french) ∧ LiveIn(x, belgium)) ::: Some people who live in Belgium speak French.\nGoTo(john, europe) → ∃x (TouristAttraction(x) ∧ See(john, x)) ::: If John goes to Europe, he will see some tourist attractions.\nSpeak(john, french) ::: John speaks French.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nGoTo(john, europe) → See(john, eiffelTower) ::: If John goes to Europe, he will see the Eiffel Tower.\n\"\"\""
    ]
  },
  {
    "id": 477,
    "context": [
      "Belgium, France and Germany are European countries.",
      "Paris is the capital of France.",
      "The Eiffel Tower is one of the main tourist attractions located in Paris.",
      "Some people who live in Belgium speak French.",
      "If John goes to Europe, he will see some tourist attractions.",
      "John speaks French."
    ],
    "question": "The Eiffel Tower is located in the capital of France.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nEuropean(x) ::: x is a European country.\nCapital(x, y) ::: y is the capital of x.\nTouristAttraction(x) ::: x is a tourist attraction.\nLocatedIn(x, y) ::: x is located in y.\nSpeak(x, y) ::: x speaks language y.\nGoTo(x, y) ::: x goes to location y.\nSee(x, y) ::: x sees y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nEuropean(belgium) ∧ European(france) ∧ European(germany) ::: Belgium, France and Germany are European countries.\nCapital(france, paris) ::: Paris is the capital of France.\nTouristAttraction(eiffelTower) ∧ LocatedIn(eiffelTower, paris) ::: The Eiffel Tower is one of the main tourist attractions located in Paris.\n∃x (Speak(x, french) ∧ LiveIn(x, belgium)) ::: Some people who live in Belgium speak French.\n∀x (GoTo(john, europe) → ∃y (TouristAttraction(y) ∧ See(john, y))) ::: If John goes to Europe, he will see some tourist attractions.\nSpeak(john, french) ::: John speaks French.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nLocatedIn(eiffelTower, paris) ::: The Eiffel Tower is located in the capital of France.\n\"\"\""
    ]
  },
  {
    "id": 478,
    "context": [
      "Belgium, France and Germany are European countries.",
      "Paris is the capital of France.",
      "The Eiffel Tower is one of the main tourist attractions located in Paris.",
      "Some people who live in Belgium speak French.",
      "If John goes to Europe, he will see some tourist attractions.",
      "John speaks French."
    ],
    "question": "John lives in Belgium.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nEuropean(x) ::: x is a European country.\nCapital(x, y) ::: y is the capital of x.\nTouristAttraction(x) ::: x is a tourist attraction.\nLocatedIn(x, y) ::: x is located in y.\nSpeak(x, y) ::: x speaks language y.\nLiveIn(x, y) ::: x lives in y.\nGoTo(x, y) ::: x goes to y.\nSee(x, y) ::: x sees y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nEuropean(belgium) ∧ European(france) ∧ European(germany) ::: Belgium, France and Germany are European countries.\nCapital(france, paris) ::: Paris is the capital of France.\nTouristAttraction(eiffelTower) ∧ LocatedIn(eiffelTower, paris) ::: The Eiffel Tower is one of the main tourist attractions located in Paris.\n∃x (LiveIn(x, belgium) ∧ Speak(x, french)) ::: Some people who live in Belgium speak French.\n∀x (GoTo(john, europe) → ∃y (TouristAttraction(y) ∧ See(john, y))) ::: If John goes to Europe, he will see some tourist attractions.\nSpeak(john, french) ::: John speaks French.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n∃x (LiveIn(john, belgium)) ::: John lives in Belgium.\n\"\"\""
    ]
  },
  {
    "id": 905,
    "context": [
      "All sports cars are loud.",
      "No loud cars are electric.",
      "If a car is a Ferrari, then it is a sports car.",
      "All cars made in Maranello are Ferrari",
      "If Prius is neither a sports car nor a loud car, then Prius is a Maranello-made car or a loud car."
    ],
    "question": "Prius is an electric car.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nSportsCar(x) ::: x is a sports car.\nLoud(x) ::: x is loud.\nElectric(x) ::: x is electric.\nFerrari(x) ::: x is a Ferrari.\nMadeInMaranello(x) ::: x is made in Maranello.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (SportsCar(x) → Loud(x)) ::: All sports cars are loud.\n∀x (Loud(x) → ¬Electric(x)) ::: No loud cars are electric.\nFerrari(x) → SportsCar(x) ::: If a car is a Ferrari, then it is a sports car.\n∀x (MadeInMaranello(x) → Ferrari(x)) ::: All cars made in Maranello are Ferrari.\n¬(SportsCar(prius) ∨ Loud(prius)) → (MadeInMaranello(prius) ∨ Loud(prius)) ::: If Prius is neither a sports car nor a loud car, then Prius is a Maranello-made car or a loud car.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nElectric(prius) ::: Prius is an electric car.\n\"\"\""
    ]
  },
  {
    "id": 906,
    "context": [
      "All sports cars are loud.",
      "No loud cars are electric.",
      "If a car is a Ferrari, then it is a sports car.",
      "All cars made in Maranello are Ferrari",
      "If Prius is neither a sports car nor a loud car, then Prius is a Maranello-made car or a loud car."
    ],
    "question": "Prius is not an electric car.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nSportsCar(x) ::: x is a sports car.\nLoud(x) ::: x is loud.\nElectric(x) ::: x is electric.\nFerrari(x) ::: x is a Ferrari.\nMadeInMaranello(x) ::: x is made in Maranello.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (SportsCar(x) → Loud(x)) ::: All sports cars are loud.\n∀x (Loud(x) → ¬Electric(x)) ::: No loud cars are electric.\nFerrari(x) → SportsCar(x) ::: If a car is a Ferrari, then it is a sports car.\n∀x (MadeInMaranello(x) → Ferrari(x)) ::: All cars made in Maranello are Ferrari.\n¬(SportsCar(prius) ∨ Loud(prius)) → (MadeInMaranello(prius) ∨ Loud(prius)) ::: If Prius is neither a sports car nor a loud car, then Prius is a Maranello-made car or a loud car.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬Electric(prius) ::: Prius is not an electric car.\n\"\"\""
    ]
  },
  {
    "id": 907,
    "context": [
      "All sports cars are loud.",
      "No loud cars are electric.",
      "If a car is a Ferrari, then it is a sports car.",
      "All cars made in Maranello are Ferrari",
      "If Prius is neither a sports car nor a loud car, then Prius is a Maranello-made car or a loud car."
    ],
    "question": "Prius is a Maranello-made car.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nSportsCar(x) ::: x is a sports car.\nLoud(x) ::: x is loud.\nElectric(x) ::: x is electric.\nFerrari(x) ::: x is a Ferrari.\nMadeInMaranello(x) ::: x is made in Maranello.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (SportsCar(x) → Loud(x)) ::: All sports cars are loud.\n∀x (Loud(x) → ¬Electric(x)) ::: No loud cars are electric.\nFerrari(x) → SportsCar(x) ::: If a car is a Ferrari, then it is a sports car.\n∀x (MadeInMaranello(x) → Ferrari(x)) ::: All cars made in Maranello are Ferrari.\n¬(SportsCar(prius) ∨ Loud(prius)) → (MadeInMaranello(prius) ∨ Loud(prius)) ::: If Prius is neither a sports car nor a loud car, then Prius is a Maranello-made car or a loud car.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nMadeInMaranello(prius) ::: Prius is a Maranello-made car.\n\"\"\""
    ]
  },
  {
    "id": 908,
    "context": [
      "All sports cars are loud.",
      "No loud cars are electric.",
      "If a car is a Ferrari, then it is a sports car.",
      "All cars made in Maranello are Ferrari",
      "If Prius is neither a sports car nor a loud car, then Prius is a Maranello-made car or a loud car."
    ],
    "question": "If Prius is a Ferrari or a loud car, then Prius is an electric car.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nSportsCar(x) ::: x is a sports car.\nLoud(x) ::: x is loud.\nElectric(x) ::: x is electric.\nFerrari(x) ::: x is a Ferrari.\nMadeInMaranello(x) ::: x is made in Maranello.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (SportsCar(x) → Loud(x)) ::: All sports cars are loud.\n∀x (Loud(x) → ¬Electric(x)) ::: No loud cars are electric.\nFerrari(x) → SportsCar(x) ::: If a car is a Ferrari, then it is a sports car.\n∀x (MadeInMaranello(x) → Ferrari(x)) ::: All cars made in Maranello are Ferrari.\n¬(SportsCar(prius) ∨ Loud(prius)) → (MadeInMaranello(prius) ∨ Loud(prius)) ::: If Prius is neither a sports car nor a loud car, then Prius is a Maranello-made car or a loud car.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n(Ferrari(prius) ∨ Loud(prius)) → Electric(prius) ::: If Prius is a Ferrari or a loud car, then Prius is an electric car.\n\"\"\""
    ]
  },
  {
    "id": 1288,
    "context": [
      "If something is a plant, then it is not a cute animal.",
      "All flowers are plants.",
      "Every kitten is a cute animal.",
      "If something is grown in a garden, then it is a flower.",
      "Piper is a kitten or a cute animal."
    ],
    "question": "Piper was grown in a garden.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nPlant(x) ::: x is a plant.\nCuteAnimal(x) ::: x is a cute animal.\nFlower(x) ::: x is a flower.\nKitten(x) ::: x is a kitten.\nGarden(x) ::: x is a garden.\nGrownIn(x, y) ::: x is grown in y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nPlant(x) → ¬CuteAnimal(x) ::: If something is a plant, then it is not a cute animal.\n∀x (Flower(x) → Plant(x)) ::: All flowers are plants.\n∀x (Kitten(x) → CuteAnimal(x)) ::: Every kitten is a cute animal.\nGrownIn(x, y) → Flower(x) ::: If something is grown in a garden, then it is a flower.\nKitten(piper) ∨ CuteAnimal(piper) ::: Piper is a kitten or a cute animal.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nGrownIn(piper, garden) ::: Piper was grown in a garden.\n\"\"\""
    ]
  },
  {
    "id": 1289,
    "context": [
      "If something is a plant, then it is not a cute animal.",
      "All flowers are plants.",
      "Every kitten is a cute animal.",
      "If something is grown in a garden, then it is a flower.",
      "Piper is a kitten or a cute animal."
    ],
    "question": "Piper was not grown in a garden.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nPlant(x) ::: x is a plant.\nCuteAnimal(x) ::: x is a cute animal.\nFlower(x) ::: x is a flower.\nKitten(x) ::: x is a kitten.\nGarden(x) ::: x is a garden.\nGrownIn(x, y) ::: x is grown in y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nPlant(x) → ¬CuteAnimal(x) ::: If something is a plant, then it is not a cute animal.\n∀x (Flower(x) → Plant(x)) ::: All flowers are plants.\n∀x (Kitten(x) → CuteAnimal(x)) ::: Every kitten is a cute animal.\nGrownIn(x, y) → Flower(x) ::: If something is grown in a garden, then it is a flower.\nKitten(piper) ∨ CuteAnimal(piper) ::: Piper is a kitten or a cute animal.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬GrownIn(piper, garden) ::: Piper was not grown in a garden.\n\"\"\""
    ]
  },
  {
    "id": 1290,
    "context": [
      "If something is a plant, then it is not a cute animal.",
      "All flowers are plants.",
      "Every kitten is a cute animal.",
      "If something is grown in a garden, then it is a flower.",
      "Piper is a kitten or a cute animal."
    ],
    "question": "Piper is a kitten.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nPlant(x) ::: x is a plant.\nCuteAnimal(x) ::: x is a cute animal.\nFlower(x) ::: x is a flower.\nKitten(x) ::: x is a kitten.\nGarden(x) ::: x is a garden.\nGrownIn(x, y) ::: x is grown in y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Plant(x) → ¬CuteAnimal(x)) ::: If something is a plant, then it is not a cute animal.\n∀x (Flower(x) → Plant(x)) ::: All flowers are plants.\n∀x (Kitten(x) → CuteAnimal(x)) ::: Every kitten is a cute animal.\n∀x (GrownIn(x, garden) → Flower(x)) ::: If something is grown in a garden, then it is a flower.\nKitten(piper) ∨ CuteAnimal(piper) ::: Piper is a kitten or a cute animal.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nKitten(piper) ::: Piper is a kitten.\n\"\"\""
    ]
  },
  {
    "id": 437,
    "context": [
      "Guam has participated in the Winter Olympics.",
      "In 1988, the Winter Olympics were held in Calgary.",
      "Guam sent an athlete to the Calgary Winter Olympics.",
      "If Guan sent an athlete to the Calgary Winter Olympics, then it participated in the Calgary Winter Olympics.",
      "Judd Bankert is the only athlete from Guam who has ever competed in the Winter Olympics."
    ],
    "question": "Judd Bankert competed in the 1992 Winter Olympics.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nParticipated(x, y) ::: x participated in the Winter Olympics in year y.\nHeld(y, x) ::: The Winter Olympics were held in location x in year y.\nSent(x, y, z) ::: x sent athlete y to the Winter Olympics in location z.\nCompeted(x, y) ::: x competed in the Winter Olympics in year y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nParticipated(guam, winterOlympics) ::: Guam has participated in the Winter Olympics.\nHeld(year1988, calgary) ::: In 1988, the Winter Olympics were held in Calgary.\nSent(guam, athlete, calgary) ::: Guam sent an athlete to the Calgary Winter Olympics.\nSent(guam, athlete, calgary) → Participated(guam, calgary) ::: If Guam sent an athlete to the Calgary Winter Olympics, then it participated in the Calgary Winter Olympics.\n∀x (Sent(guam, x, calgary) ↔ Competed(x, calgary)) ::: Judd Bankert is the only athlete from Guam who has ever competed in the Winter Olympics.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nCompeted(juddBankert, year1992) ::: Judd Bankert competed in the 1992 Winter Olympics.\n\"\"\""
    ]
  },
  {
    "id": 438,
    "context": [
      "Guam has participated in the Winter Olympics.",
      "In 1988, the Winter Olympics were held in Calgary.",
      "Guam sent an athlete to the Calgary Winter Olympics.",
      "If Guan sent an athlete to the Calgary Winter Olympics, then it participated in the Calgary Winter Olympics.",
      "Judd Bankert is the only athlete from Guam who has ever competed in the Winter Olympics."
    ],
    "question": "Guam has participated in the Summer Olympics at least once.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nParticipated(x, y) ::: x has participated in the Olympics y.\nHeld(y, x) ::: y was held in location x.\nSent(x, y, z) ::: x sent y to the z Olympics.\nCompeted(x, y) ::: x has competed in the Olympics y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nParticipated(guam, winterOlympics) ::: Guam has participated in the Winter Olympics.\nHeld(winterOlympics, calgary) ::: In 1988, the Winter Olympics were held in Calgary.\nSent(guam, athlete, calgaryWinterOlympics) ::: Guam sent an athlete to the Calgary Winter Olympics.\nSent(guam, athlete, calgaryWinterOlympics) → Participated(guam, calgaryWinterOlympics) ::: If Guam sent an athlete to the Calgary Winter Olympics, then it participated in the Calgary Winter Olympics.\n∀x (Sent(guam, x, winterOlympics) ↔ Competed(x, winterOlympics)) ::: Judd Bankert is the only athlete from Guam who has ever competed in the Winter Olympics.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n∃x (Participated(guam, summerOlympics)) ::: Guam has participated in the Summer Olympics at least once.\n\"\"\""
    ]
  },
  {
    "id": 209,
    "context": [
      "Michael O'Donnell is a British physician, journalist, author and broadcaster.",
      "One of the word-setters of My Word! was Michael O'Donnell.",
      "The magazine World Medicine was edited by Michael O'Donnell.",
      "Michael O'Donnell was born in Yorkshire as the son of a general practitioner."
    ],
    "question": "The son of a general practitioner was a word-setter of My Word!.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nBritish(x) ::: x is British.\nPhysician(x) ::: x is a physician.\nJournalist(x) ::: x is a journalist.\nAuthor(x) ::: x is an author.\nBroadcaster(x) ::: x is a broadcaster.\nWordSetter(x, y) ::: x is a word-setter of y.\nEdit(x, y) ::: x edits y.\nBornIn(x, y) ::: x was born in y.\nSonOf(x, y) ::: x is the son of y.\nGeneralPractitioner(x) ::: x is a general practitioner.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nBritish(michael) ∧ Physician(michael) ∧ Journalist(michael) ∧ Author(michael) ∧ Broadcaster(michael) ::: Michael O'Donnell is a British physician, journalist, author, and broadcaster.\nWordSetter(michael, myWord) ::: One of the word-setters of My Word! was Michael O'Donnell.\nEdit(worldMedicine, michael) ::: The magazine World Medicine was edited by Michael O'Donnell.\nBornIn(michael, yorkshire) ∧ SonOf(michael, generalPractitioner) ::: Michael O'Donnell was born in Yorkshire as the son of a general practitioner.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n∃x (SonOf(x, generalPractitioner) ∧ WordSetter(x, myWord)) ::: The son of a general practitioner was a word-setter of My Word!.\n\"\"\""
    ]
  },
  {
    "id": 210,
    "context": [
      "Michael O'Donnell is a British physician, journalist, author and broadcaster.",
      "One of the word-setters of My Word! was Michael O'Donnell.",
      "The magazine World Medicine was edited by Michael O'Donnell.",
      "Michael O'Donnell was born in Yorkshire as the son of a general practitioner."
    ],
    "question": "World Medicine is not a magazine.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nBritish(x) ::: x is British.\nPhysician(x) ::: x is a physician.\nJournalist(x) ::: x is a journalist.\nAuthor(x) ::: x is an author.\nBroadcaster(x) ::: x is a broadcaster.\nWordSetter(x, y) ::: x is a word-setter of y.\nEdit(x, y) ::: x edits y.\nBornIn(x, y) ::: x was born in y.\nSonOf(x, y) ::: x is the son of y.\nGeneralPractitioner(x) ::: x is a general practitioner.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nBritish(michael) ∧ Physician(michael) ∧ Journalist(michael) ∧ Author(michael) ∧ Broadcaster(michael) ::: Michael O'Donnell is a British physician, journalist, author, and broadcaster.\n∃x (WordSetter(michael, myWord)) ::: One of the word-setters of My Word! was Michael O'Donnell.\n∃x (Edit(michael, worldMedicine)) ::: The magazine World Medicine was edited by Michael O'Donnell.\nBornIn(michael, yorkshire) ∧ SonOf(michael, generalPractitioner) ::: Michael O'Donnell was born in Yorkshire as the son of a general practitioner.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬(∃x (Edit(x, worldMedicine))) ::: World Medicine is not a magazine.\n\"\"\""
    ]
  },
  {
    "id": 211,
    "context": [
      "Michael O'Donnell is a British physician, journalist, author and broadcaster.",
      "One of the word-setters of My Word! was Michael O'Donnell.",
      "The magazine World Medicine was edited by Michael O'Donnell.",
      "Michael O'Donnell was born in Yorkshire as the son of a general practitioner."
    ],
    "question": "There are no British authors.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nBritish(x) ::: x is British.\nPhysician(x) ::: x is a physician.\nJournalist(x) ::: x is a journalist.\nAuthor(x) ::: x is an author.\nBroadcaster(x) ::: x is a broadcaster.\nWordSetter(x, y) ::: x is one of the word-setters of y.\nEdit(x, y) ::: x edits y.\nBornIn(x, y) ::: x was born in y.\nSonOf(x, y) ::: x is the son of y.\nGeneralPractitioner(x) ::: x is a general practitioner.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nBritish(michael) ∧ Physician(michael) ∧ Journalist(michael) ∧ Author(michael) ∧ Broadcaster(michael) ::: Michael O'Donnell is a British physician, journalist, author, and broadcaster.\n∃x (WordSetter(michael, myWord)) ::: One of the word-setters of My Word! was Michael O'Donnell.\n∃x (Edit(worldMedicine, michael)) ::: The magazine World Medicine was edited by Michael O'Donnell.\nBornIn(michael, yorkshire) ∧ SonOf(michael, generalPractitioner) ::: Michael O'Donnell was born in Yorkshire as the son of a general practitioner.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬∃x Author(x) ∧ British(x) ::: There are no British authors.\n\"\"\""
    ]
  },
  {
    "id": 212,
    "context": [
      "Michael O'Donnell is a British physician, journalist, author and broadcaster.",
      "One of the word-setters of My Word! was Michael O'Donnell.",
      "The magazine World Medicine was edited by Michael O'Donnell.",
      "Michael O'Donnell was born in Yorkshire as the son of a general practitioner."
    ],
    "question": "There are no journalists that were born in Yorkshire.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nBritish(x) ::: x is British.\nPhysician(x) ::: x is a physician.\nJournalist(x) ::: x is a journalist.\nAuthor(x) ::: x is an author.\nBroadcaster(x) ::: x is a broadcaster.\nWordSetter(x, y) ::: x is one of the word-setters of y.\nEditedBy(x, y) ::: x is edited by y.\nBornIn(x, y) ::: x was born in y.\nSonOf(x, y) ::: x is the son of y.\nGeneralPractitioner(x) ::: x is a general practitioner.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nBritish(michael) ∧ Physician(michael) ∧ Journalist(michael) ∧ Author(michael) ∧ Broadcaster(michael) ::: Michael O'Donnell is a British physician, journalist, author, and broadcaster.\n∃x (WordSetter(michael, myWord)) ::: One of the word-setters of My Word! was Michael O'Donnell.\n∃x (EditedBy(worldMedicine, michael)) ::: The magazine World Medicine was edited by Michael O'Donnell.\nBornIn(michael, yorkshire) ∧ SonOf(michael, generalPractitioner) ::: Michael O'Donnell was born in Yorkshire as the son of a general practitioner.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬∃x (Journalist(x) ∧ BornIn(x, yorkshire)) ::: There are no journalists that were born in Yorkshire.\n\"\"\""
    ]
  },
  {
    "id": 213,
    "context": [
      "Michael O'Donnell is a British physician, journalist, author and broadcaster.",
      "One of the word-setters of My Word! was Michael O'Donnell.",
      "The magazine World Medicine was edited by Michael O'Donnell.",
      "Michael O'Donnell was born in Yorkshire as the son of a general practitioner."
    ],
    "question": "There is a son of a general practitioner that is not an author.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nBritish(x) ::: x is British.\nPhysician(x) ::: x is a physician.\nJournalist(x) ::: x is a journalist.\nAuthor(x) ::: x is an author.\nBroadcaster(x) ::: x is a broadcaster.\nWordSetter(x, y) ::: x is one of the word-setters of y.\nEdit(x, y) ::: x edits y.\nMagazine(x) ::: x is a magazine.\nBornIn(x, y) ::: x was born in y.\nSonOf(x, y) ::: x is the son of y.\nGeneralPractitioner(x) ::: x is a general practitioner.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nBritish(michael) ∧ Physician(michael) ∧ Journalist(michael) ∧ Author(michael) ∧ Broadcaster(michael) ::: Michael O'Donnell is a British physician, journalist, author, and broadcaster.\n∃x (WordSetter(michael, myWord)) ::: One of the word-setters of My Word! was Michael O'Donnell.\n∃x (Edit(worldMedicine, michael)) ::: The magazine World Medicine was edited by Michael O'Donnell.\nBornIn(michael, yorkshire) ∧ SonOf(michael, generalPractitioner) ::: Michael O'Donnell was born in Yorkshire as the son of a general practitioner.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n∃x (SonOf(x, generalPractitioner) ∧ ¬Author(x)) ::: There is a son of a general practitioner that is not an author.\n\"\"\""
    ]
  },
  {
    "id": 704,
    "context": [
      "No homework is fun.",
      "Some reading is homework."
    ],
    "question": "Some reading is fun.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nFun(x) ::: x is fun.\nHomework(x) ::: x is homework.\nReading(x) ::: x is reading.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Homework(x) → ¬Fun(x)) ::: No homework is fun.\n∃x (Reading(x) ∧ Homework(x)) ::: Some reading is homework.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n∃x (Reading(x) ∧ Fun(x)) ::: Some reading is fun.\n\"\"\""
    ]
  },
  {
    "id": 747,
    "context": [
      "If violence is good, it is justified.",
      "If something is justified, it is lawful."
    ],
    "question": "If violence is good, it is lawful.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nGood(x) ::: x is good.\nJustified(x) ::: x is justified.\nLawful(x) ::: x is lawful.\nViolence(x) ::: x is violence.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nGood(violence) → Justified(violence) ::: If violence is good, it is justified.\nJustified(x) → Lawful(x) ::: If something is justified, it is lawful.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nGood(violence) → Lawful(violence) ::: If violence is good, it is lawful.\n\"\"\""
    ]
  },
  {
    "id": 1025,
    "context": [
      "All people who have a horse ranch regularly ride horses for pleasure and sport.",
      "All people who have a lot of disposable income have a horse ranch.",
      "If people compete in horse dressage shows, then they have a lot of disposable income.",
      "If people compete in horse dressage shows, then they have invested in high-quality equestrian gear and equipment.",
      "If people regularly ride horses for pleasure and sport, then they do not live in cramped residential buildings.",
      "Manny either has a horse ranch and lives in cramped residential buildings, or he neither has a horse ranch nor lives in cramped residential buildings."
    ],
    "question": "Manny regularly rides horses for pleasure and sport.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nHave(x, y) ::: x has y.\nRide(x, y) ::: x regularly rides y.\nCompete(x) ::: x competes in horse dressage shows.\nInvested(x, y) ::: x has invested in y.\nLive(x, y) ::: x lives in y.\nCrampedResidentialBuilding(x) ::: x lives in cramped residential buildings.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x ((Have(x, horseRanch) → Ride(x, horses)) ∧ Ride(x, horses)) ::: All people who have a horse ranch regularly ride horses for pleasure and sport.\n∀x ((Have(x, disposableIncome) → Have(x, horseRanch)) ∧ Have(x, horseRanch)) ::: All people who have a lot of disposable income have a horse ranch.\n∀x (Compete(x) → Have(x, disposableIncome)) ::: If people compete in horse dressage shows, then they have a lot of disposable income.\n∀x (Compete(x) → Invested(x, highQualityEquestrianGear)) ::: If people compete in horse dressage shows, then they have invested in high-quality equestrian gear and equipment.\n∀x ((Ride(x, horses) → ¬Live(x, crampedResidentialBuilding)) ∧ Ride(x, horses)) ::: If people regularly ride horses for pleasure and sport, then they do not live in cramped residential buildings.\n(Have(manny, horseRanch) ∧ Live(manny, crampedResidentialBuilding)) ⊕ ¬(Have(manny, horseRanch) ∨ Live(manny, crampedResidentialBuilding)) ::: Manny either has a horse ranch and lives in cramped residential buildings, or he neither has a horse ranch nor lives in cramped residential buildings.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nRide(manny, horses) ::: Manny regularly rides horses for pleasure and sport.\n\"\"\""
    ]
  },
  {
    "id": 1026,
    "context": [
      "All people who have a horse ranch regularly ride horses for pleasure and sport.",
      "All people who have a lot of disposable income have a horse ranch.",
      "If people compete in horse dressage shows, then they have a lot of disposable income.",
      "If people compete in horse dressage shows, then they have invested in high-quality equestrian gear and equipment.",
      "If people regularly ride horses for pleasure and sport, then they do not live in cramped residential buildings.",
      "Manny either has a horse ranch and lives in cramped residential buildings, or he neither has a horse ranch nor lives in cramped residential buildings."
    ],
    "question": "Manny competes in horse dressage shows and has invested in high-quality equestrian equipment and gear.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nHaveHorseRanch(x) ::: x has a horse ranch.\nRideHorses(x) ::: x regularly rides horses for pleasure and sport.\nHaveDisposableIncome(x) ::: x has a lot of disposable income.\nCompeteInShows(x) ::: x competes in horse dressage shows.\nInvestedInGear(x) ::: x has invested in high-quality equestrian gear and equipment.\nLiveInCrampedBuilding(x) ::: x lives in cramped residential buildings.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (HaveHorseRanch(x) → (RideHorses(x) ∧ HaveDisposableIncome(x))) ::: All people who have a horse ranch regularly ride horses for pleasure and sport.\n∀x (HaveDisposableIncome(x) → HaveHorseRanch(x)) ::: All people who have a lot of disposable income have a horse ranch.\n∀x (CompeteInShows(x) → HaveDisposableIncome(x)) ::: If people compete in horse dressage shows, then they have a lot of disposable income.\n∀x (CompeteInShows(x) → InvestedInGear(x)) ::: If people compete in horse dressage shows, then they have invested in high-quality equestrian gear and equipment.\n∀x (RideHorses(x) → ¬LiveInCrampedBuilding(x)) ::: If people regularly ride horses for pleasure and sport, then they do not live in cramped residential buildings.\n(HaveHorseRanch(manny) ∧ LiveInCrampedBuilding(manny)) ⊕ ¬(HaveHorseRanch(manny) ∨ LiveInCrampedBuilding(manny)) ::: Manny either has a horse ranch and lives in cramped residential buildings, or he neither has a horse ranch nor lives in cramped residential buildings.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nCompeteInShows(manny) ∧ InvestedInGear(manny) ::: Manny competes in horse dressage shows and has invested in high-quality equestrian equipment and gear.\n\"\"\""
    ]
  },
  {
    "id": 1027,
    "context": [
      "All people who have a horse ranch regularly ride horses for pleasure and sport.",
      "All people who have a lot of disposable income have a horse ranch.",
      "If people compete in horse dressage shows, then they have a lot of disposable income.",
      "If people compete in horse dressage shows, then they have invested in high-quality equestrian gear and equipment.",
      "If people regularly ride horses for pleasure and sport, then they do not live in cramped residential buildings.",
      "Manny either has a horse ranch and lives in cramped residential buildings, or he neither has a horse ranch nor lives in cramped residential buildings."
    ],
    "question": "If Manny either has a horse ranch or competes in horse dressage shows, then Manny has not invested in high-quality equestrian equipment and gear.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nHaveHorseRanch(x) ::: x has a horse ranch.\nRideHorses(x) ::: x regularly rides horses for pleasure and sport.\nHaveDisposableIncome(x) ::: x has a lot of disposable income.\nCompeteInShows(x) ::: x competes in horse dressage shows.\nInvested(x) ::: x has invested in high-quality equestrian gear and equipment.\nLiveInCrampedBuilding(x) ::: x lives in cramped residential buildings.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (HaveHorseRanch(x) → RideHorses(x)) ::: All people who have a horse ranch regularly ride horses for pleasure and sport.\n∀x (HaveDisposableIncome(x) → HaveHorseRanch(x)) ::: All people who have a lot of disposable income have a horse ranch.\n∀x (CompeteInShows(x) → HaveDisposableIncome(x)) ::: If people compete in horse dressage shows, then they have a lot of disposable income.\n∀x (CompeteInShows(x) → Invested(x)) ::: If people compete in horse dressage shows, then they have invested in high-quality equestrian gear and equipment.\n∀x (RideHorses(x) → ¬LiveInCrampedBuilding(x)) ::: If people regularly ride horses for pleasure and sport, then they do not live in cramped residential buildings.\n(HaveHorseRanch(manny) ∧ LiveInCrampedBuilding(manny)) ⊕ ¬(HaveHorseRanch(manny) ∨ LiveInCrampedBuilding(manny)) ::: Manny either has a horse ranch and lives in cramped residential buildings, or he neither has a horse ranch nor lives in cramped residential buildings.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n(HaveHorseRanch(manny) ∨ CompeteInShows(manny)) → ¬Invested(manny) ::: If Manny either has a horse ranch or competes in horse dressage shows, then Manny has not invested in high-quality equestrian equipment and gear.\n\"\"\""
    ]
  },
  {
    "id": 159,
    "context": [
      "A roundel is a rounded artillery fortification.",
      "A roundel is not higher than adjacent walls. ",
      "Cannons can be deployed on artillery fortifications. ",
      "Roundels are the oldest artillery fortifications.",
      "Battery towers are an artillery fortification."
    ],
    "question": "Cannons can be deployed on battery towers.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nRoundel(x) ::: x is a roundel.\nArtilleryFortification(x) ::: x is an artillery fortification.\nHigher(x, y) ::: x is higher than y.\nAdjacent(x, y) ::: x is adjacent to y.\nCannon(x) ::: x is a cannon.\nDeployedOn(x, y) ::: x is deployed on y.\nOldest(x) ::: x is the oldest.\nBatteryTower(x) ::: x is a battery tower.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Roundel(x) → ArtilleryFortification(x)) ::: A roundel is a rounded artillery fortification.\n∀x ¬(Higher(Roundel(x), Adjacent(x))) ::: A roundel is not higher than adjacent walls.\n∀x (Cannon(x) → DeployedOn(x, ArtilleryFortification(x))) ::: Cannons can be deployed on artillery fortifications.\n∀x (Roundel(x) → Oldest(x)) ::: Roundels are the oldest artillery fortifications.\nBatteryTower(x) → ArtilleryFortification(x) ::: Battery towers are an artillery fortification.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n∃x (Cannon(x) ∧ DeployedOn(x, BatteryTower(x))) ::: Cannons can be deployed on battery towers.\n\"\"\""
    ]
  },
  {
    "id": 160,
    "context": [
      "A roundel is a rounded artillery fortification.",
      "A roundel is not higher than adjacent walls. ",
      "Cannons can be deployed on artillery fortifications. ",
      "Roundels are the oldest artillery fortifications.",
      "Battery towers are an artillery fortification."
    ],
    "question": "Roundels are older than battery towers.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nRoundel(x) ::: x is a roundel.\nFortification(x) ::: x is an artillery fortification.\nHigher(x, y) ::: x is higher than y.\nAdjacent(x, y) ::: x is adjacent to y.\nCannon(x) ::: x is a cannon.\nDeployedOn(x, y) ::: x is deployed on y.\nOldest(x) ::: x is the oldest.\nBatteryTower(x) ::: x is a battery tower.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Roundel(x) → Fortification(x)) ::: A roundel is a rounded artillery fortification.\n∀x (Roundel(x) → ¬Higher(x, Adjacent(x))) ::: A roundel is not higher than adjacent walls.\n∃x (Cannon(x) ∧ DeployedOn(x, Fortification(x))) ::: Cannons can be deployed on artillery fortifications.\n∀x (Roundel(x) → Oldest(x)) ::: Roundels are the oldest artillery fortifications.\nBatteryTower(x) → Fortification(x) ::: Battery towers are an artillery fortification.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nOldest(roundel) → ¬Oldest(batteryTower) ::: Roundels are older than battery towers.\n\"\"\""
    ]
  },
  {
    "id": 161,
    "context": [
      "A roundel is a rounded artillery fortification.",
      "A roundel is not higher than adjacent walls. ",
      "Cannons can be deployed on artillery fortifications. ",
      "Roundels are the oldest artillery fortifications.",
      "Battery towers are an artillery fortification."
    ],
    "question": "Battery towers are higher than adjacent walls.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nRoundel(x) ::: x is a roundel.\nArtilleryFortification(x) ::: x is an artillery fortification.\nHigher(x, y) ::: x is higher than y.\nAdjacent(x, y) ::: x is adjacent to y.\nCannon(x) ::: x is a cannon.\nDeployedOn(x, y) ::: x is deployed on y.\nOldest(x) ::: x is the oldest.\nBatteryTower(x) ::: x is a battery tower.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Roundel(x) → ArtilleryFortification(x)) ::: A roundel is a rounded artillery fortification.\n∀x ¬Higher(Roundel(x), Adjacent(x))) ::: A roundel is not higher than adjacent walls.\n∀x (Cannon(x) → DeployedOn(x, ArtilleryFortification)) ::: Cannons can be deployed on artillery fortifications.\nOldest(Roundel) ::: Roundels are the oldest artillery fortifications.\nBatteryTower(x) → ArtilleryFortification(x) ::: Battery towers are an artillery fortification.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬Higher(BatteryTower, Adjacent) ::: Battery towers are higher than adjacent walls.\n\"\"\""
    ]
  },
  {
    "id": 162,
    "context": [
      "A roundel is a rounded artillery fortification.",
      "A roundel is not higher than adjacent walls. ",
      "Cannons can be deployed on artillery fortifications. ",
      "Roundels are the oldest artillery fortifications.",
      "Battery towers are an artillery fortification."
    ],
    "question": "Roundels can be deployed on roundels.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nRoundel(x) ::: x is a roundel.\nArtilleryFortification(x) ::: x is an artillery fortification.\nHigher(x, y) ::: x is higher than y.\nDeployedOn(x, y) ::: x can be deployed on y.\nCannon(x) ::: x is a cannon.\nOldest(x) ::: x is the oldest.\nBatteryTower(x) ::: x is a battery tower.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Roundel(x) → ArtilleryFortification(x)) ::: A roundel is an artillery fortification.\n∀x (Roundel(x) → ¬Higher(x, adjacentWalls)) ::: A roundel is not higher than adjacent walls.\n∀x (Cannon(x) → DeployedOn(x, ArtilleryFortification)) ::: Cannons can be deployed on artillery fortifications.\nOldest(Roundel) ::: Roundels are the oldest artillery fortifications.\nBatteryTower(x) → ArtilleryFortification(x) ::: Battery towers are an artillery fortification.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n∃x ∃y (Roundel(x) ∧ Roundel(y) ∧ DeployedOn(x, y)) ::: Roundels can be deployed on roundels.\n\"\"\""
    ]
  },
  {
    "id": 737,
    "context": [
      "All tissues are soft.",
      "Some papers are tissues."
    ],
    "question": "Some papers are hard.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nSoft(x) ::: x is soft.\nTissue(x) ::: x is a tissue.\nPaper(x) ::: x is a paper.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Tissue(x) → Soft(x)) ::: All tissues are soft.\n∃x (Paper(x) ∧ Tissue(x)) ::: Some papers are tissues.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n∃x (Paper(x) ∧ ¬Soft(x)) ::: Some papers are hard.\n\"\"\""
    ]
  },
  {
    "id": 488,
    "context": [
      "All volunteers receive intangible benefits for their work.",
      "Volunteers work regularly or on an as-needed basis.",
      "Some volunteers are trained.",
      "Volunteers work in groups or individually.",
      "Environmental volunteers contribute toward environmental management or conservation.",
      "Participating in natural disaster response is an example of volunteers working in groups on an as-needed basis."
    ],
    "question": "Volunteers who participate in natural disaster response receive intangible benefits for their work.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nVolunteer(x) ::: x is a volunteer.\nReceiveBenefits(x) ::: x receives intangible benefits for their work.\nWorkRegularly(x) ::: x works regularly.\nWorkAsNeeded(x) ::: x works on an as-needed basis.\nTrained(x) ::: x is trained.\nWorkInGroups(x) ::: x works in groups.\nWorkIndividually(x) ::: x works individually.\nContribute(x) ::: x contributes toward environmental management or conservation.\nParticipateInNaturalDisasterResponse(x) ::: x participates in natural disaster response.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Volunteer(x) → ReceiveBenefits(x)) ::: All volunteers receive intangible benefits for their work.\n∀x (WorkRegularly(x) ∨ WorkAsNeeded(x)) ::: Volunteers work regularly or on an as-needed basis.\n∃x (Volunteer(x) ∧ Trained(x)) ::: Some volunteers are trained.\n∀x (WorkInGroups(x) ∨ WorkIndividually(x)) ::: Volunteers work in groups or individually.\n∀x (Environmental(x) → (Contribute(x) ∨ Conservation(x))) ::: Environmental volunteers contribute toward environmental management or conservation.\nParticipateInNaturalDisasterResponse(x) ↔ (WorkInGroups(x) ∧ WorkAsNeeded(x)) ::: Participating in natural disaster response is an example of volunteers working in groups on an as-needed basis.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nParticipateInNaturalDisasterResponse(x) → ReceiveBenefits(x) ::: Volunteers who participate in natural disaster response receive intangible benefits for their work.\n\"\"\""
    ]
  },
  {
    "id": 489,
    "context": [
      "All volunteers receive intangible benefits for their work.",
      "Volunteers work regularly or on an as-needed basis.",
      "Some volunteers are trained.",
      "Volunteers work in groups or individually.",
      "Environmental volunteers contribute toward environmental management or conservation.",
      "Participating in natural disaster response is an example of volunteers working in groups on an as-needed basis."
    ],
    "question": "Environmental volunteers work in groups.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nVolunteer(x) ::: x is a volunteer.\nReceiveBenefits(x) ::: x receives intangible benefits for their work.\nWorkRegularly(x) ::: x works regularly.\nWorkAsNeeded(x) ::: x works on an as-needed basis.\nTrained(x) ::: x is trained.\nWorkInGroups(x) ::: x works in groups.\nWorkIndividually(x) ::: x works individually.\nContribute(x) ::: x contributes toward environmental management or conservation.\nParticipateIn(x, y) ::: x participates in y.\nNaturalDisasterResponse(x) ::: x is participating in natural disaster response.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Volunteer(x) → ReceiveBenefits(x)) ::: All volunteers receive intangible benefits for their work.\n∀x (WorkRegularly(x) ∨ WorkAsNeeded(x)) ::: Volunteers work regularly or on an as-needed basis.\n∃x (Volunteer(x) ∧ Trained(x)) ::: Some volunteers are trained.\n∀x (WorkInGroups(x) ∨ WorkIndividually(x)) ::: Volunteers work in groups or individually.\n∀x (Volunteer(x) → (Contribute(x) ∨ Conserve(x))) ::: Environmental volunteers contribute toward environmental management or conservation.\nParticipateIn(volunteer, NaturalDisasterResponse) → (WorkInGroups(volunteer) ∧ WorkAsNeeded(volunteer)) ::: Participating in natural disaster response is an example of volunteers working in groups on an as-needed basis.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nWorkInGroups(environmentalVolunteer) ::: Environmental volunteers work in groups.\n\"\"\""
    ]
  },
  {
    "id": 490,
    "context": [
      "All volunteers receive intangible benefits for their work.",
      "Volunteers work regularly or on an as-needed basis.",
      "Some volunteers are trained.",
      "Volunteers work in groups or individually.",
      "Environmental volunteers contribute toward environmental management or conservation.",
      "Participating in natural disaster response is an example of volunteers working in groups on an as-needed basis."
    ],
    "question": "To be a volunteer, you must be trained.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nVolunteer(x) ::: x is a volunteer.\nReceiveBenefits(x) ::: x receives intangible benefits for their work.\nWorkRegularly(x) ::: x works regularly.\nWorkAsNeeded(x) ::: x works on an as-needed basis.\nTrained(x) ::: x is trained.\nWorkInGroups(x) ::: x works in groups.\nWorkIndividually(x) ::: x works individually.\nContribute(x) ::: x contributes toward environmental management or conservation.\nParticipateIn(x, y) ::: x participates in y.\nNaturalDisasterResponse(x) ::: x is participating in natural disaster response.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Volunteer(x) → ReceiveBenefits(x)) ::: All volunteers receive intangible benefits for their work.\n∀x (Volunteer(x) → (WorkRegularly(x) ∨ WorkAsNeeded(x))) ::: Volunteers work regularly or on an as-needed basis.\n∃x (Volunteer(x) ∧ Trained(x)) ::: Some volunteers are trained.\n∀x (Volunteer(x) → (WorkInGroups(x) ∨ WorkIndividually(x))) ::: Volunteers work in groups or individually.\n∀x (Volunteer(x) ∧ Contribute(x) ↔ Environmental(x)) ::: Environmental volunteers contribute toward environmental management or conservation.\nParticipateIn(volunteer, NaturalDisasterResponse) ↔ (WorkInGroups(volunteer) ∧ WorkAsNeeded(volunteer)) ::: Participating in natural disaster response is an example of volunteers working in groups on an as-needed basis.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nTrained(volunteer) ::: To be a volunteer, you must be trained.\n\"\"\""
    ]
  },
  {
    "id": 1007,
    "context": [
      "All people who are very consistent and enjoy sticking to their regular routines do not like surprises.",
      "If people wear flannel shirts every day, then they are very consistent and enjoy sticking to their regular routines.",
      "If people do not like shopping for clothes and other materialistic goods, then they wear flannel shirts every day.",
      "All old people living in stable homes do not like surprises.",
      "If people have very high energy and are impulsive, then they like surprises.",
      "If Mike is not a person who wears flannel shirts every day and has very high energy and is impulsive, then Mike either is very consistent and enjoys sticking to his regular routines or does not like surprises."
    ],
    "question": "Mike is an old person living in a stable home.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nConsistent(x) ::: x is very consistent and enjoys sticking to their regular routines.\nSurprises(x) ::: x likes surprises.\nWearFlannel(x) ::: x wears flannel shirts every day.\nMaterialistic(x) ::: x likes shopping for clothes and other materialistic goods.\nOld(x) ::: x is old.\nStableHome(x) ::: x is living in a stable home.\nHighEnergy(x) ::: x has very high energy.\nImpulsive(x) ::: x is impulsive.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Consistent(x) ∧ EnjoyRoutine(x) → ¬Surprises(x)) ::: All people who are very consistent and enjoy sticking to their regular routines do not like surprises.\n∀x (WearFlannel(x) → Consistent(x) ∧ EnjoyRoutine(x)) ::: If people wear flannel shirts every day, then they are very consistent and enjoy sticking to their regular routines.\n∀x (¬Materialistic(x) → WearFlannel(x)) ::: If people do not like shopping for clothes and other materialistic goods, then they wear flannel shirts every day.\n∀x (Old(x) ∧ StableHome(x) → ¬Surprises(x)) ::: All old people living in stable homes do not like surprises.\n∀x (HighEnergy(x) ∧ Impulsive(x) → Surprises(x)) ::: If people have very high energy and are impulsive, then they like surprises.\n¬(WearFlannel(mike) ∧ HighEnergy(mike) ∧ Impulsive(mike)) → (Consistent(mike) ∧ EnjoyRoutine(mike)) ⊕ ¬Surprises(mike) ::: If Mike is not a person who wears flannel shirts every day and has very high energy and is impulsive, then Mike either is very consistent and enjoys sticking to his regular routines or does not like surprises.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nOld(mike) ∧ StableHome(mike) ::: Mike is an old person living in a stable home.\n\"\"\""
    ]
  },
  {
    "id": 1008,
    "context": [
      "All people who are very consistent and enjoy sticking to their regular routines do not like surprises.",
      "If people wear flannel shirts every day, then they are very consistent and enjoy sticking to their regular routines.",
      "If people do not like shopping for clothes and other materialistic goods, then they wear flannel shirts every day.",
      "All old people living in stable homes do not like surprises.",
      "If people have very high energy and are impulsive, then they like surprises.",
      "If Mike is not a person who wears flannel shirts every day and has very high energy and is impulsive, then Mike either is very consistent and enjoys sticking to his regular routines or does not like surprises."
    ],
    "question": "If Mike wears flannel shirts every day or does not like shopping for clothes and other materialistic goods, then Mike is neither an old person living in a stable home nor does not like shopping for clothes and other materialistic goods.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nConsistent(x) ::: x is very consistent and enjoys sticking to their regular routines.\nSurprises(x) ::: x likes surprises.\nWearFlannel(x) ::: x wears flannel shirts every day.\nMaterialistic(x) ::: x likes shopping for clothes and other materialistic goods.\nOld(x) ::: x is an old person living in stable homes.\nHighEnergy(x) ::: x has very high energy.\nImpulsive(x) ::: x is impulsive.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Consistent(x) ∧ EnjoyRoutine(x) → ¬Surprises(x)) ::: All people who are very consistent and enjoy sticking to their regular routines do not like surprises.\n∀x (WearFlannel(x) → (Consistent(x) ∧ EnjoyRoutine(x))) ::: If people wear flannel shirts every day, then they are very consistent and enjoy sticking to their regular routines.\n∀x (¬Materialistic(x) → WearFlannel(x)) ::: If people do not like shopping for clothes and other materialistic goods, then they wear flannel shirts every day.\n∀x (Old(x) → ¬Surprises(x)) ::: All old people living in stable homes do not like surprises.\n∀x (HighEnergy(x) ∧ Impulsive(x) → Surprises(x)) ::: If people have very high energy and are impulsive, then they like surprises.\n¬(WearFlannel(mike) ∧ HighEnergy(mike) ∧ Impulsive(mike)) → (Consistent(mike) ∧ EnjoyRoutine(mike)) ⊕ ¬Surprises(mike) ::: If Mike is not a person who wears flannel shirts every day and has very high energy and is impulsive, then Mike either is very consistent and enjoys sticking to his regular routines or does not like surprises.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n(WearFlannel(mike) ∨ ¬Materialistic(mike)) → (¬Old(mike) ∧ Materialistic(mike)) ::: If Mike wears flannel shirts every day or does not like shopping for clothes and other materialistic goods, then Mike is neither an old person living in a stable home nor does not like shopping for clothes and other materialistic goods.\n\"\"\""
    ]
  },
  {
    "id": 1009,
    "context": [
      "All people who are very consistent and enjoy sticking to their regular routines do not like surprises.",
      "If people wear flannel shirts every day, then they are very consistent and enjoy sticking to their regular routines.",
      "If people do not like shopping for clothes and other materialistic goods, then they wear flannel shirts every day.",
      "All old people living in stable homes do not like surprises.",
      "If people have very high energy and are impulsive, then they like surprises.",
      "If Mike is not a person who wears flannel shirts every day and has very high energy and is impulsive, then Mike either is very consistent and enjoys sticking to his regular routines or does not like surprises."
    ],
    "question": "If Mike is not an old person living in a stable home and does not like shopping for clothes and other materialistic goods, then Mike does not like shopping for clothes and other materialistic goods.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nConsistent(x) ::: x is very consistent and enjoys sticking to their regular routines.\nSurprises(x) ::: x likes surprises.\nWearFlannel(x) ::: x wears flannel shirts every day.\nMaterialistic(x) ::: x likes shopping for clothes and other materialistic goods.\nOld(x) ::: x is an old person living in stable homes.\nHighEnergy(x) ::: x has very high energy.\nImpulsive(x) ::: x is impulsive.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Consistent(x) ∧ EnjoyRoutine(x) → ¬Surprises(x)) ::: All people who are very consistent and enjoy sticking to their regular routines do not like surprises.\n∀x (WearFlannel(x) → (Consistent(x) ∧ EnjoyRoutine(x))) ::: If people wear flannel shirts every day, then they are very consistent and enjoy sticking to their regular routines.\n∀x (¬Materialistic(x) → WearFlannel(x)) ::: If people do not like shopping for clothes and other materialistic goods, then they wear flannel shirts every day.\n∀x (Old(x) → ¬Surprises(x)) ::: All old people living in stable homes do not like surprises.\n∀x (HighEnergy(x) ∧ Impulsive(x) → Surprises(x)) ::: If people have very high energy and are impulsive, then they like surprises.\n¬(WearFlannel(mike) ∧ HighEnergy(mike) ∧ Impulsive(mike)) → (Consistent(mike) ∧ EnjoyRoutine(mike)) ⊕ ¬Surprises(mike) ::: If Mike is not a person who wears flannel shirts every day and has very high energy and is impulsive, then Mike either is very consistent and enjoys sticking to his regular routines or does not like surprises.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬(Old(mike) ∧ StableHome(mike) ∧ ¬Materialistic(mike)) → ¬Materialistic(mike) ::: If Mike is not an old person living in a stable home and does not like shopping for clothes and other materialistic goods, then Mike does not like shopping for clothes and other materialistic goods.\n\"\"\""
    ]
  },
  {
    "id": 619,
    "context": [
      "Adam owns cars.",
      "Adam has a favorite car.",
      "Among the cars he owns, Adam's favorite car is European.",
      "Adam broke his favorite car."
    ],
    "question": "Adam owns a Japanese car.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nOwns(x, y) ::: x owns y.\nFavorite(x, y) ::: x has y as a favorite.\nIsEuropean(x) ::: x is European.\nBroke(x, y) ::: x broke y.\nIsJapanese(x) ::: x is Japanese.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nOwns(adam, car) ::: Adam owns cars.\n∃x (Favorite(adam, x)) ::: Adam has a favorite car.\n∀x (Owns(adam, x) ∧ Favorite(adam, x) → IsEuropean(x)) ::: Among the cars he owns, Adam's favorite car is European.\nBroke(adam, Favorite(adam, car)) ::: Adam broke his favorite car.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n∃x (Owns(adam, x) ∧ IsJapanese(x)) ::: Adam owns a Japanese car.\n\"\"\""
    ]
  },
  {
    "id": 620,
    "context": [
      "Adam owns cars.",
      "Adam has a favorite car.",
      "Among the cars he owns, Adam's favorite car is European.",
      "Adam broke his favorite car."
    ],
    "question": "Adam broke a European car.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nOwns(x, y) ::: x owns y.\nFavorite(x, y) ::: x has y as a favorite.\nEuropean(x) ::: x is European.\nBroke(x, y) ::: x broke y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nOwns(adam, car) ::: Adam owns cars.\n∃x Favorite(adam, x) ::: Adam has a favorite car.\n∀x (Owns(adam, x) ∧ Favorite(adam, x) → European(x)) ::: Among the cars he owns, Adam's favorite car is European.\nBroke(adam, Favorite(adam, car)) ::: Adam broke his favorite car.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n∃x (Broke(adam, x) ∧ European(x)) ::: Adam broke a European car.\n\"\"\""
    ]
  },
  {
    "id": 1240,
    "context": [
      "No buildings in New Haven are higher than 400 meters. ",
      "All buildings managed by Yale Housing are in New Haven. ",
      "All buildings in Manhattan are higher than 400 meters. ",
      "All buildings owned by Bloomberg are in Manhattan. ",
      "All buildings with the Bloomberg logo are buildings owned by Bloomberg. ",
      "Tower A is neither in New Haven nor in Manhattan.",
      "Tower B is a building with the Bloomberg logo and in Manhattan. "
    ],
    "question": "Tower A is higher than 400 meters.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nHigherThan400(x) ::: x is higher than 400 meters.\nInNewHaven(x) ::: x is in New Haven.\nManagedByYaleHousing(x) ::: x is managed by Yale Housing.\nInManhattan(x) ::: x is in Manhattan.\nOwnedByBloomberg(x) ::: x is owned by Bloomberg.\nHasBloombergLogo(x) ::: x has the Bloomberg logo.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (InNewHaven(x) → ¬HigherThan400(x)) ::: No buildings in New Haven are higher than 400 meters.\n∀x (ManagedByYaleHousing(x) → InNewHaven(x)) ::: All buildings managed by Yale Housing are in New Haven.\n∀x (InManhattan(x) → HigherThan400(x)) ::: All buildings in Manhattan are higher than 400 meters.\n∀x (OwnedByBloomberg(x) → InManhattan(x)) ::: All buildings owned by Bloomberg are in Manhattan.\n∀x (HasBloombergLogo(x) → OwnedByBloomberg(x)) ::: All buildings with the Bloomberg logo are buildings owned by Bloomberg.\n¬(InNewHaven(towerA) ∨ InManhattan(towerA)) ::: Tower A is neither in New Haven nor in Manhattan.\nHasBloombergLogo(towerB) ∧ InManhattan(towerB) ::: Tower B is a building with the Bloomberg logo and in Manhattan.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬HigherThan400(towerA) ::: Tower A is higher than 400 meters.\n\"\"\""
    ]
  },
  {
    "id": 1241,
    "context": [
      "No buildings in New Haven are higher than 400 meters. ",
      "All buildings managed by Yale Housing are in New Haven. ",
      "All buildings in Manhattan are higher than 400 meters. ",
      "All buildings owned by Bloomberg are in Manhattan. ",
      "All buildings with the Bloomberg logo are buildings owned by Bloomberg. ",
      "Tower A is neither in New Haven nor in Manhattan.",
      "Tower B is a building with the Bloomberg logo and in Manhattan. "
    ],
    "question": "Tower A is not higher than 400 meters.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nHigherThan(x, y) ::: x is higher than y.\nManagedByYaleHousing(x) ::: x is managed by Yale Housing.\nInNewHaven(x) ::: x is in New Haven.\nInManhattan(x) ::: x is in Manhattan.\nOwnedByBloomberg(x) ::: x is owned by Bloomberg.\nHasBloombergLogo(x) ::: x has the Bloomberg logo.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (InNewHaven(x) → ¬HigherThan(x, 400)) ::: No buildings in New Haven are higher than 400 meters.\n∀x (ManagedByYaleHousing(x) → InNewHaven(x)) ::: All buildings managed by Yale Housing are in New Haven.\n∀x (InManhattan(x) → HigherThan(x, 400)) ::: All buildings in Manhattan are higher than 400 meters.\n∀x (OwnedByBloomberg(x) → InManhattan(x)) ::: All buildings owned by Bloomberg are in Manhattan.\n∀x (HasBloombergLogo(x) → OwnedByBloomberg(x)) ::: All buildings with the Bloomberg logo are buildings owned by Bloomberg.\n¬(InNewHaven(towerA) ∨ InManhattan(towerA)) ::: Tower A is neither in New Haven nor in Manhattan.\nInManhattan(towerB) ∧ HasBloombergLogo(towerB) ::: Tower B is a building with the Bloomberg logo and in Manhattan.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬HigherThan(towerA, 400) ::: Tower A is not higher than 400 meters.\n\"\"\""
    ]
  },
  {
    "id": 1242,
    "context": [
      "No buildings in New Haven are higher than 400 meters. ",
      "All buildings managed by Yale Housing are in New Haven. ",
      "All buildings in Manhattan are higher than 400 meters. ",
      "All buildings owned by Bloomberg are in Manhattan. ",
      "All buildings with the Bloomberg logo are buildings owned by Bloomberg. ",
      "Tower A is neither in New Haven nor in Manhattan.",
      "Tower B is a building with the Bloomberg logo and in Manhattan. "
    ],
    "question": "Tower A is a building with the Bloomberg logo or managed by Yale Housing.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nHigher(x, y) ::: x is higher than y meters.\nManagedBy(x, y) ::: x is managed by y.\nIn(x, y) ::: x is in y.\nOwnedBy(x, y) ::: x is owned by y.\nHasLogo(x, y) ::: x has the logo of y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (In(x, NewHaven) → ¬Higher(x, 400)) ::: No buildings in New Haven are higher than 400 meters.\n∀x (ManagedBy(x, YaleHousing) → In(x, NewHaven)) ::: All buildings managed by Yale Housing are in New Haven.\n∀x (In(x, Manhattan) → Higher(x, 400)) ::: All buildings in Manhattan are higher than 400 meters.\n∀x (OwnedBy(x, Bloomberg) → In(x, Manhattan)) ::: All buildings owned by Bloomberg are in Manhattan.\n∀x (HasLogo(x, Bloomberg) → OwnedBy(x, Bloomberg)) ::: All buildings with the Bloomberg logo are buildings owned by Bloomberg.\n¬(In(towerA, NewHaven) ∨ In(towerA, Manhattan)) ::: Tower A is neither in New Haven nor in Manhattan.\nIn(towerB, Manhattan) ∧ HasLogo(towerB, Bloomberg) ::: Tower B is a building with the Bloomberg logo and in Manhattan.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nHasLogo(towerA, Bloomberg) ∨ ManagedBy(towerA, YaleHousing) ::: Tower A is a building with the Bloomberg logo or managed by Yale Housing.\n\"\"\""
    ]
  },
  {
    "id": 1243,
    "context": [
      "No buildings in New Haven are higher than 400 meters. ",
      "All buildings managed by Yale Housing are in New Haven. ",
      "All buildings in Manhattan are higher than 400 meters. ",
      "All buildings owned by Bloomberg are in Manhattan. ",
      "All buildings with the Bloomberg logo are buildings owned by Bloomberg. ",
      "Tower A is neither in New Haven nor in Manhattan.",
      "Tower B is a building with the Bloomberg logo and in Manhattan. "
    ],
    "question": "Tower A is neither a building with the Bloomberg logo nor managed by Yale Housing.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nHigherThan400(x) ::: x is higher than 400 meters.\nInNewHaven(x) ::: x is in New Haven.\nManagedByYaleHousing(x) ::: x is managed by Yale Housing.\nInManhattan(x) ::: x is in Manhattan.\nOwnedByBloomberg(x) ::: x is owned by Bloomberg.\nHasBloombergLogo(x) ::: x has the Bloomberg logo.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (InNewHaven(x) → ¬HigherThan400(x)) ::: No buildings in New Haven are higher than 400 meters.\n∀x (ManagedByYaleHousing(x) → InNewHaven(x)) ::: All buildings managed by Yale Housing are in New Haven.\n∀x (InManhattan(x) → HigherThan400(x)) ::: All buildings in Manhattan are higher than 400 meters.\n∀x (OwnedByBloomberg(x) → InManhattan(x)) ::: All buildings owned by Bloomberg are in Manhattan.\n∀x (HasBloombergLogo(x) → OwnedByBloomberg(x)) ::: All buildings with the Bloomberg logo are buildings owned by Bloomberg.\n¬(InNewHaven(towerA) ∨ InManhattan(towerA)) ::: Tower A is neither in New Haven nor in Manhattan.\nInManhattan(towerB) ∧ HasBloombergLogo(towerB) ::: Tower B is a building with the Bloomberg logo and in Manhattan.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬(HasBloombergLogo(towerA) ∨ ManagedByYaleHousing(towerA)) ::: Tower A is neither a building with the Bloomberg logo nor managed by Yale Housing.\n\"\"\""
    ]
  },
  {
    "id": 1266,
    "context": [
      "No fish are birds.",
      "Everything that is an osprey is a bird.",
      "If something is a carp, then it is a fish.",
      "All goldfish are carp.",
      "If Bubbles is either an osprey or a goldfish, then Bubbles is not a fish."
    ],
    "question": "Bubbles is an Osprey.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nFish(x) ::: x is a fish.\nBird(x) ::: x is a bird.\nOsprey(x) ::: x is an osprey.\nCarp(x) ::: x is a carp.\nGoldfish(x) ::: x is a goldfish.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Fish(x) → ¬Bird(x)) ::: No fish are birds.\n∀x (Osprey(x) → Bird(x)) ::: Everything that is an osprey is a bird.\n∀x (Carp(x) → Fish(x)) ::: If something is a carp, then it is a fish.\n∀x (Goldfish(x) → Carp(x)) ::: All goldfish are carp.\n(Goldfish(bubbles) ∨ Osprey(bubbles)) → ¬Fish(bubbles) ::: If Bubbles is either an osprey or a goldfish, then Bubbles is not a fish.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nOsprey(bubbles) ::: Bubbles is an Osprey.\n\"\"\""
    ]
  },
  {
    "id": 1267,
    "context": [
      "No fish are birds.",
      "Everything that is an osprey is a bird.",
      "If something is a carp, then it is a fish.",
      "All goldfish are carp.",
      "If Bubbles is either an osprey or a goldfish, then Bubbles is not a fish."
    ],
    "question": "Bubbles is a carp.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nFish(x) ::: x is a fish.\nBird(x) ::: x is a bird.\nOsprey(x) ::: x is an osprey.\nCarp(x) ::: x is a carp.\nGoldfish(x) ::: x is a goldfish.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Fish(x) → ¬Bird(x)) ::: No fish are birds.\n∀x (Osprey(x) → Bird(x)) ::: Everything that is an osprey is a bird.\n∀x (Carp(x) → Fish(x)) ::: If something is a carp, then it is a fish.\n∀x (Goldfish(x) → Carp(x)) ::: All goldfish are carp.\n(Goldfish(bubbles) ∨ Osprey(bubbles)) → ¬Fish(bubbles) ::: If Bubbles is either an osprey or a goldfish, then Bubbles is not a fish.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nCarp(bubbles) ::: Bubbles is a carp.\n\"\"\""
    ]
  },
  {
    "id": 1268,
    "context": [
      "No fish are birds.",
      "Everything that is an osprey is a bird.",
      "If something is a carp, then it is a fish.",
      "All goldfish are carp.",
      "If Bubbles is either an osprey or a goldfish, then Bubbles is not a fish."
    ],
    "question": "Bubbles is not a carp.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nFish(x) ::: x is a fish.\nBird(x) ::: x is a bird.\nOsprey(x) ::: x is an osprey.\nCarp(x) ::: x is a carp.\nGoldfish(x) ::: x is a goldfish.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Fish(x) → ¬Bird(x)) ::: No fish are birds.\n∀x (Osprey(x) → Bird(x)) ::: Everything that is an osprey is a bird.\n∀x (Carp(x) → Fish(x)) ::: If something is a carp, then it is a fish.\n∀x (Goldfish(x) → Carp(x)) ::: All goldfish are carp.\n(Osprey(bubbles) ∨ Goldfish(bubbles)) → ¬Fish(bubbles) ::: If Bubbles is either an osprey or a goldfish, then Bubbles is not a fish.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬Carp(bubbles) ::: Bubbles is not a carp.\n\"\"\""
    ]
  },
  {
    "id": 455,
    "context": [
      "Mr. and Mrs. Smith make a travel plan, they want to go to a city in California or Florida, and where neither of them has ever been.",
      "Cities in California that they are interested in are San Francisco, Los Angeles, and San Diego.",
      "Cities in Florida that they are interested in are Orlando and Miami.",
      "Mr. Smith has been to two cities in California.",
      "Mrs. Smith has been to one city in Florida."
    ],
    "question": "Mr. Smith has been to San Francisco.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nTravel(x) ::: x makes a travel plan.\nCity(x) ::: x is a city.\nCalifornia(x) ::: x is a city in California.\nFlorida(x) ::: x is a city in Florida.\nInterested(x, y) ::: x is interested in city y.\nBeenTo(x, y) ::: x has been to city y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nTravel(mrSmith) ∧ Travel(mrsSmith) ∧ ∀x (City(x) ∧ (California(x) ∨ Florida(x)) ∧ ¬(BeenTo(mrSmith, x) ∨ BeenTo(mrsSmith, x))) ::: Mr. and Mrs. Smith make a travel plan, they want to go to a city in California or Florida, and where neither of them has ever been.\nInterested(mrSmith, sanFrancisco) ∧ Interested(mrSmith, losAngeles) ∧ Interested(mrSmith, sanDiego) ∧ Interested(mrsSmith, orlando) ∧ Interested(mrsSmith, miami) ::: Cities in California that they are interested in are San Francisco, Los Angeles, and San Diego. Cities in Florida that they are interested in are Orlando and Miami.\n∃x (California(x) ∧ BeenTo(mrSmith, x) ∧ BeenTo(mrSmith, y) ∧ x ≠ y) ::: Mr. Smith has been to two cities in California.\n∃x (Florida(x) ∧ BeenTo(mrsSmith, x)) ::: Mrs. Smith has been to one city in Florida.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nBeenTo(mrSmith, sanFrancisco) ::: Mr. Smith has been to San Francisco.\n\"\"\""
    ]
  },
  {
    "id": 456,
    "context": [
      "Mr. and Mrs. Smith make a travel plan, they want to go to a city in California or Florida, and where neither of them has ever been.",
      "Cities in California that they are interested in are San Francisco, Los Angeles, and San Diego.",
      "Cities in Florida that they are interested in are Orlando and Miami.",
      "Mr. Smith has been to two cities in California.",
      "Mrs. Smith has been to one city in Florida."
    ],
    "question": "They have at leat one candidate city in Florida to visit.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nTravelPlan(x) ::: x makes a travel plan.\nGoTo(x, y) ::: x wants to go to city y.\nCity(x) ::: x is a city.\nCalifornia(x) ::: x is a city in California.\nFlorida(x) ::: x is a city in Florida.\nVisited(x, y) ::: x has been to city y.\nInterestedIn(x, y) ::: x is interested in city y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nTravelPlan(mrSmith) ∧ TravelPlan(mrsSmith) ∧ GoTo(mrSmith, city) ∧ GoTo(mrsSmith, city) ∧ City(city) ∧ ((California(city) ∨ Florida(city)) ∧ ¬(Visited(mrSmith, city) ∨ Visited(mrsSmith, city))) ::: Mr. and Mrs. Smith make a travel plan, they want to go to a city in California or Florida, and where neither of them has ever been.\nInterestedIn(mrSmith, sanFrancisco) ∧ InterestedIn(mrSmith, losAngeles) ∧ InterestedIn(mrSmith, sanDiego) ∧ InterestedIn(mrsSmith, orlando) ∧ InterestedIn(mrsSmith, miami) ::: Cities in California that they are interested in are San Francisco, Los Angeles, and San Diego. Cities in Florida that they are interested in are Orlando and Miami.\nVisited(mrSmith, sanFrancisco) ∧ Visited(mrSmith, losAngeles) ∧ ¬Visited(mrSmith, sanDiego) ∧ Visited(mrsSmith, orlando) ∧ ¬Visited(mrsSmith, miami) ::: Mr. Smith has been to two cities in California. Mrs. Smith has been to one city in Florida.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n∃x (InterestedIn(mrSmith, x) ∧ Florida(x)) ∨ ∃x (InterestedIn(mrsSmith, x) ∧ Florida(x)) ::: They have at least one candidate city in Florida to visit.\n\"\"\""
    ]
  },
  {
    "id": 457,
    "context": [
      "Mr. and Mrs. Smith make a travel plan, they want to go to a city in California or Florida, and where neither of them has ever been.",
      "Cities in California that they are interested in are San Francisco, Los Angeles, and San Diego.",
      "Cities in Florida that they are interested in are Orlando and Miami.",
      "Mr. Smith has been to two cities in California.",
      "Mrs. Smith has been to one city in Florida."
    ],
    "question": "They have at least two candidate cities in California to visit.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nTravelPlan(x) ::: x makes a travel plan.\nGoTo(x, y) ::: x wants to go to city y.\nCalifornia(x) ::: x is a city in California.\nFlorida(x) ::: x is a city in Florida.\nBeenTo(x, y) ::: x has been to city y.\nInterestedIn(x, y) ::: x is interested in city y.\nCandidateCity(x) ::: x is a candidate city to visit.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nTravelPlan(mrSmith) ∧ TravelPlan(mrsSmith) ∧ GoTo(mrSmith, California) ∧ GoTo(mrsSmith, Florida) ∧ ¬(BeenTo(mrSmith, California) ∨ BeenTo(mrsSmith, Florida)) ::: Mr. and Mrs. Smith make a travel plan, they want to go to a city in California or Florida, and where neither of them has ever been.\nInterestedIn(mrSmith, SanFrancisco) ∧ InterestedIn(mrSmith, LosAngeles) ∧ InterestedIn(mrSmith, SanDiego) ∧ InterestedIn(mrsSmith, Orlando) ∧ InterestedIn(mrsSmith, Miami) ::: Cities in California that they are interested in are San Francisco, Los Angeles, and San Diego. Cities in Florida that they are interested in are Orlando and Miami.\nBeenTo(mrSmith, SanFrancisco) ∧ BeenTo(mrSmith, LosAngeles) ∧ ¬BeenTo(mrSmith, SanDiego) ::: Mr. Smith has been to two cities in California.\nBeenTo(mrsSmith, Orlando) ∧ ¬BeenTo(mrsSmith, Miami) ::: Mrs. Smith has been to one city in Florida.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n∃x ∃y (CandidateCity(x) ∧ CandidateCity(y) ∧ California(x) ∧ California(y) ∧ x ≠ y) ::: They have at least two candidate cities in California to visit.\n\"\"\""
    ]
  },
  {
    "id": 1429,
    "context": [
      "Everything is either big or small.",
      "All big things are heavy. ",
      "All small things are light. ",
      "All heavy things are still.",
      "All light things are unstable.",
      "All unstable things are changing.",
      "All unstable things are kinetic. ",
      "A bird is not both heavy and still."
    ],
    "question": "A bird is still.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nBig(x) ::: x is big.\nSmall(x) ::: x is small.\nHeavy(x) ::: x is heavy.\nLight(x) ::: x is light.\nStill(x) ::: x is still.\nUnstable(x) ::: x is unstable.\nChanging(x) ::: x is changing.\nKinetic(x) ::: x is kinetic.\nBird(x) ::: x is a bird.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Big(x) ∨ Small(x)) ::: Everything is either big or small.\n∀x (Big(x) → Heavy(x)) ::: All big things are heavy.\n∀x (Small(x) → Light(x)) ::: All small things are light.\n∀x (Heavy(x) → Still(x)) ::: All heavy things are still.\n∀x (Light(x) → Unstable(x)) ::: All light things are unstable.\n∀x (Unstable(x) → Changing(x)) ::: All unstable things are changing.\n∀x (Unstable(x) → Kinetic(x)) ::: All unstable things are kinetic.\n¬(Heavy(bird) ∧ Still(bird)) ::: A bird is not both heavy and still.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nStill(bird) ::: A bird is still.\n\"\"\""
    ]
  },
  {
    "id": 1430,
    "context": [
      "Everything is either big or small.",
      "All big things are heavy. ",
      "All small things are light. ",
      "All heavy things are still.",
      "All light things are unstable.",
      "All unstable things are changing.",
      "All unstable things are kinetic. ",
      "A bird is not both heavy and still."
    ],
    "question": "A bird is not still.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nBig(x) ::: x is big.\nSmall(x) ::: x is small.\nHeavy(x) ::: x is heavy.\nLight(x) ::: x is light.\nStill(x) ::: x is still.\nUnstable(x) ::: x is unstable.\nChanging(x) ::: x is changing.\nKinetic(x) ::: x is kinetic.\nBird(x) ::: x is a bird.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Big(x) ∨ Small(x)) ::: Everything is either big or small.\n∀x (Big(x) → Heavy(x)) ::: All big things are heavy.\n∀x (Small(x) → Light(x)) ::: All small things are light.\n∀x (Heavy(x) → Still(x)) ::: All heavy things are still.\n∀x (Light(x) → Unstable(x)) ::: All light things are unstable.\n∀x (Unstable(x) → Changing(x)) ::: All unstable things are changing.\n∀x (Unstable(x) → Kinetic(x)) ::: All unstable things are kinetic.\n¬(Heavy(bird) ∧ Still(bird)) ::: A bird is not both heavy and still.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬Still(bird) ::: A bird is not still.\n\"\"\""
    ]
  },
  {
    "id": 1431,
    "context": [
      "Everything is either big or small.",
      "All big things are heavy. ",
      "All small things are light. ",
      "All heavy things are still.",
      "All light things are unstable.",
      "All unstable things are changing.",
      "All unstable things are kinetic. ",
      "A bird is not both heavy and still."
    ],
    "question": "A bird is kinetic and changing.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nBig(x) ::: x is big.\nSmall(x) ::: x is small.\nHeavy(x) ::: x is heavy.\nLight(x) ::: x is light.\nStill(x) ::: x is still.\nUnstable(x) ::: x is unstable.\nChanging(x) ::: x is changing.\nKinetic(x) ::: x is kinetic.\nBird(x) ::: x is a bird.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Big(x) ∨ Small(x)) ::: Everything is either big or small.\n∀x (Big(x) → Heavy(x)) ::: All big things are heavy.\n∀x (Small(x) → Light(x)) ::: All small things are light.\n∀x (Heavy(x) → Still(x)) ::: All heavy things are still.\n∀x (Light(x) → Unstable(x)) ::: All light things are unstable.\n∀x (Unstable(x) → Changing(x)) ::: All unstable things are changing.\n∀x (Unstable(x) → Kinetic(x)) ::: All unstable things are kinetic.\n¬(Heavy(bird) ∧ Still(bird)) ::: A bird is not both heavy and still.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nKinetic(bird) ∧ Changing(bird) ::: A bird is kinetic and changing.\n\"\"\""
    ]
  },
  {
    "id": 1432,
    "context": [
      "Everything is either big or small.",
      "All big things are heavy. ",
      "All small things are light. ",
      "All heavy things are still.",
      "All light things are unstable.",
      "All unstable things are changing.",
      "All unstable things are kinetic. ",
      "A bird is not both heavy and still."
    ],
    "question": "A bird is kinetic or changing.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nBig(x) ::: x is big.\nSmall(x) ::: x is small.\nHeavy(x) ::: x is heavy.\nLight(x) ::: x is light.\nStill(x) ::: x is still.\nUnstable(x) ::: x is unstable.\nChanging(x) ::: x is changing.\nKinetic(x) ::: x is kinetic.\nBird(x) ::: x is a bird.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Big(x) ∨ Small(x)) ::: Everything is either big or small.\n∀x (Big(x) → Heavy(x)) ::: All big things are heavy.\n∀x (Small(x) → Light(x)) ::: All small things are light.\n∀x (Heavy(x) → Still(x)) ::: All heavy things are still.\n∀x (Light(x) → Unstable(x)) ::: All light things are unstable.\n∀x (Unstable(x) → Changing(x)) ::: All unstable things are changing.\n∀x (Unstable(x) → Kinetic(x)) ::: All unstable things are kinetic.\n¬(Heavy(bird) ∧ Still(bird)) ::: A bird is not both heavy and still.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nKinetic(bird) ∨ Changing(bird) ::: A bird is kinetic or changing.\n\"\"\""
    ]
  },
  {
    "id": 1433,
    "context": [
      "Everything is either big or small.",
      "All big things are heavy. ",
      "All small things are light. ",
      "All heavy things are still.",
      "All light things are unstable.",
      "All unstable things are changing.",
      "All unstable things are kinetic. ",
      "A bird is not both heavy and still."
    ],
    "question": "A bird is either kinetic or changing.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nBig(x) ::: x is big.\nSmall(x) ::: x is small.\nHeavy(x) ::: x is heavy.\nLight(x) ::: x is light.\nStill(x) ::: x is still.\nUnstable(x) ::: x is unstable.\nChanging(x) ::: x is changing.\nKinetic(x) ::: x is kinetic.\nBird(x) ::: x is a bird.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Big(x) ∨ Small(x)) ::: Everything is either big or small.\n∀x (Big(x) → Heavy(x)) ::: All big things are heavy.\n∀x (Small(x) → Light(x)) ::: All small things are light.\n∀x (Heavy(x) → Still(x)) ::: All heavy things are still.\n∀x (Light(x) → Unstable(x)) ::: All light things are unstable.\n∀x (Unstable(x) → Changing(x)) ::: All unstable things are changing.\n∀x (Unstable(x) → Kinetic(x)) ::: All unstable things are kinetic.\n¬(Heavy(bird) ∧ Still(bird)) ::: A bird is not both heavy and still.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nKinetic(bird) ∨ Changing(bird) ::: A bird is either kinetic or changing.\n\"\"\""
    ]
  },
  {
    "id": 1434,
    "context": [
      "Everything is either big or small.",
      "All big things are heavy. ",
      "All small things are light. ",
      "All heavy things are still.",
      "All light things are unstable.",
      "All unstable things are changing.",
      "All unstable things are kinetic. ",
      "A bird is not both heavy and still."
    ],
    "question": "If a bird is small or still, then the bird is either kinetic or changing.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nBig(x) ::: x is big.\nSmall(x) ::: x is small.\nHeavy(x) ::: x is heavy.\nLight(x) ::: x is light.\nStill(x) ::: x is still.\nUnstable(x) ::: x is unstable.\nChanging(x) ::: x is changing.\nKinetic(x) ::: x is kinetic.\nBird(x) ::: x is a bird.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Big(x) ∨ Small(x)) ::: Everything is either big or small.\n∀x (Big(x) → Heavy(x)) ::: All big things are heavy.\n∀x (Small(x) → Light(x)) ::: All small things are light.\n∀x (Heavy(x) → Still(x)) ::: All heavy things are still.\n∀x (Light(x) → Unstable(x)) ::: All light things are unstable.\n∀x (Unstable(x) → Changing(x)) ::: All unstable things are changing.\n∀x (Unstable(x) → Kinetic(x)) ::: All unstable things are kinetic.\n¬(Heavy(bird) ∧ Still(bird)) ::: A bird is not both heavy and still.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n(Small(bird) ∨ Still(bird)) → (Kinetic(bird) ∨ Changing(bird)) ::: If a bird is small or still, then the bird is either kinetic or changing.\n\"\"\""
    ]
  },
  {
    "id": 288,
    "context": [
      "DI Ray is a police procedural television series.",
      "DI Ray was created and written by Maya Sondhi.",
      "DI Ray was produced by Jed Mercurio.",
      "Maya Sondhi and Jed Mercurio are both British."
    ],
    "question": "DI Ray was created by a Brit.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nSeries(x) ::: x is a television series.\nCreated(x, y) ::: x was created by y.\nWritten(x, y) ::: x was written by y.\nProduced(x, y) ::: x was produced by y.\nBritish(x) ::: x is British.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nSeries(diRay) ∧ Created(diRay, mayaSondhi) ∧ Written(diRay, mayaSondhi) ∧ Produced(diRay, jedMercurio) ::: DI Ray is a police procedural television series created and written by Maya Sondhi and produced by Jed Mercurio.\nBritish(mayaSondhi) ∧ British(jedMercurio) ::: Maya Sondhi and Jed Mercurio are both British.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n∃x (Created(diRay, x) ∧ British(x)) ::: DI Ray was created by a Brit.\n\"\"\""
    ]
  },
  {
    "id": 289,
    "context": [
      "DI Ray is a police procedural television series.",
      "DI Ray was created and written by Maya Sondhi.",
      "DI Ray was produced by Jed Mercurio.",
      "Maya Sondhi and Jed Mercurio are both British."
    ],
    "question": "Some Brit produced a television series.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nSeries(x) ::: x is a television series.\nCreated(x, y) ::: x was created by y.\nWritten(x, y) ::: x was written by y.\nProduced(x, y) ::: x was produced by y.\nBritish(x) ::: x is British.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nSeries(diRay) ::: DI Ray is a police procedural television series.\nCreated(diRay, mayaSondhi) ::: DI Ray was created and written by Maya Sondhi.\nProduced(diRay, jedMercurio) ::: DI Ray was produced by Jed Mercurio.\nBritish(mayaSondhi) ∧ British(jedMercurio) ::: Maya Sondhi and Jed Mercurio are both British.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n∃x (British(x) ∧ ∃y (Produced(y, x) ∧ Series(y))) ::: Some Brit produced a television series.\n\"\"\""
    ]
  },
  {
    "id": 1347,
    "context": [
      "All men are human.",
      "All gentlemen are men.",
      "All lawyers are gentlemen.",
      "All women are human.",
      "No sheep are human.",
      "If Mike is not both a human and a sheep, then Mike is either a man or a human."
    ],
    "question": "Mike is a woman.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nHuman(x) ::: x is a human.\nMan(x) ::: x is a man.\nGentleman(x) ::: x is a gentleman.\nLawyer(x) ::: x is a lawyer.\nWoman(x) ::: x is a woman.\nSheep(x) ::: x is a sheep.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Man(x) → Human(x)) ::: All men are human.\n∀x (Gentleman(x) → Man(x)) ::: All gentlemen are men.\n∀x (Lawyer(x) → Gentleman(x)) ::: All lawyers are gentlemen.\n∀x (Woman(x) → Human(x)) ::: All women are human.\n∀x (¬Sheep(x) → Human(x)) ::: No sheep are human.\n¬(Human(mike) ∧ Sheep(mike)) → (Man(mike) ∨ Human(mike)) ::: If Mike is not both a human and a sheep, then Mike is either a man or a human.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nWoman(mike) ::: Mike is a woman.\n\"\"\""
    ]
  },
  {
    "id": 1348,
    "context": [
      "All men are human.",
      "All gentlemen are men.",
      "All lawyers are gentlemen.",
      "All women are human.",
      "No sheep are human.",
      "If Mike is not both a human and a sheep, then Mike is either a man or a human."
    ],
    "question": "If Mike is a gentleman or a lawyer, then Mike is neither a woman nor a lawyer.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nHuman(x) ::: x is a human.\nMan(x) ::: x is a man.\nGentleman(x) ::: x is a gentleman.\nLawyer(x) ::: x is a lawyer.\nWoman(x) ::: x is a woman.\nSheep(x) ::: x is a sheep.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Man(x) → Human(x)) ::: All men are human.\n∀x (Gentleman(x) → Man(x)) ::: All gentlemen are men.\n∀x (Lawyer(x) → Gentleman(x)) ::: All lawyers are gentlemen.\n∀x (Woman(x) → Human(x)) ::: All women are human.\n∀x (¬Sheep(x) → Human(x)) ::: No sheep are human.\n¬(Human(mike) ∧ Sheep(mike)) → (Man(mike) ∨ Human(mike)) ⊕ ¬(Man(mike) ∨ Human(mike)) ::: If Mike is not both a human and a sheep, then Mike is either a man or a human.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n(Gentleman(mike) ∨ Lawyer(mike)) → ¬(Woman(mike) ∨ Lawyer(mike)) ::: If Mike is a gentleman or a lawyer, then Mike is neither a woman nor a lawyer.\n\"\"\""
    ]
  },
  {
    "id": 1349,
    "context": [
      "All men are human.",
      "All gentlemen are men.",
      "All lawyers are gentlemen.",
      "All women are human.",
      "No sheep are human.",
      "If Mike is not both a human and a sheep, then Mike is either a man or a human."
    ],
    "question": "If Mike is not both a woman and a lawyer, then Mike is a lawyer.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nHuman(x) ::: x is a human.\nMan(x) ::: x is a man.\nGentleman(x) ::: x is a gentleman.\nLawyer(x) ::: x is a lawyer.\nWoman(x) ::: x is a woman.\nSheep(x) ::: x is a sheep.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Man(x) → Human(x)) ::: All men are human.\n∀x (Gentleman(x) → Man(x)) ::: All gentlemen are men.\n∀x (Lawyer(x) → Gentleman(x)) ::: All lawyers are gentlemen.\n∀x (Woman(x) → Human(x)) ::: All women are human.\n∀x (¬Sheep(x) → Human(x)) ::: No sheep are human.\n¬(Human(mike) ∧ Sheep(mike)) → (Man(mike) ∨ Human(mike)) ::: If Mike is not both a human and a sheep, then Mike is either a man or a human.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬(Woman(mike) ∧ Lawyer(mike)) → Lawyer(mike) ::: If Mike is not both a woman and a lawyer, then Mike is a lawyer.\n\"\"\""
    ]
  },
  {
    "id": 839,
    "context": [
      "Some defenders are centerback.",
      "All defenders are soccer players.",
      "No soccer players are professional basketball players.",
      "All NBA players are professional basketball players.",
      "Stephen Curry is an NBA player."
    ],
    "question": "Stephen Curry is a centerback.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nDefender(x) ::: x is a defender.\nCenterback(x) ::: x is a centerback.\nSoccerPlayer(x) ::: x is a soccer player.\nBasketballPlayer(x) ::: x is a basketball player.\nNBAPlayer(x) ::: x is an NBA player.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∃x (Defender(x) ∧ Centerback(x)) ::: Some defenders are centerback.\n∀x (Defender(x) → SoccerPlayer(x)) ::: All defenders are soccer players.\n∀x (SoccerPlayer(x) → ¬ProfessionalBasketballPlayer(x)) ::: No soccer players are professional basketball players.\n∀x (NBAPlayer(x) → ProfessionalBasketballPlayer(x)) ::: All NBA players are professional basketball players.\nNBAPlayer(stephenCurry) ::: Stephen Curry is an NBA player.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬Centerback(stephenCurry) ::: Stephen Curry is a centerback.\n\"\"\""
    ]
  },
  {
    "id": 840,
    "context": [
      "Some defenders are centerback.",
      "All defenders are soccer players.",
      "No soccer players are professional basketball players.",
      "All NBA players are professional basketball players.",
      "Stephen Curry is an NBA player."
    ],
    "question": "Stephen Curry is not a centerback and a defender.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nDefender(x) ::: x is a defender.\nCenterback(x) ::: x is a centerback.\nSoccerPlayer(x) ::: x is a soccer player.\nBasketballPlayer(x) ::: x is a basketball player.\nNBAPlayer(x) ::: x is an NBA player.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∃x (Defender(x) ∧ Centerback(x)) ::: Some defenders are centerback.\n∀x (Defender(x) → SoccerPlayer(x)) ::: All defenders are soccer players.\n∀x (SoccerPlayer(x) → ¬BasketballPlayer(x)) ::: No soccer players are professional basketball players.\n∀x (NBAPlayer(x) → BasketballPlayer(x)) ::: All NBA players are professional basketball players.\nNBAPlayer(stephenCurry) ::: Stephen Curry is an NBA player.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬(Centerback(stephenCurry) ∧ Defender(stephenCurry)) ::: Stephen Curry is not a centerback and a defender.\n\"\"\""
    ]
  },
  {
    "id": 841,
    "context": [
      "Some defenders are centerback.",
      "All defenders are soccer players.",
      "No soccer players are professional basketball players.",
      "All NBA players are professional basketball players.",
      "Stephen Curry is an NBA player."
    ],
    "question": "If Stephen Curry is not a centerback and a defender, then Stephen Curry is neither a soccer player nor a professional basketball player.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nDefender(x) ::: x is a defender.\nCenterback(x) ::: x is a centerback.\nSoccerPlayer(x) ::: x is a soccer player.\nBasketballPlayer(x) ::: x is a basketball player.\nNBAPlayer(x) ::: x is an NBA player.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∃x (Defender(x) ∧ Centerback(x)) ::: Some defenders are centerback.\n∀x (Defender(x) → SoccerPlayer(x)) ::: All defenders are soccer players.\n∀x (SoccerPlayer(x) → ¬BasketballPlayer(x)) ::: No soccer players are professional basketball players.\n∀x (NBAPlayer(x) → BasketballPlayer(x)) ::: All NBA players are professional basketball players.\nNBAPlayer(stephenCurry) ::: Stephen Curry is an NBA player.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬(Centerback(stephenCurry) ∧ Defender(stephenCurry)) → (SoccerPlayer(stephenCurry) ∨ BasketballPlayer(stephenCurry)) ⊕ ¬(SoccerPlayer(stephenCurry) ∨ BasketballPlayer(stephenCurry)) ::: If Stephen Curry is not a centerback and a defender, then Stephen Curry is neither a soccer player nor a professional basketball player.\n\"\"\""
    ]
  },
  {
    "id": 540,
    "context": [
      "If a person doesn't have enough money to buy a product, then that person can't buy it.",
      "Monitors are products.",
      "4k monitors are more expensive than 1080 monitors and 2k monitors.",
      "John is a person.",
      "John doesn't have enough money to buy a 2k monitor."
    ],
    "question": "John can not buy the 1080 monitor.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nHasEnoughMoney(x, y) ::: x has enough money to buy product y.\nCanBuy(x, y) ::: x can buy product y.\nProduct(x) ::: x is a product.\nMonitor(x) ::: x is a monitor.\nExpensive(x, y) ::: x is more expensive than y.\nPerson(x) ::: x is a person.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n¬HasEnoughMoney(x, y) → ¬CanBuy(x, y) ::: If a person doesn't have enough money to buy a product, then that person can't buy it.\n∀x (Monitor(x) → Product(x)) ::: Monitors are products.\nExpensive(4kMonitor, 1080Monitor) ∧ Expensive(4kMonitor, 2kMonitor) ::: 4k monitors are more expensive than 1080 monitors and 2k monitors.\nPerson(john) ::: John is a person.\n¬HasEnoughMoney(john, 2kMonitor) ::: John doesn't have enough money to buy a 2k monitor.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬CanBuy(john, 1080Monitor) ::: John can not buy the 1080 monitor.\n\"\"\""
    ]
  },
  {
    "id": 541,
    "context": [
      "If a person doesn't have enough money to buy a product, then that person can't buy it.",
      "Monitors are products.",
      "4k monitors are more expensive than 1080 monitors and 2k monitors.",
      "John is a person.",
      "John doesn't have enough money to buy a 2k monitor."
    ],
    "question": "John can not buy the 2k monitor.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nHasEnoughMoney(x, y) ::: x has enough money to buy y.\nCanBuy(x, y) ::: x can buy y.\nProduct(x) ::: x is a product.\nMonitor(x) ::: x is a monitor.\nExpensive(x, y) ::: x is more expensive than y.\nPerson(x) ::: x is a person.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n¬HasEnoughMoney(x, y) → ¬CanBuy(x, y) ::: If a person doesn't have enough money to buy a product, then that person can't buy it.\nProduct(monitor) ::: Monitors are products.\nExpensive(monitor4k, monitor1080) ∧ Expensive(monitor4k, monitor2k) ::: 4k monitors are more expensive than 1080 monitors and 2k monitors.\nPerson(john) ::: John is a person.\n¬HasEnoughMoney(john, monitor2k) ::: John doesn't have enough money to buy a 2k monitor.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬CanBuy(john, monitor2k) ::: John can not buy the 2k monitor.\n\"\"\""
    ]
  },
  {
    "id": 712,
    "context": [
      "All artificial satellites are important scientific achievements.",
      "Some artificial satellites are not U.S. inventions."
    ],
    "question": "All important scientific achievements are U.S. inventions.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nArtificialSatellite(x) ::: x is an artificial satellite.\nScientificAchievement(x) ::: x is an important scientific achievement.\nUSInvention(x) ::: x is a U.S. invention.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (ArtificialSatellite(x) → ScientificAchievement(x)) ::: All artificial satellites are important scientific achievements.\n∃x (ArtificialSatellite(x) ∧ ¬USInvention(x)) ::: Some artificial satellites are not U.S. inventions.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n∀x (ScientificAchievement(x) → USInvention(x)) ::: All important scientific achievements are U.S. inventions.\n\"\"\""
    ]
  },
  {
    "id": 706,
    "context": [
      "Some cats are not pets.",
      "All cats are mammals."
    ],
    "question": "Some mammals are not pets.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nCat(x) ::: x is a cat.\nPet(x) ::: x is a pet.\nMammal(x) ::: x is a mammal.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∃x (Cat(x) ∧ ¬Pet(x)) ::: Some cats are not pets.\n∀x (Cat(x) → Mammal(x)) ::: All cats are mammals.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n∃x (Mammal(x) ∧ ¬Pet(x)) ::: Some mammals are not pets.\n\"\"\""
    ]
  },
  {
    "id": 972,
    "context": [
      "If people visit a coffee shop at least three times a week, then they are addicted to coffee or other caffeinated drinks.",
      "People either visit a coffee shop at least three times a week or order takeout at least once a day.",
      "If people make a lot of their own food at home using recipes and online guides, then they order takeout at least once a day.",
      "If people own at least one coffeemaker and one blender in their home, then they do not order takeout at least once a day.",
      "All people who lead very busy lives that include 12-hour work hours make a lot of their own food at home using recipes and online guides.",
      "Sam is either both addicted to coffee or other caffeinated drinks or leads very busy lives that include 12-hour work hours, or she is neither addicted to coffee and other caffeinated drinks nor leads very busy lives that include 12-hour work hours"
    ],
    "question": "Sam is addicted to coffee and other caffeinated drinks.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nVisit(x) ::: x visits a coffee shop at least three times a week.\nAddicted(x) ::: x is addicted to coffee or other caffeinated drinks.\nOrder(x) ::: x orders takeout at least once a day.\nMakeFood(x) ::: x makes a lot of their own food at home using recipes and online guides.\nOwn(x, y) ::: x owns y.\nBusy(x) ::: x leads very busy lives that include 12-hour work hours.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Visit(x) → Addicted(x) ∨ Addicted(x)) ::: If people visit a coffee shop at least three times a week, then they are addicted to coffee or other caffeinated drinks.\n∀x (Visit(x) ∨ Order(x)) ::: People either visit a coffee shop at least three times a week or order takeout at least once a day.\n∀x (MakeFood(x) → Order(x)) ::: If people make a lot of their own food at home using recipes and online guides, then they order takeout at least once a day.\n∀x (Own(x, coffeemaker) ∧ Own(x, blender) → ¬Order(x)) ::: If people own at least one coffeemaker and one blender in their home, then they do not order takeout at least once a day.\n∀x (Busy(x) → MakeFood(x)) ::: All people who lead very busy lives that include 12-hour work hours make a lot of their own food at home using recipes and online guides.\n(Addicted(sam) ∨ Busy(sam)) ⊕ ¬(Addicted(sam) ∧ Busy(sam)) ::: Sam is either both addicted to coffee or other caffeinated drinks or leads very busy lives that include 12-hour work hours, or she is neither addicted to coffee and other caffeinated drinks nor leads very busy lives that include 12-hour work hours.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nAddicted(sam) ::: Sam is addicted to coffee and other caffeinated drinks.\n\"\"\""
    ]
  },
  {
    "id": 973,
    "context": [
      "If people visit a coffee shop at least three times a week, then they are addicted to coffee or other caffeinated drinks.",
      "People either visit a coffee shop at least three times a week or order takeout at least once a day.",
      "If people make a lot of their own food at home using recipes and online guides, then they order takeout at least once a day.",
      "If people own at least one coffeemaker and one blender in their home, then they do not order takeout at least once a day.",
      "All people who lead very busy lives that include 12-hour work hours make a lot of their own food at home using recipes and online guides.",
      "Sam is either both addicted to coffee or other caffeinated drinks or leads very busy lives that include 12-hour work hours, or she is neither addicted to coffee and other caffeinated drinks nor leads very busy lives that include 12-hour work hours"
    ],
    "question": "Sam owns at least one coffeemaker and one blender in her home.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nVisit(x) ::: x visits a coffee shop at least three times a week.\nAddicted(x) ::: x is addicted to coffee or other caffeinated drinks.\nOrderTakeout(x) ::: x orders takeout at least once a day.\nMakeFood(x) ::: x makes a lot of their own food at home using recipes and online guides.\nOwn(x, y) ::: x owns y.\nBusy(x) ::: x leads very busy lives that include 12-hour work hours.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Visit(x) → Addicted(x) ∨ Addicted(y)) ::: If people visit a coffee shop at least three times a week, then they are addicted to coffee or other caffeinated drinks.\n∀x (Visit(x) ∨ OrderTakeout(x)) ::: People either visit a coffee shop at least three times a week or order takeout at least once a day.\n∀x (MakeFood(x) → OrderTakeout(x)) ::: If people make a lot of their own food at home using recipes and online guides, then they order takeout at least once a day.\n∀x (Own(x, coffeemaker) ∧ Own(x, blender) → ¬OrderTakeout(x)) ::: If people own at least one coffeemaker and one blender in their home, then they do not order takeout at least once a day.\n∀x (Busy(x) → MakeFood(x)) ::: All people who lead very busy lives that include 12-hour work hours make a lot of their own food at home using recipes and online guides.\n(Addicted(sam) ∨ Busy(sam)) ⊕ ¬(Addicted(sam) ∧ Busy(sam)) ::: Sam is either both addicted to coffee or other caffeinated drinks or leads very busy lives that include 12-hour work hours, or she is neither addicted to coffee and other caffeinated drinks nor leads very busy lives that include 12-hour work hours.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nOwn(sam, coffeemaker) ∧ Own(sam, blender) ::: Sam owns at least one coffeemaker and one blender in her home.\n\"\"\""
    ]
  },
  {
    "id": 974,
    "context": [
      "If people visit a coffee shop at least three times a week, then they are addicted to coffee or other caffeinated drinks.",
      "People either visit a coffee shop at least three times a week or order takeout at least once a day.",
      "If people make a lot of their own food at home using recipes and online guides, then they order takeout at least once a day.",
      "If people own at least one coffeemaker and one blender in their home, then they do not order takeout at least once a day.",
      "All people who lead very busy lives that include 12-hour work hours make a lot of their own food at home using recipes and online guides.",
      "Sam is either both addicted to coffee or other caffeinated drinks or leads very busy lives that include 12-hour work hours, or she is neither addicted to coffee and other caffeinated drinks nor leads very busy lives that include 12-hour work hours"
    ],
    "question": "Sam either owns at least one coffeemaker and one blender in her home or orders takeout at least once a day.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nVisit(x) ::: x visits a coffee shop at least three times a week.\nAddicted(x) ::: x is addicted to coffee or other caffeinated drinks.\nOrder(x) ::: x orders takeout at least once a day.\nMakeFood(x) ::: x makes a lot of their own food at home using recipes and online guides.\nOwn(x, y) ::: x owns y.\nBusy(x) ::: x leads very busy lives that include 12-hour work hours.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Visit(x) → (Addicted(x) ∨ Order(x))) ::: If people visit a coffee shop at least three times a week, then they are addicted to coffee or other caffeinated drinks.\n∀x (Visit(x) ∨ Order(x)) ::: People either visit a coffee shop at least three times a week or order takeout at least once a day.\n∀x (MakeFood(x) → Order(x)) ::: If people make a lot of their own food at home using recipes and online guides, then they order takeout at least once a day.\n∀x ((Own(x, coffeemaker) ∧ Own(x, blender)) → ¬Order(x)) ::: If people own at least one coffeemaker and one blender in their home, then they do not order takeout at least once a day.\n∀x (Busy(x) → MakeFood(x)) ::: All people who lead very busy lives that include 12-hour work hours make a lot of their own food at home using recipes and online guides.\n(Addicted(sam) ∨ Busy(sam)) ⊕ ¬(Addicted(sam) ∧ Busy(sam)) ::: Sam is either both addicted to coffee or other caffeinated drinks or leads very busy lives that include 12-hour work hours, or she is neither addicted to coffee and other caffeinated drinks nor leads very busy lives that include 12-hour work hours.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nOwn(sam, coffeemaker) ∧ Own(sam, blender) ∨ Order(sam) ::: Sam either owns at least one coffeemaker and one blender in her home or orders takeout at least once a day.\n\"\"\""
    ]
  },
  {
    "id": 842,
    "context": [
      "No professional basketball players are soccer players.",
      "All NBA players are professional basketball players.",
      "All defenders are soccer players.",
      "All centerbacks are defenders.",
      "Roger Federer is not an NBA player or a defender."
    ],
    "question": "Roger Federer is a centerback.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nBasketballPlayer(x) ::: x is a professional basketball player.\nSoccerPlayer(x) ::: x is a soccer player.\nNBAPlayer(x) ::: x is an NBA player.\nDefender(x) ::: x is a defender.\nCenterback(x) ::: x is a centerback.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (BasketballPlayer(x) → ¬SoccerPlayer(x)) ::: No professional basketball players are soccer players.\n∀x (NBAPlayer(x) → BasketballPlayer(x)) ::: All NBA players are professional basketball players.\n∀x (Defender(x) → SoccerPlayer(x)) ::: All defenders are soccer players.\n∀x (Centerback(x) → Defender(x)) ::: All centerbacks are defenders.\n¬(NBAPlayer(roger) ∨ Defender(roger)) ::: Roger Federer is not an NBA player or a defender.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nCenterback(roger) ::: Roger Federer is a centerback.\n\"\"\""
    ]
  },
  {
    "id": 843,
    "context": [
      "No professional basketball players are soccer players.",
      "All NBA players are professional basketball players.",
      "All defenders are soccer players.",
      "All centerbacks are defenders.",
      "Roger Federer is not an NBA player or a defender."
    ],
    "question": "Roger Federer is not a centerback.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nBasketballPlayer(x) ::: x is a professional basketball player.\nSoccerPlayer(x) ::: x is a soccer player.\nNBAPlayer(x) ::: x is an NBA player.\nDefender(x) ::: x is a defender.\nCenterback(x) ::: x is a centerback.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (BasketballPlayer(x) → ¬SoccerPlayer(x)) ::: No professional basketball players are soccer players.\n∀x (NBAPlayer(x) → BasketballPlayer(x)) ::: All NBA players are professional basketball players.\n∀x (Defender(x) → SoccerPlayer(x)) ::: All defenders are soccer players.\n∀x (Centerback(x) → Defender(x)) ::: All centerbacks are defenders.\n¬(NBAPlayer(roger) ∨ Defender(roger)) ::: Roger Federer is not an NBA player or a defender.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬Centerback(roger) ::: Roger Federer is not a centerback.\n\"\"\""
    ]
  },
  {
    "id": 844,
    "context": [
      "No professional basketball players are soccer players.",
      "All NBA players are professional basketball players.",
      "All defenders are soccer players.",
      "All centerbacks are defenders.",
      "Roger Federer is not an NBA player or a defender."
    ],
    "question": "Roger Federer is a soccer player.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nBasketballPlayer(x) ::: x is a professional basketball player.\nSoccerPlayer(x) ::: x is a soccer player.\nNBAPlayer(x) ::: x is an NBA player.\nDefender(x) ::: x is a defender.\nCenterback(x) ::: x is a centerback.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n¬∃x (BasketballPlayer(x) ∧ SoccerPlayer(x)) ::: No professional basketball players are soccer players.\n∀x (NBAPlayer(x) → BasketballPlayer(x)) ::: All NBA players are professional basketball players.\n∀x (Defender(x) → SoccerPlayer(x)) ::: All defenders are soccer players.\n∀x (Centerback(x) → Defender(x)) ::: All centerbacks are defenders.\n¬(NBAPlayer(roger) ∨ Defender(roger)) ::: Roger Federer is not an NBA player or a defender.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nSoccerPlayer(roger) ::: Roger Federer is a soccer player.\n\"\"\""
    ]
  },
  {
    "id": 1279,
    "context": [
      "Some teachers working at a pool are not nice.",
      "All teachers working at pools are pool managers.",
      "All pool managers are lifeguards.",
      "If someone is a lifeguard, then they work at a pool.",
      "Mary does not work at a pool."
    ],
    "question": "Mary is nice.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nTeacher(x) ::: x is a teacher.\nWorksAtPool(x) ::: x works at a pool.\nNice(x) ::: x is nice.\nPoolManager(x) ::: x is a pool manager.\nLifeguard(x) ::: x is a lifeguard.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∃x (Teacher(x) ∧ WorksAtPool(x) ∧ ¬Nice(x)) ::: Some teachers working at a pool are not nice.\n∀x (Teacher(x) ∧ WorksAtPool(x) → PoolManager(x)) ::: All teachers working at pools are pool managers.\n∀x (PoolManager(x) → Lifeguard(x)) ::: All pool managers are lifeguards.\n∀x (Lifeguard(x) → WorksAtPool(x)) ::: If someone is a lifeguard, then they work at a pool.\n¬WorksAtPool(mary) ::: Mary does not work at a pool.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nNice(mary) ::: Mary is nice.\n\"\"\""
    ]
  },
  {
    "id": 1280,
    "context": [
      "Some teachers working at a pool are not nice.",
      "All teachers working at pools are pool managers.",
      "All pool managers are lifeguards.",
      "If someone is a lifeguard, then they work at a pool.",
      "Mary does not work at a pool."
    ],
    "question": "Mary is not nice and is a teacher working at a pool.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nNice(x) ::: x is nice.\nTeacher(x) ::: x is a teacher.\nPoolWorker(x) ::: x works at a pool.\nPoolManager(x) ::: x is a pool manager.\nLifeguard(x) ::: x is a lifeguard.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∃x (Teacher(x) ∧ PoolWorker(x) ∧ ¬Nice(x)) ::: Some teachers working at a pool are not nice.\n∀x (Teacher(x) ∧ PoolWorker(x) → PoolManager(x)) ::: All teachers working at pools are pool managers.\n∀x (PoolManager(x) → Lifeguard(x)) ::: All pool managers are lifeguards.\n∀x (Lifeguard(x) → PoolWorker(x)) ::: If someone is a lifeguard, then they work at a pool.\n¬PoolWorker(mary) ::: Mary does not work at a pool.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬Nice(mary) ∧ Teacher(mary) ∧ PoolWorker(mary) ::: Mary is not nice and is a teacher working at a pool.\n\"\"\""
    ]
  },
  {
    "id": 1281,
    "context": [
      "Some teachers working at a pool are not nice.",
      "All teachers working at pools are pool managers.",
      "All pool managers are lifeguards.",
      "If someone is a lifeguard, then they work at a pool.",
      "Mary does not work at a pool."
    ],
    "question": "Mary is nice and is a teacher working at a pool.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nTeacher(x) ::: x is a teacher.\nPoolWorker(x) ::: x works at a pool.\nNice(x) ::: x is nice.\nPoolManager(x) ::: x is a pool manager.\nLifeguard(x) ::: x is a lifeguard.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∃x (Teacher(x) ∧ PoolWorker(x) ∧ ¬Nice(x)) ::: Some teachers working at a pool are not nice.\n∀x (Teacher(x) ∧ PoolWorker(x) → PoolManager(x)) ::: All teachers working at pools are pool managers.\n∀x (PoolManager(x) → Lifeguard(x)) ::: All pool managers are lifeguards.\n∀x (Lifeguard(x) → PoolWorker(x)) ::: If someone is a lifeguard, then they work at a pool.\n¬PoolWorker(mary) ::: Mary does not work at a pool.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nNice(mary) ∧ Teacher(mary) ∧ PoolWorker(mary) ::: Mary is nice and is a teacher working at a pool.\n\"\"\""
    ]
  },
  {
    "id": 751,
    "context": [
      "Not all art pieces require talent.",
      "Everything that requires talent requires practice."
    ],
    "question": "There exist art pieces that do not require practice.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nRequireTalent(x) ::: x requires talent.\nRequirePractice(x) ::: x requires practice.\nArtPiece(x) ::: x is an art piece.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n¬∀x (ArtPiece(x) → RequireTalent(x)) ::: Not all art pieces require talent.\n∀x (RequireTalent(x) → RequirePractice(x)) ::: Everything that requires talent requires practice.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n∃x (ArtPiece(x) ∧ ¬RequirePractice(x)) ::: There exist art pieces that do not require practice.\n\"\"\""
    ]
  },
  {
    "id": 268,
    "context": [
      "Bernarda Bryson Shahn was a painter and lithographer.",
      "Bernarda Bryson Shahn was born in Athens, Ohio. ",
      "Bernarda Bryson Shahn was married to Ben Shahn.",
      "People born in Athens, Ohio are Americans."
    ],
    "question": "Bernarda Bryson Shahn was born in Greece.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nPainter(x) ::: x is a painter.\nLithographer(x) ::: x is a lithographer.\nBornIn(x, y) ::: x was born in y.\nMarriedTo(x, y) ::: x is married to y.\nPeople(x) ::: x is a person.\nAmerican(x) ::: x is an American.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nPainter(bernardaBrysonShahn) ∧ Lithographer(bernardaBrysonShahn) ::: Bernarda Bryson Shahn was a painter and lithographer.\nBornIn(bernardaBrysonShahn, athensOhio) ::: Bernarda Bryson Shahn was born in Athens, Ohio.\nMarriedTo(bernardaBrysonShahn, benShahn) ::: Bernarda Bryson Shahn was married to Ben Shahn.\n∀x (BornIn(x, athensOhio) → American(x)) ::: People born in Athens, Ohio are Americans.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬BornIn(bernardaBrysonShahn, greece) ::: Bernarda Bryson Shahn was born in Greece.\n\"\"\""
    ]
  },
  {
    "id": 269,
    "context": [
      "Bernarda Bryson Shahn was a painter and lithographer.",
      "Bernarda Bryson Shahn was born in Athens, Ohio. ",
      "Bernarda Bryson Shahn was married to Ben Shahn.",
      "People born in Athens, Ohio are Americans."
    ],
    "question": "Bernarda Bryson Shahn was American.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nPainter(x) ::: x is a painter.\nLithographer(x) ::: x is a lithographer.\nBornIn(x, y) ::: x was born in y.\nMarriedTo(x, y) ::: x is married to y.\nAmerican(x) ::: x is American.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nPainter(bernarda) ∧ Lithographer(bernarda) ::: Bernarda Bryson Shahn was a painter and lithographer.\nBornIn(bernarda, athensOhio) ::: Bernarda Bryson Shahn was born in Athens, Ohio.\nMarriedTo(bernarda, ben) ::: Bernarda Bryson Shahn was married to Ben Shahn.\n∀x (BornIn(x, athensOhio) → American(x)) ::: People born in Athens, Ohio are Americans.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nAmerican(bernarda) ::: Bernarda Bryson Shahn was American.\n\"\"\""
    ]
  },
  {
    "id": 270,
    "context": [
      "Bernarda Bryson Shahn was a painter and lithographer.",
      "Bernarda Bryson Shahn was born in Athens, Ohio. ",
      "Bernarda Bryson Shahn was married to Ben Shahn.",
      "People born in Athens, Ohio are Americans."
    ],
    "question": "Bernarda Bryson Shahn had been divorced once.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nPainter(x) ::: x is a painter.\nLithographer(x) ::: x is a lithographer.\nBornIn(x, y) ::: x was born in y.\nMarriedTo(x, y) ::: x is married to y.\nAmerican(x) ::: x is an American.\nDivorced(x) ::: x has been divorced.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nPainter(bernardaBrysonShahn) ∧ Lithographer(bernardaBrysonShahn) ::: Bernarda Bryson Shahn was a painter and lithographer.\nBornIn(bernardaBrysonShahn, athensOhio) ::: Bernarda Bryson Shahn was born in Athens, Ohio.\nMarriedTo(bernardaBrysonShahn, benShahn) ::: Bernarda Bryson Shahn was married to Ben Shahn.\n∀x (BornIn(x, athensOhio) → American(x)) ::: People born in Athens, Ohio are Americans.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n∃x (Divorced(bernardaBrysonShahn)) ::: Bernarda Bryson Shahn had been divorced once.\n\"\"\""
    ]
  },
  {
    "id": 987,
    "context": [
      "If people upgrade to the newest iPhone model every year, then they are not saving money for a down payment on a new house.",
      "If people enjoy reading about tech specs and keeping up to date on the latest technology, then they upgrade to the newest iPhone model every year.",
      "People either are saving money for a down payment on a new house or they live in apartments in big metropolitan cities.",
      "If people live with at least one roommate then they do not own at least one pet.",
      "All people who own at least one pet live with at least one roommate.",
      "If Emma does not both own at least one pet and live in apartments in big metropolitan cities, then Emma either owns at least one pet and lives in an apartment in big metropolitan cities, or she neither owns a pet nor lives in an apartment in big metropolitan cities. "
    ],
    "question": "Emma lives with at least one roommate.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nUpgrade(x) ::: x upgrades to the newest iPhone model every year.\nSave(x) ::: x is saving money for a down payment on a new house.\nEnjoy(x) ::: x enjoys reading about tech specs and keeping up to date on the latest technology.\nLiveIn(x, y) ::: x lives in y.\nApartment(x) ::: x lives in an apartment.\nCity(x) ::: x lives in a big metropolitan city.\nRoommate(x) ::: x lives with at least one roommate.\nOwn(x, y) ::: x owns at least one y.\nPet(x) ::: x owns at least one pet.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nUpgrade(x) → ¬Save(x) ::: If people upgrade to the newest iPhone model every year, then they are not saving money for a down payment on a new house.\nEnjoy(x) → Upgrade(x) ::: If people enjoy reading about tech specs and keeping up to date on the latest technology, then they upgrade to the newest iPhone model every year.\nSave(x) ∨ (LiveIn(x, Apartment) ∧ City(x)) ::: People either are saving money for a down payment on a new house or they live in apartments in big metropolitan cities.\nRoommate(x) → ¬Own(x, Pet) ::: If people live with at least one roommate then they do not own at least one pet.\n∀x (Own(x, Pet) → ∃y (Roommate(y))) ::: All people who own at least one pet live with at least one roommate.\n¬(Own(emma, Pet) ∧ LiveIn(emma, Apartment) ∧ City(emma)) → (Own(emma, Pet) ∧ LiveIn(emma, Apartment) ∧ City(emma)) ⊕ ¬(Own(emma, Pet) ∨ LiveIn(emma, Apartment) ∨ City(emma)) ::: If Emma does not both own at least one pet and live in apartments in big metropolitan cities, then Emma either owns at least one pet and lives in an apartment in big metropolitan cities, or she neither owns a pet nor lives in an apartment in big metropolitan cities.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nRoommate(emma) ::: Emma lives with at least one roommate.\n\"\"\""
    ]
  },
  {
    "id": 988,
    "context": [
      "If people upgrade to the newest iPhone model every year, then they are not saving money for a down payment on a new house.",
      "If people enjoy reading about tech specs and keeping up to date on the latest technology, then they upgrade to the newest iPhone model every year.",
      "People either are saving money for a down payment on a new house or they live in apartments in big metropolitan cities.",
      "If people live with at least one roommate then they do not own at least one pet.",
      "All people who own at least one pet live with at least one roommate.",
      "If Emma does not both own at least one pet and live in apartments in big metropolitan cities, then Emma either owns at least one pet and lives in an apartment in big metropolitan cities, or she neither owns a pet nor lives in an apartment in big metropolitan cities. "
    ],
    "question": "Emma enjoys reading about tech specs and keeping up to date on the latest technology.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nUpgrade(x) ::: x upgrades to the newest iPhone model every year.\nSave(x) ::: x is saving money for a down payment on a new house.\nEnjoy(x) ::: x enjoys reading about tech specs and keeping up to date on the latest technology.\nLiveIn(x, y) ::: x lives in y.\nApartment(x) ::: x lives in an apartment.\nCity(x) ::: x lives in a big metropolitan city.\nRoommate(x) ::: x lives with at least one roommate.\nOwn(x, y) ::: x owns at least one y.\nPet(x) ::: x owns at least one pet.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nUpgrade(x) → ¬Save(x) ::: If people upgrade to the newest iPhone model every year, then they are not saving money for a down payment on a new house.\nEnjoy(x) → Upgrade(x) ::: If people enjoy reading about tech specs and keeping up to date on the latest technology, then they upgrade to the newest iPhone model every year.\nSave(x) ∨ (LiveIn(x, Apartment) ∧ City(x)) ::: People either are saving money for a down payment on a new house or they live in apartments in big metropolitan cities.\nRoommate(x) → ¬Own(x, Pet) ::: If people live with at least one roommate then they do not own at least one pet.\n∀x (Own(x, Pet) → Roommate(x)) ::: All people who own at least one pet live with at least one roommate.\n¬(Own(emma, Pet) ∧ LiveIn(emma, Apartment) ∧ City(emma)) → (Own(emma, Pet) ∧ LiveIn(emma, Apartment) ∧ City(emma)) ⊕ ¬(Own(emma, Pet) ∨ LiveIn(emma, Apartment) ∨ City(emma)) ::: If Emma does not both own at least one pet and live in apartments in big metropolitan cities, then Emma either owns at least one pet and lives in an apartment in big metropolitan cities, or she neither owns a pet nor lives in an apartment in big metropolitan cities.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nEnjoy(emma) ::: Emma enjoys reading about tech specs and keeping up to date on the latest technology.\n\"\"\""
    ]
  },
  {
    "id": 1303,
    "context": [
      "If you are on the payroll, then you are being paid by the school.",
      "If someone has a job at a school, then they are on the payroll.",
      "All faculty members have a job at a school.",
      "One can either be a faculty member or a teacher.",
      "Every teacher has students.",
      "If Nancy is a teacher, then they are on the payroll.",
      "If Nancy is not a teacher, then they are not paid by the school."
    ],
    "question": "Nancy is a faculty member.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nOnPayroll(x) ::: x is on the payroll.\nPaidBySchool(x) ::: x is being paid by the school.\nHasJob(x, y) ::: x has a job at y.\nFacultyMember(x) ::: x is a faculty member.\nTeacher(x) ::: x is a teacher.\nHasStudents(x) ::: x has students.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nOnPayroll(x) → PaidBySchool(x) ::: If you are on the payroll, then you are being paid by the school.\nHasJob(x, school) → OnPayroll(x) ::: If someone has a job at a school, then they are on the payroll.\n∀x (FacultyMember(x) → HasJob(x, school)) ::: All faculty members have a job at a school.\nFacultyMember(x) ⊕ Teacher(x) ::: One can either be a faculty member or a teacher.\n∀x (Teacher(x) → HasStudents(x)) ::: Every teacher has students.\nTeacher(nancy) → OnPayroll(nancy) ::: If Nancy is a teacher, then they are on the payroll.\n¬Teacher(nancy) → ¬PaidBySchool(nancy) ::: If Nancy is not a teacher, then they are not paid by the school.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nFacultyMember(nancy) ::: Nancy is a faculty member.\n\"\"\""
    ]
  },
  {
    "id": 1304,
    "context": [
      "If you are on the payroll, then you are being paid by the school.",
      "If someone has a job at a school, then they are on the payroll.",
      "All faculty members have a job at a school.",
      "One can either be a faculty member or a teacher.",
      "Every teacher has students.",
      "If Nancy is a teacher, then they are on the payroll.",
      "If Nancy is not a teacher, then they are not paid by the school."
    ],
    "question": "Nancy is paid by the school and has students.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nOnPayroll(x) ::: x is on the payroll.\nPaidBySchool(x) ::: x is being paid by the school.\nHasJob(x, y) ::: x has a job at y.\nFacultyMember(x) ::: x is a faculty member.\nTeacher(x) ::: x is a teacher.\nHasStudents(x) ::: x has students.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nOnPayroll(x) → PaidBySchool(x) ::: If you are on the payroll, then you are being paid by the school.\nHasJob(x, school) → OnPayroll(x) ::: If someone has a job at a school, then they are on the payroll.\n∀x (FacultyMember(x) → HasJob(x, school)) ::: All faculty members have a job at a school.\n∀x (FacultyMember(x) ∨ Teacher(x)) ::: One can either be a faculty member or a teacher.\n∀x (Teacher(x) → HasStudents(x)) ::: Every teacher has students.\nTeacher(nancy) → OnPayroll(nancy) ::: If Nancy is a teacher, then they are on the payroll.\n¬Teacher(nancy) → ¬PaidBySchool(nancy) ::: If Nancy is not a teacher, then they are not paid by the school.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nOnPayroll(nancy) ∧ HasStudents(nancy) ::: Nancy is paid by the school and has students.\n\"\"\""
    ]
  },
  {
    "id": 1305,
    "context": [
      "If you are on the payroll, then you are being paid by the school.",
      "If someone has a job at a school, then they are on the payroll.",
      "All faculty members have a job at a school.",
      "One can either be a faculty member or a teacher.",
      "Every teacher has students.",
      "If Nancy is a teacher, then they are on the payroll.",
      "If Nancy is not a teacher, then they are not paid by the school."
    ],
    "question": "Nancy is not paid by the school and has students.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nOnPayroll(x) ::: x is on the payroll.\nPaidBySchool(x) ::: x is being paid by the school.\nHasJob(x, y) ::: x has a job at y.\nFacultyMember(x) ::: x is a faculty member.\nTeacher(x) ::: x is a teacher.\nHasStudents(x) ::: x has students.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nOnPayroll(x) → PaidBySchool(x) ::: If you are on the payroll, then you are being paid by the school.\nHasJob(x, school) → OnPayroll(x) ::: If someone has a job at a school, then they are on the payroll.\n∀x (FacultyMember(x) → HasJob(x, school)) ::: All faculty members have a job at a school.\n∀x (FacultyMember(x) ⊕ Teacher(x)) ::: One can either be a faculty member or a teacher.\n∀x (Teacher(x) → HasStudents(x)) ::: Every teacher has students.\nTeacher(nancy) → OnPayroll(nancy) ::: If Nancy is a teacher, then they are on the payroll.\n¬Teacher(nancy) → ¬PaidBySchool(nancy) ::: If Nancy is not a teacher, then they are not paid by the school.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬PaidBySchool(nancy) ∧ HasStudents(nancy) ::: Nancy is not paid by the school and has students.\n\"\"\""
    ]
  },
  {
    "id": 696,
    "context": [
      "Kangaroo is an animal.",
      "No Kangaroos live in Germany.",
      "If Jane saves enough money for the summer, she will fly to Germany.",
      "If Jane flies to Germany, she will go to the Berlin Zoo.",
      "If someone goes to the Berlin Zoo, they will see some of the animals that live in Germany."
    ],
    "question": "If Jane saves enough money for the summer, she will see a kangaroo.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nAnimal(x) ::: x is an animal.\nLiveInGermany(x) ::: x lives in Germany.\nSaveEnoughMoney(x) ::: x saves enough money.\nFlyToGermany(x) ::: x flies to Germany.\nGoToBerlinZoo(x) ::: x goes to the Berlin Zoo.\nSee(x, y) ::: x sees y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nAnimal(kangaroo) ::: Kangaroo is an animal.\n¬∃x LiveInGermany(kangaroo) ::: No Kangaroos live in Germany.\n(SaveEnoughMoney(jane) → FlyToGermany(jane)) ::: If Jane saves enough money for the summer, she will fly to Germany.\n(FlyToGermany(jane) → GoToBerlinZoo(jane)) ::: If Jane flies to Germany, she will go to the Berlin Zoo.\n∀x (GoToBerlinZoo(x) → ∃y (LiveInGermany(y) ∧ See(x, y))) ::: If someone goes to the Berlin Zoo, they will see some of the animals that live in Germany.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nSaveEnoughMoney(jane) → ∃x (See(jane, x) ∧ Animal(x)) ::: If Jane saves enough money for the summer, she will see a kangaroo.\n\"\"\""
    ]
  },
  {
    "id": 615,
    "context": [
      "If a class has prerequisites the student must take the prerequisites to take the class.",
      "If a class has no prerequisites, then the student can take the class",
      "CPSC 201 and CPSC 223 are prerequisites for CPSC 323.",
      "Intro Microeconomics is the only prerequisite for Intermediate Microeconomics.",
      "Intro Geology has no prerequisites."
    ],
    "question": "CPSC 201 has no prerequisites.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nHasPrerequisites(x) ::: x has prerequisites.\nTake(x, y) ::: y must take x.\nPrerequisite(x, y, z) ::: x is a prerequisite for y to take z.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (HasPrerequisites(x) → ∀y (Take(y, x) → Prerequisite(x, y, z))) ::: If a class has prerequisites the student must take the prerequisites to take the class.\n∀x (¬HasPrerequisites(x) → Take(x, y)) ::: If a class has no prerequisites, then the student can take the class.\nPrerequisite(cpsc201, cpsc323, cpsc223) ∧ Prerequisite(cpsc223, cpsc323, cpsc201) ::: CPSC 201 and CPSC 223 are prerequisites for CPSC 323.\nPrerequisite(introMicroeconomics, intermediateMicroeconomics, intermediateMicroeconomics) ::: Intro Microeconomics is the only prerequisite for Intermediate Microeconomics.\n¬HasPrerequisites(introGeology) ::: Intro Geology has no prerequisites.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬HasPrerequisites(cpsc201) ::: CPSC 201 has no prerequisites.\n\"\"\""
    ]
  },
  {
    "id": 616,
    "context": [
      "If a class has prerequisites the student must take the prerequisites to take the class.",
      "If a class has no prerequisites, then the student can take the class",
      "CPSC 201 and CPSC 223 are prerequisites for CPSC 323.",
      "Intro Microeconomics is the only prerequisite for Intermediate Microeconomics.",
      "Intro Geology has no prerequisites."
    ],
    "question": "If a student took CPSC 201 but did not take CPSC 223, they can take CPSC 323.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nHasPrerequisites(x, y) ::: class x has prerequisites y.\nTake(x, y) ::: student x takes class y.\nPrerequisite(x, y, z) ::: class x is a prerequisite for class y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x ∀y (HasPrerequisites(x, y) → (Take(student, y) ↔ Take(student, x))) ::: If a class has prerequisites the student must take the prerequisites to take the class.\n∀x (¬HasPrerequisites(x) → Take(student, x)) ::: If a class has no prerequisites, then the student can take the class.\nPrerequisite(cpsc323, cpsc201, cpsc223) ::: CPSC 201 and CPSC 223 are prerequisites for CPSC 323.\nPrerequisite(intermediateMicroeconomics, introMicroeconomics) ∧ ∀x (Prerequisite(x, introMicroeconomics) → x = intermediateMicroeconomics) ::: Intro Microeconomics is the only prerequisite for Intermediate Microeconomics.\n¬HasPrerequisites(introGeology) ::: Intro Geology has no prerequisites.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nTake(student, cpsc201) ∧ ¬Take(student, cpsc223) → Take(student, cpsc323) ::: If a student took CPSC 201 but did not take CPSC 223, they can take CPSC 323.\n\"\"\""
    ]
  },
  {
    "id": 617,
    "context": [
      "If a class has prerequisites the student must take the prerequisites to take the class.",
      "If a class has no prerequisites, then the student can take the class",
      "CPSC 201 and CPSC 223 are prerequisites for CPSC 323.",
      "Intro Microeconomics is the only prerequisite for Intermediate Microeconomics.",
      "Intro Geology has no prerequisites."
    ],
    "question": "A student cannot take Intro Geology.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nHasPrerequisites(x) ::: class x has prerequisites.\nTake(x, y) ::: student y takes class x.\nPrerequisite(x, y, z) ::: class x is a prerequisite for class y for student z.\nIntroMicroeconomics(x) ::: x is Intro Microeconomics.\nIntermediateMicroeconomics(x) ::: x is Intermediate Microeconomics.\nIntroGeology(x) ::: x is Intro Geology.\nCPSC201(x) ::: x is CPSC 201.\nCPSC223(x) ::: x is CPSC 223.\nCPSC323(x) ::: x is CPSC 323.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x ∀y ∀z (HasPrerequisites(x) ∧ Take(x, y) → Prerequisite(x, y, z)) ::: If a class has prerequisites the student must take the prerequisites to take the class.\n∀x ∀y (¬HasPrerequisites(x) → Take(x, y)) ::: If a class has no prerequisites, then the student can take the class.\nPrerequisite(CPSC201, CPSC323, student) ∧ Prerequisite(CPSC223, CPSC323, student) ::: CPSC 201 and CPSC 223 are prerequisites for CPSC 323.\n∀x (IntroMicroeconomics(x) ↔ Prerequisite(IntroMicroeconomics, IntermediateMicroeconomics, student)) ::: Intro Microeconomics is the only prerequisite for Intermediate Microeconomics.\n¬HasPrerequisites(IntroGeology) ::: Intro Geology has no prerequisites.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬Take(IntroGeology, student) ::: A student cannot take Intro Geology.\n\"\"\""
    ]
  },
  {
    "id": 618,
    "context": [
      "If a class has prerequisites the student must take the prerequisites to take the class.",
      "If a class has no prerequisites, then the student can take the class",
      "CPSC 201 and CPSC 223 are prerequisites for CPSC 323.",
      "Intro Microeconomics is the only prerequisite for Intermediate Microeconomics.",
      "Intro Geology has no prerequisites."
    ],
    "question": "Intermediate Microeconomics has one prerequisite.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nHasPrerequisites(x) ::: class x has prerequisites.\nTake(x, y) ::: student y takes class x.\nPrerequisite(x, y, z) ::: class x has prerequisite y for student z.\nIntroMicroeconomics(x) ::: x is Intro Microeconomics.\nIntermediateMicroeconomics(x) ::: x is Intermediate Microeconomics.\nCPSC201(x) ::: x is CPSC 201.\nCPSC223(x) ::: x is CPSC 223.\nCPSC323(x) ::: x is CPSC 323.\nIntroGeology(x) ::: x is Intro Geology.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x ∀y ∀z (HasPrerequisites(x) ∧ Take(x, z) → Prerequisite(x, y, z)) ::: If a class has prerequisites the student must take the prerequisites to take the class.\n∀x ∀y (¬HasPrerequisites(x) → Take(x, y)) ::: If a class has no prerequisites, then the student can take the class.\nPrerequisite(CPSC323, CPSC201, student) ∧ Prerequisite(CPSC323, CPSC223, student) ::: CPSC 201 and CPSC 223 are prerequisites for CPSC 323.\n∀x (IntroMicroeconomics(x) ↔ Prerequisite(IntermediateMicroeconomics, x, student)) ::: Intro Microeconomics is the only prerequisite for Intermediate Microeconomics.\n¬HasPrerequisites(IntroGeology) ::: Intro Geology has no prerequisites.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n∃x ∀y (Prerequisite(IntermediateMicroeconomics, x, y) ∧ ¬∃z (Prerequisite(IntermediateMicroeconomics, x, z) ∧ z ≠ y)) ::: Intermediate Microeconomics has one prerequisite.\n\"\"\""
    ]
  },
  {
    "id": 108,
    "context": [
      "A heptalogy, is a compound literary or narrative work that is made up of seven distinct works.",
      "The Harry Potter series consists of 7 distinct works.",
      "The Chronicles of Narnia consists of 7 distinct works."
    ],
    "question": "The Harry Potter series of books is a heptalogy.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nHeptalogy(x) ::: x is a heptalogy.\nConsistsOf(x, y) ::: x consists of y distinct works.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nHeptalogy(harryPotterSeries) ∧ ConsistsOf(harryPotterSeries, 7) ::: The Harry Potter series consists of 7 distinct works.\nHeptalogy(chroniclesOfNarnia) ∧ ConsistsOf(chroniclesOfNarnia, 7) ::: The Chronicles of Narnia consists of 7 distinct works.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nHeptalogy(harryPotterSeries) ::: The Harry Potter series of books is a heptalogy.\n\"\"\""
    ]
  },
  {
    "id": 109,
    "context": [
      "A heptalogy, is a compound literary or narrative work that is made up of seven distinct works.",
      "The Harry Potter series consists of 7 distinct works.",
      "The Chronicles of Narnia consists of 7 distinct works."
    ],
    "question": "The Chronicles of Narnia series of books is not a heptalogy.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nHeptalogy(x) ::: x is a heptalogy.\nConsistsOf(x, y) ::: x consists of y distinct works.\nHarryPotter(x) ::: x is the Harry Potter series.\nChroniclesOfNarnia(x) ::: x is The Chronicles of Narnia series.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nHeptalogy(heptalogy) ∧ ∀x (Heptalogy(x) → ConsistsOf(x, 7)) ::: A heptalogy is a compound literary or narrative work that is made up of seven distinct works.\nConsistsOf(HarryPotter, 7) ::: The Harry Potter series consists of 7 distinct works.\nConsistsOf(ChroniclesOfNarnia, 7) ::: The Chronicles of Narnia consists of 7 distinct works.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬Heptalogy(ChroniclesOfNarnia) ::: The Chronicles of Narnia series of books is not a heptalogy.\n\"\"\""
    ]
  },
  {
    "id": 110,
    "context": [
      "A heptalogy, is a compound literary or narrative work that is made up of seven distinct works.",
      "The Harry Potter series consists of 7 distinct works.",
      "The Chronicles of Narnia consists of 7 distinct works."
    ],
    "question": "The Lord of Rings is a heptalogy.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nHeptalogy(x) ::: x is a heptalogy.\nConsistsOf(x, y) ::: x consists of y distinct works.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nHeptalogy(harryPotter) ∧ ConsistsOf(harryPotter, 7) ::: The Harry Potter series consists of 7 distinct works.\nHeptalogy(chroniclesOfNarnia) ∧ ConsistsOf(chroniclesOfNarnia, 7) ::: The Chronicles of Narnia consists of 7 distinct works.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nHeptalogy(lordOfTheRings) ::: The Lord of Rings is a heptalogy.\n\"\"\""
    ]
  },
  {
    "id": 1022,
    "context": [
      "All people who attend Renaissance fairs regularly enjoy dressing up in old-fashioned and historical period clothing.",
      "If people are fascinated by the history of the Renaissance and other past eras, then they attend Renaissance fairs regularly.",
      "People are either fascinated by the history of the Renaissance and other past eras, or are not nostalgic academics who enjoy learning.",
      "If people are focused on the future and industry professions, then they are not nostalgic academics who enjoy learning.",
      "If people are historical professors who are passionate about their job and subject, then they are nostalgic academics who enjoy learning.",
      "If Clyde is not focused on the future and industry professions, then he is neither focused on the future and industry professions nor enjoys dressing up in old-fashioned and historical period clothing."
    ],
    "question": "Clyde attends Renaissance fairs regularly.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nAttend(x) ::: x attends Renaissance fairs regularly.\nEnjoyDressingUp(x) ::: x enjoys dressing up in old-fashioned and historical period clothing.\nFascinatedByHistory(x) ::: x is fascinated by the history of the Renaissance and other past eras.\nNostalgicAcademic(x) ::: x is a nostalgic academic who enjoys learning.\nFocusedOnFuture(x) ::: x is focused on the future and industry professions.\nHistoricalProfessor(x) ::: x is a historical professor who is passionate about their job and subject.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Attend(x) → EnjoyDressingUp(x)) ::: All people who attend Renaissance fairs regularly enjoy dressing up in old-fashioned and historical period clothing.\n∀x (FascinatedByHistory(x) → Attend(x)) ::: If people are fascinated by the history of the Renaissance and other past eras, then they attend Renaissance fairs regularly.\n∀x (FascinatedByHistory(x) ⊕ ¬NostalgicAcademic(x)) ::: People are either fascinated by the history of the Renaissance and other past eras, or are not nostalgic academics who enjoy learning.\n∀x (FocusedOnFuture(x) → ¬NostalgicAcademic(x)) ::: If people are focused on the future and industry professions, then they are not nostalgic academics who enjoy learning.\n∀x (HistoricalProfessor(x) ∧ Passionate(x) → NostalgicAcademic(x)) ::: If people are historical professors who are passionate about their job and subject, then they are nostalgic academics who enjoy learning.\n¬FocusedOnFuture(clyde) → ¬FocusedOnFuture(clyde) ∨ ¬EnjoyDressingUp(clyde) ::: If Clyde is not focused on the future and industry professions, then he is neither focused on the future and industry professions nor enjoys dressing up in old-fashioned and historical period clothing.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nAttend(clyde) ::: Clyde attends Renaissance fairs regularly.\n\"\"\""
    ]
  },
  {
    "id": 1023,
    "context": [
      "All people who attend Renaissance fairs regularly enjoy dressing up in old-fashioned and historical period clothing.",
      "If people are fascinated by the history of the Renaissance and other past eras, then they attend Renaissance fairs regularly.",
      "People are either fascinated by the history of the Renaissance and other past eras, or are not nostalgic academics who enjoy learning.",
      "If people are focused on the future and industry professions, then they are not nostalgic academics who enjoy learning.",
      "If people are historical professors who are passionate about their job and subject, then they are nostalgic academics who enjoy learning.",
      "If Clyde is not focused on the future and industry professions, then he is neither focused on the future and industry professions nor enjoys dressing up in old-fashioned and historical period clothing."
    ],
    "question": "Clyde is a history professor who is passionate about his job and subject.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nAttend(x) ::: x attends Renaissance fairs regularly.\nDressUp(x) ::: x enjoys dressing up in old-fashioned and historical period clothing.\nFascinatedByHistory(x) ::: x is fascinated by the history of the Renaissance and other past eras.\nNostalgicAcademic(x) ::: x is a nostalgic academic who enjoys learning.\nFocusedOnFuture(x) ::: x is focused on the future and industry professions.\nHistoricalProfessor(x) ::: x is a historical professor.\nPassionate(x) ::: x is passionate about his job and subject.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Attend(x) → DressUp(x)) ::: All people who attend Renaissance fairs regularly enjoy dressing up in old-fashioned and historical period clothing.\n∀x (FascinatedByHistory(x) → Attend(x)) ::: If people are fascinated by the history of the Renaissance and other past eras, then they attend Renaissance fairs regularly.\n∀x (FascinatedByHistory(x) ∨ ¬NostalgicAcademic(x)) ::: People are either fascinated by the history of the Renaissance and other past eras, or are not nostalgic academics who enjoy learning.\n∀x (FocusedOnFuture(x) → ¬NostalgicAcademic(x)) ::: If people are focused on the future and industry professions, then they are not nostalgic academics who enjoy learning.\n∀x (HistoricalProfessor(x) ∧ Passionate(x) → NostalgicAcademic(x)) ::: If people are historical professors who are passionate about their job and subject, then they are nostalgic academics who enjoy learning.\n¬FocusedOnFuture(clyde) → ¬(FocusedOnFuture(clyde) ∨ DressUp(clyde)) ::: If Clyde is not focused on the future and industry professions, then he is neither focused on the future and industry professions nor enjoys dressing up in old-fashioned and historical period clothing.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nHistoricalProfessor(clyde) ∧ Passionate(clyde) ::: Clyde is a history professor who is passionate about his job and subject.\n\"\"\""
    ]
  },
  {
    "id": 1024,
    "context": [
      "All people who attend Renaissance fairs regularly enjoy dressing up in old-fashioned and historical period clothing.",
      "If people are fascinated by the history of the Renaissance and other past eras, then they attend Renaissance fairs regularly.",
      "People are either fascinated by the history of the Renaissance and other past eras, or are not nostalgic academics who enjoy learning.",
      "If people are focused on the future and industry professions, then they are not nostalgic academics who enjoy learning.",
      "If people are historical professors who are passionate about their job and subject, then they are nostalgic academics who enjoy learning.",
      "If Clyde is not focused on the future and industry professions, then he is neither focused on the future and industry professions nor enjoys dressing up in old-fashioned and historical period clothing."
    ],
    "question": "Clyde is a history professor who is passionate about his job and subject, or is not a nostalgic academic who enjoys learning.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nAttend(x) ::: x attends Renaissance fairs regularly.\nDressUp(x) ::: x enjoys dressing up in old-fashioned and historical period clothing.\nFascinatedByHistory(x) ::: x is fascinated by the history of the Renaissance and other past eras.\nNostalgicAcademic(x) ::: x is a nostalgic academic who enjoys learning.\nFocusedOnFuture(x) ::: x is focused on the future and industry professions.\nHistoricalProfessor(x) ::: x is a historical professor.\nPassionate(x) ::: x is passionate about his job and subject.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Attend(x) → DressUp(x)) ::: All people who attend Renaissance fairs regularly enjoy dressing up in old-fashioned and historical period clothing.\n∀x (FascinatedByHistory(x) → Attend(x)) ::: If people are fascinated by the history of the Renaissance and other past eras, then they attend Renaissance fairs regularly.\n∀x (FascinatedByHistory(x) ∨ ¬NostalgicAcademic(x)) ::: People are either fascinated by the history of the Renaissance and other past eras, or are not nostalgic academics who enjoy learning.\n∀x (FocusedOnFuture(x) → ¬NostalgicAcademic(x)) ::: If people are focused on the future and industry professions, then they are not nostalgic academics who enjoy learning.\n∀x (HistoricalProfessor(x) ∧ Passionate(x) → NostalgicAcademic(x)) ::: If people are historical professors who are passionate about their job and subject, then they are nostalgic academics who enjoy learning.\n¬FocusedOnFuture(clyde) → ¬FocusedOnFuture(clyde) ∨ ¬DressUp(clyde) ::: If Clyde is not focused on the future and industry professions, then he is neither focused on the future and industry professions nor enjoys dressing up in old-fashioned and historical period clothing.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nHistoricalProfessor(clyde) ∧ Passionate(clyde) ∨ ¬NostalgicAcademic(clyde) ::: Clyde is a history professor who is passionate about his job and subject, or is not a nostalgic academic who enjoys learning.\n\"\"\""
    ]
  },
  {
    "id": 719,
    "context": [
      "No sports cars are vehicles intended to be driven at moderate speeds.",
      "All automobiles designed for family use are vehicles intended to be driven at moderate speeds."
    ],
    "question": "No sports cars are automobiles designed for family use.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nSportsCar(x) ::: x is a sports car.\nVehicle(x) ::: x is a vehicle.\nModerateSpeed(x) ::: x is intended to be driven at moderate speeds.\nAutomobile(x) ::: x is an automobile.\nFamilyUse(x) ::: x is designed for family use.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (SportsCar(x) → ¬ModerateSpeed(x)) ::: No sports cars are vehicles intended to be driven at moderate speeds.\n∀x (Automobile(x) ∧ FamilyUse(x) → ModerateSpeed(x)) ::: All automobiles designed for family use are vehicles intended to be driven at moderate speeds.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬(SportsCar(x) ∧ FamilyUse(x)) ::: No sports cars are automobiles designed for family use.\n\"\"\""
    ]
  },
  {
    "id": 949,
    "context": [
      "If people work well in teams in their workplace, then they get along with all their colleagues at their work.",
      "If people come to work every day with a positive attitude, then they work well in teams in their workplace.",
      "People either come into work every day with a positive attitude or are always tired every morning.",
      "If people get many promotions from their boss at work, then they receive negative feedback from teams at work.",
      "Kat is either both a person who works well in teams in their workplace and is always tired every morning, or she neither works well in teams in their workplace nor is always tired every morning."
    ],
    "question": "Kat is a person who comes to work every day with a positive attitude.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nWorkWell(x) ::: x works well in teams in their workplace.\nGetAlongWith(x, y) ::: x gets along with y.\nColleague(x, y) ::: x is a colleague of y.\nPositiveAttitude(x) ::: x comes to work every day with a positive attitude.\nTired(x) ::: x is always tired every morning.\nPromotions(x, y) ::: x gets many promotions from y.\nBoss(x) ::: x is the boss.\nNegativeFeedback(x, y) ::: x receives negative feedback from y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (WorkWell(x) → ∀y (Colleague(x, y) → GetAlongWith(x, y))) ::: If people work well in teams in their workplace, then they get along with all their colleagues at their work.\n∀x (PositiveAttitude(x) → WorkWell(x)) ::: If people come to work every day with a positive attitude, then they work well in teams in their workplace.\n∀x (PositiveAttitude(x) ⊕ Tired(x)) ::: People either come into work every day with a positive attitude or are always tired every morning.\n∀x (Promotions(x, boss) → NegativeFeedback(x, teams)) ::: If people get many promotions from their boss at work, then they receive negative feedback from teams at work.\n(WorkWell(kat) ∧ Tired(kat)) ⊕ ¬(WorkWell(kat) ∨ Tired(kat)) ::: Kat is either both a person who works well in teams in their workplace and is always tired every morning, or she neither works well in teams in their workplace nor is always tired every morning.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nPositiveAttitude(kat) ::: Kat is a person who comes to work every day with a positive attitude.\n\"\"\""
    ]
  },
  {
    "id": 950,
    "context": [
      "If people work well in teams in their workplace, then they get along with all their colleagues at their work.",
      "If people come to work every day with a positive attitude, then they work well in teams in their workplace.",
      "People either come into work every day with a positive attitude or are always tired every morning.",
      "If people get many promotions from their boss at work, then they receive negative feedback from teams at work.",
      "Kat is either both a person who works well in teams in their workplace and is always tired every morning, or she neither works well in teams in their workplace nor is always tired every morning."
    ],
    "question": "Kat gets along with her colleagues at her work and receives negative feedback from teams at her work.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nWorkWell(x) ::: x works well in teams in their workplace.\nGetAlong(x, y) ::: x gets along with y.\nColleague(x, y) ::: x is a colleague of y.\nPositiveAttitude(x) ::: x comes to work every day with a positive attitude.\nTired(x) ::: x is always tired every morning.\nPromotions(x) ::: x gets many promotions from their boss at work.\nNegativeFeedback(x, y) ::: x receives negative feedback from y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (WorkWell(x) → ∀y (Colleague(x, y) → GetAlong(x, y))) ::: If people work well in teams in their workplace, then they get along with all their colleagues at their work.\n∀x (PositiveAttitude(x) → WorkWell(x)) ::: If people come to work every day with a positive attitude, then they work well in teams in their workplace.\n∀x (PositiveAttitude(x) ⊕ Tired(x)) ::: People either come into work every day with a positive attitude or are always tired every morning.\n∀x (Promotions(x) → NegativeFeedback(x, teams)) ::: If people get many promotions from their boss at work, then they receive negative feedback from teams at work.\n(WorkWell(kat) ∧ Tired(kat)) ⊕ ¬(WorkWell(kat) ∨ Tired(kat)) ::: Kat is either both a person who works well in teams in their workplace and is always tired every morning, or she neither works well in teams in their workplace nor is always tired every morning.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nGetAlong(kat, colleagues) ∧ NegativeFeedback(kat, teams) ::: Kat gets along with her colleagues at her work and receives negative feedback from teams at her work.\n\"\"\""
    ]
  },
  {
    "id": 951,
    "context": [
      "If people work well in teams in their workplace, then they get along with all their colleagues at their work.",
      "If people come to work every day with a positive attitude, then they work well in teams in their workplace.",
      "People either come into work every day with a positive attitude or are always tired every morning.",
      "If people get many promotions from their boss at work, then they receive negative feedback from teams at work.",
      "Kat is either both a person who works well in teams in their workplace and is always tired every morning, or she neither works well in teams in their workplace nor is always tired every morning."
    ],
    "question": "Kat either gets along with her colleagues at her work or receives negative feedback from teams at her work.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nWorkWell(x) ::: x works well in teams in their workplace.\nGetAlong(x, y) ::: x gets along with y.\nPositiveAttitude(x) ::: x comes to work every day with a positive attitude.\nTired(x) ::: x is always tired every morning.\nPromotions(x) ::: x gets many promotions from their boss at work.\nNegativeFeedback(x, y) ::: x receives negative feedback from y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (WorkWell(x) → ∀y(GetAlong(x, y))) ::: If people work well in teams in their workplace, then they get along with all their colleagues at their work.\n∀x (PositiveAttitude(x) → WorkWell(x)) ::: If people come to work every day with a positive attitude, then they work well in teams in their workplace.\nPositiveAttitude(kat) ⊕ Tired(kat) ::: People either come into work every day with a positive attitude or are always tired every morning.\n∀x (Promotions(x) → NegativeFeedback(x, teams)) ::: If people get many promotions from their boss at work, then they receive negative feedback from teams at work.\n(WorkWell(kat) ∧ Tired(kat)) ⊕ ¬(WorkWell(kat) ∨ Tired(kat)) ::: Kat is either both a person who works well in teams in their workplace and is always tired every morning, or she neither works well in teams in their workplace nor is always tired every morning.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nGetAlong(kat, colleagues) ∨ NegativeFeedback(kat, teams) ::: Kat either gets along with her colleagues at her work or receives negative feedback from teams at her work.\n\"\"\""
    ]
  },
  {
    "id": 725,
    "context": [
      "Drishti is open-source.",
      "Open-source software is free to modify."
    ],
    "question": "Drishti is free to modify.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nOpenSource(x) ::: x is open-source.\nFreeToModify(x) ::: x is free to modify.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nOpenSource(drishti) ::: Drishti is open-source.\n∀x (OpenSource(x) → FreeToModify(x)) ::: Open-source software is free to modify.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nFreeToModify(drishti) ::: Drishti is free to modify.\n\"\"\""
    ]
  },
  {
    "id": 464,
    "context": [
      "There are five grades including A+, A, B+, B, and C in English.",
      "If a student gets A+ in English, then his score is greater than 95.",
      "If a student gets A in English, then his score is in the range of 90-95.",
      "Zhang got an A in English.",
      "Wang's English score is better than Zhang's.",
      "Wu's English score is lower than 90."
    ],
    "question": "Zhang's English score is lower than 95.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nGrade(x) ::: x is a grade.\nEnglish(x) ::: x is in English.\nScore(x, y) ::: x has a score of y.\nBetter(x, y) ::: x is better than y.\nLower(x, y) ::: x is lower than y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Grade(x) → English(x)) ::: There are five grades including A+, A, B+, B, and C in English.\nScore(student, y) → (Grade(A+) ∧ y > 95) ::: If a student gets A+ in English, then his score is greater than 95.\nScore(student, y) → (Grade(A) ∧ 90 <= y <= 95) ::: If a student gets A in English, then his score is in the range of 90-95.\nGrade(A) ∧ Score(zhang, y) ::: Zhang got an A in English.\nEnglishScore(wang, x) ∧ EnglishScore(zhang, y) ∧ Better(wang, zhang) ::: Wang's English score is better than Zhang's.\nScore(wu, y) ∧ y < 90 ::: Wu's English score is lower than 90.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nScore(zhang, y) ∧ y < 95 ::: Zhang's English score is lower than 95.\n\"\"\""
    ]
  },
  {
    "id": 465,
    "context": [
      "There are five grades including A+, A, B+, B, and C in English.",
      "If a student gets A+ in English, then his score is greater than 95.",
      "If a student gets A in English, then his score is in the range of 90-95.",
      "Zhang got an A in English.",
      "Wang's English score is better than Zhang's.",
      "Wu's English score is lower than 90."
    ],
    "question": "Wang got an A+ in English.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nGrade(x) ::: x is a grade in English.\nScore(x, y) ::: x's score in English is y.\nGets(x, y) ::: x gets grade y in English.\nBetter(x, y) ::: x's English score is better than y's.\nLower(x, y) ::: x's English score is lower than y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nGrade(aplus) ∧ Grade(a) ∧ Grade(bplus) ∧ Grade(b) ∧ Grade(c) ∧ ∀x (Gets(x, aplus) → Score(x, greaterThan95)) ::: There are five grades including A+, A, B+, B, and C in English. If a student gets A+ in English, then his score is greater than 95.\n∀x (Gets(x, a) → Score(x, range90to95)) ::: If a student gets A in English, then his score is in the range of 90-95.\nGets(zhang, a) ::: Zhang got an A in English.\nBetter(wang, zhang) ::: Wang's English score is better than Zhang's.\nLower(wu, ninety) ::: Wu's English score is lower than 90.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬Gets(wang, aplus) ::: Wang did not get an A+ in English.\n\"\"\""
    ]
  },
  {
    "id": 466,
    "context": [
      "There are five grades including A+, A, B+, B, and C in English.",
      "If a student gets A+ in English, then his score is greater than 95.",
      "If a student gets A in English, then his score is in the range of 90-95.",
      "Zhang got an A in English.",
      "Wang's English score is better than Zhang's.",
      "Wu's English score is lower than 90."
    ],
    "question": "Wu does not get an A or A+ in English.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nGrade(x) ::: x is a grade in English.\nScore(x, y) ::: x's score in English is y.\nStudent(x) ::: x is a student.\nBetter(x, y) ::: x's English score is better than y's.\nLower(x, y) ::: x's English score is lower than y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Grade(x) ↔ (x = A+ ∨ x = A ∨ x = B+ ∨ x = B ∨ x = C)) ::: There are five grades including A+, A, B+, B, and C in English.\nScore(student, y) > 95 → Grade(A+) ::: If a student gets A+ in English, then his score is greater than 95.\nScore(student, y) ∈ [90, 95] → Grade(A) ::: If a student gets A in English, then his score is in the range of 90-95.\nGrade(A) ∧ Student(zhang) ::: Zhang got an A in English.\nBetter(score(wang, x), score(zhang, y)) ::: Wang's English score is better than Zhang's.\nScore(wu, x) < 90 ::: Wu's English score is lower than 90.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬(Grade(A) ∨ Grade(A+)) ::: Wu does not get an A or A+ in English.\n\"\"\""
    ]
  },
  {
    "id": 621,
    "context": [
      "Olivia doesn't prefer warm temperature during the day.",
      "When Olivia sleeps, she prefers cool temperature.",
      "Olivia sleeps during the night.",
      "Olivia works during the day.",
      "Olivia either works or sleeps.",
      "The time is either the day or the night.",
      "Olivia either prefers warm temperature or prefers cool temperature."
    ],
    "question": "At all times, Olivia prefers cool temperature.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nPrefersWarm(x) ::: x prefers warm temperature.\nPrefersCool(x) ::: x prefers cool temperature.\nSleeps(x) ::: x sleeps.\nWorks(x) ::: x works.\nDay(x) ::: x is during the day.\nNight(x) ::: x is during the night.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n¬PrefersWarm(olivia) ::: Olivia doesn't prefer warm temperature during the day.\nSleeps(olivia) → PrefersCool(olivia) ::: When Olivia sleeps, she prefers cool temperature.\nSleeps(olivia) ::: Olivia sleeps during the night.\nWorks(olivia) ::: Olivia works during the day.\nWorks(olivia) ∨ Sleeps(olivia) ::: Olivia either works or sleeps.\nDay(time) ∨ Night(time) ::: The time is either the day or the night.\nPrefersWarm(olivia) ∨ PrefersCool(olivia) ::: Olivia either prefers warm temperature or prefers cool temperature.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n∀x (PrefersCool(olivia)) ::: At all times, Olivia prefers cool temperature.\n\"\"\""
    ]
  },
  {
    "id": 596,
    "context": [
      "Taylor Swift gives a commencement speech in New York University in 2022.",
      "Both Columbia University and New York University are located in Manhattan.",
      "Taylor Swift has received three Grammy Album of the Year Awards.",
      "Columbia University is one of the Ivy League schools."
    ],
    "question": "Taylor Swift delivers a commencement speech in Manhattan.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nGiveSpeech(x, y) ::: x gives a speech in y.\nLocatedIn(x, y) ::: x is located in y.\nReceiveAward(x, y) ::: x receives y awards.\nIvyLeague(x) ::: x is an Ivy League school.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nGiveSpeech(taylorSwift, newYorkUniversity, year2022) ::: Taylor Swift gives a commencement speech in New York University in 2022.\nLocatedIn(columbiaUniversity, manhattan) ∧ LocatedIn(newYorkUniversity, manhattan) ::: Both Columbia University and New York University are located in Manhattan.\nReceiveAward(taylorSwift, grammyAlbumOfTheYear, number3) ::: Taylor Swift has received three Grammy Album of the Year Awards.\nIvyLeague(columbiaUniversity) ::: Columbia University is one of the Ivy League schools.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n∃x (GiveSpeech(taylorSwift, x) ∧ LocatedIn(x, manhattan)) ::: Taylor Swift delivers a commencement speech in Manhattan.\n\"\"\""
    ]
  },
  {
    "id": 597,
    "context": [
      "Taylor Swift gives a commencement speech in New York University in 2022.",
      "Both Columbia University and New York University are located in Manhattan.",
      "Taylor Swift has received three Grammy Album of the Year Awards.",
      "Columbia University is one of the Ivy League schools."
    ],
    "question": "The commencement speaker of NYU does not have any album.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nGiveSpeech(x, y) ::: x gives a commencement speech in y.\nLocatedIn(x, y) ::: x is located in y.\nReceiveAward(x, y) ::: x has received y awards.\nAlbumOfTheYearGrammy(x) ::: x has received a Grammy Album of the Year Award.\nIvyLeagueSchool(x) ::: x is an Ivy League school.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nGiveSpeech(taylorSwift, NYU, year2022) ::: Taylor Swift gives a commencement speech in New York University in 2022.\nLocatedIn(ColumbiaUniversity, Manhattan) ∧ LocatedIn(NYU, Manhattan) ::: Both Columbia University and New York University are located in Manhattan.\nReceiveAward(taylorSwift, 3, AlbumOfTheYearGrammy) ::: Taylor Swift has received three Grammy Album of the Year Awards.\nIvyLeagueSchool(ColumbiaUniversity) ::: Columbia University is one of the Ivy League schools.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬∃x (GiveSpeech(x, NYU, year2022) ∧ ReceiveAward(x, 0, AlbumOfTheYearGrammy)) ::: The commencement speaker of NYU does not have any album.\n\"\"\""
    ]
  },
  {
    "id": 1204,
    "context": [
      "Customers either choose Plan A or Plan B.",
      "All who choose Plan B are rewarded with a $30 gift card. ",
      "There are no customers who do not choose any plans. ",
      "No customers rewarded a $30 gift card are older than 80.",
      "Customers are either older than 80 or are currently studying at school. ",
      "James is not a customer who is currently studying at school. "
    ],
    "question": "James is a customer who does not choose any plans.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nChoose(x, y) ::: x chooses plan y.\nReward(x, y) ::: x is rewarded with a $30 gift card.\nOlderThan80(x) ::: x is older than 80.\nStudying(x) ::: x is currently studying at school.\nCustomer(x) ::: x is a customer.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Customer(x) → (Choose(x, planA) ∨ Choose(x, planB))) ::: Customers either choose Plan A or Plan B.\n∀x (Choose(x, planB) → Reward(x, $30GiftCard)) ::: All who choose Plan B are rewarded with a $30 gift card.\n¬∃x ¬(Choose(x, planA) ∨ Choose(x, planB)) ::: There are no customers who do not choose any plans.\n¬(Reward(x, $30GiftCard) ∧ OlderThan80(x)) ::: No customers rewarded a $30 gift card are older than 80.\n∀x (Reward(x, $30GiftCard) → ¬OlderThan80(x)) ::: Customers rewarded a $30 gift card are not older than 80.\n∀x (OlderThan80(x) ∨ Studying(x)) ::: Customers are either older than 80 or are currently studying at school.\n¬Studying(james) ::: James is not a customer who is currently studying at school.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬Choose(james, planA) ∧ ¬Choose(james, planB) ::: James is a customer who does not choose any plans.\n\"\"\""
    ]
  },
  {
    "id": 1205,
    "context": [
      "Customers either choose Plan A or Plan B.",
      "All who choose Plan B are rewarded with a $30 gift card. ",
      "There are no customers who do not choose any plans. ",
      "No customers rewarded a $30 gift card are older than 80.",
      "Customers are either older than 80 or are currently studying at school. ",
      "James is not a customer who is currently studying at school. "
    ],
    "question": "James is a customer who chooses Plan A or does not choose any plans.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nChoose(x, y) ::: x chooses plan y.\nReward(x, y) ::: x is rewarded with a $30 gift card.\nOlderThan80(x) ::: x is older than 80.\nStudying(x) ::: x is currently studying at school.\nCustomer(x) ::: x is a customer.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Customer(x) → (Choose(x, planA) ∨ Choose(x, planB))) ::: Customers either choose Plan A or Plan B.\n∀x (Choose(x, planB) → Reward(x, $30GiftCard)) ::: All who choose Plan B are rewarded with a $30 gift card.\n¬∃x ¬(Choose(x, planA) ∨ Choose(x, planB)) ::: There are no customers who do not choose any plans.\n∀x (Reward(x, $30GiftCard) → ¬OlderThan80(x)) ::: No customers rewarded a $30 gift card are older than 80.\n∀x (Customer(x) → (OlderThan80(x) ∨ Studying(x))) ::: Customers are either older than 80 or are currently studying at school.\n¬Studying(james) ::: James is not a customer who is currently studying at school.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nChoose(james, planA) ∨ ¬(Choose(james, planA) ∨ Choose(james, planB)) ::: James is a customer who chooses Plan A or does not choose any plans.\n\"\"\""
    ]
  },
  {
    "id": 1206,
    "context": [
      "Customers either choose Plan A or Plan B.",
      "All who choose Plan B are rewarded with a $30 gift card. ",
      "There are no customers who do not choose any plans. ",
      "No customers rewarded a $30 gift card are older than 80.",
      "Customers are either older than 80 or are currently studying at school. ",
      "James is not a customer who is currently studying at school. "
    ],
    "question": "Suppose James is a customer who chooses Plan A or does not choose any plans, then he is either rewarded a $30 gift card or chooses Plan B.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nChoose(x, y) ::: x chooses plan y.\nReward(x, y) ::: x is rewarded with a $30 gift card.\nOlderThan80(x) ::: x is older than 80.\nStudying(x) ::: x is currently studying at school.\nCustomer(x) ::: x is a customer.\nJames(x) ::: x is James.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Customer(x) → (Choose(x, planA) ∨ Choose(x, planB))) ::: Customers either choose Plan A or Plan B.\n∀x (Choose(x, planB) → Reward(x, $30)) ::: All who choose Plan B are rewarded with a $30 gift card.\n¬∃x ¬(Choose(x, planA) ∨ Choose(x, planB)) ::: There are no customers who do not choose any plans.\n∀x (Reward(x, $30) → ¬OlderThan80(x)) ::: No customers rewarded a $30 gift card are older than 80.\n∀x (Customer(x) → (OlderThan80(x) ∨ Studying(x))) ::: Customers are either older than 80 or are currently studying at school.\n¬Studying(james) ::: James is not a customer who is currently studying at school.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n(Choose(james, planA) ∨ ¬Choose(james, planA)) → (Reward(james, $30) ∨ Choose(james, planB)) ::: Suppose James is a customer who chooses Plan A or does not choose any plans, then he is either rewarded a $30 gift card or chooses Plan B.\n\"\"\""
    ]
  },
  {
    "id": 500,
    "context": [
      "Detroit City is a horse.",
      "Some horses are racehorses.",
      "If a horse falls during a race, then it dies.",
      "Detroit City fell during a race.",
      "A horse is a racehorse if it is in a race."
    ],
    "question": "Detroit City has been in multiple races.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nHorse(x) ::: x is a horse.\nRacehorse(x) ::: x is a racehorse.\nFall(x) ::: x falls during a race.\nDie(x) ::: x dies.\nInRace(x) ::: x is in a race.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nHorse(detroitCity) ::: Detroit City is a horse.\n∃x (Horse(x) ∧ Racehorse(x)) ::: Some horses are racehorses.\n∀x (Fall(x) → Die(x)) ::: If a horse falls during a race, then it dies.\nFall(detroitCity) ::: Detroit City fell during a race.\n∀x (InRace(x) → Racehorse(x)) ::: A horse is a racehorse if it is in a race.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n∃x ∃y (InRace(x) ∧ InRace(y) ∧ x ≠ y) ::: Detroit City has been in multiple races.\n\"\"\""
    ]
  },
  {
    "id": 501,
    "context": [
      "Detroit City is a horse.",
      "Some horses are racehorses.",
      "If a horse falls during a race, then it dies.",
      "Detroit City fell during a race.",
      "A horse is a racehorse if it is in a race."
    ],
    "question": "Detroit City is dead.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nHorse(x) ::: x is a horse.\nRacehorse(x) ::: x is a racehorse.\nFall(x) ::: x falls.\nDie(x) ::: x dies.\nInRace(x) ::: x is in a race.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nHorse(detroitCity) ::: Detroit City is a horse.\n∃x (Horse(x) ∧ Racehorse(x)) ::: Some horses are racehorses.\n∀x (Fall(x) → Die(x)) ::: If a horse falls during a race, then it dies.\nFall(detroitCity) ::: Detroit City fell during a race.\n∀x (InRace(x) → Racehorse(x)) ::: A horse is a racehorse if it is in a race.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nDie(detroitCity) ::: Detroit City is dead.\n\"\"\""
    ]
  },
  {
    "id": 502,
    "context": [
      "Detroit City is a horse.",
      "Some horses are racehorses.",
      "If a horse falls during a race, then it dies.",
      "Detroit City fell during a race.",
      "A horse is a racehorse if it is in a race."
    ],
    "question": "Detroit City is a racehorse.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nHorse(x) ::: x is a horse.\nRacehorse(x) ::: x is a racehorse.\nFall(x) ::: x falls.\nDie(x) ::: x dies.\nInRace(x) ::: x is in a race.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nHorse(detroitCity) ::: Detroit City is a horse.\n∃x (Horse(x) ∧ Racehorse(x)) ::: Some horses are racehorses.\n∀x (Horse(x) ∧ Fall(x) → Die(x)) ::: If a horse falls during a race, then it dies.\nFall(detroitCity) ::: Detroit City fell during a race.\n∀x (Horse(x) → (InRace(x) → Racehorse(x))) ::: A horse is a racehorse if it is in a race.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nRacehorse(detroitCity) ::: Detroit City is a racehorse.\n\"\"\""
    ]
  },
  {
    "id": 340,
    "context": [
      "Frederick Monhoff was an architect, artist, and illustrator.",
      "Frederick Monhoff was an American.",
      "An artist is good at painting or music.",
      "All Americans speak English."
    ],
    "question": "Frederick Monhoff is good at music.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nArchitect(x) ::: x is an architect.\nArtist(x) ::: x is an artist.\nIllustrator(x) ::: x is an illustrator.\nAmerican(x) ::: x is an American.\nGoodAt(x, y) ::: x is good at y.\nSpeak(x, y) ::: x speaks language y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nArchitect(frederickMonhoff) ∧ Artist(frederickMonhoff) ∧ Illustrator(frederickMonhoff) ::: Frederick Monhoff was an architect, artist, and illustrator.\nAmerican(frederickMonhoff) ::: Frederick Monhoff was an American.\n∀x (Artist(x) → (GoodAt(x, painting) ∨ GoodAt(x, music))) ::: An artist is good at painting or music.\n∀x (American(x) → Speak(x, english)) ::: All Americans speak English.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nGoodAt(frederickMonhoff, music) ::: Frederick Monhoff is good at music.\n\"\"\""
    ]
  },
  {
    "id": 341,
    "context": [
      "Frederick Monhoff was an architect, artist, and illustrator.",
      "Frederick Monhoff was an American.",
      "An artist is good at painting or music.",
      "All Americans speak English."
    ],
    "question": "There is no illustrator who speaks English.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nArchitect(x) ::: x is an architect.\nArtist(x) ::: x is an artist.\nIllustrator(x) ::: x is an illustrator.\nAmerican(x) ::: x is an American.\nGoodAt(x, y) ::: x is good at y.\nSpeak(x, y) ::: x speaks y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nArchitect(frederickMonhoff) ∧ Artist(frederickMonhoff) ∧ Illustrator(frederickMonhoff) ::: Frederick Monhoff was an architect, artist, and illustrator.\nAmerican(frederickMonhoff) ::: Frederick Monhoff was an American.\n∀x (Artist(x) → (GoodAt(x, painting) ∨ GoodAt(x, music))) ::: An artist is good at painting or music.\n∀x (American(x) → Speak(x, english)) ::: All Americans speak English.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬∃x (Illustrator(x) ∧ Speak(x, english)) ::: There is no illustrator who speaks English.\n\"\"\""
    ]
  },
  {
    "id": 51,
    "context": [
      "Miroslav Fiedler was a Czech mathematician.",
      "Miroslav Fiedler is known for his contributions to linear algebra and graph theory.",
      "Miroslav Fiedler is honored by the Fiedler eigenvalue.",
      "Fiedler eigenvalue is the second smallest eigenvalue of the graph Laplacian."
    ],
    "question": "Miroslav Fiedler is honored by the second smallest eigenvalue of the graph Laplacian.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nCzech(x) ::: x is a Czech person.\nMathematician(x) ::: x is a mathematician.\nContributeTo(x, y) ::: x contributes to y.\nLinearAlgebra(x) ::: x is related to linear algebra.\nGraphTheory(x) ::: x is related to graph theory.\nHonoredBy(x, y) ::: x is honored by y.\nEigenvalue(x) ::: x is an eigenvalue.\nSecondSmallest(x) ::: x is the second smallest.\nGraphLaplacian(x) ::: x is the graph Laplacian.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nCzech(miroslav) ∧ Mathematician(miroslav) ::: Miroslav Fiedler was a Czech mathematician.\nContributeTo(miroslav, linearAlgebra) ∧ ContributeTo(miroslav, graphTheory) ::: Miroslav Fiedler is known for his contributions to linear algebra and graph theory.\nHonoredBy(miroslav, fiedlerEigenvalue) ∧ Eigenvalue(fiedlerEigenvalue) ∧ SecondSmallest(fiedlerEigenvalue) ∧ GraphLaplacian(graphLaplacian) ::: Miroslav Fiedler is honored by the Fiedler eigenvalue, which is the second smallest eigenvalue of the graph Laplacian.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nHonoredBy(miroslav, secondSmallest(graphLaplacian)) ::: Miroslav Fiedler is honored by the second smallest eigenvalue of the graph Laplacian.\n\"\"\""
    ]
  },
  {
    "id": 52,
    "context": [
      "Miroslav Fiedler was a Czech mathematician.",
      "Miroslav Fiedler is known for his contributions to linear algebra and graph theory.",
      "Miroslav Fiedler is honored by the Fiedler eigenvalue.",
      "Fiedler eigenvalue is the second smallest eigenvalue of the graph Laplacian."
    ],
    "question": "Miroslav Fiedler was a French mathematician.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nCzech(x) ::: x is a Czech person.\nMathematician(x) ::: x is a mathematician.\nContributeTo(x, y) ::: x contributes to y.\nKnownFor(x, y) ::: x is known for y.\nHonoredBy(x, y) ::: x is honored by y.\nEigenvalue(x) ::: x is an eigenvalue.\nSecondSmallest(x) ::: x is the second smallest.\nGraph(x) ::: x is a graph.\nLaplacian(x) ::: x is a Laplacian.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nCzech(miroslavFiedler) ∧ Mathematician(miroslavFiedler) ::: Miroslav Fiedler was a Czech mathematician.\nKnownFor(miroslavFiedler, linearAlgebra) ∧ KnownFor(miroslavFiedler, graphTheory) ::: Miroslav Fiedler is known for his contributions to linear algebra and graph theory.\nHonoredBy(miroslavFiedler, fiedlerEigenvalue) ::: Miroslav Fiedler is honored by the Fiedler eigenvalue.\nEigenvalue(fiedlerEigenvalue) ∧ SecondSmallest(fiedlerEigenvalue) ∧ Graph(graphLaplacian) ∧ Laplacian(graphLaplacian) ::: Fiedler eigenvalue is the second smallest eigenvalue of the graph Laplacian.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬Czech(miroslavFiedler) ::: Miroslav Fiedler was a French mathematician.\n\"\"\""
    ]
  },
  {
    "id": 53,
    "context": [
      "Miroslav Fiedler was a Czech mathematician.",
      "Miroslav Fiedler is known for his contributions to linear algebra and graph theory.",
      "Miroslav Fiedler is honored by the Fiedler eigenvalue.",
      "Fiedler eigenvalue is the second smallest eigenvalue of the graph Laplacian."
    ],
    "question": "A Czech mathematician is known for his contributions to linear algebra and graph theory.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nCzech(x) ::: x is a Czech person.\nMathematician(x) ::: x is a mathematician.\nContribution(x, y) ::: x has contributions to y.\nEigenvalue(x) ::: x is an eigenvalue.\nLaplacian(x) ::: x is a graph Laplacian.\nKnownFor(x, y) ::: x is known for y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nCzech(miroslavFiedler) ∧ Mathematician(miroslavFiedler) ::: Miroslav Fiedler was a Czech mathematician.\nContribution(miroslavFiedler, linearAlgebra) ∧ Contribution(miroslavFiedler, graphTheory) ::: Miroslav Fiedler is known for his contributions to linear algebra and graph theory.\nHonored(miroslavFiedler, fiedlerEigenvalue) ::: Miroslav Fiedler is honored by the Fiedler eigenvalue.\nEigenvalue(fiedlerEigenvalue) ∧ Laplacian(graphLaplacian) ∧ SecondSmallest(fiedlerEigenvalue, graphLaplacian) ::: Fiedler eigenvalue is the second smallest eigenvalue of the graph Laplacian.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n∃x (Czech(x) ∧ Mathematician(x) ∧ Contribution(x, linearAlgebra) ∧ Contribution(x, graphTheory)) ::: A Czech mathematician is known for his contributions to linear algebra and graph theory.\n\"\"\""
    ]
  },
  {
    "id": 446,
    "context": [
      "A laptop is a computer.",
      "You can play games on a computer.",
      "A phone is not a computer."
    ],
    "question": "You can play games on a laptop.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nComputer(x) ::: x is a computer.\nPlayGames(x) ::: x can play games.\nLaptop(x) ::: x is a laptop.\nPhone(x) ::: x is a phone.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Laptop(x) → Computer(x)) ::: A laptop is a computer.\n∀x (Computer(x) → PlayGames(x)) ::: You can play games on a computer.\n¬(Phone(x) → Computer(x)) ::: A phone is not a computer.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nPlayGames(laptop) ::: You can play games on a laptop.\n\"\"\""
    ]
  },
  {
    "id": 447,
    "context": [
      "A laptop is a computer.",
      "You can play games on a computer.",
      "A phone is not a computer."
    ],
    "question": "You can not play games on a phone.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nComputer(x) ::: x is a computer.\nPlayGames(x) ::: x can play games.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Laptop(x) → Computer(x)) ::: A laptop is a computer.\n∀x (Computer(x) → PlayGames(x)) ::: You can play games on a computer.\n¬(Phone(x) → Computer(x)) ::: A phone is not a computer.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬PlayGames(phone) ::: You can not play games on a phone.\n\"\"\""
    ]
  },
  {
    "id": 29,
    "context": [
      "Walter Folger Brown was an American politician and lawyer, and served as the postmaster general.",
      "Walter Folger Brown graduated from Harvard University with a Bachelors of Arts.",
      "While they were both in Toledo, Walter Folger Brown's father practiced law with Walter Folger Brown.",
      "Katherin Hafer married Walter Folger Brown."
    ],
    "question": "Walter Folger Brown graduated with a Bachelors of Arts.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nAmerican(x) ::: x is an American person.\nPolitician(x) ::: x is a politician.\nLawyer(x) ::: x is a lawyer.\nPostmasterGeneral(x) ::: x served as the postmaster general.\nGraduate(x, y, z) ::: x graduated from y with a z degree.\nPracticeLaw(x, y) ::: x practices law with y.\nMarried(x, y) ::: x is married to y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nAmerican(walter) ∧ Politician(walter) ∧ Lawyer(walter) ∧ PostmasterGeneral(walter) ::: Walter Folger Brown was an American politician and lawyer, and served as the postmaster general.\nGraduate(walter, harvardUniversity, bachelorsOfArts) ::: Walter Folger Brown graduated from Harvard University with a Bachelors of Arts.\n∃x (PracticeLaw(x, walter) ∧ PracticeLaw(x, walter)) ::: While they were both in Toledo, Walter Folger Brown's father practiced law with Walter Folger Brown.\nMarried(katherin, walter) ::: Katherin Hafer married Walter Folger Brown.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nGraduate(walter, harvardUniversity, bachelorsOfArts) ::: Walter Folger Brown graduated with a Bachelors of Arts.\n\"\"\""
    ]
  },
  {
    "id": 30,
    "context": [
      "Walter Folger Brown was an American politician and lawyer, and served as the postmaster general.",
      "Walter Folger Brown graduated from Harvard University with a Bachelors of Arts.",
      "While they were both in Toledo, Walter Folger Brown's father practiced law with Walter Folger Brown.",
      "Katherin Hafer married Walter Folger Brown."
    ],
    "question": "Walter Folger Brown's father was in Toledo.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nAmerican(x) ::: x is an American person.\nPolitician(x) ::: x is a politician.\nLawyer(x) ::: x is a lawyer.\nPostmasterGeneral(x) ::: x served as the postmaster general.\nGraduate(x, y, z) ::: x graduated from y with a z degree.\nPracticeLaw(x, y) ::: x practices law with y.\nMarried(x, y) ::: x is married to y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nAmerican(walterFolgerBrown) ∧ Politician(walterFolgerBrown) ∧ Lawyer(walterFolgerBrown) ∧ PostmasterGeneral(walterFolgerBrown) ::: Walter Folger Brown was an American politician and lawyer, and served as the postmaster general.\nGraduate(walterFolgerBrown, harvardUniversity, BachelorsOfArts) ::: Walter Folger Brown graduated from Harvard University with a Bachelors of Arts.\nPracticeLaw(father(walterFolgerBrown), walterFolgerBrown) ::: While they were both in Toledo, Walter Folger Brown's father practiced law with Walter Folger Brown.\nMarried(katherinHafer, walterFolgerBrown) ::: Katherin Hafer married Walter Folger Brown.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n∃x (PracticeLaw(x, walterFolgerBrown)) ::: Walter Folger Brown's father was in Toledo.\n\"\"\""
    ]
  },
  {
    "id": 31,
    "context": [
      "Walter Folger Brown was an American politician and lawyer, and served as the postmaster general.",
      "Walter Folger Brown graduated from Harvard University with a Bachelors of Arts.",
      "While they were both in Toledo, Walter Folger Brown's father practiced law with Walter Folger Brown.",
      "Katherin Hafer married Walter Folger Brown."
    ],
    "question": "Walter Folger Brown was not in Toledo.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nAmerican(x) ::: x is an American person.\nPolitician(x) ::: x is a politician.\nLawyer(x) ::: x is a lawyer.\nPostmasterGeneral(x) ::: x served as the postmaster general.\nGraduate(x, y, z) ::: x graduated from y with a degree in z.\nPracticeLaw(x, y) ::: x practices law with y.\nMarried(x, y) ::: x is married to y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nAmerican(walter) ∧ Politician(walter) ∧ Lawyer(walter) ∧ PostmasterGeneral(walter) ::: Walter Folger Brown was an American politician and lawyer, and served as the postmaster general.\nGraduate(walter, harvardUniversity, bachelorsOfArts) ::: Walter Folger Brown graduated from Harvard University with a Bachelors of Arts.\nPracticeLaw(father(walter), walter) ::: While they were both in Toledo, Walter Folger Brown's father practiced law with Walter Folger Brown.\nMarried(katherin, walter) ::: Katherin Hafer married Walter Folger Brown.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬InToledo(walter) ::: Walter Folger Brown was not in Toledo.\n\"\"\""
    ]
  },
  {
    "id": 1152,
    "context": [
      "All products shipped from China are made in China. ",
      "All products sold in JD are shipped from China. ",
      "All products commonly used in China are sold in JD.",
      "All products favored by young people are commonly used in China. ",
      "MacBook is not made in China and is not commonly used in China."
    ],
    "question": "The MacBook is favored by young people.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nMadeInChina(x) ::: x is made in China.\nShippedFromChina(x) ::: x is shipped from China.\nSoldInJD(x) ::: x is sold in JD.\nCommonlyUsedInChina(x) ::: x is commonly used in China.\nFavoredByYoungPeople(x) ::: x is favored by young people.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (ShippedFromChina(x) → MadeInChina(x)) ::: All products shipped from China are made in China.\n∀x (SoldInJD(x) → ShippedFromChina(x)) ::: All products sold in JD are shipped from China.\n∀x (CommonlyUsedInChina(x) → SoldInJD(x)) ::: All products commonly used in China are sold in JD.\n∀x (FavoredByYoungPeople(x) → CommonlyUsedInChina(x)) ::: All products favored by young people are commonly used in China.\n¬(MadeInChina(macbook) ∧ CommonlyUsedInChina(macbook)) ::: MacBook is not made in China and is not commonly used in China.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nFavoredByYoungPeople(macbook) ::: The MacBook is favored by young people.\n\"\"\""
    ]
  },
  {
    "id": 1153,
    "context": [
      "All products shipped from China are made in China. ",
      "All products sold in JD are shipped from China. ",
      "All products commonly used in China are sold in JD.",
      "All products favored by young people are commonly used in China. ",
      "MacBook is not made in China and is not commonly used in China."
    ],
    "question": "The MacBook is made in China.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nShippedFromChina(x) ::: x is shipped from China.\nMadeInChina(x) ::: x is made in China.\nSoldInJD(x) ::: x is sold in JD.\nCommonlyUsedInChina(x) ::: x is commonly used in China.\nFavoredByYoungPeople(x) ::: x is favored by young people.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (ShippedFromChina(x) → MadeInChina(x)) ::: All products shipped from China are made in China.\n∀x (SoldInJD(x) → ShippedFromChina(x)) ::: All products sold in JD are shipped from China.\n∀x (CommonlyUsedInChina(x) → SoldInJD(x)) ::: All products commonly used in China are sold in JD.\n∀x (FavoredByYoungPeople(x) → CommonlyUsedInChina(x)) ::: All products favored by young people are commonly used in China.\n¬(MadeInChina(macbook) ∧ CommonlyUsedInChina(macbook)) ::: MacBook is not made in China and is not commonly used in China.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬MadeInChina(macbook) ::: The MacBook is made in China.\n\"\"\""
    ]
  },
  {
    "id": 1154,
    "context": [
      "All products shipped from China are made in China. ",
      "All products sold in JD are shipped from China. ",
      "All products commonly used in China are sold in JD.",
      "All products favored by young people are commonly used in China. ",
      "MacBook is not made in China and is not commonly used in China."
    ],
    "question": "The MacBook is favored by young people and commonly used in China.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nMadeInChina(x) ::: x is made in China.\nShippedFromChina(x) ::: x is shipped from China.\nSoldInJD(x) ::: x is sold in JD.\nCommonlyUsedInChina(x) ::: x is commonly used in China.\nFavoredByYoungPeople(x) ::: x is favored by young people.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (ShippedFromChina(x) → MadeInChina(x)) ::: All products shipped from China are made in China.\n∀x (SoldInJD(x) → ShippedFromChina(x)) ::: All products sold in JD are shipped from China.\n∀x (CommonlyUsedInChina(x) → SoldInJD(x)) ::: All products commonly used in China are sold in JD.\n∀x (FavoredByYoungPeople(x) → CommonlyUsedInChina(x)) ::: All products favored by young people are commonly used in China.\n¬(MadeInChina(macbook) ∧ CommonlyUsedInChina(macbook)) ::: MacBook is not made in China and is not commonly used in China.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nFavoredByYoungPeople(macbook) ∧ CommonlyUsedInChina(macbook) ::: The MacBook is favored by young people and commonly used in China.\n\"\"\""
    ]
  },
  {
    "id": 1155,
    "context": [
      "All products shipped from China are made in China. ",
      "All products sold in JD are shipped from China. ",
      "All products commonly used in China are sold in JD.",
      "All products favored by young people are commonly used in China. ",
      "MacBook is not made in China and is not commonly used in China."
    ],
    "question": "The MacBook is either favored by young people or commonly used in China.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nMadeInChina(x) ::: x is made in China.\nShippedFromChina(x) ::: x is shipped from China.\nSoldInJD(x) ::: x is sold in JD.\nCommonlyUsedInChina(x) ::: x is commonly used in China.\nFavoredByYoungPeople(x) ::: x is favored by young people.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (ShippedFromChina(x) → MadeInChina(x)) ::: All products shipped from China are made in China.\n∀x (SoldInJD(x) → ShippedFromChina(x)) ::: All products sold in JD are shipped from China.\n∀x (CommonlyUsedInChina(x) → SoldInJD(x)) ::: All products commonly used in China are sold in JD.\n∀x (FavoredByYoungPeople(x) → CommonlyUsedInChina(x)) ::: All products favored by young people are commonly used in China.\n¬(MadeInChina(macbook) ∧ CommonlyUsedInChina(macbook)) ::: MacBook is not made in China and is not commonly used in China.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nFavoredByYoungPeople(macbook) ⊕ CommonlyUsedInChina(macbook) ::: The MacBook is either favored by young people or commonly used in China.\n\"\"\""
    ]
  },
  {
    "id": 1156,
    "context": [
      "All products shipped from China are made in China. ",
      "All products sold in JD are shipped from China. ",
      "All products commonly used in China are sold in JD.",
      "All products favored by young people are commonly used in China. ",
      "MacBook is not made in China and is not commonly used in China."
    ],
    "question": "If the MacBook is favored by young people and commonly used in China, then it is neither favored by young people nor made in China.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nMadeInChina(x) ::: x is made in China.\nShippedFromChina(x) ::: x is shipped from China.\nSoldInJD(x) ::: x is sold in JD.\nCommonlyUsedInChina(x) ::: x is commonly used in China.\nFavoredByYoungPeople(x) ::: x is favored by young people.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (ShippedFromChina(x) → MadeInChina(x)) ::: All products shipped from China are made in China.\n∀x (SoldInJD(x) → ShippedFromChina(x)) ::: All products sold in JD are shipped from China.\n∀x (CommonlyUsedInChina(x) → SoldInJD(x)) ::: All products commonly used in China are sold in JD.\n∀x (FavoredByYoungPeople(x) → CommonlyUsedInChina(x)) ::: All products favored by young people are commonly used in China.\n¬(MadeInChina(macbook) ∧ CommonlyUsedInChina(macbook)) ::: MacBook is not made in China and is not commonly used in China.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n(FavoredByYoungPeople(macbook) ∧ CommonlyUsedInChina(macbook)) → ¬(FavoredByYoungPeople(macbook) ∨ MadeInChina(macbook)) ::: If the MacBook is favored by young people and commonly used in China, then it is neither favored by young people nor made in China.\n\"\"\""
    ]
  },
  {
    "id": 589,
    "context": [
      "Oxford Circus is a road junction connecting Oxford Street and Regent Street.",
      "Oxford Street is in London.",
      "John Nash designed the construction on Regent Street.",
      "John Nash designed Oxford Circus.",
      "John Nash is an architect in British.",
      "Oxford Circus is the entrance to Oxford Circus tube station which is a part of the Central line in 1900."
    ],
    "question": "Oxford Circus is in London.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nRoadJunction(x) ::: x is a road junction.\nConnects(x, y, z) ::: x connects y and z.\nIn(x, y) ::: x is in y.\nDesign(x, y) ::: x designed y.\nArchitect(x, y) ::: x is an architect in y.\nPartOf(x, y) ::: x is a part of y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nRoadJunction(oxfordCircus) ∧ Connects(oxfordCircus, oxfordStreet, regentStreet) ::: Oxford Circus is a road junction connecting Oxford Street and Regent Street.\nIn(oxfordStreet, london) ::: Oxford Street is in London.\nDesign(johnNash, regentStreet) ∧ Design(johnNash, oxfordCircus) ∧ Architect(johnNash, british) ::: John Nash designed the construction on Regent Street. John Nash designed Oxford Circus. John Nash is an architect in British.\nPartOf(oxfordCircusTubeStation, centralLine) ∧ In(oxfordCircusTubeStation, year1900) ∧ PartOf(oxfordCircus, oxfordCircusTubeStation) ::: Oxford Circus is the entrance to Oxford Circus tube station which is a part of the Central line in 1900.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nIn(oxfordCircus, london) ::: Oxford Circus is in London.\n\"\"\""
    ]
  },
  {
    "id": 590,
    "context": [
      "Oxford Circus is a road junction connecting Oxford Street and Regent Street.",
      "Oxford Street is in London.",
      "John Nash designed the construction on Regent Street.",
      "John Nash designed Oxford Circus.",
      "John Nash is an architect in British.",
      "Oxford Circus is the entrance to Oxford Circus tube station which is a part of the Central line in 1900."
    ],
    "question": "Oxford Circus is designed by a British architect.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nRoadJunction(x) ::: x is a road junction.\nConnects(x, y, z) ::: x connects y and z.\nIn(x, y) ::: x is in y.\nDesign(x, y) ::: x designed y.\nArchitect(x) ::: x is an architect.\nPartOf(x, y) ::: x is a part of y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nRoadJunction(oxfordCircus) ∧ Connects(oxfordCircus, oxfordStreet, regentStreet) ::: Oxford Circus is a road junction connecting Oxford Street and Regent Street.\nIn(oxfordStreet, london) ::: Oxford Street is in London.\nDesign(johnNash, regentStreet) ::: John Nash designed the construction on Regent Street.\nDesign(johnNash, oxfordCircus) ::: John Nash designed Oxford Circus.\nArchitect(johnNash) ∧ In(johnNash, british) ::: John Nash is an architect in British.\nPartOf(oxfordCircusTubeStation, centralLine) ∧ In(oxfordCircusTubeStation, year1900) ::: Oxford Circus is the entrance to Oxford Circus tube station which is a part of the Central line in 1900.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n∃x (Design(british, x) ∧ Architect(british)) ::: Oxford Circus is designed by a British architect.\n\"\"\""
    ]
  },
  {
    "id": 591,
    "context": [
      "Oxford Circus is a road junction connecting Oxford Street and Regent Street.",
      "Oxford Street is in London.",
      "John Nash designed the construction on Regent Street.",
      "John Nash designed Oxford Circus.",
      "John Nash is an architect in British.",
      "Oxford Circus is the entrance to Oxford Circus tube station which is a part of the Central line in 1900."
    ],
    "question": "John Nash designed the Central line in 1900.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nRoadJunction(x) ::: x is a road junction.\nConnects(x, y, z) ::: x connects y and z.\nIn(x, y) ::: x is in y.\nDesign(x, y) ::: x designed y.\nArchitect(x, y) ::: x is an architect in y.\nPartOf(x, y) ::: x is a part of y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nRoadJunction(oxfordCircus) ∧ Connects(oxfordCircus, oxfordStreet, regentStreet) ::: Oxford Circus is a road junction connecting Oxford Street and Regent Street.\nIn(oxfordStreet, london) ::: Oxford Street is in London.\nDesign(johnNash, regentStreet) ∧ Design(johnNash, oxfordCircus) ∧ Architect(johnNash, british) ::: John Nash designed the construction on Regent Street. John Nash designed Oxford Circus. John Nash is an architect in British.\nPartOf(oxfordCircusTubeStation, centralLine) ∧ Publish(oxfordCircusTubeStation, year1900) ::: Oxford Circus is the entrance to Oxford Circus tube station which is a part of the Central line in 1900.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nDesign(johnNash, centralLine) ∧ Publish(centralLine, year1900) ::: John Nash designed the Central line in 1900.\n\"\"\""
    ]
  },
  {
    "id": 592,
    "context": [
      "Oxford Circus is a road junction connecting Oxford Street and Regent Street.",
      "Oxford Street is in London.",
      "John Nash designed the construction on Regent Street.",
      "John Nash designed Oxford Circus.",
      "John Nash is an architect in British.",
      "Oxford Circus is the entrance to Oxford Circus tube station which is a part of the Central line in 1900."
    ],
    "question": "Regent Street is not in London.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nRoadJunction(x) ::: x is a road junction.\nConnects(x, y, z) ::: x connects y and z.\nIn(x, y) ::: x is in y.\nDesign(x, y) ::: x designed y.\nArchitect(x, y) ::: x is an architect in y.\nPartOf(x, y) ::: x is a part of y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nRoadJunction(oxfordCircus) ∧ Connects(oxfordCircus, oxfordStreet, regentStreet) ::: Oxford Circus is a road junction connecting Oxford Street and Regent Street.\nIn(oxfordStreet, london) ::: Oxford Street is in London.\nDesign(johnNash, regentStreet) ∧ Design(johnNash, oxfordCircus) ::: John Nash designed the construction on Regent Street. John Nash designed Oxford Circus.\nArchitect(johnNash, british) ::: John Nash is an architect in British.\nPartOf(oxfordCircusTubeStation, centralLine) ∧ In(oxfordCircusTubeStation, year1900) ::: Oxford Circus is the entrance to Oxford Circus tube station which is a part of the Central line in 1900.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬In(regentStreet, london) ::: Regent Street is not in London.\n\"\"\""
    ]
  },
  {
    "id": 1374,
    "context": [
      "An animal is either a cat or a dog.",
      "All dogs bark.",
      "Ghosts do not exist.",
      "If something barks, then it is not alive.",
      "A thing is either alive or dead.",
      "Jojo is not dead."
    ],
    "question": "Jojo is a ghost.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nCat(x) ::: x is a cat.\nDog(x) ::: x is a dog.\nBark(x) ::: x barks.\nAlive(x) ::: x is alive.\nDead(x) ::: x is dead.\nExist(x) ::: x exists.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Animal(x) ↔ (Cat(x) ∨ Dog(x))) ::: An animal is either a cat or a dog.\n∀x (Dog(x) → Bark(x)) ::: All dogs bark.\n¬Exist(ghost) ::: Ghosts do not exist.\n∀x (Bark(x) → ¬Alive(x)) ::: If something barks, then it is not alive.\n∀x (Alive(x) ⊕ Dead(x)) ::: A thing is either alive or dead.\n¬Dead(jojo) ::: Jojo is not dead.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬Alive(jojo) ::: Jojo is a ghost.\n\"\"\""
    ]
  },
  {
    "id": 1375,
    "context": [
      "An animal is either a cat or a dog.",
      "All dogs bark.",
      "Ghosts do not exist.",
      "If something barks, then it is not alive.",
      "A thing is either alive or dead.",
      "Jojo is not dead."
    ],
    "question": "Jojo is a cat or a ghost.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nCat(x) ::: x is a cat.\nDog(x) ::: x is a dog.\nBark(x) ::: x barks.\nExist(x) ::: x exists.\nAlive(x) ::: x is alive.\nDead(x) ::: x is dead.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Animal(x) ↔ (Cat(x) ∨ Dog(x))) ::: An animal is either a cat or a dog.\n∀x (Dog(x) → Bark(x)) ::: All dogs bark.\n¬Exist(ghost) ::: Ghosts do not exist.\n∀x (Bark(x) → ¬Alive(x)) ::: If something barks, then it is not alive.\n∀x (Alive(x) ∨ Dead(x)) ::: A thing is either alive or dead.\n¬Dead(jojo) ::: Jojo is not dead.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nCat(jojo) ∨ Exist(ghost) ::: Jojo is a cat or a ghost.\n\"\"\""
    ]
  },
  {
    "id": 1376,
    "context": [
      "An animal is either a cat or a dog.",
      "All dogs bark.",
      "Ghosts do not exist.",
      "If something barks, then it is not alive.",
      "A thing is either alive or dead.",
      "Jojo is not dead."
    ],
    "question": "If Jojo is a cat or a ghost, then Jojo either barks or is a dog.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nCat(x) ::: x is a cat.\nDog(x) ::: x is a dog.\nBark(x) ::: x barks.\nAlive(x) ::: x is alive.\nDead(x) ::: x is dead.\nExist(x) ::: x exists.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Animal(x) ↔ (Cat(x) ∨ Dog(x))) ::: An animal is either a cat or a dog.\n∀x (Dog(x) → Bark(x)) ::: All dogs bark.\n¬Exist(ghost) ::: Ghosts do not exist.\n∀x (Bark(x) → ¬Alive(x)) ::: If something barks, then it is not alive.\n∀x (Alive(x) ∨ Dead(x)) ::: A thing is either alive or dead.\n¬Dead(jojo) ::: Jojo is not dead.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n(Cat(jojo) ∨ Ghost(jojo)) → (Bark(jojo) ∨ Dog(jojo)) ::: If Jojo is a cat or a ghost, then Jojo either barks or is a dog.\n\"\"\""
    ]
  },
  {
    "id": 1269,
    "context": [
      "All animals that are tigers are cats.",
      "No cats are dogs.",
      "All Bengal tigers are tigers.",
      "Everything that is a husky is a dog.",
      "Fido is either a Bengal tiger or a cat."
    ],
    "question": "Fido is a husky.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nTiger(x) ::: x is a tiger.\nCat(x) ::: x is a cat.\nDog(x) ::: x is a dog.\nBengalTiger(x) ::: x is a Bengal tiger.\nHusky(x) ::: x is a husky.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Tiger(x) → Cat(x)) ::: All animals that are tigers are cats.\n∀x (Cat(x) → ¬Dog(x)) ::: No cats are dogs.\n∀x (BengalTiger(x) → Tiger(x)) ::: All Bengal tigers are tigers.\n∀x (Husky(x) → Dog(x)) ::: Everything that is a husky is a dog.\n(BengalTiger(fido) ∨ Cat(fido)) ::: Fido is either a Bengal tiger or a cat.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nHusky(fido) ::: Fido is a husky.\n\"\"\""
    ]
  },
  {
    "id": 1270,
    "context": [
      "All animals that are tigers are cats.",
      "No cats are dogs.",
      "All Bengal tigers are tigers.",
      "Everything that is a husky is a dog.",
      "Fido is either a Bengal tiger or a cat."
    ],
    "question": "Fido is not a husky.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nTiger(x) ::: x is a tiger.\nCat(x) ::: x is a cat.\nDog(x) ::: x is a dog.\nBengalTiger(x) ::: x is a Bengal tiger.\nHusky(x) ::: x is a husky.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Tiger(x) → Cat(x)) ::: All animals that are tigers are cats.\n∀x (Cat(x) → ¬Dog(x)) ::: No cats are dogs.\n∀x (BengalTiger(x) → Tiger(x)) ::: All Bengal tigers are tigers.\n∀x (Husky(x) → Dog(x)) ::: Everything that is a husky is a dog.\n(Fido = BengalTiger) ∨ (Fido = Cat) ::: Fido is either a Bengal tiger or a cat.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬Husky(Fido) ::: Fido is not a husky.\n\"\"\""
    ]
  },
  {
    "id": 1271,
    "context": [
      "All animals that are tigers are cats.",
      "No cats are dogs.",
      "All Bengal tigers are tigers.",
      "Everything that is a husky is a dog.",
      "Fido is either a Bengal tiger or a cat."
    ],
    "question": "Fido is a Bengal tiger.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nTiger(x) ::: x is a tiger.\nCat(x) ::: x is a cat.\nDog(x) ::: x is a dog.\nBengalTiger(x) ::: x is a Bengal tiger.\nHusky(x) ::: x is a husky.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Tiger(x) → Cat(x)) ::: All animals that are tigers are cats.\n∀x (Cat(x) → ¬Dog(x)) ::: No cats are dogs.\n∀x (BengalTiger(x) → Tiger(x)) ::: All Bengal tigers are tigers.\n∀x (Husky(x) → Dog(x)) ::: Everything that is a husky is a dog.\n(BengalTiger(fido) ∨ Cat(fido)) ::: Fido is either a Bengal tiger or a cat.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nBengalTiger(fido) ::: Fido is a Bengal tiger.\n\"\"\""
    ]
  },
  {
    "id": 1272,
    "context": [
      "All animals that are tigers are cats.",
      "No cats are dogs.",
      "All Bengal tigers are tigers.",
      "Everything that is a husky is a dog.",
      "Fido is either a Bengal tiger or a cat."
    ],
    "question": "Fido is neither a dog nor a husky.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nTiger(x) ::: x is a tiger.\nCat(x) ::: x is a cat.\nDog(x) ::: x is a dog.\nBengalTiger(x) ::: x is a Bengal tiger.\nHusky(x) ::: x is a husky.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Tiger(x) → Cat(x)) ::: All animals that are tigers are cats.\n∀x (Cat(x) → ¬Dog(x)) ::: No cats are dogs.\n∀x (BengalTiger(x) → Tiger(x)) ::: All Bengal tigers are tigers.\n∀x (Husky(x) → Dog(x)) ::: Everything that is a husky is a dog.\n(Fido = BengalTiger) ∨ (Fido = Cat) ::: Fido is either a Bengal tiger or a cat.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬Dog(fido) ∧ ¬Husky(fido) ::: Fido is neither a dog nor a husky.\n\"\"\""
    ]
  },
  {
    "id": 196,
    "context": [
      "If a city hold a Summer Olympics, and the city is a US city, then the Summer Olympics will be in the US.",
      "If a city is in a state which is in US, the city is a US city.",
      "If a city in a state, and a Summer Olympics is in this city, then the Summer Olympics is in this state.",
      "The 2028 Summer Olympics is scheduled to take place in Los Angeles(LA).",
      "LA is a city in California(CA).",
      "Atlanta is a US city.",
      "Atlanta is in Georgia(CA).",
      "CA is a state in the United States.",
      "Boxing, modern pentathlon, and weightlifting will be removed from The 2028 Summer Olympics.",
      "Atlanta in the United States hold the 1996 Summer Olympics."
    ],
    "question": "The 2028 Summer Olympics will take place in the US.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nHold(x, y) ::: City x holds event y.\nUSCity(x) ::: x is a city in the US.\nSummerOlympics(x) ::: x is the Summer Olympics.\nState(x) ::: x is a state.\nIn(x, y) ::: City x is in state y.\nScheduled(x, y) ::: Event x is scheduled to take place in city y.\nRemove(x, y) ::: Event x will be removed from event y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Hold(x, SummerOlympics) ∧ USCity(x) → In(SummerOlympics, US)) ::: If a city holds a Summer Olympics, and the city is a US city, then the Summer Olympics will be in the US.\n∀x (In(x, State(y)) → USCity(x)) ::: If a city is in a state which is in the US, the city is a US city.\n∀x (In(City(x), State(y)) ∧ Hold(SummerOlympics, City(x)) → In(SummerOlympics, State(y))) ::: If a city is in a state, and a Summer Olympics is in this city, then the Summer Olympics is in this state.\nScheduled(2028SummerOlympics, LA) ::: The 2028 Summer Olympics is scheduled to take place in Los Angeles(LA).\nIn(LA, CA) ::: LA is a city in California(CA).\nUSCity(Atlanta) ::: Atlanta is a US city.\nIn(Atlanta, Georgia) ::: Atlanta is in Georgia(CA).\nState(CA) ∧ In(CA, US) ::: CA is a state in the United States.\nRemove(boxing, 2028SummerOlympics) ∧ Remove(modernPentathlon, 2028SummerOlympics) ∧ Remove(weightlifting, 2028SummerOlympics) ::: Boxing, modern pentathlon, and weightlifting will be removed from The 2028 Summer Olympics.\nHold(Atlanta, 1996SummerOlympics) ::: Atlanta in the United States hold the 1996 Summer Olympics.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nIn(2028SummerOlympics, US) ::: The 2028 Summer Olympics will take place in the US.\n\"\"\""
    ]
  },
  {
    "id": 197,
    "context": [
      "If a city hold a Summer Olympics, and the city is a US city, then the Summer Olympics will be in the US.",
      "If a city is in a state which is in US, the city is a US city.",
      "If a city in a state, and a Summer Olympics is in this city, then the Summer Olympics is in this state.",
      "The 2028 Summer Olympics is scheduled to take place in Los Angeles(LA).",
      "LA is a city in California(CA).",
      "Atlanta is a US city.",
      "Atlanta is in Georgia(CA).",
      "CA is a state in the United States.",
      "Boxing, modern pentathlon, and weightlifting will be removed from The 2028 Summer Olympics.",
      "Atlanta in the United States hold the 1996 Summer Olympics."
    ],
    "question": "The 1996 Summer Olympics is not in Georgia.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nHold(x, y) ::: City x holds event y.\nUSCity(x) ::: x is a city in the US.\nSummerOlympics(x) ::: x is the Summer Olympics.\nIn(x, y) ::: City x is in state y.\nState(x) ::: x is a state.\nScheduled(x, y) ::: Event x is scheduled to take place in city y.\nRemove(x, y) ::: Event x will be removed from y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Hold(x, SummerOlympics) ∧ USCity(x) → In(SummerOlympics, US)) ::: If a city holds a Summer Olympics, and the city is a US city, then the Summer Olympics will be in the US.\n∀x (In(x, State(y)) → USCity(x)) ::: If a city is in a state which is in the US, the city is a US city.\n∀x (In(x, State(y)) ∧ Hold(x, SummerOlympics) → In(SummerOlympics, State(y))) ::: If a city is in a state, and a Summer Olympics is in this city, then the Summer Olympics is in this state.\nScheduled(2028SummerOlympics, LA) ::: The 2028 Summer Olympics is scheduled to take place in Los Angeles(LA).\nIn(LA, CA) ::: LA is a city in California(CA).\nUSCity(Atlanta) ::: Atlanta is a US city.\nIn(Atlanta, Georgia) ::: Atlanta is in Georgia(CA).\nState(CA) ∧ In(CA, US) ::: CA is a state in the United States.\nRemove(boxing, 2028SummerOlympics) ∧ Remove(modernPentathlon, 2028SummerOlympics) ∧ Remove(weightlifting, 2028SummerOlympics) ::: Boxing, modern pentathlon, and weightlifting will be removed from The 2028 Summer Olympics.\nHold(Atlanta, 1996SummerOlympics) ∧ In(Atlanta, US) ::: Atlanta in the United States hold the 1996 Summer Olympics.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬In(1996SummerOlympics, Georgia) ::: The 1996 Summer Olympics is not in Georgia.\n\"\"\""
    ]
  },
  {
    "id": 198,
    "context": [
      "If a city hold a Summer Olympics, and the city is a US city, then the Summer Olympics will be in the US.",
      "If a city is in a state which is in US, the city is a US city.",
      "If a city in a state, and a Summer Olympics is in this city, then the Summer Olympics is in this state.",
      "The 2028 Summer Olympics is scheduled to take place in Los Angeles(LA).",
      "LA is a city in California(CA).",
      "Atlanta is a US city.",
      "Atlanta is in Georgia(CA).",
      "CA is a state in the United States.",
      "Boxing, modern pentathlon, and weightlifting will be removed from The 2028 Summer Olympics.",
      "Atlanta in the United States hold the 1996 Summer Olympics."
    ],
    "question": "Skateboarding will appear at The 2028 Summer Olympics.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nHold(x, y) ::: City x holds event y.\nUSCity(x) ::: City x is in the US.\nIn(x, y) ::: City x is in state y.\nScheduled(x, y) ::: Event x is scheduled to take place in city y.\nCity(x) ::: x is a city.\nState(x) ::: x is a state.\nRemove(x, y) ::: Event x will be removed from y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Hold(x, SummerOlympics) ∧ USCity(x) → In(SummerOlympics, US)) ::: If a city holds a Summer Olympics, and the city is a US city, then the Summer Olympics will be in the US.\n∀x (In(x, State(y)) → USCity(x)) ::: If a city is in a state which is in the US, the city is a US city.\n∀x (In(x, State(y)) ∧ Hold(x, SummerOlympics) → In(SummerOlympics, State(y))) ::: If a city is in a state, and a Summer Olympics is in this city, then the Summer Olympics is in this state.\nScheduled(2028SummerOlympics, LA) ::: The 2028 Summer Olympics is scheduled to take place in Los Angeles(LA).\nIn(LA, CA) ::: LA is a city in California(CA).\nUSCity(Atlanta) ::: Atlanta is a US city.\nIn(Atlanta, Georgia) ::: Atlanta is in Georgia(CA).\nState(CA) ∧ In(CA, US) ::: CA is a state in the United States.\nRemove(boxing, 2028SummerOlympics) ∧ Remove(modernPentathlon, 2028SummerOlympics) ∧ Remove(weightlifting, 2028SummerOlympics) ::: Boxing, modern pentathlon, and weightlifting will be removed from The 2028 Summer Olympics.\nHold(Atlanta, 1996SummerOlympics) ∧ In(Atlanta, US) ::: Atlanta in the United States hold the 1996 Summer Olympics.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬Remove(skateboarding, 2028SummerOlympics) ::: Skateboarding will appear at The 2028 Summer Olympics.\n\"\"\""
    ]
  },
  {
    "id": 23,
    "context": [
      "The taiga vole is a large vole found in northwestern North America. ",
      "Cats like playing with all voles.",
      "The taiga vole lives in the boreal taiga zone.",
      "The boreal taiga zone in North America is a cold place to live in.",
      "Taiga vole is typically much larger than most other North American voles, especially those from the genus Microtus."
    ],
    "question": "Cats like playing with taiga vole.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nLarge(x) ::: x is a large vole.\nVole(x) ::: x is a vole.\nFoundIn(x, y) ::: x is found in y.\nLikes(x, y) ::: x likes playing with y.\nLivesIn(x, y) ::: x lives in y.\nColdPlace(x) ::: x is a cold place to live in.\nMuchLarger(x, y) ::: x is much larger than y.\nGenus(x, y) ::: x is from the genus y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nVole(taigaVole) ∧ Large(taigaVole) ∧ FoundIn(taigaVole, northwesternNorthAmerica) ::: The taiga vole is a large vole found in northwestern North America.\n∀x (Vole(x) → Likes(cats, x)) ::: Cats like playing with all voles.\nLivesIn(taigaVole, borealTaigaZone) ::: The taiga vole lives in the boreal taiga zone.\nLivesIn(borealTaigaZone, northAmerica) ∧ ColdPlace(northAmerica) ::: The boreal taiga zone in North America is a cold place to live in.\nMuchLarger(taigaVole, otherVoles) ∧ Genus(otherVoles, Microtus) ::: Taiga vole is typically much larger than most other North American voles, especially those from the genus Microtus.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nLikes(cats, taigaVole) ::: Cats like playing with taiga vole.\n\"\"\""
    ]
  },
  {
    "id": 24,
    "context": [
      "The taiga vole is a large vole found in northwestern North America. ",
      "Cats like playing with all voles.",
      "The taiga vole lives in the boreal taiga zone.",
      "The boreal taiga zone in North America is a cold place to live in.",
      "Taiga vole is typically much larger than most other North American voles, especially those from the genus Microtus."
    ],
    "question": "Taiga vole's living place is not cold.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nVole(x) ::: x is a vole.\nLarge(x) ::: x is a large vole.\nFoundIn(x, y) ::: x is found in y.\nCatsLike(x) ::: Cats like playing with x.\nLivesIn(x, y) ::: x lives in y.\nColdPlace(x) ::: x is a cold place to live in.\nMuchLarger(x, y) ::: x is much larger than y.\nGenus(x, y) ::: x is from the genus y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nVole(taigaVole) ∧ Large(taigaVole) ∧ FoundIn(taigaVole, northwesternNorthAmerica) ::: The taiga vole is a large vole found in northwestern North America.\n∀x (Vole(x) → CatsLike(x)) ::: Cats like playing with all voles.\nLivesIn(taigaVole, borealTaigaZone) ::: The taiga vole lives in the boreal taiga zone.\nLivesIn(borealTaigaZone, northAmerica) ∧ ColdPlace(borealTaigaZone) ::: The boreal taiga zone in North America is a cold place to live in.\nMuchLarger(taigaVole, otherVoles) ∧ Genus(otherVoles, Microtus) ::: Taiga vole is typically much larger than most other North American voles, especially those from the genus Microtus.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬ColdPlace(borealTaigaZone) ::: Taiga vole's living place is not cold.\n\"\"\""
    ]
  },
  {
    "id": 1046,
    "context": [
      "Either in women or in men. ",
      "No men have breast cancer.",
      "Either breast cancer or non-breast cancer. ",
      "No type of cancer is without a tumor.",
      "All non-breast cancers are a type of cancer.",
      "If adenocarcinoma is a type of cancer or without a tumor, then adenocarcinoma is in women or without a tumor."
    ],
    "question": "Adenocarcinoma is a breast cancer.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nInWomen(x) ::: x is in women.\nInMen(x) ::: x is in men.\nBreastCancer(x) ::: x is breast cancer.\nNonBreastCancer(x) ::: x is non-breast cancer.\nCancer(x) ::: x is a type of cancer.\nTumor(x) ::: x has a tumor.\nAdenocarcinoma(x) ::: x is adenocarcinoma.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nInWomen(x) ∨ InMen(x) ::: Either in women or in men.\n¬∃x (InMen(x) ∧ BreastCancer(x)) ::: No men have breast cancer.\nBreastCancer(x) ∨ NonBreastCancer(x) ::: Either breast cancer or non-breast cancer.\n∀x (Cancer(x) → Tumor(x)) ::: No type of cancer is without a tumor.\n∀x (NonBreastCancer(x) → Cancer(x)) ::: All non-breast cancers are a type of cancer.\n(Cancer(adenocarcinoma) ∨ ¬Tumor(adenocarcinoma)) → (InWomen(adenocarcinoma) ∨ ¬Tumor(adenocarcinoma)) ::: If adenocarcinoma is a type of cancer or without a tumor, then adenocarcinoma is in women or without a tumor.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nBreastCancer(adenocarcinoma) ::: Adenocarcinoma is a breast cancer.\n\"\"\""
    ]
  },
  {
    "id": 1047,
    "context": [
      "Either in women or in men. ",
      "No men have breast cancer.",
      "Either breast cancer or non-breast cancer. ",
      "No type of cancer is without a tumor.",
      "All non-breast cancers are a type of cancer.",
      "If adenocarcinoma is a type of cancer or without a tumor, then adenocarcinoma is in women or without a tumor."
    ],
    "question": "Adenocarcinoma is in women.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nInWomen(x) ::: x is in women.\nInMen(x) ::: x is in men.\nBreastCancer(x) ::: x is breast cancer.\nNonBreastCancer(x) ::: x is non-breast cancer.\nCancer(x) ::: x is a type of cancer.\nTumor(x) ::: x has a tumor.\nAdenocarcinoma(x) ::: x is adenocarcinoma.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nInWomen(x) ∨ InMen(x) ::: Either in women or in men.\n∀x (InMen(x) → ¬BreastCancer(x)) ::: No men have breast cancer.\nBreastCancer(x) ∨ NonBreastCancer(x) ::: Either breast cancer or non-breast cancer.\n∀x (Cancer(x) → Tumor(x)) ::: No type of cancer is without a tumor.\n∀x (NonBreastCancer(x) → Cancer(x)) ::: All non-breast cancers are a type of cancer.\n(Cancer(adenocarcinoma) ∨ ¬Tumor(adenocarcinoma)) → (InWomen(adenocarcinoma) ∨ ¬Tumor(adenocarcinoma)) ::: If adenocarcinoma is a type of cancer or without a tumor, then adenocarcinoma is in women or without a tumor.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nInWomen(adenocarcinoma) ::: Adenocarcinoma is in women.\n\"\"\""
    ]
  },
  {
    "id": 1048,
    "context": [
      "Either in women or in men. ",
      "No men have breast cancer.",
      "Either breast cancer or non-breast cancer. ",
      "No type of cancer is without a tumor.",
      "All non-breast cancers are a type of cancer.",
      "If adenocarcinoma is a type of cancer or without a tumor, then adenocarcinoma is in women or without a tumor."
    ],
    "question": "If adenocarcinoma is in women or without a tumor, then adenocarcinoma is without a tumor and a non-breast cancer.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nInWomen(x) ::: x is in women.\nInMen(x) ::: x is in men.\nBreastCancer(x) ::: x is breast cancer.\nNonBreastCancer(x) ::: x is non-breast cancer.\nCancer(x) ::: x is a type of cancer.\nTumor(x) ::: x has a tumor.\nAdenocarcinoma(x) ::: x is adenocarcinoma.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nInWomen(x) ∨ InMen(x) ::: Either in women or in men.\n∀x (InMen(x) → ¬BreastCancer(x)) ::: No men have breast cancer.\nBreastCancer(x) ∨ NonBreastCancer(x) ::: Either breast cancer or non-breast cancer.\n∀x (Cancer(x) → Tumor(x)) ::: No type of cancer is without a tumor.\n∀x (NonBreastCancer(x) → Cancer(x)) ::: All non-breast cancers are a type of cancer.\n(Adenocarcinoma(x) ∨ ¬Tumor(x)) → (InWomen(x) ∨ ¬Tumor(x)) ::: If adenocarcinoma is a type of cancer or without a tumor, then adenocarcinoma is in women or without a tumor.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n(Adenocarcinoma(x) ∨ InWomen(x)) → (¬Tumor(x) ∧ NonBreastCancer(x)) ::: If adenocarcinoma is in women or without a tumor, then adenocarcinoma is without a tumor and a non-breast cancer.\n\"\"\""
    ]
  },
  {
    "id": 175,
    "context": [
      "Some monitors equipped in the lab are produced by the company named AOC. ",
      "All monitors equipped in the lab are cheaper than their original prices. ",
      "If the monitor is cheaper than its original prices, then its resolution is 1080p. ",
      "If a monitor is with a resolution of 1080p, then it does not support the type-c port. ",
      "LG34 is equipped in the lab.  "
    ],
    "question": "LG34 machine is produced by AOC.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nProducedBy(x, y) ::: x is produced by the company y.\nEquipped(x) ::: x is equipped in the lab.\nCheaper(x) ::: x is cheaper than its original price.\nResolution(x, y) ::: x has a resolution of y.\nSupports(x, y) ::: x supports the feature y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∃x (Equipped(x) ∧ ProducedBy(x, AOC)) ::: Some monitors equipped in the lab are produced by the company named AOC.\n∀x (Equipped(x) → Cheaper(x)) ::: All monitors equipped in the lab are cheaper than their original prices.\n∀x (Cheaper(x) → Resolution(x, 1080p)) ::: If the monitor is cheaper than its original prices, then its resolution is 1080p.\n∀x (Resolution(x, 1080p) → ¬Supports(x, type-c port)) ::: If a monitor is with a resolution of 1080p, then it does not support the type-c port.\nEquipped(LG34) ::: LG34 is equipped in the lab.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nProducedBy(LG34, AOC) ::: LG34 machine is produced by AOC.\n\"\"\""
    ]
  },
  {
    "id": 176,
    "context": [
      "Some monitors equipped in the lab are produced by the company named AOC. ",
      "All monitors equipped in the lab are cheaper than their original prices. ",
      "If the monitor is cheaper than its original prices, then its resolution is 1080p. ",
      "If a monitor is with a resolution of 1080p, then it does not support the type-c port. ",
      "LG34 is equipped in the lab.  "
    ],
    "question": "LG34 machine does not support the type-c port.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nEquipped(x) ::: x is equipped in the lab.\nProducedBy(x, y) ::: x is produced by company y.\nCheaper(x) ::: x is cheaper than its original price.\nResolution(x, y) ::: x has a resolution of y.\nSupports(x, y) ::: x supports feature y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∃x (Equipped(x) ∧ ProducedBy(x, AOC)) ::: Some monitors equipped in the lab are produced by the company named AOC.\n∀x (Equipped(x) → Cheaper(x)) ::: All monitors equipped in the lab are cheaper than their original prices.\n∀x (Cheaper(x) → Resolution(x, 1080p)) ::: If the monitor is cheaper than its original prices, then its resolution is 1080p.\n∀x (Resolution(x, 1080p) → ¬Supports(x, type-c)) ::: If a monitor is with a resolution of 1080p, then it does not support the type-c port.\nEquipped(LG34) ::: LG34 is equipped in the lab.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬Supports(LG34, type-c) ::: LG34 machine does not support the type-c port.\n\"\"\""
    ]
  },
  {
    "id": 177,
    "context": [
      "Some monitors equipped in the lab are produced by the company named AOC. ",
      "All monitors equipped in the lab are cheaper than their original prices. ",
      "If the monitor is cheaper than its original prices, then its resolution is 1080p. ",
      "If a monitor is with a resolution of 1080p, then it does not support the type-c port. ",
      "LG34 is equipped in the lab.  "
    ],
    "question": "LG34 is not with a resolution of 1080p.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nProducedBy(x, y) ::: x is produced by the company named y.\nEquipped(x) ::: x is equipped in the lab.\nCheaper(x) ::: x is cheaper than its original price.\nResolution(x, y) ::: x has a resolution of y.\nSupports(x, y) ::: x supports the type-c port.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∃x (Equipped(x) ∧ ProducedBy(x, AOC)) ::: Some monitors equipped in the lab are produced by the company named AOC.\n∀x (Equipped(x) → Cheaper(x)) ::: All monitors equipped in the lab are cheaper than their original prices.\n∀x (Cheaper(x) → Resolution(x, 1080p)) ::: If the monitor is cheaper than its original prices, then its resolution is 1080p.\n∀x (Resolution(x, 1080p) → ¬Supports(x, type-c)) ::: If a monitor is with a resolution of 1080p, then it does not support the type-c port.\nEquipped(LG34) ::: LG34 is equipped in the lab.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬Resolution(LG34, 1080p) ::: LG34 is not with a resolution of 1080p.\n\"\"\""
    ]
  },
  {
    "id": 1160,
    "context": [
      "All fruits sold in Boston are shipped from Columbia. ",
      "Some fruits sold in New Haven are shipped from Mexico.",
      "No fruits shipped from Columbia are fruits sold in New York. ",
      "Avocadoe are a kind of fruit sold in New York or New York. ",
      "Avocadoe are either shipped from Columbia and sold in New Haven, or neither shipped from Columbia nor sold in New Haven. "
    ],
    "question": "Avocados are a kind of fruit sold in New York.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nSoldInBoston(x) ::: x is a fruit sold in Boston.\nShippedFromColumbia(x) ::: x is a fruit shipped from Columbia.\nSoldInNewHaven(x) ::: x is a fruit sold in New Haven.\nShippedFromMexico(x) ::: x is a fruit shipped from Mexico.\nSoldInNewYork(x) ::: x is a fruit sold in New York.\nKindOfFruit(x) ::: x is a kind of fruit.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (SoldInBoston(x) → ShippedFromColumbia(x)) ::: All fruits sold in Boston are shipped from Columbia.\n∃x (SoldInNewHaven(x) ∧ ShippedFromMexico(x)) ::: Some fruits sold in New Haven are shipped from Mexico.\n∀x (ShippedFromColumbia(x) → ¬SoldInNewYork(x)) ::: No fruits shipped from Columbia are fruits sold in New York.\nKindOfFruit(avocadoe) ∧ (SoldInNewYork(avocadoe) ∨ SoldInNewYork(avocadoe)) ::: Avocadoe are a kind of fruit sold in New York or New York.\n¬(ShippedFromColumbia(avocadoe) ∧ SoldInNewHaven(avocadoe)) → (ShippedFromColumbia(avocadoe) ∧ SoldInNewHaven(avocadoe)) ⊕ ¬(ShippedFromColumbia(avocadoe) ∨ SoldInNewHaven(avocadoe)) ::: Avocadoe are either shipped from Columbia and sold in New Haven, or neither shipped from Columbia nor sold in New Haven.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nSoldInNewYork(avocadoe) ::: Avocados are a kind of fruit sold in New York.\n\"\"\""
    ]
  },
  {
    "id": 1161,
    "context": [
      "All fruits sold in Boston are shipped from Columbia. ",
      "Some fruits sold in New Haven are shipped from Mexico.",
      "No fruits shipped from Columbia are fruits sold in New York. ",
      "Avocadoe are a kind of fruit sold in New York or New York. ",
      "Avocadoe are either shipped from Columbia and sold in New Haven, or neither shipped from Columbia nor sold in New Haven. "
    ],
    "question": "Avocados are either sold in New York or sold in New Haven.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nSoldInBoston(x) ::: x is a fruit sold in Boston.\nShippedFromColumbia(x) ::: x is a fruit shipped from Columbia.\nSoldInNewHaven(x) ::: x is a fruit sold in New Haven.\nShippedFromMexico(x) ::: x is a fruit shipped from Mexico.\nSoldInNewYork(x) ::: x is a fruit sold in New York.\nAvocado(x) ::: x is an avocado.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (SoldInBoston(x) → ShippedFromColumbia(x)) ::: All fruits sold in Boston are shipped from Columbia.\n∃x (SoldInNewHaven(x) ∧ ShippedFromMexico(x)) ::: Some fruits sold in New Haven are shipped from Mexico.\n∀x (ShippedFromColumbia(x) → ¬SoldInNewYork(x)) ::: No fruits shipped from Columbia are fruits sold in New York.\n(SoldInNewYork(avocado) ∨ SoldInNewHaven(avocado)) ::: Avocadoe are a kind of fruit sold in New York or New York.\n¬(ShippedFromColumbia(avocado) ∧ SoldInNewHaven(avocado)) → (ShippedFromColumbia(avocado) ∧ SoldInNewHaven(avocado)) ⊕ ¬(ShippedFromColumbia(avocado) ∨ SoldInNewHaven(avocado)) ::: Avocadoe are either shipped from Columbia and sold in New Haven, or neither shipped from Columbia nor sold in New Haven.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nSoldInNewYork(avocado) ∨ SoldInNewHaven(avocado) ::: Avocados are either sold in New York or sold in New Haven.\n\"\"\""
    ]
  },
  {
    "id": 1162,
    "context": [
      "All fruits sold in Boston are shipped from Columbia. ",
      "Some fruits sold in New Haven are shipped from Mexico.",
      "No fruits shipped from Columbia are fruits sold in New York. ",
      "Avocadoe are a kind of fruit sold in New York or New York. ",
      "Avocadoe are either shipped from Columbia and sold in New Haven, or neither shipped from Columbia nor sold in New Haven. "
    ],
    "question": "Avocados are either sold in New Haven or sold in Boston",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nSoldInBoston(x) ::: x is a fruit sold in Boston.\nShippedFromColumbia(x) ::: x is a fruit shipped from Columbia.\nSoldInNewHaven(x) ::: x is a fruit sold in New Haven.\nShippedFromMexico(x) ::: x is a fruit shipped from Mexico.\nSoldInNewYork(x) ::: x is a fruit sold in New York.\nKindOf(x, y) ::: x is a kind of y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (SoldInBoston(x) → ShippedFromColumbia(x)) ::: All fruits sold in Boston are shipped from Columbia.\n∃x (SoldInNewHaven(x) ∧ ShippedFromMexico(x)) ::: Some fruits sold in New Haven are shipped from Mexico.\n∀x (ShippedFromColumbia(x) → ¬SoldInNewYork(x)) ::: No fruits shipped from Columbia are fruits sold in New York.\nKindOf(avocado, fruit) ∧ (SoldInNewYork(avocado) ∨ SoldInNewHaven(avocado)) ::: Avocadoe are a kind of fruit sold in New York or New York.\n¬(ShippedFromColumbia(avocado) ∧ SoldInNewHaven(avocado)) → (ShippedFromColumbia(avocado) ∧ SoldInNewHaven(avocado)) ⊕ ¬(ShippedFromColumbia(avocado) ∨ SoldInNewHaven(avocado)) ::: Avocadoe are either shipped from Columbia and sold in New Haven, or neither shipped from Columbia nor sold in New Haven.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nSoldInNewHaven(avocado) ∨ SoldInBoston(avocado) ::: Avocados are either sold in New Haven or sold in Boston.\n\"\"\""
    ]
  },
  {
    "id": 1163,
    "context": [
      "All fruits sold in Boston are shipped from Columbia. ",
      "Some fruits sold in New Haven are shipped from Mexico.",
      "No fruits shipped from Columbia are fruits sold in New York. ",
      "Avocadoe are a kind of fruit sold in New York or New York. ",
      "Avocadoe are either shipped from Columbia and sold in New Haven, or neither shipped from Columbia nor sold in New Haven. "
    ],
    "question": "If avocados are not sold in New York and not shipped from Columbia, then they are neither sold in New York nor New Haven.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nSoldIn(x, y) ::: x is sold in y.\nShippedFrom(x, y) ::: x is shipped from y.\nFruit(x) ::: x is a fruit.\nColumbia(x) ::: x is shipped from Columbia.\nNewHaven(x) ::: x is sold in New Haven.\nMexico(x) ::: x is shipped from Mexico.\nNewYork(x) ::: x is sold in New York.\nAvocado(x) ::: x is an avocado.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (SoldIn(x, boston) → ShippedFrom(x, columbia)) ::: All fruits sold in Boston are shipped from Columbia.\n∃x (SoldIn(x, newHaven) ∧ ShippedFrom(x, mexico)) ::: Some fruits sold in New Haven are shipped from Mexico.\n∀x (ShippedFrom(x, columbia) → ¬SoldIn(x, newYork)) ::: No fruits shipped from Columbia are fruits sold in New York.\n(Avocado(avocadoe) ∧ (SoldIn(avocadoe, newYork) ∨ SoldIn(avocadoe, newYork))) ::: Avocadoe are a kind of fruit sold in New York or New York.\n¬(ShippedFrom(avocadoe, columbia) ∧ SoldIn(avocadoe, newHaven)) → (ShippedFrom(avocadoe, columbia) ∧ SoldIn(avocadoe, newHaven)) ⊕ ¬(ShippedFrom(avocadoe, columbia) ∨ SoldIn(avocadoe, newHaven)) ::: Avocadoe are either shipped from Columbia and sold in New Haven, or neither shipped from Columbia nor sold in New Haven.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬(SoldIn(avocadoe, newYork) ∧ ShippedFrom(avocadoe, columbia)) → ¬(SoldIn(avocadoe, newYork) ∨ SoldIn(avocadoe, newHaven)) ::: If avocados are not sold in New York and not shipped from Columbia, then they are neither sold in New York nor New Haven.\n\"\"\""
    ]
  },
  {
    "id": 1183,
    "context": [
      "Some monitors equipped in the library are produced by AOC. ",
      "All monitors equipped in the library are cheaper than 800 dollars. ",
      "All monitors cheaper than 800 dollars are with a resolution of 1080p. ",
      "If a monitor has a resolution of 1080p, then it does not support the type-c port. ",
      "A-2017 supports the type-c port. "
    ],
    "question": "A-2017 is produced by AOC.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nProducedBy(x, y) ::: x is produced by y.\nEquipped(x, y) ::: x is equipped in y.\nCheaperThan(x, y) ::: x is cheaper than y dollars.\nResolution(x, y) ::: x has a resolution of y.\nSupports(x, y) ::: x supports y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∃x (Equipped(x, library) ∧ ProducedBy(x, AOC)) ::: Some monitors equipped in the library are produced by AOC.\n∀x (Equipped(x, library) → CheaperThan(x, 800)) ::: All monitors equipped in the library are cheaper than 800 dollars.\n∀x (CheaperThan(x, 800) → Resolution(x, 1080p)) ::: All monitors cheaper than 800 dollars are with a resolution of 1080p.\n∀x (Resolution(x, 1080p) → ¬Supports(x, type-c)) ::: If a monitor has a resolution of 1080p, then it does not support the type-c port.\nSupports(A-2017, type-c) ::: A-2017 supports the type-c port.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nProducedBy(A-2017, AOC) ::: A-2017 is produced by AOC.\n\"\"\""
    ]
  },
  {
    "id": 1184,
    "context": [
      "Some monitors equipped in the library are produced by AOC. ",
      "All monitors equipped in the library are cheaper than 800 dollars. ",
      "All monitors cheaper than 800 dollars are with a resolution of 1080p. ",
      "If a monitor has a resolution of 1080p, then it does not support the type-c port. ",
      "A-2017 supports the type-c port. "
    ],
    "question": "A-2017 is produced by AOC and equipped in the library.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nProducedBy(x, y) ::: x is produced by y.\nEquippedInLibrary(x) ::: x is equipped in the library.\nCheaperThan(x, y) ::: x is cheaper than y dollars.\nResolution(x, y) ::: x has a resolution of y.\nSupports(x, y) ::: x supports y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∃x (Monitors(x) ∧ EquippedInLibrary(x) ∧ ProducedBy(x, AOC)) ::: Some monitors equipped in the library are produced by AOC.\n∀x (Monitors(x) ∧ EquippedInLibrary(x) → CheaperThan(x, 800)) ::: All monitors equipped in the library are cheaper than 800 dollars.\n∀x (CheaperThan(x, 800) → Resolution(x, 1080p)) ::: All monitors cheaper than 800 dollars are with a resolution of 1080p.\n∀x (Resolution(x, 1080p) → ¬Supports(x, type-c)) ::: If a monitor has a resolution of 1080p, then it does not support the type-c port.\nSupports(A-2017, type-c) ::: A-2017 supports the type-c port.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nProducedBy(A-2017, AOC) ∧ EquippedInLibrary(A-2017) ::: A-2017 is produced by AOC and equipped in the library.\n\"\"\""
    ]
  },
  {
    "id": 1185,
    "context": [
      "Some monitors equipped in the library are produced by AOC. ",
      "All monitors equipped in the library are cheaper than 800 dollars. ",
      "All monitors cheaper than 800 dollars are with a resolution of 1080p. ",
      "If a monitor has a resolution of 1080p, then it does not support the type-c port. ",
      "A-2017 supports the type-c port. "
    ],
    "question": "If A-2017 is not with a resolution of 1080p or produced by AOC, then it is not equipped in the library.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nEquipped(x) ::: x is equipped in the library.\nProducedBy(x, y) ::: x is produced by y.\nCheaperThan(x, y) ::: x is cheaper than y dollars.\nResolution(x, y) ::: x has a resolution of y.\nSupports(x, y) ::: x supports y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∃x (Equipped(x) ∧ ProducedBy(x, AOC)) ::: Some monitors equipped in the library are produced by AOC.\n∀x (Equipped(x) → CheaperThan(x, 800)) ::: All monitors equipped in the library are cheaper than 800 dollars.\n∀x (CheaperThan(x, 800) → Resolution(x, 1080p)) ::: All monitors cheaper than 800 dollars are with a resolution of 1080p.\n∀x (Resolution(x, 1080p) → ¬Supports(x, type-c)) ::: If a monitor has a resolution of 1080p, then it does not support the type-c port.\nSupports(A-2017, type-c) ::: A-2017 supports the type-c port.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬(Resolution(A-2017, 1080p) ∨ ProducedBy(A-2017, AOC)) → ¬Equipped(A-2017) ::: If A-2017 is not with a resolution of 1080p or produced by AOC, then it is not equipped in the library.\n\"\"\""
    ]
  },
  {
    "id": 10,
    "context": [
      "Sūduva Marijampolė holds the Lithuanian Supercup.",
      "Sūduva Marijampolė is a soccer team."
    ],
    "question": "Some soccer team holds the Lithuanian Supercup.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nHolds(x, y) ::: Team x holds the trophy y.\nSoccerTeam(x) ::: x is a soccer team.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nHolds(suduvaMarijampole, lithuanianSupercup) ::: Sūduva Marijampolė holds the Lithuanian Supercup.\nSoccerTeam(suduvaMarijampole) ::: Sūduva Marijampolė is a soccer team.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n∃x (SoccerTeam(x) ∧ Holds(x, lithuanianSupercup)) ::: Some soccer team holds the Lithuanian Supercup.\n\"\"\""
    ]
  },
  {
    "id": 286,
    "context": [
      "Ainderby Quernhow is a village and civil parish in the Hambleton District.",
      "Hambleton District is in North Yorkshire.",
      "North Yorkshire is in England."
    ],
    "question": "There is a village in England.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nVillage(x) ::: x is a village.\nCivilParish(x) ::: x is a civil parish.\nDistrict(x) ::: x is a district.\nIn(x, y) ::: x is in y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nVillage(ainderbyQuernhow) ∧ CivilParish(ainderbyQuernhow) ::: Ainderby Quernhow is a village and civil parish in the Hambleton District.\nDistrict(hambletonDistrict) ∧ In(hambletonDistrict, northYorkshire) ::: Hambleton District is in North Yorkshire.\nIn(northYorkshire, england) ::: North Yorkshire is in England.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n∃x (Village(x) ∧ In(x, england)) ::: There is a village in England.\n\"\"\""
    ]
  },
  {
    "id": 287,
    "context": [
      "Ainderby Quernhow is a village and civil parish in the Hambleton District.",
      "Hambleton District is in North Yorkshire.",
      "North Yorkshire is in England."
    ],
    "question": "There is no civil parish in England.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nVillage(x) ::: x is a village.\nCivilParish(x) ::: x is a civil parish.\nDistrict(x) ::: x is a district.\nIn(x, y) ::: x is in y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nVillage(ainderbyQuernhow) ∧ CivilParish(ainderbyQuernhow) ::: Ainderby Quernhow is a village and civil parish in the Hambleton District.\nDistrict(hambleton) ∧ In(hambleton, northYorkshire) ::: Hambleton District is in North Yorkshire.\nIn(northYorkshire, england) ::: North Yorkshire is in England.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬∃x (CivilParish(x) ∧ In(x, england)) ::: There is no civil parish in England.\n\"\"\""
    ]
  },
  {
    "id": 139,
    "context": [
      "Douglas Adams is an author who created the book collection called The Salmon of Doubt. ",
      "The Salmon of Doubt is about life experiences and technology.",
      "All authors are writers.",
      "Writers create innovative ideas.",
      "Some books that contain innovative ideas are about technology."
    ],
    "question": "Douglas Adams is a writer.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nAuthor(x) ::: x is an author.\nCreated(x, y) ::: x created y.\nBookCollection(x) ::: x is a book collection.\nAbout(x, y) ::: x is about y.\nWriter(x) ::: x is a writer.\nCreate(x, y) ::: x creates y.\nInnovative(x) ::: x contains innovative ideas.\nTechnology(x) ::: x is about technology.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nAuthor(douglasAdams) ∧ Created(douglasAdams, theSalmonOfDoubt) ∧ BookCollection(theSalmonOfDoubt) ::: Douglas Adams is an author who created the book collection called The Salmon of Doubt.\nAbout(theSalmonOfDoubt, lifeExperiences) ∧ About(theSalmonOfDoubt, technology) ::: The Salmon of Doubt is about life experiences and technology.\n∀x (Author(x) → Writer(x)) ::: All authors are writers.\n∀x (Writer(x) → Create(x, innovativeIdeas)) ::: Writers create innovative ideas.\n∃x (Book(x) ∧ Innovative(x) ∧ About(x, technology)) ::: Some books that contain innovative ideas are about technology.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nWriter(douglasAdams) ::: Douglas Adams is a writer.\n\"\"\""
    ]
  },
  {
    "id": 140,
    "context": [
      "Douglas Adams is an author who created the book collection called The Salmon of Doubt. ",
      "The Salmon of Doubt is about life experiences and technology.",
      "All authors are writers.",
      "Writers create innovative ideas.",
      "Some books that contain innovative ideas are about technology."
    ],
    "question": "Douglas Adams created innovative ideas.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nAuthor(x) ::: x is an author.\nCreated(x, y) ::: x created y.\nBookCollection(x) ::: x is a book collection.\nAbout(x, y) ::: x is about y.\nLifeExperiences(x) ::: x is about life experiences.\nTechnology(x) ::: x is about technology.\nWriter(x) ::: x is a writer.\nCreate(x, y) ::: x creates y.\nInnovativeIdeas(x) ::: x contains innovative ideas.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nAuthor(douglasAdams) ∧ Created(douglasAdams, theSalmonOfDoubt) ∧ BookCollection(theSalmonOfDoubt) ::: Douglas Adams is an author who created the book collection called The Salmon of Doubt.\nAbout(theSalmonOfDoubt, lifeExperiences) ∧ About(theSalmonOfDoubt, technology) ::: The Salmon of Doubt is about life experiences and technology.\n∀x (Author(x) → Writer(x)) ::: All authors are writers.\n∀x (Writer(x) → Create(x, innovativeIdeas)) ::: Writers create innovative ideas.\n∃x (Book(x) ∧ InnovativeIdeas(x) ∧ About(x, technology)) ::: Some books that contain innovative ideas are about technology.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nCreate(douglasAdams, innovativeIdeas) ::: Douglas Adams created innovative ideas.\n\"\"\""
    ]
  },
  {
    "id": 141,
    "context": [
      "Douglas Adams is an author who created the book collection called The Salmon of Doubt. ",
      "The Salmon of Doubt is about life experiences and technology.",
      "All authors are writers.",
      "Writers create innovative ideas.",
      "Some books that contain innovative ideas are about technology."
    ],
    "question": "The Salmon of Doubt has no innovative Ideas.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nAuthor(x) ::: x is an author.\nCreated(x, y) ::: x created y.\nBookCollection(x) ::: x is a book collection.\nAbout(x, y) ::: x is about y.\nWriter(x) ::: x is a writer.\nCreate(x, y) ::: x creates y.\nInnovativeIdeas(x) ::: x contains innovative ideas.\nTechnology(x) ::: x is about technology.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nAuthor(douglasAdams) ∧ Created(douglasAdams, theSalmonOfDoubt) ::: Douglas Adams is an author who created the book collection called The Salmon of Doubt.\nAbout(theSalmonOfDoubt, lifeExperiences) ∧ About(theSalmonOfDoubt, technology) ::: The Salmon of Doubt is about life experiences and technology.\n∀x (Author(x) → Writer(x)) ::: All authors are writers.\n∀x (Writer(x) → Create(x, innovativeIdeas)) ::: Writers create innovative ideas.\n∃x (Book(x) ∧ Contains(x, innovativeIdeas) ∧ About(x, technology)) ::: Some books that contain innovative ideas are about technology.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬∃x (BookCollection(theSalmonOfDoubt) ∧ Contains(theSalmonOfDoubt, innovativeIdeas)) ::: The Salmon of Doubt has no innovative Ideas.\n\"\"\""
    ]
  },
  {
    "id": 827,
    "context": [
      "No disposable products can help slow down global warming. ",
      "All eco-friendly brands can help slow down global warming. ",
      "All sustainable fashion brands are eco-friendly brands.",
      "All fast fashion products are disposable products.",
      "If Reformation is not helping slow down global warming, then Reformation is an eco-friendly brand or a sustainable fashion brand."
    ],
    "question": "Reformation is an eco-friendly brand.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nDisposable(x) ::: x is a disposable product.\nGlobalWarming(x) ::: x can help slow down global warming.\nEcoFriendly(x) ::: x is an eco-friendly brand.\nSustainableFashion(x) ::: x is a sustainable fashion brand.\nFastFashion(x) ::: x is a fast fashion product.\nHelps(x, y) ::: x helps y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Disposable(x) → ¬GlobalWarming(x)) ::: No disposable products can help slow down global warming.\n∀x (EcoFriendly(x) → GlobalWarming(x)) ::: All eco-friendly brands can help slow down global warming.\n∀x (SustainableFashion(x) → EcoFriendly(x)) ::: All sustainable fashion brands are eco-friendly brands.\n∀x (FastFashion(x) → Disposable(x)) ::: All fast fashion products are disposable products.\n¬Helps(Reformation, GlobalWarming) → (EcoFriendly(Reformation) ∨ SustainableFashion(Reformation)) ::: If Reformation is not helping slow down global warming, then Reformation is an eco-friendly brand or a sustainable fashion brand.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nEcoFriendly(Reformation) ::: Reformation is an eco-friendly brand.\n\"\"\""
    ]
  },
  {
    "id": 828,
    "context": [
      "No disposable products can help slow down global warming. ",
      "All eco-friendly brands can help slow down global warming. ",
      "All sustainable fashion brands are eco-friendly brands.",
      "All fast fashion products are disposable products.",
      "If Reformation is not helping slow down global warming, then Reformation is an eco-friendly brand or a sustainable fashion brand."
    ],
    "question": "Reformation produces fast fashion products.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nDisposable(x) ::: x is a disposable product.\nGlobalWarming(x) ::: x can help slow down global warming.\nEcoFriendly(x) ::: x is an eco-friendly brand.\nSustainableFashion(x) ::: x is a sustainable fashion brand.\nFastFashion(x) ::: x is a fast fashion product.\nHelps(x, y) ::: x helps y.\nProduces(x, y) ::: x produces y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Disposable(x) → ¬GlobalWarming(x)) ::: No disposable products can help slow down global warming.\n∀x (EcoFriendly(x) → GlobalWarming(x)) ::: All eco-friendly brands can help slow down global warming.\n∀x (SustainableFashion(x) → EcoFriendly(x)) ::: All sustainable fashion brands are eco-friendly brands.\n∀x (FastFashion(x) → Disposable(x)) ::: All fast fashion products are disposable products.\n¬Helps(Reformation, GlobalWarming) → (EcoFriendly(Reformation) ∨ SustainableFashion(Reformation)) ::: If Reformation is not helping slow down global warming, then Reformation is an eco-friendly brand or a sustainable fashion brand.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nFastFashion(Reformation) ::: Reformation produces fast fashion products.\n\"\"\""
    ]
  },
  {
    "id": 829,
    "context": [
      "No disposable products can help slow down global warming. ",
      "All eco-friendly brands can help slow down global warming. ",
      "All sustainable fashion brands are eco-friendly brands.",
      "All fast fashion products are disposable products.",
      "If Reformation is not helping slow down global warming, then Reformation is an eco-friendly brand or a sustainable fashion brand."
    ],
    "question": "Reformation does not produce fast fashion products.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nDisposable(x) ::: x is a disposable product.\nGlobalWarming(x) ::: x can help slow down global warming.\nEcoFriendly(x) ::: x is an eco-friendly brand.\nSustainableFashion(x) ::: x is a sustainable fashion brand.\nFastFashion(x) ::: x is a fast fashion product.\nHelpsSlowDown(x) ::: x helps slow down global warming.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Disposable(x) → ¬GlobalWarming(x)) ::: No disposable products can help slow down global warming.\n∀x (EcoFriendly(x) → GlobalWarming(x)) ::: All eco-friendly brands can help slow down global warming.\n∀x (SustainableFashion(x) → EcoFriendly(x)) ::: All sustainable fashion brands are eco-friendly brands.\n∀x (FastFashion(x) → Disposable(x)) ::: All fast fashion products are disposable products.\n¬HelpsSlowDown(reformation) → (EcoFriendly(reformation) ∨ SustainableFashion(reformation)) ::: If Reformation is not helping slow down global warming, then Reformation is an eco-friendly brand or a sustainable fashion brand.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬∃x (FastFashion(x) ∧ Produce(reformation, x)) ::: Reformation does not produce fast fashion products.\n\"\"\""
    ]
  },
  {
    "id": 830,
    "context": [
      "No disposable products can help slow down global warming. ",
      "All eco-friendly brands can help slow down global warming. ",
      "All sustainable fashion brands are eco-friendly brands.",
      "All fast fashion products are disposable products.",
      "If Reformation is not helping slow down global warming, then Reformation is an eco-friendly brand or a sustainable fashion brand."
    ],
    "question": "Reformation does not produce fast fashion products or does not produce disposable products.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nDisposable(x) ::: x is a disposable product.\nGlobalWarming(x) ::: x can help slow down global warming.\nEcoFriendly(x) ::: x is an eco-friendly brand.\nSustainableFashion(x) ::: x is a sustainable fashion brand.\nFastFashion(x) ::: x is a fast fashion product.\nHelps(x, y) ::: x can help y.\nProduces(x, y) ::: x produces y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Disposable(x) → ¬Helps(x, globalWarming)) ::: No disposable products can help slow down global warming.\n∀x (EcoFriendly(x) → Helps(x, globalWarming)) ::: All eco-friendly brands can help slow down global warming.\n∀x (SustainableFashion(x) → EcoFriendly(x)) ::: All sustainable fashion brands are eco-friendly brands.\n∀x (FastFashion(x) → Disposable(x)) ::: All fast fashion products are disposable products.\n¬Helps(reformation, globalWarming) → (EcoFriendly(reformation) ∨ SustainableFashion(reformation)) ::: If Reformation is not helping slow down global warming, then Reformation is an eco-friendly brand or a sustainable fashion brand.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬Produces(reformation, fastFashion) ∨ ¬Produces(reformation, disposable) ::: Reformation does not produce fast fashion products or does not produce disposable products.\n\"\"\""
    ]
  },
  {
    "id": 831,
    "context": [
      "No disposable products can help slow down global warming. ",
      "All eco-friendly brands can help slow down global warming. ",
      "All sustainable fashion brands are eco-friendly brands.",
      "All fast fashion products are disposable products.",
      "If Reformation is not helping slow down global warming, then Reformation is an eco-friendly brand or a sustainable fashion brand."
    ],
    "question": "If Reformation produces disposable products, then Reformation produces fast fashion products.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nDisposable(x) ::: x is a disposable product.\nGlobalWarming(x) ::: x can help slow down global warming.\nEcoFriendly(x) ::: x is an eco-friendly brand.\nSustainableFashion(x) ::: x is a sustainable fashion brand.\nFastFashion(x) ::: x is a fast fashion product.\nProduces(x, y) ::: x produces y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Disposable(x) → ¬GlobalWarming(x)) ::: No disposable products can help slow down global warming.\n∀x (EcoFriendly(x) → GlobalWarming(x)) ::: All eco-friendly brands can help slow down global warming.\n∀x (SustainableFashion(x) → EcoFriendly(x)) ::: All sustainable fashion brands are eco-friendly brands.\n∀x (FastFashion(x) → Disposable(x)) ::: All fast fashion products are disposable products.\n¬GlobalWarming(reformation) → (EcoFriendly(reformation) ∨ SustainableFashion(reformation)) ::: If Reformation is not helping slow down global warming, then Reformation is an eco-friendly brand or a sustainable fashion brand.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nProduces(reformation, disposable) → Produces(reformation, fastFashion) ::: If Reformation produces disposable products, then Reformation produces fast fashion products.\n\"\"\""
    ]
  },
  {
    "id": 832,
    "context": [
      "No disposable products can help slow down global warming. ",
      "All eco-friendly brands can help slow down global warming. ",
      "All sustainable fashion brands are eco-friendly brands.",
      "All fast fashion products are disposable products.",
      "If Reformation is not helping slow down global warming, then Reformation is an eco-friendly brand or a sustainable fashion brand."
    ],
    "question": "If Reformation produces fast fashion products or helps slow down global warming, then Reformation produces fast fashion products.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nDisposable(x) ::: x is a disposable product.\nGlobalWarming(x) ::: x can help slow down global warming.\nEcoFriendly(x) ::: x is an eco-friendly brand.\nSustainableFashion(x) ::: x is a sustainable fashion brand.\nFastFashion(x) ::: x is a fast fashion product.\nProduces(x, y) ::: x produces y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Disposable(x) → ¬GlobalWarming(x)) ::: No disposable products can help slow down global warming.\n∀x (EcoFriendly(x) → GlobalWarming(x)) ::: All eco-friendly brands can help slow down global warming.\n∀x (SustainableFashion(x) → EcoFriendly(x)) ::: All sustainable fashion brands are eco-friendly brands.\n∀x (FastFashion(x) → Disposable(x)) ::: All fast fashion products are disposable products.\n¬GlobalWarming(reformation) → (EcoFriendly(reformation) ∨ SustainableFashion(reformation)) ::: If Reformation is not helping slow down global warming, then Reformation is an eco-friendly brand or a sustainable fashion brand.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n(FastFashion(reformation) ∨ GlobalWarming(reformation)) → FastFashion(reformation) ::: If Reformation produces fast fashion products or helps slow down global warming, then Reformation produces fast fashion products.\n\"\"\""
    ]
  },
  {
    "id": 284,
    "context": [
      "Roy Richardson was a cricketer for Sint Maartener, a consituent country.",
      "Roy Richardson was a right handed batsman and medium pace bowler.",
      "Roy Richardson was old when he debuted in cricket.",
      "Sherville Huggins dismissed Roy Richardson."
    ],
    "question": "Sherville Huggins has never dismissed anyone playing for a constituent country.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nCricketer(x) ::: x is a cricketer.\nCountry(x) ::: x is a country.\nRightHandedBatsman(x) ::: x is a right-handed batsman.\nMediumPaceBowler(x) ::: x is a medium pace bowler.\nOld(x) ::: x is old.\nDebut(x) ::: x debuted in cricket.\nDismiss(y, x) ::: y dismissed x.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nCricketer(royRichardson) ∧ Country(sintMaartener) ::: Roy Richardson was a cricketer for Sint Maartener, a constituent country.\nRightHandedBatsman(royRichardson) ∧ MediumPaceBowler(royRichardson) ::: Roy Richardson was a right-handed batsman and medium pace bowler.\nOld(royRichardson) ∧ Debut(royRichardson) ::: Roy Richardson was old when he debuted in cricket.\nDismiss(shervilleHuggins, royRichardson) ::: Sherville Huggins dismissed Roy Richardson.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n∀x (Country(y) ∧ Dismiss(shervilleHuggins, x)) → ¬Dismiss(shervilleHuggins, x) ::: Sherville Huggins has never dismissed anyone playing for a constituent country.\n\"\"\""
    ]
  },
  {
    "id": 285,
    "context": [
      "Roy Richardson was a cricketer for Sint Maartener, a consituent country.",
      "Roy Richardson was a right handed batsman and medium pace bowler.",
      "Roy Richardson was old when he debuted in cricket.",
      "Sherville Huggins dismissed Roy Richardson."
    ],
    "question": "There are no right handed medium pace bowlers playing for Sint Maartener.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nCricketer(x) ::: x is a cricketer.\nCountry(x, y) ::: x is from country y.\nBatsman(x) ::: x is a batsman.\nBowler(x) ::: x is a bowler.\nRightHanded(x) ::: x is a right handed player.\nMediumPace(x) ::: x is a medium pace player.\nOld(x) ::: x is old.\nDebut(x) ::: x debuted in cricket.\nDismiss(y, x) ::: y dismissed x.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nCountry(royRichardson, sintMaartener) ∧ Cricketer(royRichardson) ::: Roy Richardson was a cricketer for Sint Maartener, a constituent country.\nBatsman(royRichardson) ∧ Bowler(royRichardson) ∧ RightHanded(royRichardson) ∧ MediumPace(royRichardson) ::: Roy Richardson was a right handed batsman and medium pace bowler.\nOld(royRichardson) ∧ Debut(royRichardson) ::: Roy Richardson was old when he debuted in cricket.\nDismiss(shervilleHuggins, royRichardson) ::: Sherville Huggins dismissed Roy Richardson.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬∃x (RightHanded(x) ∧ MediumPace(x) ∧ Cricketer(x) ∧ Country(x, sintMaartener)) ::: There are no right handed medium pace bowlers playing for Sint Maartener.\n\"\"\""
    ]
  },
  {
    "id": 700,
    "context": [
      "To get a job at Google, you need to have a lot of work experience or a good education.",
      " All Yale graduates who submitted their resumes to Google got jobs there.",
      " John has a lot of work experience.",
      " John submitted his resume to Google and got a job there."
    ],
    "question": "John is a Yale graduate.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nJob(x) ::: x got a job at Google.\nWorkExperience(x) ::: x has a lot of work experience.\nEducation(x) ::: x has a good education.\nYaleGraduate(x) ::: x is a Yale graduate.\nSubmittedResume(x) ::: x submitted their resume to Google.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nJob(x) ↔ (WorkExperience(x) ∨ Education(x)) ::: To get a job at Google, you need to have a lot of work experience or a good education.\n∀x (YaleGraduate(x) → Job(x)) ::: All Yale graduates who submitted their resumes to Google got jobs there.\nWorkExperience(john) ::: John has a lot of work experience.\nSubmittedResume(john) ∧ Job(john) ::: John submitted his resume to Google and got a job there.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nYaleGraduate(john) ::: John is a Yale graduate.\n\"\"\""
    ]
  },
  {
    "id": 889,
    "context": [
      "No students are doctors.",
      "All people taking classes are students. ",
      "All graduate students are people taking classes. ",
      "All PhD students are graduate students. ",
      "If Joe is a graduate student or a doctor (but not both), then Joe is not a graduate student and a student."
    ],
    "question": "Joe is a person taking classes.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nStudent(x) ::: x is a student.\nDoctor(x) ::: x is a doctor.\nTakingClasses(x) ::: x is taking classes.\nGraduateStudent(x) ::: x is a graduate student.\nPhDStudent(x) ::: x is a PhD student.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Student(x) → ¬Doctor(x)) ::: No students are doctors.\n∀x (TakingClasses(x) → Student(x)) ::: All people taking classes are students.\n∀x (GraduateStudent(x) → TakingClasses(x)) ::: All graduate students are people taking classes.\n∀x (PhDStudent(x) → GraduateStudent(x)) ::: All PhD students are graduate students.\n(GraduateStudent(joe) ∨ Doctor(joe)) ⊕ (GraduateStudent(joe) ∧ Student(joe)) ::: If Joe is a graduate student or a doctor (but not both), then Joe is not a graduate student and a student.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nTakingClasses(joe) ::: Joe is a person taking classes.\n\"\"\""
    ]
  },
  {
    "id": 890,
    "context": [
      "No students are doctors.",
      "All people taking classes are students. ",
      "All graduate students are people taking classes. ",
      "All PhD students are graduate students. ",
      "If Joe is a graduate student or a doctor (but not both), then Joe is not a graduate student and a student."
    ],
    "question": "Joe is a PhD student.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nStudent(x) ::: x is a student.\nDoctor(x) ::: x is a doctor.\nTakingClasses(x) ::: x is taking classes.\nGraduateStudent(x) ::: x is a graduate student.\nPhDStudent(x) ::: x is a PhD student.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Student(x) → ¬Doctor(x)) ::: No students are doctors.\n∀x (TakingClasses(x) → Student(x)) ::: All people taking classes are students.\n∀x (GraduateStudent(x) → TakingClasses(x)) ::: All graduate students are people taking classes.\n∀x (PhDStudent(x) → GraduateStudent(x)) ::: All PhD students are graduate students.\n(GraduateStudent(joe) ∨ Doctor(joe)) ∧ ¬(GraduateStudent(joe) ∧ Student(joe)) ::: If Joe is a graduate student or a doctor (but not both), then Joe is not a graduate student and a student.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nPhDStudent(joe) ::: Joe is a PhD student.\n\"\"\""
    ]
  },
  {
    "id": 891,
    "context": [
      "No students are doctors.",
      "All people taking classes are students. ",
      "All graduate students are people taking classes. ",
      "All PhD students are graduate students. ",
      "If Joe is a graduate student or a doctor (but not both), then Joe is not a graduate student and a student."
    ],
    "question": "Joe is not a PhD student.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nStudent(x) ::: x is a student.\nDoctor(x) ::: x is a doctor.\nTakingClasses(x) ::: x is taking classes.\nGraduateStudent(x) ::: x is a graduate student.\nPhDStudent(x) ::: x is a PhD student.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Student(x) → ¬Doctor(x)) ::: No students are doctors.\n∀x (TakingClasses(x) → Student(x)) ::: All people taking classes are students.\n∀x (GraduateStudent(x) → TakingClasses(x)) ::: All graduate students are people taking classes.\n∀x (PhDStudent(x) → GraduateStudent(x)) ::: All PhD students are graduate students.\n(GraduateStudent(joe) ∨ Doctor(joe)) ⊕ (GraduateStudent(joe) ∧ Student(joe)) ::: If Joe is a graduate student or a doctor (but not both), then Joe is not a graduate student and a student.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬PhDStudent(joe) ::: Joe is not a PhD student.\n\"\"\""
    ]
  },
  {
    "id": 93,
    "context": [
      "Hugh Vanstone is one of the world's leading lighting designers. ",
      "Hugh Vanstone is from the UK.",
      "Hugh Vanstone has lit more than 160 productions.",
      "Hugh Vanstone attended school where he is from. "
    ],
    "question": "Hugh Vanstone is one of the world's leading ligting designers and from the uk",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nLightingDesigner(x) ::: x is a lighting designer.\nFromUK(x) ::: x is from the UK.\nLitMoreThan(x, y) ::: x has lit more than y productions.\nAttendedSchool(x, y) ::: x attended school where he is from.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nLightingDesigner(hughVanstone) ::: Hugh Vanstone is one of the world's leading lighting designers.\nFromUK(hughVanstone) ::: Hugh Vanstone is from the UK.\nLitMoreThan(hughVanstone, 160) ::: Hugh Vanstone has lit more than 160 productions.\nAttendedSchool(hughVanstone, UK) ::: Hugh Vanstone attended school where he is from.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nLightingDesigner(hughVanstone) ∧ FromUK(hughVanstone) ::: Hugh Vanstone is one of the world's leading lighting designers and from the UK.\n\"\"\""
    ]
  },
  {
    "id": 94,
    "context": [
      "Hugh Vanstone is one of the world's leading lighting designers. ",
      "Hugh Vanstone is from the UK.",
      "Hugh Vanstone has lit more than 160 productions.",
      "Hugh Vanstone attended school where he is from. "
    ],
    "question": "Hugh Vanstone has lit 170 productions.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nLightingDesigner(x) ::: x is a lighting designer.\nFromUK(x) ::: x is from the UK.\nLit(x, y) ::: x has lit y productions.\nAttendedSchool(x, y) ::: x attended school y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nLightingDesigner(hughVanstone) ::: Hugh Vanstone is one of the world's leading lighting designers.\nFromUK(hughVanstone) ::: Hugh Vanstone is from the UK.\nLit(hughVanstone, moreThan160Productions) ::: Hugh Vanstone has lit more than 160 productions.\nAttendedSchool(hughVanstone, fromUK) ::: Hugh Vanstone attended school where he is from.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nLit(hughVanstone, 170Productions) ::: Hugh Vanstone has lit 170 productions.\n\"\"\""
    ]
  },
  {
    "id": 95,
    "context": [
      "Hugh Vanstone is one of the world's leading lighting designers. ",
      "Hugh Vanstone is from the UK.",
      "Hugh Vanstone has lit more than 160 productions.",
      "Hugh Vanstone attended school where he is from. "
    ],
    "question": "Hugh Vanstone attended school in the US.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nLightingDesigner(x) ::: x is a lighting designer.\nFromUK(x) ::: x is from the UK.\nLitMoreThan(x, y) ::: x has lit more than y productions.\nAttendedSchool(x, y) ::: x attended school in y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nLightingDesigner(hughVanstone) ::: Hugh Vanstone is one of the world's leading lighting designers.\nFromUK(hughVanstone) ::: Hugh Vanstone is from the UK.\nLitMoreThan(hughVanstone, 160) ::: Hugh Vanstone has lit more than 160 productions.\nAttendedSchool(hughVanstone, UK) ::: Hugh Vanstone attended school where he is from.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬AttendedSchool(hughVanstone, US) ::: Hugh Vanstone attended school in the US.\n\"\"\""
    ]
  },
  {
    "id": 450,
    "context": [
      "No man can run faster than Bolt. ",
      "Superman is not a man."
    ],
    "question": "Superman can run faster than Bolt.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nRunFaster(x, y) ::: x can run faster than y.\nMan(x) ::: x is a man.\nBolt(x) ::: x is Bolt.\nSuperman(x) ::: x is Superman.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x ¬(Man(x) ∧ RunFaster(x, Bolt)) ::: No man can run faster than Bolt.\n¬Man(superman) ::: Superman is not a man.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nRunFaster(superman, Bolt) ::: Superman can run faster than Bolt.\n\"\"\""
    ]
  },
  {
    "id": 380,
    "context": [
      "Donald Ervin Knuth is an American computer scientist, mathematician, and Professor Emeritus at Stanford University.",
      "Knuth has been called the \"father of the analysis of algorithms\"."
    ],
    "question": "An American scientist has been called the \"father of the analysis of algorithms\".",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nAmerican(x) ::: x is an American.\nComputerScientist(x) ::: x is a computer scientist.\nMathematician(x) ::: x is a mathematician.\nProfessorEmeritus(x) ::: x is a Professor Emeritus.\nFatherOfAnalysisOfAlgorithms(x) ::: x has been called the \"father of the analysis of algorithms.\"\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nAmerican(donaldErvinKnuth) ∧ ComputerScientist(donaldErvinKnuth) ∧ Mathematician(donaldErvinKnuth) ∧ ProfessorEmeritus(donaldErvinKnuth) ::: Donald Ervin Knuth is an American computer scientist, mathematician, and Professor Emeritus at Stanford University.\nFatherOfAnalysisOfAlgorithms(knuth) ::: Knuth has been called the \"father of the analysis of algorithms\".\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n∃x (American(x) ∧ Scientist(x) ∧ FatherOfAnalysisOfAlgorithms(x)) ::: An American scientist has been called the \"father of the analysis of algorithms\".\n\"\"\""
    ]
  },
  {
    "id": 381,
    "context": [
      "Donald Ervin Knuth is an American computer scientist, mathematician, and Professor Emeritus at Stanford University.",
      "Knuth has been called the \"father of the analysis of algorithms\"."
    ],
    "question": "A mathematician has been called the \"father of the analysis of algorithms\".",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nAmerican(x) ::: x is an American person.\nComputerScientist(x) ::: x is a computer scientist.\nMathematician(x) ::: x is a mathematician.\nProfessorEmeritus(x) ::: x is a Professor Emeritus.\nWorksAt(x, y) ::: x works at y.\nCalled(x, y) ::: x has been called y.\nFatherOf(x, y) ::: x is the father of y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nAmerican(donald) ∧ ComputerScientist(donald) ∧ Mathematician(donald) ∧ ProfessorEmeritus(donald) ∧ WorksAt(donald, stanfordUniversity) ::: Donald Ervin Knuth is an American computer scientist, mathematician, and Professor Emeritus at Stanford University.\nCalled(knuth, fatherOfAnalysisOfAlgorithms) ::: Knuth has been called the \"father of the analysis of algorithms\".\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n∃x (Mathematician(x) ∧ Called(x, fatherOfAnalysisOfAlgorithms)) ::: A mathematician has been called the \"father of the analysis of algorithms\".\n\"\"\""
    ]
  },
  {
    "id": 382,
    "context": [
      "Donald Ervin Knuth is an American computer scientist, mathematician, and Professor Emeritus at Stanford University.",
      "Knuth has been called the \"father of the analysis of algorithms\"."
    ],
    "question": "Donald Knuth is a well-known figure in the field of artificial intelligence .",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nAmerican(x) ::: x is an American.\nComputerScientist(x) ::: x is a computer scientist.\nMathematician(x) ::: x is a mathematician.\nProfessorEmeritus(x) ::: x is a Professor Emeritus.\nWorksAt(x, y) ::: x works at y.\nCalled(x, y) ::: x has been called y.\nFatherOf(x, y) ::: x is the father of y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nAmerican(donaldErvinKnuth) ∧ ComputerScientist(donaldErvinKnuth) ∧ Mathematician(donaldErvinKnuth) ∧ ProfessorEmeritus(donaldErvinKnuth) ∧ WorksAt(donaldErvinKnuth, stanfordUniversity) ::: Donald Ervin Knuth is an American computer scientist, mathematician, and Professor Emeritus at Stanford University.\nCalled(knuth, fatherOfAnalysisOfAlgorithms) ::: Knuth has been called the \"father of the analysis of algorithms\".\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n∅ ::: Donald Knuth is a well-known figure in the field of artificial intelligence.\n\"\"\""
    ]
  },
  {
    "id": 363,
    "context": [
      "Neocrepidodera Corpulentas are flea beetles or moths.",
      "The species Neocrepidodera Corpulenta is in the Chrysomelidae family.",
      "There are no moths within the Chrysomelidae family."
    ],
    "question": "There is a flea beetle within the Chrysomelidae family.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nFleaBeetle(x) ::: x is a flea beetle.\nMoth(x) ::: x is a moth.\nSpecies(x) ::: x is a species.\nFamily(x) ::: x is a family.\nIn(x, y) ::: x is in y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Species(x) → (FleaBeetle(x) ∨ Moth(x))) ::: Neocrepidodera Corpulentas are flea beetles or moths.\nSpecies(neocrepidoderaCorpulenta) ∧ In(neocrepidoderaCorpulenta, Chrysomelidae) ::: The species Neocrepidodera Corpulenta is in the Chrysomelidae family.\n¬∃x (Moth(x) ∧ In(x, Chrysomelidae)) ::: There are no moths within the Chrysomelidae family.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n∃x (FleaBeetle(x) ∧ In(x, Chrysomelidae)) ::: There is a flea beetle within the Chrysomelidae family.\n\"\"\""
    ]
  },
  {
    "id": 364,
    "context": [
      "Neocrepidodera Corpulentas are flea beetles or moths.",
      "The species Neocrepidodera Corpulenta is in the Chrysomelidae family.",
      "There are no moths within the Chrysomelidae family."
    ],
    "question": "There are no flea beetles within the Chrysomelidae family.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nFleaBeetle(x) ::: x is a flea beetle.\nMoth(x) ::: x is a moth.\nSpecies(x) ::: x is a species.\nFamily(x) ::: x is a family.\nIn(x, y) ::: x is in y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Species(x) → (FleaBeetle(x) ∨ Moth(x))) ::: Neocrepidodera Corpulentas are flea beetles or moths.\nSpecies(neocrepidoderaCorpulenta) ∧ In(neocrepidoderaCorpulenta, Chrysomelidae) ::: The species Neocrepidodera Corpulenta is in the Chrysomelidae family.\n¬∃x (Moth(x) ∧ In(x, Chrysomelidae)) ::: There are no moths within the Chrysomelidae family.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬∃x (FleaBeetle(x) ∧ In(x, Chrysomelidae)) ::: There are no flea beetles within the Chrysomelidae family.\n\"\"\""
    ]
  },
  {
    "id": 644,
    "context": [
      "Carrozzeria Colli is a Milanese coachbuilder company that was established by Giuseppe Colli in 1931.",
      "Carrozzeria Colli is a company that specialized in using aluminum.",
      "The first automobiles built by Carrozzeria Colli were racing cars.",
      "Some racing cars built by Carrozzeria Colli used Fiat 1100 mechanicals and chasis.",
      "Carrozzeria Colli worked for airforces.",
      "Carrozzeria Colli made car bodies. "
    ],
    "question": "Carrozzeria Colli made car bodies in 1931.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nCompany(x) ::: x is a company.\nEstablishedBy(x, y, z) ::: x was established by y in year z.\nSpecializeIn(x, y) ::: x specializes in y.\nBuild(x, y) ::: x builds y.\nUse(x, y) ::: x uses y.\nWorkFor(x, y) ::: x works for y.\nMake(x, y) ::: x makes y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nCompany(carrozzeriaColli) ∧ EstablishedBy(carrozzeriaColli, giuseppeColli, year1931) ::: Carrozzeria Colli is a Milanese coachbuilder company that was established by Giuseppe Colli in 1931.\nCompany(carrozzeriaColli) ∧ SpecializeIn(carrozzeriaColli, aluminum) ::: Carrozzeria Colli is a company that specialized in using aluminum.\nBuild(carrozzeriaColli, racingCars) ∧ Build(carrozzeriaColli, firstAutomobiles) ∧ Build(carrozzeriaColli, racingCars) ::: The first automobiles built by Carrozzeria Colli were racing cars.\nUse(racingCars, fiat1100Mechanicals) ∧ Use(racingCars, fiat1100Chasis) ::: Some racing cars built by Carrozzeria Colli used Fiat 1100 mechanicals and chassis.\nWorkFor(carrozzeriaColli, airforces) ::: Carrozzeria Colli worked for airforces.\nMake(carrozzeriaColli, carBodies) ::: Carrozzeria Colli made car bodies.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nMake(carrozzeriaColli, carBodies) ∧ EstablishedBy(carrozzeriaColli, giuseppeColli, year1931) ::: Carrozzeria Colli made car bodies in 1931.\n\"\"\""
    ]
  },
  {
    "id": 645,
    "context": [
      "Carrozzeria Colli is a Milanese coachbuilder company that was established by Giuseppe Colli in 1931.",
      "Carrozzeria Colli is a company that specialized in using aluminum.",
      "The first automobiles built by Carrozzeria Colli were racing cars.",
      "Some racing cars built by Carrozzeria Colli used Fiat 1100 mechanicals and chasis.",
      "Carrozzeria Colli worked for airforces.",
      "Carrozzeria Colli made car bodies. "
    ],
    "question": "Carrozzeria Colli built airplanes during World War II.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nCompany(x) ::: x is a company.\nEstablishedBy(x, y, z) ::: x was established by y in year z.\nSpecializeIn(x, y) ::: x specializes in y.\nBuild(x, y) ::: x builds y.\nUse(x, y) ::: x uses y.\nWorkFor(x, y) ::: x works for y.\nMake(x, y) ::: x makes y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nCompany(carrozzeriaColli) ∧ EstablishedBy(carrozzeriaColli, giuseppeColli, year1931) ::: Carrozzeria Colli is a Milanese coachbuilder company that was established by Giuseppe Colli in 1931.\nCompany(carrozzeriaColli) ∧ SpecializeIn(carrozzeriaColli, aluminum) ::: Carrozzeria Colli is a company that specialized in using aluminum.\nBuild(carrozzeriaColli, racingCars) ∧ First(carrozzeriaColli, racingCars) ::: The first automobiles built by Carrozzeria Colli were racing cars.\n∃x (Build(carrozzeriaColli, x) ∧ Use(x, fiat1100Mechanicals) ∧ Use(x, fiat1100Chasis)) ::: Some racing cars built by Carrozzeria Colli used Fiat 1100 mechanicals and chassis.\nWorkFor(carrozzeriaColli, airforces) ::: Carrozzeria Colli worked for airforces.\nMake(carrozzeriaColli, carBodies) ::: Carrozzeria Colli made car bodies.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n∄x (Build(carrozzeriaColli, airplanes)) ::: Carrozzeria Colli built airplanes during World War II.\n\"\"\""
    ]
  },
  {
    "id": 646,
    "context": [
      "Carrozzeria Colli is a Milanese coachbuilder company that was established by Giuseppe Colli in 1931.",
      "Carrozzeria Colli is a company that specialized in using aluminum.",
      "The first automobiles built by Carrozzeria Colli were racing cars.",
      "Some racing cars built by Carrozzeria Colli used Fiat 1100 mechanicals and chasis.",
      "Carrozzeria Colli worked for airforces.",
      "Carrozzeria Colli made car bodies. "
    ],
    "question": "Giuseppe Colli established a company that made car bodies.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nCompany(x) ::: x is a company.\nEstablishedBy(x, y) ::: x was established by y.\nSpecializedIn(x, y) ::: x specialized in y.\nBuiltBy(x, y) ::: x was built by y.\nUsed(x, y) ::: x used y.\nWorkedFor(x, y) ::: x worked for y.\nMade(x, y) ::: x made y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nCompany(carrozzeriaColli) ∧ EstablishedBy(carrozzeriaColli, giuseppeColli) ∧ Publish(carrozzeriaColli, year1931) ::: Carrozzeria Colli is a Milanese coachbuilder company that was established by Giuseppe Colli in 1931.\nCompany(carrozzeriaColli) ∧ SpecializedIn(carrozzeriaColli, aluminum) ::: Carrozzeria Colli is a company that specialized in using aluminum.\nBuiltBy(firstAutomobiles, carrozzeriaColli) ∧ Used(firstAutomobiles, racingCars) ::: The first automobiles built by Carrozzeria Colli were racing cars.\n∃x (BuiltBy(racingCars, carrozzeriaColli) ∧ Used(racingCars, fiat1100Mechanicals) ∧ Used(racingCars, fiat1100Chasis)) ::: Some racing cars built by Carrozzeria Colli used Fiat 1100 mechanicals and chassis.\nWorkedFor(carrozzeriaColli, airforces) ::: Carrozzeria Colli worked for airforces.\nMade(carrozzeriaColli, carBodies) ::: Carrozzeria Colli made car bodies.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n∃x (Company(x) ∧ EstablishedBy(x, giuseppeColli) ∧ Made(x, carBodies)) ::: Giuseppe Colli established a company that made car bodies.\n\"\"\""
    ]
  },
  {
    "id": 647,
    "context": [
      "Carrozzeria Colli is a Milanese coachbuilder company that was established by Giuseppe Colli in 1931.",
      "Carrozzeria Colli is a company that specialized in using aluminum.",
      "The first automobiles built by Carrozzeria Colli were racing cars.",
      "Some racing cars built by Carrozzeria Colli used Fiat 1100 mechanicals and chasis.",
      "Carrozzeria Colli worked for airforces.",
      "Carrozzeria Colli made car bodies. "
    ],
    "question": "Giuseppe Colli established a Milanese coachbuilder company that specialized in using aluminum.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nEstablished(x, y) ::: x established y.\nCompany(x) ::: x is a company.\nSpecializedIn(x, y) ::: x specialized in y.\nBuiltBy(x, y) ::: x was built by y.\nUsed(x, y) ::: x used y.\nWorkedFor(x, y) ::: x worked for y.\nMade(x, y) ::: x made y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nEstablished(giuseppeColli, carrozzeriaColli) ∧ Company(carrozzeriaColli) ∧ SpecializedIn(carrozzeriaColli, aluminum) ∧ SpecializedIn(carrozzeriaColli, racingCars) ::: Carrozzeria Colli is a Milanese coachbuilder company that was established by Giuseppe Colli in 1931 and specialized in using aluminum.\n∀x (Company(x) → SpecializedIn(x, aluminum)) ::: Carrozzeria Colli is a company that specialized in using aluminum.\nBuiltBy(firstAutomobiles, carrozzeriaColli) ∧ Used(firstAutomobiles, racingCars) ::: The first automobiles built by Carrozzeria Colli were racing cars.\n∃x (BuiltBy(racingCars, carrozzeriaColli) ∧ Used(racingCars, fiat1100Mechanicals) ∧ Used(racingCars, fiat1100Chasis)) ::: Some racing cars built by Carrozzeria Colli used Fiat 1100 mechanicals and chassis.\nWorkedFor(carrozzeriaColli, airforces) ::: Carrozzeria Colli worked for airforces.\nMade(carrozzeriaColli, carBodies) ::: Carrozzeria Colli made car bodies.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nEstablished(giuseppeColli, milaneseCoachbuilderCompany) ∧ SpecializedIn(milaneseCoachbuilderCompany, aluminum) ::: Giuseppe Colli established a Milanese coachbuilder company that specialized in using aluminum.\n\"\"\""
    ]
  },
  {
    "id": 648,
    "context": [
      "Carrozzeria Colli is a Milanese coachbuilder company that was established by Giuseppe Colli in 1931.",
      "Carrozzeria Colli is a company that specialized in using aluminum.",
      "The first automobiles built by Carrozzeria Colli were racing cars.",
      "Some racing cars built by Carrozzeria Colli used Fiat 1100 mechanicals and chasis.",
      "Carrozzeria Colli worked for airforces.",
      "Carrozzeria Colli made car bodies. "
    ],
    "question": "The first automobiles built by Carrozzeria Colli were built using Fiat 1100 mechanicals and chasis.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nCompany(x) ::: x is a company.\nEstablishedBy(x, y, z) ::: x was established by y in year z.\nSpecializeIn(x, y) ::: x specializes in y.\nBuild(x, y) ::: x builds y.\nUse(x, y) ::: x uses y.\nWorkFor(x, y) ::: x works for y.\nMake(x, y) ::: x makes y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nCompany(carrozzeriaColli) ∧ EstablishedBy(carrozzeriaColli, giuseppeColli, year1931) ::: Carrozzeria Colli is a Milanese coachbuilder company that was established by Giuseppe Colli in 1931.\nCompany(carrozzeriaColli) ∧ SpecializeIn(carrozzeriaColli, aluminum) ::: Carrozzeria Colli is a company that specialized in using aluminum.\nBuild(carrozzeriaColli, racingCars) ∧ Build(carrozzeriaColli, firstAutomobiles) ∧ Build(carrozzeriaColli, carBodies) ::: The first automobiles built by Carrozzeria Colli were racing cars.\nBuild(carrozzeriaColli, racingCars) ∧ Use(racingCars, fiat1100Mechanicals) ∧ Use(racingCars, fiat1100Chasis) ::: Some racing cars built by Carrozzeria Colli used Fiat 1100 mechanicals and chassis.\nWorkFor(carrozzeriaColli, airforces) ::: Carrozzeria Colli worked for airforces.\nMake(carrozzeriaColli, carBodies) ::: Carrozzeria Colli made car bodies.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nBuild(carrozzeriaColli, firstAutomobiles) ∧ Use(firstAutomobiles, fiat1100Mechanicals) ∧ Use(firstAutomobiles, fiat1100Chasis) ::: The first automobiles built by Carrozzeria Colli were built using Fiat 1100 mechanicals and chassis.\n\"\"\""
    ]
  },
  {
    "id": 387,
    "context": [
      "John will go to the cinema if and only if Jack goes to the cinema today.",
      "Jack will go to the cinema if and only if Iron Man is on and the weather is not bad today.",
      "Some days in March have bad weather.",
      "Iron man is on.",
      "It's March now."
    ],
    "question": "John will go to the cinema.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nGoToCinema(x) ::: x will go to the cinema.\nOn(x) ::: x is on.\nBadWeather(x) ::: x has bad weather.\nMarch(x) ::: x is in March.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nGoToCinema(john) ↔ GoToCinema(jack) ::: John will go to the cinema if and only if Jack goes to the cinema today.\nGoToCinema(jack) ↔ (On(ironMan) ∧ ¬BadWeather(today)) ::: Jack will go to the cinema if and only if Iron Man is on and the weather is not bad today.\n∃x (March(x) ∧ BadWeather(x)) ::: Some days in March have bad weather.\nOn(ironMan) ::: Iron man is on.\nMarch(now) ::: It's March now.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nGoToCinema(john) ::: John will go to the cinema.\n\"\"\""
    ]
  },
  {
    "id": 388,
    "context": [
      "John will go to the cinema if and only if Jack goes to the cinema today.",
      "Jack will go to the cinema if and only if Iron Man is on and the weather is not bad today.",
      "Some days in March have bad weather.",
      "Iron man is on.",
      "It's March now."
    ],
    "question": "The weather is good today.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nGoToCinema(x) ::: x will go to the cinema.\nOn(x) ::: x is on.\nBadWeather(x) ::: x has bad weather.\nMarch(x) ::: x is in March.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nGoToCinema(john) ↔ GoToCinema(jack) ::: John will go to the cinema if and only if Jack goes to the cinema today.\nGoToCinema(jack) ↔ (On(ironMan) ∧ ¬BadWeather(today)) ::: Jack will go to the cinema if and only if Iron Man is on and the weather is not bad today.\n∃x (March(x) ∧ BadWeather(x)) ::: Some days in March have bad weather.\nOn(ironMan) ::: Iron man is on.\nMarch(now) ::: It's March now.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬BadWeather(today) ::: The weather is good today.\n\"\"\""
    ]
  },
  {
    "id": 247,
    "context": [
      "Quiksilver sells sportswear, clothing, footwear, and accessories.",
      "Flannels are a type of clothing.",
      "Joe owns an item fron Quiksilver."
    ],
    "question": "Quiksilver sells beer.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nSells(x, y) ::: x sells y.\nClothing(x) ::: x is clothing.\nFootwear(x) ::: x is footwear.\nAccessories(x) ::: x is accessories.\nOwns(x, y) ::: x owns y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Sells(quiksilver, Sportswear) ∧ Sells(quiksilver, Clothing) ∧ Sells(quiksilver, Footwear) ∧ Sells(quiksilver, Accessories)) ::: Quiksilver sells sportswear, clothing, footwear, and accessories.\nClothing(flannels) ::: Flannels are a type of clothing.\nOwns(joe, itemFromQuiksilver) ::: Joe owns an item from Quiksilver.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬Sells(quiksilver, Beer) ::: Quiksilver sells beer.\n\"\"\""
    ]
  },
  {
    "id": 248,
    "context": [
      "Quiksilver sells sportswear, clothing, footwear, and accessories.",
      "Flannels are a type of clothing.",
      "Joe owns an item fron Quiksilver."
    ],
    "question": "Joe owns a flannel.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nSells(x, y) ::: x sells y.\nTypeOf(x, y) ::: x is a type of y.\nOwns(x, y) ::: x owns y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Sells(quiksilver, sportswear) ∧ Sells(quiksilver, clothing) ∧ Sells(quiksilver, footwear) ∧ Sells(quiksilver, accessories)) ::: Quiksilver sells sportswear, clothing, footwear, and accessories.\nTypeOf(flannels, clothing) ::: Flannels are a type of clothing.\nOwns(joe, itemFromQuiksilver) ∧ Sells(quiksilver, itemFromQuiksilver) ::: Joe owns an item from Quiksilver.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nOwns(joe, flannels) ::: Joe owns a flannel.\n\"\"\""
    ]
  },
  {
    "id": 249,
    "context": [
      "Quiksilver sells sportswear, clothing, footwear, and accessories.",
      "Flannels are a type of clothing.",
      "Joe owns an item fron Quiksilver."
    ],
    "question": "Joe owns at least one a piece of sportswear, clothing, footwear, or accessory",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nSells(x, y) ::: x sells y.\nTypeOf(x, y) ::: x is a type of y.\nOwns(x, y) ::: x owns y.\nItem(x) ::: x is an item.\nSportswear(x) ::: x is sportswear.\nClothing(x) ::: x is clothing.\nFootwear(x) ::: x is footwear.\nAccessory(x) ::: x is an accessory.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Sells(quiksilver, x) → (Sportswear(x) ∨ Clothing(x) ∨ Footwear(x) ∨ Accessory(x))) ::: Quiksilver sells sportswear, clothing, footwear, and accessories.\nTypeOf(flannels, clothing) ::: Flannels are a type of clothing.\nOwns(joe, itemFromQuiksilver) ∧ Sells(quiksilver, itemFromQuiksilver) ::: Joe owns an item from Quiksilver.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n∃x (Owns(joe, x) ∧ (Sportswear(x) ∨ Clothing(x) ∨ Footwear(x) ∨ Accessory(x))) ::: Joe owns at least one piece of sportswear, clothing, footwear, or accessory.\n\"\"\""
    ]
  },
  {
    "id": 765,
    "context": [
      "No video games released by Nintendo support the PS4 platform.",
      "All video games in the Pokemon series are released by Nintendo. ",
      "All video games in the FIFA series support the PS4 platform. ",
      "All video games supporting users to simulate playing soccer games online are in the FIFA series.",
      "The video game named “Be Lionel” is in the Pokemon series or supports users to simulate playing football games online."
    ],
    "question": "The video game \"Be Lionel\" is in the pokemon series.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nSupport(x, y) ::: Video game x supports platform y.\nReleasedBy(x, y) ::: Video game x is released by company y.\nPokemon(x) ::: Video game x is in the Pokemon series.\nFIFA(x) ::: Video game x is in the FIFA series.\nSimulateSoccer(x) ::: Video game x supports users to simulate playing soccer games online.\nBeLionel(x) ::: Video game x is named \"Be Lionel\".\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (ReleasedBy(x, nintendo) → ¬Support(x, ps4)) ::: No video games released by Nintendo support the PS4 platform.\n∀x (Pokemon(x) → ReleasedBy(x, nintendo)) ::: All video games in the Pokemon series are released by Nintendo.\n∀x (FIFA(x) → Support(x, ps4)) ::: All video games in the FIFA series support the PS4 platform.\n∀x (SimulateSoccer(x) → FIFA(x)) ::: All video games supporting users to simulate playing soccer games online are in the FIFA series.\n(BeLionel(beLionel) ∧ Pokemon(beLionel)) ∨ SimulateSoccer(beLionel) ::: The video game named “Be Lionel” is in the Pokemon series or supports users to simulate playing football games online.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nPokemon(beLionel) ::: The video game \"Be Lionel\" is in the Pokemon series.\n\"\"\""
    ]
  },
  {
    "id": 766,
    "context": [
      "No video games released by Nintendo support the PS4 platform.",
      "All video games in the Pokemon series are released by Nintendo. ",
      "All video games in the FIFA series support the PS4 platform. ",
      "All video games supporting users to simulate playing soccer games online are in the FIFA series.",
      "The video game named “Be Lionel” is in the Pokemon series or supports users to simulate playing football games online."
    ],
    "question": "The video game named “Be Lionel” is not in the FIFA series or supports the PS4 platform.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nSupports(x, y) ::: Video game x supports platform y.\nReleasedBy(x, y) ::: Video game x is released by company y.\nInSeries(x, y) ::: Video game x is in series y.\nSimulate(x, y) ::: Video game x simulates activity y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (ReleasedBy(x, nintendo) → ¬Supports(x, ps4)) ::: No video games released by Nintendo support the PS4 platform.\n∀x (InSeries(x, pokemon) → ReleasedBy(x, nintendo)) ::: All video games in the Pokemon series are released by Nintendo.\n∀x (InSeries(x, fifa) → Supports(x, ps4)) ::: All video games in the FIFA series support the PS4 platform.\n∀x (Simulate(x, soccer) → InSeries(x, fifa)) ::: All video games supporting users to simulate playing soccer games online are in the FIFA series.\n(InSeries(beLionel, pokemon) ∨ Simulate(beLionel, football)) ::: The video game named “Be Lionel” is in the Pokemon series or supports users to simulate playing football games online.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬(InSeries(beLionel, fifa) ∨ Supports(beLionel, ps4)) ::: The video game named “Be Lionel” is not in the FIFA series or supports the PS4 platform.\n\"\"\""
    ]
  },
  {
    "id": 767,
    "context": [
      "No video games released by Nintendo support the PS4 platform.",
      "All video games in the Pokemon series are released by Nintendo. ",
      "All video games in the FIFA series support the PS4 platform. ",
      "All video games supporting users to simulate playing soccer games online are in the FIFA series.",
      "The video game named “Be Lionel” is in the Pokemon series or supports users to simulate playing football games online."
    ],
    "question": "The video game named “Be Lionel” is in the FIFA series or supports the PS4 platform.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nSupport(x, y) ::: Video game x supports platform y.\nReleasedBy(x, y) ::: Video game x is released by company y.\nPokemon(x) ::: Video game x is in the Pokemon series.\nFIFA(x) ::: Video game x is in the FIFA series.\nSimulateSoccer(x) ::: Video game x supports users to simulate playing soccer games online.\nBeLionel(x) ::: Video game x is named \"Be Lionel\".\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (ReleasedBy(x, nintendo) → ¬Support(x, ps4)) ::: No video games released by Nintendo support the PS4 platform.\n∀x (Pokemon(x) → ReleasedBy(x, nintendo)) ::: All video games in the Pokemon series are released by Nintendo.\n∀x (FIFA(x) → Support(x, ps4)) ::: All video games in the FIFA series support the PS4 platform.\n∀x (SimulateSoccer(x) → FIFA(x)) ::: All video games supporting users to simulate playing soccer games online are in the FIFA series.\n(BeLionel(beLionel) ∧ Pokemon(beLionel)) ∨ SimulateSoccer(beLionel) ::: The video game named “Be Lionel” is in the Pokemon series or supports users to simulate playing football games online.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n(FIFA(beLionel) ∨ Support(beLionel, ps4)) ::: The video game named “Be Lionel” is in the FIFA series or supports the PS4 platform.\n\"\"\""
    ]
  },
  {
    "id": 768,
    "context": [
      "No video games released by Nintendo support the PS4 platform.",
      "All video games in the Pokemon series are released by Nintendo. ",
      "All video games in the FIFA series support the PS4 platform. ",
      "All video games supporting users to simulate playing soccer games online are in the FIFA series.",
      "The video game named “Be Lionel” is in the Pokemon series or supports users to simulate playing football games online."
    ],
    "question": "The video game named “Be Lionel”  is not in the FIFA or Pokemon series.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nSupport(x, y) ::: Video game x supports platform y.\nReleasedBy(x, y) ::: Video game x is released by company y.\nInSeries(x, y) ::: Video game x is in series y.\nSimulate(x, y) ::: Video game x supports users to simulate activity y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (ReleasedBy(x, nintendo) → ¬Support(x, ps4)) ::: No video games released by Nintendo support the PS4 platform.\n∀x (InSeries(x, pokemon) → ReleasedBy(x, nintendo)) ::: All video games in the Pokemon series are released by Nintendo.\n∀x (InSeries(x, fifa) → Support(x, ps4)) ::: All video games in the FIFA series support the PS4 platform.\n∀x (Simulate(x, soccer) → InSeries(x, fifa)) ::: All video games supporting users to simulate playing soccer games online are in the FIFA series.\n(InSeries(beLionel, pokemon) ∨ Simulate(beLionel, football)) ::: The video game named “Be Lionel” is in the Pokemon series or supports users to simulate playing football games online.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬(InSeries(beLionel, fifa) ∨ InSeries(beLionel, pokemon)) ::: The video game named “Be Lionel” is not in the FIFA or Pokemon series.\n\"\"\""
    ]
  },
  {
    "id": 778,
    "context": [
      "No payment cards issued by Russian banks can be used with ApplePay.",
      "All MIR payment cards are issued by Russian banks.",
      "Some international payment cards can be used with ApplePay.",
      "Social payments in Russia can only be transferred to MIR payment cards.",
      "Bank of America payment cards can be used with ApplePay."
    ],
    "question": "Bank of America payment cards are international.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nIssuedByRussian(x) ::: x is issued by Russian banks.\nApplePay(x) ::: x can be used with ApplePay.\nMIR(x) ::: x is a MIR payment card.\nInternational(x) ::: x is an international payment card.\nSocialPayments(x) ::: x is a social payment.\nTransferredTo(x, y) ::: x can be transferred to y.\nBankOfAmerica(x) ::: x is a Bank of America payment card.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (IssuedByRussian(x) → ¬ApplePay(x)) ::: No payment cards issued by Russian banks can be used with ApplePay.\n∀x (MIR(x) → IssuedByRussian(x)) ::: All MIR payment cards are issued by Russian banks.\n∃x (International(x) ∧ ApplePay(x)) ::: Some international payment cards can be used with ApplePay.\n∀x (SocialPayments(x) → TransferredTo(x, MIR)) ::: Social payments in Russia can only be transferred to MIR payment cards.\nBankOfAmerica(bankOfAmerica) ∧ ApplePay(bankOfAmerica) ::: Bank of America payment cards can be used with ApplePay.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nInternational(bankOfAmerica) ::: Bank of America payment cards are international.\n\"\"\""
    ]
  },
  {
    "id": 779,
    "context": [
      "No payment cards issued by Russian banks can be used with ApplePay.",
      "All MIR payment cards are issued by Russian banks.",
      "Some international payment cards can be used with ApplePay.",
      "Social payments in Russia can only be transferred to MIR payment cards.",
      "Bank of America payment cards can be used with ApplePay."
    ],
    "question": "Bank of America payment cards are international and can be used to transfer social payments in Russia.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nIssuedByRussianBank(x) ::: x is a payment card issued by Russian banks.\nApplePay(x) ::: x can be used with ApplePay.\nMIR(x) ::: x is a MIR payment card.\nInternational(x) ::: x is an international payment card.\nSocialPayments(x) ::: x is a social payment in Russia.\nTransferTo(x, y) ::: x can be transferred to y.\nBankOfAmerica(x) ::: x is a Bank of America payment card.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (IssuedByRussianBank(x) → ¬ApplePay(x)) ::: No payment cards issued by Russian banks can be used with ApplePay.\n∀x (MIR(x) → IssuedByRussianBank(x)) ::: All MIR payment cards are issued by Russian banks.\n∃x (International(x) ∧ ApplePay(x)) ::: Some international payment cards can be used with ApplePay.\n∀x (SocialPayments(x) → TransferTo(x, MIR)) ::: Social payments in Russia can only be transferred to MIR payment cards.\nBankOfAmerica(boa) ∧ ApplePay(boa) ::: Bank of America payment cards can be used with ApplePay.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nInternational(boa) ∧ TransferTo(SocialPayments, MIR) ::: Bank of America payment cards are international and can be used to transfer social payments in Russia.\n\"\"\""
    ]
  },
  {
    "id": 780,
    "context": [
      "No payment cards issued by Russian banks can be used with ApplePay.",
      "All MIR payment cards are issued by Russian banks.",
      "Some international payment cards can be used with ApplePay.",
      "Social payments in Russia can only be transferred to MIR payment cards.",
      "Bank of America payment cards can be used with ApplePay."
    ],
    "question": "If Bank of America payment cards are international or issued by Russian banks, then they can not be used to transfer social payments in Russia.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nRussian(x) ::: x is issued by Russian banks.\nApplePay(x) ::: x can be used with ApplePay.\nMIR(x) ::: x is a MIR payment card.\nInternational(x) ::: x is an international payment card.\nSocialPayments(x) ::: x is a social payment in Russia.\nBankOfAmerica(x) ::: x is a Bank of America payment card.\nTransfer(x, y) ::: x can be transferred to y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Russian(x) → ¬ApplePay(x)) ::: No payment cards issued by Russian banks can be used with ApplePay.\n∀x (MIR(x) → Russian(x)) ::: All MIR payment cards are issued by Russian banks.\n∃x (International(x) ∧ ApplePay(x)) ::: Some international payment cards can be used with ApplePay.\n∀x (SocialPayments(x) → Transfer(x, MIR(x))) ::: Social payments in Russia can only be transferred to MIR payment cards.\nBankOfAmerica(b) ∧ ApplePay(b) ::: Bank of America payment cards can be used with ApplePay.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n(BankOfAmerica(x) ∧ International(x)) ∨ Russian(x) → ¬Transfer(SocialPayments, x) ::: If Bank of America payment cards are international or issued by Russian banks, then they can not be used to transfer social payments in Russia.\n\"\"\""
    ]
  },
  {
    "id": 151,
    "context": [
      "The Lumina APV is produced by Chevrolet. ",
      "The Astro is a van produced by Chevrolet. ",
      "Cars produced by Chevrolet are either cars or vans."
    ],
    "question": "The Lumina APV is van.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nProducedBy(x, y) ::: x is produced by y.\nVan(x) ::: x is a van.\nCar(x) ::: x is a car.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nProducedBy(luminaAPV, chevrolet) ::: The Lumina APV is produced by Chevrolet.\nVan(astro) ∧ ProducedBy(astro, chevrolet) ::: The Astro is a van produced by Chevrolet.\n∀x (ProducedBy(x, chevrolet) → (Car(x) ∨ Van(x))) ::: Cars produced by Chevrolet are either cars or vans.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nVan(luminaAPV) ::: The Lumina APV is a van.\n\"\"\""
    ]
  },
  {
    "id": 152,
    "context": [
      "The Lumina APV is produced by Chevrolet. ",
      "The Astro is a van produced by Chevrolet. ",
      "Cars produced by Chevrolet are either cars or vans."
    ],
    "question": "The Lumina APV is either a car or a van.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nProducedBy(x, y) ::: x is produced by y.\nCar(x) ::: x is a car.\nVan(x) ::: x is a van.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nProducedBy(luminaAPV, chevrolet) ::: The Lumina APV is produced by Chevrolet.\nProducedBy(astro, chevrolet) ::: The Astro is a van produced by Chevrolet.\n∀x (ProducedBy(x, chevrolet) → (Car(x) ∨ Van(x))) ::: Cars produced by Chevrolet are either cars or vans.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nCar(luminaAPV) ∨ Van(luminaAPV) ::: The Lumina APV is either a car or a van.\n\"\"\""
    ]
  },
  {
    "id": 153,
    "context": [
      "The Lumina APV is produced by Chevrolet. ",
      "The Astro is a van produced by Chevrolet. ",
      "Cars produced by Chevrolet are either cars or vans."
    ],
    "question": "The Astro is a van.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nProducedBy(x, y) ::: x is produced by y.\nVan(x) ::: x is a van.\nCar(x) ::: x is a car.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nProducedBy(luminaAPV, chevrolet) ::: The Lumina APV is produced by Chevrolet.\nVan(astro) ∧ ProducedBy(astro, chevrolet) ::: The Astro is a van produced by Chevrolet.\n∀x ((ProducedBy(x, chevrolet) → Car(x)) ∨ Van(x)) ::: Cars produced by Chevrolet are either cars or vans.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nVan(astro) ::: The Astro is a van.\n\"\"\""
    ]
  },
  {
    "id": 154,
    "context": [
      "The Lumina APV is produced by Chevrolet. ",
      "The Astro is a van produced by Chevrolet. ",
      "Cars produced by Chevrolet are either cars or vans."
    ],
    "question": "The Astro is a car.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nProducedBy(x, y) ::: x is produced by y.\nCar(x) ::: x is a car.\nVan(x) ::: x is a van.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nProducedBy(luminaAPV, chevrolet) ::: The Lumina APV is produced by Chevrolet.\nProducedBy(astro, chevrolet) ::: The Astro is a van produced by Chevrolet.\n∀x (ProducedBy(x, chevrolet) → (Car(x) ∨ Van(x))) ::: Cars produced by Chevrolet are either cars or vans.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nCar(astro) ::: The Astro is a car.\n\"\"\""
    ]
  },
  {
    "id": 1128,
    "context": [
      "Everyone who works in person is a commuter.",
      "People either work in person or work from home.",
      "Everyone who works from home has a relaxed schedule.",
      "George is either a commuter or has a home office setup.",
      "If George is either a person who works from home or has a home office setup, then George is not a person who works from home and a commuter."
    ],
    "question": "George is a person who works from home.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nWorksInPerson(x) ::: x works in person.\nWorksFromHome(x) ::: x works from home.\nCommuter(x) ::: x is a commuter.\nRelaxedSchedule(x) ::: x has a relaxed schedule.\nHomeOfficeSetup(x) ::: x has a home office setup.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (WorksInPerson(x) → Commuter(x)) ::: Everyone who works in person is a commuter.\n∀x (WorksInPerson(x) ⊕ WorksFromHome(x)) ::: People either work in person or work from home.\n∀x (WorksFromHome(x) → RelaxedSchedule(x)) ::: Everyone who works from home has a relaxed schedule.\nCommuter(george) ∨ HomeOfficeSetup(george) ::: George is either a commuter or has a home office setup.\n(WorksFromHome(george) ∨ HomeOfficeSetup(george)) → ¬(WorksFromHome(george) ∧ Commuter(george)) ::: If George is either a person who works from home or has a home office setup, then George is not a person who works from home and a commuter.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nWorksFromHome(george) ::: George is a person who works from home.\n\"\"\""
    ]
  },
  {
    "id": 1129,
    "context": [
      "Everyone who works in person is a commuter.",
      "People either work in person or work from home.",
      "Everyone who works from home has a relaxed schedule.",
      "George is either a commuter or has a home office setup.",
      "If George is either a person who works from home or has a home office setup, then George is not a person who works from home and a commuter."
    ],
    "question": "If George is not a person who works from home and a person who works in person, then George is neither a commuter nor a person who has a relaxed schedule.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nWorksInPerson(x) ::: x works in person.\nCommuter(x) ::: x is a commuter.\nWorksFromHome(x) ::: x works from home.\nRelaxedSchedule(x) ::: x has a relaxed schedule.\nHomeOfficeSetup(x) ::: x has a home office setup.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (WorksInPerson(x) → Commuter(x)) ::: Everyone who works in person is a commuter.\n∀x (WorksInPerson(x) ⊕ WorksFromHome(x)) ::: People either work in person or work from home.\n∀x (WorksFromHome(x) → RelaxedSchedule(x)) ::: Everyone who works from home has a relaxed schedule.\n(Commuter(george) ∨ HomeOfficeSetup(george)) ::: George is either a commuter or has a home office setup.\n(WorksFromHome(george) ∨ HomeOfficeSetup(george)) → ¬(WorksFromHome(george) ∧ Commuter(george)) ::: If George is either a person who works from home or has a home office setup, then George is not a person who works from home and a commuter.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬(WorksFromHome(george) ∧ WorksInPerson(george)) → ¬(Commuter(george) ∨ RelaxedSchedule(george)) ::: If George is not a person who works from home and a person who works in person, then George is neither a commuter nor a person who has a relaxed schedule.\n\"\"\""
    ]
  },
  {
    "id": 1130,
    "context": [
      "Everyone who works in person is a commuter.",
      "People either work in person or work from home.",
      "Everyone who works from home has a relaxed schedule.",
      "George is either a commuter or has a home office setup.",
      "If George is either a person who works from home or has a home office setup, then George is not a person who works from home and a commuter."
    ],
    "question": "If George is either a person who has a home office setup and a person who works in person, or neither a person who has a home office setup nor a person who works in person, then George is either a person who works from home or a person who has a relaxed schedule.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nWorksInPerson(x) ::: x works in person.\nCommuter(x) ::: x is a commuter.\nWorksFromHome(x) ::: x works from home.\nRelaxedSchedule(x) ::: x has a relaxed schedule.\nHomeOfficeSetup(x) ::: x has a home office setup.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (WorksInPerson(x) → Commuter(x)) ::: Everyone who works in person is a commuter.\n∀x (WorksInPerson(x) ⊕ WorksFromHome(x)) ::: People either work in person or work from home.\n∀x (WorksFromHome(x) → RelaxedSchedule(x)) ::: Everyone who works from home has a relaxed schedule.\nCommuter(george) ⊕ HomeOfficeSetup(george) ::: George is either a commuter or has a home office setup.\n(WorksFromHome(george) ∨ HomeOfficeSetup(george)) → ¬(WorksFromHome(george) ∧ Commuter(george)) ::: If George is either a person who works from home or has a home office setup, then George is not a person who works from home and a commuter.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n((HomeOfficeSetup(george) ∧ WorksInPerson(george)) ∨ ¬(HomeOfficeSetup(george) ∨ WorksInPerson(george))) → (WorksFromHome(george) ∨ RelaxedSchedule(george)) ::: If George is either a person who has a home office setup and a person who works in person, or neither a person who has a home office setup nor a person who works in person, then George is either a person who works from home or a person who has a relaxed schedule.\n\"\"\""
    ]
  },
  {
    "id": 81,
    "context": [
      "Jason Kramer is an American music supervisor.",
      "Some American radio personalities are also music supervisors. ",
      "Anyone who hosts a show on a public radio station is a radio personality.",
      "Joe Rogan is a radio personality.",
      "Jason Kramer hosted a show on a public radio station."
    ],
    "question": "Joe Rogan is American.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nAmerican(x) ::: x is American.\nMusicSupervisor(x) ::: x is a music supervisor.\nRadioPersonality(x) ::: x is a radio personality.\nHostsShow(x, y) ::: x hosts a show on y.\nPublicRadioStation(x) ::: x is a public radio station.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nAmerican(jason) ∧ MusicSupervisor(jason) ::: Jason Kramer is an American music supervisor.\n∃x (American(x) ∧ RadioPersonality(x) ∧ MusicSupervisor(x)) ::: Some American radio personalities are also music supervisors.\n∀x (HostsShow(x, PublicRadioStation) → RadioPersonality(x)) ::: Anyone who hosts a show on a public radio station is a radio personality.\nRadioPersonality(joeRogan) ::: Joe Rogan is a radio personality.\nHostsShow(jason, PublicRadioStation) ::: Jason Kramer hosted a show on a public radio station.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nAmerican(joeRogan) ::: Joe Rogan is American.\n\"\"\""
    ]
  },
  {
    "id": 82,
    "context": [
      "Jason Kramer is an American music supervisor.",
      "Some American radio personalities are also music supervisors. ",
      "Anyone who hosts a show on a public radio station is a radio personality.",
      "Joe Rogan is a radio personality.",
      "Jason Kramer hosted a show on a public radio station."
    ],
    "question": "Jason Kramer is a music supervisor.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nAmerican(x) ::: x is an American person.\nMusicSupervisor(x) ::: x is a music supervisor.\nRadioPersonality(x) ::: x is a radio personality.\nHostsShow(x, y) ::: x hosts a show on y.\nPublicRadioStation(x) ::: x is a public radio station.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nAmerican(jason) ∧ MusicSupervisor(jason) ::: Jason Kramer is an American music supervisor.\n∃x (American(x) ∧ RadioPersonality(x) ∧ MusicSupervisor(x)) ::: Some American radio personalities are also music supervisors.\n∀x (HostsShow(x, PublicRadioStation) → RadioPersonality(x)) ::: Anyone who hosts a show on a public radio station is a radio personality.\nRadioPersonality(joeRogan) ::: Joe Rogan is a radio personality.\nHostsShow(jason, PublicRadioStation) ::: Jason Kramer hosted a show on a public radio station.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nMusicSupervisor(jason) ::: Jason Kramer is a music supervisor.\n\"\"\""
    ]
  },
  {
    "id": 83,
    "context": [
      "Jason Kramer is an American music supervisor.",
      "Some American radio personalities are also music supervisors. ",
      "Anyone who hosts a show on a public radio station is a radio personality.",
      "Joe Rogan is a radio personality.",
      "Jason Kramer hosted a show on a public radio station."
    ],
    "question": "Jason Kramer is a radio personality.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nAmerican(x) ::: x is an American.\nMusicSupervisor(x) ::: x is a music supervisor.\nRadioPersonality(x) ::: x is a radio personality.\nHostsShow(x, y) ::: x hosts a show on y.\nPublicRadioStation(x) ::: x is a public radio station.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nAmerican(jason) ∧ MusicSupervisor(jason) ::: Jason Kramer is an American music supervisor.\n∃x (American(x) ∧ RadioPersonality(x) ∧ MusicSupervisor(x)) ::: Some American radio personalities are also music supervisors.\n∀x (HostsShow(x, publicRadioStation) → RadioPersonality(x)) ::: Anyone who hosts a show on a public radio station is a radio personality.\nRadioPersonality(joeRogan) ::: Joe Rogan is a radio personality.\nHostsShow(jason, publicRadioStation) ::: Jason Kramer hosted a show on a public radio station.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nRadioPersonality(jason) ::: Jason Kramer is a radio personality.\n\"\"\""
    ]
  },
  {
    "id": 1228,
    "context": [
      "No coffee sold in Walmart is produced in France. ",
      "All coffee supplied by the company is sold in Walmart. ",
      "All coffee produced in Columbia is produced in France. ",
      "All coffee favored by local residents is coffee produced in Columbia. ",
      "All coffee with high prices is favored by local residents. ",
      "Civet Coffee is not produced in Columbia and is cheap.",
      "Jamaica Blue is sold in Walmart or favored by local residents."
    ],
    "question": "Civet Coffee is produced in France.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nSoldInWalmart(x) ::: x is coffee sold in Walmart.\nProducedInFrance(x) ::: x is coffee produced in France.\nSuppliedByCompany(x) ::: x is coffee supplied by the company.\nProducedInColumbia(x) ::: x is coffee produced in Columbia.\nFavoredByResidents(x) ::: x is coffee favored by local residents.\nHighPrice(x) ::: x is coffee with high prices.\nCheap(x) ::: x is cheap coffee.\nCivetCoffee(x) ::: x is Civet Coffee.\nJamaicaBlue(x) ::: x is Jamaica Blue.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (SoldInWalmart(x) → ¬ProducedInFrance(x)) ::: No coffee sold in Walmart is produced in France.\n∀x (SuppliedByCompany(x) → SoldInWalmart(x)) ::: All coffee supplied by the company is sold in Walmart.\n∀x (ProducedInColumbia(x) → ProducedInFrance(x)) ::: All coffee produced in Columbia is produced in France.\n∀x (FavoredByResidents(x) → ProducedInColumbia(x)) ::: All coffee favored by local residents is coffee produced in Columbia.\n∀x (HighPrice(x) → FavoredByResidents(x)) ::: All coffee with high prices is favored by local residents.\n¬(ProducedInColumbia(CivetCoffee) ∧ Cheap(CivetCoffee)) ::: Civet Coffee is not produced in Columbia and is cheap.\n(JamaicaBlue(x) → SoldInWalmart(x)) ∨ FavoredByResidents(JamaicaBlue) ::: Jamaica Blue is sold in Walmart or favored by local residents.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nProducedInFrance(CivetCoffee) ::: Civet Coffee is produced in France.\n\"\"\""
    ]
  },
  {
    "id": 1229,
    "context": [
      "No coffee sold in Walmart is produced in France. ",
      "All coffee supplied by the company is sold in Walmart. ",
      "All coffee produced in Columbia is produced in France. ",
      "All coffee favored by local residents is coffee produced in Columbia. ",
      "All coffee with high prices is favored by local residents. ",
      "Civet Coffee is not produced in Columbia and is cheap.",
      "Jamaica Blue is sold in Walmart or favored by local residents."
    ],
    "question": "Civet Coffee is not produced in France.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nSoldIn(x, y) ::: x is sold in y.\nProducedIn(x, y) ::: x is produced in y.\nSuppliedBy(x, y) ::: x is supplied by y.\nProducedByCompany(x) ::: x is produced by the company.\nProducedInFrance(x) ::: x is produced in France.\nProducedInColumbia(x) ::: x is produced in Columbia.\nFavoredByLocalResidents(x) ::: x is favored by local residents.\nHighPrice(x) ::: x has high prices.\nCheap(x) ::: x is cheap.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (SoldIn(x, walmart) → ¬ProducedIn(x, france)) ::: No coffee sold in Walmart is produced in France.\n∀x (SuppliedBy(ProducedByCompany(x), x) → SoldIn(x, walmart)) ::: All coffee supplied by the company is sold in Walmart.\n∀x (ProducedIn(x, columbia) → ProducedIn(x, france)) ::: All coffee produced in Columbia is produced in France.\n∀x (FavoredByLocalResidents(x) → ProducedIn(x, columbia)) ::: All coffee favored by local residents is coffee produced in Columbia.\n∀x (HighPrice(x) → FavoredByLocalResidents(x)) ::: All coffee with high prices is favored by local residents.\n¬(ProducedIn(CivetCoffee, columbia) ∧ Cheap(CivetCoffee)) ::: Civet Coffee is not produced in Columbia and is cheap.\n(SoldIn(JamaicaBlue, walmart) ∨ FavoredByLocalResidents(JamaicaBlue)) ::: Jamaica Blue is sold in Walmart or favored by local residents.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬ProducedIn(CivetCoffee, france) ::: Civet Coffee is not produced in France.\n\"\"\""
    ]
  },
  {
    "id": 1230,
    "context": [
      "No coffee sold in Walmart is produced in France. ",
      "All coffee supplied by the company is sold in Walmart. ",
      "All coffee produced in Columbia is produced in France. ",
      "All coffee favored by local residents is coffee produced in Columbia. ",
      "All coffee with high prices is favored by local residents. ",
      "Civet Coffee is not produced in Columbia and is cheap.",
      "Jamaica Blue is sold in Walmart or favored by local residents."
    ],
    "question": "Jamaica Blue is expensive and supplied by the company.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nProducedInFrance(x) ::: x is produced in France.\nSoldInWalmart(x) ::: x is sold in Walmart.\nSuppliedByCompany(x) ::: x is supplied by the company.\nProducedInColumbia(x) ::: x is produced in Columbia.\nFavoredByLocalResidents(x) ::: x is favored by local residents.\nHighPrice(x) ::: x has high prices.\nCheap(x) ::: x is cheap.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Coffee(x) ∧ SoldInWalmart(x) → ¬ProducedInFrance(x)) ::: No coffee sold in Walmart is produced in France.\n∀x (Coffee(x) ∧ SuppliedByCompany(x) → SoldInWalmart(x)) ::: All coffee supplied by the company is sold in Walmart.\n∀x (Coffee(x) ∧ ProducedInColumbia(x) → ProducedInFrance(x)) ::: All coffee produced in Columbia is produced in France.\n∀x (Coffee(x) ∧ FavoredByLocalResidents(x) → ProducedInColumbia(x)) ::: All coffee favored by local residents is coffee produced in Columbia.\n∀x (Coffee(x) ∧ HighPrice(x) → FavoredByLocalResidents(x)) ::: All coffee with high prices is favored by local residents.\n¬(ProducedInColumbia(CivetCoffee) ∧ Cheap(CivetCoffee)) ::: Civet Coffee is not produced in Columbia and is cheap.\n(SoldInWalmart(JamaicaBlue) ∨ FavoredByLocalResidents(JamaicaBlue)) ::: Jamaica Blue is sold in Walmart or favored by local residents.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nHighPrice(JamaicaBlue) ∧ SuppliedByCompany(JamaicaBlue) ::: Jamaica Blue is expensive and supplied by the company.\n\"\"\""
    ]
  },
  {
    "id": 1231,
    "context": [
      "No coffee sold in Walmart is produced in France. ",
      "All coffee supplied by the company is sold in Walmart. ",
      "All coffee produced in Columbia is produced in France. ",
      "All coffee favored by local residents is coffee produced in Columbia. ",
      "All coffee with high prices is favored by local residents. ",
      "Civet Coffee is not produced in Columbia and is cheap.",
      "Jamaica Blue is sold in Walmart or favored by local residents."
    ],
    "question": "Jamaica Blue is not expensive and is not supplied by the company.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nProducedIn(x, y) ::: x is produced in y.\nSoldIn(x, y) ::: x is sold in y.\nSuppliedBy(x, y) ::: x is supplied by y.\nFavoredBy(x, y) ::: x is favored by y.\nHighPrice(x) ::: x has high prices.\nCheap(x) ::: x is cheap.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Coffee(x) ∧ SoldIn(x, walmart) → ¬ProducedIn(x, france)) ::: No coffee sold in Walmart is produced in France.\n∀x (Coffee(x) ∧ SuppliedBy(company) → SoldIn(x, walmart)) ::: All coffee supplied by the company is sold in Walmart.\n∀x (Coffee(x) ∧ ProducedIn(x, columbia) → ProducedIn(x, france)) ::: All coffee produced in Columbia is produced in France.\n∀x (Coffee(x) ∧ FavoredBy(residents) → ProducedIn(x, columbia)) ::: All coffee favored by local residents is coffee produced in Columbia.\n∀x (Coffee(x) ∧ HighPrice(x) → FavoredBy(residents)) ::: All coffee with high prices is favored by local residents.\n¬ProducedIn(civetCoffee, columbia) ∧ Cheap(civetCoffee) ::: Civet Coffee is not produced in Columbia and is cheap.\n(SoldIn(jamaicaBlue, walmart) ∨ FavoredBy(residents, jamaicaBlue)) ::: Jamaica Blue is sold in Walmart or favored by local residents.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬HighPrice(jamaicaBlue) ∧ ¬SuppliedBy(jamaicaBlue, company) ::: Jamaica Blue is not expensive and is not supplied by the company.\n\"\"\""
    ]
  },
  {
    "id": 600,
    "context": [
      "There are two places named Galicia: either in Spain or in Poland.",
      "Spain is in Europe.",
      "Poland is in Europe.",
      "Rochelle lives in Europe.",
      "Dominique does not live in Europe.",
      "Alfonso lives in Galicia."
    ],
    "question": "Rochelle lives in Galicia.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nPlace(x) ::: x is a place.\nGalicia(x) ::: x is named Galicia.\nIn(x, y) ::: x is in y.\nEurope(x) ::: x is in Europe.\nLivesIn(x, y) ::: x lives in y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∃x (Galicia(x) ∧ (In(x, Spain) ∨ In(x, Poland))) ::: There are two places named Galicia: either in Spain or in Poland.\nIn(spain, Europe) ::: Spain is in Europe.\nIn(poland, Europe) ::: Poland is in Europe.\nLivesIn(rochelle, Europe) ::: Rochelle lives in Europe.\n¬LivesIn(dominique, Europe) ::: Dominique does not live in Europe.\nLivesIn(alfonso, Galicia) ::: Alfonso lives in Galicia.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nLivesIn(rochelle, Galicia) ::: Rochelle lives in Galicia.\n\"\"\""
    ]
  },
  {
    "id": 601,
    "context": [
      "There are two places named Galicia: either in Spain or in Poland.",
      "Spain is in Europe.",
      "Poland is in Europe.",
      "Rochelle lives in Europe.",
      "Dominique does not live in Europe.",
      "Alfonso lives in Galicia."
    ],
    "question": "Dominique does not live in Spain.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nPlace(x) ::: x is a place.\nIn(x, y) ::: x is in y.\nLive(x, y) ::: x lives in y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∃x (Place(galicia) ∧ (In(galicia, spain) ∨ In(galicia, poland))) ::: There are two places named Galicia: either in Spain or in Poland.\nIn(spain, europe) ::: Spain is in Europe.\nIn(poland, europe) ::: Poland is in Europe.\nLive(rochelle, europe) ::: Rochelle lives in Europe.\n¬Live(dominique, europe) ::: Dominique does not live in Europe.\nLive(alfonso, galicia) ::: Alfonso lives in Galicia.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬Live(dominique, spain) ::: Dominique does not live in Spain.\n\"\"\""
    ]
  },
  {
    "id": 602,
    "context": [
      "There are two places named Galicia: either in Spain or in Poland.",
      "Spain is in Europe.",
      "Poland is in Europe.",
      "Rochelle lives in Europe.",
      "Dominique does not live in Europe.",
      "Alfonso lives in Galicia."
    ],
    "question": "Alfonso lives in Europe.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nPlace(x) ::: x is a place.\nIn(x, y) ::: x is in y.\nLives(x, y) ::: x lives in y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∃x (Place(galicia) ∧ In(galicia, spain)) ∨ In(galicia, poland) ::: There are two places named Galicia: either in Spain or in Poland.\nIn(spain, europe) ::: Spain is in Europe.\nIn(poland, europe) ::: Poland is in Europe.\nLives(rochelle, europe) ::: Rochelle lives in Europe.\n¬Lives(dominique, europe) ::: Dominique does not live in Europe.\nLives(alfonso, galicia) ::: Alfonso lives in Galicia.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nLives(alfonso, europe) ::: Alfonso lives in Europe.\n\"\"\""
    ]
  },
  {
    "id": 322,
    "context": [
      "Ralph Hammerthaler was born in Wasserburg am Inn.",
      "Wasserburg am Inn is in Germany.",
      "Germany is in Europe.",
      "Ralph Hammerthaler is a German writer.",
      "Ralph Hammerthaler was born in 1965. "
    ],
    "question": "Ralph Hammerthaler is a writer born in Asia.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nBornIn(x, y) ::: x was born in y.\nIn(x, y) ::: x is in y.\nWriter(x) ::: x is a writer.\nGerman(x) ::: x is German.\nBorn(x, y) ::: x was born in year y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nBornIn(ralph, wasserburgAmInn) ::: Ralph Hammerthaler was born in Wasserburg am Inn.\nIn(wasserburgAmInn, germany) ::: Wasserburg am Inn is in Germany.\nIn(germany, europe) ::: Germany is in Europe.\nGerman(ralph) ∧ Writer(ralph) ::: Ralph Hammerthaler is a German writer.\nBorn(ralph, 1965) ::: Ralph Hammerthaler was born in 1965.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n∃x (Writer(x) ∧ BornIn(x, asia)) ::: Ralph Hammerthaler is a writer born in Asia.\n\"\"\""
    ]
  },
  {
    "id": 323,
    "context": [
      "Ralph Hammerthaler was born in Wasserburg am Inn.",
      "Wasserburg am Inn is in Germany.",
      "Germany is in Europe.",
      "Ralph Hammerthaler is a German writer.",
      "Ralph Hammerthaler was born in 1965. "
    ],
    "question": "Ralph Hammerthaler lives in Germany.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nBornIn(x, y) ::: x was born in y.\nLocatedIn(x, y) ::: x is located in y.\nIn(x, y) ::: x is in y.\nWriter(x) ::: x is a writer.\nBornYear(x, y) ::: x was born in year y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nBornIn(ralph, wasserburgAmInn) ::: Ralph Hammerthaler was born in Wasserburg am Inn.\nLocatedIn(wasserburgAmInn, germany) ::: Wasserburg am Inn is in Germany.\nLocatedIn(germany, europe) ::: Germany is in Europe.\nWriter(ralph) ∧ LocatedIn(ralph, germany) ::: Ralph Hammerthaler is a German writer.\nBornYear(ralph, 1965) ::: Ralph Hammerthaler was born in 1965.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nLocatedIn(ralph, germany) ::: Ralph Hammerthaler lives in Germany.\n\"\"\""
    ]
  },
  {
    "id": 1171,
    "context": [
      "All books written by Tomas have sold more than 1 million copies. ",
      "Some books that have won Hugo Awards are written by Tomas.",
      "All books about the future are inspired by Shakespeare. ",
      "2001 is a book either inspired from Shakespeare or it has sold more than 1 million copies.",
      "2001 is a book that has either sold more than 1 million copies or it was written by Tomas."
    ],
    "question": "2001 is a book that has won a Hugo Award.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nWrittenBy(x, y) ::: x is written by y.\nSoldMoreThan1Million(x) ::: x has sold more than 1 million copies.\nWonHugoAward(x) ::: x has won a Hugo Award.\nInspiredByShakespeare(x) ::: x is inspired by Shakespeare.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (WrittenBy(x, tomas) → SoldMoreThan1Million(x)) ::: All books written by Tomas have sold more than 1 million copies.\n∃x (WonHugoAward(x) ∧ WrittenBy(x, tomas)) ::: Some books that have won Hugo Awards are written by Tomas.\n∀x (InspiredByShakespeare(x) → BookAboutFuture(x)) ::: All books about the future are inspired by Shakespeare.\n(Book2001 ∧ (InspiredByShakespeare(book2001) ∨ SoldMoreThan1Million(book2001))) ::: 2001 is a book either inspired from Shakespeare or it has sold more than 1 million copies.\n(Book2001 ∧ (SoldMoreThan1Million(book2001) ∨ WrittenBy(book2001, tomas))) ::: 2001 is a book that has either sold more than 1 million copies or it was written by Tomas.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nWonHugoAward(book2001) ::: 2001 is a book that has won a Hugo Award.\n\"\"\""
    ]
  },
  {
    "id": 1172,
    "context": [
      "All books written by Tomas have sold more than 1 million copies. ",
      "Some books that have won Hugo Awards are written by Tomas.",
      "All books about the future are inspired by Shakespeare. ",
      "2001 is a book either inspired from Shakespeare or it has sold more than 1 million copies.",
      "2001 is a book that has either sold more than 1 million copies or it was written by Tomas."
    ],
    "question": "2001 is a book that has won a Hugo Award and is about the future.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nWrittenBy(x, y) ::: x is written by y.\nSoldMoreThan1Million(x) ::: x has sold more than 1 million copies.\nWonHugoAward(x) ::: x has won a Hugo Award.\nInspiredByShakespeare(x) ::: x is inspired by Shakespeare.\nAboutFuture(x) ::: x is about the future.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (WrittenBy(x, tomas) → SoldMoreThan1Million(x)) ::: All books written by Tomas have sold more than 1 million copies.\n∃x (WonHugoAward(x) ∧ WrittenBy(x, tomas)) ::: Some books that have won Hugo Awards are written by Tomas.\n∀x (AboutFuture(x) → InspiredByShakespeare(x)) ::: All books about the future are inspired by Shakespeare.\n(InspiredByShakespeare(book2001) ∨ SoldMoreThan1Million(book2001)) ::: 2001 is a book either inspired from Shakespeare or it has sold more than 1 million copies.\n(SoldMoreThan1Million(book2001) ∨ WrittenBy(book2001, tomas)) ::: 2001 is a book that has either sold more than 1 million copies or it was written by Tomas.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nWonHugoAward(book2001) ∧ AboutFuture(book2001) ::: 2001 is a book that has won a Hugo Award and is about the future.\n\"\"\""
    ]
  },
  {
    "id": 1173,
    "context": [
      "All books written by Tomas have sold more than 1 million copies. ",
      "Some books that have won Hugo Awards are written by Tomas.",
      "All books about the future are inspired by Shakespeare. ",
      "2001 is a book either inspired from Shakespeare or it has sold more than 1 million copies.",
      "2001 is a book that has either sold more than 1 million copies or it was written by Tomas."
    ],
    "question": "If 2001 either has won a Hugo Award and is about the future, or neither has won a Hugo Award nor is about the future, then 2001 has neither won a Hugo Award nor is written by Tomas.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nSoldMoreThan1Million(x) ::: x has sold more than 1 million copies.\nWrittenByTomas(x) ::: x is written by Tomas.\nWonHugoAward(x) ::: x has won a Hugo Award.\nAboutFuture(x) ::: x is about the future.\nInspiredByShakespeare(x) ::: x is inspired by Shakespeare.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (WrittenByTomas(x) → SoldMoreThan1Million(x)) ::: All books written by Tomas have sold more than 1 million copies.\n∃x (WonHugoAward(x) ∧ WrittenByTomas(x)) ::: Some books that have won Hugo Awards are written by Tomas.\n∀x (AboutFuture(x) → InspiredByShakespeare(x)) ::: All books about the future are inspired by Shakespeare.\n(SoldMoreThan1Million(book2001) ∨ InspiredByShakespeare(book2001)) ::: 2001 is a book either inspired from Shakespeare or it has sold more than 1 million copies.\n(SoldMoreThan1Million(book2001) ∨ WrittenByTomas(book2001)) ::: 2001 is a book that has either sold more than 1 million copies or it was written by Tomas.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n(WonHugoAward(book2001) ∧ AboutFuture(book2001)) ⊕ ¬(WonHugoAward(book2001) ∨ AboutFuture(book2001)) → ¬(WonHugoAward(book2001) ∨ WrittenByTomas(book2001)) ::: If 2001 either has won a Hugo Award and is about the future, or neither has won a Hugo Award nor is about the future, then 2001 has neither won a Hugo Award nor is written by Tomas.\n\"\"\""
    ]
  },
  {
    "id": 1398,
    "context": [
      "No grass is food. ",
      "All meadows are grass.",
      "All edible things are food. ",
      "All fruits are edible.",
      "All lemons are fruit.",
      "Grapes are not edible and lemons.",
      "Bananas are grass or fruit."
    ],
    "question": "Grapes are a food.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nFood(x) ::: x is food.\nGrass(x) ::: x is grass.\nMeadow(x) ::: x is a meadow.\nEdible(x) ::: x is edible.\nFruit(x) ::: x is a fruit.\nLemon(x) ::: x is a lemon.\nGrape(x) ::: x is a grape.\nBanana(x) ::: x is a banana.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Grass(x) → ¬Food(x)) ::: No grass is food.\n∀x (Meadow(x) → Grass(x)) ::: All meadows are grass.\n∀x (Edible(x) → Food(x)) ::: All edible things are food.\n∀x (Fruit(x) → Edible(x)) ::: All fruits are edible.\n∀x (Lemon(x) → Fruit(x)) ::: All lemons are fruit.\n¬(Edible(grape) ∧ Lemon(grape)) ::: Grapes are not edible and lemons.\nBanana(banana) → Grass(banana) ∨ Fruit(banana) ::: Bananas are grass or fruit.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nFood(grape) ::: Grapes are a food.\n\"\"\""
    ]
  },
  {
    "id": 1399,
    "context": [
      "No grass is food. ",
      "All meadows are grass.",
      "All edible things are food. ",
      "All fruits are edible.",
      "All lemons are fruit.",
      "Grapes are not edible and lemons.",
      "Bananas are grass or fruit."
    ],
    "question": "Grapes are not a food.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nFood(x) ::: x is food.\nGrass(x) ::: x is grass.\nMeadow(x) ::: x is a meadow.\nEdible(x) ::: x is edible.\nFruit(x) ::: x is a fruit.\nLemon(x) ::: x is a lemon.\nGrapes(x) ::: x is grapes.\nBananas(x) ::: x is bananas.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Grass(x) → ¬Food(x)) ::: No grass is food.\n∀x (Meadow(x) → Grass(x)) ::: All meadows are grass.\n∀x (Edible(x) → Food(x)) ::: All edible things are food.\n∀x (Fruit(x) → Edible(x)) ::: All fruits are edible.\n∀x (Lemon(x) → Fruit(x)) ::: All lemons are fruit.\n¬(Edible(grapes) ∧ Lemon(grapes)) ::: Grapes are not edible and lemons.\n(Bananas(grapes) ∨ Fruit(grapes)) ::: Bananas are grass or fruit.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬Food(grapes) ::: Grapes are not a food.\n\"\"\""
    ]
  },
  {
    "id": 1400,
    "context": [
      "No grass is food. ",
      "All meadows are grass.",
      "All edible things are food. ",
      "All fruits are edible.",
      "All lemons are fruit.",
      "Grapes are not edible and lemons.",
      "Bananas are grass or fruit."
    ],
    "question": "Bananas are a lemon and meadow.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nFood(x) ::: x is food.\nGrass(x) ::: x is grass.\nMeadow(x) ::: x is a meadow.\nEdible(x) ::: x is edible.\nFruit(x) ::: x is a fruit.\nLemon(x) ::: x is a lemon.\nGrapes(x) ::: x is grapes.\nBananas(x) ::: x is bananas.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Grass(x) → ¬Food(x)) ::: No grass is food.\n∀x (Meadow(x) → Grass(x)) ::: All meadows are grass.\n∀x (Edible(x) → Food(x)) ::: All edible things are food.\n∀x (Fruit(x) → Edible(x)) ::: All fruits are edible.\n∀x (Lemon(x) → Fruit(x)) ::: All lemons are fruit.\n¬(Edible(grapes) ∧ Lemon(lemons)) ::: Grapes are not edible and lemons.\n(Bananas(bananas) ∨ Fruit(bananas)) ::: Bananas are grass or fruit.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nBananas(bananas) ∧ Lemon(lemons) ∧ Meadow(bananas) ::: Bananas are a lemon and meadow.\n\"\"\""
    ]
  },
  {
    "id": 1401,
    "context": [
      "No grass is food. ",
      "All meadows are grass.",
      "All edible things are food. ",
      "All fruits are edible.",
      "All lemons are fruit.",
      "Grapes are not edible and lemons.",
      "Bananas are grass or fruit."
    ],
    "question": "Bananas are not both a lemon and a meadow.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nFood(x) ::: x is food.\nGrass(x) ::: x is grass.\nMeadow(x) ::: x is a meadow.\nEdible(x) ::: x is edible.\nFruit(x) ::: x is a fruit.\nLemon(x) ::: x is a lemon.\nBanana(x) ::: x is a banana.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Grass(x) → ¬Food(x)) ::: No grass is food.\n∀x (Meadow(x) → Grass(x)) ::: All meadows are grass.\n∀x (Edible(x) → Food(x)) ::: All edible things are food.\n∀x (Fruit(x) → Edible(x)) ::: All fruits are edible.\n∀x (Lemon(x) → Fruit(x)) ::: All lemons are fruit.\n¬(Edible(grapes) ∧ Lemon(grapes)) ::: Grapes are not edible and lemons.\n(Banana(bananas) ∨ Fruit(bananas)) ::: Bananas are grass or fruit.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬(Lemon(bananas) ∧ Meadow(bananas)) ::: Bananas are not both a lemon and a meadow.\n\"\"\""
    ]
  },
  {
    "id": 60,
    "context": [
      "The Golden State Warriors are a team from San Francisco.",
      "The Golden State Warriors won the NBA finals.",
      "All teams attending the NBA finals have more than thirty years of history.",
      "Boston Celtics are a team that lost the NBA finals.",
      "If a team wins the NBA finals, then they will have more income.",
      "If a team wins or loses at the NBA finals, then they are attending the finals."
    ],
    "question": "The Boston Celtics is from San Francisco.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nTeam(x) ::: x is a team.\nFrom(x, y) ::: x is from y.\nWin(x) ::: x won the NBA finals.\nAttend(x) ::: x is attending the NBA finals.\nMoreThanThirtyYears(x) ::: x has more than thirty years of history.\nLose(x) ::: x lost the NBA finals.\nIncome(x) ::: x has more income.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nFrom(goldenStateWarriors, sanFrancisco) ::: The Golden State Warriors are a team from San Francisco.\nWin(goldenStateWarriors) ::: The Golden State Warriors won the NBA finals.\n∀x (Attend(x) → MoreThanThirtyYears(x)) ::: All teams attending the NBA finals have more than thirty years of history.\nLose(bostonCeltics) ::: Boston Celtics are a team that lost the NBA finals.\n∀x (Win(x) → Income(x)) ::: If a team wins the NBA finals, then they will have more income.\n∀x ((Win(x) ∨ Lose(x)) → Attend(x)) ::: If a team wins or loses at the NBA finals, then they are attending the finals.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nFrom(bostonCeltics, sanFrancisco) ::: The Boston Celtics is from San Francisco.\n\"\"\""
    ]
  },
  {
    "id": 61,
    "context": [
      "The Golden State Warriors are a team from San Francisco.",
      "The Golden State Warriors won the NBA finals.",
      "All teams attending the NBA finals have more than thirty years of history.",
      "Boston Celtics are a team that lost the NBA finals.",
      "If a team wins the NBA finals, then they will have more income.",
      "If a team wins or loses at the NBA finals, then they are attending the finals."
    ],
    "question": "The Boston Celtics has more than 30 years of experience.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nTeam(x) ::: x is a team.\nFrom(x, y) ::: x is from y.\nWin(x) ::: x won the NBA finals.\nAttend(x) ::: x is attending the NBA finals.\nLose(x) ::: x lost the NBA finals.\nHistory(x, y) ::: x has y years of history.\nIncome(x) ::: x has more income.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nTeam(goldenStateWarriors) ∧ From(goldenStateWarriors, sanFrancisco) ::: The Golden State Warriors are a team from San Francisco.\nWin(goldenStateWarriors) ::: The Golden State Warriors won the NBA finals.\n∀x (Attend(x) → History(x, moreThan30Years)) ::: All teams attending the NBA finals have more than thirty years of history.\nTeam(bostonCeltics) ∧ Lose(bostonCeltics) ::: Boston Celtics are a team that lost the NBA finals.\n∀x (Win(x) → Income(x)) ::: If a team wins the NBA finals, then they will have more income.\n∀x ((Win(x) ∨ Lose(x)) → Attend(x)) ::: If a team wins or loses at the NBA finals, then they are attending the finals.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nHistory(bostonCeltics, moreThan30Years) ::: The Boston Celtics has more than 30 years of experience.\n\"\"\""
    ]
  },
  {
    "id": 62,
    "context": [
      "The Golden State Warriors are a team from San Francisco.",
      "The Golden State Warriors won the NBA finals.",
      "All teams attending the NBA finals have more than thirty years of history.",
      "Boston Celtics are a team that lost the NBA finals.",
      "If a team wins the NBA finals, then they will have more income.",
      "If a team wins or loses at the NBA finals, then they are attending the finals."
    ],
    "question": "The Golden State Warriors will have more income for gate receipts.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nTeam(x) ::: x is a team.\nFrom(x, y) ::: x is from y.\nWin(x) ::: x won the NBA finals.\nAttend(x) ::: x is attending the NBA finals.\nLose(x) ::: x lost the NBA finals.\nHistory(x) ::: x has more than thirty years of history.\nIncome(x) ::: x has more income.\nGateReceipts(x) ::: x receives income from gate receipts.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nTeam(goldenStateWarriors) ∧ From(goldenStateWarriors, sanFrancisco) ::: The Golden State Warriors are a team from San Francisco.\nWin(goldenStateWarriors) ::: The Golden State Warriors won the NBA finals.\n∀x (Attend(x) → History(x)) ::: All teams attending the NBA finals have more than thirty years of history.\nTeam(bostonCeltics) ∧ Lose(bostonCeltics) ::: Boston Celtics are a team that lost the NBA finals.\n∀x (Win(x) → Income(x)) ::: If a team wins the NBA finals, then they will have more income.\n∀x ((Win(x) ∨ Lose(x)) → Attend(x)) ::: If a team wins or loses at the NBA finals, then they are attending the finals.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nIncome(goldenStateWarriors) ∧ GateReceipts(goldenStateWarriors) ::: The Golden State Warriors will have more income for gate receipts.\n\"\"\""
    ]
  },
  {
    "id": 624,
    "context": [
      "Maya will play violin if and only if she never injures her fingers.",
      "Volleyball players can injure their ankle, fingers, or shoulder.",
      "Maya is a volleyball player."
    ],
    "question": "Maya will not play violin.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nPlay(x, y) ::: x plays y.\nInjure(x, y) ::: x injures y.\nViolin(x) ::: x plays the violin.\nAnkle(x) ::: x injures their ankle.\nFingers(x) ::: x injures their fingers.\nShoulder(x) ::: x injures their shoulder.\nVolleyballPlayer(x) ::: x is a volleyball player.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nViolin(maya) ↔ ¬Injure(maya, fingers) ::: Maya will play violin if and only if she never injures her fingers.\n∀x (VolleyballPlayer(x) → (Injure(x, ankle) ∨ Injure(x, fingers) ∨ Injure(x, shoulder))) ::: Volleyball players can injure their ankle, fingers, or shoulder.\nVolleyballPlayer(maya) ::: Maya is a volleyball player.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬Play(maya, violin) ::: Maya will not play violin.\n\"\"\""
    ]
  },
  {
    "id": 1220,
    "context": [
      "All devices belonging to the company are connected to Google Home. ",
      "All devices with the company logo belong to the company. ",
      "A device is either with the company logo or belongs to employees. ",
      "All devices belonging to employees are available to connect to the company's wifi. ",
      "All devices connected to Google Home are controlled by managers. ",
      "All devices that connect to the company's wifi are easy to operate. ",
      "All devices that are easy to operate are produced after 2020. ",
      "IPod1 is produced before 2020. "
    ],
    "question": "IPod1 is controlled by managers.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nConnected(x) ::: x is connected to Google Home.\nBelongs(x, y) ::: x belongs to y.\nCompanyDevice(x) ::: x is a device belonging to the company.\nCompanyLogo(x) ::: x has the company logo.\nEmployeeDevice(x) ::: x is a device belonging to employees.\nWifi(x) ::: x is connected to the company's wifi.\nControlledBy(x, y) ::: x is controlled by y.\nManager(x) ::: x is a manager.\nEasyToOperate(x) ::: x is easy to operate.\nProduced(x, y) ::: x is produced in year y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (CompanyDevice(x) → Connected(x)) ::: All devices belonging to the company are connected to Google Home.\n∀x (CompanyLogo(x) → Belongs(x, company)) ::: All devices with the company logo belong to the company.\n∀x (CompanyLogo(x) ⊕ EmployeeDevice(x)) ::: A device is either with the company logo or belongs to employees.\n∀x (EmployeeDevice(x) → Wifi(x)) ::: All devices belonging to employees are available to connect to the company's wifi.\n∀x (Connected(x) → ControlledBy(x, manager)) ::: All devices connected to Google Home are controlled by managers.\n∀x (Wifi(x) → EasyToOperate(x)) ::: All devices that connect to the company's wifi are easy to operate.\n∀x (EasyToOperate(x) → Produced(x, after2020)) ::: All devices that are easy to operate are produced after 2020.\nProduced(iPod1, before2020) ::: IPod1 is produced before 2020.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nControlledBy(iPod1, manager) ::: IPod1 is controlled by managers.\n\"\"\""
    ]
  },
  {
    "id": 1221,
    "context": [
      "All devices belonging to the company are connected to Google Home. ",
      "All devices with the company logo belong to the company. ",
      "A device is either with the company logo or belongs to employees. ",
      "All devices belonging to employees are available to connect to the company's wifi. ",
      "All devices connected to Google Home are controlled by managers. ",
      "All devices that connect to the company's wifi are easy to operate. ",
      "All devices that are easy to operate are produced after 2020. ",
      "IPod1 is produced before 2020. "
    ],
    "question": "IPod1 is either produced after 2020 or controlled by managers.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nBelongsToCompany(x) ::: x belongs to the company.\nConnectedToGoogleHome(x) ::: x is connected to Google Home.\nHasCompanyLogo(x) ::: x has the company logo.\nBelongsToEmployees(x) ::: x belongs to employees.\nAvailableToConnectToWifi(x) ::: x is available to connect to the company's wifi.\nControlledByManagers(x) ::: x is controlled by managers.\nEasyToOperate(x) ::: x is easy to operate.\nProducedAfter2020(x) ::: x is produced after 2020.\nProducedBefore2020(x) ::: x is produced before 2020.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (BelongsToCompany(x) → ConnectedToGoogleHome(x)) ::: All devices belonging to the company are connected to Google Home.\n∀x (HasCompanyLogo(x) → BelongsToCompany(x)) ::: All devices with the company logo belong to the company.\n∀x (HasCompanyLogo(x) ⊕ BelongsToEmployees(x)) ::: A device is either with the company logo or belongs to employees.\n∀x (BelongsToEmployees(x) → AvailableToConnectToWifi(x)) ::: All devices belonging to employees are available to connect to the company's wifi.\n∀x (ConnectedToGoogleHome(x) → ControlledByManagers(x)) ::: All devices connected to Google Home are controlled by managers.\n∀x (AvailableToConnectToWifi(x) → EasyToOperate(x)) ::: All devices that connect to the company's wifi are easy to operate.\n∀x (EasyToOperate(x) → ProducedAfter2020(x)) ::: All devices that are easy to operate are produced after 2020.\nProducedBefore2020(iPod1) ::: IPod1 is produced before 2020.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nProducedAfter2020(iPod1) ⊕ ControlledByManagers(iPod1) ::: IPod1 is either produced after 2020 or controlled by managers.\n\"\"\""
    ]
  },
  {
    "id": 1222,
    "context": [
      "All devices belonging to the company are connected to Google Home. ",
      "All devices with the company logo belong to the company. ",
      "A device is either with the company logo or belongs to employees. ",
      "All devices belonging to employees are available to connect to the company's wifi. ",
      "All devices connected to Google Home are controlled by managers. ",
      "All devices that connect to the company's wifi are easy to operate. ",
      "All devices that are easy to operate are produced after 2020. ",
      "IPod1 is produced before 2020. "
    ],
    "question": "IPod1 is not with the company logo, and managers do not control it.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nBelongToCompany(x) ::: x belongs to the company.\nConnectedToGoogleHome(x) ::: x is connected to Google Home.\nCompanyLogo(x) ::: x has the company logo.\nBelongsToEmployees(x) ::: x belongs to employees.\nAvailableToConnectToWifi(x) ::: x is available to connect to the company's wifi.\nControlledByManagers(x) ::: x is controlled by managers.\nEasyToOperate(x) ::: x is easy to operate.\nProducedAfter2020(x) ::: x is produced after 2020.\nProducedBefore2020(x) ::: x is produced before 2020.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (BelongToCompany(x) → ConnectedToGoogleHome(x)) ::: All devices belonging to the company are connected to Google Home.\n∀x (CompanyLogo(x) → BelongToCompany(x)) ::: All devices with the company logo belong to the company.\n∀x (CompanyLogo(x) ⊕ BelongsToEmployees(x)) ::: A device is either with the company logo or belongs to employees.\n∀x (BelongsToEmployees(x) → AvailableToConnectToWifi(x)) ::: All devices belonging to employees are available to connect to the company's wifi.\n∀x (ConnectedToGoogleHome(x) → ControlledByManagers(x)) ::: All devices connected to Google Home are controlled by managers.\n∀x (AvailableToConnectToWifi(x) → EasyToOperate(x)) ::: All devices that connect to the company's wifi are easy to operate.\n∀x (EasyToOperate(x) → ProducedAfter2020(x)) ::: All devices that are easy to operate are produced after 2020.\nProducedBefore2020(iPod1) ::: IPod1 is produced before 2020.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬CompanyLogo(iPod1) ∧ ¬ControlledByManagers(iPod1) ::: IPod1 is not with the company logo, and managers do not control it.\n\"\"\""
    ]
  },
  {
    "id": 1223,
    "context": [
      "All devices belonging to the company are connected to Google Home. ",
      "All devices with the company logo belong to the company. ",
      "A device is either with the company logo or belongs to employees. ",
      "All devices belonging to employees are available to connect to the company's wifi. ",
      "All devices connected to Google Home are controlled by managers. ",
      "All devices that connect to the company's wifi are easy to operate. ",
      "All devices that are easy to operate are produced after 2020. ",
      "IPod1 is produced before 2020. "
    ],
    "question": "IPod1 is either with the company logo or controlled by managers.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nBelongToCompany(x) ::: x belongs to the company.\nConnectedToGoogleHome(x) ::: x is connected to Google Home.\nHasCompanyLogo(x) ::: x has the company logo.\nBelongToEmployees(x) ::: x belongs to employees.\nAvailableToConnectToWifi(x) ::: x is available to connect to the company's wifi.\nControlledByManagers(x) ::: x is controlled by managers.\nEasyToOperate(x) ::: x is easy to operate.\nProducedAfter2020(x) ::: x is produced after 2020.\nProducedBefore2020(x) ::: x is produced before 2020.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (BelongToCompany(x) → ConnectedToGoogleHome(x)) ::: All devices belonging to the company are connected to Google Home.\n∀x (HasCompanyLogo(x) → BelongToCompany(x)) ::: All devices with the company logo belong to the company.\n∀x (HasCompanyLogo(x) ⊕ BelongToEmployees(x)) ::: A device is either with the company logo or belongs to employees.\n∀x (BelongToEmployees(x) → AvailableToConnectToWifi(x)) ::: All devices belonging to employees are available to connect to the company's wifi.\n∀x (ConnectedToGoogleHome(x) → ControlledByManagers(x)) ::: All devices connected to Google Home are controlled by managers.\n∀x (AvailableToConnectToWifi(x) → EasyToOperate(x)) ::: All devices that connect to the company's wifi are easy to operate.\n∀x (EasyToOperate(x) → ProducedAfter2020(x)) ::: All devices that are easy to operate are produced after 2020.\nProducedBefore2020(iPod1) ::: IPod1 is produced before 2020.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nHasCompanyLogo(iPod1) ⊕ ControlledByManagers(iPod1) ::: IPod1 is either with the company logo or controlled by managers.\n\"\"\""
    ]
  },
  {
    "id": 715,
    "context": [
      "All CD players are delicate mechanisms.",
      "No delicate mechanisms are suitable toys for children."
    ],
    "question": "Some CD players are suitable toys for children.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nCDPlayer(x) ::: x is a CD player.\nDelicate(x) ::: x is a delicate mechanism.\nToy(x) ::: x is a toy for children.\nSuitable(x, y) ::: x is suitable for y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (CDPlayer(x) → Delicate(x)) ::: All CD players are delicate mechanisms.\n∀x (Delicate(x) → ¬Toy(x)) ::: No delicate mechanisms are suitable toys for children.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n∃x (CDPlayer(x) ∧ Toy(x) ∧ Suitable(x, children)) ::: Some CD players are suitable toys for children.\n\"\"\""
    ]
  },
  {
    "id": 921,
    "context": [
      "All mammals are living beings.",
      "All elephants are mammals.",
      "All baby elephants are elephants.",
      "Some baby elephants are sleepy.",
      "If Jumbo is a living being, then Jumbo is not an elephant or a mammal.",
      "If Jumbo is sleepy, then Jumbo is a baby elephant or an elephant."
    ],
    "question": "Jumbo is sleepy.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nMammal(x) ::: x is a mammal.\nLivingBeing(x) ::: x is a living being.\nElephant(x) ::: x is an elephant.\nBabyElephant(x) ::: x is a baby elephant.\nSleepy(x) ::: x is sleepy.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Mammal(x) → LivingBeing(x)) ::: All mammals are living beings.\n∀x (Elephant(x) → Mammal(x)) ::: All elephants are mammals.\n∀x (BabyElephant(x) → Elephant(x)) ::: All baby elephants are elephants.\n∃x (BabyElephant(x) ∧ Sleepy(x)) ::: Some baby elephants are sleepy.\nLivingBeing(jumbo) → ¬(Elephant(jumbo) ∨ Mammal(jumbo)) ::: If Jumbo is a living being, then Jumbo is not an elephant or a mammal.\nSleepy(jumbo) → (BabyElephant(jumbo) ∨ Elephant(jumbo)) ::: If Jumbo is sleepy, then Jumbo is a baby elephant or an elephant.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nSleepy(jumbo) ::: Jumbo is sleepy.\n\"\"\""
    ]
  },
  {
    "id": 922,
    "context": [
      "All mammals are living beings.",
      "All elephants are mammals.",
      "All baby elephants are elephants.",
      "Some baby elephants are sleepy.",
      "If Jumbo is a living being, then Jumbo is not an elephant or a mammal.",
      "If Jumbo is sleepy, then Jumbo is a baby elephant or an elephant."
    ],
    "question": "Jumbo is not sleepy.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nMammal(x) ::: x is a mammal.\nLivingBeing(x) ::: x is a living being.\nElephant(x) ::: x is an elephant.\nBabyElephant(x) ::: x is a baby elephant.\nSleepy(x) ::: x is sleepy.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Mammal(x) → LivingBeing(x)) ::: All mammals are living beings.\n∀x (Elephant(x) → Mammal(x)) ::: All elephants are mammals.\n∀x (BabyElephant(x) → Elephant(x)) ::: All baby elephants are elephants.\n∃x (BabyElephant(x) ∧ Sleepy(x)) ::: Some baby elephants are sleepy.\nLivingBeing(jumbo) → (¬Elephant(jumbo) ∨ ¬Mammal(jumbo)) ::: If Jumbo is a living being, then Jumbo is not an elephant or a mammal.\nSleepy(jumbo) → (BabyElephant(jumbo) ∨ Elephant(jumbo)) ::: If Jumbo is sleepy, then Jumbo is a baby elephant or an elephant.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬Sleepy(jumbo) ::: Jumbo is not sleepy.\n\"\"\""
    ]
  },
  {
    "id": 923,
    "context": [
      "All mammals are living beings.",
      "All elephants are mammals.",
      "All baby elephants are elephants.",
      "Some baby elephants are sleepy.",
      "If Jumbo is a living being, then Jumbo is not an elephant or a mammal.",
      "If Jumbo is sleepy, then Jumbo is a baby elephant or an elephant."
    ],
    "question": "Jumbo is a living being.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nMammal(x) ::: x is a mammal.\nLivingBeing(x) ::: x is a living being.\nElephant(x) ::: x is an elephant.\nBabyElephant(x) ::: x is a baby elephant.\nSleepy(x) ::: x is sleepy.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Mammal(x) → LivingBeing(x)) ::: All mammals are living beings.\n∀x (Elephant(x) → Mammal(x)) ::: All elephants are mammals.\n∀x (BabyElephant(x) → Elephant(x)) ::: All baby elephants are elephants.\n∃x (BabyElephant(x) ∧ Sleepy(x)) ::: Some baby elephants are sleepy.\nLivingBeing(jumbo) → ¬(Elephant(jumbo) ∨ Mammal(jumbo)) ::: If Jumbo is a living being, then Jumbo is not an elephant or a mammal.\nSleepy(jumbo) → (BabyElephant(jumbo) ∨ Elephant(jumbo)) ::: If Jumbo is sleepy, then Jumbo is a baby elephant or an elephant.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nLivingBeing(jumbo) ::: Jumbo is a living being.\n\"\"\""
    ]
  },
  {
    "id": 924,
    "context": [
      "All mammals are living beings.",
      "All elephants are mammals.",
      "All baby elephants are elephants.",
      "Some baby elephants are sleepy.",
      "If Jumbo is a living being, then Jumbo is not an elephant or a mammal.",
      "If Jumbo is sleepy, then Jumbo is a baby elephant or an elephant."
    ],
    "question": "Jumbo is neither sleepy nor a baby elephant.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nMammal(x) ::: x is a mammal.\nLivingBeing(x) ::: x is a living being.\nElephant(x) ::: x is an elephant.\nBabyElephant(x) ::: x is a baby elephant.\nSleepy(x) ::: x is sleepy.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Mammal(x) → LivingBeing(x)) ::: All mammals are living beings.\n∀x (Elephant(x) → Mammal(x)) ::: All elephants are mammals.\n∀x (BabyElephant(x) → Elephant(x)) ::: All baby elephants are elephants.\n∃x (BabyElephant(x) ∧ Sleepy(x)) ::: Some baby elephants are sleepy.\nLivingBeing(jumbo) → ¬(Elephant(jumbo) ∨ Mammal(jumbo)) ::: If Jumbo is a living being, then Jumbo is not an elephant or a mammal.\nSleepy(jumbo) → (BabyElephant(jumbo) ∨ Elephant(jumbo)) ::: If Jumbo is sleepy, then Jumbo is a baby elephant or an elephant.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬(Sleepy(jumbo) ∨ BabyElephant(jumbo)) ::: Jumbo is neither sleepy nor a baby elephant.\n\"\"\""
    ]
  },
  {
    "id": 925,
    "context": [
      "All mammals are living beings.",
      "All elephants are mammals.",
      "All baby elephants are elephants.",
      "Some baby elephants are sleepy.",
      "If Jumbo is a living being, then Jumbo is not an elephant or a mammal.",
      "If Jumbo is sleepy, then Jumbo is a baby elephant or an elephant."
    ],
    "question": "Jumbo is not sleepy or an elephant.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nMammal(x) ::: x is a mammal.\nLivingBeing(x) ::: x is a living being.\nElephant(x) ::: x is an elephant.\nBabyElephant(x) ::: x is a baby elephant.\nSleepy(x) ::: x is sleepy.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Mammal(x) → LivingBeing(x)) ::: All mammals are living beings.\n∀x (Elephant(x) → Mammal(x)) ::: All elephants are mammals.\n∀x (BabyElephant(x) → Elephant(x)) ::: All baby elephants are elephants.\n∃x (BabyElephant(x) ∧ Sleepy(x)) ::: Some baby elephants are sleepy.\nLivingBeing(jumbo) → ¬(Elephant(jumbo) ∨ Mammal(jumbo)) ::: If Jumbo is a living being, then Jumbo is not an elephant or a mammal.\nSleepy(jumbo) → (BabyElephant(jumbo) ∨ Elephant(jumbo)) ::: If Jumbo is sleepy, then Jumbo is a baby elephant or an elephant.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬Sleepy(jumbo) ∨ ¬Elephant(jumbo) ::: Jumbo is not sleepy or an elephant.\n\"\"\""
    ]
  },
  {
    "id": 1291,
    "context": [
      "No faculty does homework.",
      "All students do homework.",
      "All kids are students.",
      "If someone works at a school, then they are faculty.",
      "If Jill works at a school or is a teacher, then Jill works at a school."
    ],
    "question": "Jill works at a school.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nFaculty(x) ::: x is a faculty member.\nHomework(x) ::: x does homework.\nStudent(x) ::: x is a student.\nKid(x) ::: x is a kid.\nWorksAtSchool(x) ::: x works at a school.\nTeacher(x) ::: x is a teacher.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Faculty(x) → ¬Homework(x)) ::: No faculty does homework.\n∀x (Student(x) → Homework(x)) ::: All students do homework.\n∀x (Kid(x) → Student(x)) ::: All kids are students.\n∀x (WorksAtSchool(x) → Faculty(x)) ::: If someone works at a school, then they are faculty.\n(WorksAtSchool(jill) ∨ Teacher(jill)) → WorksAtSchool(jill) ::: If Jill works at a school or is a teacher, then Jill works at a school.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nWorksAtSchool(jill) ::: Jill works at a school.\n\"\"\""
    ]
  },
  {
    "id": 1292,
    "context": [
      "No faculty does homework.",
      "All students do homework.",
      "All kids are students.",
      "If someone works at a school, then they are faculty.",
      "If Jill works at a school or is a teacher, then Jill works at a school."
    ],
    "question": "Jill is a kid.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nFaculty(x) ::: x is a faculty member.\nHomework(x) ::: x does homework.\nStudent(x) ::: x is a student.\nKid(x) ::: x is a kid.\nWorksAtSchool(x) ::: x works at a school.\nTeacher(x) ::: x is a teacher.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Faculty(x) → ¬Homework(x)) ::: No faculty does homework.\n∀x (Student(x) → Homework(x)) ::: All students do homework.\n∀x (Kid(x) → Student(x)) ::: All kids are students.\n∀x (WorksAtSchool(x) → Faculty(x)) ::: If someone works at a school, then they are faculty.\n(WorksAtSchool(jill) ∨ Teacher(jill)) → WorksAtSchool(jill) ::: If Jill works at a school or is a teacher, then Jill works at a school.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nKid(jill) ::: Jill is a kid.\n\"\"\""
    ]
  },
  {
    "id": 1293,
    "context": [
      "No faculty does homework.",
      "All students do homework.",
      "All kids are students.",
      "If someone works at a school, then they are faculty.",
      "If Jill works at a school or is a teacher, then Jill works at a school."
    ],
    "question": "Jill is not a kid.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nFaculty(x) ::: x is a faculty member.\nHomework(x) ::: x does homework.\nStudent(x) ::: x is a student.\nKid(x) ::: x is a kid.\nWorksAtSchool(x) ::: x works at a school.\nTeacher(x) ::: x is a teacher.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Faculty(x) → ¬Homework(x)) ::: No faculty does homework.\n∀x (Student(x) → Homework(x)) ::: All students do homework.\n∀x (Kid(x) → Student(x)) ::: All kids are students.\n∀x (WorksAtSchool(x) → Faculty(x)) ::: If someone works at a school, then they are faculty.\n(WorksAtSchool(jill) ∨ Teacher(jill)) → WorksAtSchool(jill) ::: If Jill works at a school or is a teacher, then Jill works at a school.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬Kid(jill) ::: Jill is not a kid.\n\"\"\""
    ]
  },
  {
    "id": 941,
    "context": [
      "Either Max listens to classical music or Max listens to rap. ",
      "All the songs that Max listens to that are classical music are from the 12th century.",
      "If the song Max listens to is rap, then the song is from Kanye West. ",
      "If a songs is from Kanye West, then the song is full of lyrics. ",
      "All songs that are full of lyrics need to be written with words",
      "If “As it was” by Harry Styles is classical music that Max listens to or  from the 12th century, then “As it was” by Harry Styles is either classical music that Max listens to, or the songs are from 12th century."
    ],
    "question": "“As it was” by Harry Styles needs to be written with words.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nListensTo(x, y) ::: x listens to y.\nClassicalMusic(x) ::: x is classical music.\nRap(x) ::: x is rap.\nFrom12thCentury(x) ::: x is from the 12th century.\nFromKanyeWest(x) ::: x is from Kanye West.\nFullOfLyrics(x) ::: x is full of lyrics.\nWrittenWithWords(x) ::: x needs to be written with words.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n(ListensTo(max, classicalMusic) ∨ ListensTo(max, rap)) ::: Either Max listens to classical music or Max listens to rap.\n∀x ((ListensTo(max, x) ∧ ClassicalMusic(x)) → From12thCentury(x)) ::: All the songs that Max listens to that are classical music are from the 12th century.\n(ListensTo(max, rap) → FromKanyeWest(song)) ::: If the song Max listens to is rap, then the song is from Kanye West.\n(FromKanyeWest(song) → FullOfLyrics(song)) ::: If a song is from Kanye West, then the song is full of lyrics.\n∀x (FullOfLyrics(x) → WrittenWithWords(x)) ::: All songs that are full of lyrics need to be written with words.\n(ClassicalMusic(asItWas) ∧ ListensTo(max, asItWas)) ∨ From12thCentury(asItWas) → (ClassicalMusic(asItWas) ∧ ListensTo(max, asItWas)) ∨ From12thCentury(asItWas) ::: If “As it was” by Harry Styles is classical music that Max listens to or from the 12th century, then “As it was” by Harry Styles is either classical music that Max listens to, or the songs are from 12th century.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nWrittenWithWords(asItWas) ::: “As it was” by Harry Styles needs to be written with words.\n\"\"\""
    ]
  },
  {
    "id": 942,
    "context": [
      "Either Max listens to classical music or Max listens to rap. ",
      "All the songs that Max listens to that are classical music are from the 12th century.",
      "If the song Max listens to is rap, then the song is from Kanye West. ",
      "If a songs is from Kanye West, then the song is full of lyrics. ",
      "All songs that are full of lyrics need to be written with words",
      "If “As it was” by Harry Styles is classical music that Max listens to or  from the 12th century, then “As it was” by Harry Styles is either classical music that Max listens to, or the songs are from 12th century."
    ],
    "question": "\"As it was” by Harry Styles is a song from the 12th century.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nListens(x, y) ::: x listens to y.\nClassicalMusic(x) ::: x is classical music.\nRap(x) ::: x is rap.\nFrom12thCentury(x) ::: x is from the 12th century.\nByKanyeWest(x) ::: x is from Kanye West.\nFullOfLyrics(x) ::: x is full of lyrics.\nWrittenWithWords(x) ::: x is written with words.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n(Listens(max, classicalMusic) ∨ Listens(max, rap)) ::: Either Max listens to classical music or Max listens to rap.\n∀x ((Listens(max, x) ∧ ClassicalMusic(x)) → From12thCentury(x)) ::: All the songs that Max listens to that are classical music are from the 12th century.\n(Listens(max, rap) → ByKanyeWest(song)) ::: If the song Max listens to is rap, then the song is from Kanye West.\n(ByKanyeWest(song) → FullOfLyrics(song)) ::: If a song is from Kanye West, then the song is full of lyrics.\n∀x (FullOfLyrics(x) → WrittenWithWords(x)) ::: All songs that are full of lyrics need to be written with words.\n(ClassicalMusic(asItWas) ∧ Listens(max, asItWas)) ∨ From12thCentury(asItWas) → (ClassicalMusic(asItWas) ∧ Listens(max, asItWas)) ∨ From12thCentury(asItWas) ::: If “As it was” by Harry Styles is classical music that Max listens to or from the 12th century, then “As it was” by Harry Styles is either classical music that Max listens to, or the songs are from 12th century.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nFrom12thCentury(asItWas) ::: “As it was” by Harry Styles is a song from the 12th century.\n\"\"\""
    ]
  },
  {
    "id": 943,
    "context": [
      "Either Max listens to classical music or Max listens to rap. ",
      "All the songs that Max listens to that are classical music are from the 12th century.",
      "If the song Max listens to is rap, then the song is from Kanye West. ",
      "If a songs is from Kanye West, then the song is full of lyrics. ",
      "All songs that are full of lyrics need to be written with words",
      "If “As it was” by Harry Styles is classical music that Max listens to or  from the 12th century, then “As it was” by Harry Styles is either classical music that Max listens to, or the songs are from 12th century."
    ],
    "question": "\"As it was” by Harry Styles is not a song from Kanye West and needs to be written with words.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nListensTo(x, y) ::: x listens to y.\nClassicalMusic(x) ::: x is classical music.\nRap(x) ::: x is rap.\nFrom12thCentury(x) ::: x is from the 12th century.\nFromKanyeWest(x) ::: x is from Kanye West.\nFullOfLyrics(x) ::: x is full of lyrics.\nWrittenWithWords(x) ::: x needs to be written with words.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n(ListensTo(max, classicalMusic) ∨ ListensTo(max, rap)) ::: Either Max listens to classical music or Max listens to rap.\n∀x ((ListensTo(max, x) ∧ ClassicalMusic(x)) → From12thCentury(x)) ::: All the songs that Max listens to that are classical music are from the 12th century.\n(ListensTo(max, rap) → FromKanyeWest(song)) ::: If the song Max listens to is rap, then the song is from Kanye West.\n(FromKanyeWest(song) → FullOfLyrics(song)) ::: If a song is from Kanye West, then the song is full of lyrics.\n∀x (FullOfLyrics(x) → WrittenWithWords(x)) ::: All songs that are full of lyrics need to be written with words.\n(ClassicalMusic(\"As it was\") ∧ ListensTo(max, \"As it was\")) ∨ From12thCentury(\"As it was\") → (ClassicalMusic(\"As it was\") ∧ ListensTo(max, \"As it was\")) ∨ From12thCentury(\"As it was\") ::: If “As it was” by Harry Styles is classical music that Max listens to or from the 12th century, then “As it was” by Harry Styles is either classical music that Max listens to, or the songs are from 12th century.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬(FromKanyeWest(\"As it was\") ∧ WrittenWithWords(\"As it was\")) ::: \"As it was” by Harry Styles is not a song from Kanye West and needs to be written with words.\n\"\"\""
    ]
  },
  {
    "id": 114,
    "context": [
      "\"Your Woman\" is a song by British one-man band White Town.",
      "\"Your Woman\" song peaked at No. 1 on the UK Singles Chart.",
      "If a song peaked at No.1 at a cetain place, then it was extremely popular.",
      "\"Your Woman\" also peaked No. 1 in Iceland, Israel and Spain."
    ],
    "question": "\"Your Woman\" was extremely popular.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nSong(x) ::: x is a song.\nBritish(x) ::: x is British.\nPeakedAtNo1(x, y) ::: x peaked at No. 1 on the chart y.\nExtremelyPopular(x) ::: x is extremely popular.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nSong(yourWoman) ∧ British(yourWoman) ∧ PeakedAtNo1(yourWoman, UKSinglesChart) ::: \"Your Woman\" is a song by British one-man band White Town and peaked at No. 1 on the UK Singles Chart.\n∀x ∀y (PeakedAtNo1(x, y) → ExtremelyPopular(x)) ::: If a song peaked at No.1 at a certain place, then it was extremely popular.\nPeakedAtNo1(yourWoman, Iceland) ∧ PeakedAtNo1(yourWoman, Israel) ∧ PeakedAtNo1(yourWoman, Spain) ::: \"Your Woman\" also peaked No. 1 in Iceland, Israel, and Spain.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nExtremelyPopular(yourWoman) ::: \"Your Woman\" was extremely popular.\n\"\"\""
    ]
  },
  {
    "id": 115,
    "context": [
      "\"Your Woman\" is a song by British one-man band White Town.",
      "\"Your Woman\" song peaked at No. 1 on the UK Singles Chart.",
      "If a song peaked at No.1 at a cetain place, then it was extremely popular.",
      "\"Your Woman\" also peaked No. 1 in Iceland, Israel and Spain."
    ],
    "question": "White Town did not produce any popular song.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nSong(x) ::: x is a song.\nBand(x) ::: x is a band.\nPeakedAt(x, y) ::: x peaked at No. 1 at place y.\nExtremelyPopular(x) ::: x is extremely popular.\nProducedBy(x, y) ::: x is produced by y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nSong(yourWoman) ∧ Band(whiteTown) ∧ ProducedBy(yourWoman, whiteTown) ::: \"Your Woman\" is a song by British one-man band White Town.\nPeakedAt(yourWoman, UK) ::: \"Your Woman\" song peaked at No. 1 on the UK Singles Chart.\n∀x ∀y (PeakedAt(x, y) → ExtremelyPopular(x)) ::: If a song peaked at No.1 at a certain place, then it was extremely popular.\nPeakedAt(yourWoman, Iceland) ∧ PeakedAt(yourWoman, Israel) ∧ PeakedAt(yourWoman, Spain) ::: \"Your Woman\" also peaked No. 1 in Iceland, Israel and Spain.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬∃x (Song(x) ∧ ExtremelyPopular(x) ∧ ProducedBy(x, whiteTown)) ::: White Town did not produce any popular song.\n\"\"\""
    ]
  },
  {
    "id": 116,
    "context": [
      "\"Your Woman\" is a song by British one-man band White Town.",
      "\"Your Woman\" song peaked at No. 1 on the UK Singles Chart.",
      "If a song peaked at No.1 at a cetain place, then it was extremely popular.",
      "\"Your Woman\" also peaked No. 1 in Iceland, Israel and Spain."
    ],
    "question": "White Town was a successful band.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nSong(x) ::: x is a song.\nBand(x) ::: x is a band.\nPeakedAt(x, y) ::: x peaked at No. 1 at place y.\nExtremelyPopular(x) ::: x was extremely popular.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nSong(yourWoman) ∧ Band(whiteTown) ::: \"Your Woman\" is a song by British one-man band White Town.\nPeakedAt(yourWoman, UK) ::: \"Your Woman\" song peaked at No. 1 on the UK Singles Chart.\n∀x ∀y (PeakedAt(x, y) → ExtremelyPopular(x)) ::: If a song peaked at No.1 at a certain place, then it was extremely popular.\nPeakedAt(yourWoman, Iceland) ∧ PeakedAt(yourWoman, Israel) ∧ PeakedAt(yourWoman, Spain) ::: \"Your Woman\" also peaked No. 1 in Iceland, Israel and Spain.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n∃x (Band(x) ∧ x = whiteTown) ::: White Town was a successful band.\n\"\"\""
    ]
  },
  {
    "id": 1001,
    "context": [
      "All people who limp often and regularly have long-term medical issues with underlying causes.",
      "If people have long-term medical issues with underlying causes, then they are not often spry and energetic.",
      "People either stay indoors and rest a lot at home or people are often tired and disinterested in their activities.",
      "If people stay indoors and rest a lot at home, then they do not visit the gym at least once a day.",
      "If Mark either limps often and regularly or is often spry and energetic, then Mark limps often and regularly or is often tired and disinterested in his activities."
    ],
    "question": "Mark limps often and regularly.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nLimp(x) ::: x limps often and regularly.\nMedicalIssues(x) ::: x has long-term medical issues with underlying causes.\nSpry(x) ::: x is often spry and energetic.\nStayIndoors(x) ::: x stays indoors and rests a lot at home.\nTired(x) ::: x is often tired and disinterested in their activities.\nVisitGym(x) ::: x visits the gym at least once a day.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Limp(x) ∧ Often(x) → MedicalIssues(x)) ::: All people who limp often and regularly have long-term medical issues with underlying causes.\n∀x (MedicalIssues(x) → ¬Spry(x)) ::: If people have long-term medical issues with underlying causes, then they are not often spry and energetic.\n∀x (StayIndoors(x) ∨ Tired(x)) ::: People either stay indoors and rest a lot at home or people are often tired and disinterested in their activities.\n∀x (StayIndoors(x) → ¬VisitGym(x)) ::: If people stay indoors and rest a lot at home, then they do not visit the gym at least once a day.\n(Limp(mark) ∧ Often(mark)) ∨ Spry(mark) → (Limp(mark) ∨ Tired(mark)) ::: If Mark either limps often and regularly or is often spry and energetic, then Mark limps often and regularly or is often tired and disinterested in his activities.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nLimp(mark) ∧ Often(mark) ::: Mark limps often and regularly.\n\"\"\""
    ]
  },
  {
    "id": 1002,
    "context": [
      "All people who limp often and regularly have long-term medical issues with underlying causes.",
      "If people have long-term medical issues with underlying causes, then they are not often spry and energetic.",
      "People either stay indoors and rest a lot at home or people are often tired and disinterested in their activities.",
      "If people stay indoors and rest a lot at home, then they do not visit the gym at least once a day.",
      "If Mark either limps often and regularly or is often spry and energetic, then Mark limps often and regularly or is often tired and disinterested in his activities."
    ],
    "question": "Mark visits the gym at least once a day.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nLimp(x) ::: x limps often and regularly.\nMedicalIssues(x) ::: x has long-term medical issues with underlying causes.\nSpry(x) ::: x is often spry and energetic.\nStayIndoors(x) ::: x stays indoors and rests a lot at home.\nTired(x) ::: x is often tired and disinterested in their activities.\nVisitGym(x) ::: x visits the gym at least once a day.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Limp(x) ∧ Often(x) → MedicalIssues(x)) ::: All people who limp often and regularly have long-term medical issues with underlying causes.\n∀x (MedicalIssues(x) → ¬Spry(x)) ::: If people have long-term medical issues with underlying causes, then they are not often spry and energetic.\n∀x (StayIndoors(x) ∨ Tired(x)) ::: People either stay indoors and rest a lot at home or people are often tired and disinterested in their activities.\n∀x (StayIndoors(x) → ¬VisitGym(x)) ::: If people stay indoors and rest a lot at home, then they do not visit the gym at least once a day.\n(Limp(mark) ∧ Often(mark)) ∨ Spry(mark) → (Limp(mark) ∨ Tired(mark)) ::: If Mark either limps often and regularly or is often spry and energetic, then Mark limps often and regularly or is often tired and disinterested in his activities.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nVisitGym(mark) ::: Mark visits the gym at least once a day.\n\"\"\""
    ]
  },
  {
    "id": 1003,
    "context": [
      "All people who limp often and regularly have long-term medical issues with underlying causes.",
      "If people have long-term medical issues with underlying causes, then they are not often spry and energetic.",
      "People either stay indoors and rest a lot at home or people are often tired and disinterested in their activities.",
      "If people stay indoors and rest a lot at home, then they do not visit the gym at least once a day.",
      "If Mark either limps often and regularly or is often spry and energetic, then Mark limps often and regularly or is often tired and disinterested in his activities."
    ],
    "question": "Mark stays indoors and rests regularly at his home or visits the gym at least once a day.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nLimp(x) ::: x limps often and regularly.\nMedicalIssues(x) ::: x has long-term medical issues with underlying causes.\nSpry(x) ::: x is often spry and energetic.\nStayIndoors(x) ::: x stays indoors and rests a lot at home.\nTired(x) ::: x is often tired and disinterested in their activities.\nVisitGym(x) ::: x visits the gym at least once a day.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Limp(x) ∧ Often(x) → MedicalIssues(x)) ::: All people who limp often and regularly have long-term medical issues with underlying causes.\n∀x (MedicalIssues(x) → ¬Spry(x)) ::: If people have long-term medical issues with underlying causes, then they are not often spry and energetic.\n∀x (StayIndoors(x) ∨ Tired(x)) ::: People either stay indoors and rest a lot at home or people are often tired and disinterested in their activities.\n∀x (StayIndoors(x) → ¬VisitGym(x)) ::: If people stay indoors and rest a lot at home, then they do not visit the gym at least once a day.\n(Limp(mark) ∧ Often(mark)) ∨ Spry(mark) → (Limp(mark) ∨ Tired(mark)) ::: If Mark either limps often and regularly or is often spry and energetic, then Mark limps often and regularly or is often tired and disinterested in his activities.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nStayIndoors(mark) ∨ VisitGym(mark) ::: Mark stays indoors and rests regularly at his home or visits the gym at least once a day.\n\"\"\""
    ]
  },
  {
    "id": 543,
    "context": [
      "If two soccer teams score the same number of goals in one UCL final during the regular time, they need to play for the extra time.",
      "If two soccer teams score the same number of goals in one UCL final during both the regular time and extra time, they need to play the penalty shoot-out.",
      "Real Madrid and Atlético Madrid both scored one goal in 2016 UCL final during the regular time.",
      "Real Madrid and Atlético Madrid both scored zero goals in 2016 UCL final during the extra time."
    ],
    "question": "Real Madrid and Atlético Madrid needed to play a penalty shoot-out in 2016 UCL final.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nScores(x, y, z) ::: Team x scores y goals in UCL final z.\nPlayExtraTime(x) ::: Team x needs to play for the extra time.\nPlayPenaltyShootout(x) ::: Team x needs to play the penalty shoot-out.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n(Scores(team1, goals, final) = Scores(team2, goals, final)) → PlayExtraTime(team1) ∧ PlayExtraTime(team2) ::: If two soccer teams score the same number of goals in one UCL final during the regular time, they need to play for the extra time.\n(Scores(team1, goals, regularTime) = Scores(team1, goals, extraTime)) → PlayPenaltyShootout(team1) ::: If two soccer teams score the same number of goals in one UCL final during both the regular time and extra time, they need to play the penalty shoot-out.\nScores(realMadrid, one, 2016) ∧ Scores(atleticoMadrid, one, 2016) ::: Real Madrid and Atlético Madrid both scored one goal in 2016 UCL final during the regular time.\nScores(realMadrid, zero, 2016) ∧ Scores(atleticoMadrid, zero, 2016) ::: Real Madrid and Atlético Madrid both scored zero goals in 2016 UCL final during the extra time.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nPlayPenaltyShootout(realMadrid) ∧ PlayPenaltyShootout(atleticoMadrid) ::: Real Madrid and Atlético Madrid needed to play a penalty shoot-out in 2016 UCL final.\n\"\"\""
    ]
  },
  {
    "id": 544,
    "context": [
      "If two soccer teams score the same number of goals in one UCL final during the regular time, they need to play for the extra time.",
      "If two soccer teams score the same number of goals in one UCL final during both the regular time and extra time, they need to play the penalty shoot-out.",
      "Real Madrid and Atlético Madrid both scored one goal in 2016 UCL final during the regular time.",
      "Real Madrid and Atlético Madrid both scored zero goals in 2016 UCL final during the extra time."
    ],
    "question": "Real Madrid and Atlético Madrid did not need to play a penalty shoot-out in 2016 UCL final.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nScored(x, y, z) ::: Team x scored y goals in z UCL final.\nPlayExtraTime(x) ::: Team x needs to play for the extra time.\nPlayPenaltyShootout(x) ::: Team x needs to play the penalty shoot-out.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n(Scored(realMadrid, 1, 2016) ∧ Scored(atleticoMadrid, 1, 2016)) → PlayExtraTime(realMadrid) ::: If Real Madrid and Atlético Madrid both scored one goal in 2016 UCL final during the regular time, they need to play for the extra time.\n(Scored(realMadrid, 0, 2016) ∧ Scored(atleticoMadrid, 0, 2016) ∧ PlayExtraTime(realMadrid)) → PlayPenaltyShootout(realMadrid) ::: If Real Madrid and Atlético Madrid both scored zero goals in 2016 UCL final during the extra time, they need to play the penalty shoot-out.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬PlayPenaltyShootout(realMadrid) ::: Real Madrid and Atlético Madrid did not need to play a penalty shoot-out in 2016 UCL final.\n\"\"\""
    ]
  },
  {
    "id": 35,
    "context": [
      "System 7 is a UK-based electronic dance music band.",
      "Steve Hillage and Miquette Giraudy formed System 7.",
      "Steve Hillage and Miquette Giraudy are former members of the band Gong.",
      "Electric dance music bands are bands.",
      "System 7 has released several club singles.",
      "Club singles are not singles."
    ],
    "question": "System 7 was formed by former members of Gong.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nBand(x) ::: x is a band.\nFormed(x, y) ::: x is formed by y.\nFormerMember(x, y) ::: x is a former member of y.\nRelease(x, y) ::: x releases y.\nSingle(x) ::: x is a single.\nClubSingle(x) ::: x is a club single.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nBand(system7) ∧ UKBased(system7) ∧ ElectronicDanceMusic(system7) ::: System 7 is a UK-based electronic dance music band.\nFormed(system7, steveHillage) ∧ Formed(system7, miquetteGiraudy) ::: Steve Hillage and Miquette Giraudy formed System 7.\nFormerMember(steveHillage, gong) ∧ FormerMember(miquetteGiraudy, gong) ::: Steve Hillage and Miquette Giraudy are former members of the band Gong.\n∀x (ElectricDanceMusicBand(x) → Band(x)) ::: Electric dance music bands are bands.\nRelease(system7, clubSingles) ∧ Several(clubSingles) ::: System 7 has released several club singles.\n∀x (ClubSingle(x) → ¬Single(x)) ::: Club singles are not singles.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n∃x (FormerMember(x, gong) ∧ Formed(system7, x)) ::: System 7 was formed by former members of Gong.\n\"\"\""
    ]
  },
  {
    "id": 36,
    "context": [
      "System 7 is a UK-based electronic dance music band.",
      "Steve Hillage and Miquette Giraudy formed System 7.",
      "Steve Hillage and Miquette Giraudy are former members of the band Gong.",
      "Electric dance music bands are bands.",
      "System 7 has released several club singles.",
      "Club singles are not singles."
    ],
    "question": "System 7 has released several singles.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nBand(x) ::: x is a band.\nFormed(x, y) ::: x is formed by y.\nFormerMember(x, y) ::: x is a former member of y.\nRelease(x, y) ::: x releases y.\nSingle(x) ::: x is a single.\nClubSingle(x) ::: x is a club single.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nBand(system7) ∧ UKBased(system7) ∧ ElectronicDanceMusic(system7) ::: System 7 is a UK-based electronic dance music band.\nFormed(system7, steveHillage) ∧ Formed(system7, miquetteGiraudy) ::: Steve Hillage and Miquette Giraudy formed System 7.\nFormerMember(steveHillage, gong) ∧ FormerMember(miquetteGiraudy, gong) ::: Steve Hillage and Miquette Giraudy are former members of the band Gong.\n∀x (ElectricDanceMusic(x) → Band(x)) ::: Electric dance music bands are bands.\nRelease(system7, clubSingles) ∧ Several(clubSingles) ::: System 7 has released several club singles.\n∀x (ClubSingle(x) → ¬Single(x)) ::: Club singles are not singles.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n∃x (Release(system7, x) ∧ Single(x)) ::: System 7 has released several singles.\n\"\"\""
    ]
  },
  {
    "id": 37,
    "context": [
      "System 7 is a UK-based electronic dance music band.",
      "Steve Hillage and Miquette Giraudy formed System 7.",
      "Steve Hillage and Miquette Giraudy are former members of the band Gong.",
      "Electric dance music bands are bands.",
      "System 7 has released several club singles.",
      "Club singles are not singles."
    ],
    "question": "System 7 is not a band.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nBand(x) ::: x is a band.\nElectronicDanceMusicBand(x) ::: x is an electronic dance music band.\nFormed(x, y) ::: x is formed by y.\nFormerMember(x, y) ::: x is a former member of y.\nRelease(x, y) ::: x releases y.\nSingle(x) ::: x is a single.\nClubSingle(x) ::: x is a club single.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nElectronicDanceMusicBand(system7) ∧ Band(system7) ∧ LocatedIn(system7, UK) ::: System 7 is a UK-based electronic dance music band.\nFormed(system7, steveHillage) ∧ Formed(system7, miquetteGiraudy) ::: Steve Hillage and Miquette Giraudy formed System 7.\nFormerMember(steveHillage, gong) ∧ FormerMember(miquetteGiraudy, gong) ::: Steve Hillage and Miquette Giraudy are former members of the band Gong.\n∀x (ElectronicDanceMusicBand(x) → Band(x)) ::: Electric dance music bands are bands.\nRelease(system7, clubSingles) ∧ ¬Single(clubSingles) ::: System 7 has released several club singles and club singles are not singles.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬Band(system7) ::: System 7 is not a band.\n\"\"\""
    ]
  },
  {
    "id": 545,
    "context": [
      "A summarization model is always faithful if it uses content from the input documents.",
      "Extractive models are a kind of summarization models.",
      "Extractive model can only use content from the input documents."
    ],
    "question": "Extractive models are always faithful.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nFaithful(x) ::: x is faithful.\nSummarizationModel(x) ::: x is a summarization model.\nExtractiveModel(x) ::: x is an extractive model.\nUsesContent(x, y) ::: x uses content from y.\nInputDocuments(x) ::: x is input documents.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (SummarizationModel(x) → Faithful(x) ∧ UsesContent(x, InputDocuments(x))) ::: A summarization model is always faithful if it uses content from the input documents.\n∀x (ExtractiveModel(x) → SummarizationModel(x)) ::: Extractive models are a kind of summarization models.\n∀x (ExtractiveModel(x) → UsesContent(x, InputDocuments(x))) ::: Extractive model can only use content from the input documents.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n∀x (ExtractiveModel(x) → Faithful(x)) ::: Extractive models are always faithful.\n\"\"\""
    ]
  },
  {
    "id": 546,
    "context": [
      "A summarization model is always faithful if it uses content from the input documents.",
      "Extractive models are a kind of summarization models.",
      "Extractive model can only use content from the input documents."
    ],
    "question": "Extractive models are not always faithful.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nFaithful(x) ::: x is faithful.\nSummarizationModel(x) ::: x is a summarization model.\nExtractiveModel(x) ::: x is an extractive model.\nUsesContent(x, y) ::: x uses content from y.\nInputDocuments(x) ::: x is an input document.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (SummarizationModel(x) → Faithful(x) ∧ ∀y (UsesContent(x, y) → InputDocuments(y))) ::: A summarization model is always faithful if it uses content from the input documents.\n∀x (ExtractiveModel(x) → SummarizationModel(x)) ::: Extractive models are a kind of summarization models.\n∀x (ExtractiveModel(x) → ∀y (UsesContent(x, y) → InputDocuments(y))) ::: Extractive model can only use content from the input documents.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬(∀x (ExtractiveModel(x) → Faithful(x))) ::: Extractive models are not always faithful.\n\"\"\""
    ]
  },
  {
    "id": 989,
    "context": [
      "If people practice coding questions, then they are not studying to go to medical school to become a doctor.",
      "If people want to work in the software engineering industry, then they practice coding questions.",
      "If people enjoy healthcare fields and want to help people with medical issues, then they are studying to go to medical school to become a doctor.",
      "If people grew up with parents who worked as doctors, then they enjoy healthcare fields and want to help people with medical issues.",
      "If people study hard, then they grew up with parents who worked as doctors.",
      "If Robin neither enjoys healthcare fields and wants to help people with medical issues nor grew up with parents who worked as doctors, then Robin is either a person who studies hard or grew up with parents who worked as doctors."
    ],
    "question": "Robin is a person who studies hard.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nPractice(x) ::: x practices coding questions.\nStudy(x) ::: x is studying to go to medical school to become a doctor.\nSoftwareEngineering(x) ::: x wants to work in the software engineering industry.\nEnjoy(x, y) ::: x enjoys y.\nHelp(x, y) ::: x wants to help people with y.\nHealthcareFields(x) ::: x enjoys healthcare fields.\nGrewUpWithParents(x) ::: x grew up with parents who worked as doctors.\nStudyHard(x) ::: x studies hard.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nPractice(x) → ¬Study(x) ::: If people practice coding questions, then they are not studying to go to medical school to become a doctor.\nSoftwareEngineering(x) → Practice(x) ::: If people want to work in the software engineering industry, then they practice coding questions.\n(Enjoy(x, healthcareFields) ∧ Help(x, medicalIssues)) → Study(x) ::: If people enjoy healthcare fields and want to help people with medical issues, then they are studying to go to medical school to become a doctor.\nGrewUpWithParents(x) → (Enjoy(x, healthcareFields) ∧ Help(x, medicalIssues)) ::: If people grew up with parents who worked as doctors, then they enjoy healthcare fields and want to help people with medical issues.\nStudyHard(x) → GrewUpWithParents(x) ::: If people study hard, then they grew up with parents who worked as doctors.\n¬(Enjoy(robin, healthcareFields) ∧ Help(robin, medicalIssues)) → (StudyHard(robin) ∨ GrewUpWithParents(robin)) ::: If Robin neither enjoys healthcare fields and wants to help people with medical issues nor grew up with parents who worked as doctors, then Robin is either a person who studies hard or grew up with parents who worked as doctors.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nStudyHard(robin) ::: Robin is a person who studies hard.\n\"\"\""
    ]
  },
  {
    "id": 990,
    "context": [
      "If people practice coding questions, then they are not studying to go to medical school to become a doctor.",
      "If people want to work in the software engineering industry, then they practice coding questions.",
      "If people enjoy healthcare fields and want to help people with medical issues, then they are studying to go to medical school to become a doctor.",
      "If people grew up with parents who worked as doctors, then they enjoy healthcare fields and want to help people with medical issues.",
      "If people study hard, then they grew up with parents who worked as doctors.",
      "If Robin neither enjoys healthcare fields and wants to help people with medical issues nor grew up with parents who worked as doctors, then Robin is either a person who studies hard or grew up with parents who worked as doctors."
    ],
    "question": "Robin practices coding questions and wants to work in the software engineering industry.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nPractice(x) ::: x practices coding questions.\nStudy(x) ::: x is studying to go to medical school to become a doctor.\nSoftwareEngineer(x) ::: x wants to work in the software engineering industry.\nEnjoy(x) ::: x enjoys healthcare fields and wants to help people with medical issues.\nParent(x, y) ::: x grew up with parents who worked as y.\nHardStudy(x) ::: x studies hard.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nPractice(x) → ¬Study(x) ::: If people practice coding questions, then they are not studying to go to medical school to become a doctor.\nSoftwareEngineer(x) → Practice(x) ::: If people want to work in the software engineering industry, then they practice coding questions.\nEnjoy(x) ∧ Study(x) → Study(x) ::: If people enjoy healthcare fields and want to help people with medical issues, then they are studying to go to medical school to become a doctor.\nParent(x, doctor) → Enjoy(x) ∧ Study(x) ::: If people grew up with parents who worked as doctors, then they enjoy healthcare fields and want to help people with medical issues.\nHardStudy(x) → Parent(x, doctor) ::: If people study hard, then they grew up with parents who worked as doctors.\n¬(Enjoy(robin) ∧ Study(robin)) ∧ ¬Parent(robin, doctor) → HardStudy(robin) ∨ Parent(robin, doctor) ::: If Robin neither enjoys healthcare fields and wants to help people with medical issues nor grew up with parents who worked as doctors, then Robin is either a person who studies hard or grew up with parents who worked as doctors.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nPractice(robin) ∧ SoftwareEngineer(robin) ::: Robin practices coding questions and wants to work in the software engineering industry.\n\"\"\""
    ]
  },
  {
    "id": 991,
    "context": [
      "If people practice coding questions, then they are not studying to go to medical school to become a doctor.",
      "If people want to work in the software engineering industry, then they practice coding questions.",
      "If people enjoy healthcare fields and want to help people with medical issues, then they are studying to go to medical school to become a doctor.",
      "If people grew up with parents who worked as doctors, then they enjoy healthcare fields and want to help people with medical issues.",
      "If people study hard, then they grew up with parents who worked as doctors.",
      "If Robin neither enjoys healthcare fields and wants to help people with medical issues nor grew up with parents who worked as doctors, then Robin is either a person who studies hard or grew up with parents who worked as doctors."
    ],
    "question": "Robin neither practices coding questions nor works to work in the software engineering industry.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nPractice(x) ::: x practices coding questions.\nStudy(x) ::: x is studying to go to medical school to become a doctor.\nSoftwareEngineering(x) ::: x wants to work in the software engineering industry.\nEnjoy(x, y) ::: x enjoys y.\nHelp(x, y) ::: x helps people with y.\nMedicalIssues(x) ::: x is related to medical issues.\nParent(x, y) ::: x's parent is y.\nDoctor(x) ::: x is a doctor.\nGrowUp(x, y) ::: x grew up with y.\nStudyHard(x) ::: x studies hard.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nPractice(x) → ¬Study(x) ::: If people practice coding questions, then they are not studying to go to medical school to become a doctor.\nSoftwareEngineering(x) → Practice(x) ::: If people want to work in the software engineering industry, then they practice coding questions.\n(Enjoy(x, healthcareFields) ∧ Help(x, medicalIssues)) → Study(x) ::: If people enjoy healthcare fields and want to help people with medical issues, then they are studying to go to medical school to become a doctor.\nParent(x, doctor) → (Enjoy(x, healthcareFields) ∧ Help(x, medicalIssues)) ::: If people grew up with parents who worked as doctors, then they enjoy healthcare fields and want to help people with medical issues.\nStudyHard(x) → GrowUp(x, doctor) ::: If people study hard, then they grew up with parents who worked as doctors.\n¬(Enjoy(robin, healthcareFields) ∧ Help(robin, medicalIssues)) → (StudyHard(robin) ∨ GrowUp(robin, doctor)) ::: If Robin neither enjoys healthcare fields and wants to help people with medical issues nor grew up with parents who worked as doctors, then Robin is either a person who studies hard or grew up with parents who worked as doctors.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬(Practice(robin) ∨ SoftwareEngineering(robin)) ::: Robin neither practices coding questions nor works to work in the software engineering industry.\n\"\"\""
    ]
  },
  {
    "id": 1028,
    "context": [
      "If people go to the spa at least once a week, then they are not people who are miserly and need to save a large portion of their income.",
      "People are either miserly and need to save a large portion of their income, or people that frivolously spend a lot of money every time they go out.",
      "If people frivolously spend a lot of money every time they go out, then they value quality manufacturing and luxury items.",
      "If people value quality manufacturing and luxury items, then they enjoy shopping for materialistic items in their free time.",
      "If Jess is not miserly and needs to save a large portion of their income, then Jess does not value quality manufacturing and luxury items.",
      "If Jess either values quality manufacturing and luxury items or, if he does not, then he is miserly and needs to save a large portion of his income, then Jess frivolously spends a lot of money every time he goes out."
    ],
    "question": "Jess frivolously spends a lot of money every time they go out.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nGoToSpa(x) ::: x goes to the spa at least once a week.\nMiserly(x) ::: x is miserly and needs to save a large portion of their income.\nFrivolousSpender(x) ::: x frivolously spends a lot of money every time they go out.\nValueQuality(x) ::: x values quality manufacturing and luxury items.\nEnjoyShopping(x) ::: x enjoys shopping for materialistic items in their free time.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nGoToSpa(x) → ¬(Miserly(x) ∧ NeedToSave(x)) ::: If people go to the spa at least once a week, then they are not people who are miserly and need to save a large portion of their income.\nMiserly(x) ∨ FrivolousSpender(x) ::: People are either miserly and need to save a large portion of their income, or people that frivolously spend a lot of money every time they go out.\nFrivolousSpender(x) → ValueQuality(x) ::: If people frivolously spend a lot of money every time they go out, then they value quality manufacturing and luxury items.\nValueQuality(x) → EnjoyShopping(x) ::: If people value quality manufacturing and luxury items, then they enjoy shopping for materialistic items in their free time.\n¬(Miserly(jess) ∧ NeedToSave(jess)) → ¬ValueQuality(jess) ::: If Jess is not miserly and needs to save a large portion of their income, then Jess does not value quality manufacturing and luxury items.\n(ValueQuality(jess) ∨ ¬ValueQuality(jess)) → FrivolousSpender(jess) ::: If Jess either values quality manufacturing and luxury items or, if he does not, then he is miserly and needs to save a large portion of his income, then Jess frivolously spends a lot of money every time he goes out.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nFrivolousSpender(jess) ::: Jess frivolously spends a lot of money every time they go out.\n\"\"\""
    ]
  },
  {
    "id": 1029,
    "context": [
      "If people go to the spa at least once a week, then they are not people who are miserly and need to save a large portion of their income.",
      "People are either miserly and need to save a large portion of their income, or people that frivolously spend a lot of money every time they go out.",
      "If people frivolously spend a lot of money every time they go out, then they value quality manufacturing and luxury items.",
      "If people value quality manufacturing and luxury items, then they enjoy shopping for materialistic items in their free time.",
      "If Jess is not miserly and needs to save a large portion of their income, then Jess does not value quality manufacturing and luxury items.",
      "If Jess either values quality manufacturing and luxury items or, if he does not, then he is miserly and needs to save a large portion of his income, then Jess frivolously spends a lot of money every time he goes out."
    ],
    "question": "Jess either enjoys shopping for materialistic items in his free time or, if he does not, then he goes to the spa at least once a week.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nSpa(x) ::: x goes to the spa at least once a week.\nMiserly(x) ::: x is miserly and needs to save a large portion of their income.\nFrivolous(x) ::: x frivolously spends a lot of money every time they go out.\nValueQuality(x) ::: x values quality manufacturing and luxury items.\nEnjoyShopping(x) ::: x enjoys shopping for materialistic items in their free time.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Spa(x) → ¬(Miserly(x) ∧ NeedToSave(x))) ::: If people go to the spa at least once a week, then they are not people who are miserly and need to save a large portion of their income.\n∀x (Miserly(x) ∧ NeedToSave(x)) ∨ (Frivolous(x) ∧ SpendALot(x)) ::: People are either miserly and need to save a large portion of their income, or people that frivolously spend a lot of money every time they go out.\n∀x (Frivolous(x) ∧ SpendALot(x)) → ValueQuality(x) ::: If people frivolously spend a lot of money every time they go out, then they value quality manufacturing and luxury items.\n∀x (ValueQuality(x) → EnjoyShopping(x)) ::: If people value quality manufacturing and luxury items, then they enjoy shopping for materialistic items in their free time.\n¬(Miserly(jess) ∧ NeedToSave(jess)) → ¬ValueQuality(jess) ::: If Jess is not miserly and needs to save a large portion of their income, then Jess does not value quality manufacturing and luxury items.\n(ValueQuality(jess) ∨ ¬ValueQuality(jess)) → (Frivolous(jess) ∧ SpendALot(jess)) ::: If Jess either values quality manufacturing and luxury items or, if he does not, then he is miserly and needs to save a large portion of his income, then Jess frivolously spends a lot of money every time he goes out.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nEnjoyShopping(jess) ∨ ¬EnjoyShopping(jess) → Spa(jess) ::: Jess either enjoys shopping for materialistic items in his free time or, if he does not, then he goes to the spa at least once a week.\n\"\"\""
    ]
  },
  {
    "id": 1030,
    "context": [
      "If people go to the spa at least once a week, then they are not people who are miserly and need to save a large portion of their income.",
      "People are either miserly and need to save a large portion of their income, or people that frivolously spend a lot of money every time they go out.",
      "If people frivolously spend a lot of money every time they go out, then they value quality manufacturing and luxury items.",
      "If people value quality manufacturing and luxury items, then they enjoy shopping for materialistic items in their free time.",
      "If Jess is not miserly and needs to save a large portion of their income, then Jess does not value quality manufacturing and luxury items.",
      "If Jess either values quality manufacturing and luxury items or, if he does not, then he is miserly and needs to save a large portion of his income, then Jess frivolously spends a lot of money every time he goes out."
    ],
    "question": "If Jess either enjoys shopping for materialistic items in his free time or, if he does not, then he goes to the spa at least once a week, then Jess neither values quality manufacturing and luxury items nor goes to the spa at least once a week.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nGoToSpa(x) ::: x goes to the spa at least once a week.\nMiserly(x) ::: x is miserly and needs to save a large portion of their income.\nFrivolousSpender(x) ::: x frivolously spends a lot of money every time they go out.\nValueQuality(x) ::: x values quality manufacturing and luxury items.\nEnjoyShopping(x) ::: x enjoys shopping for materialistic items in their free time.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nGoToSpa(x) → ¬(Miserly(x) ∧ SaveLargePortion(x)) ::: If people go to the spa at least once a week, then they are not people who are miserly and need to save a large portion of their income.\nMiserly(x) ∨ FrivolousSpender(x) ::: People are either miserly and need to save a large portion of their income, or people that frivolously spend a lot of money every time they go out.\nFrivolousSpender(x) → ValueQuality(x) ::: If people frivolously spend a lot of money every time they go out, then they value quality manufacturing and luxury items.\nValueQuality(x) → EnjoyShopping(x) ::: If people value quality manufacturing and luxury items, then they enjoy shopping for materialistic items in their free time.\n¬(Miserly(jess) ∧ SaveLargePortion(jess)) → ¬ValueQuality(jess) ::: If Jess is not miserly and needs to save a large portion of their income, then Jess does not value quality manufacturing and luxury items.\n(ValueQuality(jess) ∨ ¬ValueQuality(jess)) → FrivolousSpender(jess) ::: If Jess either values quality manufacturing and luxury items or, if he does not, then he is miserly and needs to save a large portion of his income, then Jess frivolously spends a lot of money every time he goes out.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n(EnjoyShopping(jess) ∨ ¬EnjoyShopping(jess)) → GoToSpa(jess) → ¬(ValueQuality(jess) ∨ GoToSpa(jess)) ::: If Jess either enjoys shopping for materialistic items in his free time or, if he does not, then he goes to the spa at least once a week, then Jess neither values quality manufacturing and luxury items nor goes to the spa at least once a week.\n\"\"\""
    ]
  },
  {
    "id": 628,
    "context": [
      "The indie pop band Phoenix has released 6 albums. ",
      "Phoenix's album \"Wolfgang Amadeus Phoenix\" sold over 500,000 copies. ",
      "A certified gold album or single is one which sold over half a million copies. ",
      "\"1901\" is a single from Phoenix's album \"Wolfgang Amadeus Phoenix.\"",
      "Over 400,000 copies of \"1901\" have been sold. "
    ],
    "question": "The album \"Wolfgang Amadeus Phoenix\" is a certified gold album.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nBand(x) ::: x is a band.\nAlbum(x) ::: x is an album.\nSingle(x) ::: x is a single.\nRelease(x, y) ::: x has released y albums.\nSell(x, y) ::: x sold y copies.\nCertifiedGold(x) ::: x is a certified gold album or single.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nBand(phoenix) ∧ Release(phoenix, 6) ::: The indie pop band Phoenix has released 6 albums.\nAlbum(wolfgangAmadeusPhoenix) ∧ Sell(wolfgangAmadeusPhoenix, over500000) ::: Phoenix's album \"Wolfgang Amadeus Phoenix\" sold over 500,000 copies.\n∀x (Sell(x, over500000) → CertifiedGold(x)) ::: A certified gold album or single is one which sold over half a million copies.\nSingle(1901) ∧ Release(1901, wolfgangAmadeusPhoenix) ::: \"1901\" is a single from Phoenix's album \"Wolfgang Amadeus Phoenix.\"\nSell(1901, over400000) ::: Over 400,000 copies of \"1901\" have been sold.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nCertifiedGold(wolfgangAmadeusPhoenix) ::: The album \"Wolfgang Amadeus Phoenix\" is a certified gold album.\n\"\"\""
    ]
  },
  {
    "id": 629,
    "context": [
      "The indie pop band Phoenix has released 6 albums. ",
      "Phoenix's album \"Wolfgang Amadeus Phoenix\" sold over 500,000 copies. ",
      "A certified gold album or single is one which sold over half a million copies. ",
      "\"1901\" is a single from Phoenix's album \"Wolfgang Amadeus Phoenix.\"",
      "Over 400,000 copies of \"1901\" have been sold. "
    ],
    "question": "The single \"1901\" is a certified gold single.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nBand(x) ::: x is a band.\nAlbum(x) ::: x is an album.\nSingle(x) ::: x is a single.\nRelease(x, y) ::: x has released y albums.\nSell(x, y) ::: x sold over y copies.\nCertifiedGold(x) ::: x is a certified gold album or single.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nBand(phoenix) ∧ Release(phoenix, 6) ::: The indie pop band Phoenix has released 6 albums.\nAlbum(wolfgangAmadeusPhoenix) ∧ Sell(wolfgangAmadeusPhoenix, 500000) ::: Phoenix's album \"Wolfgang Amadeus Phoenix\" sold over 500,000 copies.\n∀x (Sell(x, 500000) → CertifiedGold(x)) ::: A certified gold album or single is one which sold over half a million copies.\nSingle(1901) ∧ Album(wolfgangAmadeusPhoenix) ::: \"1901\" is a single from Phoenix's album \"Wolfgang Amadeus Phoenix.\"\nSell(1901, 400000) ::: Over 400,000 copies of \"1901\" have been sold.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nCertifiedGold(1901) ::: The single \"1901\" is a certified gold single.\n\"\"\""
    ]
  },
  {
    "id": 11,
    "context": [
      "Peter Parker is a either a superhero or a civilian.",
      "The Hulk is a destroyer.",
      "The Hulk wakes up when he is angry.",
      "If the Hulk wakes up, then he will break a bridge.",
      "Thor is a god.",
      "Thor will break a bridge when he is happy.",
      "A god is not a destroyer and a destroyer is not a god.",
      "Peter Parker wears a uniform when he is a superhero.",
      "Peter Parker is not a civilian if and only if a destroyer is breaking a bridge.",
      "If Thor is happy, the Hulk is angry."
    ],
    "question": "If the Hulk does not wake up, then Thor is not happy.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nSuperhero(x) ::: x is a superhero.\nCivilian(x) ::: x is a civilian.\nDestroyer(x) ::: x is a destroyer.\nWakesUp(x) ::: x wakes up.\nAngry(x) ::: x is angry.\nBreaksBridge(x) ::: x breaks a bridge.\nGod(x) ::: x is a god.\nHappy(x) ::: x is happy.\nWearsUniform(x) ::: x wears a uniform.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nSuperhero(peterParker) ∨ Civilian(peterParker) ::: Peter Parker is a either a superhero or a civilian.\nDestroyer(theHulk) ::: The Hulk is a destroyer.\nWakesUp(theHulk) → Angry(theHulk) ::: The Hulk wakes up when he is angry.\nWakesUp(theHulk) → BreaksBridge(theHulk) ::: If the Hulk wakes up, then he will break a bridge.\nGod(thor) ::: Thor is a god.\nHappy(thor) → BreaksBridge(thor) ::: Thor will break a bridge when he is happy.\n∀x ((God(x) → ¬Destroyer(x)) ∧ (Destroyer(x) → ¬God(x))) ::: A god is not a destroyer and a destroyer is not a god.\nSuperhero(peterParker) → WearsUniform(peterParker) ::: Peter Parker wears a uniform when he is a superhero.\n¬Civilian(peterParker) ↔ BreaksBridge(theHulk) ::: Peter Parker is not a civilian if and only if a destroyer is breaking a bridge.\nHappy(thor) → Angry(theHulk) ::: If Thor is happy, the Hulk is angry.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬WakesUp(theHulk) → ¬Happy(thor) ::: If the Hulk does not wake up, then Thor is not happy.\n\"\"\""
    ]
  },
  {
    "id": 12,
    "context": [
      "Peter Parker is a either a superhero or a civilian.",
      "The Hulk is a destroyer.",
      "The Hulk wakes up when he is angry.",
      "If the Hulk wakes up, then he will break a bridge.",
      "Thor is a god.",
      "Thor will break a bridge when he is happy.",
      "A god is not a destroyer and a destroyer is not a god.",
      "Peter Parker wears a uniform when he is a superhero.",
      "Peter Parker is not a civilian if and only if a destroyer is breaking a bridge.",
      "If Thor is happy, the Hulk is angry."
    ],
    "question": "If Thor is happy, then Peter Parker wears a uniform.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nSuperhero(x) ::: x is a superhero.\nCivilian(x) ::: x is a civilian.\nDestroyer(x) ::: x is a destroyer.\nWakesUp(x) ::: x wakes up.\nAngry(x) ::: x is angry.\nBreaksBridge(x) ::: x breaks a bridge.\nGod(x) ::: x is a god.\nHappy(x) ::: x is happy.\nWearsUniform(x) ::: x wears a uniform.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nSuperhero(peterParker) ∨ Civilian(peterParker) ::: Peter Parker is a either a superhero or a civilian.\nDestroyer(theHulk) ::: The Hulk is a destroyer.\nWakesUp(theHulk) → Angry(theHulk) ::: The Hulk wakes up when he is angry.\nWakesUp(theHulk) → BreaksBridge(theHulk) ::: If the Hulk wakes up, then he will break a bridge.\nGod(thor) ::: Thor is a god.\nHappy(thor) → BreaksBridge(thor) ::: Thor will break a bridge when he is happy.\n∀x ((God(x) → ¬Destroyer(x)) ∧ (Destroyer(x) → ¬God(x))) ::: A god is not a destroyer and a destroyer is not a god.\nSuperhero(peterParker) → WearsUniform(peterParker) ::: Peter Parker wears a uniform when he is a superhero.\n¬Civilian(peterParker) ↔ BreaksBridge(destroyer) ::: Peter Parker is not a civilian if and only if a destroyer is breaking a bridge.\nHappy(thor) → Angry(theHulk) ::: If Thor is happy, the Hulk is angry.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nHappy(thor) → WearsUniform(peterParker) ::: If Thor is happy, then Peter Parker wears a uniform.\n\"\"\""
    ]
  },
  {
    "id": 13,
    "context": [
      "Peter Parker is a either a superhero or a civilian.",
      "The Hulk is a destroyer.",
      "The Hulk wakes up when he is angry.",
      "If the Hulk wakes up, then he will break a bridge.",
      "Thor is a god.",
      "Thor will break a bridge when he is happy.",
      "A god is not a destroyer and a destroyer is not a god.",
      "Peter Parker wears a uniform when he is a superhero.",
      "Peter Parker is not a civilian if and only if a destroyer is breaking a bridge.",
      "If Thor is happy, the Hulk is angry."
    ],
    "question": "If Thor is not happy, then no bridge will be broken.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nSuperhero(x) ::: x is a superhero.\nCivilian(x) ::: x is a civilian.\nDestroyer(x) ::: x is a destroyer.\nWakesUp(x) ::: x wakes up.\nAngry(x) ::: x is angry.\nBreaksBridge(x) ::: x breaks a bridge.\nGod(x) ::: x is a god.\nHappy(x) ::: x is happy.\nWearsUniform(x) ::: x wears a uniform.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nSuperhero(peterParker) ∨ Civilian(peterParker) ::: Peter Parker is a either a superhero or a civilian.\nDestroyer(theHulk) ::: The Hulk is a destroyer.\nWakesUp(theHulk) → Angry(theHulk) ::: The Hulk wakes up when he is angry.\nWakesUp(theHulk) → BreaksBridge(theHulk) ::: If the Hulk wakes up, then he will break a bridge.\nGod(thor) ::: Thor is a god.\nHappy(thor) → BreaksBridge(thor) ::: Thor will break a bridge when he is happy.\n∀x ((God(x) → ¬Destroyer(x)) ∧ (Destroyer(x) → ¬God(x))) ::: A god is not a destroyer and a destroyer is not a god.\nSuperhero(peterParker) → WearsUniform(peterParker) ::: Peter Parker wears a uniform when he is a superhero.\n¬Civilian(peterParker) ↔ BreaksBridge(theHulk) ::: Peter Parker is not a civilian if and only if a destroyer is breaking a bridge.\nHappy(thor) → Angry(theHulk) ::: If Thor is happy, the Hulk is angry.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬Happy(thor) → ¬∃x BreaksBridge(x) ::: If Thor is not happy, then no bridge will be broken.\n\"\"\""
    ]
  },
  {
    "id": 259,
    "context": [
      "Diethylcarbamazine is a medication discovered in the year 1947.",
      "Diethylcarbamazine can be used to treat river blindness.",
      "The only preferred treatment for river blindness is ivermectin.",
      "Diethylcarbamazine is not ivermectin."
    ],
    "question": "Diethylcarbamazine is not preferred for the treatment of river blindness.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nMedication(x) ::: x is a medication.\nDiscovered(x, y) ::: x is discovered in year y.\nTreat(x, y) ::: x can be used to treat y.\nPreferredTreatment(x, y) ::: x is the preferred treatment for y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nMedication(diethylcarbamazine) ∧ Discovered(diethylcarbamazine, year1947) ::: Diethylcarbamazine is a medication discovered in the year 1947.\nTreat(diethylcarbamazine, riverBlindness) ::: Diethylcarbamazine can be used to treat river blindness.\n∀x (PreferredTreatment(ivermectin, riverBlindness)) ::: The only preferred treatment for river blindness is ivermectin.\n¬(Diethylcarbamazine = ivermectin) ::: Diethylcarbamazine is not ivermectin.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬PreferredTreatment(diethylcarbamazine, riverBlindness) ::: Diethylcarbamazine is not preferred for the treatment of river blindness.\n\"\"\""
    ]
  },
  {
    "id": 260,
    "context": [
      "Diethylcarbamazine is a medication discovered in the year 1947.",
      "Diethylcarbamazine can be used to treat river blindness.",
      "The only preferred treatment for river blindness is ivermectin.",
      "Diethylcarbamazine is not ivermectin."
    ],
    "question": "Diethylcarbamazine was often used to treat river blindness.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nMedication(x) ::: x is a medication.\nDiscovered(x, y) ::: x is discovered in year y.\nTreats(x, y) ::: x can be used to treat y.\nPreferredTreatment(x, y) ::: x is the preferred treatment for y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nMedication(diethylcarbamazine) ∧ Discovered(diethylcarbamazine, year1947) ::: Diethylcarbamazine is a medication discovered in the year 1947.\nTreats(diethylcarbamazine, riverBlindness) ::: Diethylcarbamazine can be used to treat river blindness.\n∀x (PreferredTreatment(ivermectin, riverBlindness)) ::: The only preferred treatment for river blindness is ivermectin.\n¬(diethylcarbamazine = ivermectin) ::: Diethylcarbamazine is not ivermectin.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nTreats(diethylcarbamazine, riverBlindness) ::: Diethylcarbamazine was often used to treat river blindness.\n\"\"\""
    ]
  },
  {
    "id": 261,
    "context": [
      "Diethylcarbamazine is a medication discovered in the year 1947.",
      "Diethylcarbamazine can be used to treat river blindness.",
      "The only preferred treatment for river blindness is ivermectin.",
      "Diethylcarbamazine is not ivermectin."
    ],
    "question": "Diethylcarbamazine is used in the treatment of filariasis.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nMedication(x) ::: x is a medication.\nDiscovered(x, y) ::: x is discovered in year y.\nTreats(x, y) ::: x can be used to treat y.\nPreferredTreatment(x, y) ::: x is the preferred treatment for y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nMedication(diethylcarbamazine) ∧ Discovered(diethylcarbamazine, year1947) ::: Diethylcarbamazine is a medication discovered in the year 1947.\nTreats(diethylcarbamazine, riverBlindness) ::: Diethylcarbamazine can be used to treat river blindness.\n∀x (PreferredTreatment(ivermectin, riverBlindness)) ::: The only preferred treatment for river blindness is ivermectin.\n¬(diethylcarbamazine = ivermectin) ::: Diethylcarbamazine is not ivermectin.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nTreats(diethylcarbamazine, filariasis) ::: Diethylcarbamazine is used in the treatment of filariasis.\n\"\"\""
    ]
  },
  {
    "id": 1062,
    "context": [
      "All univariate analyses use a generalized linear model. ",
      "All multivoxel (pattern) analyses are implementing machine learning algorithms.",
      "All implementing machine learning algorithms are to learn and classify multivariate data.",
      "The Latent Dirichlet allocation model uses a generalized linear model or a univariate analysis. ",
      "If the Latent Dirichlet allocation model does not learn and classify multivariate data, then the Latent Dirichlet allocation model uses a generalized linear model and a multivoxel (pattern) analysis."
    ],
    "question": "Latent Dirichlet allocation model is implementing machine learning algorithms.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nUnivariate(x) ::: x is an univariate analysis.\nGLM(x) ::: x uses a generalized linear model.\nMultivoxel(x) ::: x is a multivoxel analysis.\nML(x) ::: x is implementing machine learning algorithms.\nLearn(x) ::: x learns data.\nClassify(x) ::: x classifies data.\nMultivariate(x) ::: x is multivariate data.\nLDA(x) ::: x is the Latent Dirichlet allocation model.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Univariate(x) → GLM(x)) ::: All univariate analyses use a generalized linear model.\n∀x (Multivoxel(x) → ML(x)) ::: All multivoxel (pattern) analyses are implementing machine learning algorithms.\n∀x (ML(x) → (Learn(x) ∧ Classify(Multivariate(x)))) ::: All implementing machine learning algorithms are to learn and classify multivariate data.\n(GLM(LDA) ∨ Univariate(LDA)) ::: The Latent Dirichlet allocation model uses a generalized linear model or a univariate analysis.\n¬(Learn(LDA) ∧ Classify(Multivariate(LDA))) → (GLM(LDA) ∧ Multivoxel(LDA)) ::: If the Latent Dirichlet allocation model does not learn and classify multivariate data, then the Latent Dirichlet allocation model uses a generalized linear model and a multivoxel (pattern) analysis.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nML(LDA) ::: Latent Dirichlet allocation model is implementing machine learning algorithms.\n\"\"\""
    ]
  },
  {
    "id": 1063,
    "context": [
      "All univariate analyses use a generalized linear model. ",
      "All multivoxel (pattern) analyses are implementing machine learning algorithms.",
      "All implementing machine learning algorithms are to learn and classify multivariate data.",
      "The Latent Dirichlet allocation model uses a generalized linear model or a univariate analysis. ",
      "If the Latent Dirichlet allocation model does not learn and classify multivariate data, then the Latent Dirichlet allocation model uses a generalized linear model and a multivoxel (pattern) analysis."
    ],
    "question": "Latent Dirichlet allocation model uses a generalized linear model and learns and classifies multivariate data.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nUnivariate(x) ::: x is an univariate analysis.\nGLM(x) ::: x uses a generalized linear model.\nMultivoxel(x) ::: x is a multivoxel analysis.\nImplementingML(x) ::: x is implementing machine learning algorithms.\nLearnClassify(x) ::: x learns and classifies multivariate data.\nLDA(x) ::: x is the Latent Dirichlet allocation model.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Univariate(x) → GLM(x)) ::: All univariate analyses use a generalized linear model.\n∀x (Multivoxel(x) → ImplementingML(x)) ::: All multivoxel (pattern) analyses are implementing machine learning algorithms.\n∀x (ImplementingML(x) → LearnClassify(x)) ::: All implementing machine learning algorithms are to learn and classify multivariate data.\n(GLM(LDA) ∨ Univariate(LDA)) ::: The Latent Dirichlet allocation model uses a generalized linear model or a univariate analysis.\n¬(LearnClassify(LDA)) → (GLM(LDA) ∧ Multivoxel(LDA)) ::: If the Latent Dirichlet allocation model does not learn and classify multivariate data, then the Latent Dirichlet allocation model uses a generalized linear model and a multivoxel (pattern) analysis.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nGLM(LDA) ∧ LearnClassify(LDA) ::: Latent Dirichlet allocation model uses a generalized linear model and learns and classifies multivariate data.\n\"\"\""
    ]
  },
  {
    "id": 1064,
    "context": [
      "All univariate analyses use a generalized linear model. ",
      "All multivoxel (pattern) analyses are implementing machine learning algorithms.",
      "All implementing machine learning algorithms are to learn and classify multivariate data.",
      "The Latent Dirichlet allocation model uses a generalized linear model or a univariate analysis. ",
      "If the Latent Dirichlet allocation model does not learn and classify multivariate data, then the Latent Dirichlet allocation model uses a generalized linear model and a multivoxel (pattern) analysis."
    ],
    "question": "Latent Dirichlet allocation model either uses a generalized linear model or learns and classifies multivariate data.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nUnivariate(x) ::: x is an univariate analysis.\nGLM(x) ::: x uses a generalized linear model.\nMultivoxel(x) ::: x is a multivoxel analysis.\nImplementingML(x) ::: x is implementing machine learning algorithms.\nLearnClassify(x) ::: x learns and classifies multivariate data.\nLDA(x) ::: x is the Latent Dirichlet allocation model.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Univariate(x) → GLM(x)) ::: All univariate analyses use a generalized linear model.\n∀x (Multivoxel(x) → ImplementingML(x)) ::: All multivoxel (pattern) analyses are implementing machine learning algorithms.\n∀x (ImplementingML(x) → LearnClassify(x)) ::: All implementing machine learning algorithms are to learn and classify multivariate data.\n(GLM(LDA) ∨ Univariate(LDA)) ::: The Latent Dirichlet allocation model uses a generalized linear model or a univariate analysis.\n¬(LearnClassify(LDA)) → (GLM(LDA) ∧ Multivoxel(LDA)) ::: If the Latent Dirichlet allocation model does not learn and classify multivariate data, then the Latent Dirichlet allocation model uses a generalized linear model and a multivoxel (pattern) analysis.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nGLM(LDA) ∨ LearnClassify(LDA) ::: Latent Dirichlet allocation model either uses a generalized linear model or learns and classifies multivariate data.\n\"\"\""
    ]
  },
  {
    "id": 1040,
    "context": [
      "If something requires a medical diagnosis, then lab tests or imaging is required. ",
      "All rare diseases require a medical diagnosis.",
      "If something is mild, then no lab tests or imaging is required. ",
      "All blood cancers are rare diseases.",
      "All Leukemia is blood cancer. ",
      "If bladder cancer is either both blood cancer and Leukemia or neither blood cancer nor Leukemia, then bladder cancer is Leukemia."
    ],
    "question": "Bladder cancer is mild.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nRequiresDiagnosis(x) ::: x requires a medical diagnosis.\nLabTestsOrImaging(x) ::: x requires lab tests or imaging.\nRareDisease(x) ::: x is a rare disease.\nMild(x) ::: x is mild.\nBloodCancer(x) ::: x is a blood cancer.\nLeukemia(x) ::: x is Leukemia.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (RequiresDiagnosis(x) → LabTestsOrImaging(x) ∨ Imaging(x)) ::: If something requires a medical diagnosis, then lab tests or imaging is required.\n∀x (RareDisease(x) → RequiresDiagnosis(x)) ::: All rare diseases require a medical diagnosis.\n∀x (Mild(x) → ¬LabTestsOrImaging(x)) ::: If something is mild, then no lab tests or imaging is required.\n∀x (BloodCancer(x) → RareDisease(x)) ::: All blood cancers are rare diseases.\n∀x (Leukemia(x) → BloodCancer(x)) ::: All Leukemia is blood cancer.\n((BloodCancer(bladderCancer) ∧ Leukemia(bladderCancer)) ∨ (¬BloodCancer(bladderCancer) ∧ ¬Leukemia(bladderCancer))) → Leukemia(bladderCancer) ::: If bladder cancer is either both blood cancer and Leukemia or neither blood cancer nor Leukemia, then bladder cancer is Leukemia.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nMild(bladderCancer) ::: Bladder cancer is mild.\n\"\"\""
    ]
  },
  {
    "id": 1041,
    "context": [
      "If something requires a medical diagnosis, then lab tests or imaging is required. ",
      "All rare diseases require a medical diagnosis.",
      "If something is mild, then no lab tests or imaging is required. ",
      "All blood cancers are rare diseases.",
      "All Leukemia is blood cancer. ",
      "If bladder cancer is either both blood cancer and Leukemia or neither blood cancer nor Leukemia, then bladder cancer is Leukemia."
    ],
    "question": "Bladder cancer is Leukemia.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nRequiresDiagnosis(x) ::: x requires a medical diagnosis.\nLabTests(x) ::: lab tests are required for x.\nImaging(x) ::: imaging is required for x.\nRareDisease(x) ::: x is a rare disease.\nMild(x) ::: x is mild.\nBloodCancer(x) ::: x is a blood cancer.\nLeukemia(x) ::: x is Leukemia.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (RequiresDiagnosis(x) → (LabTests(x) ∨ Imaging(x))) ::: If something requires a medical diagnosis, then lab tests or imaging is required.\n∀x (RareDisease(x) → RequiresDiagnosis(x)) ::: All rare diseases require a medical diagnosis.\n∀x (Mild(x) → ¬(LabTests(x) ∨ Imaging(x))) ::: If something is mild, then no lab tests or imaging is required.\n∀x (BloodCancer(x) → RareDisease(x)) ::: All blood cancers are rare diseases.\n∀x (Leukemia(x) → BloodCancer(x)) ::: All Leukemia is blood cancer.\n((BloodCancer(bladderCancer) ∧ Leukemia(bladderCancer)) ∨ (¬BloodCancer(bladderCancer) ∧ ¬Leukemia(bladderCancer))) → Leukemia(bladderCancer) ::: If bladder cancer is either both blood cancer and Leukemia or neither blood cancer nor Leukemia, then bladder cancer is Leukemia.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nLeukemia(bladderCancer) ::: Bladder cancer is Leukemia.\n\"\"\""
    ]
  },
  {
    "id": 1042,
    "context": [
      "If something requires a medical diagnosis, then lab tests or imaging is required. ",
      "All rare diseases require a medical diagnosis.",
      "If something is mild, then no lab tests or imaging is required. ",
      "All blood cancers are rare diseases.",
      "All Leukemia is blood cancer. ",
      "If bladder cancer is either both blood cancer and Leukemia or neither blood cancer nor Leukemia, then bladder cancer is Leukemia."
    ],
    "question": "Bladder cancer is either a rare disease or mild.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nRequiresDiagnosis(x) ::: x requires a medical diagnosis.\nLabTestsOrImaging(x) ::: x requires lab tests or imaging.\nRareDisease(x) ::: x is a rare disease.\nMild(x) ::: x is mild.\nBloodCancer(x) ::: x is a blood cancer.\nLeukemia(x) ::: x is Leukemia.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (RequiresDiagnosis(x) → LabTestsOrImaging(x)) ::: If something requires a medical diagnosis, then lab tests or imaging is required.\n∀x (RareDisease(x) → RequiresDiagnosis(x)) ::: All rare diseases require a medical diagnosis.\n∀x (Mild(x) → ¬LabTestsOrImaging(x)) ::: If something is mild, then no lab tests or imaging is required.\n∀x (BloodCancer(x) → RareDisease(x)) ::: All blood cancers are rare diseases.\n∀x (Leukemia(x) → BloodCancer(x)) ::: All Leukemia is blood cancer.\n((BloodCancer(bladderCancer) ∧ Leukemia(bladderCancer)) ∨ (¬BloodCancer(bladderCancer) ∧ ¬Leukemia(bladderCancer))) → Leukemia(bladderCancer) ::: If bladder cancer is either both blood cancer and Leukemia or neither blood cancer nor Leukemia, then bladder cancer is Leukemia.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nRareDisease(bladderCancer) ∨ Mild(bladderCancer) ::: Bladder cancer is either a rare disease or mild.\n\"\"\""
    ]
  },
  {
    "id": 1049,
    "context": [
      "No precious metals aren't scarce.",
      "All non-rare earth metals are not scarce.",
      "Either non-rare earth metals or rare earth metals. ",
      "All rare earth metals can be used for batteries.",
      "All rare earth metals are essential for electric vehicles.",
      "Lithium is neither a non-rare earth metal nor essential for electric vehicles."
    ],
    "question": "Lithium is a rare earth metal.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nPrecious(x) ::: x is a precious metal.\nScarce(x) ::: x is scarce.\nNonRareEarth(x) ::: x is a non-rare earth metal.\nRareEarth(x) ::: x is a rare earth metal.\nBatteries(x) ::: x can be used for batteries.\nElectricVehicles(x) ::: x is essential for electric vehicles.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n¬Precious(x) → ¬Scarce(x) ::: No precious metals aren't scarce.\n∀x (NonRareEarth(x) → ¬Scarce(x)) ::: All non-rare earth metals are not scarce.\nNonRareEarth(x) ∨ RareEarth(x) ::: Either non-rare earth metals or rare earth metals.\n∀x (RareEarth(x) → Batteries(x)) ::: All rare earth metals can be used for batteries.\n∀x (RareEarth(x) → ElectricVehicles(x)) ::: All rare earth metals are essential for electric vehicles.\n¬(NonRareEarth(lithium) ∨ ElectricVehicles(lithium)) ::: Lithium is neither a non-rare earth metal nor essential for electric vehicles.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬RareEarth(lithium) ::: Lithium is not a rare earth metal.\n\"\"\""
    ]
  },
  {
    "id": 1050,
    "context": [
      "No precious metals aren't scarce.",
      "All non-rare earth metals are not scarce.",
      "Either non-rare earth metals or rare earth metals. ",
      "All rare earth metals can be used for batteries.",
      "All rare earth metals are essential for electric vehicles.",
      "Lithium is neither a non-rare earth metal nor essential for electric vehicles."
    ],
    "question": "Lithium is a precious metal and is used for batteries.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nPrecious(x) ::: x is a precious metal.\nScare(x) ::: x is scarce.\nNonRareEarth(x) ::: x is a non-rare earth metal.\nRareEarth(x) ::: x is a rare earth metal.\nBattery(x) ::: x can be used for batteries.\nEssentialForEV(x) ::: x is essential for electric vehicles.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n¬(Precious(x) ∧ ¬Scare(x)) ::: No precious metals aren't scarce.\n∀x (NonRareEarth(x) → ¬Scare(x)) ::: All non-rare earth metals are not scarce.\nNonRareEarth(x) ∨ RareEarth(x) ::: Either non-rare earth metals or rare earth metals.\n∀x (RareEarth(x) → Battery(x)) ::: All rare earth metals can be used for batteries.\n∀x (RareEarth(x) → EssentialForEV(x)) ::: All rare earth metals are essential for electric vehicles.\n¬(NonRareEarth(lithium) ∨ EssentialForEV(lithium)) ::: Lithium is neither a non-rare earth metal nor essential for electric vehicles.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nPrecious(lithium) ∧ Battery(lithium) ::: Lithium is a precious metal and is used for batteries.\n\"\"\""
    ]
  },
  {
    "id": 1051,
    "context": [
      "No precious metals aren't scarce.",
      "All non-rare earth metals are not scarce.",
      "Either non-rare earth metals or rare earth metals. ",
      "All rare earth metals can be used for batteries.",
      "All rare earth metals are essential for electric vehicles.",
      "Lithium is neither a non-rare earth metal nor essential for electric vehicles."
    ],
    "question": "If Lithium is not essential for electric vehicles or a precious metal, then Lithium is not a non-rare earth metal or usable for batteries.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nPrecious(x) ::: x is a precious metal.\nScare(x) ::: x is scarce.\nNonRareEarth(x) ::: x is a non-rare earth metal.\nRareEarth(x) ::: x is a rare earth metal.\nBattery(x) ::: x can be used for batteries.\nEssential(x) ::: x is essential for electric vehicles.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n¬(Precious(x) ∧ ¬Scare(x)) ::: No precious metals aren't scarce.\n∀x (NonRareEarth(x) → ¬Scare(x)) ::: All non-rare earth metals are not scarce.\nNonRareEarth(x) ∨ RareEarth(x) ::: Either non-rare earth metals or rare earth metals.\n∀x (RareEarth(x) → Battery(x)) ::: All rare earth metals can be used for batteries.\n∀x (RareEarth(x) → Essential(x)) ::: All rare earth metals are essential for electric vehicles.\n¬(NonRareEarth(lithium) ∨ Essential(lithium)) ::: Lithium is neither a non-rare earth metal nor essential for electric vehicles.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n(¬Essential(lithium) ∨ Precious(lithium)) → (¬NonRareEarth(lithium) ∨ ¬Battery(lithium)) ::: If Lithium is not essential for electric vehicles or a precious metal, then Lithium is not a non-rare earth metal or usable for batteries.\n\"\"\""
    ]
  },
  {
    "id": 863,
    "context": [
      "If people own at least one pet, then they do not have tidy houses.",
      "If people grew up with childhood pets, then they own at least one pet.",
      "If people hire a maid or cleaning service, then they have tidy houses.",
      "If people live in the suburbs, then they have tidy houses.",
      "Jack either does not hire a maid or cleaning service or, if he does, then he does not own at least one pet."
    ],
    "question": "Jack lives in the suburbs.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nOwnsPet(x) ::: x owns at least one pet.\nTidyHouse(x) ::: x has a tidy house.\nGrewUpWithChildhoodPets(x) ::: x grew up with childhood pets.\nHireMaid(x) ::: x hires a maid.\nCleaningService(x) ::: x hires a cleaning service.\nLiveInSuburbs(x) ::: x lives in the suburbs.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (OwnsPet(x) → ¬TidyHouse(x)) ::: If people own at least one pet, then they do not have tidy houses.\n∀x (GrewUpWithChildhoodPets(x) → OwnsPet(x)) ::: If people grew up with childhood pets, then they own at least one pet.\n∀x ((HireMaid(x) ∨ CleaningService(x)) → TidyHouse(x)) ::: If people hire a maid or cleaning service, then they have tidy houses.\n∀x (LiveInSuburbs(x) → TidyHouse(x)) ::: If people live in the suburbs, then they have tidy houses.\n¬(HireMaid(jack) ∨ CleaningService(jack)) ∨ (HireMaid(jack) → ¬OwnsPet(jack)) ::: Jack either does not hire a maid or cleaning service or, if he does, then he does not own at least one pet.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nLiveInSuburbs(jack) ::: Jack lives in the suburbs.\n\"\"\""
    ]
  },
  {
    "id": 864,
    "context": [
      "If people own at least one pet, then they do not have tidy houses.",
      "If people grew up with childhood pets, then they own at least one pet.",
      "If people hire a maid or cleaning service, then they have tidy houses.",
      "If people live in the suburbs, then they have tidy houses.",
      "Jack either does not hire a maid or cleaning service or, if he does, then he does not own at least one pet."
    ],
    "question": "Jack does not live in the suburbs.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nOwnsPet(x) ::: x owns at least one pet.\nTidyHouse(x) ::: x has a tidy house.\nGrewUpWithChildhoodPets(x) ::: x grew up with childhood pets.\nHireMaid(x) ::: x hires a maid.\nCleaningService(x) ::: x hires a cleaning service.\nLiveInSuburbs(x) ::: x lives in the suburbs.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (OwnsPet(x) → ¬TidyHouse(x)) ::: If people own at least one pet, then they do not have tidy houses.\n∀x (GrewUpWithChildhoodPets(x) → OwnsPet(x)) ::: If people grew up with childhood pets, then they own at least one pet.\n∀x ((HireMaid(x) ∨ CleaningService(x)) → TidyHouse(x)) ::: If people hire a maid or cleaning service, then they have tidy houses.\n∀x (LiveInSuburbs(x) → TidyHouse(x)) ::: If people live in the suburbs, then they have tidy houses.\n¬(HireMaid(jack) ∨ CleaningService(jack)) ∨ (HireMaid(jack) → ¬OwnsPet(jack)) ::: Jack either does not hire a maid or cleaning service or, if he does, then he does not own at least one pet.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬LiveInSuburbs(jack) ::: Jack does not live in the suburbs.\n\"\"\""
    ]
  },
  {
    "id": 865,
    "context": [
      "If people own at least one pet, then they do not have tidy houses.",
      "If people grew up with childhood pets, then they own at least one pet.",
      "If people hire a maid or cleaning service, then they have tidy houses.",
      "If people live in the suburbs, then they have tidy houses.",
      "Jack either does not hire a maid or cleaning service or, if he does, then he does not own at least one pet."
    ],
    "question": "Jack has a tidy house.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nOwnsPet(x) ::: x owns at least one pet.\nTidyHouse(x) ::: x has a tidy house.\nGrewUpWithChildhoodPets(x) ::: x grew up with childhood pets.\nHireMaid(x) ::: x hires a maid.\nCleaningService(x) ::: x hires a cleaning service.\nLiveInSuburbs(x) ::: x lives in the suburbs.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (OwnsPet(x) → ¬TidyHouse(x)) ::: If people own at least one pet, then they do not have tidy houses.\n∀x (GrewUpWithChildhoodPets(x) → OwnsPet(x)) ::: If people grew up with childhood pets, then they own at least one pet.\n∀x ((HireMaid(x) ∨ CleaningService(x)) → TidyHouse(x)) ::: If people hire a maid or cleaning service, then they have tidy houses.\n∀x (LiveInSuburbs(x) → TidyHouse(x)) ::: If people live in the suburbs, then they have tidy houses.\n¬(HireMaid(jack) ∨ CleaningService(jack)) ∨ (HireMaid(jack) → ¬OwnsPet(jack)) ::: Jack either does not hire a maid or cleaning service or, if he does, then he does not own at least one pet.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nTidyHouse(jack) ::: Jack has a tidy house.\n\"\"\""
    ]
  },
  {
    "id": 866,
    "context": [
      "If people own at least one pet, then they do not have tidy houses.",
      "If people grew up with childhood pets, then they own at least one pet.",
      "If people hire a maid or cleaning service, then they have tidy houses.",
      "If people live in the suburbs, then they have tidy houses.",
      "Jack either does not hire a maid or cleaning service or, if he does, then he does not own at least one pet."
    ],
    "question": "Jack neither lives in the suburbs nor owns at least one pet.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nOwnsPet(x) ::: x owns at least one pet.\nTidyHouse(x) ::: x has a tidy house.\nGrewUpWithChildhoodPets(x) ::: x grew up with childhood pets.\nHireMaid(x) ::: x hires a maid.\nCleaningService(x) ::: x hires a cleaning service.\nLiveInSuburbs(x) ::: x lives in the suburbs.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (OwnsPet(x) → ¬TidyHouse(x)) ::: If people own at least one pet, then they do not have tidy houses.\n∀x (GrewUpWithChildhoodPets(x) → OwnsPet(x)) ::: If people grew up with childhood pets, then they own at least one pet.\n∀x ((HireMaid(x) ∨ CleaningService(x)) → TidyHouse(x)) ::: If people hire a maid or cleaning service, then they have tidy houses.\n∀x (LiveInSuburbs(x) → TidyHouse(x)) ::: If people live in the suburbs, then they have tidy houses.\n¬(HireMaid(jack) ∨ CleaningService(jack)) ∨ (¬OwnsPet(jack) ∧ (HireMaid(jack) → ¬OwnsPet(jack))) ::: Jack either does not hire a maid or cleaning service or, if he does, then he does not own at least one pet.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬LiveInSuburbs(jack) ∧ ¬OwnsPet(jack) ::: Jack neither lives in the suburbs nor owns at least one pet.\n\"\"\""
    ]
  },
  {
    "id": 867,
    "context": [
      "If people own at least one pet, then they do not have tidy houses.",
      "If people grew up with childhood pets, then they own at least one pet.",
      "If people hire a maid or cleaning service, then they have tidy houses.",
      "If people live in the suburbs, then they have tidy houses.",
      "Jack either does not hire a maid or cleaning service or, if he does, then he does not own at least one pet."
    ],
    "question": "Jack grew up with childhood pets and lives in the suburbs.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nOwns(x, y) ::: x owns y.\nHasTidyHouse(x) ::: x has a tidy house.\nGrewUpWithChildhoodPets(x) ::: x grew up with childhood pets.\nHire(x, y) ::: x hires y.\nLiveInSuburbs(x) ::: x lives in the suburbs.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Owns(x, y) → ¬HasTidyHouse(x)) ::: If people own at least one pet, then they do not have tidy houses.\n∀x (GrewUpWithChildhoodPets(x) → Owns(x, y)) ::: If people grew up with childhood pets, then they own at least one pet.\n∀x (Hire(x, maid) ∨ Hire(x, cleaningService) → HasTidyHouse(x)) ::: If people hire a maid or cleaning service, then they have tidy houses.\n∀x (LiveInSuburbs(x) → HasTidyHouse(x)) ::: If people live in the suburbs, then they have tidy houses.\n¬(Hire(jack, maid) ∨ Hire(jack, cleaningService)) ∨ (Hire(jack, maid) → ¬Owns(jack, y)) ::: Jack either does not hire a maid or cleaning service or, if he does, then he does not own at least one pet.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nGrewUpWithChildhoodPets(jack) ∧ LiveInSuburbs(jack) ::: Jack grew up with childhood pets and lives in the suburbs.\n\"\"\""
    ]
  },
  {
    "id": 727,
    "context": [
      "A bottle is either standing upright or toppled over. ",
      "The bottle is not upright."
    ],
    "question": "The bottle is toppled over.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nUpright(x) ::: x is standing upright.\nToppled(x) ::: x is toppled over.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nUpright(bottle) ⊕ Toppled(bottle) ::: A bottle is either standing upright or toppled over.\n¬Upright(bottle) ::: The bottle is not upright.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nToppled(bottle) ::: The bottle is toppled over.\n\"\"\""
    ]
  },
  {
    "id": 957,
    "context": [
      "If people eat cereal and milk every day for breakfast, then they have very busy morning schedules every day.",
      "All young children below the age of ten eat cereal and milk every day for breakfast.",
      "People are either young children below the age of ten or have a lot of commitments they voluntarily signed up for.",
      "If people have a lot of commitments they voluntarily signed up for, then they are hardworking individuals with high ambitions and goals for the future.",
      "If people are hardworking individuals with high ambitions and goals for the future, then they are not good at staying organized and motivated.",
      "John either is both a hardworking individual with high ambitions and goals for the future and has busy morning schedules every day, or he is neither a hardworking individual with high ambitions and goals for the future nor does he have a busy morning schedule every day."
    ],
    "question": "John is good at staying organized and motivated.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nEat(x, y) ::: x eats y every day for breakfast.\nBusy(x) ::: x has very busy morning schedules every day.\nYoung(x) ::: x is a young child below the age of ten.\nCommitments(x) ::: x has a lot of commitments they voluntarily signed up for.\nHardworking(x) ::: x is a hardworking individual.\nAmbitious(x) ::: x has high ambitions.\nGoal(x) ::: x has goals for the future.\nOrganized(x) ::: x is good at staying organized.\nMotivated(x) ::: x is motivated.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Eat(x, cereal) ∧ Eat(x, milk) → Busy(x)) ::: If people eat cereal and milk every day for breakfast, then they have very busy morning schedules every day.\n∀x (Young(x) → (Eat(x, cereal) ∧ Eat(x, milk))) ::: All young children below the age of ten eat cereal and milk every day for breakfast.\n∀x (Young(x) ∨ Commitments(x)) ::: People are either young children below the age of ten or have a lot of commitments they voluntarily signed up for.\n∀x (Commitments(x) → (Hardworking(x) ∧ Ambitious(x) ∧ Goal(x))) ::: If people have a lot of commitments they voluntarily signed up for, then they are hardworking individuals with high ambitions and goals for the future.\n∀x (Hardworking(x) ∧ Ambitious(x) ∧ Goal(x) → ¬Organized(x) ∧ ¬Motivated(x)) ::: If people are hardworking individuals with high ambitions and goals for the future, then they are not good at staying organized and motivated.\n(Hardworking(john) ∧ Ambitious(john) ∧ Goal(john) ∧ Busy(john)) ⊕ ¬(Hardworking(john) ∨ Ambitious(john) ∨ Goal(john) ∨ Busy(john)) ::: John either is both a hardworking individual with high ambitions and goals for the future and has busy morning schedules every day, or he is neither a hardworking individual with high ambitions and goals for the future nor does he have a busy morning schedule every day.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nOrganized(john) ∧ Motivated(john) ::: John is good at staying organized and motivated.\n\"\"\""
    ]
  },
  {
    "id": 958,
    "context": [
      "If people eat cereal and milk every day for breakfast, then they have very busy morning schedules every day.",
      "All young children below the age of ten eat cereal and milk every day for breakfast.",
      "People are either young children below the age of ten or have a lot of commitments they voluntarily signed up for.",
      "If people have a lot of commitments they voluntarily signed up for, then they are hardworking individuals with high ambitions and goals for the future.",
      "If people are hardworking individuals with high ambitions and goals for the future, then they are not good at staying organized and motivated.",
      "John either is both a hardworking individual with high ambitions and goals for the future and has busy morning schedules every day, or he is neither a hardworking individual with high ambitions and goals for the future nor does he have a busy morning schedule every day."
    ],
    "question": "John eats cereal and milk every day for breakfast.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nEat(x, y) ::: x eats y every day for breakfast.\nBusy(x) ::: x has very busy morning schedules every day.\nYoung(x) ::: x is a young child below the age of ten.\nCommitments(x) ::: x has a lot of commitments they voluntarily signed up for.\nHardworking(x) ::: x is a hardworking individual.\nAmbitious(x) ::: x has high ambitions and goals for the future.\nOrganized(x) ::: x is good at staying organized.\nMotivated(x) ::: x is motivated.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Eat(x, cerealAndMilk) → Busy(x)) ::: If people eat cereal and milk every day for breakfast, then they have very busy morning schedules every day.\n∀x (Young(x) → Eat(x, cerealAndMilk)) ::: All young children below the age of ten eat cereal and milk every day for breakfast.\n∀x (Young(x) ∨ Commitments(x)) ::: People are either young children below the age of ten or have a lot of commitments they voluntarily signed up for.\n∀x (Commitments(x) → (Hardworking(x) ∧ Ambitious(x))) ::: If people have a lot of commitments they voluntarily signed up for, then they are hardworking individuals with high ambitions and goals for the future.\n∀x (Hardworking(x) ∧ Ambitious(x) → (¬Organized(x) ∧ ¬Motivated(x))) ::: If people are hardworking individuals with high ambitions and goals for the future, then they are not good at staying organized and motivated.\n¬((Hardworking(john) ∧ Ambitious(john)) ∧ Busy(john)) → ((Hardworking(john) ∧ Ambitious(john)) ∧ Busy(john)) ⊕ ¬(Hardworking(john) ∨ Ambitious(john) ∨ Busy(john)) ::: John either is both a hardworking individual with high ambitions and goals for the future and has busy morning schedules every day, or he is neither a hardworking individual with high ambitions and goals for the future nor does he have a busy morning schedule every day.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nEat(john, cerealAndMilk) ::: John eats cereal and milk every day for breakfast.\n\"\"\""
    ]
  },
  {
    "id": 959,
    "context": [
      "If people eat cereal and milk every day for breakfast, then they have very busy morning schedules every day.",
      "All young children below the age of ten eat cereal and milk every day for breakfast.",
      "People are either young children below the age of ten or have a lot of commitments they voluntarily signed up for.",
      "If people have a lot of commitments they voluntarily signed up for, then they are hardworking individuals with high ambitions and goals for the future.",
      "If people are hardworking individuals with high ambitions and goals for the future, then they are not good at staying organized and motivated.",
      "John either is both a hardworking individual with high ambitions and goals for the future and has busy morning schedules every day, or he is neither a hardworking individual with high ambitions and goals for the future nor does he have a busy morning schedule every day."
    ],
    "question": "John is either a hardworking individual with high ambitions and goals for the future or is good at staying organized and motivated.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nEat(x, y) ::: x eats y every day for breakfast.\nBusy(x) ::: x has very busy morning schedules every day.\nYoung(x) ::: x is a young child below the age of ten.\nCommitments(x) ::: x has a lot of commitments they voluntarily signed up for.\nHardworking(x) ::: x is a hardworking individual.\nAmbitious(x) ::: x has high ambitions and goals for the future.\nOrganized(x) ::: x is good at staying organized.\nMotivated(x) ::: x is motivated.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Eat(x, cereal) ∧ Eat(x, milk) → Busy(x)) ::: If people eat cereal and milk every day for breakfast, then they have very busy morning schedules every day.\n∀x (Young(x) → (Eat(x, cereal) ∧ Eat(x, milk))) ::: All young children below the age of ten eat cereal and milk every day for breakfast.\n∀x (Young(x) ∨ Commitments(x)) ::: People are either young children below the age of ten or have a lot of commitments they voluntarily signed up for.\n∀x (Commitments(x) → (Hardworking(x) ∧ Ambitious(x))) ::: If people have a lot of commitments they voluntarily signed up for, then they are hardworking individuals with high ambitions and goals for the future.\n∀x (Hardworking(x) ∧ Ambitious(x) → (¬Organized(x) ∧ ¬Motivated(x))) ::: If people are hardworking individuals with high ambitions and goals for the future, then they are not good at staying organized and motivated.\n(¬(Hardworking(john) ∧ Ambitious(john)) ∨ Busy(john)) → ((Hardworking(john) ∧ Ambitious(john)) ∨ (¬Hardworking(john) ∧ ¬Ambitious(john))) ::: John either is both a hardworking individual with high ambitions and goals for the future and has busy morning schedules every day, or he is neither a hardworking individual with high ambitions and goals for the future nor does he have a busy morning schedule every day.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n(Hardworking(john) ∧ Ambitious(john)) ∨ Organized(john) ::: John is either a hardworking individual with high ambitions and goals for the future or is good at staying organized and motivated.\n\"\"\""
    ]
  },
  {
    "id": 238,
    "context": [
      "Ableton has an office in Germany.",
      "Ableton has an office in the USA.",
      "USA and Germany are different countries.",
      "Any company that has offices in different countries is a multinational company.",
      "Ableton makes music software."
    ],
    "question": "Ableton is a multinational company.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nHasOffice(x, y) ::: Company x has an office in country y.\nDifferent(x, y) ::: x and y are different countries.\nMultinational(x) ::: x is a multinational company.\nMakes(x, y) ::: x makes y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nHasOffice(ableton, germany) ::: Ableton has an office in Germany.\nHasOffice(ableton, USA) ::: Ableton has an office in the USA.\nDifferent(USA, Germany) ::: USA and Germany are different countries.\n∀x (∃y ∃z (HasOffice(x, y) ∧ HasOffice(x, z) ∧ Different(y, z)) → Multinational(x)) ::: Any company that has offices in different countries is a multinational company.\nMakes(ableton, musicSoftware) ::: Ableton makes music software.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nMultinational(ableton) ::: Ableton is a multinational company.\n\"\"\""
    ]
  },
  {
    "id": 239,
    "context": [
      "Ableton has an office in Germany.",
      "Ableton has an office in the USA.",
      "USA and Germany are different countries.",
      "Any company that has offices in different countries is a multinational company.",
      "Ableton makes music software."
    ],
    "question": "Ableton makes AI software.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nHasOffice(x, y) ::: Company x has an office in country y.\nDifferent(x, y) ::: x and y are different countries.\nMultinational(x) ::: x is a multinational company.\nMakes(x, y) ::: x makes y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nHasOffice(ableton, germany) ::: Ableton has an office in Germany.\nHasOffice(ableton, USA) ::: Ableton has an office in the USA.\nDifferent(USA, Germany) ::: USA and Germany are different countries.\n∀x (∃y ∃z (HasOffice(x, y) ∧ HasOffice(x, z) ∧ Different(y, z)) → Multinational(x)) ::: Any company that has offices in different countries is a multinational company.\nMakes(ableton, musicSoftware) ::: Ableton makes music software.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬Makes(ableton, aiSoftware) ::: Ableton does not make AI software.\n\"\"\""
    ]
  },
  {
    "id": 240,
    "context": [
      "Ableton has an office in Germany.",
      "Ableton has an office in the USA.",
      "USA and Germany are different countries.",
      "Any company that has offices in different countries is a multinational company.",
      "Ableton makes music software."
    ],
    "question": "Ableton does not have an office in Germany.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nHasOffice(x, y) ::: Company x has an office in country y.\nDifferent(x, y) ::: x and y are different countries.\nMultinational(x) ::: x is a multinational company.\nMakes(x, y) ::: x makes y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nHasOffice(ableton, germany) ::: Ableton has an office in Germany.\nHasOffice(ableton, USA) ::: Ableton has an office in the USA.\nDifferent(USA, Germany) ::: USA and Germany are different countries.\n∀x (∃y ∃z (HasOffice(x, y) ∧ HasOffice(x, z) ∧ Different(y, z)) → Multinational(x)) ::: Any company that has offices in different countries is a multinational company.\nMakes(ableton, musicSoftware) ::: Ableton makes music software.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬HasOffice(ableton, germany) ::: Ableton does not have an office in Germany.\n\"\"\""
    ]
  },
  {
    "id": 1300,
    "context": [
      "Every swimmer can go underwater.",
      "Everyone that eats fish they catch themselves is a swimmer.",
      "Every penguin eats fish they catch themselves.",
      "All nonflying birds in Antarctica are penguins.",
      "Fido is a penguin or a swimmer."
    ],
    "question": "Fido eats fish they catch themselves.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nSwimmer(x) ::: x is a swimmer.\nEatsFish(x) ::: x eats fish.\nCatchesFish(x) ::: x catches fish.\nPenguin(x) ::: x is a penguin.\nNonFlyingBird(x) ::: x is a nonflying bird.\nAntarctica(x) ::: x is in Antarctica.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Swimmer(x) → CanGoUnderwater(x)) ::: Every swimmer can go underwater.\n∀x (EatsFish(x) ∧ CatchesFish(x) → Swimmer(x)) ::: Everyone that eats fish they catch themselves is a swimmer.\n∀x (Penguin(x) → (EatsFish(x) ∧ CatchesFish(x))) ::: Every penguin eats fish they catch themselves.\n∀x (NonFlyingBird(x) ∧ Antarctica(x) → Penguin(x)) ::: All nonflying birds in Antarctica are penguins.\n(Penguin(fido) ∨ Swimmer(fido)) ::: Fido is a penguin or a swimmer.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nEatsFish(fido) ∧ CatchesFish(fido) ::: Fido eats fish they catch themselves.\n\"\"\""
    ]
  },
  {
    "id": 1301,
    "context": [
      "Every swimmer can go underwater.",
      "Everyone that eats fish they catch themselves is a swimmer.",
      "Every penguin eats fish they catch themselves.",
      "All nonflying birds in Antarctica are penguins.",
      "Fido is a penguin or a swimmer."
    ],
    "question": "Fido is neither a non-flying bird nor can Fido go underwater.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nSwimmer(x) ::: x is a swimmer.\nEatsFish(x) ::: x eats fish.\nCatchesFish(x) ::: x catches fish.\nPenguin(x) ::: x is a penguin.\nNonFlyingBird(x) ::: x is a non-flying bird.\nAntarctica(x) ::: x is in Antarctica.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Swimmer(x) → CanGoUnderwater(x)) ::: Every swimmer can go underwater.\n∀x (EatsFish(x) ∧ CatchesFish(x) → Swimmer(x)) ::: Everyone that eats fish they catch themselves is a swimmer.\n∀x (Penguin(x) → (EatsFish(x) ∧ CatchesFish(x))) ::: Every penguin eats fish they catch themselves.\n∀x (NonFlyingBird(x) ∧ Antarctica(x) → Penguin(x)) ::: All nonflying birds in Antarctica are penguins.\n(Penguin(fido) ∨ Swimmer(fido)) ::: Fido is a penguin or a swimmer.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬(NonFlyingBird(fido) ∨ CanGoUnderwater(fido)) ::: Fido is neither a non-flying bird nor can Fido go underwater.\n\"\"\""
    ]
  },
  {
    "id": 1302,
    "context": [
      "Every swimmer can go underwater.",
      "Everyone that eats fish they catch themselves is a swimmer.",
      "Every penguin eats fish they catch themselves.",
      "All nonflying birds in Antarctica are penguins.",
      "Fido is a penguin or a swimmer."
    ],
    "question": "If Fido can either go underwater or is a swimmer, then Fido is a nonflying bird in Antartica.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nSwimmer(x) ::: x is a swimmer.\nGoUnderwater(x) ::: x can go underwater.\nEatFish(x) ::: x eats fish.\nCatch(x, y) ::: x catches y.\nPenguin(x) ::: x is a penguin.\nNonFlyingBird(x) ::: x is a nonflying bird.\nAntarctica(x) ::: x is in Antarctica.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Swimmer(x) → GoUnderwater(x)) ::: Every swimmer can go underwater.\n∀x (EatFish(x) ∧ Catch(x, x)) → Swimmer(x) ::: Everyone that eats fish they catch themselves is a swimmer.\n∀x (Penguin(x) → (EatFish(x) ∧ Catch(x, x))) ::: Every penguin eats fish they catch themselves.\n∀x (NonFlyingBird(x) ∧ Antarctica(x) → Penguin(x)) ::: All nonflying birds in Antarctica are penguins.\n(Penguin(fido) ∨ Swimmer(fido)) ::: Fido is a penguin or a swimmer.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n(Swimmer(fido) ∨ GoUnderwater(fido)) → (NonFlyingBird(fido) ∧ Antarctica(fido)) ::: If Fido can either go underwater or is a swimmer, then Fido is a nonflying bird in Antarctica.\n\"\"\""
    ]
  },
  {
    "id": 1359,
    "context": [
      "All professors are teachers.",
      "All researchers are professors.",
      "No teachers are students.",
      "All people who study are students.",
      "Leon is not studying or a researcher.",
      "If Leon is not studying, then Leon is a teacher."
    ],
    "question": "Leon is a professor.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nProfessor(x) ::: x is a professor.\nTeacher(x) ::: x is a teacher.\nResearcher(x) ::: x is a researcher.\nStudent(x) ::: x is a student.\nStudy(x) ::: x studies.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Professor(x) → Teacher(x)) ::: All professors are teachers.\n∀x (Researcher(x) → Professor(x)) ::: All researchers are professors.\n∀x (Teacher(x) → ¬Student(x)) ::: No teachers are students.\n∀x (Study(x) → Student(x)) ::: All people who study are students.\n¬(Study(leon) ∨ Researcher(leon)) ::: Leon is not studying or a researcher.\n¬Study(leon) → Teacher(leon) ::: If Leon is not studying, then Leon is a teacher.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nProfessor(leon) ::: Leon is a professor.\n\"\"\""
    ]
  },
  {
    "id": 1360,
    "context": [
      "All professors are teachers.",
      "All researchers are professors.",
      "No teachers are students.",
      "All people who study are students.",
      "Leon is not studying or a researcher.",
      "If Leon is not studying, then Leon is a teacher."
    ],
    "question": "Leon is neither a student nor a researcher.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nProfessor(x) ::: x is a professor.\nTeacher(x) ::: x is a teacher.\nResearcher(x) ::: x is a researcher.\nStudent(x) ::: x is a student.\nStudy(x) ::: x studies.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Professor(x) → Teacher(x)) ::: All professors are teachers.\n∀x (Researcher(x) → Professor(x)) ::: All researchers are professors.\n∀x (Teacher(x) → ¬Student(x)) ::: No teachers are students.\n∀x (Study(x) → Student(x)) ::: All people who study are students.\n¬(Study(leon) ∨ Researcher(leon)) ::: Leon is not studying or a researcher.\n¬Study(leon) → Teacher(leon) ::: If Leon is not studying, then Leon is a teacher.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬Student(leon) ∧ ¬Researcher(leon) ::: Leon is neither a student nor a researcher.\n\"\"\""
    ]
  },
  {
    "id": 1361,
    "context": [
      "All professors are teachers.",
      "All researchers are professors.",
      "No teachers are students.",
      "All people who study are students.",
      "Leon is not studying or a researcher.",
      "If Leon is not studying, then Leon is a teacher."
    ],
    "question": "If Leon is not a researcher, then Leon is a student.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nProfessor(x) ::: x is a professor.\nTeacher(x) ::: x is a teacher.\nResearcher(x) ::: x is a researcher.\nStudent(x) ::: x is a student.\nStudy(x) ::: x studies.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Professor(x) → Teacher(x)) ::: All professors are teachers.\n∀x (Researcher(x) → Professor(x)) ::: All researchers are professors.\n∀x (Teacher(x) → ¬Student(x)) ::: No teachers are students.\n∀x (Study(x) → Student(x)) ::: All people who study are students.\n¬(Study(leon) ∨ Researcher(leon)) ::: Leon is not studying or a researcher.\n¬Study(leon) → Teacher(leon) ::: If Leon is not studying, then Leon is a teacher.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬Researcher(leon) → Student(leon) ::: If Leon is not a researcher, then Leon is a student.\n\"\"\""
    ]
  },
  {
    "id": 345,
    "context": [
      "A cutman is responsible for preventing and treating physical damage to a fighter.",
      "Cutmen appear in matches such as a boxing, kickboxing or a mixed martial arts bout. ",
      "Cutmen typically handle swelling, nosebleeds and lacerations. ",
      "Jack is a cutman."
    ],
    "question": "No cutmen appear in boxing matches.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nResponsibleFor(x, y) ::: x is responsible for preventing and treating physical damage to y.\nAppearIn(x, y) ::: x appears in matches such as y.\nHandle(x, y) ::: x typically handles y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (ResponsibleFor(Cutman, x) → Prevent(x) ∧ Treat(x)) ::: A cutman is responsible for preventing and treating physical damage to a fighter.\n∀x (AppearIn(Cutman, x) → Boxing(x) ∨ Kickboxing(x) ∨ MixedMartialArts(x)) ::: Cutmen appear in matches such as a boxing, kickboxing or a mixed martial arts bout.\n∀x (Cutman(x) → Handle(x, Swelling) ∧ Handle(x, Nosebleeds) ∧ Handle(x, Lacerations)) ::: Cutmen typically handle swelling, nosebleeds and lacerations.\nCutman(jack) ::: Jack is a cutman.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬∃x (AppearIn(Cutman, Boxing)) ::: No cutmen appear in boxing matches.\n\"\"\""
    ]
  },
  {
    "id": 346,
    "context": [
      "A cutman is responsible for preventing and treating physical damage to a fighter.",
      "Cutmen appear in matches such as a boxing, kickboxing or a mixed martial arts bout. ",
      "Cutmen typically handle swelling, nosebleeds and lacerations. ",
      "Jack is a cutman."
    ],
    "question": "If someone is not a cutman, then they cannot handle nosebleeds.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nResponsibleFor(x, y) ::: x is responsible for preventing and treating physical damage to y.\nAppearIn(x, y) ::: x appears in matches such as y.\nHandle(x, y) ::: x handles y.\nSwelling(x) ::: x handles swelling.\nNosebleeds(x) ::: x handles nosebleeds.\nLacerations(x) ::: x handles lacerations.\nCutman(x) ::: x is a cutman.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Cutman(x) → ResponsibleFor(x, fighter)) ::: A cutman is responsible for preventing and treating physical damage to a fighter.\n∀x (Cutman(x) → AppearIn(x, boxing) ∨ AppearIn(x, kickboxing) ∨ AppearIn(x, mixedMartialArts)) ::: Cutmen appear in matches such as a boxing, kickboxing or a mixed martial arts bout.\n∀x (Cutman(x) → Swelling(x) ∧ Nosebleeds(x) ∧ Lacerations(x)) ::: Cutmen typically handle swelling, nosebleeds and lacerations.\nCutman(jack) ::: Jack is a cutman.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬Cutman(x) → ¬Handle(x, nosebleeds) ::: If someone is not a cutman, then they cannot handle nosebleeds.\n\"\"\""
    ]
  },
  {
    "id": 347,
    "context": [
      "A cutman is responsible for preventing and treating physical damage to a fighter.",
      "Cutmen appear in matches such as a boxing, kickboxing or a mixed martial arts bout. ",
      "Cutmen typically handle swelling, nosebleeds and lacerations. ",
      "Jack is a cutman."
    ],
    "question": "Jack can treat physical damage.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nResponsibleFor(x, y) ::: x is responsible for preventing and treating physical damage to y.\nAppearIn(x, y) ::: x appears in matches such as y.\nHandle(x, y) ::: x typically handles y.\nCutman(x) ::: x is a cutman.\nPhysicalDamage(x) ::: x is physical damage.\nTreat(x, y) ::: x treats y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Cutman(x) → ResponsibleFor(x, fighter)) ::: A cutman is responsible for preventing and treating physical damage to a fighter.\n∀x (Cutman(x) → AppearIn(x, boxing) ∨ AppearIn(x, kickboxing) ∨ AppearIn(x, mixedMartialArts)) ::: Cutmen appear in matches such as a boxing, kickboxing or a mixed martial arts bout.\n∀x (Cutman(x) → Handle(x, swelling) ∧ Handle(x, nosebleeds) ∧ Handle(x, lacerations)) ::: Cutmen typically handle swelling, nosebleeds and lacerations.\nCutman(jack) ::: Jack is a cutman.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n∃x (Cutman(jack) ∧ Treat(jack, physicalDamage)) ::: Jack can treat physical damage.\n\"\"\""
    ]
  },
  {
    "id": 491,
    "context": [
      "The Mona Lisa is one of the world's best-known artworks.",
      "The Mona Lisa is a portrait painted by Leonardo da Vinci.",
      "Leonardo da Vinci was a scientist and painter.",
      "Painting genres are history, portrait, animal, landscape, and still life."
    ],
    "question": "One of the world's best-known artworks is painted by a scientist.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nArtwork(x) ::: x is an artwork.\nPainted(x, y) ::: x is painted by y.\nScientist(x) ::: x is a scientist.\nPainter(x) ::: x is a painter.\nGenre(x) ::: x is a painting genre.\nHistory(x) ::: x is a history genre.\nPortrait(x) ::: x is a portrait genre.\nAnimal(x) ::: x is an animal genre.\nLandscape(x) ::: x is a landscape genre.\nStillLife(x) ::: x is a still life genre.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nArtwork(monaLisa) ∧ BestKnown(monaLisa) ::: The Mona Lisa is one of the world's best-known artworks.\nPortrait(monaLisa) ∧ Painted(monaLisa, leonardo) ::: The Mona Lisa is a portrait painted by Leonardo da Vinci.\nScientist(leonardo) ∧ Painter(leonardo) ::: Leonardo da Vinci was a scientist and painter.\nGenre(history) ∧ Genre(portrait) ∧ Genre(animal) ∧ Genre(landscape) ∧ Genre(stillLife) ::: Painting genres are history, portrait, animal, landscape, and still life.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n∃x (Artwork(x) ∧ BestKnown(x) ∧ Painted(x, scientist)) ::: One of the world's best-known artworks is painted by a scientist.\n\"\"\""
    ]
  },
  {
    "id": 492,
    "context": [
      "The Mona Lisa is one of the world's best-known artworks.",
      "The Mona Lisa is a portrait painted by Leonardo da Vinci.",
      "Leonardo da Vinci was a scientist and painter.",
      "Painting genres are history, portrait, animal, landscape, and still life."
    ],
    "question": "Leonardo da Vinci has artworks in the landscape genre.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nArtwork(x) ::: x is an artwork.\nKnown(x) ::: x is one of the world's best-known artworks.\nPortrait(x) ::: x is a portrait.\nPainted(x, y) ::: x is painted by y.\nPainter(x) ::: x is a painter.\nScientist(x) ::: x is a scientist.\nGenre(x) ::: x is a painting genre.\nHistory(x) ::: x is a history genre.\nAnimal(x) ::: x is an animal genre.\nLandscape(x) ::: x is a landscape genre.\nStillLife(x) ::: x is a still life genre.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nArtwork(monaLisa) ∧ Known(monaLisa) ::: The Mona Lisa is one of the world's best-known artworks.\nPortrait(monaLisa) ∧ Painted(monaLisa, leonardo) ::: The Mona Lisa is a portrait painted by Leonardo da Vinci.\nScientist(leonardo) ∧ Painter(leonardo) ::: Leonardo da Vinci was a scientist and painter.\nGenre(history) ∧ Genre(portrait) ∧ Genre(animal) ∧ Genre(landscape) ∧ Genre(stillLife) ::: Painting genres are history, portrait, animal, landscape, and still life.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n∃x (Artwork(x) ∧ Painted(x, leonardo) ∧ Genre(landscape)) ::: Leonardo da Vinci has artworks in the landscape genre.\n\"\"\""
    ]
  },
  {
    "id": 493,
    "context": [
      "The Mona Lisa is one of the world's best-known artworks.",
      "The Mona Lisa is a portrait painted by Leonardo da Vinci.",
      "Leonardo da Vinci was a scientist and painter.",
      "Painting genres are history, portrait, animal, landscape, and still life."
    ],
    "question": "No world's best-known artworks are portraits.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nArtwork(x) ::: x is an artwork.\nKnown(x) ::: x is known.\nPortrait(x) ::: x is a portrait.\nPainted(x, y) ::: x is painted by y.\nPerson(x) ::: x is a person.\nScientist(x) ::: x is a scientist.\nPainter(x) ::: x is a painter.\nGenre(x) ::: x is a painting genre.\nHistory(x) ::: x is history genre.\nAnimal(x) ::: x is animal genre.\nLandscape(x) ::: x is landscape genre.\nStillLife(x) ::: x is still life genre.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nArtwork(monaLisa) ∧ Known(monaLisa) ::: The Mona Lisa is one of the world's best-known artworks.\nPortrait(monaLisa) ∧ Painted(monaLisa, leonardoDaVinci) ::: The Mona Lisa is a portrait painted by Leonardo da Vinci.\nScientist(leonardoDaVinci) ∧ Painter(leonardoDaVinci) ::: Leonardo da Vinci was a scientist and painter.\nGenre(history) ∧ Genre(portrait) ∧ Genre(animal) ∧ Genre(landscape) ∧ Genre(stillLife) ::: Painting genres are history, portrait, animal, landscape, and still life.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬∃x (Artwork(x) ∧ Known(x) ∧ Portrait(x)) ::: No world's best-known artworks are portraits.\n\"\"\""
    ]
  },
  {
    "id": 892,
    "context": [
      "No professional tennis umpires are professional tennis players.",
      "If you are a World Tour player, then you are a professional tennis player.",
      "All Grand Slam champions are World Tour players.",
      "All Grand Slam umpires are professional tennis umpires.",
      "Nadal is a World Tour player or a Grand Slam champion"
    ],
    "question": "Nadal is a Grand Slam umpire.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nUmpire(x) ::: x is a professional tennis umpire.\nPlayer(x) ::: x is a professional tennis player.\nWorldTour(x) ::: x is a World Tour player.\nChampion(x) ::: x is a Grand Slam champion.\nNadal ::: Nadal is a specific person.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Umpire(x) → ¬Player(x)) ::: No professional tennis umpires are professional tennis players.\n∀x (WorldTour(x) → Player(x)) ::: If you are a World Tour player, then you are a professional tennis player.\n∀x (Champion(x) → WorldTour(x)) ::: All Grand Slam champions are World Tour players.\n∀x (Umpire(x) → Player(x)) ::: All Grand Slam umpires are professional tennis umpires.\n(WorldTour(nadal) ∨ Champion(nadal)) ::: Nadal is a World Tour player or a Grand Slam champion.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nUmpire(nadal) ::: Nadal is a Grand Slam umpire.\n\"\"\""
    ]
  },
  {
    "id": 893,
    "context": [
      "No professional tennis umpires are professional tennis players.",
      "If you are a World Tour player, then you are a professional tennis player.",
      "All Grand Slam champions are World Tour players.",
      "All Grand Slam umpires are professional tennis umpires.",
      "Nadal is a World Tour player or a Grand Slam champion"
    ],
    "question": "Nadal is not a Grand Slam umpire.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nUmpire(x) ::: x is a professional tennis umpire.\nPlayer(x) ::: x is a professional tennis player.\nWorldTour(x) ::: x is a World Tour player.\nChampion(x) ::: x is a Grand Slam champion.\nGrandSlamUmpire(x) ::: x is a Grand Slam umpire.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Umpire(x) → ¬Player(x)) ::: No professional tennis umpires are professional tennis players.\n∀x (WorldTour(x) → Player(x)) ::: If you are a World Tour player, then you are a professional tennis player.\n∀x (Champion(x) → WorldTour(x)) ::: All Grand Slam champions are World Tour players.\n∀x (GrandSlamUmpire(x) → Umpire(x)) ::: All Grand Slam umpires are professional tennis umpires.\n(WorldTour(nadal) ∨ Champion(nadal)) ::: Nadal is a World Tour player or a Grand Slam champion.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬GrandSlamUmpire(nadal) ::: Nadal is not a Grand Slam umpire.\n\"\"\""
    ]
  },
  {
    "id": 894,
    "context": [
      "No professional tennis umpires are professional tennis players.",
      "If you are a World Tour player, then you are a professional tennis player.",
      "All Grand Slam champions are World Tour players.",
      "All Grand Slam umpires are professional tennis umpires.",
      "Nadal is a World Tour player or a Grand Slam champion"
    ],
    "question": "Nadal is a Grand Slam champion.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nUmpire(x) ::: x is a professional tennis umpire.\nPlayer(x) ::: x is a professional tennis player.\nWorldTourPlayer(x) ::: x is a World Tour player.\nGrandSlamChampion(x) ::: x is a Grand Slam champion.\nNadal(x) ::: x is Nadal.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Umpire(x) → ¬Player(x)) ::: No professional tennis umpires are professional tennis players.\n∀x (WorldTourPlayer(x) → Player(x)) ::: If you are a World Tour player, then you are a professional tennis player.\n∀x (GrandSlamChampion(x) → WorldTourPlayer(x)) ::: All Grand Slam champions are World Tour players.\n∀x (GrandSlamUmpire(x) → Umpire(x)) ::: All Grand Slam umpires are professional tennis umpires.\n(WorldTourPlayer(nadal) ∨ GrandSlamChampion(nadal)) ::: Nadal is a World Tour player or a Grand Slam champion.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nGrandSlamChampion(nadal) ::: Nadal is a Grand Slam champion.\n\"\"\""
    ]
  },
  {
    "id": 895,
    "context": [
      "No professional tennis umpires are professional tennis players.",
      "If you are a World Tour player, then you are a professional tennis player.",
      "All Grand Slam champions are World Tour players.",
      "All Grand Slam umpires are professional tennis umpires.",
      "Nadal is a World Tour player or a Grand Slam champion"
    ],
    "question": "Nadal is neither a Grand Slam umpire nor a professional tennis umpire.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nUmpire(x) ::: x is a professional tennis umpire.\nPlayer(x) ::: x is a professional tennis player.\nWorldTourPlayer(x) ::: x is a World Tour player.\nGrandSlamChampion(x) ::: x is a Grand Slam champion.\nGrandSlamUmpire(x) ::: x is a Grand Slam umpire.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Umpire(x) → ¬Player(x)) ::: No professional tennis umpires are professional tennis players.\n∀x (WorldTourPlayer(x) → Player(x)) ::: If you are a World Tour player, then you are a professional tennis player.\n∀x (GrandSlamChampion(x) → WorldTourPlayer(x)) ::: All Grand Slam champions are World Tour players.\n∀x (GrandSlamUmpire(x) → Umpire(x)) ::: All Grand Slam umpires are professional tennis umpires.\n(WorldTourPlayer(nadal) ∨ GrandSlamChampion(nadal)) ::: Nadal is a World Tour player or a Grand Slam champion.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬(GrandSlamUmpire(nadal) ∨ Umpire(nadal)) ::: Nadal is neither a Grand Slam umpire nor a professional tennis umpire.\n\"\"\""
    ]
  },
  {
    "id": 896,
    "context": [
      "No professional tennis umpires are professional tennis players.",
      "If you are a World Tour player, then you are a professional tennis player.",
      "All Grand Slam champions are World Tour players.",
      "All Grand Slam umpires are professional tennis umpires.",
      "Nadal is a World Tour player or a Grand Slam champion"
    ],
    "question": "If Nadal is a professional tennis umpire, then Nadal is a Grand Slam Umpire.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nUmpire(x) ::: x is a professional tennis umpire.\nPlayer(x) ::: x is a professional tennis player.\nWorldTour(x) ::: x is a World Tour player.\nChampion(x) ::: x is a Grand Slam champion.\nGrandSlamUmpire(x) ::: x is a Grand Slam umpire.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Umpire(x) → ¬Player(x)) ::: No professional tennis umpires are professional tennis players.\n∀x (WorldTour(x) → Player(x)) ::: If you are a World Tour player, then you are a professional tennis player.\n∀x (Champion(x) → WorldTour(x)) ::: All Grand Slam champions are World Tour players.\n∀x (GrandSlamUmpire(x) → Umpire(x)) ::: All Grand Slam umpires are professional tennis umpires.\n(WorldTour(nadal) ∨ Champion(nadal)) ::: Nadal is a World Tour player or a Grand Slam champion.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n(WorldTour(nadal) → GrandSlamUmpire(nadal)) ::: If Nadal is a professional tennis umpire, then Nadal is a Grand Slam Umpire.\n\"\"\""
    ]
  },
  {
    "id": 897,
    "context": [
      "No professional tennis umpires are professional tennis players.",
      "If you are a World Tour player, then you are a professional tennis player.",
      "All Grand Slam champions are World Tour players.",
      "All Grand Slam umpires are professional tennis umpires.",
      "Nadal is a World Tour player or a Grand Slam champion"
    ],
    "question": "If Nadal is a Grand Slam umpire or a professional tennis player, then Nadal is a Grand Slam umpire.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nUmpire(x) ::: x is a professional tennis umpire.\nPlayer(x) ::: x is a professional tennis player.\nWorldTourPlayer(x) ::: x is a World Tour player.\nGrandSlamChampion(x) ::: x is a Grand Slam champion.\nGrandSlamUmpire(x) ::: x is a Grand Slam umpire.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Umpire(x) → ¬Player(x)) ::: No professional tennis umpires are professional tennis players.\n∀x (WorldTourPlayer(x) → Player(x)) ::: If you are a World Tour player, then you are a professional tennis player.\n∀x (GrandSlamChampion(x) → WorldTourPlayer(x)) ::: All Grand Slam champions are World Tour players.\n∀x (GrandSlamUmpire(x) → Umpire(x)) ::: All Grand Slam umpires are professional tennis umpires.\n(WorldTourPlayer(nadal) ∨ GrandSlamChampion(nadal)) ::: Nadal is a World Tour player or a Grand Slam champion.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n(GrandSlamUmpire(nadal) ∨ Player(nadal)) → GrandSlamUmpire(nadal) ::: If Nadal is a Grand Slam umpire or a professional tennis player, then Nadal is a Grand Slam umpire.\n\"\"\""
    ]
  },
  {
    "id": 368,
    "context": [
      "Buisnesses are either sanctioned or unsanctioned.",
      "Sanctioned buisnesses are limited.",
      "Unsanctioned buisnesses are free.",
      "The Crude Oil Data Exchange is a buisness that isn't free."
    ],
    "question": "Crude Oil Data Exchange is sanctioned.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nBusiness(x) ::: x is a business.\nSanctioned(x) ::: x is sanctioned.\nUnsanctioned(x) ::: x is unsanctioned.\nLimited(x) ::: x is limited.\nFree(x) ::: x is free.\nCrudeOilDataExchange(x) ::: x is the Crude Oil Data Exchange.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Business(x) → (Sanctioned(x) ∨ Unsanctioned(x))) ::: Businesses are either sanctioned or unsanctioned.\n∀x (Sanctioned(x) → Limited(x)) ::: Sanctioned businesses are limited.\n∀x (Unsanctioned(x) → Free(x)) ::: Unsanctioned businesses are free.\nCrudeOilDataExchange(crudeOilDataExchange) ∧ ¬Free(crudeOilDataExchange) ::: The Crude Oil Data Exchange is a business that isn't free.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nSanctioned(crudeOilDataExchange) ::: Crude Oil Data Exchange is sanctioned.\n\"\"\""
    ]
  },
  {
    "id": 369,
    "context": [
      "Buisnesses are either sanctioned or unsanctioned.",
      "Sanctioned buisnesses are limited.",
      "Unsanctioned buisnesses are free.",
      "The Crude Oil Data Exchange is a buisness that isn't free."
    ],
    "question": "Crude Oil Data Exchange is unsanctioned.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nBusiness(x) ::: x is a business.\nSanctioned(x) ::: x is sanctioned.\nUnsanctioned(x) ::: x is unsanctioned.\nLimited(x) ::: x is limited.\nFree(x) ::: x is free.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Business(x) → (Sanctioned(x) ∨ Unsanctioned(x))) ::: Businesses are either sanctioned or unsanctioned.\n∀x (Sanctioned(x) → Limited(x)) ::: Sanctioned businesses are limited.\n∀x (Unsanctioned(x) → Free(x)) ::: Unsanctioned businesses are free.\nBusiness(crudeOilDataExchange) ∧ ¬Free(crudeOilDataExchange) ::: The Crude Oil Data Exchange is a business that isn't free.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nUnsanctioned(crudeOilDataExchange) ::: Crude Oil Data Exchange is unsanctioned.\n\"\"\""
    ]
  },
  {
    "id": 370,
    "context": [
      "Buisnesses are either sanctioned or unsanctioned.",
      "Sanctioned buisnesses are limited.",
      "Unsanctioned buisnesses are free.",
      "The Crude Oil Data Exchange is a buisness that isn't free."
    ],
    "question": "Crude Oil Data Exchange is limited.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nSanctioned(x) ::: x is a sanctioned business.\nUnsanctioned(x) ::: x is an unsanctioned business.\nLimited(x) ::: x is limited.\nFree(x) ::: x is free.\nCrudeOilDataExchange(x) ::: x is the Crude Oil Data Exchange business.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Sanctioned(x) ∨ Unsanctioned(x)) ::: Businesses are either sanctioned or unsanctioned.\n∀x (Sanctioned(x) → Limited(x)) ::: Sanctioned businesses are limited.\n∀x (Unsanctioned(x) → Free(x)) ::: Unsanctioned businesses are free.\nCrudeOilDataExchange(crudeOilDataExchange) ∧ ¬Free(crudeOilDataExchange) ::: The Crude Oil Data Exchange is a business that isn't free.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nLimited(crudeOilDataExchange) ::: Crude Oil Data Exchange is limited.\n\"\"\""
    ]
  },
  {
    "id": 750,
    "context": [
      "When something is depressing, it is sad.",
      "V is depressing. "
    ],
    "question": "V is invigorating",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nDepressing(x) ::: x is depressing.\nSad(x) ::: x is sad.\nInvigorating(x) ::: x is invigorating.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Depressing(x) → Sad(x)) ::: When something is depressing, it is sad.\nDepressing(v) ::: V is depressing.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬Invigorating(v) ::: V is not invigorating.\n\"\"\""
    ]
  },
  {
    "id": 314,
    "context": [
      "Palstaves are a type of early bronze axe.",
      "Commonly found in northern, western and south-western Europe, palstaves are cast in moulds.",
      "John Evans is an archeologist who popularized the term \"palstave\".",
      "A paalstab is not an axe, but rather a digging shovel."
    ],
    "question": "John Evans Popularized the term paalstab.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nTypeOf(x, y) ::: x is a type of y.\nFoundIn(x, y) ::: x is commonly found in y.\nCastIn(x, y) ::: x is cast in y.\nPerson(x) ::: x is a person.\nArcheologist(x) ::: x is an archeologist.\nPopularize(x, y) ::: x popularized the term y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nTypeOf(palstaves, earlyBronzeAxe) ::: Palstaves are a type of early bronze axe.\nFoundIn(palstaves, northernEurope) ∧ FoundIn(palstaves, westernEurope) ∧ FoundIn(palstaves, southwesternEurope) ∧ CastIn(palstaves, moulds) ::: Commonly found in northern, western and south-western Europe, palstaves are cast in moulds.\nPerson(johnEvans) ∧ Archeologist(johnEvans) ∧ Popularize(johnEvans, palstave) ::: John Evans is an archeologist who popularized the term \"palstave\".\n¬TypeOf(paalstab, axe) ∧ TypeOf(paalstab, diggingShovel) ::: A paalstab is not an axe, but rather a digging shovel.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nPopularize(johnEvans, paalstab) ::: John Evans Popularized the term paalstab.\n\"\"\""
    ]
  },
  {
    "id": 315,
    "context": [
      "Palstaves are a type of early bronze axe.",
      "Commonly found in northern, western and south-western Europe, palstaves are cast in moulds.",
      "John Evans is an archeologist who popularized the term \"palstave\".",
      "A paalstab is not an axe, but rather a digging shovel."
    ],
    "question": "There is an axe that is commonly found in Western Europe.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nAxe(x) ::: x is an axe.\nBronze(x) ::: x is made of bronze.\nFoundIn(x, y) ::: x is commonly found in region y.\nCastInMoulds(x) ::: x is cast in moulds.\nArcheologist(x) ::: x is an archeologist.\nPopularize(x, y) ::: x popularized the term y.\nShovel(x) ::: x is a digging shovel.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Palstave(x) → Bronze(x) ∧ Axe(x)) ::: Palstaves are a type of early bronze axe.\n∀x (Palstave(x) ∧ FoundIn(x, northern) ∨ FoundIn(x, western) ∨ FoundIn(x, south-western) → CastInMoulds(x)) ::: Commonly found in northern, western and south-western Europe, palstaves are cast in moulds.\nArcheologist(johnEvans) ∧ Popularize(johnEvans, palstave) ::: John Evans is an archeologist who popularized the term \"palstave\".\n∀x (Paalstab(x) → ¬Axe(x) ∧ Shovel(x)) ::: A paalstab is not an axe, but rather a digging shovel.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n∃x (Axe(x) ∧ FoundIn(x, western)) ::: There is an axe that is commonly found in Western Europe.\n\"\"\""
    ]
  },
  {
    "id": 316,
    "context": [
      "Palstaves are a type of early bronze axe.",
      "Commonly found in northern, western and south-western Europe, palstaves are cast in moulds.",
      "John Evans is an archeologist who popularized the term \"palstave\".",
      "A paalstab is not an axe, but rather a digging shovel."
    ],
    "question": "Archeologists haven't popularized anything.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nTypeOf(x, y) ::: x is a type of y.\nFoundIn(x, y) ::: x is commonly found in y.\nCastIn(x, y) ::: x is cast in y.\nArcheologist(x) ::: x is an archeologist.\nPopularize(x, y) ::: x popularized the term y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nTypeOf(palstaves, earlyBronzeAxe) ::: Palstaves are a type of early bronze axe.\nFoundIn(palstaves, northern) ∧ FoundIn(palstaves, western) ∧ FoundIn(palstaves, southwesternEurope) ∧ CastIn(palstaves, moulds) ::: Commonly found in northern, western and south-western Europe, palstaves are cast in moulds.\nArcheologist(johnEvans) ∧ Popularize(johnEvans, palstave) ::: John Evans is an archeologist who popularized the term \"palstave\".\n¬TypeOf(paalstab, axe) ∧ TypeOf(paalstab, diggingShovel) ::: A paalstab is not an axe, but rather a digging shovel.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬∃x (Archeologist(x) ∧ ∃y (Popularize(x, y))) ::: Archeologists haven't popularized anything.\n\"\"\""
    ]
  },
  {
    "id": 274,
    "context": [
      "Koei Tecmo is a Japanese video game and anime holding company.",
      "Holding companies hold several companies.",
      "Tecmo was disbanded in Japan, while Koei survived, but was renamed.",
      "Video game holding companies are holding companies."
    ],
    "question": "Koei Tecmo holds another company.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nJapanese(x) ::: x is Japanese.\nCompany(x) ::: x is a company.\nVideoGame(x) ::: x is a video game.\nAnime(x) ::: x is an anime.\nHoldingCompany(x) ::: x is a holding company.\nHold(x, y) ::: x holds y.\nDisbanded(x) ::: x was disbanded.\nRenamed(x) ::: x was renamed.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nJapanese(koeiTecmo) ∧ Company(koeiTecmo) ∧ VideoGame(koeiTecmo) ∧ Anime(koeiTecmo) ::: Koei Tecmo is a Japanese video game and anime holding company.\n∀x (HoldingCompany(x) → ∃y (Company(y) ∧ Hold(x, y))) ::: Holding companies hold several companies.\nDisbanded(tecmo) ∧ Japanese(tecmmo) ∧ Company(tecmo) ::: Tecmo was disbanded in Japan.\nSurvived(koei) ∧ Japanese(koei) ∧ Company(koei) ∧ Renamed(koei) ::: Koei survived, but was renamed.\n∀x (VideoGame(x) → HoldingCompany(x)) ::: Video game holding companies are holding companies.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n∃x (Company(x) ∧ Hold(koeiTecmo, x)) ::: Koei Tecmo holds another company.\n\"\"\""
    ]
  },
  {
    "id": 275,
    "context": [
      "Koei Tecmo is a Japanese video game and anime holding company.",
      "Holding companies hold several companies.",
      "Tecmo was disbanded in Japan, while Koei survived, but was renamed.",
      "Video game holding companies are holding companies."
    ],
    "question": "Tecmo holds another company.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nJapanese(x) ::: x is Japanese.\nCompany(x) ::: x is a company.\nVideoGame(x) ::: x is a video game.\nAnime(x) ::: x is an anime.\nHoldingCompany(x) ::: x is a holding company.\nHold(x, y) ::: x holds y.\nDisbanded(x) ::: x was disbanded.\nRenamed(x) ::: x was renamed.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nJapanese(koeiTecmo) ∧ Company(koeiTecmo) ∧ VideoGame(koeiTecmo) ∧ Anime(koeiTecmo) ∧ HoldingCompany(koeiTecmo) ::: Koei Tecmo is a Japanese video game and anime holding company.\n∀x (HoldingCompany(x) → ∃y Company(y) ∧ Hold(x, y)) ::: Holding companies hold several companies.\nDisbanded(tecmo) ∧ Japanese(tecmmo) ∧ Company(tecmo) ::: Tecmo was disbanded in Japan.\nSurvived(koei) ∧ Japanese(koei) ∧ Company(koei) ∧ Renamed(koei) ::: Koei survived, but was renamed.\n∀x (VideoGame(x) → HoldingCompany(x)) ::: Video game holding companies are holding companies.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n∃y (Company(y) ∧ Hold(tecmo, y)) ::: Tecmo holds another company.\n\"\"\""
    ]
  },
  {
    "id": 276,
    "context": [
      "Koei Tecmo is a Japanese video game and anime holding company.",
      "Holding companies hold several companies.",
      "Tecmo was disbanded in Japan, while Koei survived, but was renamed.",
      "Video game holding companies are holding companies."
    ],
    "question": "Koei Tecmo holds anime.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nJapanese(x) ::: x is Japanese.\nCompany(x) ::: x is a company.\nVideoGame(x) ::: x is a video game.\nAnime(x) ::: x is an anime.\nHoldingCompany(x) ::: x is a holding company.\nHold(x, y) ::: x holds y.\nDisbanded(x) ::: x was disbanded.\nRenamed(x) ::: x was renamed.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nJapanese(koeiTecmo) ∧ Company(koeiTecmo) ∧ VideoGame(koeiTecmo) ∧ Anime(koeiTecmo) ::: Koei Tecmo is a Japanese video game and anime holding company.\n∀x (HoldingCompany(x) → ∃y Company(y) ∧ Hold(x, y)) ::: Holding companies hold several companies.\nDisbanded(tecmo) ∧ Japanese(tecmmo) ∧ Company(tecmo) ::: Tecmo was disbanded in Japan.\nSurvived(koei) ∧ Japanese(koei) ∧ Company(koei) ∧ Renamed(koei) ::: Koei survived, but was renamed.\n∀x (VideoGame(x) → HoldingCompany(x)) ::: Video game holding companies are holding companies.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nHold(koeiTecmo, anime) ::: Koei Tecmo holds anime.\n\"\"\""
    ]
  },
  {
    "id": 570,
    "context": [
      "The PlayStation EyeToy is a camera accessory for the Playstation 2. ",
      "The PlayStation Eye is a camera accessory for the Playstation 3.",
      "The Playstation Camera is a camera accessory for the Playstation 4 and the Playstation 5.",
      "Camera accessory for the system is compatible with that system",
      "Only the Playstation Camera is compatible with more than one system."
    ],
    "question": "The Playstation Eye can be used with the Playstation 2 and the Playstation 3.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nAccessory(x, y) ::: x is a camera accessory for the system y.\nCompatible(x, y) ::: x is compatible with system y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nAccessory(PlayStationEyeToy, PlayStation2) ::: The PlayStation EyeToy is a camera accessory for the Playstation 2.\nAccessory(PlayStationEye, PlayStation3) ::: The PlayStation Eye is a camera accessory for the Playstation 3.\nAccessory(PlaystationCamera, PlayStation4) ∧ Accessory(PlaystationCamera, PlayStation5) ::: The Playstation Camera is a camera accessory for the Playstation 4 and the Playstation 5.\n∀x (Accessory(x, y) → Compatible(x, y)) ::: Camera accessory for the system is compatible with that system.\n∀x (Accessory(x, PlayStation2) ∧ Accessory(x, PlayStation3) → x = PlayStationEye) ::: Only the Playstation Camera is compatible with more than one system.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nCompatible(PlayStationEye, PlayStation2) ∧ Compatible(PlayStationEye, PlayStation3) ::: The Playstation Eye can be used with the Playstation 2 and the Playstation 3.\n\"\"\""
    ]
  },
  {
    "id": 571,
    "context": [
      "The PlayStation EyeToy is a camera accessory for the Playstation 2. ",
      "The PlayStation Eye is a camera accessory for the Playstation 3.",
      "The Playstation Camera is a camera accessory for the Playstation 4 and the Playstation 5.",
      "Camera accessory for the system is compatible with that system",
      "Only the Playstation Camera is compatible with more than one system."
    ],
    "question": "The Playstation EyeToy is compatible with the Playstation 2.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nAccessory(x, y) ::: x is a camera accessory for the system y.\nCompatible(x, y) ::: x is compatible with system y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nAccessory(eyeToy, playstation2) ::: The PlayStation EyeToy is a camera accessory for the Playstation 2.\nAccessory(eye, playstation3) ::: The PlayStation Eye is a camera accessory for the Playstation 3.\nAccessory(camera, playstation4) ∧ Accessory(camera, playstation5) ::: The Playstation Camera is a camera accessory for the Playstation 4 and the Playstation 5.\n∀x (Accessory(x, y) → Compatible(x, y)) ::: Camera accessory for the system is compatible with that system.\n∀x (Accessory(x, playstation4) ∧ Accessory(x, playstation5) → x = camera) ::: Only the Playstation Camera is compatible with more than one system.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nCompatible(eyeToy, playstation2) ::: The Playstation EyeToy is compatible with the Playstation 2.\n\"\"\""
    ]
  },
  {
    "id": 572,
    "context": [
      "The PlayStation EyeToy is a camera accessory for the Playstation 2. ",
      "The PlayStation Eye is a camera accessory for the Playstation 3.",
      "The Playstation Camera is a camera accessory for the Playstation 4 and the Playstation 5.",
      "Camera accessory for the system is compatible with that system",
      "Only the Playstation Camera is compatible with more than one system."
    ],
    "question": "The Playstation Camera can be used for all Playstation consoles.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nEyeToy(x) ::: x is a PlayStation EyeToy.\nEye(x) ::: x is a PlayStation Eye.\nCamera(x) ::: x is a Playstation Camera.\nCompatible(x, y) ::: x is compatible with y.\nSystem(x) ::: x is a Playstation system.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nEyeToy(playstation2) ∧ Camera(playstation2) ∧ Compatible(playstation2, playstation2) ::: The PlayStation EyeToy is a camera accessory for the Playstation 2.\nEye(playstation3) ∧ Camera(playstation3) ∧ Compatible(playstation3, playstation3) ::: The PlayStation Eye is a camera accessory for the Playstation 3.\nCamera(playstation4) ∧ Camera(playstation5) ∧ Compatible(playstation4, playstation4) ∧ Compatible(playstation5, playstation5) ::: The Playstation Camera is a camera accessory for the Playstation 4 and the Playstation 5.\n∀x (Camera(x) → Compatible(x, x)) ::: Camera accessory for the system is compatible with that system.\n∀x (Camera(x) ↔ (Compatible(x, system1) ∧ Compatible(x, system2) ∧ ¬(system1 = system2))) ::: Only the Playstation Camera is compatible with more than one system.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n∀x (Camera(x) → (Compatible(x, playstation2) ∧ Compatible(x, playstation3) ∧ Compatible(x, playstation4) ∧ Compatible(x, playstation5))) ::: The Playstation Camera can be used for all Playstation consoles.\n\"\"\""
    ]
  },
  {
    "id": 723,
    "context": [
      "Adam Buska is a European football player.",
      "If a European plays football, they play what Americans call soccer."
    ],
    "question": "Adam Buska plays what Americans call soccer.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nEuropean(x) ::: x is a European person.\nFootballPlayer(x) ::: x is a football player.\nPlay(x, y) ::: x plays y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nEuropean(adam) ∧ FootballPlayer(adam) ::: Adam Buska is a European football player.\n∀x (European(x) ∧ FootballPlayer(x) → Play(x, soccer)) ::: If a European plays football, they play what Americans call soccer.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nPlay(adam, soccer) ::: Adam Buska plays what Americans call soccer.\n\"\"\""
    ]
  },
  {
    "id": 1157,
    "context": [
      "If the game has sold more than 1 million copies, then it is on the Best Seller list. ",
      "All Games developed by Paradox Development Studio sold more than 1 million copies. ",
      "Some games published before 2010 support the Linux OS system. ",
      "All games on the Best Seller list are popular among young people. ",
      "FIFA22 neither supports the Linux OS system nor is it popular among young people."
    ],
    "question": "FIFA21 is published before 2010",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nSoldMoreThan1Million(x) ::: x has sold more than 1 million copies.\nOnBestSellerList(x) ::: x is on the Best Seller list.\nDevelopedByParadox(x) ::: x is developed by Paradox Development Studio.\nSupportsLinux(x) ::: x supports the Linux OS system.\nPopularAmongYoung(x) ::: x is popular among young people.\nPublishedBefore2010(x) ::: x is published before 2010.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (SoldMoreThan1Million(x) → OnBestSellerList(x)) ::: If the game has sold more than 1 million copies, then it is on the Best Seller list.\n∀x (DevelopedByParadox(x) → SoldMoreThan1Million(x)) ::: All Games developed by Paradox Development Studio sold more than 1 million copies.\n∃x (PublishedBefore2010(x) ∧ SupportsLinux(x)) ::: Some games published before 2010 support the Linux OS system.\n∀x (OnBestSellerList(x) → PopularAmongYoung(x)) ::: All games on the Best Seller list are popular among young people.\n¬(SupportsLinux(fifa22) ∨ PopularAmongYoung(fifa22)) ::: FIFA22 neither supports the Linux OS system nor is it popular among young people.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nPublishedBefore2010(fifa21) ::: FIFA21 is published before 2010.\n\"\"\""
    ]
  },
  {
    "id": 1158,
    "context": [
      "If the game has sold more than 1 million copies, then it is on the Best Seller list. ",
      "All Games developed by Paradox Development Studio sold more than 1 million copies. ",
      "Some games published before 2010 support the Linux OS system. ",
      "All games on the Best Seller list are popular among young people. ",
      "FIFA22 neither supports the Linux OS system nor is it popular among young people."
    ],
    "question": "FIFA21 is published before 2010 and developed by Paradox Development Studio",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nSoldMoreThan1Million(x) ::: x has sold more than 1 million copies.\nOnBestSellerList(x) ::: x is on the Best Seller list.\nDevelopedByParadox(x) ::: x is developed by Paradox Development Studio.\nSupportsLinux(x) ::: x supports the Linux OS system.\nPublishedBefore2010(x) ::: x is published before 2010.\nPopularAmongYoung(x) ::: x is popular among young people.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nSoldMoreThan1Million(x) → OnBestSellerList(x) ::: If the game has sold more than 1 million copies, then it is on the Best Seller list.\n∀x (DevelopedByParadox(x) → SoldMoreThan1Million(x)) ::: All Games developed by Paradox Development Studio sold more than 1 million copies.\n∃x (PublishedBefore2010(x) ∧ SupportsLinux(x)) ::: Some games published before 2010 support the Linux OS system.\n∀x (OnBestSellerList(x) → PopularAmongYoung(x)) ::: All games on the Best Seller list are popular among young people.\n¬(SupportsLinux(fifa22) ∨ PopularAmongYoung(fifa22)) ::: FIFA22 neither supports the Linux OS system nor is it popular among young people.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nPublishedBefore2010(fifa21) ∧ DevelopedByParadox(fifa21) ::: FIFA21 is published before 2010 and developed by Paradox Development Studio.\n\"\"\""
    ]
  },
  {
    "id": 1159,
    "context": [
      "If the game has sold more than 1 million copies, then it is on the Best Seller list. ",
      "All Games developed by Paradox Development Studio sold more than 1 million copies. ",
      "Some games published before 2010 support the Linux OS system. ",
      "All games on the Best Seller list are popular among young people. ",
      "FIFA22 neither supports the Linux OS system nor is it popular among young people."
    ],
    "question": "if FIFA21 is either a game published before 2010 or developed by Paradox Development Studio, then it is either in the Best Seller list and sold more than 1 million copies; or not in the Best Seller list and hasn't sold more than 1 million copies.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nSoldMoreThan1Million(x) ::: x has sold more than 1 million copies.\nBestSeller(x) ::: x is on the Best Seller list.\nDevelopedByParadox(x) ::: x is developed by Paradox Development Studio.\nSupportsLinux(x) ::: x supports the Linux OS system.\nPopularAmongYoung(x) ::: x is popular among young people.\nPublishedBefore2010(x) ::: x is published before 2010.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (SoldMoreThan1Million(x) → BestSeller(x)) ::: If the game has sold more than 1 million copies, then it is on the Best Seller list.\n∀x (DevelopedByParadox(x) → SoldMoreThan1Million(x)) ::: All Games developed by Paradox Development Studio sold more than 1 million copies.\n∃x (PublishedBefore2010(x) ∧ SupportsLinux(x)) ::: Some games published before 2010 support the Linux OS system.\n∀x (BestSeller(x) → PopularAmongYoung(x)) ::: All games on the Best Seller list are popular among young people.\n¬(SupportsLinux(fifa22) ∨ PopularAmongYoung(fifa22)) ::: FIFA22 neither supports the Linux OS system nor is it popular among young people.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n((PublishedBefore2010(fifa21) ∨ DevelopedByParadox(fifa21)) → ((BestSeller(fifa21) ∧ SoldMoreThan1Million(fifa21)) ∨ (¬BestSeller(fifa21) ∧ ¬SoldMoreThan1Million(fifa21)))) ::: if FIFA21 is either a game published before 2010 or developed by Paradox Development Studio, then it is either in the Best Seller list and sold more than 1 million copies; or not in the Best Seller list and hasn't sold more than 1 million copies.\n\"\"\""
    ]
  },
  {
    "id": 593,
    "context": [
      "China is one of BRICS and its economy is emerging.",
      "India is one of BRICS and its economy is emerging.",
      "All people from China speak Chinese.",
      "All people from India speak Hindi or English.",
      "There is an Indian."
    ],
    "question": "All people from BRICS neither speak Hindi nor speak English.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nBRICS(x) ::: x is a country in BRICS.\nEmerging(x) ::: the economy of x is emerging.\nSpeak(x, y) ::: x speaks language y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nBRICS(china) ∧ Emerging(china) ::: China is one of BRICS and its economy is emerging.\nBRICS(india) ∧ Emerging(india) ::: India is one of BRICS and its economy is emerging.\n∀x (BRICS(x) → Speak(x, chinese)) ::: All people from China speak Chinese.\n∀x (BRICS(x) → (Speak(x, hindi) ∨ Speak(x, english))) ::: All people from India speak Hindi or English.\n∃x Indian(x) ::: There is an Indian.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n∀x (BRICS(x) → ¬(Speak(x, hindi) ∨ Speak(x, english))) ::: All people from BRICS neither speak Hindi nor speak English.\n\"\"\""
    ]
  },
  {
    "id": 594,
    "context": [
      "China is one of BRICS and its economy is emerging.",
      "India is one of BRICS and its economy is emerging.",
      "All people from China speak Chinese.",
      "All people from India speak Hindi or English.",
      "There is an Indian."
    ],
    "question": "India's economy is not emerging.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nBRICS(x) ::: x is one of BRICS countries.\nEmerging(x) ::: the economy of x is emerging.\nSpeak(x, y) ::: x speaks language y.\nFrom(x, y) ::: x is from country y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nBRICS(china) ∧ Emerging(china) ::: China is one of BRICS and its economy is emerging.\nBRICS(india) ∧ Emerging(india) ::: India is one of BRICS and its economy is emerging.\n∀x (From(x, china) → Speak(x, chinese)) ::: All people from China speak Chinese.\n∀x (From(x, india) → (Speak(x, hindi) ∨ Speak(x, english))) ::: All people from India speak Hindi or English.\n∃x From(x, india) ::: There is an Indian.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬Emerging(india) ::: India's economy is not emerging.\n\"\"\""
    ]
  },
  {
    "id": 595,
    "context": [
      "China is one of BRICS and its economy is emerging.",
      "India is one of BRICS and its economy is emerging.",
      "All people from China speak Chinese.",
      "All people from India speak Hindi or English.",
      "There is an Indian."
    ],
    "question": "There is a person from BRICS speaking Hindi.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nBRICS(x) ::: x is a country in BRICS.\nEmerging(x) ::: the economy of x is emerging.\nSpeak(x, y) ::: x speaks language y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nBRICS(china) ∧ Emerging(china) ::: China is one of BRICS and its economy is emerging.\nBRICS(india) ∧ Emerging(india) ::: India is one of BRICS and its economy is emerging.\n∀x (BRICS(x) → ∀y (Speak(x, y) ↔ (y = chinese))) ::: All people from China speak Chinese.\n∀x (BRICS(x) → ∀y (Speak(x, y) ↔ (y = hindi ∨ y = english))) ::: All people from India speak Hindi or English.\n∃x (BRICS(x)) ::: There is a person from BRICS.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n∃x (BRICS(x) ∧ Speak(x, hindi)) ::: There is a person from BRICS speaking Hindi.\n\"\"\""
    ]
  },
  {
    "id": 265,
    "context": [
      "Daveed Diggs is an actor and film producer.",
      "Daveed Diggs played two roles in the musical Hamilton.",
      "One of the actors from Hamilton won the best actor award.",
      "The actor playing Thomas Jefferson won the best actor award.",
      "Daveed Diggs played Thomas Jefferson.",
      "Musicals are not films."
    ],
    "question": "Hamilton is a film.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nActor(x) ::: x is an actor.\nFilmProducer(x) ::: x is a film producer.\nPlayed(x, y) ::: x played the role y.\nWonAward(x) ::: x won the best actor award.\nRole(x, y) ::: x played the role y.\nMusical(x) ::: x is a musical.\nFilm(x) ::: x is a film.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nActor(daveedDiggs) ∧ FilmProducer(daveedDiggs) ::: Daveed Diggs is an actor and film producer.\nPlayed(daveedDiggs, role1) ∧ Played(daveedDiggs, role2) ∧ Role(role1, hamilton) ∧ Role(role2, hamilton) ::: Daveed Diggs played two roles in the musical Hamilton.\n∃x (Actor(x) ∧ Role(x, hamilton) ∧ WonAward(x)) ::: One of the actors from Hamilton won the best actor award.\nActor(thomasJefferson) ∧ Role(thomasJefferson, thomasJefferson) ∧ WonAward(thomasJefferson) ::: The actor playing Thomas Jefferson won the best actor award.\nPlayed(daveedDiggs, thomasJefferson) ::: Daveed Diggs played Thomas Jefferson.\n¬(Musical(x) ∧ Film(x)) ::: Musicals are not films.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬Film(hamilton) ::: Hamilton is not a film.\n\"\"\""
    ]
  },
  {
    "id": 266,
    "context": [
      "Daveed Diggs is an actor and film producer.",
      "Daveed Diggs played two roles in the musical Hamilton.",
      "One of the actors from Hamilton won the best actor award.",
      "The actor playing Thomas Jefferson won the best actor award.",
      "Daveed Diggs played Thomas Jefferson.",
      "Musicals are not films."
    ],
    "question": "Daveed Diggs won the best actor award.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nActor(x) ::: x is an actor.\nFilmProducer(x) ::: x is a film producer.\nPlayed(x, y) ::: x played the role y.\nWonAward(x, y) ::: x won the award y.\nHamilton(x) ::: x is from the musical Hamilton.\nBestActorAward(x) ::: x won the best actor award.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nActor(daveedDiggs) ∧ FilmProducer(daveedDiggs) ::: Daveed Diggs is an actor and film producer.\nPlayed(daveedDiggs, role1) ∧ Played(daveedDiggs, role2) ∧ role1 ≠ role2 ∧ Hamilton(role1) ∧ Hamilton(role2) ::: Daveed Diggs played two roles in the musical Hamilton.\n∃x (Actor(x) ∧ WonAward(x, bestActorAward) ∧ Hamilton(x)) ::: One of the actors from Hamilton won the best actor award.\nActor(thomasJefferson) ∧ Played(thomasJefferson, role) ∧ role = thomasJefferson ∧ WonAward(thomasJefferson, bestActorAward) ::: The actor playing Thomas Jefferson won the best actor award.\nPlayed(daveedDiggs, thomasJefferson) ::: Daveed Diggs played Thomas Jefferson.\n¬(Musicals(x) ∧ Films(x)) ::: Musicals are not films.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nWonAward(daveedDiggs, bestActorAward) ::: Daveed Diggs won the best actor award.\n\"\"\""
    ]
  },
  {
    "id": 267,
    "context": [
      "Daveed Diggs is an actor and film producer.",
      "Daveed Diggs played two roles in the musical Hamilton.",
      "One of the actors from Hamilton won the best actor award.",
      "The actor playing Thomas Jefferson won the best actor award.",
      "Daveed Diggs played Thomas Jefferson.",
      "Musicals are not films."
    ],
    "question": "Hamilton won two awards.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nActor(x) ::: x is an actor.\nFilmProducer(x) ::: x is a film producer.\nPlayed(x, y) ::: x played the role y.\nWonAward(x) ::: x won an award.\nRole(x, y) ::: x played the role y.\nMusical(x) ::: x is a musical.\nFilm(x) ::: x is a film.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nActor(daveedDiggs) ∧ FilmProducer(daveedDiggs) ::: Daveed Diggs is an actor and film producer.\nPlayed(daveedDiggs, role1) ∧ Played(daveedDiggs, role2) ∧ Role(role1, hamilton) ∧ Role(role2, hamilton) ::: Daveed Diggs played two roles in the musical Hamilton.\n∃x (Actor(x) ∧ Played(x, hamilton) ∧ WonAward(x)) ::: One of the actors from Hamilton won the best actor award.\nActor(thomasJefferson) ∧ Played(thomasJefferson, thomasJefferson) ∧ WonAward(thomasJefferson) ::: The actor playing Thomas Jefferson won the best actor award.\nPlayed(daveedDiggs, thomasJefferson) ::: Daveed Diggs played Thomas Jefferson.\n∀x (Musical(x) → ¬Film(x)) ::: Musicals are not films.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n∃x (WonAward(x) ∧ Role(x, hamilton)) ::: Hamilton won two awards.\n\"\"\""
    ]
  },
  {
    "id": 630,
    "context": [
      "Ernest Pohl was a Polish football player. ",
      "A football player in the Polish First Division has scored over 180 goals. ",
      "Ernest Pohl scored more than 180 goals in the Polish First Division. ",
      "Górnik Zabrze's stadium was named after a soccer player from Ruda Śląska. ",
      "Ernest Pohl is from Ruda Śląska. "
    ],
    "question": "Ernest Pohl has not scored more than 180 goals.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nPolish(x) ::: x is a Polish person.\nFootballPlayer(x) ::: x is a football player.\nScoredOver180Goals(x) ::: x has scored over 180 goals.\nInPolishFirstDivision(x) ::: x is in the Polish First Division.\nNamedAfter(x, y) ::: x is named after y.\nFrom(x, y) ::: x is from y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nPolish(ernest) ∧ FootballPlayer(ernest) ::: Ernest Pohl was a Polish football player.\n∀x (FootballPlayer(x) ∧ InPolishFirstDivision(x) → ScoredOver180Goals(x)) ::: A football player in the Polish First Division has scored over 180 goals.\nFootballPlayer(ernest) ∧ InPolishFirstDivision(ernest) ∧ ScoredOver180Goals(ernest) ::: Ernest Pohl scored more than 180 goals in the Polish First Division.\nNamedAfter(gornikZabrzeStadium, soccerPlayerFromRudaSlaska) ::: Górnik Zabrze's stadium was named after a soccer player from Ruda Śląska.\nFrom(ernest, rudaSlaska) ::: Ernest Pohl is from Ruda Śląska.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬ScoredOver180Goals(ernest) ::: Ernest Pohl has not scored more than 180 goals.\n\"\"\""
    ]
  },
  {
    "id": 631,
    "context": [
      "Ernest Pohl was a Polish football player. ",
      "A football player in the Polish First Division has scored over 180 goals. ",
      "Ernest Pohl scored more than 180 goals in the Polish First Division. ",
      "Górnik Zabrze's stadium was named after a soccer player from Ruda Śląska. ",
      "Ernest Pohl is from Ruda Śląska. "
    ],
    "question": "Górnik Zabrze's stadium was named after Ernest Pohl.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nPolish(x) ::: x is a Polish person.\nFootballPlayer(x) ::: x is a football player.\nScoredOver180Goals(x) ::: x has scored over 180 goals.\nInPolishFirstDivision(x) ::: x is in the Polish First Division.\nNamedAfter(x, y) ::: x is named after y.\nFrom(x, y) ::: x is from y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nPolish(ernest) ∧ FootballPlayer(ernest) ::: Ernest Pohl was a Polish football player.\n∀x (FootballPlayer(x) ∧ InPolishFirstDivision(x) → ScoredOver180Goals(x)) ::: A football player in the Polish First Division has scored over 180 goals.\nFootballPlayer(ernest) ∧ InPolishFirstDivision(ernest) ∧ ScoredOver180Goals(ernest) ::: Ernest Pohl scored more than 180 goals in the Polish First Division.\nNamedAfter(gornikZabrzeStadium, soccerPlayerFromRudaSlaska) ::: Górnik Zabrze's stadium was named after a soccer player from Ruda Śląska.\nFrom(ernest, rudaSlaska) ::: Ernest Pohl is from Ruda Śląska.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nNamedAfter(gornikZabrzeStadium, ernest) ::: Górnik Zabrze's stadium was named after Ernest Pohl.\n\"\"\""
    ]
  },
  {
    "id": 418,
    "context": [
      "Ann J. Land was a member of the Philadelphia City Council and was also a member of the Democratic Party.",
      "Ann J. Land ran unopposed for the Philadephia City Council in 1980.",
      "People who run unopposed for the Philadelphia City Council are elected to the positions they run for in the same year.",
      "Michael Nutter was a political challenger.",
      "Ann J. Land defeated Michael Nutter and ran for the Philadelphia City Council in 1987."
    ],
    "question": "Ann J. Land was elected to the Philadelphia City Council in 1980.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nMember(x, y) ::: x is a member of y.\nParty(x, y) ::: x is a member of the y party.\nRunUnopposed(x, y, z) ::: x ran unopposed for the y in year z.\nElected(x, y, z) ::: x was elected to the y in year z.\nChallenger(x) ::: x is a political challenger.\nDefeated(x, y) ::: x defeated y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nMember(annJLand, philadelphiaCityCouncil) ∧ Party(annJLand, democraticParty) ::: Ann J. Land was a member of the Philadelphia City Council and was also a member of the Democratic Party.\nRunUnopposed(annJLand, philadelphiaCityCouncil, year1980) ::: Ann J. Land ran unopposed for the Philadephia City Council in 1980.\n∀x (RunUnopposed(x, philadelphiaCityCouncil, y) → Elected(x, philadelphiaCityCouncil, y)) ::: People who run unopposed for the Philadelphia City Council are elected to the positions they run for in the same year.\nChallenger(michaelNutter) ::: Michael Nutter was a political challenger.\nDefeated(annJLand, michaelNutter) ∧ RunUnopposed(annJLand, philadelphiaCityCouncil, year1987) ::: Ann J. Land defeated Michael Nutter and ran for the Philadelphia City Council in 1987.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nElected(annJLand, philadelphiaCityCouncil, year1980) ::: Ann J. Land was elected to the Philadelphia City Council in 1980.\n\"\"\""
    ]
  },
  {
    "id": 419,
    "context": [
      "Ann J. Land was a member of the Philadelphia City Council and was also a member of the Democratic Party.",
      "Ann J. Land ran unopposed for the Philadephia City Council in 1980.",
      "People who run unopposed for the Philadelphia City Council are elected to the positions they run for in the same year.",
      "Michael Nutter was a political challenger.",
      "Ann J. Land defeated Michael Nutter and ran for the Philadelphia City Council in 1987."
    ],
    "question": "Ann J. Land was elected to the Philadelphia City Council in 1987.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nMember(x, y) ::: x is a member of y.\nParty(x, y) ::: x is a member of the y party.\nRunUnopposed(x, y, z) ::: x ran unopposed for the y in year z.\nElected(x, y, z) ::: x was elected to the y in year z.\nChallenger(x) ::: x is a political challenger.\nDefeated(x, y) ::: x defeated y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nMember(annJLand, philadelphiaCityCouncil) ∧ Party(annJLand, democraticParty) ::: Ann J. Land was a member of the Philadelphia City Council and was also a member of the Democratic Party.\nRunUnopposed(annJLand, philadelphiaCityCouncil, year1980) ::: Ann J. Land ran unopposed for the Philadephia City Council in 1980.\n∀x (RunUnopposed(x, philadelphiaCityCouncil, y) → Elected(x, z, y)) ::: People who run unopposed for the Philadelphia City Council are elected to the positions they run for in the same year.\nChallenger(michaelNutter) ::: Michael Nutter was a political challenger.\nDefeated(annJLand, michaelNutter) ∧ RunUnopposed(annJLand, philadelphiaCityCouncil, year1987) ::: Ann J. Land defeated Michael Nutter and ran for the Philadelphia City Council in 1987.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nElected(annJLand, philadelphiaCityCouncil, year1987) ::: Ann J. Land was elected to the Philadelphia City Council in 1987.\n\"\"\""
    ]
  },
  {
    "id": 420,
    "context": [
      "Ann J. Land was a member of the Philadelphia City Council and was also a member of the Democratic Party.",
      "Ann J. Land ran unopposed for the Philadephia City Council in 1980.",
      "People who run unopposed for the Philadelphia City Council are elected to the positions they run for in the same year.",
      "Michael Nutter was a political challenger.",
      "Ann J. Land defeated Michael Nutter and ran for the Philadelphia City Council in 1987."
    ],
    "question": "There was some member of the Democratic Party elected to the Philadelphia City Council in 1980.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nMember(x) ::: x is a member of a political party.\nCouncilMember(x) ::: x is a member of the Philadelphia City Council.\nParty(x) ::: x is a political party.\nRanUnopposed(x, y) ::: x ran unopposed for position y.\nElected(x, y) ::: x is elected to position y.\nChallenger(x) ::: x is a political challenger.\nDefeated(x, y) ::: x defeated y in an election.\nRanFor(x, y) ::: x ran for position y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nMember(ann, democraticParty) ∧ CouncilMember(ann) ∧ Party(democraticParty) ::: Ann J. Land was a member of the Philadelphia City Council and was also a member of the Democratic Party.\nRanUnopposed(ann, cityCouncil1980) ::: Ann J. Land ran unopposed for the Philadelphia City Council in 1980.\n∀x (RanUnopposed(x, cityCouncil) → Elected(x, cityCouncil)) ::: People who run unopposed for the Philadelphia City Council are elected to the positions they run for in the same year.\nChallenger(michael) ::: Michael Nutter was a political challenger.\nDefeated(ann, michael) ∧ RanFor(ann, cityCouncil1987) ::: Ann J. Land defeated Michael Nutter and ran for the Philadelphia City Council in 1987.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n∃x (Member(x, democraticParty) ∧ Elected(x, cityCouncil1980)) ::: There was some member of the Democratic Party elected to the Philadelphia City Council in 1980.\n\"\"\""
    ]
  },
  {
    "id": 337,
    "context": [
      "Aberdeen won the cup in the 2013 final.",
      "Rangers won the cup in 2014 final.",
      "Aberdeen and Rangers are different teams.",
      "Different teams cannot win the same cup in a given year's final."
    ],
    "question": "Rangers won the cup in 2015.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nWonCup(x, y) ::: Team x won the cup in year y.\nDifferentTeams(x, y) ::: x and y are different teams.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nWonCup(aberdeen, 2013) ::: Aberdeen won the cup in the 2013 final.\nWonCup(rangers, 2014) ::: Rangers won the cup in the 2014 final.\nDifferentTeams(aberdeen, rangers) ::: Aberdeen and Rangers are different teams.\n∀x ∀y ((DifferentTeams(x, y)) → ∀z ¬(WonCup(x, z) ∧ WonCup(y, z))) ::: Different teams cannot win the same cup in a given year's final.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬WonCup(rangers, 2015) ::: Rangers did not win the cup in 2015.\n\"\"\""
    ]
  },
  {
    "id": 338,
    "context": [
      "Aberdeen won the cup in the 2013 final.",
      "Rangers won the cup in 2014 final.",
      "Aberdeen and Rangers are different teams.",
      "Different teams cannot win the same cup in a given year's final."
    ],
    "question": "Rangers won the cup in 2013.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nWonCup(x, y) ::: Team x won the cup in year y.\nDifferentTeams(x, y) ::: x and y are different teams.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nWonCup(aberdeen, 2013) ::: Aberdeen won the cup in the 2013 final.\nWonCup(rangers, 2014) ::: Rangers won the cup in the 2014 final.\nDifferentTeams(aberdeen, rangers) ::: Aberdeen and Rangers are different teams.\n∀x ∀y ∀z ((DifferentTeams(x, y) ∧ WonCup(x, z) ∧ WonCup(y, z)) → ¬(WonCup(x, z) ∧ WonCup(y, z))) ::: Different teams cannot win the same cup in a given year's final.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬WonCup(rangers, 2013) ::: Rangers did not win the cup in 2013.\n\"\"\""
    ]
  },
  {
    "id": 339,
    "context": [
      "Aberdeen won the cup in the 2013 final.",
      "Rangers won the cup in 2014 final.",
      "Aberdeen and Rangers are different teams.",
      "Different teams cannot win the same cup in a given year's final."
    ],
    "question": "Aberdeen has won a cup before.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nWon(x, y) ::: Team x won the cup in year y final.\nDifferentTeams(x, y) ::: x and y are different teams.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nWon(aberdeen, 2013) ::: Aberdeen won the cup in the 2013 final.\nWon(rangers, 2014) ::: Rangers won the cup in the 2014 final.\nDifferentTeams(aberdeen, rangers) ::: Aberdeen and Rangers are different teams.\n∀x ∀y ((DifferentTeams(x, y) ∧ Won(x, z) ∧ Won(y, z)) → ¬(Won(x, z) ∧ Won(y, z))) ::: Different teams cannot win the same cup in a given year's final.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n∃y Won(aberdeen, y) ::: Aberdeen has won a cup before.\n\"\"\""
    ]
  },
  {
    "id": 848,
    "context": [
      "All young working professionals who have regular 9-5 jobs also have pets.",
      "Some people who live in Manhattan are young working professionals who have regular 9-5 jobs.",
      "All people who have pets are people who have at least one child.",
      "People who do not have at least one child are people who own a sports car.",
      "Mary either does not own a sports car or, if they do, then they do not have at least one child."
    ],
    "question": "Mary is a person who lives in Manhattan.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nYoung(x) ::: x is a young working professional.\nJob(x) ::: x has a regular 9-5 job.\nPetOwner(x) ::: x has pets.\nManhattanResident(x) ::: x lives in Manhattan.\nChild(x) ::: x has at least one child.\nSportsCarOwner(x) ::: x owns a sports car.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x ((Young(x) ∧ Job(x)) → PetOwner(x)) ::: All young working professionals who have regular 9-5 jobs also have pets.\n∃x (ManhattanResident(x) ∧ Young(x) ∧ Job(x)) ::: Some people who live in Manhattan are young working professionals who have regular 9-5 jobs.\n∀x (PetOwner(x) → Child(x)) ::: All people who have pets are people who have at least one child.\n¬Child(x) → SportsCarOwner(x) ::: People who do not have at least one child are people who own a sports car.\n¬SportsCarOwner(mary) ∨ (SportsCarOwner(mary) → ¬Child(mary)) ::: Mary either does not own a sports car or, if they do, then they do not have at least one child.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nManhattanResident(mary) ::: Mary is a person who lives in Manhattan.\n\"\"\""
    ]
  },
  {
    "id": 849,
    "context": [
      "All young working professionals who have regular 9-5 jobs also have pets.",
      "Some people who live in Manhattan are young working professionals who have regular 9-5 jobs.",
      "All people who have pets are people who have at least one child.",
      "People who do not have at least one child are people who own a sports car.",
      "Mary either does not own a sports car or, if they do, then they do not have at least one child."
    ],
    "question": "Mary is a person who lives in Manhattan and is a young working professional who has a regular 9-5 job.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nYoung(x) ::: x is a young working professional.\nJob(x) ::: x has a regular 9-5 job.\nPetOwner(x) ::: x has pets.\nManhattanResident(x) ::: x lives in Manhattan.\nChild(x) ::: x has at least one child.\nSportsCarOwner(x) ::: x owns a sports car.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x ((Young(x) ∧ Job(x)) → PetOwner(x)) ::: All young working professionals who have regular 9-5 jobs also have pets.\n∃x (ManhattanResident(x) ∧ Young(x) ∧ Job(x)) ::: Some people who live in Manhattan are young working professionals who have regular 9-5 jobs.\n∀x (PetOwner(x) → Child(x)) ::: All people who have pets are people who have at least one child.\n¬Child(x) → SportsCarOwner(x) ::: People who do not have at least one child are people who own a sports car.\n¬SportsCarOwner(mary) ∨ (SportsCarOwner(mary) → ¬Child(mary)) ::: Mary either does not own a sports car or, if they do, then they do not have at least one child.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nManhattanResident(mary) ∧ Young(mary) ∧ Job(mary) ::: Mary is a person who lives in Manhattan and is a young working professional who has a regular 9-5 job.\n\"\"\""
    ]
  },
  {
    "id": 850,
    "context": [
      "All young working professionals who have regular 9-5 jobs also have pets.",
      "Some people who live in Manhattan are young working professionals who have regular 9-5 jobs.",
      "All people who have pets are people who have at least one child.",
      "People who do not have at least one child are people who own a sports car.",
      "Mary either does not own a sports car or, if they do, then they do not have at least one child."
    ],
    "question": "If Mary is a young working professional who has a regular 9-5 job, then Mary does not live in Manhattan.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nYoung(x) ::: x is a young person.\nWorkingProfessional(x) ::: x is a working professional.\nJob(x) ::: x has a regular 9-5 job.\nPetOwner(x) ::: x has pets.\nManhattanResident(x) ::: x lives in Manhattan.\nChild(x) ::: x has at least one child.\nSportsCarOwner(x) ::: x owns a sports car.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x ((Young(x) ∧ WorkingProfessional(x) ∧ Job(x)) → PetOwner(x)) ::: All young working professionals who have regular 9-5 jobs also have pets.\n∃x (ManhattanResident(x) ∧ Young(x) ∧ WorkingProfessional(x) ∧ Job(x)) ::: Some people who live in Manhattan are young working professionals who have regular 9-5 jobs.\n∀x (PetOwner(x) → Child(x)) ::: All people who have pets are people who have at least one child.\n¬Child(x) → SportsCarOwner(x) ::: People who do not have at least one child are people who own a sports car.\n¬SportsCarOwner(mary) ∨ (SportsCarOwner(mary) → ¬Child(mary)) ::: Mary either does not own a sports car or, if they do, then they do not have at least one child.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n(Young(mary) ∧ WorkingProfessional(mary) ∧ Job(mary)) → ¬ManhattanResident(mary) ::: If Mary is a young working professional who has a regular 9-5 job, then Mary does not live in Manhattan.\n\"\"\""
    ]
  },
  {
    "id": 1085,
    "context": [
      "Either block design or event-related design. ",
      "All event-related designs are brain image acquisition.",
      "All brain image acquisition is preceded by data processing.",
      "Nothing preceded by data processing acquires data.",
      "Picture memory is either an event-related design and acquiring data or neither an event-related design nor acquiring data."
    ],
    "question": "Picture memory is preceded by data processing.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nBlockDesign(x) ::: x is a block design.\nEventRelatedDesign(x) ::: x is an event-related design.\nBrainImageAcquisition(x) ::: x is brain image acquisition.\nDataProcessing(x) ::: x is data processing.\nAcquiresData(x) ::: x acquires data.\nPreceded(x, y) ::: x is preceded by y.\nPictureMemory(x) ::: x is picture memory.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nBlockDesign(x) ∨ EventRelatedDesign(x) ::: Either block design or event-related design.\n∀x (EventRelatedDesign(x) → BrainImageAcquisition(x)) ::: All event-related designs are brain image acquisition.\n∀x (BrainImageAcquisition(x) → Preceded(x, DataProcessing)) ::: All brain image acquisition is preceded by data processing.\n∀x (Preceded(x, DataProcessing) → ¬AcquiresData(x)) ::: Nothing preceded by data processing acquires data.\n(PictureMemory(x) ∧ EventRelatedDesign(x) ∧ AcquiresData(x)) ⊕ ¬(EventRelatedDesign(x) ∨ AcquiresData(x)) ::: Picture memory is either an event-related design and acquiring data or neither an event-related design nor acquiring data.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nPreceded(PictureMemory, DataProcessing) ::: Picture memory is preceded by data processing.\n\"\"\""
    ]
  },
  {
    "id": 1086,
    "context": [
      "Either block design or event-related design. ",
      "All event-related designs are brain image acquisition.",
      "All brain image acquisition is preceded by data processing.",
      "Nothing preceded by data processing acquires data.",
      "Picture memory is either an event-related design and acquiring data or neither an event-related design nor acquiring data."
    ],
    "question": "Picture memory is a block design.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nBlockDesign(x) ::: x is a block design.\nEventDesign(x) ::: x is an event-related design.\nBrainImageAcquisition(x) ::: x is brain image acquisition.\nDataProcessing(x) ::: x is data processing.\nPrecedes(x, y) ::: x is preceded by y.\nAcquiresData(x) ::: x acquires data.\nPictureMemory(x) ::: x is picture memory.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nBlockDesign(block) ∨ EventDesign(event) ::: Either block design or event-related design.\n∀x (EventDesign(x) → BrainImageAcquisition(x)) ::: All event-related designs are brain image acquisition.\n∀x (BrainImageAcquisition(x) → Precedes(x, DataProcessing(x))) ::: All brain image acquisition is preceded by data processing.\n∀x (Precedes(DataProcessing(x), AcquiresData(x))) ::: Nothing preceded by data processing acquires data.\n(PictureMemory(picture) ∧ EventDesign(picture) ∧ AcquiresData(picture)) ⊕ ¬(EventDesign(picture) ∨ AcquiresData(picture)) ::: Picture memory is either an event-related design and acquiring data or neither an event-related design nor acquiring data.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nBlockDesign(picture) ::: Picture memory is a block design.\n\"\"\""
    ]
  },
  {
    "id": 1087,
    "context": [
      "Either block design or event-related design. ",
      "All event-related designs are brain image acquisition.",
      "All brain image acquisition is preceded by data processing.",
      "Nothing preceded by data processing acquires data.",
      "Picture memory is either an event-related design and acquiring data or neither an event-related design nor acquiring data."
    ],
    "question": "Picture memory is either a block design or acquiring data.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nBlockDesign(x) ::: x is a block design.\nEventDesign(x) ::: x is an event-related design.\nBrainImageAcquisition(x) ::: x is brain image acquisition.\nDataProcessing(x) ::: x is data processing.\nAcquiresData(x) ::: x acquires data.\nPictureMemory(x) ::: x is picture memory.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nBlockDesign() ∨ EventDesign() ::: Either block design or event-related design.\n∀x (EventDesign(x) → BrainImageAcquisition(x)) ::: All event-related designs are brain image acquisition.\n∀x (BrainImageAcquisition(x) → PrecededByDataProcessing(x)) ::: All brain image acquisition is preceded by data processing.\n∀x (PrecededByDataProcessing(x) → ¬AcquiresData(x)) ::: Nothing preceded by data processing acquires data.\n(PictureMemory() ∧ EventDesign() ∧ AcquiresData()) ⊕ ¬(EventDesign() ∨ AcquiresData()) ::: Picture memory is either an event-related design and acquiring data or neither an event-related design nor acquiring data.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nBlockDesign(pictureMemory) ∨ AcquiresData(pictureMemory) ::: Picture memory is either a block design or acquiring data.\n\"\"\""
    ]
  },
  {
    "id": 1088,
    "context": [
      "Either block design or event-related design. ",
      "All event-related designs are brain image acquisition.",
      "All brain image acquisition is preceded by data processing.",
      "Nothing preceded by data processing acquires data.",
      "Picture memory is either an event-related design and acquiring data or neither an event-related design nor acquiring data."
    ],
    "question": "If picture memory is not acquiring data, then picture memory is a block design and acquiring data.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nBlockDesign(x) ::: x is a block design.\nEventRelatedDesign(x) ::: x is an event-related design.\nBrainImageAcquisition(x) ::: x is brain image acquisition.\nDataProcessing(x) ::: x is data processing.\nAcquiresData(x) ::: x acquires data.\nPictureMemory(x) ::: x is picture memory.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nBlockDesign(x) ∨ EventRelatedDesign(x) ::: Either block design or event-related design.\n∀x (EventRelatedDesign(x) → BrainImageAcquisition(x)) ::: All event-related designs are brain image acquisition.\n∀x (BrainImageAcquisition(x) → DataProcessing(x)) ::: All brain image acquisition is preceded by data processing.\n∀x (DataProcessing(x) → ¬AcquiresData(x)) ::: Nothing preceded by data processing acquires data.\n(PictureMemory(x) ∧ EventRelatedDesign(x) ∧ AcquiresData(x)) ⊕ ¬(PictureMemory(x) ∨ EventRelatedDesign(x) ∨ AcquiresData(x)) ::: Picture memory is either an event-related design and acquiring data or neither an event-related design nor acquiring data.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬AcquiresData(pictureMemory) → (BlockDesign(pictureMemory) ∧ AcquiresData(pictureMemory)) ::: If picture memory is not acquiring data, then picture memory is a block design and acquiring data.\n\"\"\""
    ]
  },
  {
    "id": 726,
    "context": [
      "The USS Lyon was a US Navy ship involved in WWII.",
      "All ships involved in WWII are currently decommissioned or in a museum."
    ],
    "question": "The USS Lyon is decommissioned.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nShip(x) ::: x is a ship.\nUSNavy(x) ::: x is a US Navy ship.\nInvolvedInWWII(x) ::: x was involved in WWII.\nDecommissioned(x) ::: x is decommissioned.\nInMuseum(x) ::: x is in a museum.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nUSNavy(ussLyon) ∧ InvolvedInWWII(ussLyon) ::: The USS Lyon was a US Navy ship involved in WWII.\n∀x (Ship(x) ∧ InvolvedInWWII(x) → Decommissioned(x) ∨ InMuseum(x)) ::: All ships involved in WWII are currently decommissioned or in a museum.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nDecommissioned(ussLyon) ::: The USS Lyon is decommissioned.\n\"\"\""
    ]
  },
  {
    "id": 929,
    "context": [
      "All disposable chopsticks are made from trees.",
      "Some chopsticks are eco-friendly.",
      "Either disposable chopsticks or reusable chopsticks. ",
      "If chopsticks are made from metals, then they are not made from plastics. ",
      "All reusable chopsticks are made from metal.",
      "Chopsticks at restaurants are either made from metals and made from plastics, or neither made from metals nor made from plastics."
    ],
    "question": "Chopsticks at restaurants are eco-friendly.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nMadeFrom(x, y) ::: x is made from y.\nDisposable(x) ::: x is disposable.\nTree(x) ::: x is a tree.\nEcoFriendly(x) ::: x is eco-friendly.\nReusable(x) ::: x is reusable.\nMetal(x) ::: x is metal.\nPlastic(x) ::: x is plastic.\nRestaurant(x) ::: x is at a restaurant.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Disposable(x) → MadeFrom(x, tree)) ::: All disposable chopsticks are made from trees.\n∃x (Chopsticks(x) ∧ EcoFriendly(x)) ::: Some chopsticks are eco-friendly.\nDisposable(chopsticks) ∨ Reusable(chopsticks) ::: Either disposable chopsticks or reusable chopsticks.\n∀x (MadeFrom(x, metal) → ¬MadeFrom(x, plastic)) ::: If chopsticks are made from metals, then they are not made from plastics.\n∀x (Reusable(x) → MadeFrom(x, metal)) ::: All reusable chopsticks are made from metal.\n(Restaurant(chopsticks) ∧ MadeFrom(chopsticks, metal) ∧ MadeFrom(chopsticks, plastic)) ⊕ ¬(MadeFrom(chopsticks, metal) ∨ MadeFrom(chopsticks, plastic)) ::: Chopsticks at restaurants are either made from metals and made from plastics, or neither made from metals nor made from plastics.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n∃x (Restaurant(x) ∧ EcoFriendly(x)) ::: Chopsticks at restaurants are eco-friendly.\n\"\"\""
    ]
  },
  {
    "id": 930,
    "context": [
      "All disposable chopsticks are made from trees.",
      "Some chopsticks are eco-friendly.",
      "Either disposable chopsticks or reusable chopsticks. ",
      "If chopsticks are made from metals, then they are not made from plastics. ",
      "All reusable chopsticks are made from metal.",
      "Chopsticks at restaurants are either made from metals and made from plastics, or neither made from metals nor made from plastics."
    ],
    "question": "Chopsticks at restaurants are eco-friendly or made from trees.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nDisposable(x) ::: x is a disposable chopstick.\nTree(x) ::: x is made from trees.\nEcoFriendly(x) ::: x is eco-friendly.\nReusable(x) ::: x is a reusable chopstick.\nMetal(x) ::: x is made from metal.\nPlastic(x) ::: x is made from plastic.\nRestaurant(x) ::: x is at a restaurant.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Disposable(x) → Tree(x)) ::: All disposable chopsticks are made from trees.\n∃x (Chopsticks(x) ∧ EcoFriendly(x)) ::: Some chopsticks are eco-friendly.\nDisposable(x) ∨ Reusable(x) ::: Either disposable chopsticks or reusable chopsticks.\nMetal(x) → ¬Plastic(x) ::: If chopsticks are made from metals, then they are not made from plastics.\n∀x (Reusable(x) → Metal(x)) ::: All reusable chopsticks are made from metal.\n(Restaurant(x) ∧ Metal(x) ∧ Plastic(x)) ⊕ ¬(Metal(x) ∨ Plastic(x)) ::: Chopsticks at restaurants are either made from metals and made from plastics, or neither made from metals nor made from plastics.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nEcoFriendly(restaurant) ∨ Tree(restaurant) ::: Chopsticks at restaurants are eco-friendly or made from trees.\n\"\"\""
    ]
  },
  {
    "id": 931,
    "context": [
      "All disposable chopsticks are made from trees.",
      "Some chopsticks are eco-friendly.",
      "Either disposable chopsticks or reusable chopsticks. ",
      "If chopsticks are made from metals, then they are not made from plastics. ",
      "All reusable chopsticks are made from metal.",
      "Chopsticks at restaurants are either made from metals and made from plastics, or neither made from metals nor made from plastics."
    ],
    "question": "If Chopsticks at restaurants are made from plastics or made from trees, then Chopsticks at restaurants are made from plastics and are eco-friendly.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nMadeFrom(x, y) ::: x is made from y.\nDisposable(x) ::: x is disposable.\nTree(x) ::: x is a tree.\nEcoFriendly(x) ::: x is eco-friendly.\nReusable(x) ::: x is reusable.\nMetal(x) ::: x is metal.\nPlastic(x) ::: x is plastic.\nRestaurant(x) ::: x is at a restaurant.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Disposable(x) → MadeFrom(x, tree)) ::: All disposable chopsticks are made from trees.\n∃x (Chopsticks(x) ∧ EcoFriendly(x)) ::: Some chopsticks are eco-friendly.\nDisposable(chopsticks) ∨ Reusable(chopsticks) ::: Either disposable chopsticks or reusable chopsticks.\n∀x (MadeFrom(x, metal) → ¬MadeFrom(x, plastic)) ::: If chopsticks are made from metals, then they are not made from plastics.\n∀x (Reusable(x) → MadeFrom(x, metal)) ::: All reusable chopsticks are made from metal.\n(MadeFrom(chopsticks, metal) ∧ MadeFrom(chopsticks, plastic)) ⊕ ¬(MadeFrom(chopsticks, metal) ∨ MadeFrom(chopsticks, plastic)) ::: Chopsticks at restaurants are either made from metals and made from plastics, or neither made from metals nor made from plastics.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n(MadeFrom(chopsticks, plastic) ∨ MadeFrom(chopsticks, tree)) → (MadeFrom(chopsticks, plastic) ∧ EcoFriendly(chopsticks)) ::: If Chopsticks at restaurants are made from plastics or made from trees, then Chopsticks at restaurants are made from plastics and are eco-friendly.\n\"\"\""
    ]
  },
  {
    "id": 1285,
    "context": [
      "Anything that is lazy is unproductive.",
      "No one unproductive is an energetic person.",
      "If something is a sloth, then it is lazy.",
      "Some animals are sloths.",
      "Sid is not either an energetic person or a sloth."
    ],
    "question": "Sid is an animal.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nLazy(x) ::: x is lazy.\nUnproductive(x) ::: x is unproductive.\nEnergetic(x) ::: x is an energetic person.\nSloth(x) ::: x is a sloth.\nAnimal(x) ::: x is an animal.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Lazy(x) → Unproductive(x)) ::: Anything that is lazy is unproductive.\n∀x (Unproductive(x) → ¬Energetic(x)) ::: No one unproductive is an energetic person.\n∀x (Sloth(x) → Lazy(x)) ::: If something is a sloth, then it is lazy.\n∃x (Animal(x) ∧ Sloth(x)) ::: Some animals are sloths.\n¬(Energetic(sid) ∨ Sloth(sid)) ::: Sid is not either an energetic person or a sloth.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nAnimal(sid) ::: Sid is an animal.\n\"\"\""
    ]
  },
  {
    "id": 1286,
    "context": [
      "Anything that is lazy is unproductive.",
      "No one unproductive is an energetic person.",
      "If something is a sloth, then it is lazy.",
      "Some animals are sloths.",
      "Sid is not either an energetic person or a sloth."
    ],
    "question": "Sid is an energetic person and an animal.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nLazy(x) ::: x is lazy.\nUnproductive(x) ::: x is unproductive.\nEnergetic(x) ::: x is an energetic person.\nSloth(x) ::: x is a sloth.\nAnimal(x) ::: x is an animal.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Lazy(x) → Unproductive(x)) ::: Anything that is lazy is unproductive.\n∀x (Unproductive(x) → ¬Energetic(x)) ::: No one unproductive is an energetic person.\n∀x (Sloth(x) → Lazy(x)) ::: If something is a sloth, then it is lazy.\n∃x (Animal(x) ∧ Sloth(x)) ::: Some animals are sloths.\n¬(Energetic(sid) ∨ Sloth(sid)) ::: Sid is not either an energetic person or a sloth.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nEnergetic(sid) ∧ Animal(sid) ::: Sid is an energetic person and an animal.\n\"\"\""
    ]
  },
  {
    "id": 1287,
    "context": [
      "Anything that is lazy is unproductive.",
      "No one unproductive is an energetic person.",
      "If something is a sloth, then it is lazy.",
      "Some animals are sloths.",
      "Sid is not either an energetic person or a sloth."
    ],
    "question": "If Sid is either an animal or unproductive, then Sid is not an energetic person.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nLazy(x) ::: x is lazy.\nUnproductive(x) ::: x is unproductive.\nEnergetic(x) ::: x is an energetic person.\nSloth(x) ::: x is a sloth.\nAnimal(x) ::: x is an animal.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Lazy(x) → Unproductive(x)) ::: Anything that is lazy is unproductive.\n∀x (Unproductive(x) → ¬Energetic(x)) ::: No one unproductive is an energetic person.\n∀x (Sloth(x) → Lazy(x)) ::: If something is a sloth, then it is lazy.\n∃x (Animal(x) ∧ Sloth(x)) ::: Some animals are sloths.\n¬(Energetic(sid) ∨ Sloth(sid)) ::: Sid is not either an energetic person or a sloth.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n(Animal(sid) ∨ Unproductive(sid)) → ¬Energetic(sid) ::: If Sid is either an animal or unproductive, then Sid is not an energetic person.\n\"\"\""
    ]
  },
  {
    "id": 542,
    "context": [
      "European soccer clubs can attend UCL, UEL and UECL.",
      "A soccer club eligible to attend UCL has a higher ranking than a soccer club eligible to attend UEL.",
      "A soccer club eligible to attend UEL has a higher ranking than a soccer club eligible to attend UECL.",
      "Manchester United and Machester City are both European soccer clubs.",
      "Manchester United is eligible to attend UEL next season.",
      "Manchester City is eligible to attend UCL next season."
    ],
    "question": "Manchester City has a higher ranking than Manchester United.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nClub(x) ::: x is a soccer club.\nAttend(x, y) ::: x can attend tournament y.\nHigherRanking(x, y) ::: x has a higher ranking than y.\nEligible(x, y) ::: x is eligible to attend tournament y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Club(x) → (Attend(x, UCL) ∧ Attend(x, UEL) ∧ Attend(x, UECL))) ::: European soccer clubs can attend UCL, UEL and UECL.\n∀x (Eligible(x, UCL) → ∃y (Eligible(y, UEL) ∧ HigherRanking(x, y))) ::: A soccer club eligible to attend UCL has a higher ranking than a soccer club eligible to attend UEL.\n∀x (Eligible(x, UEL) → ∃y (Eligible(y, UECL) ∧ HigherRanking(x, y))) ::: A soccer club eligible to attend UEL has a higher ranking than a soccer club eligible to attend UECL.\nClub(manchesterUnited) ∧ Club(manchesterCity) ::: Manchester United and Machester City are both European soccer clubs.\nEligible(manchesterUnited, UEL) ::: Manchester United is eligible to attend UEL next season.\nEligible(manchesterCity, UCL) ::: Manchester City is eligible to attend UCL next season.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nHigherRanking(manchesterCity, manchesterUnited) ::: Manchester City has a higher ranking than Manchester United.\n\"\"\""
    ]
  },
  {
    "id": 193,
    "context": [
      "If a person coach a football club, the person is a football coach.",
      "If a person has a position in a club for a position in a year, and the club is in NFL in the same year, the person plays in NFL.",
      "Minnesota Vikings is a football club.",
      "Dennis Green coached Minnesota Vikings.",
      "Cris Carter had 13 touchdown receptions.",
      "Minnesota Vikings was in the National Football League in 1997.",
      "John Randle was Minnesota Vikings defensive tackle in 1997."
    ],
    "question": "Dennis Green is a football coach.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nCoach(x) ::: x is a football coach.\nFootballCoach(x) ::: x is a football coach.\nPosition(x, y, z) ::: x has a position in y for z.\nClub(x) ::: x is a football club.\nPlays(x, y) ::: x plays in y.\nNFL(x) ::: x is in the NFL.\nTouchdowns(x, y) ::: x had y touchdown receptions.\nDefensiveTackle(x, y) ::: x is a defensive tackle for y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Coach(x) → FootballCoach(x)) ::: If a person coach a football club, the person is a football coach.\n∀x∀y∀z ((Position(x, y, z) ∧ Club(y) ∧ NFL(y, z)) → Plays(x, NFL)) ::: If a person has a position in a club for a position in a year, and the club is in NFL in the same year, the person plays in NFL.\nClub(minnesotaVikings) ::: Minnesota Vikings is a football club.\nCoach(dennisGreen) ∧ Coach(minnesotaVikings) ::: Dennis Green coached Minnesota Vikings.\nTouchdowns(crisCarter, 13) ::: Cris Carter had 13 touchdown receptions.\nClub(minnesotaVikings) ∧ NFL(minnesotaVikings, 1997) ::: Minnesota Vikings was in the National Football League in 1997.\nDefensiveTackle(johnRandle, minnesotaVikings) ∧ NFL(minnesotaVikings, 1997) ::: John Randle was Minnesota Vikings defensive tackle in 1997.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nFootballCoach(dennisGreen) ::: Dennis Green is a football coach.\n\"\"\""
    ]
  },
  {
    "id": 194,
    "context": [
      "If a person coach a football club, the person is a football coach.",
      "If a person has a position in a club for a position in a year, and the club is in NFL in the same year, the person plays in NFL.",
      "Minnesota Vikings is a football club.",
      "Dennis Green coached Minnesota Vikings.",
      "Cris Carter had 13 touchdown receptions.",
      "Minnesota Vikings was in the National Football League in 1997.",
      "John Randle was Minnesota Vikings defensive tackle in 1997."
    ],
    "question": "John Randle didn't play in the National Football League.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nCoach(x) ::: x coaches a football club.\nFootballCoach(x) ::: x is a football coach.\nHasPosition(x, y, z) ::: x has a position in club y for position z in a year.\nPlaysInNFL(x) ::: x plays in the NFL.\nClub(x) ::: x is a football club.\nNFL(x) ::: x is in the National Football League.\nYear(x) ::: x is a year.\nMinnesotaVikings ::: Minnesota Vikings is a football club.\nDennisGreen ::: Dennis Green coached Minnesota Vikings.\nCrisCarter ::: Cris Carter had 13 touchdown receptions.\nJohnRandle ::: John Randle was Minnesota Vikings defensive tackle.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Coach(x) → FootballCoach(x)) ::: If a person coaches a football club, the person is a football coach.\n∀x∀y∀z ((HasPosition(x, y, z) ∧ Club(y) ∧ Year(z) ∧ NFL(y, z)) → PlaysInNFL(x)) ::: If a person has a position in a club for a position in a year, and the club is in NFL in the same year, the person plays in NFL.\nClub(minnesotaVikings) ::: Minnesota Vikings is a football club.\nCoach(dennisGreen) ∧ Coach(crisCarter) ∧ Coach(johnRandle) ::: Dennis Green coached Minnesota Vikings.\nHasPosition(crisCarter, minnesotaVikings, receiver) ∧ HasPosition(johnRandle, minnesotaVikings, defensiveTackle) ::: Cris Carter had 13 touchdown receptions. John Randle was Minnesota Vikings defensive tackle in 1997.\nNFL(minnesotaVikings, year1997) ::: Minnesota Vikings was in the National Football League in 1997.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬PlaysInNFL(johnRandle) ::: John Randle didn't play in the National Football League.\n\"\"\""
    ]
  },
  {
    "id": 195,
    "context": [
      "If a person coach a football club, the person is a football coach.",
      "If a person has a position in a club for a position in a year, and the club is in NFL in the same year, the person plays in NFL.",
      "Minnesota Vikings is a football club.",
      "Dennis Green coached Minnesota Vikings.",
      "Cris Carter had 13 touchdown receptions.",
      "Minnesota Vikings was in the National Football League in 1997.",
      "John Randle was Minnesota Vikings defensive tackle in 1997."
    ],
    "question": "Cris Carter played for Minnesota Vikings.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nCoach(x) ::: x is a football coach.\nFootballCoach(x) ::: x is a football coach.\nHasPosition(x, y, z) ::: x has a position y in a club z.\nPlaysInNFL(x) ::: x plays in NFL.\nClub(x) ::: x is a club.\nNFL(x) ::: x is in NFL.\nYear(x) ::: x is a year.\nTouchdownReceptions(x, y) ::: x had y touchdown receptions.\nDefensiveTackle(x) ::: x is a defensive tackle.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Coach(x) → FootballCoach(x)) ::: If a person coach a football club, the person is a football coach.\n∀x (HasPosition(x, y, z) ∧ Club(z) ∧ NFL(z, y) → PlaysInNFL(x)) ::: If a person has a position in a club for a position in a year, and the club is in NFL in the same year, the person plays in NFL.\nClub(minnesotaVikings) ::: Minnesota Vikings is a football club.\nCoach(dennisGreen) ∧ Coach(minnesotaVikings) ::: Dennis Green coached Minnesota Vikings.\nTouchdownReceptions(crisCarter, 13) ::: Cris Carter had 13 touchdown receptions.\nClub(minnesotaVikings) ∧ NFL(minnesotaVikings, 1997) ::: Minnesota Vikings was in the National Football League in 1997.\nDefensiveTackle(johnRandle) ∧ Club(minnesotaVikings) ∧ Year(1997) ::: John Randle was Minnesota Vikings defensive tackle in 1997.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nPlaysInNFL(crisCarter) ::: Cris Carter played for Minnesota Vikings.\n\"\"\""
    ]
  },
  {
    "id": 1338,
    "context": [
      "All cats are cute.",
      "Ghosts do not exist.",
      "An animal is either a cat or a dog.",
      "Nothing that barks is lovely. ",
      "If something is a dog, then it barks.",
      "Grace is either a cat and a dog, or neither a cat nor a dog."
    ],
    "question": "Grace is a ghost.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nCute(x) ::: x is cute.\nCat(x) ::: x is a cat.\nGhost(x) ::: x is a ghost.\nAnimal(x) ::: x is an animal.\nDog(x) ::: x is a dog.\nBarks(x) ::: x barks.\nLovely(x) ::: x is lovely.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Cat(x) → Cute(x)) ::: All cats are cute.\n¬∃x Ghost(x) ::: Ghosts do not exist.\n∀x (Animal(x) ↔ (Cat(x) ∨ Dog(x))) ::: An animal is either a cat or a dog.\n¬∃x (Barks(x) ∧ Lovely(x)) ::: Nothing that barks is lovely.\n∀x (Dog(x) → Barks(x)) ::: If something is a dog, then it barks.\n(Cat(grace) ∧ Dog(grace)) ⊕ ¬(Cat(grace) ∨ Dog(grace)) ::: Grace is either a cat and a dog, or neither a cat nor a dog.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬Ghost(grace) ::: Grace is not a ghost.\n\"\"\""
    ]
  },
  {
    "id": 1339,
    "context": [
      "All cats are cute.",
      "Ghosts do not exist.",
      "An animal is either a cat or a dog.",
      "Nothing that barks is lovely. ",
      "If something is a dog, then it barks.",
      "Grace is either a cat and a dog, or neither a cat nor a dog."
    ],
    "question": "If Grace is either both cute and lovely, or neither cute nor lovely, then Grace is either a dog or a ghost.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nCute(x) ::: x is cute.\nGhost(x) ::: x is a ghost.\nAnimal(x) ::: x is an animal.\nCat(x) ::: x is a cat.\nDog(x) ::: x is a dog.\nBarks(x) ::: x barks.\nLovely(x) ::: x is lovely.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Cat(x) → Cute(x)) ::: All cats are cute.\n¬∃x Ghost(x) ::: Ghosts do not exist.\n∀x (Animal(x) ↔ (Cat(x) ∨ Dog(x))) ::: An animal is either a cat or a dog.\n¬∃x (Barks(x) ∧ Lovely(x)) ::: Nothing that barks is lovely.\n∀x (Dog(x) → Barks(x)) ::: If something is a dog, then it barks.\n(Cat(grace) ∧ Dog(grace)) ⊕ ¬(Cat(grace) ∨ Dog(grace)) ::: Grace is either a cat and a dog, or neither a cat nor a dog.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n((Cute(grace) ∧ Lovely(grace)) ∨ ¬(Cute(grace) ∨ Lovely(grace))) → (Dog(grace) ∨ Ghost(grace)) ::: If Grace is either both cute and lovely, or neither cute nor lovely, then Grace is either a dog or a ghost.\n\"\"\""
    ]
  },
  {
    "id": 1340,
    "context": [
      "All cats are cute.",
      "Ghosts do not exist.",
      "An animal is either a cat or a dog.",
      "Nothing that barks is lovely. ",
      "If something is a dog, then it barks.",
      "Grace is either a cat and a dog, or neither a cat nor a dog."
    ],
    "question": "If Grace is not both a ghost and lovely, then Grace is either a cat or cute.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nCute(x) ::: x is cute.\nCat(x) ::: x is a cat.\nGhost(x) ::: x is a ghost.\nAnimal(x) ::: x is an animal.\nDog(x) ::: x is a dog.\nBarks(x) ::: x barks.\nLovely(x) ::: x is lovely.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Cat(x) → Cute(x)) ::: All cats are cute.\n¬∃x Ghost(x) ::: Ghosts do not exist.\n∀x (Animal(x) ↔ (Cat(x) ∨ Dog(x))) ::: An animal is either a cat or a dog.\n∀x (Barks(x) → ¬Lovely(x)) ::: Nothing that barks is lovely.\n∀x (Dog(x) → Barks(x)) ::: If something is a dog, then it barks.\n(Cat(grace) ∧ Dog(grace)) ⊕ ¬(Cat(grace) ∨ Dog(grace)) ::: Grace is either a cat and a dog, or neither a cat nor a dog.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬(Ghost(grace) ∧ Lovely(grace)) → (Cat(grace) ∨ Cute(grace)) ::: If Grace is not both a ghost and lovely, then Grace is either a cat or cute.\n\"\"\""
    ]
  },
  {
    "id": 299,
    "context": [
      "Shafaq-Asiman is a large complex of offshore geological structures in the Caspian Sea.",
      "Baku is northwest of Shafaq-Asiman.",
      "If place A is northwest of place B, then place B is southeast of place A."
    ],
    "question": "Baku is southeast of Shafaq-Asiman.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nGeologicalStructure(x) ::: x is a geological structure.\nOffshore(x) ::: x is an offshore structure.\nNorthwest(x, y) ::: x is northwest of y.\nSoutheast(x, y) ::: x is southeast of y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nGeologicalStructure(shafaqAsiman) ∧ Offshore(shafaqAsiman) ::: Shafaq-Asiman is a large complex of offshore geological structures in the Caspian Sea.\nNorthwest(baku, shafaqAsiman) ::: Baku is northwest of Shafaq-Asiman.\n∀x ∀y ((Northwest(x, y)) → (Southeast(y, x))) ::: If place A is northwest of place B, then place B is southeast of place A.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nSoutheast(baku, shafaqAsiman) ::: Baku is southeast of Shafaq-Asiman.\n\"\"\""
    ]
  },
  {
    "id": 300,
    "context": [
      "Shafaq-Asiman is a large complex of offshore geological structures in the Caspian Sea.",
      "Baku is northwest of Shafaq-Asiman.",
      "If place A is northwest of place B, then place B is southeast of place A."
    ],
    "question": "A large complex is southeast of Baku.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nLargeComplex(x) ::: x is a large complex.\nOffshoreGeologicalStructure(x) ::: x is an offshore geological structure.\nIn(x, y) ::: x is in y.\nNorthwest(x, y) ::: x is northwest of y.\nSoutheast(x, y) ::: x is southeast of y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nLargeComplex(shafaqAsiman) ∧ OffshoreGeologicalStructure(shafaqAsiman) ::: Shafaq-Asiman is a large complex of offshore geological structures in the Caspian Sea.\nNorthwest(baku, shafaqAsiman) ::: Baku is northwest of Shafaq-Asiman.\n∀x ∀y ((Northwest(x, y)) → (Southeast(y, x))) ::: If place A is northwest of place B, then place B is southeast of place A.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nLargeComplex(x) ∧ Southeast(x, baku) ::: A large complex is southeast of Baku.\n\"\"\""
    ]
  },
  {
    "id": 301,
    "context": [
      "Shafaq-Asiman is a large complex of offshore geological structures in the Caspian Sea.",
      "Baku is northwest of Shafaq-Asiman.",
      "If place A is northwest of place B, then place B is southeast of place A."
    ],
    "question": "Baku is not northwest of an offshore geological structures.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nComplex(x) ::: x is a large complex of offshore geological structures.\nGeologicalStructures(x) ::: x is offshore geological structures.\nPlace(x) ::: x is a place.\nNorthwest(x, y) ::: x is northwest of y.\nSoutheast(x, y) ::: x is southeast of y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nComplex(shafaqAsiman) ∧ GeologicalStructures(shafaqAsiman) ::: Shafaq-Asiman is a large complex of offshore geological structures in the Caspian Sea.\nNorthwest(baku, shafaqAsiman) ::: Baku is northwest of Shafaq-Asiman.\n∀x ∀y ((Northwest(x, y)) → (Southeast(y, x))) ::: If place A is northwest of place B, then place B is southeast of place A.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬Northwest(baku, complex) ::: Baku is not northwest of an offshore geological structures.\n\"\"\""
    ]
  },
  {
    "id": 214,
    "context": [
      "Herodicus was a Greek physician, dietician, sophist, and gymnastic-master.",
      "Herodicus was born in the city of Selymbria.",
      "Selymbria is a colony of the city-state Megara.",
      "One of the tutors of Hippocrates was Herodicus.",
      "Massages were recommended by Herodicus.",
      "Some of theories of Herodicus are considered to be the foundation of sports medicine."
    ],
    "question": "Herodicus tutored Hippocrates.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nGreek(x) ::: x is a Greek person.\nPhysician(x) ::: x is a physician.\nDietician(x) ::: x is a dietician.\nSophist(x) ::: x is a sophist.\nGymnasticMaster(x) ::: x is a gymnastic master.\nBornIn(x, y) ::: x was born in y.\nColonyOf(x, y) ::: x is a colony of y.\nTutorOf(x, y) ::: x is a tutor of y.\nRecommend(x, y) ::: x recommends y.\nTheory(x) ::: x is a theory.\nFoundationOf(x, y) ::: x is considered the foundation of y.\nSportsMedicine(x) ::: x is sports medicine.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nGreek(herodicus) ∧ Physician(herodicus) ∧ Dietician(herodicus) ∧ Sophist(herodicus) ∧ GymnasticMaster(herodicus) ::: Herodicus was a Greek physician, dietician, sophist, and gymnastic-master.\nBornIn(herodicus, selymbria) ::: Herodicus was born in the city of Selymbria.\nColonyOf(selymbria, megara) ::: Selymbria is a colony of the city-state Megara.\nTutorOf(herodicus, hippocrates) ::: One of the tutors of Hippocrates was Herodicus.\nRecommend(herodicus, massages) ::: Massages were recommended by Herodicus.\n∃x (Theory(x) ∧ FoundationOf(x, sportsMedicine)) ::: Some of theories of Herodicus are considered to be the foundation of sports medicine.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nTutorOf(herodicus, hippocrates) ::: Herodicus tutored Hippocrates.\n\"\"\""
    ]
  },
  {
    "id": 215,
    "context": [
      "Herodicus was a Greek physician, dietician, sophist, and gymnastic-master.",
      "Herodicus was born in the city of Selymbria.",
      "Selymbria is a colony of the city-state Megara.",
      "One of the tutors of Hippocrates was Herodicus.",
      "Massages were recommended by Herodicus.",
      "Some of theories of Herodicus are considered to be the foundation of sports medicine."
    ],
    "question": "Herodicus was tutored by Hippocrates.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nGreek(x) ::: x is a Greek person.\nPhysician(x) ::: x is a physician.\nDietician(x) ::: x is a dietician.\nSophist(x) ::: x is a sophist.\nGymnasticMaster(x) ::: x is a gymnastic master.\nBornIn(x, y) ::: x was born in y.\nColonyOf(x, y) ::: x is a colony of y.\nTutorOf(x, y) ::: x is a tutor of y.\nRecommend(x, y) ::: x recommends y.\nTheory(x) ::: x is a theory.\nFoundationOf(x, y) ::: x is the foundation of y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nGreek(herodicus) ∧ Physician(herodicus) ∧ Dietician(herodicus) ∧ Sophist(herodicus) ∧ GymnasticMaster(herodicus) ::: Herodicus was a Greek physician, dietician, sophist, and gymnastic-master.\nBornIn(herodicus, selymbria) ::: Herodicus was born in the city of Selymbria.\nColonyOf(selymbria, megara) ::: Selymbria is a colony of the city-state Megara.\nTutorOf(hippocrates, herodicus) ::: One of the tutors of Hippocrates was Herodicus.\nRecommend(herodicus, massages) ::: Massages were recommended by Herodicus.\n∃x (Theory(x) ∧ FoundationOf(x, sportsMedicine)) ::: Some of theories of Herodicus are considered to be the foundation of sports medicine.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nTutorOf(herodicus, hippocrates) ::: Herodicus was tutored by Hippocrates.\n\"\"\""
    ]
  },
  {
    "id": 216,
    "context": [
      "Herodicus was a Greek physician, dietician, sophist, and gymnastic-master.",
      "Herodicus was born in the city of Selymbria.",
      "Selymbria is a colony of the city-state Megara.",
      "One of the tutors of Hippocrates was Herodicus.",
      "Massages were recommended by Herodicus.",
      "Some of theories of Herodicus are considered to be the foundation of sports medicine."
    ],
    "question": "Herodicus was born in a city-state.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nGreek(x) ::: x is a Greek person.\nPhysician(x) ::: x is a physician.\nDietician(x) ::: x is a dietician.\nSophist(x) ::: x is a sophist.\nGymnasticMaster(x) ::: x is a gymnastic-master.\nBornIn(x, y) ::: x was born in y.\nColonyOf(x, y) ::: x is a colony of y.\nTutorOf(x, y) ::: x is a tutor of y.\nRecommend(x, y) ::: x recommends y.\nTheory(x, y) ::: x is a theory of y.\nFoundationOf(x, y) ::: x is considered to be the foundation of y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nGreek(herodicus) ∧ Physician(herodicus) ∧ Dietician(herodicus) ∧ Sophist(herodicus) ∧ GymnasticMaster(herodicus) ::: Herodicus was a Greek physician, dietician, sophist, and gymnastic-master.\nBornIn(herodicus, selymbria) ::: Herodicus was born in the city of Selymbria.\nColonyOf(selymbria, megara) ::: Selymbria is a colony of the city-state Megara.\nTutorOf(herodicus, hippocrates) ::: One of the tutors of Hippocrates was Herodicus.\nRecommend(herodicus, massages) ::: Massages were recommended by Herodicus.\n∃x (Theory(x, sportsMedicine) ∧ FoundationOf(x, sportsMedicine)) ::: Some of theories of Herodicus are considered to be the foundation of sports medicine.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n∃x (BornIn(herodicus, x) ∧ ColonyOf(x, cityState)) ::: Herodicus was born in a city-state.\n\"\"\""
    ]
  },
  {
    "id": 217,
    "context": [
      "Herodicus was a Greek physician, dietician, sophist, and gymnastic-master.",
      "Herodicus was born in the city of Selymbria.",
      "Selymbria is a colony of the city-state Megara.",
      "One of the tutors of Hippocrates was Herodicus.",
      "Massages were recommended by Herodicus.",
      "Some of theories of Herodicus are considered to be the foundation of sports medicine."
    ],
    "question": "Herodicus did not recommend massages.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nGreek(x) ::: x is a Greek person.\nPhysician(x) ::: x is a physician.\nDietician(x) ::: x is a dietician.\nSophist(x) ::: x is a sophist.\nGymnasticMaster(x) ::: x is a gymnastic-master.\nBornIn(x, y) ::: x was born in y.\nColonyOf(x, y) ::: x is a colony of y.\nTutorOf(x, y) ::: x is one of the tutors of y.\nRecommendedBy(x, y) ::: x is recommended by y.\nTheory(x) ::: x is a theory.\nFoundationOf(x, y) ::: x is considered to be the foundation of y.\nSportsMedicine(x) ::: x is sports medicine.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nGreek(herodicus) ∧ Physician(herodicus) ∧ Dietician(herodicus) ∧ Sophist(herodicus) ∧ GymnasticMaster(herodicus) ::: Herodicus was a Greek physician, dietician, sophist, and gymnastic-master.\nBornIn(herodicus, selymbria) ::: Herodicus was born in the city of Selymbria.\nColonyOf(selymbria, megara) ::: Selymbria is a colony of the city-state Megara.\nTutorOf(herodicus, hippocrates) ::: One of the tutors of Hippocrates was Herodicus.\nRecommendedBy(massages, herodicus) ::: Massages were recommended by Herodicus.\n∃x (Theory(x) ∧ FoundationOf(x, sportsMedicine)) ::: Some of theories of Herodicus are considered to be the foundation of sports medicine.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬RecommendedBy(massages, herodicus) ::: Herodicus did not recommend massages.\n\"\"\""
    ]
  },
  {
    "id": 218,
    "context": [
      "Herodicus was a Greek physician, dietician, sophist, and gymnastic-master.",
      "Herodicus was born in the city of Selymbria.",
      "Selymbria is a colony of the city-state Megara.",
      "One of the tutors of Hippocrates was Herodicus.",
      "Massages were recommended by Herodicus.",
      "Some of theories of Herodicus are considered to be the foundation of sports medicine."
    ],
    "question": "Herodicus was born in a colony of a city-state.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nGreek(x) ::: x is a Greek person.\nPhysician(x) ::: x is a physician.\nDietician(x) ::: x is a dietician.\nSophist(x) ::: x is a sophist.\nGymnasticMaster(x) ::: x is a gymnastic-master.\nBornIn(x, y) ::: x was born in y.\nColony(x, y) ::: x is a colony of y.\nTutorOf(x, y) ::: x is a tutor of y.\nRecommend(x, y) ::: x recommends y.\nTheory(x, y) ::: x is a theory of y.\nSportsMedicine(x) ::: x is related to sports medicine.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nGreek(herodicus) ∧ Physician(herodicus) ∧ Dietician(herodicus) ∧ Sophist(herodicus) ∧ GymnasticMaster(herodicus) ::: Herodicus was a Greek physician, dietician, sophist, and gymnastic-master.\nBornIn(herodicus, selymbria) ::: Herodicus was born in the city of Selymbria.\nColony(selymbria, megara) ::: Selymbria is a colony of the city-state Megara.\nTutorOf(herodicus, hippocrates) ::: One of the tutors of Hippocrates was Herodicus.\nRecommend(herodicus, massages) ::: Massages were recommended by Herodicus.\n∃x (Theory(x, herodicus) ∧ SportsMedicine(x)) ::: Some of theories of Herodicus are considered to be the foundation of sports medicine.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n∃x (Colony(bornIn(herodicus, x), cityState(x))) ::: Herodicus was born in a colony of a city-state.\n\"\"\""
    ]
  },
  {
    "id": 1263,
    "context": [
      "No kid loves the Opera.",
      "All adults love the Opera.",
      "If someone is a scientist, then they are an adult.",
      "Some students are kids.",
      "Billy is a kid."
    ],
    "question": "Billy is a student.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nLoves(x, y) ::: x loves y.\nOpera(x) ::: x loves the Opera.\nAdult(x) ::: x is an adult.\nScientist(x) ::: x is a scientist.\nStudent(x) ::: x is a student.\nKid(x) ::: x is a kid.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Kid(x) → ¬Loves(x, Opera)) ::: No kid loves the Opera.\n∀x (Adult(x) → Loves(x, Opera)) ::: All adults love the Opera.\n∀x (Scientist(x) → Adult(x)) ::: If someone is a scientist, then they are an adult.\n∃x (Student(x) ∧ Kid(x)) ::: Some students are kids.\nKid(billy) ::: Billy is a kid.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n∃x (Student(x) ∧ x = billy) ::: Billy is a student.\n\"\"\""
    ]
  },
  {
    "id": 1264,
    "context": [
      "No kid loves the Opera.",
      "All adults love the Opera.",
      "If someone is a scientist, then they are an adult.",
      "Some students are kids.",
      "Billy is a kid."
    ],
    "question": "Billy is a student and a scientist.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nLoves(x, y) ::: x loves y.\nOpera(x) ::: x loves the Opera.\nAdult(x) ::: x is an adult.\nScientist(x) ::: x is a scientist.\nStudent(x) ::: x is a student.\nKid(x) ::: x is a kid.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Kid(x) → ¬Loves(x, Opera)) ::: No kid loves the Opera.\n∀x (Adult(x) → Loves(x, Opera)) ::: All adults love the Opera.\n∀x (Scientist(x) → Adult(x)) ::: If someone is a scientist, then they are an adult.\n∃x (Student(x) ∧ Kid(x)) ::: Some students are kids.\nKid(billy) ::: Billy is a kid.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nStudent(billy) ∧ Scientist(billy) ::: Billy is a student and a scientist.\n\"\"\""
    ]
  },
  {
    "id": 1265,
    "context": [
      "No kid loves the Opera.",
      "All adults love the Opera.",
      "If someone is a scientist, then they are an adult.",
      "Some students are kids.",
      "Billy is a kid."
    ],
    "question": "If Billy is a student or a scientist, then Billy is a student and a kid.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nLoves(x, y) ::: x loves y.\nOpera(x) ::: x loves the Opera.\nAdult(x) ::: x is an adult.\nScientist(x) ::: x is a scientist.\nStudent(x) ::: x is a student.\nKid(x) ::: x is a kid.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Kid(x) → ¬Loves(x, Opera)) ::: No kid loves the Opera.\n∀x (Adult(x) → Loves(x, Opera)) ::: All adults love the Opera.\n∀x (Scientist(x) → Adult(x)) ::: If someone is a scientist, then they are an adult.\n∃x (Student(x) ∧ Kid(x)) ::: Some students are kids.\nKid(billy) ::: Billy is a kid.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n(Student(billy) ∨ Scientist(billy)) → (Student(billy) ∧ Kid(billy)) ::: If Billy is a student or a scientist, then Billy is a student and a kid.\n\"\"\""
    ]
  },
  {
    "id": 205,
    "context": [
      "Brian Winter is a Scottish football referee.",
      "After being injured, Brian Winter retired in 2012.",
      "Brian Winter was appointed as a referee observer after his retirement.",
      "Some football referees become referee observers.",
      "The son of Brian Winter, Andy Winter, is a football player who plays for Hamilton Academical."
    ],
    "question": "There is a son of a referee observer that plays football.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nScottish(x) ::: x is Scottish.\nReferee(x) ::: x is a football referee.\nRetired(x, y) ::: x retired in year y.\nObserver(x) ::: x is a referee observer.\nBecome(x, y) ::: x becomes y.\nSon(x, y) ::: x is the son of y.\nFootballPlayer(x) ::: x is a football player.\nPlayFor(x, y) ::: x plays for y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nScottish(brian) ∧ Referee(brian) ::: Brian Winter is a Scottish football referee.\nRetired(brian, 2012) ::: After being injured, Brian Winter retired in 2012.\nObserver(brian) ∧ Appointed(brian) ::: Brian Winter was appointed as a referee observer after his retirement.\n∃x (Referee(x) ∧ Become(x, observer)) ::: Some football referees become referee observers.\nSon(andy, brian) ∧ FootballPlayer(andy) ∧ PlayFor(andy, hamiltonAcademical) ::: The son of Brian Winter, Andy Winter, is a football player who plays for Hamilton Academical.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n∃x (Son(x, y) ∧ FootballPlayer(x)) ::: There is a son of a referee observer that plays football.\n\"\"\""
    ]
  },
  {
    "id": 206,
    "context": [
      "Brian Winter is a Scottish football referee.",
      "After being injured, Brian Winter retired in 2012.",
      "Brian Winter was appointed as a referee observer after his retirement.",
      "Some football referees become referee observers.",
      "The son of Brian Winter, Andy Winter, is a football player who plays for Hamilton Academical."
    ],
    "question": "Brian Winter is not a referee observer.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nScottish(x) ::: x is Scottish.\nReferee(x) ::: x is a football referee.\nRetired(x, y) ::: x retired in year y.\nObserver(x) ::: x is a referee observer.\nSon(x, y) ::: x is the son of y.\nFootballPlayer(x) ::: x is a football player.\nPlaysFor(x, y) ::: x plays for team y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nScottish(brian) ∧ Referee(brian) ::: Brian Winter is a Scottish football referee.\nRetired(brian, 2012) ::: After being injured, Brian Winter retired in 2012.\nObserver(brian) ∧ Son(andy, brian) ∧ FootballPlayer(andy) ∧ PlaysFor(andy, hamiltonAcademical) ::: Brian Winter was appointed as a referee observer after his retirement. The son of Brian Winter, Andy Winter, is a football player who plays for Hamilton Academical.\n∃x (Referee(x) ∧ Observer(x)) ::: Some football referees become referee observers.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬Observer(brian) ::: Brian Winter is not a referee observer.\n\"\"\""
    ]
  },
  {
    "id": 207,
    "context": [
      "Brian Winter is a Scottish football referee.",
      "After being injured, Brian Winter retired in 2012.",
      "Brian Winter was appointed as a referee observer after his retirement.",
      "Some football referees become referee observers.",
      "The son of Brian Winter, Andy Winter, is a football player who plays for Hamilton Academical."
    ],
    "question": "Brian Winter is retired.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nScottish(x) ::: x is Scottish.\nReferee(x) ::: x is a football referee.\nRetired(x) ::: x is retired.\nObserver(x) ::: x is a referee observer.\nPlayer(x) ::: x is a football player.\nPlaysFor(x, y) ::: x plays for team y.\nSon(x, y) ::: x is the son of y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nScottish(brian) ∧ Referee(brian) ::: Brian Winter is a Scottish football referee.\nInjured(brian) ∧ Retired(brian, 2012) ::: After being injured, Brian Winter retired in 2012.\nRetired(brian, 2012) → Observer(brian) ::: Brian Winter was appointed as a referee observer after his retirement.\n∃x (Referee(x) ∧ Observer(x)) ::: Some football referees become referee observers.\nPlayer(andy) ∧ PlaysFor(andy, hamiltonAcademical) ∧ Son(andy, brian) ::: The son of Brian Winter, Andy Winter, is a football player who plays for Hamilton Academical.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nRetired(brian, 2012) ::: Brian Winter is retired.\n\"\"\""
    ]
  },
  {
    "id": 208,
    "context": [
      "Brian Winter is a Scottish football referee.",
      "After being injured, Brian Winter retired in 2012.",
      "Brian Winter was appointed as a referee observer after his retirement.",
      "Some football referees become referee observers.",
      "The son of Brian Winter, Andy Winter, is a football player who plays for Hamilton Academical."
    ],
    "question": "Andy Winter is a referee.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nScottish(x) ::: x is Scottish.\nFootballReferee(x) ::: x is a football referee.\nRetired(x, y) ::: x retired in year y.\nObserver(x) ::: x is a referee observer.\nSon(x, y) ::: x is the son of y.\nFootballPlayer(x) ::: x is a football player.\nPlaysFor(x, y) ::: x plays for team y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nScottish(brian) ∧ FootballReferee(brian) ::: Brian Winter is a Scottish football referee.\nRetired(brian, 2012) ::: After being injured, Brian Winter retired in 2012.\nObserver(brian) ::: Brian Winter was appointed as a referee observer after his retirement.\n∃x (FootballReferee(x) ∧ Observer(x)) ::: Some football referees become referee observers.\nSon(andy, brian) ∧ FootballPlayer(andy) ∧ PlaysFor(andy, hamiltonAcademical) ::: The son of Brian Winter, Andy Winter, is a football player who plays for Hamilton Academical.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬FootballReferee(andy) ::: Andy Winter is not a referee.\n\"\"\""
    ]
  },
  {
    "id": 1105,
    "context": [
      "People are either interested in puzzles or bad at chess.",
      "If a person is bad at chess, then they don't play a lot of chess.",
      "A person is either a planner or a creative person.",
      "Erica is someone who plays a lot of chess.",
      "If Erica is neither bad at chess nor creative, then Erica is either someone who plans and is creative, or someone who neither plans nor is creative."
    ],
    "question": "Erica plans.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nInterested(x) ::: x is interested in puzzles.\nBadAtChess(x) ::: x is bad at chess.\nPlayALotOfChess(x) ::: x plays a lot of chess.\nPlanner(x) ::: x is a planner.\nCreative(x) ::: x is a creative person.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Interested(x) ∨ BadAtChess(x)) ::: People are either interested in puzzles or bad at chess.\nBadAtChess(x) → ¬PlayALotOfChess(x) ::: If a person is bad at chess, then they don't play a lot of chess.\n∀x (Planner(x) ∨ Creative(x)) ::: A person is either a planner or a creative person.\nPlayALotOfChess(erica) ::: Erica is someone who plays a lot of chess.\n¬(BadAtChess(erica) ∨ Creative(erica)) → (Planner(erica) ∧ Creative(erica)) ⊕ (¬Planner(erica) ∧ ¬Creative(erica)) ::: If Erica is neither bad at chess nor creative, then Erica is either someone who plans and is creative, or someone who neither plans nor is creative.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nPlanner(erica) ::: Erica plans.\n\"\"\""
    ]
  },
  {
    "id": 1106,
    "context": [
      "People are either interested in puzzles or bad at chess.",
      "If a person is bad at chess, then they don't play a lot of chess.",
      "A person is either a planner or a creative person.",
      "Erica is someone who plays a lot of chess.",
      "If Erica is neither bad at chess nor creative, then Erica is either someone who plans and is creative, or someone who neither plans nor is creative."
    ],
    "question": "Erica is interested in puzzles and is creative.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nInterestedIn(x, y) ::: x is interested in y.\nBadAtChess(x) ::: x is bad at chess.\nPlayALotOfChess(x) ::: x plays a lot of chess.\nPlanner(x) ::: x is a planner.\nCreative(x) ::: x is a creative person.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (InterestedIn(x, puzzles) ∨ BadAtChess(x)) ::: People are either interested in puzzles or bad at chess.\nBadAtChess(x) → ¬PlayALotOfChess(x) ::: If a person is bad at chess, then they don't play a lot of chess.\n∀x (Planner(x) ∨ Creative(x)) ::: A person is either a planner or a creative person.\nPlayALotOfChess(erica) ::: Erica is someone who plays a lot of chess.\n¬(BadAtChess(erica) ∨ Creative(erica)) → (Planner(erica) ∧ Creative(erica)) ⊕ (¬Planner(erica) ∧ ¬Creative(erica)) ::: If Erica is neither bad at chess nor creative, then Erica is either someone who plans and is creative, or someone who neither plans nor is creative.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nInterestedIn(erica, puzzles) ∧ Creative(erica) ::: Erica is interested in puzzles and is creative.\n\"\"\""
    ]
  },
  {
    "id": 1107,
    "context": [
      "People are either interested in puzzles or bad at chess.",
      "If a person is bad at chess, then they don't play a lot of chess.",
      "A person is either a planner or a creative person.",
      "Erica is someone who plays a lot of chess.",
      "If Erica is neither bad at chess nor creative, then Erica is either someone who plans and is creative, or someone who neither plans nor is creative."
    ],
    "question": "Erica is either interested in puzzles or is creative.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nInterestedIn(x) ::: x is interested in puzzles.\nBadAtChess(x) ::: x is bad at chess.\nPlayALotOfChess(x) ::: x plays a lot of chess.\nPlanner(x) ::: x is a planner.\nCreative(x) ::: x is a creative person.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (InterestedIn(x) ∨ BadAtChess(x)) ::: People are either interested in puzzles or bad at chess.\nBadAtChess(x) → ¬PlayALotOfChess(x) ::: If a person is bad at chess, then they don't play a lot of chess.\n∀x (Planner(x) ∨ Creative(x)) ::: A person is either a planner or a creative person.\nPlayALotOfChess(erica) ::: Erica is someone who plays a lot of chess.\n¬(BadAtChess(erica) ∨ Creative(erica)) → (Planner(erica) ∧ Creative(erica)) ⊕ (¬Planner(erica) ∧ ¬Creative(erica)) ::: If Erica is neither bad at chess nor creative, then Erica is either someone who plans and is creative, or someone who neither plans nor is creative.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nInterestedIn(erica) ∨ Creative(erica) ::: Erica is either interested in puzzles or is creative.\n\"\"\""
    ]
  },
  {
    "id": 1108,
    "context": [
      "People are either interested in puzzles or bad at chess.",
      "If a person is bad at chess, then they don't play a lot of chess.",
      "A person is either a planner or a creative person.",
      "Erica is someone who plays a lot of chess.",
      "If Erica is neither bad at chess nor creative, then Erica is either someone who plans and is creative, or someone who neither plans nor is creative."
    ],
    "question": "If Erica plans ahead or plays a lot of chess matches, then Erica is not interested in puzzles and creative.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nInterestedIn(x, y) ::: x is interested in y.\nBadAt(x, y) ::: x is bad at y.\nPlayALotOf(x, y) ::: x plays a lot of y.\nPlanner(x) ::: x is a planner.\nCreative(x) ::: x is a creative person.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (InterestedIn(x, puzzles) ∨ BadAt(x, chess)) ::: People are either interested in puzzles or bad at chess.\n∀x (BadAt(x, chess) → ¬PlayALotOf(x, chess)) ::: If a person is bad at chess, then they don't play a lot of chess.\n∀x (Planner(x) ∨ Creative(x)) ::: A person is either a planner or a creative person.\nPlayALotOf(erica, chess) ::: Erica is someone who plays a lot of chess.\n¬(BadAt(erica, chess) ∨ Creative(erica)) → ((Planner(erica) ∧ Creative(erica)) ∨ (¬Planner(erica) ∧ ¬Creative(erica))) ::: If Erica is neither bad at chess nor creative, then Erica is either someone who plans and is creative, or someone who neither plans nor is creative.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n(Planner(erica) ∨ PlayALotOf(erica, chess)) → (¬InterestedIn(erica, puzzles) ∧ ¬Creative(erica)) ::: If Erica plans ahead or plays a lot of chess matches, then Erica is not interested in puzzles and creative.\n\"\"\""
    ]
  },
  {
    "id": 1109,
    "context": [
      "People are either interested in puzzles or bad at chess.",
      "If a person is bad at chess, then they don't play a lot of chess.",
      "A person is either a planner or a creative person.",
      "Erica is someone who plays a lot of chess.",
      "If Erica is neither bad at chess nor creative, then Erica is either someone who plans and is creative, or someone who neither plans nor is creative."
    ],
    "question": "If Erica is creative, then Erica is not interested in puzzles and creative.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nInterestedIn(x, y) ::: x is interested in y.\nBadAt(x, y) ::: x is bad at y.\nPlayALotOf(x, y) ::: x plays a lot of y.\nPlanner(x) ::: x is a planner.\nCreative(x) ::: x is a creative person.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (InterestedIn(x, puzzles) ⊕ BadAt(x, chess)) ::: People are either interested in puzzles or bad at chess.\nBadAt(x, chess) → ¬PlayALotOf(x, chess) ::: If a person is bad at chess, then they don't play a lot of chess.\n∀x (Planner(x) ⊕ Creative(x)) ::: A person is either a planner or a creative person.\nPlayALotOf(erica, chess) ::: Erica is someone who plays a lot of chess.\n¬(BadAt(erica, chess) ∨ Creative(erica)) → (Planner(erica) ∧ Creative(erica)) ⊕ ¬(Planner(erica) ∨ Creative(erica)) ::: If Erica is neither bad at chess nor creative, then Erica is either someone who plans and is creative, or someone who neither plans nor is creative.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nCreative(erica) → ¬(InterestedIn(erica, puzzles) ∧ Creative(erica)) ::: If Erica is creative, then Erica is not interested in puzzles and creative.\n\"\"\""
    ]
  },
  {
    "id": 1110,
    "context": [
      "People are either interested in puzzles or bad at chess.",
      "If a person is bad at chess, then they don't play a lot of chess.",
      "A person is either a planner or a creative person.",
      "Erica is someone who plays a lot of chess.",
      "If Erica is neither bad at chess nor creative, then Erica is either someone who plans and is creative, or someone who neither plans nor is creative."
    ],
    "question": "If Erica is interested in puzzles and is creative, then Erica is not creative.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nInterestedIn(x) ::: x is interested in puzzles.\nBadAtChess(x) ::: x is bad at chess.\nPlayALotOfChess(x) ::: x plays a lot of chess.\nPlanner(x) ::: x is a planner.\nCreative(x) ::: x is a creative person.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (InterestedIn(x) ∨ BadAtChess(x)) ::: People are either interested in puzzles or bad at chess.\n∀x (BadAtChess(x) → ¬PlayALotOfChess(x)) ::: If a person is bad at chess, then they don't play a lot of chess.\n∀x (Planner(x) ∨ Creative(x)) ::: A person is either a planner or a creative person.\nPlayALotOfChess(erica) ::: Erica is someone who plays a lot of chess.\n¬(BadAtChess(erica) ∨ Creative(erica)) → ((Planner(erica) ∧ Creative(erica)) ∨ (¬Planner(erica) ∧ ¬Creative(erica))) ::: If Erica is neither bad at chess nor creative, then Erica is either someone who plans and is creative, or someone who neither plans nor is creative.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n(InterestedIn(erica) ∧ Creative(erica)) → ¬Creative(erica) ::: If Erica is interested in puzzles and is creative, then Erica is not creative.\n\"\"\""
    ]
  },
  {
    "id": 1111,
    "context": [
      "People are either interested in puzzles or bad at chess.",
      "If a person is bad at chess, then they don't play a lot of chess.",
      "A person is either a planner or a creative person.",
      "Erica is someone who plays a lot of chess.",
      "If Erica is neither bad at chess nor creative, then Erica is either someone who plans and is creative, or someone who neither plans nor is creative."
    ],
    "question": "If Erica either plays a lot of chess matches or is creative, then Erica is neither interested in puzzles nor a person who plays a lot of chess matches.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nInterestedIn(x, y) ::: x is interested in y.\nBadAt(x, y) ::: x is bad at y.\nPlayALotOf(x, y) ::: x plays a lot of y.\nPlanner(x) ::: x is a planner.\nCreative(x) ::: x is a creative person.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (InterestedIn(x, puzzles) ∨ BadAt(x, chess)) ::: People are either interested in puzzles or bad at chess.\nBadAt(x, chess) → ¬PlayALotOf(x, chess) ::: If a person is bad at chess, then they don't play a lot of chess.\n∀x (Planner(x) ∨ Creative(x)) ::: A person is either a planner or a creative person.\nPlayALotOf(erica, chess) ::: Erica is someone who plays a lot of chess.\n¬(BadAt(erica, chess) ∨ Creative(erica)) → (Planner(erica) ∧ Creative(erica)) ∨ (¬Planner(erica) ∧ ¬Creative(erica)) ::: If Erica is neither bad at chess nor creative, then Erica is either someone who plans and is creative, or someone who neither plans nor is creative.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n(PlayALotOf(erica, chess) ∨ Creative(erica)) → ¬(InterestedIn(erica, puzzles) ∨ PlayALotOf(erica, chess)) ::: If Erica either plays a lot of chess matches or is creative, then Erica is neither interested in puzzles nor a person who plays a lot of chess matches.\n\"\"\""
    ]
  },
  {
    "id": 1112,
    "context": [
      "People are either interested in puzzles or bad at chess.",
      "If a person is bad at chess, then they don't play a lot of chess.",
      "A person is either a planner or a creative person.",
      "Erica is someone who plays a lot of chess.",
      "If Erica is neither bad at chess nor creative, then Erica is either someone who plans and is creative, or someone who neither plans nor is creative."
    ],
    "question": "If Erica is interested in puzzles and plays a lot of chess matches, then Erica is either a person who plays a lot of chess matches or a person that is creative.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nInterestedIn(x, y) ::: x is interested in y.\nBadAt(x, y) ::: x is bad at y.\nPlayALotOf(x, y) ::: x plays a lot of y.\nPlanner(x) ::: x is a planner.\nCreative(x) ::: x is a creative person.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (InterestedIn(x, puzzles) ∨ BadAt(x, chess)) ::: People are either interested in puzzles or bad at chess.\n∀x (BadAt(x, chess) → ¬PlayALotOf(x, chess)) ::: If a person is bad at chess, then they don't play a lot of chess.\n∀x (Planner(x) ∨ Creative(x)) ::: A person is either a planner or a creative person.\nPlayALotOf(erica, chess) ::: Erica is someone who plays a lot of chess.\n¬(BadAt(erica, chess) ∨ Creative(erica)) → ((Planner(erica) ∧ Creative(erica)) ∨ ¬(Planner(erica) ∨ Creative(erica))) ::: If Erica is neither bad at chess nor creative, then Erica is either someone who plans and is creative, or someone who neither plans nor is creative.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n(InterestedIn(erica, puzzles) ∧ PlayALotOf(erica, chess)) → (PlayALotOf(erica, chess) ∨ Creative(erica)) ::: If Erica is interested in puzzles and plays a lot of chess matches, then Erica is either a person who plays a lot of chess matches or a person that is creative.\n\"\"\""
    ]
  },
  {
    "id": 1113,
    "context": [
      "People are either interested in puzzles or bad at chess.",
      "If a person is bad at chess, then they don't play a lot of chess.",
      "A person is either a planner or a creative person.",
      "Erica is someone who plays a lot of chess.",
      "If Erica is neither bad at chess nor creative, then Erica is either someone who plans and is creative, or someone who neither plans nor is creative."
    ],
    "question": "If Erica plans ahead or is interested in puzzles, then Erica is creative.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nInterestedIn(x, y) ::: x is interested in y.\nBadAt(x, y) ::: x is bad at y.\nPlayALotOf(x, y) ::: x plays a lot of y.\nPlanner(x) ::: x is a planner.\nCreative(x) ::: x is a creative person.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (InterestedIn(x, puzzles) ∨ BadAt(x, chess)) ::: People are either interested in puzzles or bad at chess.\n∀x (BadAt(x, chess) → ¬PlayALotOf(x, chess)) ::: If a person is bad at chess, then they don't play a lot of chess.\n∀x (Planner(x) ∨ Creative(x)) ::: A person is either a planner or a creative person.\nPlayALotOf(erica, chess) ::: Erica is someone who plays a lot of chess.\n¬(BadAt(erica, chess) ∨ Creative(erica)) → (Planner(erica) ∧ Creative(erica)) ⊕ (¬Planner(erica) ∧ ¬Creative(erica)) ::: If Erica is neither bad at chess nor creative, then Erica is either someone who plans and is creative, or someone who neither plans nor is creative.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n(Planner(erica) ∨ InterestedIn(erica, puzzles)) → Creative(erica) ::: If Erica plans ahead or is interested in puzzles, then Erica is creative.\n\"\"\""
    ]
  },
  {
    "id": 1114,
    "context": [
      "People are either interested in puzzles or bad at chess.",
      "If a person is bad at chess, then they don't play a lot of chess.",
      "A person is either a planner or a creative person.",
      "Erica is someone who plays a lot of chess.",
      "If Erica is neither bad at chess nor creative, then Erica is either someone who plans and is creative, or someone who neither plans nor is creative."
    ],
    "question": "If Erica is either bad at chess or interested in puzzles, then Erica is not a person who plays a lot of chess matches and creative.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nInterestedIn(x, y) ::: x is interested in y.\nBadAt(x, y) ::: x is bad at y.\nPlayALotOf(x, y) ::: x plays a lot of y.\nPlanner(x) ::: x is a planner.\nCreative(x) ::: x is a creative person.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (InterestedIn(x, puzzles) ∨ BadAt(x, chess)) ::: People are either interested in puzzles or bad at chess.\n∀x (BadAt(x, chess) → ¬PlayALotOf(x, chess)) ::: If a person is bad at chess, then they don't play a lot of chess.\n∀x (Planner(x) ∨ Creative(x)) ::: A person is either a planner or a creative person.\nPlayALotOf(erica, chess) ::: Erica is someone who plays a lot of chess.\n¬(BadAt(erica, chess) ∨ Creative(erica)) → (Planner(erica) ∧ Creative(erica)) ⊕ (¬Planner(erica) ∧ ¬Creative(erica)) ::: If Erica is neither bad at chess nor creative, then Erica is either someone who plans and is creative, or someone who neither plans nor is creative.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n(BadAt(erica, chess) ∨ InterestedIn(erica, puzzles)) → ¬(PlayALotOf(erica, chess) ∧ Creative(erica)) ::: If Erica is either bad at chess or interested in puzzles, then Erica is not a person who plays a lot of chess matches and creative.\n\"\"\""
    ]
  },
  {
    "id": 374,
    "context": [
      "Soccer players have a right foot and a left foot.",
      "Top soccer players are soccer players who can use their both feet very efficiently.",
      "If a soccer player can score many goals using left foot, then they can use that foot very efficiently.",
      "If a soccer player can score many goals using right foot, then they can use that foot very efficiently.",
      "Cristiano Ronaldo is a soccer player.",
      "Cristiano Ronaldo can use his right foot very efficiently.",
      "Cristiano Ronaldo have scored more than one hundred goals using his left foot."
    ],
    "question": "Cristiano Ronaldo is a top soccer player.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nSoccerPlayer(x) ::: x is a soccer player.\nRightFoot(x) ::: x has a right foot.\nLeftFoot(x) ::: x has a left foot.\nEfficient(x) ::: x can use their foot efficiently.\nScoreManyGoalsLeft(x) ::: x can score many goals using their left foot.\nScoreManyGoalsRight(x) ::: x can score many goals using their right foot.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (SoccerPlayer(x) → (RightFoot(x) ∧ LeftFoot(x))) ::: Soccer players have a right foot and a left foot.\n∀x (TopSoccerPlayer(x) ↔ (SoccerPlayer(x) ∧ Efficient(x))) ::: Top soccer players are soccer players who can use their both feet very efficiently.\n∀x (ScoreManyGoalsLeft(x) → Efficient(x)) ::: If a soccer player can score many goals using left foot, then they can use that foot very efficiently.\n∀x (ScoreManyGoalsRight(x) → Efficient(x)) ::: If a soccer player can score many goals using right foot, then they can use that foot very efficiently.\nSoccerPlayer(cristianoRonaldo) ::: Cristiano Ronaldo is a soccer player.\nRightFoot(cristianoRonaldo) ::: Cristiano Ronaldo can use his right foot very efficiently.\nScoreManyGoalsLeft(cristianoRonaldo) ::: Cristiano Ronaldo have scored more than one hundred goals using his left foot.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nTopSoccerPlayer(cristianoRonaldo) ::: Cristiano Ronaldo is a top soccer player.\n\"\"\""
    ]
  },
  {
    "id": 375,
    "context": [
      "Soccer players have a right foot and a left foot.",
      "Top soccer players are soccer players who can use their both feet very efficiently.",
      "If a soccer player can score many goals using left foot, then they can use that foot very efficiently.",
      "If a soccer player can score many goals using right foot, then they can use that foot very efficiently.",
      "Cristiano Ronaldo is a soccer player.",
      "Cristiano Ronaldo can use his right foot very efficiently.",
      "Cristiano Ronaldo have scored more than one hundred goals using his left foot."
    ],
    "question": "Cristiano Ronaldo is not a top soccer player.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nSoccerPlayer(x) ::: x is a soccer player.\nRightFoot(x) ::: x has a right foot.\nLeftFoot(x) ::: x has a left foot.\nTopSoccerPlayer(x) ::: x is a top soccer player.\nEfficient(x) ::: x can use their foot efficiently.\nScoreManyGoalsLeft(x) ::: x can score many goals using left foot.\nScoreManyGoalsRight(x) ::: x can score many goals using right foot.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (SoccerPlayer(x) → (RightFoot(x) ∧ LeftFoot(x))) ::: Soccer players have a right foot and a left foot.\n∀x (TopSoccerPlayer(x) → (SoccerPlayer(x) ∧ Efficient(x))) ::: Top soccer players are soccer players who can use their both feet very efficiently.\n∀x (ScoreManyGoalsLeft(x) → Efficient(x)) ::: If a soccer player can score many goals using left foot, then they can use that foot very efficiently.\n∀x (ScoreManyGoalsRight(x) → Efficient(x)) ::: If a soccer player can score many goals using right foot, then they can use that foot very efficiently.\nSoccerPlayer(cristiano) ::: Cristiano Ronaldo is a soccer player.\nRightFoot(cristiano) ∧ Efficient(cristiano) ::: Cristiano Ronaldo can use his right foot very efficiently.\nScoreManyGoalsLeft(cristiano) ::: Cristiano Ronaldo have scored more than one hundred goals using his left foot.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬TopSoccerPlayer(cristiano) ::: Cristiano Ronaldo is not a top soccer player.\n\"\"\""
    ]
  },
  {
    "id": 512,
    "context": [
      "The National Lobster Hatchery is a hatchery located in Padstow England.",
      "The National Lobster Hatchery is open to visitors.",
      "A hatchery is either for profit, or for conservation.",
      "If a hatchery is for conservation, it might release animals into the wild.",
      "The National Lobster Hatchery is not for profit."
    ],
    "question": "The National Lobster Hatchery is for conservation.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nLocatedIn(x, y) ::: x is located in y.\nOpenToVisitors(x) ::: x is open to visitors.\nForProfit(x) ::: x is for profit.\nForConservation(x) ::: x is for conservation.\nReleaseAnimals(x) ::: x releases animals into the wild.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nLocatedIn(nationalLobsterHatchery, padstowEngland) ::: The National Lobster Hatchery is a hatchery located in Padstow England.\nOpenToVisitors(nationalLobsterHatchery) ::: The National Lobster Hatchery is open to visitors.\n∀x (Hatchery(x) → (ForProfit(x) ∨ ForConservation(x))) ::: A hatchery is either for profit, or for conservation.\n(ForConservation(x) → ReleaseAnimals(x)) ::: If a hatchery is for conservation, it might release animals into the wild.\n¬ForProfit(nationalLobsterHatchery) ::: The National Lobster Hatchery is not for profit.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nForConservation(nationalLobsterHatchery) ::: The National Lobster Hatchery is for conservation.\n\"\"\""
    ]
  },
  {
    "id": 513,
    "context": [
      "The National Lobster Hatchery is a hatchery located in Padstow England.",
      "The National Lobster Hatchery is open to visitors.",
      "A hatchery is either for profit, or for conservation.",
      "If a hatchery is for conservation, it might release animals into the wild.",
      "The National Lobster Hatchery is not for profit."
    ],
    "question": "All hatcheries are open to visitors.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nHatchery(x) ::: x is a hatchery.\nLocatedIn(x, y) ::: x is located in y.\nOpenToVisitors(x) ::: x is open to visitors.\nForProfit(x) ::: x is for profit.\nForConservation(x) ::: x is for conservation.\nRelease(x, y) ::: x releases y into the wild.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nLocatedIn(nationalLobsterHatchery, padstowEngland) ::: The National Lobster Hatchery is a hatchery located in Padstow England.\nOpenToVisitors(nationalLobsterHatchery) ::: The National Lobster Hatchery is open to visitors.\n∀x (Hatchery(x) → (ForProfit(x) ∨ ForConservation(x))) ::: A hatchery is either for profit, or for conservation.\n∀x (ForConservation(x) → Release(x, animals)) ::: If a hatchery is for conservation, it might release animals into the wild.\n¬ForProfit(nationalLobsterHatchery) ::: The National Lobster Hatchery is not for profit.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n∀x (Hatchery(x) → OpenToVisitors(x)) ::: All hatcheries are open to visitors.\n\"\"\""
    ]
  },
  {
    "id": 514,
    "context": [
      "The National Lobster Hatchery is a hatchery located in Padstow England.",
      "The National Lobster Hatchery is open to visitors.",
      "A hatchery is either for profit, or for conservation.",
      "If a hatchery is for conservation, it might release animals into the wild.",
      "The National Lobster Hatchery is not for profit."
    ],
    "question": "The National Lobster Hatchery releases animals into the wild.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nLocatedIn(x, y) ::: x is located in y.\nOpenTo(x, y) ::: x is open to visitors.\nHatchery(x) ::: x is a hatchery.\nForProfit(x) ::: x is for profit.\nForConservation(x) ::: x is for conservation.\nRelease(x, y) ::: x releases animals into y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nLocatedIn(nationalLobsterHatchery, padstowEngland) ::: The National Lobster Hatchery is a hatchery located in Padstow England.\nOpenTo(nationalLobsterHatchery, visitors) ::: The National Lobster Hatchery is open to visitors.\n∀x (Hatchery(x) → (ForProfit(x) ∨ ForConservation(x))) ::: A hatchery is either for profit, or for conservation.\n(ForConservation(nationalLobsterHatchery) → Release(nationalLobsterHatchery, wild)) ::: If a hatchery is for conservation, it might release animals into the wild.\n¬ForProfit(nationalLobsterHatchery) ::: The National Lobster Hatchery is not for profit.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nRelease(nationalLobsterHatchery, wild) ::: The National Lobster Hatchery releases animals into the wild.\n\"\"\""
    ]
  },
  {
    "id": 636,
    "context": [
      "Rhos Aelwyd F.C. is a Welsh football club.",
      "Rhos Aelwyd F.C. is the only club based in Ponciau. ",
      "The Premier Division was won in 2005–06 by a team from Ponciau. ",
      "The winner of the Premier Division in 2009–10 was promoted back to the Cymru Alliance.",
      "The Premier Division in 2009–10 was won by the same team that won in 2005-06. "
    ],
    "question": "Rhos Aelwyd F.C. won the 2005-06 Premier Division.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nFootballClub(x) ::: x is a football club.\nWelsh(x) ::: x is Welsh.\nBasedIn(x, y) ::: x is based in y.\nWinner(x, y) ::: x is the winner of y.\nPromoted(x) ::: x is promoted.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nFootballClub(rhosAelwyd) ∧ Welsh(rhosAelwyd) ::: Rhos Aelwyd F.C. is a Welsh football club.\nFootballClub(rhosAelwyd) ∧ BasedIn(rhosAelwyd, ponciau) ::: Rhos Aelwyd F.C. is the only club based in Ponciau.\n∃x (Winner(x, 2005-06) ∧ BasedIn(x, ponciau)) ::: The Premier Division was won in 2005–06 by a team from Ponciau.\nWinner(x, 2009-10) → Promoted(x) ::: The winner of the Premier Division in 2009–10 was promoted back to the Cymru Alliance.\nWinner(x, 2009-10) ↔ Winner(x, 2005-06) ::: The Premier Division in 2009–10 was won by the same team that won in 2005-06.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nWinner(rhosAelwyd, 2005-06) ::: Rhos Aelwyd F.C. won the 2005-06 Premier Division.\n\"\"\""
    ]
  },
  {
    "id": 637,
    "context": [
      "Rhos Aelwyd F.C. is a Welsh football club.",
      "Rhos Aelwyd F.C. is the only club based in Ponciau. ",
      "The Premier Division was won in 2005–06 by a team from Ponciau. ",
      "The winner of the Premier Division in 2009–10 was promoted back to the Cymru Alliance.",
      "The Premier Division in 2009–10 was won by the same team that won in 2005-06. "
    ],
    "question": "Rhos Aelwyd F.C. was promoted to the Cymru Alliance.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nWelsh(x) ::: x is Welsh.\nFootballClub(x) ::: x is a football club.\nBasedIn(x, y) ::: x is based in y.\nWinner(x, y) ::: x is the winner of y.\nPromotedTo(x, y) ::: x is promoted to y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nWelsh(rhosAelwyd) ∧ FootballClub(rhosAelwyd) ::: Rhos Aelwyd F.C. is a Welsh football club.\n∀x (FootballClub(x) ∧ BasedIn(x, ponciau)) ::: Rhos Aelwyd F.C. is the only club based in Ponciau.\nWinner(team2005-06, ponciau) ::: The Premier Division was won in 2005–06 by a team from Ponciau.\nWinner(team2009-10, premierDivision) ∧ PromotedTo(team2009-10, cymruAlliance) ::: The winner of the Premier Division in 2009–10 was promoted back to the Cymru Alliance.\nWinner(team2009-10, premierDivision) ↔ Winner(team2005-06, premierDivision) ::: The Premier Division in 2009–10 was won by the same team that won in 2005-06.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nPromotedTo(rhosAelwyd, cymruAlliance) ::: Rhos Aelwyd F.C. was promoted to the Cymru Alliance.\n\"\"\""
    ]
  },
  {
    "id": 1362,
    "context": [
      "All OS are software.",
      "All Mac are OS.",
      "An OS is either Mac or Windows.",
      "All Windows are convenient.",
      "All software has code.",
      "If something is convenient, then it is popular.",
      "Burger is a piece of code and a Mac.",
      "PyTorch is either Windows and software, or neither Windows nor software."
    ],
    "question": "Burger is popular.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nOS(x) ::: x is an operating system.\nSoftware(x) ::: x is software.\nMac(x) ::: x is a Mac.\nWindows(x) ::: x is Windows.\nConvenient(x) ::: x is convenient.\nCode(x) ::: x has code.\nPopular(x) ::: x is popular.\nBurger(x) ::: x is a burger.\nPyTorch(x) ::: x is PyTorch.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (OS(x) → Software(x)) ::: All OS are software.\n∀x (Mac(x) → OS(x)) ::: All Mac are OS.\n∀x (OS(x) ↔ (Mac(x) ∨ Windows(x))) ::: An OS is either Mac or Windows.\n∀x (Windows(x) → Convenient(x)) ::: All Windows are convenient.\n∀x (Software(x) → Code(x)) ::: All software has code.\n∀x (Convenient(x) → Popular(x)) ::: If something is convenient, then it is popular.\nCode(burger) ∧ Mac(burger) ::: Burger is a piece of code and a Mac.\n(PyTorch(x) ↔ (Windows(x) ∧ Software(x))) ⊕ ¬(Windows(x) ∨ Software(x)) ::: PyTorch is either Windows and software, or neither Windows nor software.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nPopular(burger) ::: Burger is popular.\n\"\"\""
    ]
  },
  {
    "id": 1363,
    "context": [
      "All OS are software.",
      "All Mac are OS.",
      "An OS is either Mac or Windows.",
      "All Windows are convenient.",
      "All software has code.",
      "If something is convenient, then it is popular.",
      "Burger is a piece of code and a Mac.",
      "PyTorch is either Windows and software, or neither Windows nor software."
    ],
    "question": "Burger is not popular.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nOS(x) ::: x is an operating system.\nSoftware(x) ::: x is software.\nMac(x) ::: x is a Mac.\nWindows(x) ::: x is Windows.\nConvenient(x) ::: x is convenient.\nCode(x) ::: x has code.\nPopular(x) ::: x is popular.\nBurger(x) ::: x is a burger.\nPyTorch(x) ::: x is PyTorch.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (OS(x) → Software(x)) ::: All OS are software.\n∀x (Mac(x) → OS(x)) ::: All Mac are OS.\n∀x (OS(x) ↔ (Mac(x) ∨ Windows(x))) ::: An OS is either Mac or Windows.\n∀x (Windows(x) → Convenient(x)) ::: All Windows are convenient.\n∀x (Software(x) → Code(x)) ::: All software has code.\n∀x (Convenient(x) → Popular(x)) ::: If something is convenient, then it is popular.\nCode(burger) ∧ Mac(burger) ::: Burger is a piece of code and a Mac.\n(PyTorch(x) ↔ (Windows(x) ∧ Software(x))) ⊕ ¬(Windows(x) ∨ Software(x)) ::: PyTorch is either Windows and software, or neither Windows nor software.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬Popular(burger) ::: Burger is not popular.\n\"\"\""
    ]
  },
  {
    "id": 1364,
    "context": [
      "All OS are software.",
      "All Mac are OS.",
      "An OS is either Mac or Windows.",
      "All Windows are convenient.",
      "All software has code.",
      "If something is convenient, then it is popular.",
      "Burger is a piece of code and a Mac.",
      "PyTorch is either Windows and software, or neither Windows nor software."
    ],
    "question": "PyTorch is popular and has code.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nOS(x) ::: x is an operating system.\nSoftware(x) ::: x is software.\nMac(x) ::: x is a Mac.\nWindows(x) ::: x is Windows.\nConvenient(x) ::: x is convenient.\nCode(x) ::: x has code.\nPopular(x) ::: x is popular.\nBurger(x) ::: x is a burger.\nPyTorch(x) ::: x is PyTorch.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (OS(x) → Software(x)) ::: All OS are software.\n∀x (Mac(x) → OS(x)) ::: All Mac are OS.\n∀x (OS(x) ↔ (Mac(x) ∨ Windows(x))) ::: An OS is either Mac or Windows.\n∀x (Windows(x) → Convenient(x)) ::: All Windows are convenient.\n∀x (Software(x) → Code(x)) ::: All software has code.\n∀x (Convenient(x) → Popular(x)) ::: If something is convenient, then it is popular.\nCode(burger) ∧ Mac(burger) ::: Burger is a piece of code and a Mac.\n(Mac(pytorch) ∧ Software(pytorch)) ⊕ ¬(Mac(pytorch) ∨ Software(pytorch)) ::: PyTorch is either Windows and software, or neither Windows nor software.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nPopular(pytorch) ∧ Code(pytorch) ::: PyTorch is popular and has code.\n\"\"\""
    ]
  },
  {
    "id": 1365,
    "context": [
      "All OS are software.",
      "All Mac are OS.",
      "An OS is either Mac or Windows.",
      "All Windows are convenient.",
      "All software has code.",
      "If something is convenient, then it is popular.",
      "Burger is a piece of code and a Mac.",
      "PyTorch is either Windows and software, or neither Windows nor software."
    ],
    "question": "PyTorch is not popular and has code.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nOS(x) ::: x is an operating system.\nSoftware(x) ::: x is software.\nMac(x) ::: x is a Mac.\nWindows(x) ::: x is Windows.\nConvenient(x) ::: x is convenient.\nCode(x) ::: x has code.\nPopular(x) ::: x is popular.\nBurger(x) ::: x is a burger.\nPyTorch(x) ::: x is PyTorch.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (OS(x) → Software(x)) ::: All OS are software.\n∀x (Mac(x) → OS(x)) ::: All Mac are OS.\n∀x (OS(x) ↔ (Mac(x) ∨ Windows(x))) ::: An OS is either Mac or Windows.\n∀x (Windows(x) → Convenient(x)) ::: All Windows are convenient.\n∀x (Software(x) → Code(x)) ::: All software has code.\n∀x (Convenient(x) → Popular(x)) ::: If something is convenient, then it is popular.\nCode(burger) ∧ Mac(burger) ::: Burger is a piece of code and a Mac.\n(PyTorch(x) ↔ (Windows(x) ∧ Software(x))) ⊕ ¬(Windows(x) ∨ Software(x)) ::: PyTorch is either Windows and software, or neither Windows nor software.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬Popular(PyTorch) ∧ Code(PyTorch) ::: PyTorch is not popular and has code.\n\"\"\""
    ]
  },
  {
    "id": 353,
    "context": [
      "Roads are made of either concrete or asphalt.",
      "Roads made of concrete last longer than roads made with asphalt.",
      "Roads made of asphalt are smoother than roads made of concrete.",
      "Everyone prefers the smoother of two roads. ",
      "Road one is made of concrete and Road two is made of asphalt."
    ],
    "question": "Road one will last longer than Road two",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nRoad(x) ::: x is a road.\nConcrete(x) ::: x is made of concrete.\nAsphalt(x) ::: x is made of asphalt.\nLastLonger(x, y) ::: x lasts longer than y.\nSmoother(x, y) ::: x is smoother than y.\nPrefers(x, y) ::: x prefers y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Road(x) → (Concrete(x) ∨ Asphalt(x))) ::: Roads are made of either concrete or asphalt.\n∀x (Concrete(x) → LastLonger(x, y)) ::: Roads made of concrete last longer than roads made with asphalt.\n∀x (Asphalt(x) → Smoother(x, y)) ::: Roads made of asphalt are smoother than roads made of concrete.\n∀x ∀y (Road(x) ∧ Road(y) → Prefers(Smoother(x, y), x)) ::: Everyone prefers the smoother of two roads.\nConcrete(road1) ∧ Asphalt(road2) ::: Road one is made of concrete and Road two is made of asphalt.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nLastLonger(road1, road2) ::: Road one will last longer than Road two.\n\"\"\""
    ]
  },
  {
    "id": 354,
    "context": [
      "Roads are made of either concrete or asphalt.",
      "Roads made of concrete last longer than roads made with asphalt.",
      "Roads made of asphalt are smoother than roads made of concrete.",
      "Everyone prefers the smoother of two roads. ",
      "Road one is made of concrete and Road two is made of asphalt."
    ],
    "question": "Road two is not smoother than Road one.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nRoad(x) ::: x is a road.\nConcrete(x) ::: x is made of concrete.\nAsphalt(x) ::: x is made of asphalt.\nLastLonger(x, y) ::: x lasts longer than y.\nSmoother(x, y) ::: x is smoother than y.\nPrefers(x, y) ::: x prefers y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Road(x) → (Concrete(x) ∨ Asphalt(x))) ::: Roads are made of either concrete or asphalt.\n∀x (Concrete(x) → ∀y (Asphalt(y) → LastLonger(x, y))) ::: Roads made of concrete last longer than roads made with asphalt.\n∀x (Asphalt(x) → ∀y (Concrete(y) → Smoother(x, y))) ::: Roads made of asphalt are smoother than roads made of concrete.\n∀x ∀y (Road(x) ∧ Road(y) → Prefers(x, y) ↔ Smoother(x, y)) ::: Everyone prefers the smoother of two roads.\nConcrete(road1) ∧ Asphalt(road2) ::: Road one is made of concrete and Road two is made of asphalt.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬Smoother(road2, road1) ::: Road two is not smoother than Road one.\n\"\"\""
    ]
  },
  {
    "id": 355,
    "context": [
      "Roads are made of either concrete or asphalt.",
      "Roads made of concrete last longer than roads made with asphalt.",
      "Roads made of asphalt are smoother than roads made of concrete.",
      "Everyone prefers the smoother of two roads. ",
      "Road one is made of concrete and Road two is made of asphalt."
    ],
    "question": "John prefers Road two.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nRoad(x) ::: x is a road.\nConcrete(x) ::: x is made of concrete.\nAsphalt(x) ::: x is made of asphalt.\nLastLonger(x, y) ::: x lasts longer than y.\nSmoother(x, y) ::: x is smoother than y.\nPrefers(x, y) ::: x prefers y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Road(x) → (Concrete(x) ∨ Asphalt(x))) ::: Roads are made of either concrete or asphalt.\n∀x (Concrete(x) → ∀y (Road(y) ∧ Asphalt(y) → LastLonger(x, y))) ::: Roads made of concrete last longer than roads made with asphalt.\n∀x (Asphalt(x) → ∀y (Road(y) ∧ Concrete(y) → Smoother(x, y))) ::: Roads made of asphalt are smoother than roads made of concrete.\n∀x ∀y (Road(x) ∧ Road(y) → (Smoother(x, y) ↔ Prefers(x, y))) ::: Everyone prefers the smoother of two roads.\nConcrete(road1) ∧ Asphalt(road2) ::: Road one is made of concrete and Road two is made of asphalt.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nPrefers(john, road2) ::: John prefers Road two.\n\"\"\""
    ]
  },
  {
    "id": 226,
    "context": [
      "Camp Davern is a traditional summer camp for boys and girls.",
      "Camp Davern was established in the year 1946.",
      "Camp Davern was operated by the YMCA until the year 2015.",
      "Camp Davern is one of Ontario's oldest summer camps."
    ],
    "question": "One of Ontario's oldest summer camps is a traditional summer camp for boys and girls.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nSummerCamp(x) ::: x is a summer camp.\nTraditional(x) ::: x is a traditional summer camp.\nBoysAndGirls(x) ::: x is a summer camp for boys and girls.\nEstablished(x, y) ::: x was established in year y.\nOperatedBy(x, y) ::: x was operated by y.\nOldest(x) ::: x is one of the oldest summer camps in Ontario.\nOntario(x) ::: x is located in Ontario.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nSummerCamp(campDavern) ∧ BoysAndGirls(campDavern) ::: Camp Davern is a traditional summer camp for boys and girls.\nEstablished(campDavern, year1946) ::: Camp Davern was established in the year 1946.\nOperatedBy(campDavern, YMCA) ∧ ¬OperatedBy(campDavern, year2015) ::: Camp Davern was operated by the YMCA until the year 2015.\nOldest(campDavern) ∧ Ontario(campDavern) ::: Camp Davern is one of Ontario's oldest summer camps.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nOldest(campDavern) ∧ Ontario(campDavern) ∧ Traditional(campDavern) ∧ BoysAndGirls(campDavern) ::: One of Ontario's oldest summer camps is a traditional summer camp for boys and girls.\n\"\"\""
    ]
  },
  {
    "id": 227,
    "context": [
      "Camp Davern is a traditional summer camp for boys and girls.",
      "Camp Davern was established in the year 1946.",
      "Camp Davern was operated by the YMCA until the year 2015.",
      "Camp Davern is one of Ontario's oldest summer camps."
    ],
    "question": "A traditional summer camp for boys and girls was operated by the YMCA until the year 2015.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nSummerCamp(x) ::: x is a summer camp.\nTraditional(x) ::: x is a traditional summer camp.\nBoys(x) ::: x is for boys.\nGirls(x) ::: x is for girls.\nEstablished(x, y) ::: x was established in year y.\nOperatedBy(x, y) ::: x is operated by y.\nOldest(x) ::: x is one of the oldest.\nOntario(x) ::: x is in Ontario.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nSummerCamp(campDavern) ∧ Traditional(campDavern) ∧ Boys(campDavern) ∧ Girls(campDavern) ::: Camp Davern is a traditional summer camp for boys and girls.\nEstablished(campDavern, year1946) ::: Camp Davern was established in the year 1946.\n∀x (SummerCamp(x) → OperatedBy(x, YMCA)) ∧ OperatedBy(campDavern, YMCA) ∧ ¬(OperatedBy(campDavern, year2015)) ::: Camp Davern was operated by the YMCA until the year 2015.\nSummerCamp(campDavern) ∧ Oldest(campDavern) ∧ Ontario(campDavern) ::: Camp Davern is one of Ontario's oldest summer camps.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nTraditional(campDavern) ∧ Boys(campDavern) ∧ Girls(campDavern) ∧ OperatedBy(campDavern, YMCA) ∧ ¬(OperatedBy(campDavern, year2015)) ::: A traditional summer camp for boys and girls was operated by the YMCA until the year 2015.\n\"\"\""
    ]
  },
  {
    "id": 228,
    "context": [
      "Camp Davern is a traditional summer camp for boys and girls.",
      "Camp Davern was established in the year 1946.",
      "Camp Davern was operated by the YMCA until the year 2015.",
      "Camp Davern is one of Ontario's oldest summer camps."
    ],
    "question": "Camp Davern was established in 1989.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nSummerCamp(x) ::: x is a summer camp.\nTraditional(x) ::: x is a traditional summer camp.\nBoys(x) ::: x is for boys.\nGirls(x) ::: x is for girls.\nEstablished(x, y) ::: x was established in year y.\nOperatedBy(x, y) ::: x was operated by y.\nOldest(x) ::: x is one of the oldest.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nSummerCamp(campDavern) ∧ Traditional(campDavern) ∧ Boys(campDavern) ∧ Girls(campDavern) ::: Camp Davern is a traditional summer camp for boys and girls.\nEstablished(campDavern, year1946) ::: Camp Davern was established in the year 1946.\nOperatedBy(campDavern, YMCA) ∧ ¬OperatedBy(campDavern, year2015) ::: Camp Davern was operated by the YMCA until the year 2015.\nOldest(campDavern) ∧ SummerCamp(campDavern) ∧ Boys(campDavern) ∧ Girls(campDavern) ∧ LocatedIn(campDavern, Ontario) ::: Camp Davern is one of Ontario's oldest summer camps.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬Established(campDavern, year1989) ::: Camp Davern was not established in 1989.\n\"\"\""
    ]
  },
  {
    "id": 995,
    "context": [
      "If people publish journals, then they do not work in the entertainment industry.",
      "All people who are award-winning novelists publish journals.",
      "People either work in the entertainment industry or are highly acclaimed in their profession.",
      "If people are highly acclaimed in their profession, then they often hold tenured and high-ranking positions at their workplace.",
      "If people are highly acclaimed in their profession, then they often receive glowing feedback and recommendations from their colleagues.",
      "If Emily is either both highly acclaimed in her profession and often holds tenured and high-ranking positions at her workplace, or she is neither highly acclaimed in her profession nor often holds tenured and high-ranking positions at her workplace, then Emily is not highly acclaimed in her profession. "
    ],
    "question": "Emily often holds tenured and high-ranking positions at her workplace.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nPublish(x, y) ::: x publishes y.\nWork(x, y) ::: x works in y.\nEntertainmentIndustry(x) ::: x works in the entertainment industry.\nAwardWinningNovelist(x) ::: x is an award-winning novelist.\nHighlyAcclaimed(x) ::: x is highly acclaimed in their profession.\nHoldPosition(x, y) ::: x holds tenured and high-ranking positions at y.\nReceiveFeedback(x) ::: x receives glowing feedback and recommendations from colleagues.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Publish(x, journal) → ¬Work(x, entertainmentIndustry)) ::: If people publish journals, then they do not work in the entertainment industry.\n∀x (AwardWinningNovelist(x) → Publish(x, journal)) ::: All people who are award-winning novelists publish journals.\n∀x (Work(x, entertainmentIndustry) ⊕ HighlyAcclaimed(x)) ::: People either work in the entertainment industry or are highly acclaimed in their profession.\n∀x (HighlyAcclaimed(x) → HoldPosition(x, workplace)) ::: If people are highly acclaimed in their profession, then they often hold tenured and high-ranking positions at their workplace.\n∀x (HighlyAcclaimed(x) → ReceiveFeedback(x)) ::: If people are highly acclaimed in their profession, then they often receive glowing feedback and recommendations from their colleagues.\n(HighlyAcclaimed(emily) ∧ HoldPosition(emily, workplace)) ⊕ ¬(HighlyAcclaimed(emily) ∨ HoldPosition(emily, workplace)) → ¬HighlyAcclaimed(emily) ::: If Emily is either both highly acclaimed in her profession and often holds tenured and high-ranking positions at her workplace, or she is neither highly acclaimed in her profession nor often holds tenured and high-ranking positions at her workplace, then Emily is not highly acclaimed in her profession.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nHoldPosition(emily, workplace) ::: Emily often holds tenured and high-ranking positions at her workplace.\n\"\"\""
    ]
  },
  {
    "id": 996,
    "context": [
      "If people publish journals, then they do not work in the entertainment industry.",
      "All people who are award-winning novelists publish journals.",
      "People either work in the entertainment industry or are highly acclaimed in their profession.",
      "If people are highly acclaimed in their profession, then they often hold tenured and high-ranking positions at their workplace.",
      "If people are highly acclaimed in their profession, then they often receive glowing feedback and recommendations from their colleagues.",
      "If Emily is either both highly acclaimed in her profession and often holds tenured and high-ranking positions at her workplace, or she is neither highly acclaimed in her profession nor often holds tenured and high-ranking positions at her workplace, then Emily is not highly acclaimed in her profession. "
    ],
    "question": "Emily often receives glowing feedback and recommendations from their colleagues and is an award-winning novelist.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nPublish(x) ::: x publishes journals.\nEntertainment(x) ::: x works in the entertainment industry.\nAwardWinningNovelist(x) ::: x is an award-winning novelist.\nHighlyAcclaimed(x) ::: x is highly acclaimed in their profession.\nHoldTenuredPosition(x) ::: x often holds tenured positions at their workplace.\nReceiveFeedback(x) ::: x often receives glowing feedback and recommendations from colleagues.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nPublish(x) → ¬Entertainment(x) ::: If people publish journals, then they do not work in the entertainment industry.\n∀x (AwardWinningNovelist(x) → Publish(x)) ::: All people who are award-winning novelists publish journals.\nEntertainment(x) ⊕ HighlyAcclaimed(x) ::: People either work in the entertainment industry or are highly acclaimed in their profession.\nHighlyAcclaimed(x) → (HoldTenuredPosition(x) ∧ ReceiveFeedback(x)) ::: If people are highly acclaimed in their profession, then they often hold tenured and high-ranking positions at their workplace and often receive glowing feedback and recommendations from their colleagues.\n(HighlyAcclaimed(emily) ∧ HoldTenuredPosition(emily)) ⊕ ¬(HighlyAcclaimed(emily) ∨ HoldTenuredPosition(emily)) → ¬HighlyAcclaimed(emily) ::: If Emily is either both highly acclaimed in her profession and often holds tenured and high-ranking positions at her workplace, or she is neither highly acclaimed in her profession nor often holds tenured and high-ranking positions at her workplace, then Emily is not highly acclaimed in her profession.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nReceiveFeedback(emily) ∧ AwardWinningNovelist(emily) ::: Emily often receives glowing feedback and recommendations from their colleagues and is an award-winning novelist.\n\"\"\""
    ]
  },
  {
    "id": 997,
    "context": [
      "If people publish journals, then they do not work in the entertainment industry.",
      "All people who are award-winning novelists publish journals.",
      "People either work in the entertainment industry or are highly acclaimed in their profession.",
      "If people are highly acclaimed in their profession, then they often hold tenured and high-ranking positions at their workplace.",
      "If people are highly acclaimed in their profession, then they often receive glowing feedback and recommendations from their colleagues.",
      "If Emily is either both highly acclaimed in her profession and often holds tenured and high-ranking positions at her workplace, or she is neither highly acclaimed in her profession nor often holds tenured and high-ranking positions at her workplace, then Emily is not highly acclaimed in her profession. "
    ],
    "question": "If Emily either often receives glowing feedback and recommendations from her colleagues or is an award-winning novelist, then Emily does not both publish journals and is an award-winning novelist.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nPublish(x, y) ::: x publishes y.\nWork(x, y) ::: x works in y.\nEntertainmentIndustry(x) ::: x works in the entertainment industry.\nAwardWinningNovelist(x) ::: x is an award-winning novelist.\nHighlyAcclaimed(x) ::: x is highly acclaimed in their profession.\nHoldTenuredPosition(x) ::: x holds a tenured position.\nHoldHighRankingPosition(x) ::: x holds a high-ranking position.\nReceiveFeedback(x) ::: x receives glowing feedback.\nRecommendations(x) ::: x receives recommendations.\nColleague(x, y) ::: x is a colleague of y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Publish(x, journal) → ¬Work(x, entertainmentIndustry)) ::: If people publish journals, then they do not work in the entertainment industry.\n∀x (AwardWinningNovelist(x) → Publish(x, journal)) ::: All people who are award-winning novelists publish journals.\n∀x (Work(x, entertainmentIndustry) ⊕ HighlyAcclaimed(x)) ::: People either work in the entertainment industry or are highly acclaimed in their profession.\n∀x (HighlyAcclaimed(x) → (HoldTenuredPosition(x) ∧ HoldHighRankingPosition(x))) ::: If people are highly acclaimed in their profession, then they often hold tenured and high-ranking positions at their workplace.\n∀x (HighlyAcclaimed(x) → (ReceiveFeedback(x) ∧ Recommendations(x))) ::: If people are highly acclaimed in their profession, then they often receive glowing feedback and recommendations from their colleagues.\n((HighlyAcclaimed(emily) ∧ HoldTenuredPosition(emily) ∧ HoldHighRankingPosition(emily)) ⊕ (¬HighlyAcclaimed(emily) ∧ ¬HoldTenuredPosition(emily) ∧ ¬HoldHighRankingPosition(emily))) → ¬HighlyAcclaimed(emily) ::: If Emily is either both highly acclaimed in her profession and often holds tenured and high-ranking positions at her workplace, or she is neither highly acclaimed in her profession nor often holds tenured and high-ranking positions at her workplace, then Emily is not highly acclaimed in her profession.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n((ReceiveFeedback(emily) ∨ AwardWinningNovelist(emily)) → ¬(Publish(emily, journal) ∧ AwardWinningNovelist(emily))) ::: If Emily either often receives glowing feedback and recommendations from her colleagues or is an award-winning novelist, then Emily does not both publish journals and is an award-winning novelist.\n\"\"\""
    ]
  },
  {
    "id": 25,
    "context": [
      "Thick as Thieves is a young adult fantasy novel, written by Megan Whalen Turner.",
      "Thick as Thieves was published by Greenwillow Books.",
      "If a book was published by a company, than the author of that book worked with the company that published the book.",
      "The fictional Mede Empire is where Thick as Thieves is set.",
      "The Mede Empire plots to swallow up some nearby countries.",
      "Attolia and Sounis are countries near the Mede Empire.",
      "Thick as Thieves was sold both as a hardcover and an e-book."
    ],
    "question": "Megan Whalen Turner worked with Greenwillow Books.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nAuthor(x, y) ::: x is the author of y.\nPublishedBy(x, y) ::: x was published by y.\nWorkedWith(x, y) ::: x worked with y.\nSetIn(x, y) ::: x is set in y.\nPlotToSwallow(x, y) ::: x plots to swallow up y.\nNear(x, y) ::: x is near y.\nSoldAs(x, y) ::: x was sold as y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nAuthor(meganWhalenTurner, thickAsThieves) ::: Thick as Thieves is a young adult fantasy novel, written by Megan Whalen Turner.\nPublishedBy(thickAsThieves, greenwillowBooks) ::: Thick as Thieves was published by Greenwillow Books.\n∀x∀y ((PublishedBy(x, y)) → (Author(x, y) ∧ WorkedWith(Author(x, y), y))) ::: If a book was published by a company, than the author of that book worked with the company that published the book.\nSetIn(thickAsThieves, medeEmpire) ::: The fictional Mede Empire is where Thick as Thieves is set.\nPlotToSwallow(medeEmpire, someNearbyCountries) ::: The Mede Empire plots to swallow up some nearby countries.\nNear(attolia, medeEmpire) ∧ Near(sounis, medeEmpire) ::: Attolia and Sounis are countries near the Mede Empire.\nSoldAs(thickAsThieves, hardcover) ∧ SoldAs(thickAsThieves, e-book) ::: Thick as Thieves was sold both as a hardcover and an e-book.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nWorkedWith(meganWhalenTurner, greenwillowBooks) ::: Megan Whalen Turner worked with Greenwillow Books.\n\"\"\""
    ]
  },
  {
    "id": 26,
    "context": [
      "Thick as Thieves is a young adult fantasy novel, written by Megan Whalen Turner.",
      "Thick as Thieves was published by Greenwillow Books.",
      "If a book was published by a company, than the author of that book worked with the company that published the book.",
      "The fictional Mede Empire is where Thick as Thieves is set.",
      "The Mede Empire plots to swallow up some nearby countries.",
      "Attolia and Sounis are countries near the Mede Empire.",
      "Thick as Thieves was sold both as a hardcover and an e-book."
    ],
    "question": "The Mede Empire plans to swallow up Attolia.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nNovel(x) ::: x is a novel.\nAuthor(x, y) ::: x is the author of y.\nPublishedBy(x, y) ::: x is published by y.\nCompany(x) ::: x is a company.\nWorksWith(x, y) ::: x worked with y.\nSetIn(x, y) ::: x is set in y.\nPlotTo(x, y) ::: x plots to y.\nNear(x, y) ::: x is near y.\nSoldAs(x, y) ::: x is sold as y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nNovel(thickAsThieves) ∧ Author(meganWhalenTurner, thickAsThieves) ::: Thick as Thieves is a young adult fantasy novel, written by Megan Whalen Turner.\nPublishedBy(thickAsThieves, greenwillowBooks) ::: Thick as Thieves was published by Greenwillow Books.\n∀x∀y ((PublishedBy(x, y)) → WorksWith(Author(x, y), x)) ::: If a book was published by a company, than the author of that book worked with the company that published the book.\nSetIn(thickAsThieves, medeEmpire) ::: The fictional Mede Empire is where Thick as Thieves is set.\nPlotTo(medeEmpire, swallowUp(some(nearbyCountries))) ::: The Mede Empire plots to swallow up some nearby countries.\nNear(attolia, medeEmpire) ∧ Near(sounis, medeEmpire) ::: Attolia and Sounis are countries near the Mede Empire.\nSoldAs(thickAsThieves, hardcover) ∧ SoldAs(thickAsThieves, e-book) ::: Thick as Thieves was sold both as a hardcover and an e-book.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nPlotTo(medeEmpire, swallowUp(attolia)) ::: The Mede Empire plans to swallow up Attolia.\n\"\"\""
    ]
  },
  {
    "id": 27,
    "context": [
      "Thick as Thieves is a young adult fantasy novel, written by Megan Whalen Turner.",
      "Thick as Thieves was published by Greenwillow Books.",
      "If a book was published by a company, than the author of that book worked with the company that published the book.",
      "The fictional Mede Empire is where Thick as Thieves is set.",
      "The Mede Empire plots to swallow up some nearby countries.",
      "Attolia and Sounis are countries near the Mede Empire.",
      "Thick as Thieves was sold both as a hardcover and an e-book."
    ],
    "question": "Thick as Thieves is not set in the mede empire.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nNovel(x) ::: x is a novel.\nWrittenBy(x, y) ::: x is written by y.\nPublishedBy(x, y) ::: x is published by y.\nWorksWith(x, y) ::: x works with y.\nSetIn(x, y) ::: x is set in y.\nPlotTo(x, y) ::: x plots to y.\nNear(x, y) ::: x is near y.\nSoldAs(x, y) ::: x is sold as y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nNovel(thickAsThieves) ∧ WrittenBy(thickAsThieves, meganWhalenTurner) ::: Thick as Thieves is a young adult fantasy novel, written by Megan Whalen Turner.\nPublishedBy(thickAsThieves, greenwillowBooks) ::: Thick as Thieves was published by Greenwillow Books.\n∀x∀y ((PublishedBy(x, y)) → WorksWith(Author(x), y)) ::: If a book was published by a company, than the author of that book worked with the company that published the book.\nSetIn(thickAsThieves, medeEmpire) ::: The fictional Mede Empire is where Thick as Thieves is set.\nPlotTo(medeEmpire, swallowUp(someNearbyCountries)) ::: The Mede Empire plots to swallow up some nearby countries.\nNear(attolia, medeEmpire) ∧ Near(sounis, medeEmpire) ::: Attolia and Sounis are countries near the Mede Empire.\nSoldAs(thickAsThieves, hardcover) ∧ SoldAs(thickAsThieves, ebook) ::: Thick as Thieves was sold both as a hardcover and an e-book.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬SetIn(thickAsThieves, medeEmpire) ::: Thick as Thieves is not set in the Mede Empire.\n\"\"\""
    ]
  },
  {
    "id": 28,
    "context": [
      "Thick as Thieves is a young adult fantasy novel, written by Megan Whalen Turner.",
      "Thick as Thieves was published by Greenwillow Books.",
      "If a book was published by a company, than the author of that book worked with the company that published the book.",
      "The fictional Mede Empire is where Thick as Thieves is set.",
      "The Mede Empire plots to swallow up some nearby countries.",
      "Attolia and Sounis are countries near the Mede Empire.",
      "Thick as Thieves was sold both as a hardcover and an e-book."
    ],
    "question": "Megan Whalen Turner did not work with Greenwillow Books.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nAuthor(x, y) ::: x is the author of y.\nPublishedBy(x, y) ::: x was published by y.\nWorkedWith(x, y) ::: x worked with y.\nSetIn(x, y) ::: x is set in y.\nPlotTo(x, y) ::: x plots to y.\nNear(x, y) ::: x is near y.\nSoldAs(x, y) ::: x was sold as y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nAuthor(thickAsThieves, meganWhalenTurner) ::: Thick as Thieves is a young adult fantasy novel, written by Megan Whalen Turner.\nPublishedBy(thickAsThieves, greenwillowBooks) ::: Thick as Thieves was published by Greenwillow Books.\n∀x∀y (PublishedBy(x, y) → WorkedWith(Author(x, y), y)) ::: If a book was published by a company, than the author of that book worked with the company that published the book.\nSetIn(thickAsThieves, medeEmpire) ::: The fictional Mede Empire is where Thick as Thieves is set.\nPlotTo(medeEmpire, swallowUp(someCountries)) ::: The Mede Empire plots to swallow up some nearby countries.\nNear(attolia, medeEmpire) ∧ Near(sounis, medeEmpire) ::: Attolia and Sounis are countries near the Mede Empire.\nSoldAs(thickAsThieves, hardcover) ∧ SoldAs(thickAsThieves, e-book) ::: Thick as Thieves was sold both as a hardcover and an e-book.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬WorkedWith(meganWhalenTurner, greenwillowBooks) ::: Megan Whalen Turner did not work with Greenwillow Books.\n\"\"\""
    ]
  },
  {
    "id": 351,
    "context": [
      "WeTab is a MeeGo-based tablet computer.",
      "There is a WeTab product.",
      "WeTab was announced by Neofonie.",
      "Neofonie is a German producer.",
      "Germans speak English or German."
    ],
    "question": "There is a tablet computer that was announced by a German.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nTablet(x) ::: x is a tablet computer.\nProduct(x) ::: x is a product.\nAnnouncedBy(x, y) ::: x was announced by y.\nProducer(x) ::: x is a producer.\nSpeak(x, y) ::: x speaks y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nWeTab is a MeeGo-based tablet computer. ::: Tablet(WeTab) \nThere is a WeTab product. ::: Product(WeTab)\nWeTab was announced by Neofonie. ::: AnnouncedBy(WeTab, Neofonie)\nNeofonie is a German producer. ::: Producer(Neofonie) ∧ German(Neofonie)\n∀x (German(x) → (Speak(x, English) ∨ Speak(x, German))) ::: Germans speak English or German.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n∃x (Tablet(x) ∧ AnnouncedBy(x, German)) ::: There is a tablet computer that was announced by a German.\n\"\"\""
    ]
  },
  {
    "id": 352,
    "context": [
      "WeTab is a MeeGo-based tablet computer.",
      "There is a WeTab product.",
      "WeTab was announced by Neofonie.",
      "Neofonie is a German producer.",
      "Germans speak English or German."
    ],
    "question": "Neofonie doesn't speak English or German.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nTablet(x) ::: x is a tablet computer.\nProduct(x) ::: x is a product.\nAnnouncedBy(x, y) ::: x was announced by y.\nProducer(x) ::: x is a producer.\nSpeak(x, y) ::: x speaks y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nTablet(wetab) ∧ BasedOn(wetab, meego) ::: WeTab is a MeeGo-based tablet computer.\nProduct(wetab) ::: There is a WeTab product.\nAnnouncedBy(wetab, neofonie) ::: WeTab was announced by Neofonie.\nProducer(neofonie) ∧ German(neofonie) ::: Neofonie is a German producer.\n∀x (German(x) → (Speak(x, english) ∨ Speak(x, german))) ::: Germans speak English or German.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬(Speak(neofonie, english) ∨ Speak(neofonie, german)) ::: Neofonie doesn't speak English or German.\n\"\"\""
    ]
  },
  {
    "id": 1186,
    "context": [
      "Some employees working in business analysis are good at math. ",
      "All employees working in business analysis are working in this company. ",
      "No employees working in this company are from China. ",
      "All employees working in software engineering are from China. ",
      "James is working in software engineering. "
    ],
    "question": "James is good at math.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nGoodAtMath(x) ::: x is good at math.\nWorksInBusinessAnalysis(x) ::: x works in business analysis.\nWorksInCompany(x) ::: x works in this company.\nFromChina(x) ::: x is from China.\nWorksInSoftwareEngineering(x) ::: x works in software engineering.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∃x (WorksInBusinessAnalysis(x) ∧ GoodAtMath(x)) ::: Some employees working in business analysis are good at math.\n∀x (WorksInBusinessAnalysis(x) → WorksInCompany(x)) ::: All employees working in business analysis are working in this company.\n∀x (WorksInCompany(x) → ¬FromChina(x)) ::: No employees working in this company are from China.\n∀x (WorksInSoftwareEngineering(x) → FromChina(x)) ::: All employees working in software engineering are from China.\nWorksInSoftwareEngineering(james) ::: James is working in software engineering.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nGoodAtMath(james) ::: James is good at math.\n\"\"\""
    ]
  },
  {
    "id": 1187,
    "context": [
      "Some employees working in business analysis are good at math. ",
      "All employees working in business analysis are working in this company. ",
      "No employees working in this company are from China. ",
      "All employees working in software engineering are from China. ",
      "James is working in software engineering. "
    ],
    "question": "James is not good at math and he is working in business analysis.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nGoodAtMath(x) ::: x is good at math.\nWorkingInBusinessAnalysis(x) ::: x is working in business analysis.\nWorkingInCompany(x) ::: x is working in this company.\nFromChina(x) ::: x is from China.\nWorkingInSoftwareEngineering(x) ::: x is working in software engineering.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∃x (WorkingInBusinessAnalysis(x) ∧ GoodAtMath(x)) ::: Some employees working in business analysis are good at math.\n∀x (WorkingInBusinessAnalysis(x) → WorkingInCompany(x)) ::: All employees working in business analysis are working in this company.\n∀x (WorkingInCompany(x) → ¬FromChina(x)) ::: No employees working in this company are from China.\n∀x (WorkingInSoftwareEngineering(x) → FromChina(x)) ::: All employees working in software engineering are from China.\nWorkingInSoftwareEngineering(james) ::: James is working in software engineering.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬GoodAtMath(james) ∧ WorkingInBusinessAnalysis(james) ::: James is not good at math and he is working in business analysis.\n\"\"\""
    ]
  },
  {
    "id": 1188,
    "context": [
      "Some employees working in business analysis are good at math. ",
      "All employees working in business analysis are working in this company. ",
      "No employees working in this company are from China. ",
      "All employees working in software engineering are from China. ",
      "James is working in software engineering. "
    ],
    "question": "If James is not good at math and he is in business analysis, then he is neither working in this company nor working in software engineering.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nGoodAtMath(x) ::: x is good at math.\nBusinessAnalysisEmployee(x) ::: x is an employee working in business analysis.\nWorksInCompany(x) ::: x is working in this company.\nFromChina(x) ::: x is from China.\nSoftwareEngineeringEmployee(x) ::: x is an employee working in software engineering.\nWorksIn(x, y) ::: x works in y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∃x (BusinessAnalysisEmployee(x) ∧ GoodAtMath(x)) ::: Some employees working in business analysis are good at math.\n∀x (BusinessAnalysisEmployee(x) → WorksInCompany(x)) ::: All employees working in business analysis are working in this company.\n∀x (WorksInCompany(x) → ¬FromChina(x)) ::: No employees working in this company are from China.\n∀x (SoftwareEngineeringEmployee(x) → FromChina(x)) ::: All employees working in software engineering are from China.\nWorksIn(james, softwareEngineering) ::: James is working in software engineering.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬(GoodAtMath(james) ∧ BusinessAnalysisEmployee(james)) → ¬(WorksInCompany(james) ∨ WorksIn(james, softwareEngineering)) ::: If James is not good at math and he is in business analysis, then he is neither working in this company nor working in software engineering.\n\"\"\""
    ]
  },
  {
    "id": 452,
    "context": [
      "The party provides five kinds of fruits: strawberry, orange, blueberry, grape, and cherry.",
      "All fruits are provided in the same weight at the beginning of the party.",
      "If the fruit had the lowest remaining weight at the end of the party, then it means it was the most popular fruit.",
      "At the end of the party, strawberries had the lowest remaining weight.",
      "At the end of the party, the amount of leftover blueberries was lower than that of cherries.",
      "Benjamin only ate oranges and grapes at the party."
    ],
    "question": "Blueberries were the most popular fruit at the party.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nProvides(x, y) ::: The party provides fruit x.\nSameWeight(x) ::: All fruits are provided in the same weight.\nLowestWeightEnd(x) ::: Fruit x had the lowest remaining weight at the end of the party.\nMostPopular(x) ::: Fruit x was the most popular fruit.\nLeftover(x, y) ::: The amount of leftover fruit x is lower than that of fruit y.\nAte(x, y) ::: Person x ate fruit y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nProvides(strawberry) ∧ Provides(orange) ∧ Provides(blueberry) ∧ Provides(grape) ∧ Provides(cherry) ::: The party provides five kinds of fruits: strawberry, orange, blueberry, grape, and cherry.\n∀x SameWeight(x) ::: All fruits are provided in the same weight at the beginning of the party.\nLowestWeightEnd(strawberry) → MostPopular(strawberry) ::: If the fruit had the lowest remaining weight at the end of the party, then it means it was the most popular fruit.\nLowestWeightEnd(strawberry) ::: At the end of the party, strawberries had the lowest remaining weight.\nLeftover(blueberry, cherry) ::: At the end of the party, the amount of leftover blueberries was lower than that of cherries.\nAte(benjamin, orange) ∧ Ate(benjamin, grape) ::: Benjamin only ate oranges and grapes at the party.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nMostPopular(blueberry) ::: Blueberries were the most popular fruit at the party.\n\"\"\""
    ]
  },
  {
    "id": 453,
    "context": [
      "The party provides five kinds of fruits: strawberry, orange, blueberry, grape, and cherry.",
      "All fruits are provided in the same weight at the beginning of the party.",
      "If the fruit had the lowest remaining weight at the end of the party, then it means it was the most popular fruit.",
      "At the end of the party, strawberries had the lowest remaining weight.",
      "At the end of the party, the amount of leftover blueberries was lower than that of cherries.",
      "Benjamin only ate oranges and grapes at the party."
    ],
    "question": "Cherries were the most popular fruit at the party.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nProvides(x, y) ::: The party provides fruit y.\nSameWeight(x) ::: All fruits are provided in the same weight at the beginning of the party.\nLowestWeightEnd(x) ::: Fruit x had the lowest remaining weight at the end of the party.\nMostPopular(x) ::: Fruit x is the most popular fruit.\nLeftover(x, y) ::: The amount of leftover fruit x is lower than that of fruit y.\nAte(x, y) ::: Person x ate fruit y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nProvides(party, strawberry) ∧ Provides(party, orange) ∧ Provides(party, blueberry) ∧ Provides(party, grape) ∧ Provides(party, cherry) ::: The party provides five kinds of fruits: strawberry, orange, blueberry, grape, and cherry.\nSameWeight(x) ::: All fruits are provided in the same weight at the beginning of the party.\nLowestWeightEnd(x) → MostPopular(x) ::: If the fruit had the lowest remaining weight at the end of the party, then it means it was the most popular fruit.\nLowestWeightEnd(strawberry) ::: At the end of the party, strawberries had the lowest remaining weight.\nLeftover(blueberry, cherry) ::: At the end of the party, the amount of leftover blueberries was lower than that of cherries.\nAte(benjamin, orange) ∧ Ate(benjamin, grape) ::: Benjamin only ate oranges and grapes at the party.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nMostPopular(cherry) ::: Cherries were the most popular fruit at the party.\n\"\"\""
    ]
  },
  {
    "id": 454,
    "context": [
      "The party provides five kinds of fruits: strawberry, orange, blueberry, grape, and cherry.",
      "All fruits are provided in the same weight at the beginning of the party.",
      "If the fruit had the lowest remaining weight at the end of the party, then it means it was the most popular fruit.",
      "At the end of the party, strawberries had the lowest remaining weight.",
      "At the end of the party, the amount of leftover blueberries was lower than that of cherries.",
      "Benjamin only ate oranges and grapes at the party."
    ],
    "question": "Benjamin ate blueberries at the party.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nProvides(x, y) ::: The party provides fruit y.\nSameWeight(x) ::: All fruits are provided in the same weight at the beginning of the party.\nLowestWeightEnd(x) ::: Fruit x had the lowest remaining weight at the end of the party.\nMostPopular(x) ::: Fruit x was the most popular fruit.\nLeftover(x, y) ::: The amount of leftover fruit x is lower than that of fruit y.\nAte(x, y) ::: Person x ate fruit y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nProvides(party, strawberry) ∧ Provides(party, orange) ∧ Provides(party, blueberry) ∧ Provides(party, grape) ∧ Provides(party, cherry) ::: The party provides five kinds of fruits: strawberry, orange, blueberry, grape, and cherry.\nSameWeight(x) ::: All fruits are provided in the same weight at the beginning of the party.\nLowestWeightEnd(strawberry) → MostPopular(strawberry) ::: If the fruit had the lowest remaining weight at the end of the party, then it means it was the most popular fruit.\nLowestWeightEnd(strawberry) ::: At the end of the party, strawberries had the lowest remaining weight.\nLeftover(blueberry, cherry) ::: At the end of the party, the amount of leftover blueberries was lower than that of cherries.\nAte(benjamin, orange) ∧ Ate(benjamin, grape) ::: Benjamin only ate oranges and grapes at the party.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬Ate(benjamin, blueberry) ::: Benjamin did not eat blueberries at the party.\n\"\"\""
    ]
  },
  {
    "id": 187,
    "context": [
      "All students who attend in person have registered for the conference. ",
      "Students either attend the conference in person or remotely. ",
      "No students from China attend the conference remotely. ",
      "James attends the conference but he does not attend the conference remotely.",
      "Jack attends the conference and he is a student from China."
    ],
    "question": "James attends the conference but not in person.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nAttendInPerson(x) ::: x attends the conference in person.\nRegistered(x) ::: x has registered for the conference.\nAttendRemotely(x) ::: x attends the conference remotely.\nFromChina(x) ::: x is a student from China.\nAttend(x) ::: x attends the conference.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Student(x) ∧ AttendInPerson(x) → Registered(x)) ::: All students who attend in person have registered for the conference.\n∀x (Attend(x) ⊕ AttendRemotely(x)) ::: Students either attend the conference in person or remotely.\n∀x (FromChina(x) → ¬AttendRemotely(x)) ::: No students from China attend the conference remotely.\nAttend(james) ∧ ¬AttendRemotely(james) ::: James attends the conference but he does not attend the conference remotely.\nAttend(jack) ∧ FromChina(jack) ::: Jack attends the conference and he is a student from China.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nAttend(james) ∧ ¬AttendInPerson(james) ::: James attends the conference but not in person.\n\"\"\""
    ]
  },
  {
    "id": 188,
    "context": [
      "All students who attend in person have registered for the conference. ",
      "Students either attend the conference in person or remotely. ",
      "No students from China attend the conference remotely. ",
      "James attends the conference but he does not attend the conference remotely.",
      "Jack attends the conference and he is a student from China."
    ],
    "question": "Jack attends the conference in person.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nAttendInPerson(x) ::: x attends the conference in person.\nRegistered(x) ::: x has registered for the conference.\nAttendRemotely(x) ::: x attends the conference remotely.\nStudent(x) ::: x is a student.\nFromChina(x) ::: x is from China.\nAttend(x) ::: x attends the conference.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Student(x) ∧ AttendInPerson(x) → Registered(x)) ::: All students who attend in person have registered for the conference.\n∀x (Student(x) → AttendInPerson(x) ∨ AttendRemotely(x)) ::: Students either attend the conference in person or remotely.\n∀x (FromChina(x) → ¬AttendRemotely(x)) ::: No students from China attend the conference remotely.\nAttend(james) ∧ ¬AttendRemotely(james) ::: James attends the conference but he does not attend the conference remotely.\nAttend(jack) ∧ Student(jack) ∧ FromChina(jack) ::: Jack attends the conference and he is a student from China.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nAttendInPerson(jack) ::: Jack attends the conference in person.\n\"\"\""
    ]
  },
  {
    "id": 189,
    "context": [
      "All students who attend in person have registered for the conference. ",
      "Students either attend the conference in person or remotely. ",
      "No students from China attend the conference remotely. ",
      "James attends the conference but he does not attend the conference remotely.",
      "Jack attends the conference and he is a student from China."
    ],
    "question": "Jack has registered for the conference.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nAttendInPerson(x) ::: x attends the conference in person.\nRegistered(x) ::: x has registered for the conference.\nAttendRemotely(x) ::: x attends the conference remotely.\nStudent(x) ::: x is a student.\nFromChina(x) ::: x is from China.\nAttend(x) ::: x attends the conference.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Student(x) ∧ AttendInPerson(x) → Registered(x)) ::: All students who attend in person have registered for the conference.\n∀x (Attend(x) ↔ (AttendInPerson(x) ∨ AttendRemotely(x))) ::: Students either attend the conference in person or remotely.\n∀x (FromChina(x) → ¬AttendRemotely(x)) ::: No students from China attend the conference remotely.\nAttend(james) ∧ ¬AttendRemotely(james) ::: James attends the conference but he does not attend the conference remotely.\nAttend(jack) ∧ Student(jack) ∧ FromChina(jack) ::: Jack attends the conference and he is a student from China.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nRegistered(jack) ::: Jack has registered for the conference.\n\"\"\""
    ]
  },
  {
    "id": 633,
    "context": [
      "David Ha'ivri is a political strategist. ",
      "If you are born in Israel to at least one Israeli parent, then you receive citizenship at birth. ",
      "David Ha'ivri emigrated to the United States from Israel, where he was born to Israeli parents. ",
      "Several Zionist leaders have been elected to the Shomron Regional Municipal council. ",
      "David Ha'ivri is a Zionist leader. "
    ],
    "question": "David Ha'ivri is an Israeli citizen.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nPoliticalStrategist(x) ::: x is a political strategist.\nBornInIsrael(x) ::: x is born in Israel.\nIsraeliParent(x) ::: x is an Israeli parent.\nReceiveCitizenship(x) ::: x receives citizenship at birth.\nEmigrated(x, y) ::: x emigrated to y.\nZionistLeader(x) ::: x is a Zionist leader.\nElectedToCouncil(x, y) ::: x is elected to council y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nPoliticalStrategist(david) ::: David Ha'ivri is a political strategist.\n∀x (BornInIsrael(x) ∧ IsraeliParent(x) → ReceiveCitizenship(x)) ::: If you are born in Israel to at least one Israeli parent, then you receive citizenship at birth.\nBornInIsrael(david) ∧ IsraeliParent(david) ∧ Emigrated(david, unitedStates) ∧ BornInIsrael(david) ∧ IsraeliParent(david) ::: David Ha'ivri emigrated to the United States from Israel, where he was born to Israeli parents.\n∃x (ZionistLeader(x) ∧ ElectedToCouncil(x, shomronRegionalMunicipalCouncil)) ::: Several Zionist leaders have been elected to the Shomron Regional Municipal council.\nZionistLeader(david) ::: David Ha'ivri is a Zionist leader.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nBornInIsrael(david) ∧ IsraeliParent(david) ∧ ReceiveCitizenship(david) ::: David Ha'ivri is an Israeli citizen.\n\"\"\""
    ]
  },
  {
    "id": 634,
    "context": [
      "David Ha'ivri is a political strategist. ",
      "If you are born in Israel to at least one Israeli parent, then you receive citizenship at birth. ",
      "David Ha'ivri emigrated to the United States from Israel, where he was born to Israeli parents. ",
      "Several Zionist leaders have been elected to the Shomron Regional Municipal council. ",
      "David Ha'ivri is a Zionist leader. "
    ],
    "question": "David Ha'ivri is a United States citizen.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nPoliticalStrategist(x) ::: x is a political strategist.\nBornInIsrael(x) ::: x is born in Israel.\nIsraeliParent(x) ::: x has at least one Israeli parent.\nCitizenAtBirth(x) ::: x receives citizenship at birth.\nEmigrated(x, y, z) ::: x emigrated to y from z.\nElectedToCouncil(x, y) ::: x has been elected to council y.\nZionistLeader(x) ::: x is a Zionist leader.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nPoliticalStrategist(david) ::: David Ha'ivri is a political strategist.\n∀x (BornInIsrael(x) ∧ IsraeliParent(x) → CitizenAtBirth(x)) ::: If you are born in Israel to at least one Israeli parent, then you receive citizenship at birth.\nBornInIsrael(david) ∧ IsraeliParent(david) ∧ Emigrated(david, unitedStates, israel) ::: David Ha'ivri emigrated to the United States from Israel, where he was born to Israeli parents.\n∃x (ZionistLeader(x) ∧ ElectedToCouncil(x, shomronRegionalMunicipalCouncil)) ::: Several Zionist leaders have been elected to the Shomron Regional Municipal council.\nZionistLeader(david) ::: David Ha'ivri is a Zionist leader.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬CitizenAtBirth(david) ∧ Emigrated(david, unitedStates, israel) ::: David Ha'ivri is a United States citizen.\n\"\"\""
    ]
  },
  {
    "id": 635,
    "context": [
      "David Ha'ivri is a political strategist. ",
      "If you are born in Israel to at least one Israeli parent, then you receive citizenship at birth. ",
      "David Ha'ivri emigrated to the United States from Israel, where he was born to Israeli parents. ",
      "Several Zionist leaders have been elected to the Shomron Regional Municipal council. ",
      "David Ha'ivri is a Zionist leader. "
    ],
    "question": "David Ha'ivri has been elected to the Shomron Regional Municipal council.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nPoliticalStrategist(x) ::: x is a political strategist.\nBornInIsrael(x) ::: x is born in Israel.\nIsraeliParent(x) ::: x has at least one Israeli parent.\nReceiveCitizenship(x) ::: x receives citizenship at birth.\nEmigrate(x, y) ::: x emigrates to y.\nZionistLeader(x) ::: x is a Zionist leader.\nElected(x, y) ::: x is elected to y.\nCouncil(x) ::: x is the Shomron Regional Municipal council.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nPoliticalStrategist(david) ::: David Ha'ivri is a political strategist.\n∀x (BornInIsrael(x) ∧ IsraeliParent(x) → ReceiveCitizenship(x)) ::: If you are born in Israel to at least one Israeli parent, then you receive citizenship at birth.\nBornInIsrael(david) ∧ IsraeliParent(david) ∧ Emigrate(david, US) ∧ BornInIsrael(david) ∧ IsraeliParent(david) ::: David Ha'ivri emigrated to the United States from Israel, where he was born to Israeli parents.\n∃x (ZionistLeader(x) ∧ Elected(x, council)) ::: Several Zionist leaders have been elected to the Shomron Regional Municipal council.\nZionistLeader(david) ::: David Ha'ivri is a Zionist leader.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nElected(david, council) ::: David Ha'ivri has been elected to the Shomron Regional Municipal council.\n\"\"\""
    ]
  },
  {
    "id": 3,
    "context": [
      "Mary has the flu.",
      "Flu and influenza are the same disease.",
      "Susan doesn't have influenza."
    ],
    "question": "Either Mary or Susan has influenza.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nHas(x, y) ::: x has disease y.\nSame(x, y) ::: x is the same as y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nHas(mary, flu) ::: Mary has the flu.\n∀x (Same(flu, x) ∧ Same(x, influenza)) ::: Flu and influenza are the same disease.\n¬Has(susan, influenza) ::: Susan doesn't have influenza.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nHas(mary, influenza) ∨ Has(susan, influenza) ::: Either Mary or Susan has influenza.\n\"\"\""
    ]
  },
  {
    "id": 121,
    "context": [
      "James Cocks was a British lawyer.",
      "James Cocks was a Whig politician who sat in the House of Commons.",
      "A British is a European.",
      "Any lawyer is familiar with laws.",
      "Some Whigs speak French."
    ],
    "question": "No lawyer ever sat in the House of Commons.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nBritish(x) ::: x is British.\nLawyer(x) ::: x is a lawyer.\nPolitician(x) ::: x is a politician.\nSit(x, y) ::: x sat in y.\nEuropean(x) ::: x is European.\nFamiliar(x, y) ::: x is familiar with y.\nSpeak(x, y) ::: x speaks y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nBritish(jamesCocks) ∧ Lawyer(jamesCocks) ::: James Cocks was a British lawyer.\nPolitician(jamesCocks) ∧ Sit(jamesCocks, houseOfCommons) ::: James Cocks was a Whig politician who sat in the House of Commons.\n∀x (British(x) → European(x)) ::: A British is a European.\n∀x (Lawyer(x) → Familiar(x, laws)) ::: Any lawyer is familiar with laws.\n∃x (Politician(x) ∧ Speak(x, french)) ::: Some Whigs speak French.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬∃x (Lawyer(x) ∧ Sit(x, houseOfCommons)) ::: No lawyer ever sat in the House of Commons.\n\"\"\""
    ]
  },
  {
    "id": 122,
    "context": [
      "James Cocks was a British lawyer.",
      "James Cocks was a Whig politician who sat in the House of Commons.",
      "A British is a European.",
      "Any lawyer is familiar with laws.",
      "Some Whigs speak French."
    ],
    "question": "Some European is familiar with laws.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nBritish(x) ::: x is British.\nLawyer(x) ::: x is a lawyer.\nPolitician(x) ::: x is a politician.\nEuropean(x) ::: x is European.\nFamiliarWith(x, y) ::: x is familiar with y.\nSpeak(x, y) ::: x speaks y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nBritish(jamesCocks) ∧ Lawyer(jamesCocks) ::: James Cocks was a British lawyer.\nPolitician(jamesCocks) ∧ SitInHouseOfCommons(jamesCocks) ::: James Cocks was a Whig politician who sat in the House of Commons.\n∀x (British(x) → European(x)) ::: A British is a European.\n∀x (Lawyer(x) → FamiliarWith(x, laws)) ::: Any lawyer is familiar with laws.\n∃x (Whig(x) ∧ Speak(x, french)) ::: Some Whigs speak French.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n∃x (European(x) ∧ FamiliarWith(x, laws)) ::: Some European is familiar with laws.\n\"\"\""
    ]
  },
  {
    "id": 123,
    "context": [
      "James Cocks was a British lawyer.",
      "James Cocks was a Whig politician who sat in the House of Commons.",
      "A British is a European.",
      "Any lawyer is familiar with laws.",
      "Some Whigs speak French."
    ],
    "question": "James Cocks speaks French.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nBritish(x) ::: x is British.\nLawyer(x) ::: x is a lawyer.\nPolitician(x) ::: x is a politician.\nEuropean(x) ::: x is European.\nFamiliarWith(x, y) ::: x is familiar with y.\nSpeak(x, y) ::: x speaks y.\nWhig(x) ::: x is a Whig.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nBritish(jamesCocks) ∧ Lawyer(jamesCocks) ::: James Cocks was a British lawyer.\nWhig(jamesCocks) ∧ Politician(jamesCocks) ∧ SitInHouseOfCommons(jamesCocks) ::: James Cocks was a Whig politician who sat in the House of Commons.\n∀x (British(x) → European(x)) ::: A British is a European.\n∀x (Lawyer(x) → FamiliarWith(x, laws)) ::: Any lawyer is familiar with laws.\n∃x (Whig(x) ∧ Speak(x, french)) ::: Some Whigs speak French.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nSpeak(jamesCocks, french) ::: James Cocks speaks French.\n\"\"\""
    ]
  },
  {
    "id": 365,
    "context": [
      "Beasts of Prey is either a fantasy novel or a science fiction novel.",
      "Science fiction novels are not about mythological creatures",
      "Beasts of Prey Is about a creature known as the Shetani.",
      "Shetanis are mythological."
    ],
    "question": "Beasts of prey is a fantasy novel.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nFantasy(x) ::: x is a fantasy novel.\nScienceFiction(x) ::: x is a science fiction novel.\nAbout(x, y) ::: x is about y.\nMythologicalCreature(x) ::: x is a mythological creature.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nFantasy(beastsOfPrey) ∨ ScienceFiction(beastsOfPrey) ::: Beasts of Prey is either a fantasy novel or a science fiction novel.\n∀x (ScienceFiction(x) → ¬About(x, mythologicalCreature)) ::: Science fiction novels are not about mythological creatures.\nAbout(beastsOfPrey, shetani) ::: Beasts of Prey is about a creature known as the Shetani.\nMythologicalCreature(shetani) ::: Shetanis are mythological.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nFantasy(beastsOfPrey) ::: Beasts of prey is a fantasy novel.\n\"\"\""
    ]
  },
  {
    "id": 366,
    "context": [
      "Beasts of Prey is either a fantasy novel or a science fiction novel.",
      "Science fiction novels are not about mythological creatures",
      "Beasts of Prey Is about a creature known as the Shetani.",
      "Shetanis are mythological."
    ],
    "question": "Beasts of prey isn't a science fiction novel.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nFantasy(x) ::: x is a fantasy novel.\nScienceFiction(x) ::: x is a science fiction novel.\nAbout(x, y) ::: x is about y.\nMythologicalCreature(x) ::: x is a mythological creature.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n(Fantasy(beastsOfPrey) ∨ ScienceFiction(beastsOfPrey)) ::: Beasts of Prey is either a fantasy novel or a science fiction novel.\n∀x (ScienceFiction(x) → ¬About(x, mythologicalCreature)) ::: Science fiction novels are not about mythological creatures.\nAbout(beastsOfPrey, shetani) ::: Beasts of Prey is about a creature known as the Shetani.\nMythologicalCreature(shetani) ::: Shetanis are mythological.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬ScienceFiction(beastsOfPrey) ::: Beasts of prey isn't a science fiction novel.\n\"\"\""
    ]
  },
  {
    "id": 367,
    "context": [
      "Beasts of Prey is either a fantasy novel or a science fiction novel.",
      "Science fiction novels are not about mythological creatures",
      "Beasts of Prey Is about a creature known as the Shetani.",
      "Shetanis are mythological."
    ],
    "question": "A shetani is either mythological or a creature.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nFantasyNovel(x) ::: x is a fantasy novel.\nScienceFictionNovel(x) ::: x is a science fiction novel.\nAbout(x, y) ::: x is about y.\nCreature(x) ::: x is a creature.\nMythologicalCreature(x) ::: x is a mythological creature.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nFantasyNovel(beastsOfPrey) ∨ ScienceFictionNovel(beastsOfPrey) ::: Beasts of Prey is either a fantasy novel or a science fiction novel.\n∀x (ScienceFictionNovel(x) → ¬About(x, mythologicalCreatures)) ::: Science fiction novels are not about mythological creatures.\nAbout(beastsOfPrey, shetani) ::: Beasts of Prey is about a creature known as the Shetani.\nMythologicalCreature(shetani) ::: Shetanis are mythological.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nMythologicalCreature(shetani) ∨ Creature(shetani) ::: A shetani is either mythological or a creature.\n\"\"\""
    ]
  },
  {
    "id": 47,
    "context": [
      "Odell is an English surname originating in Odell, Bedfordshire.",
      "In some families Odell is spelled O'Dell, in a mistaken Irish adaptation.",
      "Notable people with the surname include Amy Odell, Jack Odell, and Mats Odell.",
      "Amy Odell is a British singer-songwriter.",
      "Jack Odell is an English toy inventor."
    ],
    "question": "Jack Odell is a notable people.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nSurname(x) ::: x is a surname.\nOriginatingIn(x, y) ::: x originates in y.\nSpelled(x, y) ::: x is spelled as y.\nMistakenAdaptation(x, y, z) ::: x is mistakenly adapted from y to z.\nNotable(x) ::: x is a notable person.\nPerson(x) ::: x is a person.\nSingerSongwriter(x) ::: x is a singer-songwriter.\nToyInventor(x) ::: x is a toy inventor.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nSurname(odell) ∧ OriginatingIn(odell, bedfordshire) ::: Odell is an English surname originating in Odell, Bedfordshire.\n∃x (Surname(odell) ∧ Spelled(odell, o'dell) ∧ MistakenAdaptation(o'dell, irish, odell)) ::: In some families Odell is spelled O'Dell, in a mistaken Irish adaptation.\nNotable(amyOdell) ∧ Notable(jackOdell) ∧ Notable(matsOdell) ∧ Person(amyOdell) ∧ Person(jackOdell) ∧ Person(matsOdell) ::: Notable people with the surname include Amy Odell, Jack Odell, and Mats Odell.\nSingerSongwriter(amyOdell) ::: Amy Odell is a British singer-songwriter.\nToyInventor(jackOdell) ::: Jack Odell is an English toy inventor.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nNotable(jackOdell) ::: Jack Odell is a notable person.\n\"\"\""
    ]
  },
  {
    "id": 48,
    "context": [
      "Odell is an English surname originating in Odell, Bedfordshire.",
      "In some families Odell is spelled O'Dell, in a mistaken Irish adaptation.",
      "Notable people with the surname include Amy Odell, Jack Odell, and Mats Odell.",
      "Amy Odell is a British singer-songwriter.",
      "Jack Odell is an English toy inventor."
    ],
    "question": "Odell is Amy Odell's surname.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nSurname(x) ::: x is a surname.\nOriginatingIn(x, y) ::: x originates in y.\nSpelled(x, y) ::: x is spelled as y.\nMistakenAdaptation(x, y, z) ::: x is a mistaken adaptation of y in z.\nPerson(x) ::: x is a person.\nSingerSongwriter(x) ::: x is a singer-songwriter.\nToyInventor(x) ::: x is a toy inventor.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nOriginatingIn(odell, bedfordshire) ∧ Surname(odell) ::: Odell is an English surname originating in Odell, Bedfordshire.\n∃x (Surname(odell) ∧ Spelled(odell, o'dell) ∧ MistakenAdaptation(o'dell, irish, odell)) ::: In some families Odell is spelled O'Dell, in a mistaken Irish adaptation.\nPerson(amyOdell) ∧ Person(jackOdell) ∧ Person(matsOdell) ∧ Surname(amyOdell) ∧ Surname(jackOdell) ∧ Surname(matsOdell) ::: Notable people with the surname include Amy Odell, Jack Odell, and Mats Odell.\nSingerSongwriter(amyOdell) ::: Amy Odell is a British singer-songwriter.\nToyInventor(jackOdell) ::: Jack Odell is an English toy inventor.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nSurname(odell, amyOdell) ::: Odell is Amy Odell's surname.\n\"\"\""
    ]
  },
  {
    "id": 49,
    "context": [
      "Odell is an English surname originating in Odell, Bedfordshire.",
      "In some families Odell is spelled O'Dell, in a mistaken Irish adaptation.",
      "Notable people with the surname include Amy Odell, Jack Odell, and Mats Odell.",
      "Amy Odell is a British singer-songwriter.",
      "Jack Odell is an English toy inventor."
    ],
    "question": "Amy Odell is an English toy inventor.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nSurname(x) ::: x is a surname.\nOriginatingIn(x, y) ::: x originates in y.\nSpelled(x, y) ::: x is spelled as y.\nMistakenAdaptation(x, y, z) ::: x is a mistaken adaptation of y in z.\nPerson(x) ::: x is a person.\nSingerSongwriter(x) ::: x is a singer-songwriter.\nToyInventor(x) ::: x is a toy inventor.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nSurname(odell) ∧ OriginatingIn(odell, bedfordshire) ::: Odell is an English surname originating in Odell, Bedfordshire.\n∃x (Surname(odell) ∧ Spelled(odell, o'dell) ∧ MistakenAdaptation(odell, o'dell, irish)) ::: In some families Odell is spelled O'Dell, in a mistaken Irish adaptation.\nPerson(amy) ∧ Surname(amy) ∧ SingerSongwriter(amy) ::: Amy Odell is a British singer-songwriter.\nPerson(jack) ∧ Surname(jack) ∧ ToyInventor(jack) ::: Jack Odell is an English toy inventor.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nToyInventor(amy) ::: Amy Odell is an English toy inventor.\n\"\"\""
    ]
  },
  {
    "id": 50,
    "context": [
      "Odell is an English surname originating in Odell, Bedfordshire.",
      "In some families Odell is spelled O'Dell, in a mistaken Irish adaptation.",
      "Notable people with the surname include Amy Odell, Jack Odell, and Mats Odell.",
      "Amy Odell is a British singer-songwriter.",
      "Jack Odell is an English toy inventor."
    ],
    "question": "Amy Odell is also Amy O'dell.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nSurname(x) ::: x is a surname.\nOriginatingIn(x, y) ::: x originates in y.\nSpelled(x, y) ::: x is spelled as y.\nMistakenAdaptation(x, y, z) ::: x is a mistaken adaptation of y in z.\nPerson(x) ::: x is a person.\nSingerSongwriter(x) ::: x is a singer-songwriter.\nToyInventor(x) ::: x is a toy inventor.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nSurname(odell) ∧ OriginatingIn(odell, bedfordshire) ::: Odell is an English surname originating in Odell, Bedfordshire.\n∃x (Surname(odell) ∧ Spelled(odell, o'dell) ∧ MistakenAdaptation(odell, o'dell, irish)) ::: In some families Odell is spelled O'Dell, in a mistaken Irish adaptation.\nPerson(amy) ∧ Surname(amy) ∧ SingerSongwriter(amy) ::: Amy Odell is a British singer-songwriter.\nPerson(jack) ∧ Surname(jack) ∧ ToyInventor(jack) ::: Jack Odell is an English toy inventor.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nSpelled(amy, o'dell) ::: Amy Odell is also Amy O'dell.\n\"\"\""
    ]
  },
  {
    "id": 482,
    "context": [
      "If you go somewhere by train, you will not lose time.",
      "If you go somewhere by car and meet traffic jam, you will lose time.",
      "If you lose time, you will be late for work.",
      "Mary can get from New Haven to New York City either by train or car.",
      "Mary is late for work."
    ],
    "question": "Mary gets from New Haven to New York City by train.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nGoByTrain(x) ::: x goes somewhere by train.\nGoByCar(x) ::: x goes somewhere by car.\nMeetTrafficJam(x) ::: x meets traffic jam.\nLoseTime(x) ::: x loses time.\nLateForWork(x) ::: x is late for work.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nGoByTrain(x) → ¬LoseTime(x) ::: If you go somewhere by train, you will not lose time.\n(GoByCar(x) ∧ MeetTrafficJam(x)) → LoseTime(x) ::: If you go somewhere by car and meet traffic jam, you will lose time.\nLoseTime(x) → LateForWork(x) ::: If you lose time, you will be late for work.\n(GoByTrain(mary) ∨ GoByCar(mary)) ∧ LateForWork(mary) ::: Mary can get from New Haven to New York City either by train or car, and Mary is late for work.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nGoByTrain(mary) ::: Mary gets from New Haven to New York City by train.\n\"\"\""
    ]
  },
  {
    "id": 483,
    "context": [
      "If you go somewhere by train, you will not lose time.",
      "If you go somewhere by car and meet traffic jam, you will lose time.",
      "If you lose time, you will be late for work.",
      "Mary can get from New Haven to New York City either by train or car.",
      "Mary is late for work."
    ],
    "question": "Mary gets from New Haven to New York City by car.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nGoByTrain(x) ::: x goes somewhere by train.\nGoByCar(x) ::: x goes somewhere by car.\nMeetTrafficJam(x) ::: x meets traffic jam.\nLoseTime(x) ::: x loses time.\nLateForWork(x) ::: x is late for work.\nFrom(x, y, z) ::: x can get from y to z.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nGoByTrain(x) → ¬LoseTime(x) ::: If you go somewhere by train, you will not lose time.\n(GoByCar(x) ∧ MeetTrafficJam(x)) → LoseTime(x) ::: If you go somewhere by car and meet traffic jam, you will lose time.\nLoseTime(x) → LateForWork(x) ::: If you lose time, you will be late for work.\n(From(mary, newHaven, newYorkCity) ∧ GoByTrain(mary)) ∨ (From(mary, newHaven, newYorkCity) ∧ GoByCar(mary)) ::: Mary can get from New Haven to New York City either by train or car.\nLateForWork(mary) ::: Mary is late for work.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nFrom(mary, newHaven, newYorkCity) ∧ GoByCar(mary) ::: Mary gets from New Haven to New York City by car.\n\"\"\""
    ]
  },
  {
    "id": 484,
    "context": [
      "If you go somewhere by train, you will not lose time.",
      "If you go somewhere by car and meet traffic jam, you will lose time.",
      "If you lose time, you will be late for work.",
      "Mary can get from New Haven to New York City either by train or car.",
      "Mary is late for work."
    ],
    "question": "Mary meets traffic jam.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nGoByTrain(x) ::: x goes somewhere by train.\nGoByCar(x) ::: x goes somewhere by car.\nMeetTrafficJam(x) ::: x meets traffic jam.\nLoseTime(x) ::: x loses time.\nLateForWork(x) ::: x is late for work.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nGoByTrain(x) → ¬LoseTime(x) ::: If you go somewhere by train, you will not lose time.\n(GoByCar(x) ∧ MeetTrafficJam(x)) → LoseTime(x) ::: If you go somewhere by car and meet traffic jam, you will lose time.\nLoseTime(x) → LateForWork(x) ::: If you lose time, you will be late for work.\n(GoByTrain(mary) ∨ GoByCar(mary)) ::: Mary can get from New Haven to New York City either by train or car.\nLateForWork(mary) ::: Mary is late for work.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nMeetTrafficJam(mary) ::: Mary meets traffic jam.\n\"\"\""
    ]
  },
  {
    "id": 746,
    "context": [
      "If a person is hungry, the person is uncomfortable.",
      "If a person is uncomfortable, the person is unhappy."
    ],
    "question": "If a person is not hungry, the person is unhappy.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nHungry(x) ::: x is hungry.\nUncomfortable(x) ::: x is uncomfortable.\nUnhappy(x) ::: x is unhappy.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nHungry(x) → Uncomfortable(x) ::: If a person is hungry, the person is uncomfortable.\nUncomfortable(x) → Unhappy(x) ::: If a person is uncomfortable, the person is unhappy.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬Hungry(x) → Unhappy(x) ::: If a person is not hungry, the person is unhappy.\n\"\"\""
    ]
  },
  {
    "id": 769,
    "context": [
      "Tipped employees do not get a guaranteed minimum wage.",
      "If a person is a white-collar worker, they will get a guaranteed minimum wage (All white-collar workers get a guaranteed minimum wage).",
      "All lawyers are white-collar workers.",
      "Every advocate is a lawyer.",
      "Mary is not a lawyer or a tipped employee."
    ],
    "question": "Mary is a white-collar worker.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nTipped(x) ::: x is a tipped employee.\nMinimumWage(x) ::: x gets a guaranteed minimum wage.\nWhiteCollar(x) ::: x is a white-collar worker.\nLawyer(x) ::: x is a lawyer.\nAdvocate(x) ::: x is an advocate.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n¬MinimumWage(tipped) ::: Tipped employees do not get a guaranteed minimum wage.\nWhiteCollar(x) → MinimumWage(x) ::: If a person is a white-collar worker, they will get a guaranteed minimum wage (All white-collar workers get a guaranteed minimum wage).\n∀x (Lawyer(x) → WhiteCollar(x)) ::: All lawyers are white-collar workers.\n∀x (Advocate(x) → Lawyer(x)) ::: Every advocate is a lawyer.\n¬(Lawyer(mary) ∨ Tipped(mary)) ::: Mary is not a lawyer or a tipped employee.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nWhiteCollar(mary) ::: Mary is a white-collar worker.\n\"\"\""
    ]
  },
  {
    "id": 770,
    "context": [
      "Tipped employees do not get a guaranteed minimum wage.",
      "If a person is a white-collar worker, they will get a guaranteed minimum wage (All white-collar workers get a guaranteed minimum wage).",
      "All lawyers are white-collar workers.",
      "Every advocate is a lawyer.",
      "Mary is not a lawyer or a tipped employee."
    ],
    "question": "Mary is an advocate.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nTipped(x) ::: x is a tipped employee.\nMinimumWage(x) ::: x gets a guaranteed minimum wage.\nWhiteCollar(x) ::: x is a white-collar worker.\nLawyer(x) ::: x is a lawyer.\nAdvocate(x) ::: x is an advocate.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n¬MinimumWage(x) → Tipped(x) ::: Tipped employees do not get a guaranteed minimum wage.\nWhiteCollar(x) → MinimumWage(x) ::: If a person is a white-collar worker, they will get a guaranteed minimum wage.\n∀x (Lawyer(x) → WhiteCollar(x)) ::: All lawyers are white-collar workers.\n∀x (Advocate(x) → Lawyer(x)) ::: Every advocate is a lawyer.\n¬(Lawyer(mary) ∨ Tipped(mary)) ::: Mary is not a lawyer or a tipped employee.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nAdvocate(mary) ::: Mary is an advocate.\n\"\"\""
    ]
  },
  {
    "id": 771,
    "context": [
      "Tipped employees do not get a guaranteed minimum wage.",
      "If a person is a white-collar worker, they will get a guaranteed minimum wage (All white-collar workers get a guaranteed minimum wage).",
      "All lawyers are white-collar workers.",
      "Every advocate is a lawyer.",
      "Mary is not a lawyer or a tipped employee."
    ],
    "question": "Mary is not an advocate.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nTipped(x) ::: x is a tipped employee.\nMinimumWage(x) ::: x gets a guaranteed minimum wage.\nWhiteCollar(x) ::: x is a white-collar worker.\nLawyer(x) ::: x is a lawyer.\nAdvocate(x) ::: x is an advocate.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n¬MinimumWage(x) → Tipped(x) ::: Tipped employees do not get a guaranteed minimum wage.\nWhiteCollar(x) → MinimumWage(x) ::: If a person is a white-collar worker, they will get a guaranteed minimum wage.\n∀x (Lawyer(x) → WhiteCollar(x)) ::: All lawyers are white-collar workers.\n∀x (Advocate(x) → Lawyer(x)) ::: Every advocate is a lawyer.\n¬(Lawyer(mary) ∨ Tipped(mary)) ::: Mary is not a lawyer or a tipped employee.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬Advocate(mary) ::: Mary is not an advocate.\n\"\"\""
    ]
  },
  {
    "id": 772,
    "context": [
      "Tipped employees do not get a guaranteed minimum wage.",
      "If a person is a white-collar worker, they will get a guaranteed minimum wage (All white-collar workers get a guaranteed minimum wage).",
      "All lawyers are white-collar workers.",
      "Every advocate is a lawyer.",
      "Mary is not a lawyer or a tipped employee."
    ],
    "question": "Mary is either an advocate or a tipped employee.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nTipped(x) ::: x is a tipped employee.\nGuaranteedMinimumWage(x) ::: x gets a guaranteed minimum wage.\nWhiteCollar(x) ::: x is a white-collar worker.\nLawyer(x) ::: x is a lawyer.\nAdvocate(x) ::: x is an advocate.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Tipped(x) → ¬GuaranteedMinimumWage(x)) ::: Tipped employees do not get a guaranteed minimum wage.\n∀x (WhiteCollar(x) → GuaranteedMinimumWage(x)) ::: If a person is a white-collar worker, they will get a guaranteed minimum wage.\n∀x (Lawyer(x) → WhiteCollar(x)) ::: All lawyers are white-collar workers.\n∀x (Advocate(x) → Lawyer(x)) ::: Every advocate is a lawyer.\n¬(Lawyer(mary) ∨ Tipped(mary)) ::: Mary is not a lawyer or a tipped employee.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nAdvocate(mary) ∨ Tipped(mary) ::: Mary is either an advocate or a tipped employee.\n\"\"\""
    ]
  },
  {
    "id": 773,
    "context": [
      "Tipped employees do not get a guaranteed minimum wage.",
      "If a person is a white-collar worker, they will get a guaranteed minimum wage (All white-collar workers get a guaranteed minimum wage).",
      "All lawyers are white-collar workers.",
      "Every advocate is a lawyer.",
      "Mary is not a lawyer or a tipped employee."
    ],
    "question": "If Mary is not an advocate and gets a guaranteed minimum wage, she is not a tipped employee.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nTipped(x) ::: x is a tipped employee.\nGuaranteedMinimumWage(x) ::: x gets a guaranteed minimum wage.\nWhiteCollar(x) ::: x is a white-collar worker.\nLawyer(x) ::: x is a lawyer.\nAdvocate(x) ::: x is an advocate.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Tipped(x) → ¬GuaranteedMinimumWage(x)) ::: Tipped employees do not get a guaranteed minimum wage.\n∀x (WhiteCollar(x) → GuaranteedMinimumWage(x)) ::: If a person is a white-collar worker, they will get a guaranteed minimum wage (All white-collar workers get a guaranteed minimum wage).\n∀x (Lawyer(x) → WhiteCollar(x)) ::: All lawyers are white-collar workers.\n∀x (Advocate(x) → Lawyer(x)) ::: Every advocate is a lawyer.\n¬(Lawyer(mary) ∨ Tipped(mary)) ::: Mary is not a lawyer or a tipped employee.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n(¬Advocate(mary) ∧ GuaranteedMinimumWage(mary)) → ¬Tipped(mary) ::: If Mary is not an advocate and gets a guaranteed minimum wage, she is not a tipped employee.\n\"\"\""
    ]
  },
  {
    "id": 774,
    "context": [
      "Tipped employees do not get a guaranteed minimum wage.",
      "If a person is a white-collar worker, they will get a guaranteed minimum wage (All white-collar workers get a guaranteed minimum wage).",
      "All lawyers are white-collar workers.",
      "Every advocate is a lawyer.",
      "Mary is not a lawyer or a tipped employee."
    ],
    "question": "If Mary is either an advocate or a tipped employee, she is an advocate.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nTipped(x) ::: x is a tipped employee.\nGuaranteedMinimumWage(x) ::: x gets a guaranteed minimum wage.\nWhiteCollarWorker(x) ::: x is a white-collar worker.\nLawyer(x) ::: x is a lawyer.\nAdvocate(x) ::: x is an advocate.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n¬GuaranteedMinimumWage(x) ::: Tipped employees do not get a guaranteed minimum wage.\nWhiteCollarWorker(x) → GuaranteedMinimumWage(x) ::: If a person is a white-collar worker, they will get a guaranteed minimum wage (All white-collar workers get a guaranteed minimum wage).\n∀x (Lawyer(x) → WhiteCollarWorker(x)) ::: All lawyers are white-collar workers.\n∀x (Advocate(x) → Lawyer(x)) ::: Every advocate is a lawyer.\n¬(Lawyer(mary) ∨ Tipped(mary)) ::: Mary is not a lawyer or a tipped employee.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n(Advocate(mary) ∨ Tipped(mary)) → Advocate(mary) ::: If Mary is either an advocate or a tipped employee, she is an advocate.\n\"\"\""
    ]
  },
  {
    "id": 232,
    "context": [
      "Asa Hoffmann was born in New York City.",
      "Asa Hoffman lives in Manhattan.",
      "Asa Hoffman is a chess player.",
      "Some chess players are grandmasters.",
      "People born and living in New York City are New Yorkers.",
      "People liviing in Manhattan live in New York City."
    ],
    "question": "Asa Hoffmann is a New Yorkers.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nBornIn(x, y) ::: x was born in y.\nLivesIn(x, y) ::: x lives in y.\nChessPlayer(x) ::: x is a chess player.\nGrandmaster(x) ::: x is a grandmaster.\nNewYorker(x) ::: x is a New Yorker.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nBornIn(asaHoffmann, newYorkCity) ::: Asa Hoffmann was born in New York City.\nLivesIn(asaHoffmann, manhattan) ::: Asa Hoffman lives in Manhattan.\nChessPlayer(asaHoffmann) ::: Asa Hoffman is a chess player.\n∃x (ChessPlayer(x) ∧ Grandmaster(x)) ::: Some chess players are grandmasters.\n∀x ((BornIn(x, newYorkCity) ∧ LivesIn(x, newYorkCity)) → NewYorker(x)) ::: People born and living in New York City are New Yorkers.\nLivesIn(manhattan, newYorkCity) ::: People living in Manhattan live in New York City.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nNewYorker(asaHoffmann) ::: Asa Hoffmann is a New Yorker.\n\"\"\""
    ]
  },
  {
    "id": 233,
    "context": [
      "Asa Hoffmann was born in New York City.",
      "Asa Hoffman lives in Manhattan.",
      "Asa Hoffman is a chess player.",
      "Some chess players are grandmasters.",
      "People born and living in New York City are New Yorkers.",
      "People liviing in Manhattan live in New York City."
    ],
    "question": "Asa Hoffmann is a grandmaster.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nBorn(x, y) ::: x was born in y.\nLives(x, y) ::: x lives in y.\nChessPlayer(x) ::: x is a chess player.\nGrandmaster(x) ::: x is a grandmaster.\nNewYorker(x) ::: x is a New Yorker.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nBorn(asaHoffmann, newYorkCity) ::: Asa Hoffmann was born in New York City.\nLives(asaHoffmann, manhattan) ::: Asa Hoffman lives in Manhattan.\nChessPlayer(asaHoffmann) ::: Asa Hoffman is a chess player.\n∃x (ChessPlayer(x) ∧ Grandmaster(x)) ::: Some chess players are grandmasters.\n∀x ((Born(x, newYorkCity) ∧ Lives(x, newYorkCity)) → NewYorker(x)) ::: People born and living in New York City are New Yorkers.\nLives(manhattan, newYorkCity) ::: People living in Manhattan live in New York City.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nGrandmaster(asaHoffmann) ::: Asa Hoffmann is a grandmaster.\n\"\"\""
    ]
  },
  {
    "id": 234,
    "context": [
      "Asa Hoffmann was born in New York City.",
      "Asa Hoffman lives in Manhattan.",
      "Asa Hoffman is a chess player.",
      "Some chess players are grandmasters.",
      "People born and living in New York City are New Yorkers.",
      "People liviing in Manhattan live in New York City."
    ],
    "question": "Asa Hoffmann does not live in New York.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nBornIn(x, y) ::: x was born in y.\nLivesIn(x, y) ::: x lives in y.\nChessPlayer(x) ::: x is a chess player.\nGrandmaster(x) ::: x is a grandmaster.\nNewYorker(x) ::: x is a New Yorker.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nBornIn(asaHoffmann, newYorkCity) ::: Asa Hoffmann was born in New York City.\nLivesIn(asaHoffmann, manhattan) ::: Asa Hoffman lives in Manhattan.\nChessPlayer(asaHoffmann) ::: Asa Hoffman is a chess player.\n∃x (ChessPlayer(x) ∧ Grandmaster(x)) ::: Some chess players are grandmasters.\n∀x ((BornIn(x, newYorkCity) ∧ LivesIn(x, newYorkCity)) → NewYorker(x)) ::: People born and living in New York City are New Yorkers.\nLivesIn(manhattan, newYorkCity) ::: People living in Manhattan live in New York City.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬LivesIn(asaHoffmann, newYorkCity) ::: Asa Hoffmann does not live in New York.\n\"\"\""
    ]
  },
  {
    "id": 784,
    "context": [
      "Some of those who apply for a Schengen Visa get it.",
      "To apply for a Schengen Visa, you need to provide financial guarantees.",
      "If you need to provide financial guarantees, you must request documents from the bank.",
      "Do not close your bank account if you request documents from the bank.",
      "Philip closed his bank account."
    ],
    "question": "Philip got a Schengen Visa.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nApply(x) ::: x applies for a Schengen Visa.\nGet(x) ::: x gets a Schengen Visa.\nProvide(x) ::: x provides financial guarantees.\nRequest(x) ::: x requests documents from the bank.\nClose(x) ::: x closes his bank account.\nBank(x) ::: x is a bank.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∃x (Apply(x) ∧ Get(x)) ::: Some of those who apply for a Schengen Visa get it.\n∀x (Apply(x) → Provide(x)) ::: To apply for a Schengen Visa, you need to provide financial guarantees.\n∀x (Provide(x) → Request(x)) ::: If you need to provide financial guarantees, you must request documents from the bank.\nRequest(x) → ¬Close(x) ::: Do not close your bank account if you request documents from the bank.\nClose(philip) ::: Philip closed his bank account.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nGet(philip) ::: Philip got a Schengen Visa.\n\"\"\""
    ]
  },
  {
    "id": 785,
    "context": [
      "Some of those who apply for a Schengen Visa get it.",
      "To apply for a Schengen Visa, you need to provide financial guarantees.",
      "If you need to provide financial guarantees, you must request documents from the bank.",
      "Do not close your bank account if you request documents from the bank.",
      "Philip closed his bank account."
    ],
    "question": "Philip applied for a Schengen Visa and got it.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nApply(x) ::: x applies for a Schengen Visa.\nGet(x) ::: x gets a Schengen Visa.\nProvide(x) ::: x provides financial guarantees.\nRequest(x) ::: x requests documents from the bank.\nClose(x) ::: x closes his bank account.\nBank(x) ::: x is a bank.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∃x (Apply(x) ∧ Get(x)) ::: Some of those who apply for a Schengen Visa get it.\n∀x (Apply(x) → Provide(x)) ::: To apply for a Schengen Visa, you need to provide financial guarantees.\n∀x (Provide(x) → Request(x)) ::: If you need to provide financial guarantees, you must request documents from the bank.\nRequest(x) → ¬Close(x) ::: Do not close your bank account if you request documents from the bank.\nClose(philip) ::: Philip closed his bank account.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nApply(philip) ∧ Get(philip) ::: Philip applied for a Schengen Visa and got it.\n\"\"\""
    ]
  },
  {
    "id": 786,
    "context": [
      "Some of those who apply for a Schengen Visa get it.",
      "To apply for a Schengen Visa, you need to provide financial guarantees.",
      "If you need to provide financial guarantees, you must request documents from the bank.",
      "Do not close your bank account if you request documents from the bank.",
      "Philip closed his bank account."
    ],
    "question": "If Philip did not request documents from the bank or get a Schengen Visa, he didn’t apply for a Schengen Visa.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nApply(x) ::: x applies for a Schengen Visa.\nGet(x) ::: x gets a Schengen Visa.\nProvide(x) ::: x provides financial guarantees.\nRequest(x) ::: x requests documents from the bank.\nClose(x) ::: x closes his bank account.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∃x (Apply(x) ∧ Get(x)) ::: Some of those who apply for a Schengen Visa get it.\n∀x (Apply(x) → Provide(x)) ::: To apply for a Schengen Visa, you need to provide financial guarantees.\n∀x (Provide(x) → Request(x)) ::: If you need to provide financial guarantees, you must request documents from the bank.\n(Request(philip) ∧ ¬Close(philip)) → ¬Close(philip) ::: Do not close your bank account if you request documents from the bank.\nClose(philip) ::: Philip closed his bank account.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n(¬Request(philip) ∨ ¬Get(philip)) → ¬Apply(philip) ::: If Philip did not request documents from the bank or get a Schengen Visa, he didn’t apply for a Schengen Visa.\n\"\"\""
    ]
  },
  {
    "id": 745,
    "context": [
      "Some fears lead to anxiety.",
      "Some anxiety leads to terror."
    ],
    "question": "No fears lead to terror.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nFear(x) ::: x is a fear.\nAnxiety(x) ::: x is anxiety.\nTerror(x) ::: x is terror.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∃x (Fear(x) ∧ LeadsTo(x, anxiety)) ::: Some fears lead to anxiety.\n∃x (Anxiety(x) ∧ LeadsTo(x, terror)) ::: Some anxiety leads to terror.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬∃x (Fear(x) ∧ LeadsTo(x, terror)) ::: No fears lead to terror.\n\"\"\""
    ]
  },
  {
    "id": 598,
    "context": [
      "The Great Lakes are Lake Superior, Lake Michigan, Lake Huron, Lake Erie, and Lake Ontario.",
      "Some major settlements of Lake Erie are in NY, PA, OH, and MI.",
      "NY, PA, OH, MI are states in the US.",
      "ON is a state of Canada.",
      "There is a major settlement of Lake Huron in ON. ",
      "All states are in their country.",
      "The US is in North America.",
      "The Great Lakes began to form at the end of the Last Glacial Period."
    ],
    "question": "Lake Erie has a major settlement.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nLake(x) ::: x is a lake.\nSettlement(x) ::: x is a major settlement.\nState(x) ::: x is a state.\nCountry(x) ::: x is a country.\nIn(x, y) ::: x is in y.\nForm(x, y) ::: x began to form at y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nLake(superior) ∧ Lake(michigan) ∧ Lake(huron) ∧ Lake(erie) ∧ Lake(ontario) ::: The Great Lakes are Lake Superior, Lake Michigan, Lake Huron, Lake Erie, and Lake Ontario.\n∃x (Settlement(x) ∧ In(x, NY) ∧ In(x, PA) ∧ In(x, OH) ∧ In(x, MI)) ::: Some major settlements of Lake Erie are in NY, PA, OH, and MI.\nState(NY) ∧ State(PA) ∧ State(OH) ∧ State(MI) ∧ State(ON) ::: NY, PA, OH, MI are states in the US. ON is a state of Canada.\n∃x (Settlement(x) ∧ In(x, ON)) ∧ In(ON, Canada) ::: There is a major settlement of Lake Huron in ON.\n∀x (State(x) → In(x, Country(x))) ::: All states are in their country.\nIn(US, NorthAmerica) ::: The US is in North America.\nForm(GreatLakes, endOfLastGlacialPeriod) ::: The Great Lakes began to form at the end of the Last Glacial Period.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n∃x (Settlement(x) ∧ In(x, LakeErie)) ::: Lake Erie has a major settlement.\n\"\"\""
    ]
  },
  {
    "id": 599,
    "context": [
      "The Great Lakes are Lake Superior, Lake Michigan, Lake Huron, Lake Erie, and Lake Ontario.",
      "Some major settlements of Lake Erie are in NY, PA, OH, and MI.",
      "NY, PA, OH, MI are states in the US.",
      "ON is a state of Canada.",
      "There is a major settlement of Lake Huron in ON. ",
      "All states are in their country.",
      "The US is in North America.",
      "The Great Lakes began to form at the end of the Last Glacial Period."
    ],
    "question": "There is a great lake that did not form at the end of the Last Glacial Period.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nGreatLake(x) ::: x is a Great Lake.\nMajorSettlement(x, y) ::: x is a major settlement of y.\nState(x) ::: x is a state.\nCountry(x) ::: x is a country.\nIn(x, y) ::: x is in y.\nFormed(x, y) ::: x formed at the end of y.\nLastGlacialPeriod(x) ::: x is the Last Glacial Period.\nNorthAmerica(x) ::: x is North America.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nGreatLake(superior) ∧ GreatLake(michigan) ∧ GreatLake(huron) ∧ GreatLake(erie) ∧ GreatLake(ontario) ::: The Great Lakes are Lake Superior, Lake Michigan, Lake Huron, Lake Erie, and Lake Ontario.\n∃x (MajorSettlement(x, erie) ∧ In(x, NY) ∧ In(x, PA) ∧ In(x, OH) ∧ In(x, MI)) ::: Some major settlements of Lake Erie are in NY, PA, OH, and MI.\nState(NY) ∧ State(PA) ∧ State(OH) ∧ State(MI) ∧ State(ON) ::: NY, PA, OH, MI are states in the US. ON is a state of Canada.\nMajorSettlement(x, huron) ∧ In(x, ON) ::: There is a major settlement of Lake Huron in ON.\n∀x (State(x) → In(x, Country(x))) ::: All states are in their country.\nIn(US, NorthAmerica) ::: The US is in North America.\nFormed(GreatLakes, LastGlacialPeriod) ::: The Great Lakes began to form at the end of the Last Glacial Period.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n∃x (GreatLake(x) ∧ ¬Formed(x, LastGlacialPeriod)) ::: There is a great lake that did not form at the end of the Last Glacial Period.\n\"\"\""
    ]
  },
  {
    "id": 836,
    "context": [
      "All defenders are soccer players.",
      "No soccer players are professional basketball players.",
      "All centerbacks are defenders.",
      "All NBA players are professional basketball players.",
      "If Stephen Curry is not an NBA player, then Stephen Curry is not an NBA player or a soccer player."
    ],
    "question": "Stephen Curry is a professional basketball player.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nDefender(x) ::: x is a defender.\nSoccerPlayer(x) ::: x is a soccer player.\nBasketballPlayer(x) ::: x is a basketball player.\nCenterback(x) ::: x is a centerback.\nNBAPlayer(x) ::: x is an NBA player.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Defender(x) → SoccerPlayer(x)) ::: All defenders are soccer players.\n∀x (SoccerPlayer(x) → ¬ProfessionalBasketballPlayer(x)) ::: No soccer players are professional basketball players.\n∀x (Centerback(x) → Defender(x)) ::: All centerbacks are defenders.\n∀x (NBAPlayer(x) → ProfessionalBasketballPlayer(x)) ::: All NBA players are professional basketball players.\n¬NBAPlayer(stephenCurry) → (¬NBAPlayer(stephenCurry) ∨ ¬SoccerPlayer(stephenCurry)) ::: If Stephen Curry is not an NBA player, then Stephen Curry is not an NBA player or a soccer player.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nProfessionalBasketballPlayer(stephenCurry) ::: Stephen Curry is a professional basketball player.\n\"\"\""
    ]
  },
  {
    "id": 837,
    "context": [
      "All defenders are soccer players.",
      "No soccer players are professional basketball players.",
      "All centerbacks are defenders.",
      "All NBA players are professional basketball players.",
      "If Stephen Curry is not an NBA player, then Stephen Curry is not an NBA player or a soccer player."
    ],
    "question": "Stephen Curry is a centerback.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nDefender(x) ::: x is a defender.\nSoccerPlayer(x) ::: x is a soccer player.\nBasketballPlayer(x) ::: x is a basketball player.\nCenterback(x) ::: x is a centerback.\nNBAPlayer(x) ::: x is an NBA player.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Defender(x) → SoccerPlayer(x)) ::: All defenders are soccer players.\n∀x (SoccerPlayer(x) → ¬ProfessionalBasketballPlayer(x)) ::: No soccer players are professional basketball players.\n∀x (Centerback(x) → Defender(x)) ::: All centerbacks are defenders.\n∀x (NBAPlayer(x) → ProfessionalBasketballPlayer(x)) ::: All NBA players are professional basketball players.\n¬NBAPlayer(stephenCurry) → (¬NBAPlayer(stephenCurry) ∨ ¬SoccerPlayer(stephenCurry)) ::: If Stephen Curry is not an NBA player, then Stephen Curry is not an NBA player or a soccer player.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nCenterback(stephenCurry) ::: Stephen Curry is a centerback.\n\"\"\""
    ]
  },
  {
    "id": 838,
    "context": [
      "All defenders are soccer players.",
      "No soccer players are professional basketball players.",
      "All centerbacks are defenders.",
      "All NBA players are professional basketball players.",
      "If Stephen Curry is not an NBA player, then Stephen Curry is not an NBA player or a soccer player."
    ],
    "question": "Stephen Curry is not a centerback.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nDefender(x) ::: x is a defender.\nSoccerPlayer(x) ::: x is a soccer player.\nBasketballPlayer(x) ::: x is a basketball player.\nCenterback(x) ::: x is a centerback.\nNBAPlayer(x) ::: x is an NBA player.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Defender(x) → SoccerPlayer(x)) ::: All defenders are soccer players.\n∀x (SoccerPlayer(x) → ¬ProfessionalBasketballPlayer(x)) ::: No soccer players are professional basketball players.\n∀x (Centerback(x) → Defender(x)) ::: All centerbacks are defenders.\n∀x (NBAPlayer(x) → ProfessionalBasketballPlayer(x)) ::: All NBA players are professional basketball players.\n¬NBAPlayer(stephenCurry) → (¬NBAPlayer(stephenCurry) ∨ ¬SoccerPlayer(stephenCurry)) ::: If Stephen Curry is not an NBA player, then Stephen Curry is not an NBA player or a soccer player.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬Centerback(stephenCurry) ::: Stephen Curry is not a centerback.\n\"\"\""
    ]
  },
  {
    "id": 90,
    "context": [
      "Naive cynicism was proposed by Justin Kruger and a colleague.",
      "Thomas Gilovich is a colleague of Justin Kruger. ",
      "Naive cynicism is a philosophy of mind."
    ],
    "question": "Thomas Gilovich proposed naive cynicism.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nProposedBy(x, y) ::: x was proposed by y.\nColleague(x, y) ::: x is a colleague of y.\nPhilosophy(x) ::: x is a philosophy of mind.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nProposedBy(naiveCynicism, justinKruger) ∧ ProposedBy(naiveCynicism, colleague) ::: Naive cynicism was proposed by Justin Kruger and a colleague.\nColleague(thomasGilovich, justinKruger) ::: Thomas Gilovich is a colleague of Justin Kruger.\nPhilosophy(naiveCynicism) ::: Naive cynicism is a philosophy of mind.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nProposedBy(naiveCynicism, thomasGilovich) ::: Thomas Gilovich proposed naive cynicism.\n\"\"\""
    ]
  },
  {
    "id": 91,
    "context": [
      "Naive cynicism was proposed by Justin Kruger and a colleague.",
      "Thomas Gilovich is a colleague of Justin Kruger. ",
      "Naive cynicism is a philosophy of mind."
    ],
    "question": "Justin Kruger propose a philosophy of mind.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nPropose(x, y) ::: x proposed y.\nColleague(x, y) ::: x is a colleague of y.\nPhilosophy(x) ::: x is a philosophy.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nPropose(justin, naiveCynicism) ∧ Colleague(thomas, justin) ::: Naive cynicism was proposed by Justin Kruger and a colleague.\nColleague(thomas, justin) ::: Thomas Gilovich is a colleague of Justin Kruger.\nPhilosophy(naiveCynicism) ::: Naive cynicism is a philosophy of mind.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n∃x (Propose(justin, x) ∧ Philosophy(x)) ::: Justin Kruger proposed a philosophy of mind.\n\"\"\""
    ]
  },
  {
    "id": 92,
    "context": [
      "Naive cynicism was proposed by Justin Kruger and a colleague.",
      "Thomas Gilovich is a colleague of Justin Kruger. ",
      "Naive cynicism is a philosophy of mind."
    ],
    "question": "Thomas Gilovich worked on philiophies of mind.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nProposedBy(x, y) ::: x was proposed by y.\nColleague(x, y) ::: x is a colleague of y.\nPhilosophyOfMind(x) ::: x is a philosophy of mind.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nProposedBy(naiveCynicism, justinKruger) ∧ ProposedBy(naiveCynicism, colleague) ::: Naive cynicism was proposed by Justin Kruger and a colleague.\nColleague(thomasGilovich, justinKruger) ::: Thomas Gilovich is a colleague of Justin Kruger.\nPhilosophyOfMind(naiveCynicism) ::: Naive cynicism is a philosophy of mind.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n∃x (Colleague(thomasGilovich, x) ∧ PhilosophyOfMind(x)) ::: Thomas Gilovich worked on philosophies of mind.\n\"\"\""
    ]
  },
  {
    "id": 383,
    "context": [
      "",
      "The Turing Award has been awarded to Donald Knuth, Marvin Minsky, Richard Hamming and John McCarthy. ",
      "Donald Knuth made major contributions to the analysis of algorithms.",
      "Marvin Minsky is recognized by his contributions to the field of artificial intelligence.",
      "Richard Hamming did research on numerical methods.",
      "John McCarthy had a central role in creating and shaping the field of artificial inteligence. "
    ],
    "question": "At least two people who have won the Turing Award worked in the field of artificial intelligence.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nTuringAwardWinner(x) ::: x has won the Turing Award.\nContributionToAnalysisOfAlgorithms(x) ::: x made major contributions to the analysis of algorithms.\nContributionToArtificialIntelligence(x) ::: x is recognized by contributions to the field of artificial intelligence.\nResearchOnNumericalMethods(x) ::: x did research on numerical methods.\nCentralRoleInCreatingAI(x) ::: x had a central role in creating and shaping the field of artificial intelligence.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nTuringAwardWinner(donaldKnuth) ∧ TuringAwardWinner(marvinMinsky) ∧ TuringAwardWinner(richardHamming) ∧ TuringAwardWinner(johnMcCarthy) ::: The Turing Award has been awarded to Donald Knuth, Marvin Minsky, Richard Hamming and John McCarthy.\n∀x (TuringAwardWinner(x) → ContributionToAnalysisOfAlgorithms(x)) ::: Donald Knuth made major contributions to the analysis of algorithms.\n∀x (TuringAwardWinner(x) → ContributionToArtificialIntelligence(x)) ::: Marvin Minsky is recognized by his contributions to the field of artificial intelligence.\n∀x (TuringAwardWinner(x) → ResearchOnNumericalMethods(x)) ::: Richard Hamming did research on numerical methods.\n∀x (TuringAwardWinner(x) → CentralRoleInCreatingAI(x)) ::: John McCarthy had a central role in creating and shaping the field of artificial intelligence.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n∃x ∃y (TuringAwardWinner(x) ∧ TuringAwardWinner(y) ∧ ContributionToArtificialIntelligence(x) ∧ ContributionToArtificialIntelligence(y) ∧ x ≠ y) ::: At least two people who have won the Turing Award worked in the field of artificial intelligence.\n\"\"\""
    ]
  },
  {
    "id": 384,
    "context": [
      "",
      "The Turing Award has been awarded to Donald Knuth, Marvin Minsky, Richard Hamming and John McCarthy. ",
      "Donald Knuth made major contributions to the analysis of algorithms.",
      "Marvin Minsky is recognized by his contributions to the field of artificial intelligence.",
      "Richard Hamming did research on numerical methods.",
      "John McCarthy had a central role in creating and shaping the field of artificial inteligence. "
    ],
    "question": "At least two people who worked in the field of artificial intelligence have won the Turing Award.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nAwarded(x, y) ::: x has been awarded the Turing Award.\nContribution(x, y) ::: x made major contributions to y.\nRecognized(x, y) ::: x is recognized by his contributions to y.\nResearch(x, y) ::: x did research on y.\nRole(x, y) ::: x had a central role in y.\nField(x) ::: x is a field.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nAwarded(donaldKnuth, turingAward) ∧ Awarded(marvinMinsky, turingAward) ∧ Awarded(richardHamming, turingAward) ∧ Awarded(johnMcCarthy, turingAward) ::: The Turing Award has been awarded to Donald Knuth, Marvin Minsky, Richard Hamming and John McCarthy.\n∀x (Contribution(donaldKnuth, algorithms)) ::: Donald Knuth made major contributions to the analysis of algorithms.\nRecognized(marvinMinsky, artificialIntelligence) ::: Marvin Minsky is recognized by his contributions to the field of artificial intelligence.\nResearch(richardHamming, numericalMethods) ::: Richard Hamming did research on numerical methods.\nRole(johnMcCarthy, creatingAndShaping(artificialIntelligence)) ::: John McCarthy had a central role in creating and shaping the field of artificial intelligence.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n∃x ∃y (Role(x, creatingAndShaping(artificialIntelligence)) ∧ Role(y, creatingAndShaping(artificialIntelligence)) ∧ Awarded(x, turingAward) ∧ Awarded(y, turingAward) ∧ x ≠ y) ::: At least two people who worked in the field of artificial intelligence have won the Turing Award.\n\"\"\""
    ]
  },
  {
    "id": 385,
    "context": [
      "",
      "The Turing Award has been awarded to Donald Knuth, Marvin Minsky, Richard Hamming and John McCarthy. ",
      "Donald Knuth made major contributions to the analysis of algorithms.",
      "Marvin Minsky is recognized by his contributions to the field of artificial intelligence.",
      "Richard Hamming did research on numerical methods.",
      "John McCarthy had a central role in creating and shaping the field of artificial inteligence. "
    ],
    "question": "Only one people who have won the Turing Award made significant contributions to the analysis of algorithms.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nTuringAwardWinner(x) ::: x has won the Turing Award.\nMadeContributionsToAnalysisOfAlgorithms(x) ::: x made significant contributions to the analysis of algorithms.\nRecognizedForContributionsToAI(x) ::: x is recognized for contributions to the field of artificial intelligence.\nDidResearchOnNumericalMethods(x) ::: x did research on numerical methods.\nCreatedFieldOfAI(x) ::: x had a central role in creating and shaping the field of artificial intelligence.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nTuringAwardWinner(donaldKnuth) ∧ TuringAwardWinner(marvinMinsky) ∧ TuringAwardWinner(richardHamming) ∧ TuringAwardWinner(johnMcCarthy) ::: The Turing Award has been awarded to Donald Knuth, Marvin Minsky, Richard Hamming and John McCarthy.\n∀x (TuringAwardWinner(x) → MadeContributionsToAnalysisOfAlgorithms(x)) ::: Only one people who have won the Turing Award made significant contributions to the analysis of algorithms.\nMadeContributionsToAnalysisOfAlgorithms(donaldKnuth) ::: Donald Knuth made major contributions to the analysis of algorithms.\nRecognizedForContributionsToAI(marvinMinsky) ::: Marvin Minsky is recognized by his contributions to the field of artificial intelligence.\nDidResearchOnNumericalMethods(richardHamming) ::: Richard Hamming did research on numerical methods.\nCreatedFieldOfAI(johnMcCarthy) ::: John McCarthy had a central role in creating and shaping the field of artificial intelligence.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n∀x (TuringAwardWinner(x) → MadeContributionsToAnalysisOfAlgorithms(x)) ∧ ∃x (MadeContributionsToAnalysisOfAlgorithms(x) ∧ ¬(x = donaldKnuth)) ::: Only one people who have won the Turing Award made significant contributions to the analysis of algorithms.\n\"\"\""
    ]
  },
  {
    "id": 386,
    "context": [
      "",
      "The Turing Award has been awarded to Donald Knuth, Marvin Minsky, Richard Hamming and John McCarthy. ",
      "Donald Knuth made major contributions to the analysis of algorithms.",
      "Marvin Minsky is recognized by his contributions to the field of artificial intelligence.",
      "Richard Hamming did research on numerical methods.",
      "John McCarthy had a central role in creating and shaping the field of artificial inteligence. "
    ],
    "question": "No Turing Award winners worked in the field of numerical methods.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nTuringAwardWinner(x) ::: x is a winner of the Turing Award.\nContributionToAnalysisOfAlgorithms(x) ::: x made major contributions to the analysis of algorithms.\nContributionToAI(x) ::: x is recognized by contributions to the field of artificial intelligence.\nResearchOnNumericalMethods(x) ::: x did research on numerical methods.\nCentralRoleInCreatingAI(x) ::: x had a central role in creating and shaping the field of artificial intelligence.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nTuringAwardWinner(donaldKnuth) ∧ TuringAwardWinner(marvinMinsky) ∧ TuringAwardWinner(richardHamming) ∧ TuringAwardWinner(johnMcCarthy) ::: The Turing Award has been awarded to Donald Knuth, Marvin Minsky, Richard Hamming and John McCarthy.\n∀x (TuringAwardWinner(x) → ContributionToAnalysisOfAlgorithms(x)) ::: Donald Knuth made major contributions to the analysis of algorithms.\n∀x (TuringAwardWinner(x) → ContributionToAI(x)) ::: Marvin Minsky is recognized by his contributions to the field of artificial intelligence.\n∀x (TuringAwardWinner(x) → ResearchOnNumericalMethods(x)) ::: Richard Hamming did research on numerical methods.\n∀x (TuringAwardWinner(x) → CentralRoleInCreatingAI(x)) ::: John McCarthy had a central role in creating and shaping the field of artificial intelligence.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬∃x (TuringAwardWinner(x) ∧ ResearchOnNumericalMethods(x)) ::: No Turing Award winners worked in the field of numerical methods.\n\"\"\""
    ]
  },
  {
    "id": 1224,
    "context": [
      "No easy Leetcode problems have an AC rate lower than 20 percent. ",
      "All Leetcode problems recommended to novices are easy.                                                                                                       ",
      "Leetcode problems either have an AC rate lower than 20 percent or are starred by more than 1 thousand users. ",
      "All hard Leetcode problems are starred by more than 1 thousand users. ",
      "No Leetcode problems published after 2022 are starred by more than 1 thousand users. ",
      "2Sum is not recommended to novices and hard. ",
      "4Sum is either starred by more than 1 thousand users and published after 2022, or neither starred by more than 1 thousand users nor published after 2022. "
    ],
    "question": "2Sum is an easy Leetcode problem.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nEasy(x) ::: x is an easy Leetcode problem.\nACRate(x, y) ::: x has an AC rate of y percent.\nRecommended(x) ::: x is recommended to novices.\nLeetcode(x) ::: x is a Leetcode problem.\nStarredBy(x, y) ::: x is starred by y users.\nHard(x) ::: x is a hard Leetcode problem.\nPublishedAfter(x, y) ::: x is published after year y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Easy(x) → ¬ACRate(x, y) < 20) ::: No easy Leetcode problems have an AC rate lower than 20 percent.\n∀x (Leetcode(x) ∧ Recommended(x) → Easy(x)) ::: All Leetcode problems recommended to novices are easy.\n∀x (Leetcode(x) → (ACRate(x, y) < 20 ∨ StarredBy(x, z > 1000))) ::: Leetcode problems either have an AC rate lower than 20 percent or are starred by more than 1 thousand users.\n∀x (Hard(x) → StarredBy(x, z > 1000)) ::: All hard Leetcode problems are starred by more than 1 thousand users.\n∀x (Leetcode(x) ∧ PublishedAfter(x, 2022) → ¬StarredBy(x, z > 1000)) ::: No Leetcode problems published after 2022 are starred by more than 1 thousand users.\n¬(Recommended(2Sum) ∧ Hard(2Sum)) ::: 2Sum is not recommended to novices and hard.\n¬(StarredBy(4Sum, z > 1000) ∧ PublishedAfter(4Sum, 2022)) → (StarredBy(4Sum, z > 1000) ∧ PublishedAfter(4Sum, 2022)) ⊕ ¬(StarredBy(4Sum, z > 1000) ∨ PublishedAfter(4Sum, 2022)) ::: 4Sum is either starred by more than 1 thousand users and published after 2022, or neither starred by more than 1 thousand users nor published after 2022.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nEasy(2Sum) ::: 2Sum is an easy Leetcode problem.\n\"\"\""
    ]
  },
  {
    "id": 1225,
    "context": [
      "No easy Leetcode problems have an AC rate lower than 20 percent. ",
      "All Leetcode problems recommended to novices are easy.                                                                                                       ",
      "Leetcode problems either have an AC rate lower than 20 percent or are starred by more than 1 thousand users. ",
      "All hard Leetcode problems are starred by more than 1 thousand users. ",
      "No Leetcode problems published after 2022 are starred by more than 1 thousand users. ",
      "2Sum is not recommended to novices and hard. ",
      "4Sum is either starred by more than 1 thousand users and published after 2022, or neither starred by more than 1 thousand users nor published after 2022. "
    ],
    "question": "2Sum is not an easy Leetcode problem.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nEasy(x) ::: x is an easy Leetcode problem.\nACRate(x, y) ::: x has an acceptance rate of y percent.\nRecommended(x) ::: x is recommended to novices.\nLeetcode(x) ::: x is a Leetcode problem.\nStarredBy(x, y) ::: x is starred by y users.\nHard(x) ::: x is a hard Leetcode problem.\nPublishedAfter(x, y) ::: x is published after year y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Easy(x) → ¬ACRate(x, y)) ::: No easy Leetcode problems have an AC rate lower than 20 percent.\n∀x (Leetcode(x) ∧ Recommended(x) → Easy(x)) ::: All Leetcode problems recommended to novices are easy.\n∀x (ACRate(x, y) ⊕ StarredBy(x, z)) ::: Leetcode problems either have an AC rate lower than 20 percent or are starred by more than 1 thousand users.\n∀x (Hard(x) → StarredBy(x, z)) ::: All hard Leetcode problems are starred by more than 1 thousand users.\n∀x (Leetcode(x) ∧ PublishedAfter(x, year2022) → ¬StarredBy(x, z)) ::: No Leetcode problems published after 2022 are starred by more than 1 thousand users.\n¬(Recommended(2Sum) ∧ Hard(2Sum)) ::: 2Sum is not recommended to novices and hard.\n(StarredBy(4Sum, z) ∧ PublishedAfter(4Sum, year2022)) ⊕ ¬(StarredBy(4Sum, z) ∨ PublishedAfter(4Sum, year2022)) ::: 4Sum is either starred by more than 1 thousand users and published after 2022, or neither starred by more than 1 thousand users nor published after 2022.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬Easy(2Sum) ::: 2Sum is not an easy Leetcode problem.\n\"\"\""
    ]
  },
  {
    "id": 1226,
    "context": [
      "No easy Leetcode problems have an AC rate lower than 20 percent. ",
      "All Leetcode problems recommended to novices are easy.                                                                                                       ",
      "Leetcode problems either have an AC rate lower than 20 percent or are starred by more than 1 thousand users. ",
      "All hard Leetcode problems are starred by more than 1 thousand users. ",
      "No Leetcode problems published after 2022 are starred by more than 1 thousand users. ",
      "2Sum is not recommended to novices and hard. ",
      "4Sum is either starred by more than 1 thousand users and published after 2022, or neither starred by more than 1 thousand users nor published after 2022. "
    ],
    "question": "4Sum is a Leetcode problem recommended to the novice or is hard.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nEasy(x) ::: x is an easy Leetcode problem.\nACRate(x, y) ::: x has an acceptance rate of y percent.\nRecommended(x, y) ::: x is recommended to y.\nLeetcode(x) ::: x is a Leetcode problem.\nStarredBy(x, y) ::: x is starred by y users.\nThousand(x) ::: x is starred by more than 1 thousand users.\nHard(x) ::: x is a hard Leetcode problem.\nPublishedAfter(x, y) ::: x is published after year y.\nNovice(x) ::: x is a novice.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n¬∃x (Easy(x) ∧ ACRate(x, y) ∧ y < 20) ::: No easy Leetcode problems have an AC rate lower than 20 percent.\n∀x (Leetcode(x) ∧ Recommended(x, novice) → Easy(x)) ::: All Leetcode problems recommended to novices are easy.\n∀x (Leetcode(x) → (ACRate(x, y) < 20 ∨ Thousand(x))) ::: Leetcode problems either have an AC rate lower than 20 percent or are starred by more than 1 thousand users.\n∀x (Hard(x) → Thousand(x)) ::: All hard Leetcode problems are starred by more than 1 thousand users.\n¬∀x (Leetcode(x) ∧ PublishedAfter(x, 2022) → Thousand(x)) ::: No Leetcode problems published after 2022 are starred by more than 1 thousand users.\n¬(Recommended(2Sum, novice) ∧ Hard(2Sum)) ::: 2Sum is not recommended to novices and hard.\n(StarredBy(4Sum, y) ∧ PublishedAfter(4Sum, 2022)) ⊕ ¬(StarredBy(4Sum, y) ∨ PublishedAfter(4Sum, 2022)) ::: 4Sum is either starred by more than 1 thousand users and published after 2022, or neither starred by more than 1 thousand users nor published after 2022.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nRecommended(4Sum, novice) ∨ Hard(4Sum) ::: 4Sum is a Leetcode problem recommended to the novice or is hard.\n\"\"\""
    ]
  },
  {
    "id": 1227,
    "context": [
      "No easy Leetcode problems have an AC rate lower than 20 percent. ",
      "All Leetcode problems recommended to novices are easy.                                                                                                       ",
      "Leetcode problems either have an AC rate lower than 20 percent or are starred by more than 1 thousand users. ",
      "All hard Leetcode problems are starred by more than 1 thousand users. ",
      "No Leetcode problems published after 2022 are starred by more than 1 thousand users. ",
      "2Sum is not recommended to novices and hard. ",
      "4Sum is either starred by more than 1 thousand users and published after 2022, or neither starred by more than 1 thousand users nor published after 2022. "
    ],
    "question": "4Sum is neither a 2Sum Leetcode problem recommended to the novice nor a Leetcode problem that's hard.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nEasy(x) ::: x is an easy Leetcode problem.\nACRate(x, y) ::: x has an AC rate of y percent.\nRecommended(x, y) ::: x is recommended to y.\nStarredBy(x, y) ::: x is starred by y users.\nHard(x) ::: x is a hard Leetcode problem.\nPublishedAfter(x, y) ::: x is published after year y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Easy(x) → ¬ACRate(x, y)) ::: No easy Leetcode problems have an AC rate lower than 20 percent.\n∀x (Recommended(x, novice) → Easy(x)) ::: All Leetcode problems recommended to novices are easy.\n∀x (ACRate(x, y) ∨ StarredBy(x, z)) ::: Leetcode problems either have an AC rate lower than 20 percent or are starred by more than 1 thousand users.\n∀x (Hard(x) → StarredBy(x, z)) ::: All hard Leetcode problems are starred by more than 1 thousand users.\n∀x (PublishedAfter(x, year2022) → ¬StarredBy(x, z)) ::: No Leetcode problems published after 2022 are starred by more than 1 thousand users.\n¬(Recommended(2Sum, novice) ∧ Hard(2Sum)) ::: 2Sum is not recommended to novices and hard.\n(StarredBy(4Sum, z) ∧ PublishedAfter(4Sum, year2022)) ⊕ ¬(StarredBy(4Sum, z) ∨ PublishedAfter(4Sum, year2022)) ::: 4Sum is either starred by more than 1 thousand users and published after 2022, or neither starred by more than 1 thousand users nor published after 2022.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬(Recommended(4Sum, novice) ∧ Hard(4Sum)) ::: 4Sum is neither a 2Sum Leetcode problem recommended to the novice nor a Leetcode problem that's hard.\n\"\"\""
    ]
  },
  {
    "id": 319,
    "context": [
      "Show Your Love is a song recorded by the South Korean boy band BtoB 4u.",
      "The lead single of the extended play Inside is Show Your Love.",
      "Show Your Love contains a hopeful message.",
      "BtoB 4u member Hyunsik wrote Show Your Love.",
      "There is a music video for Show Your Love."
    ],
    "question": "Show your love wasn't written by a member of a boy band.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nRecorded(x, y) ::: x recorded the song y.\nLeadSingle(x, y) ::: x is the lead single of the album y.\nContainsMessage(x, y) ::: x contains the message y.\nWrote(x, y, z) ::: x wrote the song y for the artist z.\nMusicVideo(x) ::: x has a music video.\nMember(x, y) ::: x is a member of the group y.\nBoyBand(x) ::: x is a boy band.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nRecorded(btob4u, showYourLove) ::: Show Your Love is a song recorded by the South Korean boy band BtoB 4u.\nLeadSingle(showYourLove, inside) ::: The lead single of the extended play Inside is Show Your Love.\nContainsMessage(showYourLove, hopeful) ::: Show Your Love contains a hopeful message.\nWrote(hyunsik, showYourLove, btob4u) ::: BtoB 4u member Hyunsik wrote Show Your Love.\nMusicVideo(showYourLove) ::: There is a music video for Show Your Love.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬∃x (Wrote(x, showYourLove, BoyBand)) ::: Show your love wasn't written by a member of a boy band.\n\"\"\""
    ]
  },
  {
    "id": 320,
    "context": [
      "Show Your Love is a song recorded by the South Korean boy band BtoB 4u.",
      "The lead single of the extended play Inside is Show Your Love.",
      "Show Your Love contains a hopeful message.",
      "BtoB 4u member Hyunsik wrote Show Your Love.",
      "There is a music video for Show Your Love."
    ],
    "question": "A lead single of inside contains a a hopeful message.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nRecorded(x, y) ::: x recorded the song y.\nLeadSingle(x, y) ::: x is the lead single of the album y.\nContainsMessage(x) ::: x contains a hopeful message.\nWrote(x, y) ::: x wrote the song y.\nMusicVideo(x) ::: there is a music video for the song x.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nRecorded(btob4u, showYourLove) ::: Show Your Love is a song recorded by the South Korean boy band BtoB 4u.\nLeadSingle(showYourLove, inside) ::: The lead single of the extended play Inside is Show Your Love.\nContainsMessage(showYourLove) ::: Show Your Love contains a hopeful message.\nWrote(hyunsik, showYourLove) ::: BtoB 4u member Hyunsik wrote Show Your Love.\nMusicVideo(showYourLove) ::: There is a music video for Show Your Love.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n∃x (LeadSingle(x, inside) ∧ ContainsMessage(x)) ::: A lead single of inside contains a hopeful message.\n\"\"\""
    ]
  },
  {
    "id": 321,
    "context": [
      "Show Your Love is a song recorded by the South Korean boy band BtoB 4u.",
      "The lead single of the extended play Inside is Show Your Love.",
      "Show Your Love contains a hopeful message.",
      "BtoB 4u member Hyunsik wrote Show Your Love.",
      "There is a music video for Show Your Love."
    ],
    "question": "Hyunsik is Korean.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nSong(x) ::: x is a song.\nRecorded(x, y) ::: x is recorded by y.\nLeadSingle(x, y) ::: x is the lead single of y.\nContains(x, y) ::: x contains a message y.\nWrote(x, y) ::: y wrote x.\nMusicVideo(x) ::: x has a music video.\nKorean(x) ::: x is Korean.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nSong(showYourLove) ∧ Recorded(showYourLove, btob4u) ::: Show Your Love is a song recorded by the South Korean boy band BtoB 4u.\nLeadSingle(showYourLove, inside) ::: The lead single of the extended play Inside is Show Your Love.\nContains(showYourLove, hopefulMessage) ::: Show Your Love contains a hopeful message.\nWrote(showYourLove, hyunsik) ::: BtoB 4u member Hyunsik wrote Show Your Love.\nMusicVideo(showYourLove) ::: There is a music video for Show Your Love.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nKorean(hyunsik) ::: Hyunsik is Korean.\n\"\"\""
    ]
  },
  {
    "id": 739,
    "context": [
      "All tables are round.",
      "Some furniture are tables."
    ],
    "question": "Some furniture are round.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nRound(x) ::: x is round.\nTable(x) ::: x is a table.\nFurniture(x) ::: x is furniture.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Table(x) → Round(x)) ::: All tables are round.\n∃x (Furniture(x) ∧ Table(x)) ::: Some furniture are tables.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n∃x (Furniture(x) ∧ Round(x)) ::: Some furniture are round.\n\"\"\""
    ]
  },
  {
    "id": 716,
    "context": [
      "All juvenile delinquents are maladjusted individuals.",
      "Some juvenile delinquents are products of broken homes."
    ],
    "question": "Some maladjusted individuals are products of broken homes.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nJuvenileDelinquent(x) ::: x is a juvenile delinquent.\nMaladjusted(x) ::: x is a maladjusted individual.\nBrokenHome(x) ::: x is a product of a broken home.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (JuvenileDelinquent(x) → Maladjusted(x)) ::: All juvenile delinquents are maladjusted individuals.\n∃x (JuvenileDelinquent(x) ∧ BrokenHome(x)) ::: Some juvenile delinquents are products of broken homes.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n∃x (Maladjusted(x) ∧ BrokenHome(x)) ::: Some maladjusted individuals are products of broken homes.\n\"\"\""
    ]
  },
  {
    "id": 1089,
    "context": [
      "Either brain reading or brain decoding. ",
      "All brain decoding is extracting information from BOLD signals.",
      "No extracting information from BOLD signals is without statistical pattern analysis. ",
      "Writing a novel is without statistical pattern analysis.",
      "If multivoxel (pattern) analysis is without statistical pattern analysis and a brain reading, then multivoxel (pattern) analysis is without statistical pattern analysis and brain decoding."
    ],
    "question": "Multivoxel (pattern) analysis is a brain decoding.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nBrainReading(x) ::: x is brain reading.\nBrainDecoding(x) ::: x is brain decoding.\nExtractingInformation(x) ::: x is extracting information from BOLD signals.\nStatisticalPatternAnalysis(x) ::: x involves statistical pattern analysis.\nWritingNovel(x) ::: x is writing a novel.\nMultivoxelAnalysis(x) ::: x is multivoxel (pattern) analysis.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nBrainReading(x) ∨ BrainDecoding(x) ::: Either brain reading or brain decoding.\n∀x (BrainDecoding(x) → ExtractingInformation(x)) ::: All brain decoding is extracting information from BOLD signals.\n¬(ExtractingInformation(x) ∧ ¬StatisticalPatternAnalysis(x)) ::: No extracting information from BOLD signals is without statistical pattern analysis.\nWritingNovel(x) → ¬StatisticalPatternAnalysis(x) ::: Writing a novel is without statistical pattern analysis.\n(¬StatisticalPatternAnalysis(multivoxel) ∧ BrainReading(multivoxel)) → (¬StatisticalPatternAnalysis(multivoxel) ∧ BrainDecoding(multivoxel)) ::: If multivoxel (pattern) analysis is without statistical pattern analysis and a brain reading, then multivoxel (pattern) analysis is without statistical pattern analysis and brain decoding.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nBrainDecoding(multivoxel) ::: Multivoxel (pattern) analysis is a brain decoding.\n\"\"\""
    ]
  },
  {
    "id": 1090,
    "context": [
      "Either brain reading or brain decoding. ",
      "All brain decoding is extracting information from BOLD signals.",
      "No extracting information from BOLD signals is without statistical pattern analysis. ",
      "Writing a novel is without statistical pattern analysis.",
      "If multivoxel (pattern) analysis is without statistical pattern analysis and a brain reading, then multivoxel (pattern) analysis is without statistical pattern analysis and brain decoding."
    ],
    "question": "Multivoxel (pattern) analysis is the writing of a novel.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nBrainReading(x) ::: x is brain reading.\nBrainDecoding(x) ::: x is brain decoding.\nExtractingInfo(x) ::: x is extracting information from BOLD signals.\nStatisticalPatternAnalysis(x) ::: x involves statistical pattern analysis.\nWritingNovel(x) ::: x is writing a novel.\nMultivoxelAnalysis(x) ::: x is multivoxel (pattern) analysis.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nBrainReading(x) ∨ BrainDecoding(x) ::: Either brain reading or brain decoding.\n∀x (BrainDecoding(x) → ExtractingInfo(x)) ::: All brain decoding is extracting information from BOLD signals.\n∀x (ExtractingInfo(x) → ¬StatisticalPatternAnalysis(x)) ::: No extracting information from BOLD signals is without statistical pattern analysis.\n¬(WritingNovel(x) → StatisticalPatternAnalysis(x)) ::: Writing a novel is without statistical pattern analysis.\n¬(StatisticalPatternAnalysis(multivoxel) ∧ BrainReading(multivoxel)) → (¬StatisticalPatternAnalysis(multivoxel) ∧ ¬BrainDecoding(multivoxel)) ::: If multivoxel (pattern) analysis is without statistical pattern analysis and a brain reading, then multivoxel (pattern) analysis is without statistical pattern analysis and brain decoding.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nWritingNovel(multivoxel) ::: Multivoxel (pattern) analysis is the writing of a novel.\n\"\"\""
    ]
  },
  {
    "id": 1091,
    "context": [
      "Either brain reading or brain decoding. ",
      "All brain decoding is extracting information from BOLD signals.",
      "No extracting information from BOLD signals is without statistical pattern analysis. ",
      "Writing a novel is without statistical pattern analysis.",
      "If multivoxel (pattern) analysis is without statistical pattern analysis and a brain reading, then multivoxel (pattern) analysis is without statistical pattern analysis and brain decoding."
    ],
    "question": "Multivoxel (pattern) analysis is without statistical pattern analysis and writing a novel.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nBrainReading(x) ::: x is brain reading.\nBrainDecoding(x) ::: x is brain decoding.\nExtractingInformation(x) ::: x is extracting information from BOLD signals.\nStatisticalPatternAnalysis(x) ::: x involves statistical pattern analysis.\nWritingNovel(x) ::: x is writing a novel.\nMultivoxelAnalysis(x) ::: x is multivoxel (pattern) analysis.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nBrainReading(x) ∨ BrainDecoding(x) ::: Either brain reading or brain decoding.\n∀x (BrainDecoding(x) → ExtractingInformation(x)) ::: All brain decoding is extracting information from BOLD signals.\n¬(ExtractingInformation(x) ∧ ¬StatisticalPatternAnalysis(x)) ::: No extracting information from BOLD signals is without statistical pattern analysis.\nWritingNovel(x) → ¬StatisticalPatternAnalysis(x) ::: Writing a novel is without statistical pattern analysis.\n¬(StatisticalPatternAnalysis(multivoxel) ∧ BrainReading(multivoxel)) → (¬StatisticalPatternAnalysis(multivoxel) ∧ BrainDecoding(multivoxel)) ::: If multivoxel (pattern) analysis is without statistical pattern analysis and a brain reading, then multivoxel (pattern) analysis is without statistical pattern analysis and brain decoding.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬(StatisticalPatternAnalysis(multivoxel) ∧ WritingNovel(multivoxel)) ::: Multivoxel (pattern) analysis is without statistical pattern analysis and writing a novel.\n\"\"\""
    ]
  },
  {
    "id": 1092,
    "context": [
      "Either brain reading or brain decoding. ",
      "All brain decoding is extracting information from BOLD signals.",
      "No extracting information from BOLD signals is without statistical pattern analysis. ",
      "Writing a novel is without statistical pattern analysis.",
      "If multivoxel (pattern) analysis is without statistical pattern analysis and a brain reading, then multivoxel (pattern) analysis is without statistical pattern analysis and brain decoding."
    ],
    "question": "Multivoxel (pattern) analysis is without statistical pattern analysis or writing a novel.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nBrainReading(x) ::: x is brain reading.\nBrainDecoding(x) ::: x is brain decoding.\nExtractingInformation(x) ::: x is extracting information from BOLD signals.\nStatisticalPatternAnalysis(x) ::: x involves statistical pattern analysis.\nWritingNovel(x) ::: x is writing a novel.\nMultivoxelAnalysis(x) ::: x is multivoxel (pattern) analysis.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nBrainReading(x) ∨ BrainDecoding(x) ::: Either brain reading or brain decoding.\n∀x (BrainDecoding(x) → ExtractingInformation(x)) ::: All brain decoding is extracting information from BOLD signals.\n¬(ExtractingInformation(x) ∧ ¬StatisticalPatternAnalysis(x)) ::: No extracting information from BOLD signals is without statistical pattern analysis.\nWritingNovel(x) → ¬StatisticalPatternAnalysis(x) ::: Writing a novel is without statistical pattern analysis.\n¬(StatisticalPatternAnalysis(multivoxel) ∧ BrainReading(multivoxel)) → (¬StatisticalPatternAnalysis(multivoxel) ∧ ¬BrainDecoding(multivoxel)) ::: If multivoxel (pattern) analysis is without statistical pattern analysis and a brain reading, then multivoxel (pattern) analysis is without statistical pattern analysis and brain decoding.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬StatisticalPatternAnalysis(multivoxel) ∨ WritingNovel(multivoxel) ::: Multivoxel (pattern) analysis is without statistical pattern analysis or writing a novel.\n\"\"\""
    ]
  },
  {
    "id": 1093,
    "context": [
      "Either brain reading or brain decoding. ",
      "All brain decoding is extracting information from BOLD signals.",
      "No extracting information from BOLD signals is without statistical pattern analysis. ",
      "Writing a novel is without statistical pattern analysis.",
      "If multivoxel (pattern) analysis is without statistical pattern analysis and a brain reading, then multivoxel (pattern) analysis is without statistical pattern analysis and brain decoding."
    ],
    "question": "Multivoxel (pattern) analysis is either without statistical pattern analysis or writing a novel.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nBrainReading(x) ::: x is brain reading.\nBrainDecoding(x) ::: x is brain decoding.\nExtractingInfo(x) ::: x is extracting information from BOLD signals.\nStatisticalPatternAnalysis(x) ::: x involves statistical pattern analysis.\nWritingNovel(x) ::: x is writing a novel.\nMultivoxelAnalysis(x) ::: x is multivoxel (pattern) analysis.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nBrainReading(x) ∨ BrainDecoding(x) ::: Either brain reading or brain decoding.\n∀x (BrainDecoding(x) → ExtractingInfo(x)) ::: All brain decoding is extracting information from BOLD signals.\n∀x (ExtractingInfo(x) → ¬StatisticalPatternAnalysis(x)) ::: No extracting information from BOLD signals is without statistical pattern analysis.\nWritingNovel(x) → ¬StatisticalPatternAnalysis(x) ::: Writing a novel is without statistical pattern analysis.\n¬(StatisticalPatternAnalysis(multivoxel) ∧ BrainReading(multivoxel)) → (¬StatisticalPatternAnalysis(multivoxel) ∧ ¬StatisticalPatternAnalysis(multivoxel)) ::: If multivoxel (pattern) analysis is without statistical pattern analysis and a brain reading, then multivoxel (pattern) analysis is without statistical pattern analysis and brain decoding.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nWritingNovel(multivoxel) ∨ ¬StatisticalPatternAnalysis(multivoxel) ::: Multivoxel (pattern) analysis is either without statistical pattern analysis or writing a novel.\n\"\"\""
    ]
  },
  {
    "id": 1094,
    "context": [
      "Either brain reading or brain decoding. ",
      "All brain decoding is extracting information from BOLD signals.",
      "No extracting information from BOLD signals is without statistical pattern analysis. ",
      "Writing a novel is without statistical pattern analysis.",
      "If multivoxel (pattern) analysis is without statistical pattern analysis and a brain reading, then multivoxel (pattern) analysis is without statistical pattern analysis and brain decoding."
    ],
    "question": "If multivoxel (pattern) analysis is writing a novel, then multivoxel (pattern) analysis is neither without statistical pattern analysis nor writing a novel.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nBrainReading(x) ::: x is brain reading.\nBrainDecoding(x) ::: x is brain decoding.\nExtractingInformation(x) ::: x is extracting information from BOLD signals.\nStatisticalPatternAnalysis(x) ::: x involves statistical pattern analysis.\nWritingNovel(x) ::: x is writing a novel.\nMultivoxelAnalysis(x) ::: x is multivoxel (pattern) analysis.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nBrainReading(x) ∨ BrainDecoding(x) ::: Either brain reading or brain decoding.\n∀x (BrainDecoding(x) → ExtractingInformation(x)) ::: All brain decoding is extracting information from BOLD signals.\n¬(ExtractingInformation(x) ∧ ¬StatisticalPatternAnalysis(x)) ::: No extracting information from BOLD signals is without statistical pattern analysis.\n¬(WritingNovel(x) ∧ ¬StatisticalPatternAnalysis(x)) ::: Writing a novel is without statistical pattern analysis.\n(¬StatisticalPatternAnalysis(multivoxel) ∧ ¬BrainReading(multivoxel)) → (¬StatisticalPatternAnalysis(multivoxel) ∧ BrainDecoding(multivoxel)) ::: If multivoxel (pattern) analysis is without statistical pattern analysis and a brain reading, then multivoxel (pattern) analysis is without statistical pattern analysis and brain decoding.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n(WritingNovel(multivoxel) → ¬(¬StatisticalPatternAnalysis(multivoxel) ∧ WritingNovel(multivoxel))) ::: If multivoxel (pattern) analysis is writing a novel, then multivoxel (pattern) analysis is neither without statistical pattern analysis nor writing a novel.\n\"\"\""
    ]
  },
  {
    "id": 609,
    "context": [
      "If you have room for dessert, you have room for broccoli.",
      "Everyone at Luis's dinner party has room for dessert, including Luis.",
      "Mauricia does not have room for broccoli.",
      "Luis's dinner party is the first ever dinner party that Allison has attended.",
      "Gustave has room for both broccoli and asparagus.",
      "Broccoli and asparagus are both vegetables."
    ],
    "question": "Allison has room for broccoli.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nRoomFor(x) ::: x has room for something.\nBroccoli(x) ::: x has room for broccoli.\nDessert(x) ::: x has room for dessert.\nAtDinnerParty(x, y) ::: x is at y's dinner party.\nAttend(x, y) ::: x attends y.\nVegetable(x) ::: x is a vegetable.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (RoomFor(x) → RoomFor(broccoli)) ::: If you have room for dessert, you have room for broccoli.\n∀x (AtDinnerParty(x, luis) → RoomFor(dessert)) ::: Everyone at Luis's dinner party has room for dessert, including Luis.\n¬RoomFor(broccoli) ::: Mauricia does not have room for broccoli.\nAtDinnerParty(allison, luis) ∧ ¬Attend(allison, dinnerParty) ::: Luis's dinner party is the first ever dinner party that Allison has attended.\nRoomFor(broccoli) ∧ RoomFor(asparagus) ∧ Vegetable(broccoli) ∧ Vegetable(asparagus) ::: Gustave has room for both broccoli and asparagus. Broccoli and asparagus are both vegetables.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nRoomFor(broccoli) ::: Allison has room for broccoli.\n\"\"\""
    ]
  },
  {
    "id": 610,
    "context": [
      "If you have room for dessert, you have room for broccoli.",
      "Everyone at Luis's dinner party has room for dessert, including Luis.",
      "Mauricia does not have room for broccoli.",
      "Luis's dinner party is the first ever dinner party that Allison has attended.",
      "Gustave has room for both broccoli and asparagus.",
      "Broccoli and asparagus are both vegetables."
    ],
    "question": "Mauricia is at Luis's dinner party.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nRoomFor(x) ::: x has room for something.\nBroccoli(x) ::: x has room for broccoli.\nDessert(x) ::: x has room for dessert.\nAttend(x, y) ::: x attends y.\nHas(x, y) ::: x has y.\nVegetable(x) ::: x is a vegetable.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (RoomFor(x) → Broccoli(x)) ::: If you have room for dessert, you have room for broccoli.\n∀x (Attend(x, luis) → RoomFor(x)) ∧ RoomFor(luis) ::: Everyone at Luis's dinner party has room for dessert, including Luis.\n¬Broccoli(mauricia) ::: Mauricia does not have room for broccoli.\nAttend(allison, luis) ∧ ¬∃y (Attend(allison, y)) ::: Luis's dinner party is the first ever dinner party that Allison has attended.\nRoomFor(gustave) ∧ Broccoli(gustave) ∧ Asparagus(gustave) ::: Gustave has room for both broccoli and asparagus.\n∀x (Broccoli(x) ∧ Asparagus(x) → Vegetable(x)) ::: Broccoli and asparagus are both vegetables.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nAttend(mauricia, luis) ::: Mauricia is at Luis's dinner party.\n\"\"\""
    ]
  },
  {
    "id": 611,
    "context": [
      "If you have room for dessert, you have room for broccoli.",
      "Everyone at Luis's dinner party has room for dessert, including Luis.",
      "Mauricia does not have room for broccoli.",
      "Luis's dinner party is the first ever dinner party that Allison has attended.",
      "Gustave has room for both broccoli and asparagus.",
      "Broccoli and asparagus are both vegetables."
    ],
    "question": "Gustav has room for dessert.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nRoomFor(x, y) ::: x has room for y.\nBroccoli(x) ::: x is broccoli.\nAsparagus(x) ::: x is asparagus.\nVegetable(x) ::: x is a vegetable.\nAttend(x, y) ::: x attends y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (RoomFor(x, dessert) → RoomFor(x, broccoli)) ::: If you have room for dessert, you have room for broccoli.\n∀x (Attend(x, luis) → RoomFor(x, dessert)) ::: Everyone at Luis's dinner party has room for dessert, including Luis.\n¬RoomFor(mauricia, broccoli) ::: Mauricia does not have room for broccoli.\nAttend(allison, luis) ∧ ¬∃y (Attend(allison, y)) ::: Luis's dinner party is the first ever dinner party that Allison has attended.\nRoomFor(gustave, broccoli) ∧ RoomFor(gustave, asparagus) ::: Gustave has room for both broccoli and asparagus.\n∀x (Broccoli(x) ∧ Asparagus(x) → Vegetable(x)) ::: Broccoli and asparagus are both vegetables.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nRoomFor(gustave, dessert) ::: Gustav has room for dessert.\n\"\"\""
    ]
  },
  {
    "id": 124,
    "context": [
      "Imagine Dragons is an American pop rock band.",
      "The lead singer of Imagine Dragons is Dan.",
      "Dan is also a songwriter.",
      "All lead singers are singers.",
      "All singers are musicians.",
      "Demons is one of the most popular singles of Imagine Dragons.",
      "Some singles of Imagine Dragons have been on Billboard Hot 100."
    ],
    "question": "Some rock band has a songwriter.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nBand(x) ::: x is a band.\nAmerican(x) ::: x is American.\nPopRock(x) ::: x is a pop rock band.\nLeadSinger(x, y) ::: y is the lead singer of band x.\nPerson(x) ::: x is a person.\nSongwriter(x) ::: x is a songwriter.\nSinger(x) ::: x is a singer.\nMusician(x) ::: x is a musician.\nSingle(x) ::: x is a single.\nPopular(x) ::: x is popular.\nOnBillboard(x) ::: x has been on Billboard Hot 100.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nBand(imagineDragons) ∧ American(imagineDragons) ∧ PopRock(imagineDragons) ::: Imagine Dragons is an American pop rock band.\nLeadSinger(imagineDragons, dan) ::: The lead singer of Imagine Dragons is Dan.\nSongwriter(dan) ::: Dan is also a songwriter.\n∀x (LeadSinger(x, y) → Singer(y)) ::: All lead singers are singers.\n∀x (Singer(x) → Musician(x)) ::: All singers are musicians.\nSingle(demons) ∧ Popular(demons) ::: Demons is one of the most popular singles of Imagine Dragons.\n∃x (Single(x) ∧ OnBillboard(x)) ::: Some singles of Imagine Dragons have been on Billboard Hot 100.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n∃x (Band(x) ∧ ∃y (Songwriter(y))) ::: Some rock band has a songwriter.\n\"\"\""
    ]
  },
  {
    "id": 125,
    "context": [
      "Imagine Dragons is an American pop rock band.",
      "The lead singer of Imagine Dragons is Dan.",
      "Dan is also a songwriter.",
      "All lead singers are singers.",
      "All singers are musicians.",
      "Demons is one of the most popular singles of Imagine Dragons.",
      "Some singles of Imagine Dragons have been on Billboard Hot 100."
    ],
    "question": "Dan is not a musician.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nBand(x) ::: x is a band.\nAmerican(x) ::: x is American.\nPopRock(x) ::: x is a pop rock band.\nLeadSinger(x, y) ::: y is the lead singer of x.\nSongwriter(x) ::: x is a songwriter.\nSinger(x) ::: x is a singer.\nMusician(x) ::: x is a musician.\nPopular(x) ::: x is popular.\nSingle(x) ::: x is a single.\nOnBillboard(x) ::: x has been on Billboard Hot 100.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nBand(imagineDragons) ∧ American(imagineDragons) ∧ PopRock(imagineDragons) ::: Imagine Dragons is an American pop rock band.\nLeadSinger(imagineDragons, dan) ::: The lead singer of Imagine Dragons is Dan.\nSongwriter(dan) ::: Dan is also a songwriter.\n∀x (LeadSinger(x, y) → Singer(y)) ::: All lead singers are singers.\n∀x (Singer(x) → Musician(x)) ::: All singers are musicians.\nPopular(demons) ∧ Single(demons) ∧ OnBillboard(demons) ::: Demons is one of the most popular singles of Imagine Dragons.\n∃x (Single(x) ∧ OnBillboard(x)) ::: Some singles of Imagine Dragons have been on Billboard Hot 100.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬Musician(dan) ::: Dan is not a musician.\n\"\"\""
    ]
  },
  {
    "id": 126,
    "context": [
      "Imagine Dragons is an American pop rock band.",
      "The lead singer of Imagine Dragons is Dan.",
      "Dan is also a songwriter.",
      "All lead singers are singers.",
      "All singers are musicians.",
      "Demons is one of the most popular singles of Imagine Dragons.",
      "Some singles of Imagine Dragons have been on Billboard Hot 100."
    ],
    "question": "Demons has been on Billboard Hot 100.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nBand(x) ::: x is a band.\nAmerican(x) ::: x is American.\nPopRock(x) ::: x is a pop rock band.\nLeadSinger(x, y) ::: y is the lead singer of band x.\nSongwriter(x) ::: x is a songwriter.\nSinger(x) ::: x is a singer.\nMusician(x) ::: x is a musician.\nPopular(x) ::: x is popular.\nSingle(x) ::: x is a single.\nOnBillboardHot100(x) ::: x has been on Billboard Hot 100.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nBand(imagineDragons) ∧ American(imagineDragons) ∧ PopRock(imagineDragons) ::: Imagine Dragons is an American pop rock band.\nLeadSinger(imagineDragons, dan) ::: The lead singer of Imagine Dragons is Dan.\nSongwriter(dan) ::: Dan is also a songwriter.\n∀x (LeadSinger(y, x) → Singer(x)) ::: All lead singers are singers.\n∀x (Singer(x) → Musician(x)) ::: All singers are musicians.\nPopular(demons) ∧ Single(demons) ∧ OnBillboardHot100(demons) ::: Demons is one of the most popular singles of Imagine Dragons.\n∃x (Single(x) ∧ OnBillboardHot100(x)) ::: Some singles of Imagine Dragons have been on Billboard Hot 100.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nOnBillboardHot100(demons) ::: Demons has been on Billboard Hot 100.\n\"\"\""
    ]
  },
  {
    "id": 1315,
    "context": [
      "All bread is food.",
      "Some sandwiches are bread.",
      "All food is edible. ",
      "No edible things are poisonous.",
      "Deodorant is poisonous."
    ],
    "question": "Deodorant is a sandwich.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nBread(x) ::: x is bread.\nFood(x) ::: x is food.\nSandwich(x) ::: x is a sandwich.\nEdible(x) ::: x is edible.\nPoisonous(x) ::: x is poisonous.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Bread(x) → Food(x)) ::: All bread is food.\n∃x (Sandwich(x) ∧ Bread(x)) ::: Some sandwiches are bread.\n∀x (Food(x) → Edible(x)) ::: All food is edible.\n∀x (Edible(x) → ¬Poisonous(x)) ::: No edible things are poisonous.\nPoisonous(deodorant) ::: Deodorant is poisonous.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬(Deodorant is a sandwich) ::: Deodorant is not a sandwich.\n\"\"\""
    ]
  },
  {
    "id": 1316,
    "context": [
      "All bread is food.",
      "Some sandwiches are bread.",
      "All food is edible. ",
      "No edible things are poisonous.",
      "Deodorant is poisonous."
    ],
    "question": "Deodorant is a sandwich and bread.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nBread(x) ::: x is bread.\nFood(x) ::: x is food.\nSandwich(x) ::: x is a sandwich.\nEdible(x) ::: x is edible.\nPoisonous(x) ::: x is poisonous.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Bread(x) → Food(x)) ::: All bread is food.\n∃x (Sandwich(x) ∧ Bread(x)) ::: Some sandwiches are bread.\n∀x (Food(x) → Edible(x)) ::: All food is edible.\n∀x (Edible(x) → ¬Poisonous(x)) ::: No edible things are poisonous.\nPoisonous(deodorant) ::: Deodorant is poisonous.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nSandwich(deodorant) ∧ Bread(deodorant) ::: Deodorant is a sandwich and bread.\n\"\"\""
    ]
  },
  {
    "id": 1317,
    "context": [
      "All bread is food.",
      "Some sandwiches are bread.",
      "All food is edible. ",
      "No edible things are poisonous.",
      "Deodorant is poisonous."
    ],
    "question": "If deodorant is a loaf of bread, then deodorant is not a sandwich.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nBread(x) ::: x is bread.\nFood(x) ::: x is food.\nSandwich(x) ::: x is a sandwich.\nEdible(x) ::: x is edible.\nPoisonous(x) ::: x is poisonous.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Bread(x) → Food(x)) ::: All bread is food.\n∃x (Sandwich(x) ∧ Bread(x)) ::: Some sandwiches are bread.\n∀x (Food(x) → Edible(x)) ::: All food is edible.\n∀x (Edible(x) → ¬Poisonous(x)) ::: No edible things are poisonous.\nPoisonous(deodorant) ::: Deodorant is poisonous.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n(Bread(deodorant) → ¬Sandwich(deodorant)) ::: If deodorant is a loaf of bread, then deodorant is not a sandwich.\n\"\"\""
    ]
  },
  {
    "id": 461,
    "context": [
      "Common utilities include water, electricity, gas, heating, sewer, trash, and recycling.",
      "Many apartment rents cover the cost of water and electricity.",
      "Susan lives in an apartment where the rent covers all utilities.",
      "The rent of the apartment where Ava lives does not cover any utility expenses.",
      "Noah lives in an apartment where the rent does not cover heating."
    ],
    "question": "Noah needs to pay the water bill.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nUtility(x) ::: x is a common utility.\nWater(x) ::: x is water utility.\nElectricity(x) ::: x is electricity utility.\nGas(x) ::: x is gas utility.\nHeating(x) ::: x is heating utility.\nSewer(x) ::: x is sewer utility.\nTrash(x) ::: x is trash utility.\nRecycling(x) ::: x is recycling utility.\nRentCover(x, y) ::: Rent of apartment x covers utility y.\nLivesIn(x, y) ::: x lives in apartment y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Utility(x) ↔ (Water(x) ∨ Electricity(x) ∨ Gas(x) ∨ Heating(x) ∨ Sewer(x) ∨ Trash(x) ∨ Recycling(x))) ::: Common utilities include water, electricity, gas, heating, sewer, trash, and recycling.\n∃x (Apartment(x) ∧ RentCover(x, Water) ∧ RentCover(x, Electricity)) ::: Many apartment rents cover the cost of water and electricity.\nLivesIn(susan, apartment) ∧ ∀y (Utility(y) → RentCover(apartment, y)) ::: Susan lives in an apartment where the rent covers all utilities.\nLivesIn(ava, apartment) ∧ ¬∃y (Utility(y) ∧ RentCover(apartment, y)) ::: The rent of the apartment where Ava lives does not cover any utility expenses.\nLivesIn(noah, apartment) ∧ ¬RentCover(apartment, Heating) ::: Noah lives in an apartment where the rent does not cover heating.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬RentCover(noah, Water) ::: Noah needs to pay the water bill.\n\"\"\""
    ]
  },
  {
    "id": 462,
    "context": [
      "Common utilities include water, electricity, gas, heating, sewer, trash, and recycling.",
      "Many apartment rents cover the cost of water and electricity.",
      "Susan lives in an apartment where the rent covers all utilities.",
      "The rent of the apartment where Ava lives does not cover any utility expenses.",
      "Noah lives in an apartment where the rent does not cover heating."
    ],
    "question": "Noah and Ava both need to pay the heating bill.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nUtility(x) ::: x is a common utility (water, electricity, gas, heating, sewer, trash, recycling).\nCoversRent(x, y) ::: x covers the rent of y.\nLivesIn(x, y) ::: x lives in apartment y.\nNeedToPay(x, y) ::: x needs to pay the bill for utility y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x Utility(x) ::: Common utilities include water, electricity, gas, heating, sewer, trash, and recycling.\n∃x (ApartmentRent(x) ∧ CoversRent(x, water) ∧ CoversRent(x, electricity)) ::: Many apartment rents cover the cost of water and electricity.\nLivesIn(susan, apartment) ∧ CoversRent(apartment, water) ∧ CoversRent(apartment, electricity) ∧ CoversRent(apartment, gas) ∧ CoversRent(apartment, heating) ∧ CoversRent(apartment, sewer) ∧ CoversRent(apartment, trash) ∧ CoversRent(apartment, recycling) ::: Susan lives in an apartment where the rent covers all utilities.\nLivesIn(ava, apartment) ∧ ¬CoversRent(apartment, water) ∧ ¬CoversRent(apartment, electricity) ∧ ¬CoversRent(apartment, gas) ∧ ¬CoversRent(apartment, heating) ∧ ¬CoversRent(apartment, sewer) ∧ ¬CoversRent(apartment, trash) ∧ ¬CoversRent(apartment, recycling) ::: The rent of the apartment where Ava lives does not cover any utility expenses.\nLivesIn(noah, apartment) ∧ ¬CoversRent(apartment, heating) ::: Noah lives in an apartment where the rent does not cover heating.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nNeedToPay(noah, heating) ∧ NeedToPay(ava, heating) ::: Noah and Ava both need to pay the heating bill.\n\"\"\""
    ]
  },
  {
    "id": 463,
    "context": [
      "Common utilities include water, electricity, gas, heating, sewer, trash, and recycling.",
      "Many apartment rents cover the cost of water and electricity.",
      "Susan lives in an apartment where the rent covers all utilities.",
      "The rent of the apartment where Ava lives does not cover any utility expenses.",
      "Noah lives in an apartment where the rent does not cover heating."
    ],
    "question": "Susan does not need to pay the water bill.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nUtility(x) ::: x is a common utility.\nWater(x) ::: x is water utility.\nElectricity(x) ::: x is electricity utility.\nGas(x) ::: x is gas utility.\nHeating(x) ::: x is heating utility.\nSewer(x) ::: x is sewer utility.\nTrash(x) ::: x is trash utility.\nRecycling(x) ::: x is recycling utility.\nApartment(x) ::: x is an apartment.\nRentCover(x, y) ::: Rent of apartment x covers utility y.\nLivesIn(x, y) ::: Person x lives in apartment y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Utility(x) ↔ (Water(x) ∨ Electricity(x) ∨ Gas(x) ∨ Heating(x) ∨ Sewer(x) ∨ Trash(x) ∨ Recycling(x))) ::: Common utilities include water, electricity, gas, heating, sewer, trash, and recycling.\n∃x (Apartment(x) ∧ RentCover(x, Water) ∧ RentCover(x, Electricity)) ::: Many apartment rents cover the cost of water and electricity.\nLivesIn(susan, apartment) ∧ RentCover(apartment, Utility) ∧ ∀x (Utility(x) → RentCover(apartment, x)) ::: Susan lives in an apartment where the rent covers all utilities.\nLivesIn(ava, apartment) ∧ ¬∃x (Utility(x) ∧ RentCover(apartment, x)) ::: The rent of the apartment where Ava lives does not cover any utility expenses.\nLivesIn(noah, apartment) ∧ ¬RentCover(apartment, Heating) ::: Noah lives in an apartment where the rent does not cover heating.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬RentCover(apartmentSusanLivesIn, Water) ::: Susan does not need to pay the water bill.\n\"\"\""
    ]
  },
  {
    "id": 804,
    "context": [
      "All clothes are products. ",
      "No products are perfect. ",
      "All dresses are clothes.",
      "All skirts are dresses. ",
      "If Nike is clothes, then Nike is perfect and a dress."
    ],
    "question": "Nike is perfect.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nClothes(x) ::: x is clothes.\nProducts(x) ::: x is products.\nPerfect(x) ::: x is perfect.\nDresses(x) ::: x is dresses.\nSkirts(x) ::: x is skirts.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Clothes(x) → Products(x)) ::: All clothes are products.\n∀x (Products(x) → ¬Perfect(x)) ::: No products are perfect.\n∀x (Dresses(x) → Clothes(x)) ::: All dresses are clothes.\n∀x (Skirts(x) → Dresses(x)) ::: All skirts are dresses.\nClothes(nike) → (Perfect(nike) ∧ Dresses(nike)) ::: If Nike is clothes, then Nike is perfect and a dress.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nPerfect(nike) ::: Nike is perfect.\n\"\"\""
    ]
  },
  {
    "id": 805,
    "context": [
      "All clothes are products. ",
      "No products are perfect. ",
      "All dresses are clothes.",
      "All skirts are dresses. ",
      "If Nike is clothes, then Nike is perfect and a dress."
    ],
    "question": "Nike is a skirt.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nClothes(x) ::: x is clothes.\nProducts(x) ::: x is products.\nPerfect(x) ::: x is perfect.\nDresses(x) ::: x is dresses.\nSkirts(x) ::: x is skirts.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Clothes(x) → Products(x)) ::: All clothes are products.\n∀x (Products(x) → ¬Perfect(x)) ::: No products are perfect.\n∀x (Dresses(x) → Clothes(x)) ::: All dresses are clothes.\n∀x (Skirts(x) → Dresses(x)) ::: All skirts are dresses.\nClothes(nike) → (Perfect(nike) ∧ Dresses(nike)) ::: If Nike is clothes, then Nike is perfect and a dress.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nSkirts(nike) ::: Nike is a skirt.\n\"\"\""
    ]
  },
  {
    "id": 806,
    "context": [
      "All clothes are products. ",
      "No products are perfect. ",
      "All dresses are clothes.",
      "All skirts are dresses. ",
      "If Nike is clothes, then Nike is perfect and a dress."
    ],
    "question": "Nike is not a skirt.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nClothes(x) ::: x is clothes.\nProducts(x) ::: x is a product.\nPerfect(x) ::: x is perfect.\nDresses(x) ::: x is a dress.\nSkirts(x) ::: x is a skirt.\nNike(x) ::: x is Nike.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Clothes(x) → Products(x)) ::: All clothes are products.\n∀x (Products(x) → ¬Perfect(x)) ::: No products are perfect.\n∀x (Dresses(x) → Clothes(x)) ::: All dresses are clothes.\n∀x (Skirts(x) → Dresses(x)) ::: All skirts are dresses.\nClothes(nike) → (Perfect(nike) ∧ Dresses(nike)) ::: If Nike is clothes, then Nike is perfect and a dress.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬Skirts(nike) ::: Nike is not a skirt.\n\"\"\""
    ]
  },
  {
    "id": 169,
    "context": [
      "All pets are animals.",
      "Pets can be either a dog or a cat.",
      "If a person has a pet, they care for that pet. ",
      "Dogs and Cats can be naughty. ",
      "Pets who are naughty are not liked as much. ",
      "Charlie has a naughty pet dog named Leo. "
    ],
    "question": "Leo is an animal.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nPet(x) ::: x is a pet.\nAnimal(x) ::: x is an animal.\nDog(x) ::: x is a dog.\nCat(x) ::: x is a cat.\nPerson(x) ::: x is a person.\nHasPet(x, y) ::: x has a pet y.\nCareFor(x, y) ::: x cares for pet y.\nNaughty(x) ::: x is naughty.\nLiked(x) ::: x is liked.\nNamed(x, y) ::: x is named y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Pet(x) → Animal(x)) ::: All pets are animals.\n∀x (Pet(x) → (Dog(x) ∨ Cat(x))) ::: Pets can be either a dog or a cat.\n∀x (Person(x) ∧ HasPet(x, y) → CareFor(x, y)) ::: If a person has a pet, they care for that pet.\n∀x (Dog(x) ∨ Cat(x) → Naughty(x)) ::: Dogs and Cats can be naughty.\n∀x (Pet(x) ∧ Naughty(x) → ¬Liked(x)) ::: Pets who are naughty are not liked as much.\nNaughty(leo) ∧ Dog(leo) ∧ Named(leo, charlie) ::: Charlie has a naughty pet dog named Leo.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nAnimal(leo) ::: Leo is an animal.\n\"\"\""
    ]
  },
  {
    "id": 170,
    "context": [
      "All pets are animals.",
      "Pets can be either a dog or a cat.",
      "If a person has a pet, they care for that pet. ",
      "Dogs and Cats can be naughty. ",
      "Pets who are naughty are not liked as much. ",
      "Charlie has a naughty pet dog named Leo. "
    ],
    "question": "Charlie does not like Leo and does not care for Leo.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nPet(x) ::: x is a pet.\nAnimal(x) ::: x is an animal.\nDog(x) ::: x is a dog.\nCat(x) ::: x is a cat.\nPerson(x) ::: x is a person.\nHasPet(x, y) ::: x has a pet y.\nCaresFor(x, y) ::: x cares for pet y.\nNaughty(x) ::: x is naughty.\nLiked(x) ::: x is liked.\nName(x, y) ::: x is named y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Pet(x) → Animal(x)) ::: All pets are animals.\n∀x (Pet(x) ↔ (Dog(x) ∨ Cat(x))) ::: Pets can be either a dog or a cat.\n∀x ∀y ((Person(x) ∧ HasPet(x, y)) → CaresFor(x, y)) ::: If a person has a pet, they care for that pet.\n∀x ((Dog(x) ∨ Cat(x)) → Naughty(x)) ::: Dogs and Cats can be naughty.\n∀x ((Pet(x) ∧ Naughty(x)) → ¬Liked(x)) ::: Pets who are naughty are not liked as much.\nNaughty(Leo) ∧ Pet(Leo) ∧ Dog(Leo) ∧ Name(Leo, leo) ∧ HasPet(charlie, leo) ::: Charlie has a naughty pet dog named Leo.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬Liked(leo) ∧ ¬CaresFor(charlie, leo) ::: Charlie does not like Leo and does not care for Leo.\n\"\"\""
    ]
  },
  {
    "id": 171,
    "context": [
      "All pets are animals.",
      "Pets can be either a dog or a cat.",
      "If a person has a pet, they care for that pet. ",
      "Dogs and Cats can be naughty. ",
      "Pets who are naughty are not liked as much. ",
      "Charlie has a naughty pet dog named Leo. "
    ],
    "question": "Dogs are always not naughty.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nPet(x) ::: x is a pet.\nAnimal(x) ::: x is an animal.\nDog(x) ::: x is a dog.\nCat(x) ::: x is a cat.\nPerson(x) ::: x is a person.\nHasPet(x, y) ::: x has a pet y.\nCareFor(x, y) ::: x cares for pet y.\nNaughty(x) ::: x is naughty.\nLiked(x) ::: x is liked.\nNamed(x, y) ::: x is named y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Pet(x) → Animal(x)) ::: All pets are animals.\n∀x (Pet(x) → (Dog(x) ∨ Cat(x))) ::: Pets can be either a dog or a cat.\n∀x (Person(x) ∧ HasPet(x, y) → CareFor(x, y)) ::: If a person has a pet, they care for that pet.\n∀x (Dog(x) ∨ Cat(x) → Naughty(x)) ::: Dogs and Cats can be naughty.\n∀x (Pet(x) ∧ Naughty(x) → ¬Liked(x)) ::: Pets who are naughty are not liked as much.\nNaughty(leo) ∧ Dog(leo) ∧ Named(leo, charlie) ::: Charlie has a naughty pet dog named Leo.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬∃x (Dog(x) ∧ Naughty(x)) ::: Dogs are always not naughty.\n\"\"\""
    ]
  },
  {
    "id": 728,
    "context": [
      "Surprises are either fun or dreadful.",
      "All scares are surprises."
    ],
    "question": "All scares are fun.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nSurprise(x) ::: x is a surprise.\nFun(x) ::: x is fun.\nDreadful(x) ::: x is dreadful.\nScare(x) ::: x is a scare.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Surprise(x) → (Fun(x) ∨ Dreadful(x))) ::: Surprises are either fun or dreadful.\n∀x (Scare(x) → Surprise(x)) ::: All scares are surprises.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n∀x (Scare(x) → Fun(x)) ::: All scares are fun.\n\"\"\""
    ]
  },
  {
    "id": 66,
    "context": [
      "All books written by Cixin Liu have sold more than 1 million copies. ",
      "Some books that have won the Hugo Award were written by Cixin Liu.",
      "All books about the future are influenced by Isaac Asimov.",
      "The book the Three Body Problem has sold more than 1 million copies.",
      "The Three Body Problem is about the future."
    ],
    "question": "The Three Body Problem won the Hugo Award.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nWrittenBy(x, y) ::: x is written by y.\nSoldMoreThan1M(x) ::: x has sold more than 1 million copies.\nWonHugoAward(x) ::: x has won the Hugo Award.\nAboutFuture(x) ::: x is about the future.\nInfluencedBy(x, y) ::: x is influenced by y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (WrittenBy(x, cixinLiu) → SoldMoreThan1M(x)) ::: All books written by Cixin Liu have sold more than 1 million copies.\n∃x (WonHugoAward(x) ∧ WrittenBy(x, cixinLiu)) ::: Some books that have won the Hugo Award were written by Cixin Liu.\n∀x (AboutFuture(x) → InfluencedBy(x, isaacAsimov)) ::: All books about the future are influenced by Isaac Asimov.\nSoldMoreThan1M(threeBodyProblem) ∧ AboutFuture(threeBodyProblem) ::: The book the Three Body Problem has sold more than 1 million copies and is about the future.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nWonHugoAward(threeBodyProblem) ::: The Three Body Problem won the Hugo Award.\n\"\"\""
    ]
  },
  {
    "id": 67,
    "context": [
      "All books written by Cixin Liu have sold more than 1 million copies. ",
      "Some books that have won the Hugo Award were written by Cixin Liu.",
      "All books about the future are influenced by Isaac Asimov.",
      "The book the Three Body Problem has sold more than 1 million copies.",
      "The Three Body Problem is about the future."
    ],
    "question": "The Three Body Problem was influenced by Isaac Asimov.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nWrittenBy(x, y) ::: x is written by y.\nSoldMoreThan1Million(x) ::: x has sold more than 1 million copies.\nWonHugoAward(x) ::: x has won the Hugo Award.\nAboutFuture(x) ::: x is about the future.\nInfluencedBy(x, y) ::: x is influenced by y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (WrittenBy(x, cixinLiu) → SoldMoreThan1Million(x)) ::: All books written by Cixin Liu have sold more than 1 million copies.\n∃x (WonHugoAward(x) ∧ WrittenBy(x, cixinLiu)) ::: Some books that have won the Hugo Award were written by Cixin Liu.\n∀x (AboutFuture(x) → InfluencedBy(x, isaacAsimov)) ::: All books about the future are influenced by Isaac Asimov.\nSoldMoreThan1Million(threeBodyProblem) ∧ AboutFuture(threeBodyProblem) ::: The book the Three Body Problem has sold more than 1 million copies and is about the future.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nInfluencedBy(threeBodyProblem, isaacAsimov) ::: The Three Body Problem was influenced by Isaac Asimov.\n\"\"\""
    ]
  },
  {
    "id": 68,
    "context": [
      "All books written by Cixin Liu have sold more than 1 million copies. ",
      "Some books that have won the Hugo Award were written by Cixin Liu.",
      "All books about the future are influenced by Isaac Asimov.",
      "The book the Three Body Problem has sold more than 1 million copies.",
      "The Three Body Problem is about the future."
    ],
    "question": "The Three Body Problem was written by Cixin Liu.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nWrittenBy(x, y) ::: x is written by y.\nSoldMoreThan1Million(x) ::: x has sold more than 1 million copies.\nWonHugoAward(x) ::: x has won the Hugo Award.\nAboutFuture(x) ::: x is about the future.\nInfluencedBy(x, y) ::: x is influenced by y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (WrittenBy(x, cixinLiu) → SoldMoreThan1Million(x)) ::: All books written by Cixin Liu have sold more than 1 million copies.\n∃x (WonHugoAward(x) ∧ WrittenBy(x, cixinLiu)) ::: Some books that have won the Hugo Award were written by Cixin Liu.\n∀x (AboutFuture(x) → InfluencedBy(x, isaacAsimov)) ::: All books about the future are influenced by Isaac Asimov.\nWrittenBy(threeBodyProblem, cixinLiu) ∧ SoldMoreThan1Million(threeBodyProblem) ∧ AboutFuture(threeBodyProblem) ::: The book the Three Body Problem has sold more than 1 million copies and is about the future.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nWrittenBy(threeBodyProblem, cixinLiu) ::: The Three Body Problem was written by Cixin Liu.\n\"\"\""
    ]
  },
  {
    "id": 1189,
    "context": [
      "Some students who major in computer science get up early. ",
      "If a student gets up early, then he/she will study in the morning. ",
      "All students studying in the morning are good at time management. ",
      "All students good at time management are popular among students. ",
      "James is not popular among students. "
    ],
    "question": "James majors in computer science.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nMajor(x, y) ::: x majors in y.\nGetUpEarly(x) ::: x gets up early.\nStudy(x, y) ::: x studies in y.\nGoodAtTimeManagement(x) ::: x is good at time management.\nPopularAmongStudents(x) ::: x is popular among students.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∃x (Major(x, computerScience) ∧ GetUpEarly(x)) ::: Some students who major in computer science get up early.\n∀x (GetUpEarly(x) → Study(x, morning)) ::: If a student gets up early, then he/she will study in the morning.\n∀x (Study(x, morning) → GoodAtTimeManagement(x)) ::: All students studying in the morning are good at time management.\n∀x (GoodAtTimeManagement(x) → PopularAmongStudents(x)) ::: All students good at time management are popular among students.\n¬PopularAmongStudents(james) ::: James is not popular among students.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nMajor(james, computerScience) ::: James majors in computer science.\n\"\"\""
    ]
  },
  {
    "id": 1190,
    "context": [
      "Some students who major in computer science get up early. ",
      "If a student gets up early, then he/she will study in the morning. ",
      "All students studying in the morning are good at time management. ",
      "All students good at time management are popular among students. ",
      "James is not popular among students. "
    ],
    "question": "James majors in computer science and gets up early.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nMajorCS(x) ::: x majors in computer science.\nGetUpEarly(x) ::: x gets up early.\nStudyMorning(x) ::: x studies in the morning.\nGoodTimeManagement(x) ::: x is good at time management.\nPopular(x) ::: x is popular among students.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∃x (MajorCS(x) ∧ GetUpEarly(x)) ::: Some students who major in computer science get up early.\n∀x (GetUpEarly(x) → StudyMorning(x)) ::: If a student gets up early, then he/she will study in the morning.\n∀x (StudyMorning(x) → GoodTimeManagement(x)) ::: All students studying in the morning are good at time management.\n∀x (GoodTimeManagement(x) → Popular(x)) ::: All students good at time management are popular among students.\n¬Popular(james) ::: James is not popular among students.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nMajorCS(james) ∧ GetUpEarly(james) ::: James majors in computer science and gets up early.\n\"\"\""
    ]
  },
  {
    "id": 1191,
    "context": [
      "Some students who major in computer science get up early. ",
      "If a student gets up early, then he/she will study in the morning. ",
      "All students studying in the morning are good at time management. ",
      "All students good at time management are popular among students. ",
      "James is not popular among students. "
    ],
    "question": "If James gets up early, then he majors in computer science.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nMajorCS(x) ::: x majors in computer science.\nGetUpEarly(x) ::: x gets up early.\nStudyMorning(x) ::: x studies in the morning.\nGoodTimeManagement(x) ::: x is good at time management.\nPopular(x) ::: x is popular among students.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∃x (MajorCS(x) ∧ GetUpEarly(x)) ::: Some students who major in computer science get up early.\n∀x (GetUpEarly(x) → StudyMorning(x)) ::: If a student gets up early, then he/she will study in the morning.\n∀x (StudyMorning(x) → GoodTimeManagement(x)) ::: All students studying in the morning are good at time management.\n∀x (GoodTimeManagement(x) → Popular(x)) ::: All students good at time management are popular among students.\n¬Popular(james) ::: James is not popular among students.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nGetUpEarly(james) → MajorCS(james) ::: If James gets up early, then he majors in computer science.\n\"\"\""
    ]
  },
  {
    "id": 721,
    "context": [
      "There is no dog on the roof.",
      "If there is a dog on the roof something went wrong."
    ],
    "question": "Something went wrong.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nOnRoof(x) ::: x is on the roof.\nDog(x) ::: x is a dog.\nWentWrong(x) ::: x went wrong.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n¬∃x Dog(x) ∧ OnRoof(x) ::: There is no dog on the roof.\n(∃x Dog(x) ∧ OnRoof(x)) → WentWrong(y) ::: If there is a dog on the roof something went wrong.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nWentWrong(something) ::: Something went wrong.\n\"\"\""
    ]
  },
  {
    "id": 41,
    "context": [
      "Elephantopus is a genus of perennial plants in the daisy family.",
      "Elephantopus is widespread over much of Africa, southern Asia, Australia, and the Americas.",
      "Several species of Elephantopus are native to the southeastern United States.",
      "Elephantopus scaber is a traditional medicine."
    ],
    "question": "Elephantopus is widespread over much of Australia and Southern Asia.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nGenus(x) ::: x is a genus of plants.\nPlant(x) ::: x is a plant.\nPerennial(x) ::: x is a perennial plant.\nFamily(x) ::: x is in the daisy family.\nWidespread(x, y) ::: x is widespread over y.\nNativeTo(x, y) ::: x is native to y.\nTraditionalMedicine(x) ::: x is a traditional medicine.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nGenus(elephantopus) ∧ Plant(elephantopus) ∧ Perennial(elephantopus) ∧ Family(elephantopus, daisy) ::: Elephantopus is a genus of perennial plants in the daisy family.\nWidespread(elephantopus, africa) ∧ Widespread(elephantopus, southernAsia) ∧ Widespread(elephantopus, australia) ∧ Widespread(elephantopus, americas) ::: Elephantopus is widespread over much of Africa, southern Asia, Australia, and the Americas.\n∃x (Plant(x) ∧ NativeTo(x, southeasternUnitedStates)) ∧ Several(x) ::: Several species of Elephantopus are native to the southeastern United States.\nTraditionalMedicine(elephantopusScaber) ::: Elephantopus scaber is a traditional medicine.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nWidespread(elephantopus, australia) ∧ Widespread(elephantopus, southernAsia) ::: Elephantopus is widespread over much of Australia and Southern Asia.\n\"\"\""
    ]
  },
  {
    "id": 42,
    "context": [
      "Elephantopus is a genus of perennial plants in the daisy family.",
      "Elephantopus is widespread over much of Africa, southern Asia, Australia, and the Americas.",
      "Several species of Elephantopus are native to the southeastern United States.",
      "Elephantopus scaber is a traditional medicine."
    ],
    "question": "No Elephantopus is native to the southeastern United States.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nGenus(x) ::: x is a genus of plants.\nPlant(x) ::: x is a plant.\nPerennial(x) ::: x is a perennial plant.\nFamily(x) ::: x is in the daisy family.\nWidespread(x, y) ::: x is widespread over y.\nNativeTo(x, y) ::: x is native to y.\nTraditionalMedicine(x) ::: x is a traditional medicine.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nGenus(elephantopus) ∧ Perennial(elephantopus) ∧ Family(elephantopus, daisy) ::: Elephantopus is a genus of perennial plants in the daisy family.\nWidespread(elephantopus, africa) ∧ Widespread(elephantopus, southernAsia) ∧ Widespread(elephantopus, australia) ∧ Widespread(elephantopus, americas) ::: Elephantopus is widespread over much of Africa, southern Asia, Australia, and the Americas.\n∃x (Plant(x) ∧ Genus(elephantopus) ∧ NativeTo(x, southeasternUS)) ::: Several species of Elephantopus are native to the southeastern United States.\nTraditionalMedicine(elephantopusScaber) ::: Elephantopus scaber is a traditional medicine.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬∃x (Plant(x) ∧ Genus(elephantopus) ∧ NativeTo(x, southeasternUS)) ::: No Elephantopus is native to the southeastern United States.\n\"\"\""
    ]
  },
  {
    "id": 43,
    "context": [
      "Elephantopus is a genus of perennial plants in the daisy family.",
      "Elephantopus is widespread over much of Africa, southern Asia, Australia, and the Americas.",
      "Several species of Elephantopus are native to the southeastern United States.",
      "Elephantopus scaber is a traditional medicine."
    ],
    "question": "Elephantopus is a traditional medicine.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nGenus(x) ::: x is a genus of plants.\nPlant(x) ::: x is a plant.\nPerennial(x) ::: x is a perennial plant.\nFamily(x) ::: x is a family of plants.\nWidespread(x, y) ::: x is widespread over y.\nNativeTo(x, y) ::: x is native to y.\nTraditionalMedicine(x) ::: x is a traditional medicine.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nGenus(elephantopus) ∧ Plant(elephantopus) ∧ Family(daisy, elephantopus) ::: Elephantopus is a genus of perennial plants in the daisy family.\nWidespread(elephantopus, africa) ∧ Widespread(elephantopus, southernAsia) ∧ Widespread(elephantopus, australia) ∧ Widespread(elephantopus, americas) ::: Elephantopus is widespread over much of Africa, southern Asia, Australia, and the Americas.\n∃x (Species(x) ∧ Elephantopus(x) ∧ NativeTo(x, southeasternUnitedStates)) ::: Several species of Elephantopus are native to the southeastern United States.\nTraditionalMedicine(elephantopusScaber) ::: Elephantopus scaber is a traditional medicine.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nTraditionalMedicine(elephantopusScaber) ::: Elephantopus is a traditional medicine.\n\"\"\""
    ]
  },
  {
    "id": 1236,
    "context": [
      "All Yale dormitories are located on York Street. ",
      "All buildings managed by Yale Housing are dormitories. ",
      "All buildings operated by Yale Housing staff are managed by Yale Housing. ",
      "No buildings open to students are established after 1800. ",
      "All buildings located on York Street are open to students. ",
      "Harkness is either a building operated by Yale Housing staff or located on York Street. "
    ],
    "question": "Harkness is a Yale dormitory.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nLocatedOn(x, y) ::: x is located on y.\nManagedBy(x, y) ::: x is managed by y.\nOperatedBy(x, y) ::: x is operated by y.\nOpenToStudents(x) ::: x is open to students.\nEstablishedAfter(x, y) ::: x is established after year y.\nBuilding(x) ::: x is a building.\nYaleDormitory(x) ::: x is a Yale dormitory.\nYaleHousing(x) ::: x is managed by Yale Housing.\nYaleHousingStaff(x) ::: x is Yale Housing staff.\nYorkStreet(x) ::: x is located on York Street.\nHarkness(x) ::: x is Harkness.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (YaleDormitory(x) → LocatedOn(x, YorkStreet)) ::: All Yale dormitories are located on York Street.\n∀x (YaleHousing(x) → YaleDormitory(x)) ::: All buildings managed by Yale Housing are dormitories.\n∀x (YaleHousingStaff(x) → ManagedBy(x, YaleHousing)) ::: All buildings operated by Yale Housing staff are managed by Yale Housing.\n∀x (OpenToStudents(x) → EstablishedAfter(x, 1800)) ::: No buildings open to students are established after 1800.\n∀x (LocatedOn(x, YorkStreet) → OpenToStudents(x)) ::: All buildings located on York Street are open to students.\n(OperatedBy(Harkness, YaleHousingStaff) ∨ LocatedOn(Harkness, YorkStreet)) ::: Harkness is either a building operated by Yale Housing staff or located on York Street.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nYaleDormitory(Harkness) ::: Harkness is a Yale dormitory.\n\"\"\""
    ]
  },
  {
    "id": 1237,
    "context": [
      "All Yale dormitories are located on York Street. ",
      "All buildings managed by Yale Housing are dormitories. ",
      "All buildings operated by Yale Housing staff are managed by Yale Housing. ",
      "No buildings open to students are established after 1800. ",
      "All buildings located on York Street are open to students. ",
      "Harkness is either a building operated by Yale Housing staff or located on York Street. "
    ],
    "question": "Harkness is not a Yale dormitory.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nLocatedOn(x, y) ::: x is located on y.\nDormitory(x) ::: x is a Yale dormitory.\nManagedByYaleHousing(x) ::: x is managed by Yale Housing.\nOperatedByYaleHousingStaff(x) ::: x is operated by Yale Housing staff.\nOpenToStudents(x) ::: x is open to students.\nEstablishedAfter(x, y) ::: x is established after year y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Dormitory(x) → LocatedOn(x, YorkStreet)) ::: All Yale dormitories are located on York Street.\n∀x (ManagedByYaleHousing(x) → Dormitory(x)) ::: All buildings managed by Yale Housing are dormitories.\n∀x (OperatedByYaleHousingStaff(x) → ManagedByYaleHousing(x)) ::: All buildings operated by Yale Housing staff are managed by Yale Housing.\n∀x (OpenToStudents(x) → EstablishedAfter(x, 1800)) ::: No buildings open to students are established after 1800.\n∀x (LocatedOn(x, YorkStreet) → OpenToStudents(x)) ::: All buildings located on York Street are open to students.\n(OperatedByYaleHousingStaff(harkness) ∨ LocatedOn(harkness, YorkStreet)) ::: Harkness is either a building operated by Yale Housing staff or located on York Street.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬Dormitory(harkness) ::: Harkness is not a Yale dormitory.\n\"\"\""
    ]
  },
  {
    "id": 1238,
    "context": [
      "All Yale dormitories are located on York Street. ",
      "All buildings managed by Yale Housing are dormitories. ",
      "All buildings operated by Yale Housing staff are managed by Yale Housing. ",
      "No buildings open to students are established after 1800. ",
      "All buildings located on York Street are open to students. ",
      "Harkness is either a building operated by Yale Housing staff or located on York Street. "
    ],
    "question": "Harkness is established after 1800.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nLocatedOn(x, y) ::: x is located on y.\nManagedBy(x, y) ::: x is managed by y.\nOperatedBy(x, y) ::: x is operated by y.\nOpenToStudents(x) ::: x is open to students.\nEstablishedAfter(x, y) ::: x is established after year y.\nBuilding(x) ::: x is a building.\nYaleDormitory(x) ::: x is a Yale dormitory.\nYaleHousing(x) ::: x is managed by Yale Housing.\nYaleHousingStaff(x) ::: x is Yale Housing staff.\nYorkStreet(x) ::: x is located on York Street.\nHarkness(x) ::: x is Harkness.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (YaleDormitory(x) → LocatedOn(x, YorkStreet)) ::: All Yale dormitories are located on York Street.\n∀x (YaleHousing(x) → YaleDormitory(x)) ::: All buildings managed by Yale Housing are dormitories.\n∀x (YaleHousingStaff(x) → ManagedBy(x, YaleHousing)) ::: All buildings operated by Yale Housing staff are managed by Yale Housing.\n∀x (OpenToStudents(x) → EstablishedAfter(x, 1800)) ::: No buildings open to students are established after 1800.\n∀x (LocatedOn(x, YorkStreet) → OpenToStudents(x)) ::: All buildings located on York Street are open to students.\n(Harkness(harkness) ∧ OperatedBy(harkness, YaleHousingStaff)) ∨ LocatedOn(harkness, YorkStreet) ::: Harkness is either a building operated by Yale Housing staff or located on York Street.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬EstablishedAfter(Harkness, 1800) ::: Harkness is established after 1800.\n\"\"\""
    ]
  },
  {
    "id": 1239,
    "context": [
      "All Yale dormitories are located on York Street. ",
      "All buildings managed by Yale Housing are dormitories. ",
      "All buildings operated by Yale Housing staff are managed by Yale Housing. ",
      "No buildings open to students are established after 1800. ",
      "All buildings located on York Street are open to students. ",
      "Harkness is either a building operated by Yale Housing staff or located on York Street. "
    ],
    "question": "Harkness is established before 1800.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nLocatedOn(x, y) ::: x is located on y.\nManagedBy(x, y) ::: x is managed by y.\nOperatedBy(x, y) ::: x is operated by y.\nOpenToStudents(x) ::: x is open to students.\nEstablishedBefore(x, y) ::: x is established before year y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Dormitory(x) → LocatedOn(x, YorkStreet)) ::: All Yale dormitories are located on York Street.\n∀x (ManagedBy(x, YaleHousing) → Dormitory(x)) ::: All buildings managed by Yale Housing are dormitories.\n∀x (OperatedBy(x, YaleHousingStaff) → ManagedBy(x, YaleHousing)) ::: All buildings operated by Yale Housing staff are managed by Yale Housing.\n∀x (OpenToStudents(x) → EstablishedBefore(x, 1800)) ::: No buildings open to students are established after 1800.\n∀x (LocatedOn(x, YorkStreet) → OpenToStudents(x)) ::: All buildings located on York Street are open to students.\n(OperatedBy(Harkness, YaleHousingStaff) ∨ LocatedOn(Harkness, YorkStreet)) ::: Harkness is either a building operated by Yale Housing staff or located on York Street.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nEstablishedBefore(Harkness, 1800) ::: Harkness is established before 1800.\n\"\"\""
    ]
  },
  {
    "id": 794,
    "context": [
      "There are no mansion houses in an urban area.",
      "All skyscrapers reside in urban areas.",
      "Every creepy haunted house is in a mansion house.",
      "Every terrifying Halloween scare comes from a creepy haunted house.",
      "The Scream is a creepy haunted house or a terrifying Halloween scare."
    ],
    "question": "The Scream is a skyscraper.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nMansion(x) ::: x is a mansion house.\nUrban(x) ::: x is in an urban area.\nSkyscraper(x) ::: x is a skyscraper.\nHaunted(x) ::: x is a creepy haunted house.\nHalloweenScare(x) ::: x is a terrifying Halloween scare.\nScream(x) ::: x is The Scream.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Mansion(x) → ¬Urban(x)) ::: There are no mansion houses in an urban area.\n∀x (Skyscraper(x) → Urban(x)) ::: All skyscrapers reside in urban areas.\n∀x (Haunted(x) → Mansion(x)) ::: Every creepy haunted house is in a mansion house.\n∀x (HalloweenScare(x) → Haunted(x)) ::: Every terrifying Halloween scare comes from a creepy haunted house.\nHaunted(scream) ∨ HalloweenScare(scream) ::: The Scream is a creepy haunted house or a terrifying Halloween scare.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬Skyscraper(scream) ::: The Scream is not a skyscraper.\n\"\"\""
    ]
  },
  {
    "id": 795,
    "context": [
      "There are no mansion houses in an urban area.",
      "All skyscrapers reside in urban areas.",
      "Every creepy haunted house is in a mansion house.",
      "Every terrifying Halloween scare comes from a creepy haunted house.",
      "The Scream is a creepy haunted house or a terrifying Halloween scare."
    ],
    "question": "The Scream is not a skyscraper.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nMansion(x) ::: x is a mansion house.\nUrban(x) ::: x is in an urban area.\nSkyscraper(x) ::: x is a skyscraper.\nHaunted(x) ::: x is a creepy haunted house.\nHalloweenScare(x) ::: x is a terrifying Halloween scare.\nScream(x) ::: x is The Scream.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Mansion(x) → ¬Urban(x)) ::: There are no mansion houses in an urban area.\n∀x (Skyscraper(x) → Urban(x)) ::: All skyscrapers reside in urban areas.\n∀x (Haunted(x) → Mansion(x)) ::: Every creepy haunted house is in a mansion house.\n∀x (HalloweenScare(x) → Haunted(x)) ::: Every terrifying Halloween scare comes from a creepy haunted house.\nScream(scream) ⊕ HalloweenScare(scream) ::: The Scream is a creepy haunted house or a terrifying Halloween scare.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬Skyscraper(scream) ::: The Scream is not a skyscraper.\n\"\"\""
    ]
  },
  {
    "id": 796,
    "context": [
      "There are no mansion houses in an urban area.",
      "All skyscrapers reside in urban areas.",
      "Every creepy haunted house is in a mansion house.",
      "Every terrifying Halloween scare comes from a creepy haunted house.",
      "The Scream is a creepy haunted house or a terrifying Halloween scare."
    ],
    "question": "The Scream is a terrifying Halloween scare.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nMansion(x) ::: x is a mansion house.\nUrban(x) ::: x is in an urban area.\nSkyscraper(x) ::: x is a skyscraper.\nCreepy(x) ::: x is a creepy haunted house.\nTerrifying(x) ::: x is a terrifying Halloween scare.\nScream(x) ::: x is The Scream.\nHalloweenScare(x) ::: x is a Halloween scare.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Mansion(x) → ¬Urban(x)) ::: There are no mansion houses in an urban area.\n∀x (Skyscraper(x) → Urban(x)) ::: All skyscrapers reside in urban areas.\n∀x (Creepy(x) → Mansion(x)) ::: Every creepy haunted house is in a mansion house.\n∀x (Terrifying(x) → HalloweenScare(x)) ::: Every terrifying Halloween scare comes from a creepy haunted house.\nCreepy(scream) ∨ Terrifying(scream) ::: The Scream is a creepy haunted house or a terrifying Halloween scare.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nTerrifying(scream) ::: The Scream is a terrifying Halloween scare.\n\"\"\""
    ]
  },
  {
    "id": 797,
    "context": [
      "There are no mansion houses in an urban area.",
      "All skyscrapers reside in urban areas.",
      "Every creepy haunted house is in a mansion house.",
      "Every terrifying Halloween scare comes from a creepy haunted house.",
      "The Scream is a creepy haunted house or a terrifying Halloween scare."
    ],
    "question": "The Scream is either a skyscraper or a mansion house.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nMansion(x) ::: x is a mansion house.\nUrban(x) ::: x is in an urban area.\nSkyscraper(x) ::: x is a skyscraper.\nHaunted(x) ::: x is a creepy haunted house.\nHalloweenScare(x) ::: x is a terrifying Halloween scare.\nScream(x) ::: x is The Scream.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Mansion(x) → ¬Urban(x)) ::: There are no mansion houses in an urban area.\n∀x (Skyscraper(x) → Urban(x)) ::: All skyscrapers reside in urban areas.\n∀x (Haunted(x) → Mansion(x)) ::: Every creepy haunted house is in a mansion house.\n∀x (HalloweenScare(x) → Haunted(x)) ::: Every terrifying Halloween scare comes from a creepy haunted house.\nScream(scream) ⊕ Haunted(scream) ⊕ HalloweenScare(scream) ::: The Scream is a creepy haunted house or a terrifying Halloween scare.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nSkyscraper(scream) ⊕ Mansion(scream) ::: The Scream is either a skyscraper or a mansion house.\n\"\"\""
    ]
  },
  {
    "id": 798,
    "context": [
      "There are no mansion houses in an urban area.",
      "All skyscrapers reside in urban areas.",
      "Every creepy haunted house is in a mansion house.",
      "Every terrifying Halloween scare comes from a creepy haunted house.",
      "The Scream is a creepy haunted house or a terrifying Halloween scare."
    ],
    "question": "The Scream is either a skyscraper or an urban area.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nMansion(x) ::: x is a mansion house.\nUrban(x) ::: x is an urban area.\nSkyscraper(x) ::: x is a skyscraper.\nHaunted(x) ::: x is a creepy haunted house.\nHalloweenScare(x) ::: x is a terrifying Halloween scare.\nScream(x) ::: x is The Scream.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Mansion(x) → ¬Urban(x)) ::: There are no mansion houses in an urban area.\n∀x (Skyscraper(x) → Urban(x)) ::: All skyscrapers reside in urban areas.\n∀x (Haunted(x) → Mansion(x)) ::: Every creepy haunted house is in a mansion house.\n∀x (HalloweenScare(x) → Haunted(x)) ::: Every terrifying Halloween scare comes from a creepy haunted house.\nScream(scream) ⊕ (Haunted(scream) ∨ HalloweenScare(scream)) ::: The Scream is a creepy haunted house or a terrifying Halloween scare.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nSkyscraper(scream) ⊕ Urban(scream) ::: The Scream is either a skyscraper or an urban area.\n\"\"\""
    ]
  },
  {
    "id": 799,
    "context": [
      "There are no mansion houses in an urban area.",
      "All skyscrapers reside in urban areas.",
      "Every creepy haunted house is in a mansion house.",
      "Every terrifying Halloween scare comes from a creepy haunted house.",
      "The Scream is a creepy haunted house or a terrifying Halloween scare."
    ],
    "question": "The Scream is either a skyscraper or a creepy haunted house.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nMansion(x) ::: x is a mansion house.\nUrban(x) ::: x is in an urban area.\nSkyscraper(x) ::: x is a skyscraper.\nHaunted(x) ::: x is a creepy haunted house.\nHalloweenScare(x) ::: x is a terrifying Halloween scare.\nScream(x) ::: x is The Scream.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Mansion(x) → ¬Urban(x)) ::: There are no mansion houses in an urban area.\n∀x (Skyscraper(x) → Urban(x)) ::: All skyscrapers reside in urban areas.\n∀x (Haunted(x) → Mansion(x)) ::: Every creepy haunted house is in a mansion house.\n∀x (HalloweenScare(x) → Haunted(x)) ::: Every terrifying Halloween scare comes from a creepy haunted house.\nHaunted(scream) ∨ HalloweenScare(scream) ::: The Scream is a creepy haunted house or a terrifying Halloween scare.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nSkyscraper(scream) ⊕ Haunted(scream) ::: The Scream is either a skyscraper or a creepy haunted house.\n\"\"\""
    ]
  },
  {
    "id": 800,
    "context": [
      "There are no mansion houses in an urban area.",
      "All skyscrapers reside in urban areas.",
      "Every creepy haunted house is in a mansion house.",
      "Every terrifying Halloween scare comes from a creepy haunted house.",
      "The Scream is a creepy haunted house or a terrifying Halloween scare."
    ],
    "question": "If The Scream is not a mansion in an urban area, then it is either a skyscraper or an urban area.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nMansion(x) ::: x is a mansion house.\nUrban(x) ::: x is an urban area.\nSkyscraper(x) ::: x is a skyscraper.\nHaunted(x) ::: x is a creepy haunted house.\nHalloweenScare(x) ::: x is a terrifying Halloween scare.\nScream(x) ::: x is The Scream.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n¬∃x (Mansion(x) ∧ Urban(x)) ::: There are no mansion houses in an urban area.\n∀x (Skyscraper(x) → Urban(x)) ::: All skyscrapers reside in urban areas.\n∀x (Haunted(x) → Mansion(x)) ::: Every creepy haunted house is in a mansion house.\n∀x (HalloweenScare(x) → Haunted(x)) ::: Every terrifying Halloween scare comes from a creepy haunted house.\n(Scream(scream) ∨ HalloweenScare(scream)) ∧ Haunted(scream) ::: The Scream is a creepy haunted house or a terrifying Halloween scare.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬(Mansion(scream) ∧ Urban(scream)) → (Skyscraper(scream) ∨ Urban(scream)) ::: If The Scream is not a mansion in an urban area, then it is either a skyscraper or an urban area.\n\"\"\""
    ]
  },
  {
    "id": 801,
    "context": [
      "There are no mansion houses in an urban area.",
      "All skyscrapers reside in urban areas.",
      "Every creepy haunted house is in a mansion house.",
      "Every terrifying Halloween scare comes from a creepy haunted house.",
      "The Scream is a creepy haunted house or a terrifying Halloween scare."
    ],
    "question": "If The Scream is either a skyscraper or a mansion house, then it is in an urban area.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nMansion(x) ::: x is a mansion house.\nUrban(x) ::: x is in an urban area.\nSkyscraper(x) ::: x is a skyscraper.\nHaunted(x) ::: x is a creepy haunted house.\nHalloweenScare(x) ::: x is a terrifying Halloween scare.\nScream(x) ::: x is The Scream.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Mansion(x) → ¬Urban(x)) ::: There are no mansion houses in an urban area.\n∀x (Skyscraper(x) → Urban(x)) ::: All skyscrapers reside in urban areas.\n∀x (Haunted(x) → Mansion(x)) ::: Every creepy haunted house is in a mansion house.\n∀x (HalloweenScare(x) → Haunted(x)) ::: Every terrifying Halloween scare comes from a creepy haunted house.\n(Scream(scream) ∨ HalloweenScare(scream)) ∧ (Haunted(scream) ∨ HalloweenScare(scream)) ::: The Scream is a creepy haunted house or a terrifying Halloween scare.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n(Skyscraper(scream) ∨ Mansion(scream)) → Urban(scream) ::: If The Scream is either a skyscraper or a mansion house, then it is in an urban area.\n\"\"\""
    ]
  },
  {
    "id": 802,
    "context": [
      "There are no mansion houses in an urban area.",
      "All skyscrapers reside in urban areas.",
      "Every creepy haunted house is in a mansion house.",
      "Every terrifying Halloween scare comes from a creepy haunted house.",
      "The Scream is a creepy haunted house or a terrifying Halloween scare."
    ],
    "question": "If The Scream is either a skyscraper or a mansion house, then it is neither a creepy haunted house nor a terrifying Halloween scare.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nMansion(x) ::: x is a mansion house.\nUrban(x) ::: x is in an urban area.\nSkyscraper(x) ::: x is a skyscraper.\nCreepy(x) ::: x is a creepy haunted house.\nHaunted(x) ::: x is a haunted house.\nTerrifying(x) ::: x is a terrifying Halloween scare.\nScream(x) ::: x is The Scream.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n¬∃x (Mansion(x) ∧ Urban(x)) ::: There are no mansion houses in an urban area.\n∀x (Skyscraper(x) → Urban(x)) ::: All skyscrapers reside in urban areas.\n∀x (Creepy(x) → ∃y (Mansion(y) ∧ Haunted(y) ∧ Creepy(x))) ::: Every creepy haunted house is in a mansion house.\n∀x (Terrifying(x) → ∃y (Creepy(y) ∧ Haunted(y) ∧ Terrifying(x))) ::: Every terrifying Halloween scare comes from a creepy haunted house.\n(Scream(scream) ∧ Creepy(scream)) ∨ (Scream(scream) ∧ Terrifying(scream)) ::: The Scream is a creepy haunted house or a terrifying Halloween scare.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n(Skyscraper(scream) ∨ Mansion(scream)) → ¬(Creepy(scream) ∨ Terrifying(scream)) ::: If The Scream is either a skyscraper or a mansion house, then it is neither a creepy haunted house nor a terrifying Halloween scare.\n\"\"\""
    ]
  },
  {
    "id": 803,
    "context": [
      "There are no mansion houses in an urban area.",
      "All skyscrapers reside in urban areas.",
      "Every creepy haunted house is in a mansion house.",
      "Every terrifying Halloween scare comes from a creepy haunted house.",
      "The Scream is a creepy haunted house or a terrifying Halloween scare."
    ],
    "question": "If The Scream is either a skyscraper or a creepy haunted house, then it is not a mansion house.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nMansion(x) ::: x is a mansion house.\nUrban(x) ::: x is in an urban area.\nSkyscraper(x) ::: x is a skyscraper.\nHaunted(x) ::: x is a creepy haunted house.\nHalloweenScare(x) ::: x is a terrifying Halloween scare.\nScream(x) ::: x is The Scream.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Mansion(x) → ¬Urban(x)) ::: There are no mansion houses in an urban area.\n∀x (Skyscraper(x) → Urban(x)) ::: All skyscrapers reside in urban areas.\n∀x (Haunted(x) → Mansion(x)) ::: Every creepy haunted house is in a mansion house.\n∀x (HalloweenScare(x) → Haunted(x)) ::: Every terrifying Halloween scare comes from a creepy haunted house.\n(Scream(scream) ∨ HalloweenScare(scream)) ∧ (Haunted(scream) ∨ HalloweenScare(scream)) ::: The Scream is a creepy haunted house or a terrifying Halloween scare.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n(Skyscraper(scream) ∨ Haunted(scream)) → ¬Mansion(scream) ::: If The Scream is either a skyscraper or a creepy haunted house, then it is not a mansion house.\n\"\"\""
    ]
  },
  {
    "id": 331,
    "context": [
      "Phuoc Binh national park is a national park in Vietnam. ",
      "Any national park in Vietnam is classified as a nature reserve. ",
      "There is a national park in Vietnam classified as a UNESCO World Heritage Site.",
      "All national parks in Vietnam are either managed by the Ministry of Agriculture or by the People's Committee. ",
      "Phuoc Binh is not managed by the Ministry of Agriculture."
    ],
    "question": "There is a nature reserve in Vietnam.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nNationalPark(x) ::: x is a national park.\nVietnam(x) ::: x is in Vietnam.\nNatureReserve(x) ::: x is classified as a nature reserve.\nUNESCO(x) ::: x is classified as a UNESCO World Heritage Site.\nManagedByMinistryOfAgriculture(x) ::: x is managed by the Ministry of Agriculture.\nManagedByPeoplesCommittee(x) ::: x is managed by the People's Committee.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nNationalPark(phuocBinh) ∧ Vietnam(phuocBinh) ::: Phuoc Binh national park is a national park in Vietnam.\n∀x (NationalPark(x) ∧ Vietnam(x) → NatureReserve(x)) ::: Any national park in Vietnam is classified as a nature reserve.\n∃x (NationalPark(x) ∧ Vietnam(x) ∧ UNESCO(x)) ::: There is a national park in Vietnam classified as a UNESCO World Heritage Site.\n∀x (NationalPark(x) ∧ Vietnam(x) → (ManagedByMinistryOfAgriculture(x) ∨ ManagedByPeoplesCommittee(x))) ::: All national parks in Vietnam are either managed by the Ministry of Agriculture or by the People's Committee.\n¬ManagedByMinistryOfAgriculture(phuocBinh) ::: Phuoc Binh is not managed by the Ministry of Agriculture.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n∃x (NationalPark(x) ∧ Vietnam(x) ∧ NatureReserve(x)) ::: There is a nature reserve in Vietnam.\n\"\"\""
    ]
  },
  {
    "id": 332,
    "context": [
      "Phuoc Binh national park is a national park in Vietnam. ",
      "Any national park in Vietnam is classified as a nature reserve. ",
      "There is a national park in Vietnam classified as a UNESCO World Heritage Site.",
      "All national parks in Vietnam are either managed by the Ministry of Agriculture or by the People's Committee. ",
      "Phuoc Binh is not managed by the Ministry of Agriculture."
    ],
    "question": "Phuoc Binh is a UNESCO Heritage Site.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nNationalPark(x) ::: x is a national park.\nVietnam(x) ::: x is in Vietnam.\nNatureReserve(x) ::: x is classified as a nature reserve.\nUNESCOHeritageSite(x) ::: x is classified as a UNESCO World Heritage Site.\nManagedByMinistryOfAgriculture(x) ::: x is managed by the Ministry of Agriculture.\nManagedByPeoplesCommittee(x) ::: x is managed by the People's Committee.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nNationalPark(phuocBinh) ∧ Vietnam(phuocBinh) ::: Phuoc Binh national park is a national park in Vietnam.\n∀x (NationalPark(x) ∧ Vietnam(x) → NatureReserve(x)) ::: Any national park in Vietnam is classified as a nature reserve.\n∃x (NationalPark(x) ∧ Vietnam(x) ∧ UNESCOHeritageSite(x)) ::: There is a national park in Vietnam classified as a UNESCO World Heritage Site.\n∀x (NationalPark(x) ∧ Vietnam(x) → (ManagedByMinistryOfAgriculture(x) ∨ ManagedByPeoplesCommittee(x))) ::: All national parks in Vietnam are either managed by the Ministry of Agriculture or by the People's Committee.\n¬ManagedByMinistryOfAgriculture(phuocBinh) ::: Phuoc Binh is not managed by the Ministry of Agriculture.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nUNESCOHeritageSite(phuocBinh) ::: Phuoc Binh is a UNESCO Heritage Site.\n\"\"\""
    ]
  },
  {
    "id": 333,
    "context": [
      "Phuoc Binh national park is a national park in Vietnam. ",
      "Any national park in Vietnam is classified as a nature reserve. ",
      "There is a national park in Vietnam classified as a UNESCO World Heritage Site.",
      "All national parks in Vietnam are either managed by the Ministry of Agriculture or by the People's Committee. ",
      "Phuoc Binh is not managed by the Ministry of Agriculture."
    ],
    "question": "Phuoc Binh is managed by the People's Committee.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nNationalPark(x) ::: x is a national park.\nVietnam(x) ::: x is in Vietnam.\nNatureReserve(x) ::: x is classified as a nature reserve.\nUNESCO(x) ::: x is classified as a UNESCO World Heritage Site.\nManagedBy(x, y) ::: x is managed by y.\nMinistryOfAgriculture(x) ::: x is managed by the Ministry of Agriculture.\nPeoplesCommittee(x) ::: x is managed by the People's Committee.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nNationalPark(phuocBinh) ∧ Vietnam(phuocBinh) ::: Phuoc Binh national park is a national park in Vietnam.\n∀x (NationalPark(x) ∧ Vietnam(x) → NatureReserve(x)) ::: Any national park in Vietnam is classified as a nature reserve.\n∃x (NationalPark(x) ∧ Vietnam(x) ∧ UNESCO(x)) ::: There is a national park in Vietnam classified as a UNESCO World Heritage Site.\n∀x (NationalPark(x) ∧ Vietnam(x) → (ManagedBy(x, MinistryOfAgriculture) ∨ ManagedBy(x, PeoplesCommittee))) ::: All national parks in Vietnam are either managed by the Ministry of Agriculture or by the People's Committee.\n¬ManagedBy(phuocBinh, MinistryOfAgriculture) ::: Phuoc Binh is not managed by the Ministry of Agriculture.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nManagedBy(phuocBinh, PeoplesCommittee) ::: Phuoc Binh is managed by the People's Committee.\n\"\"\""
    ]
  },
  {
    "id": 404,
    "context": [
      "Greyhound racing is a competitive sport where spectators bet on greyhounds.",
      "Coursing is a part of Greyhound racing.",
      "Some competitive sports where spectators bet on things are banned.",
      "Coursing involves spectators betting on a hare being pursued by greyhounds.",
      "Hares are small game.",
      "If a competitive sport involves spectators betting on small game, then it is banned."
    ],
    "question": "No coursing is banned.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nCompetitiveSport(x) ::: x is a competitive sport.\nSpectatorsBet(x) ::: spectators bet on x.\nGreyhoundRacing(x) ::: x is greyhound racing.\nCoursing(x) ::: x is coursing.\nBanned(x) ::: x is banned.\nInvolves(x, y) ::: x involves y.\nSmallGame(x) ::: x is a small game.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (GreyhoundRacing(x) → (CompetitiveSport(x) ∧ SpectatorsBet(x))) ::: Greyhound racing is a competitive sport where spectators bet on greyhounds.\nCoursing(coursing) ∧ Involves(coursing, GreyhoundRacing) ::: Coursing is a part of Greyhound racing.\n∃x (CompetitiveSport(x) ∧ SpectatorsBet(x) ∧ Banned(x)) ::: Some competitive sports where spectators bet on things are banned.\nInvolves(coursing, SmallGame) ∧ Involves(coursing, SpectatorsBet(hare)) ∧ SmallGame(hare) ::: Coursing involves spectators betting on a hare being pursued by greyhounds.\n∀x (Involves(CompetitiveSport(x), SmallGame(x)) → Banned(CompetitiveSport(x))) ::: If a competitive sport involves spectators betting on small game, then it is banned.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬∃x (Coursing(x) ∧ Banned(x)) ::: No coursing is banned.\n\"\"\""
    ]
  },
  {
    "id": 405,
    "context": [
      "Greyhound racing is a competitive sport where spectators bet on greyhounds.",
      "Coursing is a part of Greyhound racing.",
      "Some competitive sports where spectators bet on things are banned.",
      "Coursing involves spectators betting on a hare being pursued by greyhounds.",
      "Hares are small game.",
      "If a competitive sport involves spectators betting on small game, then it is banned."
    ],
    "question": "Greyhound racing is a competitive sport.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nCompetitiveSport(x) ::: x is a competitive sport.\nSpectatorsBet(x) ::: spectators bet on x.\nGreyhoundRacing(x) ::: x is greyhound racing.\nCoursing(x) ::: x is coursing.\nBanned(x) ::: x is banned.\nInvolves(x, y) ::: x involves y.\nSmallGame(x) ::: x is a small game.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nGreyhoundRacing(greyhound) ∧ ∀x (GreyhoundRacing(x) → SpectatorsBet(x)) ::: Greyhound racing is a competitive sport where spectators bet on greyhounds.\nCoursing(coursing) ∧ Involves(coursing, greyhound) ∧ ∀x (Coursing(x) → GreyhoundRacing(x)) ::: Coursing is a part of Greyhound racing.\n∃x (CompetitiveSport(x) ∧ SpectatorsBet(x) ∧ Banned(x)) ::: Some competitive sports where spectators bet on things are banned.\nInvolves(coursing, hare) ∧ SpectatorsBet(coursing) ∧ ∀x (Involves(x, smallGame) → Banned(x)) ::: Coursing involves spectators betting on a hare being pursued by greyhounds.\nSmallGame(hare) ::: Hares are small game.\n∀x (CompetitiveSport(x) ∧ SpectatorsBet(x) ∧ SmallGame(x) → Banned(x)) ::: If a competitive sport involves spectators betting on small game, then it is banned.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nCompetitiveSport(greyhound) ::: Greyhound racing is a competitive sport.\n\"\"\""
    ]
  },
  {
    "id": 547,
    "context": [
      "If a soccer player receives two yellow cards in one game, this player will be ejected from the rest of the game.",
      "If a soccer player receives one red card in one game, this player will be ejected from the rest of the game.",
      "Henry is a soccer player.",
      "In one game, Henry first receives one yellow card, then he receives one red card."
    ],
    "question": "Henry will be ejected from the rest of the game.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nSoccerPlayer(x) ::: x is a soccer player.\nReceivesYellowCard(x, game) ::: x receives a yellow card in game.\nReceivesRedCard(x, game) ::: x receives a red card in game.\nEjected(x, game) ::: x is ejected from the rest of the game.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (ReceivesYellowCard(x, game) ∧ ReceivesYellowCard(x, game) → Ejected(x, game)) ::: If a soccer player receives two yellow cards in one game, this player will be ejected from the rest of the game.\n∀x (ReceivesRedCard(x, game) → Ejected(x, game)) ::: If a soccer player receives one red card in one game, this player will be ejected from the rest of the game.\nSoccerPlayer(henry) ::: Henry is a soccer player.\nReceivesYellowCard(henry, game1) ∧ ReceivesRedCard(henry, game1) ::: In one game, Henry first receives one yellow card, then he receives one red card.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nEjected(henry, game1) ::: Henry will be ejected from the rest of the game.\n\"\"\""
    ]
  },
  {
    "id": 548,
    "context": [
      "If a soccer player receives two yellow cards in one game, this player will be ejected from the rest of the game.",
      "If a soccer player receives one red card in one game, this player will be ejected from the rest of the game.",
      "Henry is a soccer player.",
      "In one game, Henry first receives one yellow card, then he receives one red card."
    ],
    "question": "Henry will not be ejected from the rest of the game.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nSoccerPlayer(x) ::: x is a soccer player.\nReceives(x, y, z) ::: x receives y cards in one game, z is the color of the card.\nEjected(x) ::: x is ejected from the rest of the game.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Receives(x, yellow, 2) → Ejected(x)) ::: If a soccer player receives two yellow cards in one game, this player will be ejected from the rest of the game.\n∀x (Receives(x, red, 1) → Ejected(x)) ::: If a soccer player receives one red card in one game, this player will be ejected from the rest of the game.\nSoccerPlayer(henry) ::: Henry is a soccer player.\nReceives(henry, yellow, 1) ∧ Receives(henry, red, 1) ::: In one game, Henry first receives one yellow card, then he receives one red card.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬Ejected(henry) ::: Henry will not be ejected from the rest of the game.\n\"\"\""
    ]
  },
  {
    "id": 736,
    "context": [
      "All trees are plants. ",
      "Some living things are trees."
    ],
    "question": "Some living things are plants.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nTree(x) ::: x is a tree.\nPlant(x) ::: x is a plant.\nLivingThing(x) ::: x is a living thing.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Tree(x) → Plant(x)) ::: All trees are plants.\n∃x (LivingThing(x) ∧ Tree(x)) ::: Some living things are trees.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n∃x (LivingThing(x) ∧ Plant(x)) ::: Some living things are plants.\n\"\"\""
    ]
  },
  {
    "id": 44,
    "context": [
      "Dagfinn is a given name.",
      "Notable people with the given name include Dagfinn Aarskog, Dagfinn Bakke and Dagfinn Dahl. ",
      "Dagfinn Aarskog is a Norwegian physician.",
      "Dagfinn Dahl is a Norwegian barrister."
    ],
    "question": "Dagfinn Aarskog is a notable person.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nGivenName(x) ::: x is a given name.\nNotablePerson(x) ::: x is a notable person.\nNorwegian(x) ::: x is Norwegian.\nPhysician(x) ::: x is a physician.\nBarrister(x) ::: x is a barrister.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nGivenName(dagfinn) ::: Dagfinn is a given name.\n∀x (GivenName(x) → (NotablePerson(x) ∨ Norwegian(x))) ::: Notable people with the given name include Dagfinn Aarskog, Dagfinn Bakke, and Dagfinn Dahl.\nNorwegian(aarskog) ∧ Physician(aarskog) ::: Dagfinn Aarskog is a Norwegian physician.\nNorwegian(dahl) ∧ Barrister(dahl) ::: Dagfinn Dahl is a Norwegian barrister.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nNotablePerson(aarskog) ::: Dagfinn Aarskog is a notable person.\n\"\"\""
    ]
  },
  {
    "id": 45,
    "context": [
      "Dagfinn is a given name.",
      "Notable people with the given name include Dagfinn Aarskog, Dagfinn Bakke and Dagfinn Dahl. ",
      "Dagfinn Aarskog is a Norwegian physician.",
      "Dagfinn Dahl is a Norwegian barrister."
    ],
    "question": "Dagfinn is Dagfinn Aarskog's given name.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nGivenName(x) ::: x is a given name.\nPerson(x) ::: x is a person.\nNorwegian(x) ::: x is Norwegian.\nPhysician(x) ::: x is a physician.\nBarrister(x) ::: x is a barrister.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nGivenName(dagfinn) ::: Dagfinn is a given name.\nPerson(dagfinn) ∧ Person(dagfinnAarskog) ∧ Person(dagfinnBakke) ∧ Person(dagfinnDahl) ::: Notable people with the given name include Dagfinn Aarskog, Dagfinn Bakke, and Dagfinn Dahl.\nNorwegian(dagfinnAarskog) ∧ Physician(dagfinnAarskog) ::: Dagfinn Aarskog is a Norwegian physician.\nNorwegian(dagfinnDahl) ∧ Barrister(dagfinnDahl) ::: Dagfinn Dahl is a Norwegian barrister.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nGivenName(dagfinn) ∧ Person(dagfinn) ∧ Person(dagfinnAarskog) ::: Dagfinn is Dagfinn Aarskog's given name.\n\"\"\""
    ]
  },
  {
    "id": 46,
    "context": [
      "Dagfinn is a given name.",
      "Notable people with the given name include Dagfinn Aarskog, Dagfinn Bakke and Dagfinn Dahl. ",
      "Dagfinn Aarskog is a Norwegian physician.",
      "Dagfinn Dahl is a Norwegian barrister."
    ],
    "question": "Dagfinn Dahl is a Norwegian physician.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nGivenName(x) ::: x is a given name.\nPerson(x) ::: x is a person.\nNorwegian(x) ::: x is Norwegian.\nPhysician(x) ::: x is a physician.\nBarrister(x) ::: x is a barrister.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nGivenName(dagfinn) ::: Dagfinn is a given name.\nPerson(dagfinnAarskog) ∧ Person(dagfinnBakke) ∧ Person(dagfinnDahl) ∧ GivenName(dagfinnAarskog) ∧ GivenName(dagfinnBakke) ∧ GivenName(dagfinnDahl) ::: Notable people with the given name include Dagfinn Aarskog, Dagfinn Bakke and Dagfinn Dahl.\nNorwegian(dagfinnAarskog) ∧ Physician(dagfinnAarskog) ::: Dagfinn Aarskog is a Norwegian physician.\nNorwegian(dagfinnDahl) ∧ Barrister(dagfinnDahl) ::: Dagfinn Dahl is a Norwegian barrister.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nPhysician(dagfinnDahl) ::: Dagfinn Dahl is a Norwegian physician.\n\"\"\""
    ]
  },
  {
    "id": 749,
    "context": [
      "If entertainment is interesting, it will be popular.",
      "All popular things are well-known."
    ],
    "question": "If entertainment is interesting, it will be well-known.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nInteresting(x) ::: x is interesting.\nPopular(x) ::: x is popular.\nWellKnown(x) ::: x is well-known.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nInteresting(x) → Popular(x) ::: If entertainment is interesting, it will be popular.\n∀x (Popular(x) → WellKnown(x)) ::: All popular things are well-known.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nInteresting(entertainment) → WellKnown(entertainment) ::: If entertainment is interesting, it will be well-known.\n\"\"\""
    ]
  },
  {
    "id": 687,
    "context": [
      "It is not true that some giant language models do not have good performance. ",
      "All language models with good performance are used by some researchers.",
      "If a language model is used by some researchers, it is popular. ",
      "If BERT is a giant language model, then GPT3 is also a giant language model. ",
      "BERT is a giant language model. "
    ],
    "question": "GPT3 is popular.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nLanguageModel(x) ::: x is a language model.\nPerformance(x) ::: x has good performance.\nResearcher(x) ::: x is a researcher.\nPopular(x) ::: x is popular.\nGiant(x) ::: x is a giant language model.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n¬∃x (Giant(x) ∧ ¬Performance(x)) ::: It is not true that some giant language models do not have good performance.\n∀x (Performance(x) → ∃y (Researcher(y) ∧ Uses(y, x))) ::: All language models with good performance are used by some researchers.\n∀x (Uses(x, y) → Popular(x)) ::: If a language model is used by some researchers, it is popular.\n(BERT(bert) ∧ Giant(bert)) → Giant(gpt3) ::: If BERT is a giant language model, then GPT3 is also a giant language model.\nGiant(bert) ::: BERT is a giant language model.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nPopular(gpt3) ::: GPT3 is popular.\n\"\"\""
    ]
  },
  {
    "id": 334,
    "context": [
      "St Johnstone is a Scottish team.",
      "St Johnstone is part of the Scottish Premiership.",
      "If a team is part of the league, it has joined the league.",
      "St Johnstone and Minsk are different teams.",
      "For two different teams, either one team wins or the other team wins.",
      "Minsk won against St Johnstone."
    ],
    "question": "At least one Scottish team has joined the Scottish Premiership.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nScottish(x) ::: x is a Scottish team.\nTeam(x) ::: x is a team.\nPartOfLeague(x, y) ::: x is part of the league y.\nJoin(x, y) ::: x has joined the league y.\nDifferent(x, y) ::: x and y are different teams.\nWin(x, y) ::: x wins against y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nScottish(stJohnstone) ∧ Team(stJohnstone) ::: St Johnstone is a Scottish team.\nPartOfLeague(stJohnstone, scottishPremiership) ::: St Johnstone is part of the Scottish Premiership.\n∀x (Team(x) ∧ PartOfLeague(x, y) → Join(x, y)) ::: If a team is part of the league, it has joined the league.\nDifferent(stJohnstone, minsk) ::: St Johnstone and Minsk are different teams.\n∀x ∀y (Different(x, y) → (Win(x, y) ∨ Win(y, x))) ::: For two different teams, either one team wins or the other team wins.\nWin(minsk, stJohnstone) ::: Minsk won against St Johnstone.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n∃x (Scottish(x) ∧ PartOfLeague(x, scottishPremiership)) ::: At least one Scottish team has joined the Scottish Premiership.\n\"\"\""
    ]
  },
  {
    "id": 335,
    "context": [
      "St Johnstone is a Scottish team.",
      "St Johnstone is part of the Scottish Premiership.",
      "If a team is part of the league, it has joined the league.",
      "St Johnstone and Minsk are different teams.",
      "For two different teams, either one team wins or the other team wins.",
      "Minsk won against St Johnstone."
    ],
    "question": "St Johnstone won against Minsk.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nScottish(x) ::: x is a Scottish team.\nPartOfLeague(x, y) ::: x is part of the league y.\nJoinedLeague(x) ::: x has joined the league.\nDifferent(x, y) ::: x and y are different teams.\nWins(x, y) ::: x wins against y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nScottish(stJohnstone) ::: St Johnstone is a Scottish team.\nPartOfLeague(stJohnstone, scottishPremiership) ::: St Johnstone is part of the Scottish Premiership.\n∀x∀y ((PartOfLeague(x, y)) → JoinedLeague(x)) ::: If a team is part of the league, it has joined the league.\nDifferent(stJohnstone, minsk) ::: St Johnstone and Minsk are different teams.\n∀x∀y (Different(x, y) → (Wins(x, y) ∨ Wins(y, x))) ::: For two different teams, either one team wins or the other team wins.\nWins(minsk, stJohnstone) ::: Minsk won against St Johnstone.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nWins(stJohnstone, minsk) ::: St Johnstone won against Minsk.\n\"\"\""
    ]
  },
  {
    "id": 336,
    "context": [
      "St Johnstone is a Scottish team.",
      "St Johnstone is part of the Scottish Premiership.",
      "If a team is part of the league, it has joined the league.",
      "St Johnstone and Minsk are different teams.",
      "For two different teams, either one team wins or the other team wins.",
      "Minsk won against St Johnstone."
    ],
    "question": "Minsk joined the Scottish Premiership.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nScottish(x) ::: x is a Scottish team.\nPartOfLeague(x, y) ::: x is part of the league y.\nJoinedLeague(x) ::: x has joined the league.\nDifferent(x, y) ::: x and y are different teams.\nWins(x, y) ::: x wins against y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nScottish(stJohnstone) ::: St Johnstone is a Scottish team.\nPartOfLeague(stJohnstone, scottishPremiership) ::: St Johnstone is part of the Scottish Premiership.\n∀x (PartOfLeague(x, y) → JoinedLeague(x)) ::: If a team is part of the league, it has joined the league.\nDifferent(stJohnstone, minsk) ::: St Johnstone and Minsk are different teams.\n∀x ∀y (Different(x, y) → (Wins(x, y) ∨ Wins(y, x))) ::: For two different teams, either one team wins or the other team wins.\nWins(minsk, stJohnstone) ::: Minsk won against St Johnstone.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nJoinedLeague(minsk) ::: Minsk joined the Scottish Premiership.\n\"\"\""
    ]
  },
  {
    "id": 1232,
    "context": [
      "No Boeing-737 plane is equipped with more than 300 seats. ",
      "All planes in Delta are of type Boeing-737. ",
      "Planes are either equipped with more than 300 seats or have a capacity of 100 passengers. ",
      "All planes with a capacity of 100 passengers are scheduled for a short-distance flight. ",
      "All planes with a capacity of 100 passengers are produced before 2010. ",
      "Jake32 is either a Boeing-737 plane or a plane in Delta. ",
      "T10 is either a Boeing-737 plane and in Delta, or neither a Boeing-737 plane nor in Delta. "
    ],
    "question": "Jake32 was produced before 2010 and is scheduled for a short-distance flight.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nEquippedWithMoreThan300Seats(x) ::: x is equipped with more than 300 seats.\nType(x, y) ::: x is of type y.\nPlane(x) ::: x is a plane.\nCapacityOf100Passengers(x) ::: x has a capacity of 100 passengers.\nScheduledForShortDistanceFlight(x) ::: x is scheduled for a short-distance flight.\nProducedBefore2010(x) ::: x is produced before 2010.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Plane(x) ∧ Type(x, Boeing-737) → ¬EquippedWithMoreThan300Seats(x)) ::: No Boeing-737 plane is equipped with more than 300 seats.\n∀x (Plane(x) ∧ Type(x, Delta) → Type(x, Boeing-737)) ::: All planes in Delta are of type Boeing-737.\n∀x (Plane(x) → (EquippedWithMoreThan300Seats(x) ∨ CapacityOf100Passengers(x))) ::: Planes are either equipped with more than 300 seats or have a capacity of 100 passengers.\n∀x (CapacityOf100Passengers(x) → ScheduledForShortDistanceFlight(x)) ::: All planes with a capacity of 100 passengers are scheduled for a short-distance flight.\n∀x (CapacityOf100Passengers(x) → ProducedBefore2010(x)) ::: All planes with a capacity of 100 passengers are produced before 2010.\n(Type(jake32, Boeing-737) ∨ Type(jake32, Delta)) ::: Jake32 is either a Boeing-737 plane or a plane in Delta.\n(Type(t10, Boeing-737) ∧ Type(t10, Delta)) ⊕ ¬(Type(t10, Boeing-737) ∨ Type(t10, Delta)) ::: T10 is either a Boeing-737 plane and in Delta, or neither a Boeing-737 plane nor in Delta.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nProducedBefore2010(jake32) ∧ ScheduledForShortDistanceFlight(jake32) ::: Jake32 was produced before 2010 and is scheduled for a short-distance flight.\n\"\"\""
    ]
  },
  {
    "id": 1233,
    "context": [
      "No Boeing-737 plane is equipped with more than 300 seats. ",
      "All planes in Delta are of type Boeing-737. ",
      "Planes are either equipped with more than 300 seats or have a capacity of 100 passengers. ",
      "All planes with a capacity of 100 passengers are scheduled for a short-distance flight. ",
      "All planes with a capacity of 100 passengers are produced before 2010. ",
      "Jake32 is either a Boeing-737 plane or a plane in Delta. ",
      "T10 is either a Boeing-737 plane and in Delta, or neither a Boeing-737 plane nor in Delta. "
    ],
    "question": "Jake32 is not produced before 2010 and is not scheduled for a short-distance flight.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nEquippedWithMoreThan300Seats(x) ::: x is equipped with more than 300 seats.\nType(x, y) ::: x is of type y.\nPlane(x) ::: x is a plane.\nCapacityOf100Passengers(x) ::: x has a capacity of 100 passengers.\nScheduledForShortDistanceFlight(x) ::: x is scheduled for a short-distance flight.\nProducedBefore2010(x) ::: x is produced before 2010.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Plane(x) ∧ Type(x, Boeing-737) → ¬EquippedWithMoreThan300Seats(x)) ::: No Boeing-737 plane is equipped with more than 300 seats.\n∀x (Plane(x) ∧ Type(x, Delta) → Type(x, Boeing-737)) ::: All planes in Delta are of type Boeing-737.\n∀x (Plane(x) → (EquippedWithMoreThan300Seats(x) ∨ CapacityOf100Passengers(x))) ::: Planes are either equipped with more than 300 seats or have a capacity of 100 passengers.\n∀x (CapacityOf100Passengers(x) → ScheduledForShortDistanceFlight(x)) ::: All planes with a capacity of 100 passengers are scheduled for a short-distance flight.\n∀x (CapacityOf100Passengers(x) → ProducedBefore2010(x)) ::: All planes with a capacity of 100 passengers are produced before 2010.\n(Type(jake32, Boeing-737) ∨ Type(jake32, Delta)) ::: Jake32 is either a Boeing-737 plane or a plane in Delta.\n(Type(t10, Boeing-737) ∧ Type(t10, Delta)) ⊕ ¬(Type(t10, Boeing-737) ∨ Type(t10, Delta)) ::: T10 is either a Boeing-737 plane and in Delta, or neither a Boeing-737 plane nor in Delta.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬(ProducedBefore2010(jake32) ∧ ScheduledForShortDistanceFlight(jake32)) ::: Jake32 is not produced before 2010 and is not scheduled for a short-distance flight.\n\"\"\""
    ]
  },
  {
    "id": 1234,
    "context": [
      "No Boeing-737 plane is equipped with more than 300 seats. ",
      "All planes in Delta are of type Boeing-737. ",
      "Planes are either equipped with more than 300 seats or have a capacity of 100 passengers. ",
      "All planes with a capacity of 100 passengers are scheduled for a short-distance flight. ",
      "All planes with a capacity of 100 passengers are produced before 2010. ",
      "Jake32 is either a Boeing-737 plane or a plane in Delta. ",
      "T10 is either a Boeing-737 plane and in Delta, or neither a Boeing-737 plane nor in Delta. "
    ],
    "question": "Jake32 is produced before 2010 or scheduled for a short-distance flight.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nEquippedWithMoreThan300Seats(x) ::: x is equipped with more than 300 seats.\nType(x, y) ::: x is of type y.\nPlane(x) ::: x is a plane.\nCapacityOf100Passengers(x) ::: x has a capacity of 100 passengers.\nScheduledForShortDistanceFlight(x) ::: x is scheduled for a short-distance flight.\nProducedBefore2010(x) ::: x is produced before 2010.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n¬∃x (Plane(x) ∧ EquippedWithMoreThan300Seats(x)) ::: No Boeing-737 plane is equipped with more than 300 seats.\n∀x (Type(x, boeing737) → Type(x, delta)) ::: All planes in Delta are of type Boeing-737.\n∀x (Plane(x) → (EquippedWithMoreThan300Seats(x) ∨ CapacityOf100Passengers(x))) ::: Planes are either equipped with more than 300 seats or have a capacity of 100 passengers.\n∀x (CapacityOf100Passengers(x) → ScheduledForShortDistanceFlight(x)) ::: All planes with a capacity of 100 passengers are scheduled for a short-distance flight.\n∀x (CapacityOf100Passengers(x) → ProducedBefore2010(x)) ::: All planes with a capacity of 100 passengers are produced before 2010.\n(Type(jake32, boeing737) ∨ Type(jake32, delta)) ::: Jake32 is either a Boeing-737 plane or a plane in Delta.\n(Type(t10, boeing737) ∧ Type(t10, delta)) ⊕ ¬(Type(t10, boeing737) ∨ Type(t10, delta)) ::: T10 is either a Boeing-737 plane and in Delta, or neither a Boeing-737 plane nor in Delta.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nProducedBefore2010(jake32) ∨ ScheduledForShortDistanceFlight(jake32) ::: Jake32 is produced before 2010 or scheduled for a short-distance flight.\n\"\"\""
    ]
  },
  {
    "id": 1235,
    "context": [
      "No Boeing-737 plane is equipped with more than 300 seats. ",
      "All planes in Delta are of type Boeing-737. ",
      "Planes are either equipped with more than 300 seats or have a capacity of 100 passengers. ",
      "All planes with a capacity of 100 passengers are scheduled for a short-distance flight. ",
      "All planes with a capacity of 100 passengers are produced before 2010. ",
      "Jake32 is either a Boeing-737 plane or a plane in Delta. ",
      "T10 is either a Boeing-737 plane and in Delta, or neither a Boeing-737 plane nor in Delta. "
    ],
    "question": "Jake32 is neither produced before 2010 nor scheduled for a short-distance flight.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nEquippedWithMoreThan300Seats(x) ::: x is equipped with more than 300 seats.\nType(x, y) ::: x is of type y.\nPlane(x) ::: x is a plane.\nCapacityOf100Passengers(x) ::: x has a capacity of 100 passengers.\nScheduledForShortDistanceFlight(x) ::: x is scheduled for a short-distance flight.\nProducedBefore2010(x) ::: x is produced before 2010.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n¬∃x (Plane(x) ∧ EquippedWithMoreThan300Seats(x)) ::: No Boeing-737 plane is equipped with more than 300 seats.\n∀x (Type(x, boeing737) → Type(x, delta)) ::: All planes in Delta are of type Boeing-737.\n∀x (EquippedWithMoreThan300Seats(x) ∨ CapacityOf100Passengers(x)) ::: Planes are either equipped with more than 300 seats or have a capacity of 100 passengers.\n∀x (CapacityOf100Passengers(x) → ScheduledForShortDistanceFlight(x)) ::: All planes with a capacity of 100 passengers are scheduled for a short-distance flight.\n∀x (CapacityOf100Passengers(x) → ProducedBefore2010(x)) ::: All planes with a capacity of 100 passengers are produced before 2010.\n(Type(jake32, boeing737) ∨ Type(jake32, delta)) ::: Jake32 is either a Boeing-737 plane or a plane in Delta.\n(Type(t10, boeing737) ∧ Type(t10, delta)) ⊕ ¬(Type(t10, boeing737) ∨ Type(t10, delta)) ::: T10 is either a Boeing-737 plane and in Delta, or neither a Boeing-737 plane nor in Delta.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬(ProducedBefore2010(jake32) ∨ ScheduledForShortDistanceFlight(jake32)) ::: Jake32 is neither produced before 2010 nor scheduled for a short-distance flight.\n\"\"\""
    ]
  },
  {
    "id": 558,
    "context": [
      "The SAT test is wholly owned and developed by the College Board.",
      "The SAT test is intended to assess student's readiness for college.",
      "The SAT was originally designed not to be aligned with high school curricula. ",
      "Several adjustments were made for the version of the SAT introduced in 2016 to reflect more closely on what students learn in high school. "
    ],
    "question": "Since 2016 the SAT has been better aligned with high school curricula.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nOwns(x, y) ::: x wholly owns and develops y.\nAssess(x, y) ::: x is intended to assess y.\nReadyForCollege(x) ::: x assesses student's readiness for college.\nAlignWith(x, y) ::: x is aligned with y.\nLearn(x, y) ::: x reflects on what students learn in y.\nIntroduced(x, y) ::: x is introduced in year y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nOwns(collegeBoard, SAT) ::: The SAT test is wholly owned and developed by the College Board.\nAssess(SAT, readyForCollege) ::: The SAT test is intended to assess student's readiness for college.\n¬AlignWith(SAT, highSchoolCurricula) ::: The SAT was originally designed not to be aligned with high school curricula.\nIntroduced(SAT, year2016) ∧ AlignWith(SAT, highSchoolCurricula) ∧ Learn(SAT, highSchool) ::: Several adjustments were made for the version of the SAT introduced in 2016 to reflect more closely on what students learn in high school.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nAlignWith(SAT, highSchoolCurricula) ::: Since 2016 the SAT has been better aligned with high school curricula.\n\"\"\""
    ]
  },
  {
    "id": 559,
    "context": [
      "The SAT test is wholly owned and developed by the College Board.",
      "The SAT test is intended to assess student's readiness for college.",
      "The SAT was originally designed not to be aligned with high school curricula. ",
      "Several adjustments were made for the version of the SAT introduced in 2016 to reflect more closely on what students learn in high school. "
    ],
    "question": "The SAT test is owned by the College Board and multiple other third parties.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nOwns(x, y) ::: x owns y.\nDeveloped(x, y) ::: x developed y.\nAssess(x, y) ::: x assesses y.\nReadyForCollege(x) ::: x is readiness for college.\nAlignWith(x, y) ::: x aligns with y.\nLearn(x, y) ::: x learns y.\nIntroduced(x, y) ::: x is introduced in year y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nOwns(collegeBoard, SAT) ∧ Developed(collegeBoard, SAT) ::: The SAT test is wholly owned and developed by the College Board.\nAssess(SAT, readyForCollege) ::: The SAT test is intended to assess student's readiness for college.\n¬AlignWith(SAT, highSchoolCurricula) ::: The SAT was originally designed not to be aligned with high school curricula.\nIntroduced(SAT, year2016) ∧ AlignWith(SAT, highSchoolCurricula) ∧ Learn(students, highSchoolCurricula) ::: Several adjustments were made for the version of the SAT introduced in 2016 to reflect more closely on what students learn in high school.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n∃x (Owns(x, SAT) ∧ x != collegeBoard) ::: The SAT test is owned by the College Board and multiple other third parties.\n\"\"\""
    ]
  },
  {
    "id": 560,
    "context": [
      "The SAT test is wholly owned and developed by the College Board.",
      "The SAT test is intended to assess student's readiness for college.",
      "The SAT was originally designed not to be aligned with high school curricula. ",
      "Several adjustments were made for the version of the SAT introduced in 2016 to reflect more closely on what students learn in high school. "
    ],
    "question": "The SAT test assesses student's math skills.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nOwns(x, y) ::: x wholly owns y.\nDeveloped(x, y) ::: x developed y.\nAssess(x, y) ::: x assesses y.\nReadyForCollege(x) ::: x is intended to assess student's readiness for college.\nAlignWithCurricula(x) ::: x is aligned with high school curricula.\nAdjustmentsMade(x, y) ::: x made adjustments for the version of y.\nLearn(x, y) ::: x learn y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nOwns(collegeBoard, SAT) ∧ Developed(collegeBoard, SAT) ::: The SAT test is wholly owned and developed by the College Board.\nAssess(SAT, readyForCollege) ::: The SAT test is intended to assess student's readiness for college.\n¬AlignWithCurricula(SAT) ::: The SAT was originally designed not to be aligned with high school curricula.\nAdjustmentsMade(SAT, version2016) ∧ Learn(students, highSchoolCurricula) ::: Several adjustments were made for the version of the SAT introduced in 2016 to reflect more closely on what students learn in high school.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nAssess(SAT, mathSkills) ::: The SAT test assesses student's math skills.\n\"\"\""
    ]
  },
  {
    "id": 99,
    "context": [
      "Rafa Nadal was born in Mallorca.",
      "Rafa Nadal is a professional tennis player.",
      "Nadal's win ratio is higher than 80%.",
      "All players in the Big 3 are professionals who have a high win ratio."
    ],
    "question": "Nadal was not born in Mallorca.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nBornIn(x, y) ::: x was born in y.\nProfessional(x) ::: x is a professional.\nHighWinRatio(x) ::: x has a high win ratio.\nBig3(x) ::: x is a player in the Big 3.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nBornIn(rafa, mallorca) ::: Rafa Nadal was born in Mallorca.\nProfessional(rafa) ::: Rafa Nadal is a professional tennis player.\nHighWinRatio(rafa) ∧ (WinRatio(rafa) > 80) ::: Nadal's win ratio is higher than 80%.\n∀x (Big3(x) → (Professional(x) ∧ HighWinRatio(x))) ::: All players in the Big 3 are professionals who have a high win ratio.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬BornIn(rafa, mallorca) ::: Nadal was not born in Mallorca.\n\"\"\""
    ]
  },
  {
    "id": 100,
    "context": [
      "Rafa Nadal was born in Mallorca.",
      "Rafa Nadal is a professional tennis player.",
      "Nadal's win ratio is higher than 80%.",
      "All players in the Big 3 are professionals who have a high win ratio."
    ],
    "question": "Nadal is in the Big 3.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nBornIn(x, y) ::: x was born in y.\nProfessionalPlayer(x) ::: x is a professional tennis player.\nHighWinRatio(x) ::: x has a win ratio higher than 80%.\nBig3(x) ::: x is in the Big 3.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nBornIn(rafa, mallorca) ::: Rafa Nadal was born in Mallorca.\nProfessionalPlayer(rafa) ::: Rafa Nadal is a professional tennis player.\nHighWinRatio(rafa) ::: Nadal's win ratio is higher than 80%.\n∀x ((ProfessionalPlayer(x) ∧ HighWinRatio(x)) → Big3(x)) ::: All players in the Big 3 are professionals who have a high win ratio.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nBig3(rafa) ::: Nadal is in the Big 3.\n\"\"\""
    ]
  },
  {
    "id": 101,
    "context": [
      "Rafa Nadal was born in Mallorca.",
      "Rafa Nadal is a professional tennis player.",
      "Nadal's win ratio is higher than 80%.",
      "All players in the Big 3 are professionals who have a high win ratio."
    ],
    "question": "Nadal is the greatest player of all time.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nBornIn(x, y) ::: x was born in y.\nProfessionalPlayer(x) ::: x is a professional tennis player.\nWinRatio(x, y) ::: x has a win ratio of y.\nIsBig3(x) ::: x is a player in the Big 3.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nBornIn(rafa, mallorca) ::: Rafa Nadal was born in Mallorca.\nProfessionalPlayer(rafa) ::: Rafa Nadal is a professional tennis player.\nWinRatio(rafa, ratio) ∧ ratio > 80% ::: Nadal's win ratio is higher than 80%.\n∀x ((IsBig3(x) → (ProfessionalPlayer(x) ∧ WinRatio(x, high)))) ::: All players in the Big 3 are professionals who have a high win ratio.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n∃x (IsBig3(x) ∧ ∀y (WinRatio(rafa, y) → WinRatio(x, y))) ::: Nadal is the greatest player of all time.\n\"\"\""
    ]
  },
  {
    "id": 735,
    "context": [
      "No cookie is healthy.",
      "All oreos are cookies."
    ],
    "question": "All cookies are delicious.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nHealthy(x) ::: x is healthy.\nCookie(x) ::: x is a cookie.\nOreo(x) ::: x is an Oreo.\nDelicious(x) ::: x is delicious.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Cookie(x) → ¬Healthy(x)) ::: No cookie is healthy.\n∀x (Oreo(x) → Cookie(x)) ::: All oreos are cookies.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n∀x (Cookie(x) → Delicious(x)) ::: All cookies are delicious.\n\"\"\""
    ]
  },
  {
    "id": 787,
    "context": [
      "No animals are plants. ",
      "All humans are animals.",
      "All pupils are human.",
      "All flowers are plants.",
      "If Jack is a human or a flower, then Jack is a human and a flower."
    ],
    "question": "Jack is a pupil.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nAnimal(x) ::: x is an animal.\nPlant(x) ::: x is a plant.\nHuman(x) ::: x is a human.\nPupil(x) ::: x is a pupil.\nFlower(x) ::: x is a flower.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Animal(x) → ¬Plant(x)) ::: No animals are plants.\n∀x (Human(x) → Animal(x)) ::: All humans are animals.\n∀x (Pupil(x) → Human(x)) ::: All pupils are human.\n∀x (Flower(x) → Plant(x)) ::: All flowers are plants.\n(Human(jack) ∨ Flower(jack)) → (Human(jack) ∧ Flower(jack)) ::: If Jack is a human or a flower, then Jack is a human and a flower.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nPupil(jack) ::: Jack is a pupil.\n\"\"\""
    ]
  },
  {
    "id": 788,
    "context": [
      "No animals are plants. ",
      "All humans are animals.",
      "All pupils are human.",
      "All flowers are plants.",
      "If Jack is a human or a flower, then Jack is a human and a flower."
    ],
    "question": "Jack is not a pupil.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nAnimal(x) ::: x is an animal.\nPlant(x) ::: x is a plant.\nHuman(x) ::: x is a human.\nPupil(x) ::: x is a pupil.\nFlower(x) ::: x is a flower.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Animal(x) → ¬Plant(x)) ::: No animals are plants.\n∀x (Human(x) → Animal(x)) ::: All humans are animals.\n∀x (Pupil(x) → Human(x)) ::: All pupils are human.\n∀x (Flower(x) → Plant(x)) ::: All flowers are plants.\n(Human(jack) ∨ Flower(jack)) → (Human(jack) ∧ Flower(jack)) ::: If Jack is a human or a flower, then Jack is a human and a flower.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬Pupil(jack) ::: Jack is not a pupil.\n\"\"\""
    ]
  },
  {
    "id": 789,
    "context": [
      "No animals are plants. ",
      "All humans are animals.",
      "All pupils are human.",
      "All flowers are plants.",
      "If Jack is a human or a flower, then Jack is a human and a flower."
    ],
    "question": "Jack is a plant.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nAnimal(x) ::: x is an animal.\nPlant(x) ::: x is a plant.\nHuman(x) ::: x is a human.\nPupil(x) ::: x is a pupil.\nFlower(x) ::: x is a flower.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Animal(x) → ¬Plant(x)) ::: No animals are plants.\n∀x (Human(x) → Animal(x)) ::: All humans are animals.\n∀x (Pupil(x) → Human(x)) ::: All pupils are human.\n∀x (Flower(x) → Plant(x)) ::: All flowers are plants.\n(Human(jack) ∨ Flower(jack)) → (Human(jack) ∧ Flower(jack)) ::: If Jack is a human or a flower, then Jack is a human and a flower.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nPlant(jack) ::: Jack is a plant.\n\"\"\""
    ]
  },
  {
    "id": 790,
    "context": [
      "No animals are plants. ",
      "All humans are animals.",
      "All pupils are human.",
      "All flowers are plants.",
      "If Jack is a human or a flower, then Jack is a human and a flower."
    ],
    "question": "If Jack is a human, then Jack is not a pupil.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nAnimal(x) ::: x is an animal.\nPlant(x) ::: x is a plant.\nHuman(x) ::: x is a human.\nPupil(x) ::: x is a pupil.\nFlower(x) ::: x is a flower.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Animal(x) → ¬Plant(x)) ::: No animals are plants.\n∀x (Human(x) → Animal(x)) ::: All humans are animals.\n∀x (Pupil(x) → Human(x)) ::: All pupils are human.\n∀x (Flower(x) → Plant(x)) ::: All flowers are plants.\n(Human(jack) ∨ Flower(jack)) → (Human(jack) ∧ Flower(jack)) ::: If Jack is a human or a flower, then Jack is a human and a flower.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nHuman(jack) → ¬Pupil(jack) ::: If Jack is a human, then Jack is not a pupil.\n\"\"\""
    ]
  },
  {
    "id": 1326,
    "context": [
      "No shoes are food. ",
      "All slippers are shoes.",
      "A thing is either food or clothes.",
      "No wearable things are airtight.",
      "All clothes are wearable. ",
      "If a watch is not airtight and clothes, then a watch is either both airtight and clothes, or neither airtight nor clothes."
    ],
    "question": "Watch is a wearable.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nShoes(x) ::: x is a shoe.\nFood(x) ::: x is food.\nSlippers(x) ::: x is a slipper.\nClothes(x) ::: x is clothes.\nWearable(x) ::: x is wearable.\nAirtight(x) ::: x is airtight.\nWatch(x) ::: x is a watch.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Shoes(x) → ¬Food(x)) ::: No shoes are food.\n∀x (Slippers(x) → Shoes(x)) ::: All slippers are shoes.\n∀x ((Food(x) ∨ Clothes(x)) ∧ ¬(Food(x) ∧ Clothes(x))) ::: A thing is either food or clothes.\n∀x (Wearable(x) → ¬Airtight(x)) ::: No wearable things are airtight.\n∀x (Clothes(x) → Wearable(x)) ::: All clothes are wearable.\n¬(¬Airtight(watch) ∧ Clothes(watch)) → (Airtight(watch) ∧ Clothes(watch)) ⊕ ¬(Airtight(watch) ∨ Clothes(watch)) ::: If a watch is not airtight and clothes, then a watch is either both airtight and clothes, or neither airtight nor clothes.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nWearable(watch) ::: Watch is a wearable.\n\"\"\""
    ]
  },
  {
    "id": 1327,
    "context": [
      "No shoes are food. ",
      "All slippers are shoes.",
      "A thing is either food or clothes.",
      "No wearable things are airtight.",
      "All clothes are wearable. ",
      "If a watch is not airtight and clothes, then a watch is either both airtight and clothes, or neither airtight nor clothes."
    ],
    "question": "Watch is a slipper.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nShoes(x) ::: x is a shoe.\nFood(x) ::: x is food.\nSlippers(x) ::: x is a slipper.\nClothes(x) ::: x is clothes.\nWearable(x) ::: x is wearable.\nAirtight(x) ::: x is airtight.\nWatch(x) ::: x is a watch.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Shoes(x) → ¬Food(x)) ::: No shoes are food.\n∀x (Slippers(x) → Shoes(x)) ::: All slippers are shoes.\n∀x (Food(x) ⊕ Clothes(x)) ::: A thing is either food or clothes.\n∀x (Wearable(x) → ¬Airtight(x)) ::: No wearable things are airtight.\n∀x (Clothes(x) → Wearable(x)) ::: All clothes are wearable.\n¬(¬Airtight(watch) ∧ Clothes(watch)) → (Airtight(watch) ∧ Clothes(watch)) ⊕ ¬(Airtight(watch) ∨ Clothes(watch)) ::: If a watch is not airtight and clothes, then a watch is either both airtight and clothes, or neither airtight nor clothes.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬(Watch(watch) ∧ Slippers(watch)) ::: Watch is a slipper.\n\"\"\""
    ]
  },
  {
    "id": 1328,
    "context": [
      "No shoes are food. ",
      "All slippers are shoes.",
      "A thing is either food or clothes.",
      "No wearable things are airtight.",
      "All clothes are wearable. ",
      "If a watch is not airtight and clothes, then a watch is either both airtight and clothes, or neither airtight nor clothes."
    ],
    "question": "Watch is neither airtight nor a slipper.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nFood(x) ::: x is food.\nShoes(x) ::: x is shoes.\nSlippers(x) ::: x is slippers.\nClothes(x) ::: x is clothes.\nWearable(x) ::: x is wearable.\nAirtight(x) ::: x is airtight.\nWatch(x) ::: x is a watch.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Shoes(x) → ¬Food(x)) ::: No shoes are food.\n∀x (Slippers(x) → Shoes(x)) ::: All slippers are shoes.\n∀x (¬Food(x) ↔ Clothes(x)) ::: A thing is either food or clothes.\n∀x (Wearable(x) → ¬Airtight(x)) ::: No wearable things are airtight.\n∀x (Clothes(x) → Wearable(x)) ::: All clothes are wearable.\n¬(¬Airtight(watch) ∧ Clothes(watch)) → (Airtight(watch) ∧ Clothes(watch)) ⊕ ¬(Airtight(watch) ∨ Clothes(watch)) ::: If a watch is not airtight and clothes, then a watch is either both airtight and clothes, or neither airtight nor clothes.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬(Airtight(watch) ∨ Slippers(watch)) ::: Watch is neither airtight nor a slipper.\n\"\"\""
    ]
  },
  {
    "id": 102,
    "context": [
      "An Olympian is a person who trains for an Olympic sport and goes to the Olympics.",
      "Carlos Reyes trains for an Olympic sport.",
      "Carlos Reyes went to the Olympics.",
      "Carlos Reyes is a welterweight.",
      "Heavy weights are not welterweights."
    ],
    "question": "Carlos Reyes is an Olympian.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nOlympian(x) ::: x is an Olympian.\nTrains(x) ::: x trains for an Olympic sport.\nGoesToOlympics(x) ::: x goes to the Olympics.\nWelterweight(x) ::: x is a welterweight.\nHeavyweight(x) ::: x is a heavyweight.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Trains(x) ∧ GoesToOlympics(x) → Olympian(x)) ::: An Olympian is a person who trains for an Olympic sport and goes to the Olympics.\nTrains(carlosReyes) ::: Carlos Reyes trains for an Olympic sport.\nGoesToOlympics(carlosReyes) ::: Carlos Reyes went to the Olympics.\nWelterweight(carlosReyes) ::: Carlos Reyes is a welterweight.\n∀x (Heavyweight(x) → ¬Welterweight(x)) ::: Heavy weights are not welterweights.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nOlympian(carlosReyes) ::: Carlos Reyes is an Olympian.\n\"\"\""
    ]
  },
  {
    "id": 103,
    "context": [
      "An Olympian is a person who trains for an Olympic sport and goes to the Olympics.",
      "Carlos Reyes trains for an Olympic sport.",
      "Carlos Reyes went to the Olympics.",
      "Carlos Reyes is a welterweight.",
      "Heavy weights are not welterweights."
    ],
    "question": "Carlos Reyes is a heavy weight.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nOlympian(x) ::: x is an Olympian.\nTrains(x, y) ::: x trains for y.\nGoesToOlympics(x) ::: x goes to the Olympics.\nWelterweight(x) ::: x is a welterweight.\nHeavyweight(x) ::: x is a heavyweight.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Olympian(x) ↔ (Trains(x, OlympicSport) ∧ GoesToOlympics(x))) ::: An Olympian is a person who trains for an Olympic sport and goes to the Olympics.\nTrains(carlos, OlympicSport) ::: Carlos Reyes trains for an Olympic sport.\nGoesToOlympics(carlos) ::: Carlos Reyes went to the Olympics.\nWelterweight(carlos) ::: Carlos Reyes is a welterweight.\n∀x (Heavyweight(x) → ¬Welterweight(x)) ::: Heavy weights are not welterweights.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nHeavyweight(carlos) ::: Carlos Reyes is a heavy weight.\n\"\"\""
    ]
  },
  {
    "id": 104,
    "context": [
      "An Olympian is a person who trains for an Olympic sport and goes to the Olympics.",
      "Carlos Reyes trains for an Olympic sport.",
      "Carlos Reyes went to the Olympics.",
      "Carlos Reyes is a welterweight.",
      "Heavy weights are not welterweights."
    ],
    "question": "Carlos Reyes won an Olympic medal.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nOlympian(x) ::: x is an Olympian.\nTrains(x) ::: x trains for an Olympic sport.\nGoesToOlympics(x) ::: x goes to the Olympics.\nWelterweight(x) ::: x is a welterweight.\nHeavyweight(x) ::: x is a heavyweight.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Olympian(x) ↔ (Trains(x) ∧ GoesToOlympics(x))) ::: An Olympian is a person who trains for an Olympic sport and goes to the Olympics.\nTrains(carlosReyes) ::: Carlos Reyes trains for an Olympic sport.\nGoesToOlympics(carlosReyes) ::: Carlos Reyes went to the Olympics.\nWelterweight(carlosReyes) ::: Carlos Reyes is a welterweight.\n∀x (Heavyweight(x) → ¬Welterweight(x)) ::: Heavy weights are not welterweights.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n∃x (WonMedal(x) ∧ Author(x, carlosReyes)) ::: Carlos Reyes won an Olympic medal.\n\"\"\""
    ]
  },
  {
    "id": 868,
    "context": [
      "If people have a lot of decorations in their room, they cannot pack and move out of their rooms very easily.",
      "If people have high ambitions and future career goals, then they can pack and move out of their rooms very easily.",
      "If people are big fans of pop bands and singers, then they have a lot of decorations in their room.",
      "All young teenage girls who attend college are big fans of pop bands and singers.",
      "If Sam has high ambitions and future career goals, then Sam is a big fan of pop bands and singers."
    ],
    "question": "Sam is a young teenage girl who attends college.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nDecorations(x) ::: x has a lot of decorations in their room.\nPackMove(x) ::: x can pack and move out of their room very easily.\nAmbitions(x) ::: x has high ambitions.\nGoals(x) ::: x has future career goals.\nPopFan(x) ::: x is a big fan of pop bands and singers.\nAttendCollege(x) ::: x attends college.\nTeenageGirl(x) ::: x is a young teenage girl.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nDecorations(x) → ¬PackMove(x) ::: If people have a lot of decorations in their room, they cannot pack and move out of their rooms very easily.\n(Ambitions(x) ∧ Goals(x)) → PackMove(x) ::: If people have high ambitions and future career goals, then they can pack and move out of their rooms very easily.\nPopFan(x) → Decorations(x) ::: If people are big fans of pop bands and singers, then they have a lot of decorations in their room.\n∀x (TeenageGirl(x) ∧ AttendCollege(x) → PopFan(x)) ::: All young teenage girls who attend college are big fans of pop bands and singers.\n(Ambitions(sam) ∧ Goals(sam)) → PopFan(sam) ::: If Sam has high ambitions and future career goals, then Sam is a big fan of pop bands and singers.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nTeenageGirl(sam) ∧ AttendCollege(sam) ::: Sam is a young teenage girl who attends college.\n\"\"\""
    ]
  },
  {
    "id": 869,
    "context": [
      "If people have a lot of decorations in their room, they cannot pack and move out of their rooms very easily.",
      "If people have high ambitions and future career goals, then they can pack and move out of their rooms very easily.",
      "If people are big fans of pop bands and singers, then they have a lot of decorations in their room.",
      "All young teenage girls who attend college are big fans of pop bands and singers.",
      "If Sam has high ambitions and future career goals, then Sam is a big fan of pop bands and singers."
    ],
    "question": "Sam is not a young teenage girl who attends college.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nDecorations(x) ::: x has a lot of decorations in their room.\nPackMove(x) ::: x can pack and move out of their room very easily.\nAmbitions(x) ::: x has high ambitions.\nCareerGoals(x) ::: x has future career goals.\nPopFan(x) ::: x is a big fan of pop bands and singers.\nAttendCollege(x) ::: x attends college.\nTeenageGirl(x) ::: x is a young teenage girl.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nDecorations(x) → ¬PackMove(x) ::: If people have a lot of decorations in their room, they cannot pack and move out of their rooms very easily.\n(Ambitions(x) ∧ CareerGoals(x)) → PackMove(x) ::: If people have high ambitions and future career goals, then they can pack and move out of their rooms very easily.\nPopFan(x) → Decorations(x) ::: If people are big fans of pop bands and singers, then they have a lot of decorations in their room.\n∀x (TeenageGirl(x) ∧ AttendCollege(x) → PopFan(x)) ::: All young teenage girls who attend college are big fans of pop bands and singers.\n(Ambitions(sam) ∧ CareerGoals(sam)) → PopFan(sam) ::: If Sam has high ambitions and future career goals, then Sam is a big fan of pop bands and singers.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬(TeenageGirl(sam) ∧ AttendCollege(sam)) ::: Sam is not a young teenage girl who attends college.\n\"\"\""
    ]
  },
  {
    "id": 870,
    "context": [
      "If people have a lot of decorations in their room, they cannot pack and move out of their rooms very easily.",
      "If people have high ambitions and future career goals, then they can pack and move out of their rooms very easily.",
      "If people are big fans of pop bands and singers, then they have a lot of decorations in their room.",
      "All young teenage girls who attend college are big fans of pop bands and singers.",
      "If Sam has high ambitions and future career goals, then Sam is a big fan of pop bands and singers."
    ],
    "question": "Sam is a big fan of pop bands and singers.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nDecorations(x) ::: x has a lot of decorations in their room.\nPack(x) ::: x can pack and move out of their room very easily.\nAmbitions(x) ::: x has high ambitions.\nGoals(x) ::: x has future career goals.\nPopFan(x) ::: x is a big fan of pop bands and singers.\nAttendCollege(x) ::: x attends college.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nDecorations(x) → ¬Pack(x) ::: If people have a lot of decorations in their room, they cannot pack and move out of their rooms very easily.\n(Ambitions(x) ∧ Goals(x)) → Pack(x) ::: If people have high ambitions and future career goals, then they can pack and move out of their rooms very easily.\nPopFan(x) → Decorations(x) ::: If people are big fans of pop bands and singers, then they have a lot of decorations in their room.\n∀x (AttendCollege(x) → PopFan(x)) ::: All young teenage girls who attend college are big fans of pop bands and singers.\n(Ambitions(sam) ∧ Goals(sam)) → PopFan(sam) ::: If Sam has high ambitions and future career goals, then Sam is a big fan of pop bands and singers.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nPopFan(sam) ::: Sam is a big fan of pop bands and singers.\n\"\"\""
    ]
  },
  {
    "id": 871,
    "context": [
      "If people have a lot of decorations in their room, they cannot pack and move out of their rooms very easily.",
      "If people have high ambitions and future career goals, then they can pack and move out of their rooms very easily.",
      "If people are big fans of pop bands and singers, then they have a lot of decorations in their room.",
      "All young teenage girls who attend college are big fans of pop bands and singers.",
      "If Sam has high ambitions and future career goals, then Sam is a big fan of pop bands and singers."
    ],
    "question": "Sam neither has high ambitions and future career goals nor is she a young teenage girl who attends college.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nDecorations(x) ::: x has a lot of decorations in their room.\nPackMove(x) ::: x can pack and move out of their room very easily.\nAmbitions(x) ::: x has high ambitions.\nFutureGoals(x) ::: x has future career goals.\nPopFan(x) ::: x is a big fan of pop bands and singers.\nAttendCollege(x) ::: x attends college.\nTeenageGirl(x) ::: x is a young teenage girl.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nDecorations(x) → ¬PackMove(x) ::: If people have a lot of decorations in their room, they cannot pack and move out of their rooms very easily.\n(Ambitions(x) ∧ FutureGoals(x)) → PackMove(x) ::: If people have high ambitions and future career goals, then they can pack and move out of their rooms very easily.\nPopFan(x) → Decorations(x) ::: If people are big fans of pop bands and singers, then they have a lot of decorations in their room.\n∀x (TeenageGirl(x) ∧ AttendCollege(x) → PopFan(x)) ::: All young teenage girls who attend college are big fans of pop bands and singers.\n(Ambitions(sam) ∧ FutureGoals(sam)) → PopFan(sam) ::: If Sam has high ambitions and future career goals, then Sam is a big fan of pop bands and singers.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬(Ambitions(sam) ∧ FutureGoals(sam)) ∧ ¬(TeenageGirl(sam) ∧ AttendCollege(sam)) ::: Sam neither has high ambitions and future career goals nor is she a young teenage girl who attends college.\n\"\"\""
    ]
  },
  {
    "id": 872,
    "context": [
      "If people have a lot of decorations in their room, they cannot pack and move out of their rooms very easily.",
      "If people have high ambitions and future career goals, then they can pack and move out of their rooms very easily.",
      "If people are big fans of pop bands and singers, then they have a lot of decorations in their room.",
      "All young teenage girls who attend college are big fans of pop bands and singers.",
      "If Sam has high ambitions and future career goals, then Sam is a big fan of pop bands and singers."
    ],
    "question": "Sam has high ambitions and future career goals and is a young teenage girl who attends college.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nDecorations(x) ::: x has a lot of decorations in their room.\nPackMove(x) ::: x can pack and move out of their room very easily.\nAmbitions(x) ::: x has high ambitions.\nGoals(x) ::: x has future career goals.\nPopFan(x) ::: x is a big fan of pop bands and singers.\nAttendCollege(x) ::: x attends college.\nTeenageGirl(x) ::: x is a young teenage girl.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Decorations(x) → ¬PackMove(x)) ::: If people have a lot of decorations in their room, they cannot pack and move out of their rooms very easily.\n∀x ((Ambitions(x) ∧ Goals(x)) → PackMove(x)) ::: If people have high ambitions and future career goals, then they can pack and move out of their rooms very easily.\n∀x (PopFan(x) → Decorations(x)) ::: If people are big fans of pop bands and singers, then they have a lot of decorations in their room.\n∀x (TeenageGirl(x) ∧ AttendCollege(x) → PopFan(x)) ::: All young teenage girls who attend college are big fans of pop bands and singers.\n(Ambitions(sam) ∧ Goals(sam)) → PopFan(sam) ::: If Sam has high ambitions and future career goals, then Sam is a big fan of pop bands and singers.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nAmbitions(sam) ∧ Goals(sam) ∧ TeenageGirl(sam) ∧ AttendCollege(sam) ::: Sam has high ambitions and future career goals and is a young teenage girl who attends college.\n\"\"\""
    ]
  },
  {
    "id": 873,
    "context": [
      "If people have a lot of decorations in their room, they cannot pack and move out of their rooms very easily.",
      "If people have high ambitions and future career goals, then they can pack and move out of their rooms very easily.",
      "If people are big fans of pop bands and singers, then they have a lot of decorations in their room.",
      "All young teenage girls who attend college are big fans of pop bands and singers.",
      "If Sam has high ambitions and future career goals, then Sam is a big fan of pop bands and singers."
    ],
    "question": "Sam has high ambitions and future career goals and is a young teenage girl who attends college.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nDecorations(x) ::: x has a lot of decorations in their room.\nPackMove(x) ::: x can pack and move out of their room very easily.\nAmbitions(x) ::: x has high ambitions.\nGoals(x) ::: x has future career goals.\nPopFan(x) ::: x is a big fan of pop bands and singers.\nAttendCollege(x) ::: x attends college.\nTeenageGirl(x) ::: x is a young teenage girl.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Decorations(x) → ¬PackMove(x)) ::: If people have a lot of decorations in their room, they cannot pack and move out of their rooms very easily.\n∀x ((Ambitions(x) ∧ Goals(x)) → PackMove(x)) ::: If people have high ambitions and future career goals, then they can pack and move out of their rooms very easily.\n∀x (PopFan(x) → Decorations(x)) ::: If people are big fans of pop bands and singers, then they have a lot of decorations in their room.\n∀x (TeenageGirl(x) ∧ AttendCollege(x) → PopFan(x)) ::: All young teenage girls who attend college are big fans of pop bands and singers.\n(Ambitions(sam) ∧ Goals(sam)) → PopFan(sam) ::: If Sam has high ambitions and future career goals, then Sam is a big fan of pop bands and singers.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nAmbitions(sam) ∧ Goals(sam) ∧ TeenageGirl(sam) ∧ AttendCollege(sam) ::: Sam has high ambitions and future career goals and is a young teenage girl who attends college.\n\"\"\""
    ]
  },
  {
    "id": 874,
    "context": [
      "If people have a lot of decorations in their room, they cannot pack and move out of their rooms very easily.",
      "If people have high ambitions and future career goals, then they can pack and move out of their rooms very easily.",
      "If people are big fans of pop bands and singers, then they have a lot of decorations in their room.",
      "All young teenage girls who attend college are big fans of pop bands and singers.",
      "If Sam has high ambitions and future career goals, then Sam is a big fan of pop bands and singers."
    ],
    "question": "If Sam is a young teenage girl who attends college, then Sam either does not have high ambitions and future career goals or is a big fan of pop bands and singers.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nDecorations(x) ::: x has a lot of decorations in their room.\nPack(x) ::: x can pack and move out of their room very easily.\nAmbitions(x) ::: x has high ambitions and future career goals.\nPopFan(x) ::: x is a big fan of pop bands and singers.\nAttendCollege(x) ::: x attends college.\nTeenageGirl(x) ::: x is a young teenage girl.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nDecorations(x) → ¬Pack(x) ::: If people have a lot of decorations in their room, they cannot pack and move out of their rooms very easily.\nAmbitions(x) ∧ FutureCareerGoals(x) → Pack(x) ::: If people have high ambitions and future career goals, then they can pack and move out of their rooms very easily.\nPopFan(x) → Decorations(x) ::: If people are big fans of pop bands and singers, then they have a lot of decorations in their room.\n∀x (TeenageGirl(x) ∧ AttendCollege(x) → PopFan(x)) ::: All young teenage girls who attend college are big fans of pop bands and singers.\nAmbitions(sam) ∧ FutureCareerGoals(sam) → PopFan(sam) ::: If Sam has high ambitions and future career goals, then Sam is a big fan of pop bands and singers.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n(TeenageGirl(sam) ∧ AttendCollege(sam)) → (¬Ambitions(sam) ∧ ¬FutureCareerGoals(sam)) ∨ PopFan(sam) ::: If Sam is a young teenage girl who attends college, then Sam either does not have high ambitions and future career goals or is a big fan of pop bands and singers.\n\"\"\""
    ]
  },
  {
    "id": 875,
    "context": [
      "If people have a lot of decorations in their room, they cannot pack and move out of their rooms very easily.",
      "If people have high ambitions and future career goals, then they can pack and move out of their rooms very easily.",
      "If people are big fans of pop bands and singers, then they have a lot of decorations in their room.",
      "All young teenage girls who attend college are big fans of pop bands and singers.",
      "If Sam has high ambitions and future career goals, then Sam is a big fan of pop bands and singers."
    ],
    "question": "If Sam has high ambitions and future career goals and is a young teenage girl who attends college, then Sam either does not have high ambitions and future career goals or is not a young teenage girl who attends college.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nDecorations(x) ::: x has a lot of decorations in their room.\nPackMove(x) ::: x can pack and move out of their room very easily.\nAmbitions(x) ::: x has high ambitions and future career goals.\nPopFan(x) ::: x is a big fan of pop bands and singers.\nAttendCollege(x) ::: x attends college.\nTeenageGirl(x) ::: x is a young teenage girl.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Decorations(x) → ¬PackMove(x)) ::: If people have a lot of decorations in their room, they cannot pack and move out of their rooms very easily.\n∀x (Ambitions(x) ∧ FutureCareerGoals(x) → PackMove(x)) ::: If people have high ambitions and future career goals, then they can pack and move out of their rooms very easily.\n∀x (PopFan(x) → Decorations(x)) ::: If people are big fans of pop bands and singers, then they have a lot of decorations in their room.\n∀x (TeenageGirl(x) ∧ AttendCollege(x) → PopFan(x)) ::: All young teenage girls who attend college are big fans of pop bands and singers.\nAmbitions(sam) ∧ FutureCareerGoals(sam) → PopFan(sam) ::: If Sam has high ambitions and future career goals, then Sam is a big fan of pop bands and singers.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n(Ambitions(sam) ∧ FutureCareerGoals(sam) ∧ TeenageGirl(sam) ∧ AttendCollege(sam)) → (¬Ambitions(sam) ∨ ¬TeenageGirl(sam) ∨ ¬AttendCollege(sam)) ::: If Sam has high ambitions and future career goals and is a young teenage girl who attends college, then Sam either does not have high ambitions and future career goals or is not a young teenage girl who attends college.\n\"\"\""
    ]
  },
  {
    "id": 876,
    "context": [
      "If people have a lot of decorations in their room, they cannot pack and move out of their rooms very easily.",
      "If people have high ambitions and future career goals, then they can pack and move out of their rooms very easily.",
      "If people are big fans of pop bands and singers, then they have a lot of decorations in their room.",
      "All young teenage girls who attend college are big fans of pop bands and singers.",
      "If Sam has high ambitions and future career goals, then Sam is a big fan of pop bands and singers."
    ],
    "question": "If Sam has high ambitions and future career goals, then Sam is a young teenage girl who attends college.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nDecorations(x) ::: x has a lot of decorations in their room.\nPackMove(x) ::: x can pack and move out of their room very easily.\nAmbitions(x) ::: x has high ambitions.\nGoals(x) ::: x has future career goals.\nPopFan(x) ::: x is a big fan of pop bands and singers.\nAttendCollege(x) ::: x is a young teenage girl who attends college.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Decorations(x) → ¬PackMove(x)) ::: If people have a lot of decorations in their room, they cannot pack and move out of their rooms very easily.\n∀x ((Ambitions(x) ∧ Goals(x)) → PackMove(x)) ::: If people have high ambitions and future career goals, then they can pack and move out of their rooms very easily.\n∀x (PopFan(x) → Decorations(x)) ::: If people are big fans of pop bands and singers, then they have a lot of decorations in their room.\n∀x (AttendCollege(x) → PopFan(x)) ::: All young teenage girls who attend college are big fans of pop bands and singers.\n(Ambitions(sam) ∧ Goals(sam)) → PopFan(sam) ::: If Sam has high ambitions and future career goals, then Sam is a big fan of pop bands and singers.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n(Ambitions(sam) ∧ Goals(sam)) → (AttendCollege(sam)) ::: If Sam has high ambitions and future career goals, then Sam is a young teenage girl who attends college.\n\"\"\""
    ]
  },
  {
    "id": 527,
    "context": [
      "A student who loves shrieking will be punished.",
      "If a person swears, then he is a student.",
      "If someone is a teacher, then Bob will talk to him.",
      "All gentlemen are in a suit.",
      "All teachers are men.",
      "There is a teacher.",
      "If someone is not a gentlemen, then he is not nice.",
      "Willy is nice.",
      "Bob loves shrieking and swearing."
    ],
    "question": "Willy is in a suit.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nStudent(x) ::: x is a student.\nLove(x, y) ::: x loves y.\nPunished(x) ::: x will be punished.\nSwears(x) ::: x swears.\nTeacher(x) ::: x is a teacher.\nTalkTo(x, y) ::: Bob will talk to x.\nGentlemen(x) ::: x is a gentleman.\nSuit(x) ::: x is in a suit.\nMen(x) ::: x is a man.\nNice(x) ::: x is nice.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Student(x) ∧ Love(x, shrieking) → Punished(x)) ::: A student who loves shrieking will be punished.\n∀x (Swears(x) → Student(x)) ::: If a person swears, then he is a student.\n∀x (Teacher(x) → TalkTo(bob, x)) ::: If someone is a teacher, then Bob will talk to him.\n∀x (Gentlemen(x) → Suit(x)) ::: All gentlemen are in a suit.\n∀x (Teacher(x) → Men(x)) ::: All teachers are men.\n∃x Teacher(x) ::: There is a teacher.\n∀x (¬Gentlemen(x) → ¬Nice(x)) ::: If someone is not a gentlemen, then he is not nice.\nNice(willy) ::: Willy is nice.\nLove(bob, shrieking) ∧ Swears(bob) ::: Bob loves shrieking and swearing.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nSuit(willy) ::: Willy is in a suit.\n\"\"\""
    ]
  },
  {
    "id": 528,
    "context": [
      "A student who loves shrieking will be punished.",
      "If a person swears, then he is a student.",
      "If someone is a teacher, then Bob will talk to him.",
      "All gentlemen are in a suit.",
      "All teachers are men.",
      "There is a teacher.",
      "If someone is not a gentlemen, then he is not nice.",
      "Willy is nice.",
      "Bob loves shrieking and swearing."
    ],
    "question": "Bob will be not punished.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nStudent(x) ::: x is a student.\nLove(x, y) ::: x loves y.\nPunished(x) ::: x will be punished.\nSwear(x) ::: x swears.\nTeacher(x) ::: x is a teacher.\nTalkTo(x, y) ::: Bob will talk to x.\nGentlemen(x) ::: x is a gentleman.\nSuit(x) ::: x is in a suit.\nMen(x) ::: x is a man.\nNice(x) ::: x is nice.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Student(x) ∧ Love(x, shrieking) → Punished(x)) ::: A student who loves shrieking will be punished.\n∀x (Swear(x) → Student(x)) ::: If a person swears, then he is a student.\n∀x (Teacher(x) → TalkTo(bob, x)) ::: If someone is a teacher, then Bob will talk to him.\n∀x (Gentlemen(x) → Suit(x)) ::: All gentlemen are in a suit.\n∀x (Teacher(x) → Men(x)) ::: All teachers are men.\n∃x Teacher(x) ::: There is a teacher.\n∀x (¬Gentlemen(x) → ¬Nice(x)) ::: If someone is not a gentlemen, then he is not nice.\nNice(willy) ::: Willy is nice.\nLove(bob, shrieking) ∧ Love(bob, swearing) ::: Bob loves shrieking and swearing.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬Punished(bob) ::: Bob will not be punished.\n\"\"\""
    ]
  },
  {
    "id": 529,
    "context": [
      "A student who loves shrieking will be punished.",
      "If a person swears, then he is a student.",
      "If someone is a teacher, then Bob will talk to him.",
      "All gentlemen are in a suit.",
      "All teachers are men.",
      "There is a teacher.",
      "If someone is not a gentlemen, then he is not nice.",
      "Willy is nice.",
      "Bob loves shrieking and swearing."
    ],
    "question": "There is a man that Bob will talk to.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nStudent(x) ::: x is a student.\nLove(x, y) ::: x loves y.\nPunished(x) ::: x will be punished.\nSwear(x) ::: x swears.\nTeacher(x) ::: x is a teacher.\nTalkTo(x, y) ::: Bob will talk to x.\nGentleman(x) ::: x is a gentleman.\nSuit(x) ::: x is in a suit.\nMan(x) ::: x is a man.\nNice(x) ::: x is nice.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Student(x) ∧ Love(x, shrieking) → Punished(x)) ::: A student who loves shrieking will be punished.\n∀x (Swear(x) → Student(x)) ::: If a person swears, then he is a student.\n∀x (Teacher(x) → TalkTo(bob, x)) ::: If someone is a teacher, then Bob will talk to him.\n∀x (Gentleman(x) → Suit(x)) ::: All gentlemen are in a suit.\n∀x (Teacher(x) → Man(x)) ::: All teachers are men.\n∃x Teacher(x) ::: There is a teacher.\n¬(Gentleman(x) → Nice(x)) ::: If someone is not a gentlemen, then he is not nice.\nNice(willy) ::: Willy is nice.\nLove(bob, shrieking) ∧ Swear(bob) ::: Bob loves shrieking and swearing.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n∃x (Man(x) ∧ TalkTo(bob, x)) ::: There is a man that Bob will talk to.\n\"\"\""
    ]
  },
  {
    "id": 142,
    "context": [
      "Quincy McDuffie is an American professional wide receiver in Canadian Football.",
      "People who can catch balls are good wide receivers. ",
      "Quincy McDuffie can catch many footballs easily.",
      "Good wide receivers play professionally.",
      "Good wide receivers can catch with both their left and right hand.",
      "All footballs are balls."
    ],
    "question": "Quincy McDuffie is a good wide receiver.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nAmerican(x) ::: x is an American person.\nWideReceiver(x) ::: x is a wide receiver.\nCatch(x) ::: x can catch balls.\nProfessionalPlayer(x) ::: x is a professional player.\nPlay(x, y) ::: x plays y.\nCatchWithBothHands(x) ::: x can catch with both their left and right hand.\nBall(x) ::: x is a ball.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nAmerican(quincy) ∧ WideReceiver(quincy) ∧ Play(quincy, canadianFootball) ::: Quincy McDuffie is an American professional wide receiver in Canadian Football.\n∀x (Catch(x) → WideReceiver(x)) ::: People who can catch balls are good wide receivers.\nCatch(quincy, manyFootballs) ::: Quincy McDuffie can catch many footballs easily.\n∀x (WideReceiver(x) → ProfessionalPlayer(x)) ::: Good wide receivers play professionally.\n∀x (WideReceiver(x) → CatchWithBothHands(x)) ::: Good wide receivers can catch with both their left and right hand.\n∀x (Football(x) → Ball(x)) ::: All footballs are balls.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nWideReceiver(quincy) ::: Quincy McDuffie is a good wide receiver.\n\"\"\""
    ]
  },
  {
    "id": 143,
    "context": [
      "Quincy McDuffie is an American professional wide receiver in Canadian Football.",
      "People who can catch balls are good wide receivers. ",
      "Quincy McDuffie can catch many footballs easily.",
      "Good wide receivers play professionally.",
      "Good wide receivers can catch with both their left and right hand.",
      "All footballs are balls."
    ],
    "question": "Quincy McDuffie can catch every ball.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nAmerican(x) ::: x is an American person.\nWideReceiver(x) ::: x is a wide receiver.\nCatch(x, y) ::: x can catch y.\nGood(x) ::: x is good.\nPlayProfessionally(x) ::: x plays professionally.\nCatchWithBothHands(x) ::: x can catch with both left and right hand.\nBall(x) ::: x is a ball.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nAmerican(quincy) ∧ WideReceiver(quincy) ∧ PlayProfessionally(quincy) ::: Quincy McDuffie is an American professional wide receiver in Canadian Football.\n∀x (Catch(x, ball) → Good(WideReceiver(x))) ::: People who can catch balls are good wide receivers.\nCatch(quincy, manyFootballs) ::: Quincy McDuffie can catch many footballs easily.\n∀x (Good(WideReceiver(x)) → PlayProfessionally(x)) ::: Good wide receivers play professionally.\n∀x (Good(WideReceiver(x)) → CatchWithBothHands(x)) ::: Good wide receivers can catch with both their left and right hand.\n∀x (Ball(x)) ::: All footballs are balls.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n∀x (Ball(x) → Catch(quincy, x)) ::: Quincy McDuffie can catch every ball.\n\"\"\""
    ]
  },
  {
    "id": 144,
    "context": [
      "Quincy McDuffie is an American professional wide receiver in Canadian Football.",
      "People who can catch balls are good wide receivers. ",
      "Quincy McDuffie can catch many footballs easily.",
      "Good wide receivers play professionally.",
      "Good wide receivers can catch with both their left and right hand.",
      "All footballs are balls."
    ],
    "question": "Professional wide receivers are good at catching balls.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nAmerican(x) ::: x is an American person.\nWideReceiver(x) ::: x is a wide receiver.\nCanadianFootball(x) ::: x is a Canadian Football player.\nCatch(x, y) ::: x can catch y.\nGood(x) ::: x is good.\nPlayProfessionally(x) ::: x plays professionally.\nCatchWithBothHands(x) ::: x can catch with both left and right hand.\nBall(x) ::: x is a ball.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nAmerican(quincy) ∧ WideReceiver(quincy) ∧ CanadianFootball(quincy) ::: Quincy McDuffie is an American professional wide receiver in Canadian Football.\n∀x (Catch(x, ball) → Good(WideReceiver(x))) ::: People who can catch balls are good wide receivers.\nCatch(quincy, manyFootballs) ∧ Easily(quincy, manyFootballs) ::: Quincy McDuffie can catch many footballs easily.\n∀x (Good(WideReceiver(x)) → PlayProfessionally(x)) ::: Good wide receivers play professionally.\n∀x (Good(WideReceiver(x)) → CatchWithBothHands(x)) ::: Good wide receivers can catch with both their left and right hand.\n∀x (Football(x) → Ball(x)) ::: All footballs are balls.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n∀x (WideReceiver(x) → (∀y (Ball(y) → Catch(x, y)))) ::: Professional wide receivers are good at catching balls.\n\"\"\""
    ]
  },
  {
    "id": 14,
    "context": [
      "Boves is a railway station located in France. ",
      "The preceding station of Boves is Longueau.",
      "The preceding station of Dommartin is Boves.",
      "France is a European country.",
      "Dommartin is situated on the Paris–Lille railway. ",
      "Any two contiguous stations are on the same railway.",
      "Boves is served by regional TER Hauts-de-France trains.",
      "If A is located in B and B is located in C, then A is located in C.",
      "If A precedes B and B preceds C, than A preceds C."
    ],
    "question": "Longueau is situated on the Paris–Lille railway.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nStation(x) ::: x is a railway station.\nLocatedIn(x, y) ::: x is located in y.\nPrecedes(x, y) ::: x precedes y.\nOnRailway(x, y) ::: x is on the railway y.\nCountry(x) ::: x is a country.\nEuropean(x) ::: x is a European country.\nServedBy(x, y) ::: x is served by y.\nTrain(x) ::: x is a train.\nContiguous(x, y) ::: x and y are contiguous stations.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nStation(boves) ∧ LocatedIn(boves, france) ::: Boves is a railway station located in France.\nPrecedes(boves, longueau) ::: The preceding station of Boves is Longueau.\nPrecedes(dommartin, boves) ::: The preceding station of Dommartin is Boves.\nCountry(france) ∧ European(france) ::: France is a European country.\nLocatedIn(dommartin, parisLilleRailway) ::: Dommartin is situated on the Paris–Lille railway.\n∀x ∀y ((Contiguous(x, y) ∧ Station(x) ∧ Station(y)) → OnRailway(x, z) ∧ OnRailway(y, z)) ::: Any two contiguous stations are on the same railway.\nServedBy(boves, TERHautsDeFrance) ::: Boves is served by regional TER Hauts-de-France trains.\n∀x ∀y ∀z ((LocatedIn(x, y) ∧ LocatedIn(y, z)) → LocatedIn(x, z)) ::: If A is located in B and B is located in C, then A is located in C.\n∀x ∀y ∀z ((Precedes(x, y) ∧ Precedes(y, z)) → Precedes(x, z)) ::: If A precedes B and B preceds C, than A preceds C.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nLocatedIn(longueau, parisLilleRailway) ::: Longueau is situated on the Paris–Lille railway.\n\"\"\""
    ]
  },
  {
    "id": 15,
    "context": [
      "Boves is a railway station located in France. ",
      "The preceding station of Boves is Longueau.",
      "The preceding station of Dommartin is Boves.",
      "France is a European country.",
      "Dommartin is situated on the Paris–Lille railway. ",
      "Any two contiguous stations are on the same railway.",
      "Boves is served by regional TER Hauts-de-France trains.",
      "If A is located in B and B is located in C, then A is located in C.",
      "If A precedes B and B preceds C, than A preceds C."
    ],
    "question": "Boves is not in Europe.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nStation(x) ::: x is a railway station.\nLocatedIn(x, y) ::: x is located in y.\nPrecedes(x, y) ::: x precedes y.\nOnRailway(x, y) ::: x is on the railway y.\nCountry(x) ::: x is a country.\nEuropean(x) ::: x is a European country.\nServedBy(x, y) ::: x is served by y.\nTrain(x) ::: x is a train.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nStation(boves) ∧ LocatedIn(boves, france) ::: Boves is a railway station located in France.\nPrecedes(boves, longueau) ::: The preceding station of Boves is Longueau.\nPrecedes(dommartin, boves) ::: The preceding station of Dommartin is Boves.\nCountry(france) ∧ European(france) ::: France is a European country.\nLocatedIn(dommartin, parisLilleRailway) ::: Dommartin is situated on the Paris–Lille railway.\n∀x ∀y ((Station(x) ∧ Station(y) ∧ Precedes(x, y)) → OnRailway(x, y)) ::: Any two contiguous stations are on the same railway.\nServedBy(boves, TERHautsDeFrance) ::: Boves is served by regional TER Hauts-de-France trains.\n∀x ∀y ∀z ((LocatedIn(x, y) ∧ LocatedIn(y, z)) → LocatedIn(x, z)) ::: If A is located in B and B is located in C, then A is located in C.\n∀x ∀y ∀z ((Precedes(x, y) ∧ Precedes(y, z)) → Precedes(x, z)) ::: If A precedes B and B preceds C, than A preceds C.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬European(boves) ::: Boves is not in Europe.\n\"\"\""
    ]
  },
  {
    "id": 16,
    "context": [
      "Boves is a railway station located in France. ",
      "The preceding station of Boves is Longueau.",
      "The preceding station of Dommartin is Boves.",
      "France is a European country.",
      "Dommartin is situated on the Paris–Lille railway. ",
      "Any two contiguous stations are on the same railway.",
      "Boves is served by regional TER Hauts-de-France trains.",
      "If A is located in B and B is located in C, then A is located in C.",
      "If A precedes B and B preceds C, than A preceds C."
    ],
    "question": "Longueau is served by regional TER Hauts-de-France trains.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nStation(x) ::: x is a railway station.\nLocatedIn(x, y) ::: x is located in y.\nPrecedes(x, y) ::: x precedes y.\nOnRailway(x, y) ::: x is on the railway y.\nCountry(x) ::: x is a country.\nContiguous(x, y) ::: x and y are contiguous stations.\nServedBy(x, y) ::: x is served by regional trains y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nStation(boves) ∧ LocatedIn(boves, france) ::: Boves is a railway station located in France.\nPrecedes(boves, longueau) ::: The preceding station of Boves is Longueau.\nPrecedes(dommartin, boves) ::: The preceding station of Dommartin is Boves.\nCountry(france) ∧ LocatedIn(dommartin, parisLilleRailway) ::: France is a European country. Dommartin is situated on the Paris–Lille railway.\n∀x ∀y ((Contiguous(x, y) ∧ OnRailway(x, z) ∧ OnRailway(y, z)) → OnRailway(x, y)) ::: Any two contiguous stations are on the same railway.\nServedBy(boves, TERHautsDeFrance) ::: Boves is served by regional TER Hauts-de-France trains.\n∀x ∀y ∀z ((LocatedIn(x, y) ∧ LocatedIn(y, z)) → LocatedIn(x, z)) ::: If A is located in B and B is located in C, then A is located in C.\n∀x ∀y ∀z ((Precedes(x, y) ∧ Precedes(y, z)) → Precedes(x, z)) ::: If A precedes B and B preceds C, than A preceds C.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nServedBy(longueau, TERHautsDeFrance) ::: Longueau is served by regional TER Hauts-de-France trains.\n\"\"\""
    ]
  },
  {
    "id": 310,
    "context": [
      "Edwin Smith was a New Zealand Rower from Auckland.",
      "Edwin Smith was also known as Ted Smith.",
      "Edwin Smith went to Rose Road Primary School, located in Grey Lynn.",
      "Edwin Smith was a sergeant who served with the New Zealand 24th battalion in Italy and Egypt.",
      "Broadway Sheetmetals was a buisness that was ran and owned by Edwin Smith, who was a sheetmetal worker."
    ],
    "question": "Ted Smith was a sergeant.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nNewZealandRower(x) ::: x is a New Zealand Rower.\nFrom(x, y) ::: x is from y.\nAlsoKnownAs(x, y) ::: x is also known as y.\nWentTo(x, y) ::: x went to y.\nLocatedIn(x, y) ::: x is located in y.\nSergeant(x) ::: x is a sergeant.\nServedWith(x, y) ::: x served with y.\nOwnedBy(x, y) ::: x is owned by y.\nRanBy(x, y) ::: x is ran by y.\nWorker(x) ::: x is a worker.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nNewZealandRower(edwin) ∧ From(edwin, auckland) ::: Edwin Smith was a New Zealand Rower from Auckland.\nAlsoKnownAs(edwin, ted) ::: Edwin Smith was also known as Ted Smith.\nWentTo(edwin, roseRoadPrimarySchool) ∧ LocatedIn(roseRoadPrimarySchool, greyLynn) ::: Edwin Smith went to Rose Road Primary School, located in Grey Lynn.\nSergeant(edwin) ∧ ServedWith(edwin, newZealand24thBattalion) ∧ ServedWith(edwin, italy) ∧ ServedWith(edwin, egypt) ::: Edwin Smith was a sergeant who served with the New Zealand 24th battalion in Italy and Egypt.\nWorker(edwin) ∧ RanBy(broadwaySheetmetals, edwin) ∧ OwnedBy(edwin, broadwaySheetmetals) ::: Broadway Sheetmetals was a business that was ran and owned by Edwin Smith, who was a sheetmetal worker.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nSergeant(ted) ::: Ted Smith was a sergeant.\n\"\"\""
    ]
  },
  {
    "id": 311,
    "context": [
      "Edwin Smith was a New Zealand Rower from Auckland.",
      "Edwin Smith was also known as Ted Smith.",
      "Edwin Smith went to Rose Road Primary School, located in Grey Lynn.",
      "Edwin Smith was a sergeant who served with the New Zealand 24th battalion in Italy and Egypt.",
      "Broadway Sheetmetals was a buisness that was ran and owned by Edwin Smith, who was a sheetmetal worker."
    ],
    "question": "There are no rowers that own a buisness.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nRower(x) ::: x is a rower.\nKnownAs(x, y) ::: x is known as y.\nWentTo(x, y) ::: x went to school at y.\nSergeant(x) ::: x is a sergeant.\nServedWith(x, y, z) ::: x served with y in z.\nOwnedBy(x, y) ::: x is owned by y.\nRanBy(x, y) ::: x is ran by y.\nWorker(x) ::: x is a worker.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nRower(edwin) ∧ From(edwin, auckland) ∧ From(auckland, newZealand) ::: Edwin Smith was a New Zealand Rower from Auckland.\nKnownAs(edwin, ted) ::: Edwin Smith was also known as Ted Smith.\nWentTo(edwin, roseRoadPrimarySchool) ∧ LocatedIn(roseRoadPrimarySchool, greyLynn) ::: Edwin Smith went to Rose Road Primary School, located in Grey Lynn.\nSergeant(edwin) ∧ ServedWith(edwin, newZealand24thBattalion, italy) ∧ ServedWith(edwin, newZealand24thBattalion, egypt) ::: Edwin Smith was a sergeant who served with the New Zealand 24th battalion in Italy and Egypt.\nWorker(edwin) ∧ RanBy(broadwaySheetmetals, edwin) ∧ OwnedBy(edwin, broadwaySheetmetals) ::: Broadway Sheetmetals was a business that was ran and owned by Edwin Smith, who was a sheetmetal worker.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬∃x (Rower(x) ∧ ∃y (OwnedBy(y, x))) ::: There are no rowers that own a business.\n\"\"\""
    ]
  },
  {
    "id": 312,
    "context": [
      "Edwin Smith was a New Zealand Rower from Auckland.",
      "Edwin Smith was also known as Ted Smith.",
      "Edwin Smith went to Rose Road Primary School, located in Grey Lynn.",
      "Edwin Smith was a sergeant who served with the New Zealand 24th battalion in Italy and Egypt.",
      "Broadway Sheetmetals was a buisness that was ran and owned by Edwin Smith, who was a sheetmetal worker."
    ],
    "question": "No sergeants are from Auckland.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nRower(x) ::: x is a rower.\nFrom(x, y) ::: x is from y.\nKnownAs(x, y) ::: x is known as y.\nWentToSchool(x, y) ::: x went to school y.\nLocatedIn(x, y) ::: x is located in y.\nSergeant(x) ::: x is a sergeant.\nServedWith(x, y, z) ::: x served with y in z.\nOwnedBy(x, y) ::: x is owned by y.\nRanBy(x, y) ::: x is ran by y.\nWorker(x) ::: x is a worker.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nRower(edwin) ∧ From(edwin, auckland) ::: Edwin Smith was a New Zealand Rower from Auckland.\nKnownAs(edwin, ted) ::: Edwin Smith was also known as Ted Smith.\nWentToSchool(edwin, roseRoadPrimarySchool) ∧ LocatedIn(roseRoadPrimarySchool, greyLynn) ::: Edwin Smith went to Rose Road Primary School, located in Grey Lynn.\nSergeant(edwin) ∧ ServedWith(edwin, newZealand24thBattalion, italy) ∧ ServedWith(edwin, newZealand24thBattalion, egypt) ::: Edwin Smith was a sergeant who served with the New Zealand 24th battalion in Italy and Egypt.\nWorker(edwin) ∧ RanBy(broadwaySheetmetals, edwin) ∧ OwnedBy(edwin, broadwaySheetmetals) ::: Broadway Sheetmetals was a business that was ran and owned by Edwin Smith, who was a sheetmetal worker.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬∃x (Sergeant(x) ∧ From(x, auckland)) ::: No sergeants are from Auckland.\n\"\"\""
    ]
  },
  {
    "id": 313,
    "context": [
      "Edwin Smith was a New Zealand Rower from Auckland.",
      "Edwin Smith was also known as Ted Smith.",
      "Edwin Smith went to Rose Road Primary School, located in Grey Lynn.",
      "Edwin Smith was a sergeant who served with the New Zealand 24th battalion in Italy and Egypt.",
      "Broadway Sheetmetals was a buisness that was ran and owned by Edwin Smith, who was a sheetmetal worker."
    ],
    "question": "No buisness owner has served in Egypt.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nRower(x) ::: x is a rower.\nFrom(x, y) ::: x is from y.\nKnownAs(x, y) ::: x is known as y.\nWentTo(x, y) ::: x went to y.\nLocatedIn(x, y) ::: x is located in y.\nSergeant(x) ::: x is a sergeant.\nServedWith(x, y) ::: x served with y.\nRan(x, y) ::: x ran y.\nOwnedBy(x, y) ::: x is owned by y.\nWorker(x) ::: x is a worker.\nBusiness(x) ::: x is a business.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nFrom(edwin, newZealand) ∧ Rower(edwin) ∧ From(auckland, newZealand) ::: Edwin Smith was a New Zealand Rower from Auckland.\nKnownAs(edwin, ted) ::: Edwin Smith was also known as Ted Smith.\nWentTo(edwin, roseRoadPrimarySchool) ∧ LocatedIn(roseRoadPrimarySchool, greyLynn) ::: Edwin Smith went to Rose Road Primary School, located in Grey Lynn.\nSergeant(edwin) ∧ ServedWith(edwin, newZealand24thBattalion) ∧ ServedWith(edwin, italy) ∧ ServedWith(edwin, egypt) ::: Edwin Smith was a sergeant who served with the New Zealand 24th battalion in Italy and Egypt.\nBusiness(broadwaySheetmetals) ∧ Ran(broadwaySheetmetals, edwin) ∧ OwnedBy(broadwaySheetmetals, edwin) ∧ Worker(edwin, sheetmetal) ::: Broadway Sheetmetals was a business that was ran and owned by Edwin Smith, who was a sheetmetal worker.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬∃x (BusinessOwner(x) ∧ ServedWith(x, egypt)) ::: No business owner has served in Egypt.\n\"\"\""
    ]
  },
  {
    "id": 506,
    "context": [
      "A werewolf is a human that can turn into a wolf.",
      "A werewolf has been scratched or bitten by another werewolf.",
      "If someone has been scratched or bitten, they have been attacked."
    ],
    "question": "All humans are werewolves.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nHuman(x) ::: x is a human.\nWerewolf(x) ::: x is a werewolf.\nTurnIntoWolf(x) ::: x can turn into a wolf.\nScratched(x) ::: x has been scratched.\nBitten(x) ::: x has been bitten.\nAttacked(x) ::: x has been attacked.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Werewolf(x) → (Human(x) ∧ TurnIntoWolf(x))) ::: A werewolf is a human that can turn into a wolf.\n∃x (Werewolf(x) ∧ (Scratched(x) ∨ Bitten(x))) ::: A werewolf has been scratched or bitten by another werewolf.\n∀x ((Scratched(x) ∨ Bitten(x)) → Attacked(x)) ::: If someone has been scratched or bitten, they have been attacked.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n∀x (Human(x) → Werewolf(x)) ::: All humans are werewolves.\n\"\"\""
    ]
  },
  {
    "id": 507,
    "context": [
      "A werewolf is a human that can turn into a wolf.",
      "A werewolf has been scratched or bitten by another werewolf.",
      "If someone has been scratched or bitten, they have been attacked."
    ],
    "question": "A werewolf is a wolf.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nWerewolf(x) ::: x is a werewolf.\nHuman(x) ::: x is a human.\nWolf(x) ::: x is a wolf.\nTurnInto(x, y) ::: x can turn into y.\nScratched(x) ::: x has been scratched.\nBitten(x) ::: x has been bitten.\nAttacked(x) ::: x has been attacked.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Werewolf(x) → (Human(x) ∧ TurnInto(x, wolf))) ::: A werewolf is a human that can turn into a wolf.\n∀x (Werewolf(x) → (Scratched(x) ∨ Bitten(x))) ::: A werewolf has been scratched or bitten by another werewolf.\n∀x ((Scratched(x) ∨ Bitten(x)) → Attacked(x)) ::: If someone has been scratched or bitten, they have been attacked.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬(Werewolf(wolf)) ::: A werewolf is a wolf.\n\"\"\""
    ]
  },
  {
    "id": 508,
    "context": [
      "A werewolf is a human that can turn into a wolf.",
      "A werewolf has been scratched or bitten by another werewolf.",
      "If someone has been scratched or bitten, they have been attacked."
    ],
    "question": "A werewolf has scratched someone before.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nWerewolf(x) ::: x is a werewolf.\nHuman(x) ::: x is a human.\nTurnIntoWolf(x) ::: x can turn into a wolf.\nScratched(x) ::: x has been scratched.\nBitten(x) ::: x has been bitten.\nAttacked(x) ::: x has been attacked.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Werewolf(x) → (Human(x) ∧ TurnIntoWolf(x))) ::: A werewolf is a human that can turn into a wolf.\n∀x (Scratched(x) ∨ Bitten(x) → Attacked(x)) ::: If someone has been scratched or bitten, they have been attacked.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n∃x (Scratched(werewolf) ∧ Scratched(x)) ::: A werewolf has scratched someone before.\n\"\"\""
    ]
  },
  {
    "id": 409,
    "context": [
      "UFC Fight Night was a mixed martial arts event and was held in Sweden.",
      "At UFC Fight Night, Sadollah was scheduled to fight Musoke.",
      "Sadollah fought Akiyama at UFC Fight Night.",
      "Musoke fought Yakovlev at UFC Fight Night.",
      "Jung was injured at UFC Fight Night.",
      "Injured people did not fight at UFC Fight Night."
    ],
    "question": "Jung fought Sadollah.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nEvent(x) ::: x is an event.\nMMAEvent(x) ::: x is a mixed martial arts event.\nHeldIn(x, y) ::: x was held in y.\nScheduledToFight(x, y) ::: x was scheduled to fight y.\nFought(x, y) ::: x fought y.\nInjured(x) ::: x is injured.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nEvent(ufcFightNight) ∧ MMAEvent(ufcFightNight) ∧ HeldIn(ufcFightNight, sweden) ::: UFC Fight Night was a mixed martial arts event and was held in Sweden.\nScheduledToFight(sadollah, musoke) ∧ ScheduledToFight(musoke, yakovlev) ::: At UFC Fight Night, Sadollah was scheduled to fight Musoke and Musoke was scheduled to fight Yakovlev.\nFought(sadollah, akiyama) ∧ Fought(musoke, yakovlev) ::: Sadollah fought Akiyama at UFC Fight Night and Musoke fought Yakovlev at UFC Fight Night.\nInjured(jung) ∧ Injured(jung) → ¬Fought(jung, _) ::: Jung was injured at UFC Fight Night and injured people did not fight at UFC Fight Night.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬Fought(jung, sadollah) ::: Jung did not fight Sadollah.\n\"\"\""
    ]
  },
  {
    "id": 410,
    "context": [
      "UFC Fight Night was a mixed martial arts event and was held in Sweden.",
      "At UFC Fight Night, Sadollah was scheduled to fight Musoke.",
      "Sadollah fought Akiyama at UFC Fight Night.",
      "Musoke fought Yakovlev at UFC Fight Night.",
      "Jung was injured at UFC Fight Night.",
      "Injured people did not fight at UFC Fight Night."
    ],
    "question": "Jung did not fight at UFC Fight Night.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nEvent(x) ::: x is an event.\nMMAEvent(x) ::: x is a mixed martial arts event.\nHeldIn(x, y) ::: x is held in y.\nScheduledToFight(x, y) ::: x is scheduled to fight y.\nFought(x, y) ::: x fought y.\nInjured(x) ::: x is injured.\nDidNotFight(x) ::: x did not fight.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nEvent(ufcFightNight) ∧ MMAEvent(ufcFightNight) ∧ HeldIn(ufcFightNight, sweden) ::: UFC Fight Night was a mixed martial arts event and was held in Sweden.\nScheduledToFight(sadollah, musoke) ∧ ScheduledToFight(musoke, yakovlev) ::: At UFC Fight Night, Sadollah was scheduled to fight Musoke and Musoke was scheduled to fight Yakovlev.\nFought(sadollah, akiyama) ∧ Fought(musoke, yakovlev) ::: Sadollah fought Akiyama at UFC Fight Night and Musoke fought Yakovlev at UFC Fight Night.\nInjured(jung) ::: Jung was injured at UFC Fight Night.\n∀x (Injured(x) → DidNotFight(x)) ::: Injured people did not fight at UFC Fight Night.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nDidNotFight(jung) ::: Jung did not fight at UFC Fight Night.\n\"\"\""
    ]
  },
  {
    "id": 411,
    "context": [
      "UFC Fight Night was a mixed martial arts event and was held in Sweden.",
      "At UFC Fight Night, Sadollah was scheduled to fight Musoke.",
      "Sadollah fought Akiyama at UFC Fight Night.",
      "Musoke fought Yakovlev at UFC Fight Night.",
      "Jung was injured at UFC Fight Night.",
      "Injured people did not fight at UFC Fight Night."
    ],
    "question": "Sadollah fought Musoke.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nEvent(x) ::: x is an event.\nMMAEvent(x) ::: x is a mixed martial arts event.\nHeldIn(x, y) ::: x was held in y.\nScheduledToFight(x, y) ::: x was scheduled to fight y.\nFought(x, y) ::: x fought y.\nInjured(x) ::: x is injured.\nDidNotFight(x) ::: x did not fight.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nEvent(ufcFightNight) ∧ MMAEvent(ufcFightNight) ∧ HeldIn(ufcFightNight, sweden) ::: UFC Fight Night was a mixed martial arts event and was held in Sweden.\nScheduledToFight(sadollah, musoke) ∧ ScheduledToFight(sadollah, akiyama) ∧ ScheduledToFight(musoke, yakovlev) ::: At UFC Fight Night, Sadollah was scheduled to fight Musoke. Sadollah fought Akiyama at UFC Fight Night. Musoke fought Yakovlev at UFC Fight Night.\nInjured(jung) ∧ DidNotFight(jung) ::: Jung was injured at UFC Fight Night. Injured people did not fight at UFC Fight Night.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nFought(sadollah, musoke) ::: Sadollah fought Musoke.\n\"\"\""
    ]
  },
  {
    "id": 412,
    "context": [
      "UFC Fight Night was a mixed martial arts event and was held in Sweden.",
      "At UFC Fight Night, Sadollah was scheduled to fight Musoke.",
      "Sadollah fought Akiyama at UFC Fight Night.",
      "Musoke fought Yakovlev at UFC Fight Night.",
      "Jung was injured at UFC Fight Night.",
      "Injured people did not fight at UFC Fight Night."
    ],
    "question": "Nelson fought Story at UFC Fight Night.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nEvent(x) ::: x is an event.\nMMAEvent(x) ::: x is a mixed martial arts event.\nHeldIn(x, y) ::: x is held in y.\nScheduledToFight(x, y) ::: x is scheduled to fight y.\nFight(x, y) ::: x fought y.\nInjured(x) ::: x is injured.\nDidNotFight(x) ::: x did not fight.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nEvent(ufcFightNight) ∧ MMAEvent(ufcFightNight) ∧ HeldIn(ufcFightNight, sweden) ::: UFC Fight Night was a mixed martial arts event and was held in Sweden.\nScheduledToFight(sadollah, musoke) ∧ ScheduledToFight(sadollah, akiyama) ∧ ScheduledToFight(musoke, yakovlev) ::: At UFC Fight Night, Sadollah was scheduled to fight Musoke. Sadollah fought Akiyama at UFC Fight Night. Musoke fought Yakovlev at UFC Fight Night.\nInjured(jung) ∧ InjuredPeopleDidNotFight(ufcFightNight) ::: Jung was injured at UFC Fight Night. Injured people did not fight at UFC Fight Night.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬Fight(nelson, story) ::: Nelson did not fight Story at UFC Fight Night.\n\"\"\""
    ]
  },
  {
    "id": 1356,
    "context": [
      "All drinks are edible. ",
      "All juices are drinks. ",
      "All orange juice is a juice. ",
      "A juice is either an orange juice or an apple juice.",
      "All apple juice is sweet.",
      "If coke is apple juice, then coke is a drink.",
      "If coke is not apple juice, then coke is not edible."
    ],
    "question": "Coke is orange juice.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nEdible(x) ::: x is edible.\nDrink(x) ::: x is a drink.\nJuice(x) ::: x is a juice.\nOrangeJuice(x) ::: x is orange juice.\nAppleJuice(x) ::: x is apple juice.\nSweet(x) ::: x is sweet.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Drink(x) → Edible(x)) ::: All drinks are edible.\n∀x (Juice(x) → Drink(x)) ::: All juices are drinks.\n∀x (OrangeJuice(x) → Juice(x)) ::: All orange juice is a juice.\n∀x (Juice(x) ↔ (OrangeJuice(x) ∨ AppleJuice(x))) ::: A juice is either an orange juice or an apple juice.\n∀x (AppleJuice(x) → Sweet(x)) ::: All apple juice is sweet.\n(AppleJuice(coke) → Drink(coke)) → (AppleJuice(coke) → Drink(coke)) ::: If coke is apple juice, then coke is a drink.\n¬(AppleJuice(coke)) → ¬(Edible(coke)) ::: If coke is not apple juice, then coke is not edible.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nOrangeJuice(coke) ::: Coke is orange juice.\n\"\"\""
    ]
  },
  {
    "id": 1357,
    "context": [
      "All drinks are edible. ",
      "All juices are drinks. ",
      "All orange juice is a juice. ",
      "A juice is either an orange juice or an apple juice.",
      "All apple juice is sweet.",
      "If coke is apple juice, then coke is a drink.",
      "If coke is not apple juice, then coke is not edible."
    ],
    "question": "Coke is edible and sweet.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nEdible(x) ::: x is edible.\nDrink(x) ::: x is a drink.\nJuice(x) ::: x is a juice.\nOrangeJuice(x) ::: x is orange juice.\nAppleJuice(x) ::: x is apple juice.\nSweet(x) ::: x is sweet.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Drink(x) → Edible(x)) ::: All drinks are edible.\n∀x (Juice(x) → Drink(x)) ::: All juices are drinks.\n∀x (OrangeJuice(x) → Juice(x)) ::: All orange juice is a juice.\n∀x (Juice(x) ↔ (OrangeJuice(x) ∨ AppleJuice(x))) ::: A juice is either an orange juice or an apple juice.\n∀x (AppleJuice(x) → Sweet(x)) ::: All apple juice is sweet.\n(AppleJuice(coke) → Drink(coke)) ::: If coke is apple juice, then coke is a drink.\n¬(AppleJuice(coke)) → ¬(Edible(coke)) ::: If coke is not apple juice, then coke is not edible.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nEdible(coke) ∧ Sweet(coke) ::: Coke is edible and sweet.\n\"\"\""
    ]
  },
  {
    "id": 1358,
    "context": [
      "All drinks are edible. ",
      "All juices are drinks. ",
      "All orange juice is a juice. ",
      "A juice is either an orange juice or an apple juice.",
      "All apple juice is sweet.",
      "If coke is apple juice, then coke is a drink.",
      "If coke is not apple juice, then coke is not edible."
    ],
    "question": "Coke is not edible and sweet.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nEdible(x) ::: x is edible.\nDrink(x) ::: x is a drink.\nJuice(x) ::: x is a juice.\nOrangeJuice(x) ::: x is orange juice.\nAppleJuice(x) ::: x is apple juice.\nSweet(x) ::: x is sweet.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Drink(x) → Edible(x)) ::: All drinks are edible.\n∀x (Juice(x) → Drink(x)) ::: All juices are drinks.\n∀x (OrangeJuice(x) → Juice(x)) ::: All orange juice is a juice.\n∀x (Juice(x) ↔ (OrangeJuice(x) ∨ AppleJuice(x))) ::: A juice is either an orange juice or an apple juice.\n∀x (AppleJuice(x) → Sweet(x)) ::: All apple juice is sweet.\n(AppleJuice(coke) → Drink(coke)) → (AppleJuice(coke) → Drink(coke)) ::: If coke is apple juice, then coke is a drink.\n¬(AppleJuice(coke)) → ¬(Edible(coke)) ::: If coke is not apple juice, then coke is not edible.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬Edible(coke) ∧ Sweet(coke) ::: Coke is not edible and sweet.\n\"\"\""
    ]
  },
  {
    "id": 119,
    "context": [
      "Federico Garcia Lorca was a talented Spanish poet and he supported the Popular Front.",
      "The Spanish Nationalists opposed anyone who supported the Popular Front",
      "Talented poets are popular.",
      "Spanish Nationalists killed anyone who they opposed and were popular.",
      "Daniel supported the Popular Front but was not popular."
    ],
    "question": "Daniel was not killed by the Spanish Nationalists.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nSpanish(x) ::: x is Spanish.\nPoet(x) ::: x is a poet.\nSupports(x, y) ::: x supports y.\nOpposes(x, y) ::: x opposes y.\nPopularFront(x) ::: x supports the Popular Front.\nTalented(x) ::: x is talented.\nPopular(x) ::: x is popular.\nKilled(x, y) ::: x is killed by y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nSpanish(federico) ∧ Poet(federico) ∧ Talented(federico) ∧ Supports(federico, popularFront) ::: Federico Garcia Lorca was a talented Spanish poet and he supported the Popular Front.\n∀x ((SpanishNationalists(x) ∧ Opposes(x, popularFront)) → ¬Supports(y, popularFront)) ::: The Spanish Nationalists opposed anyone who supported the Popular Front.\n∀x (Talented(x) → Popular(x)) ::: Talented poets are popular.\n∀x ((SpanishNationalists(x) ∧ Opposes(x, y) ∧ Popular(y)) → Killed(x, y)) ::: Spanish Nationalists killed anyone who they opposed and were popular.\nSupports(daniel, popularFront) ∧ ¬Popular(daniel) ::: Daniel supported the Popular Front but was not popular.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬Killed(daniel, spanishNationalists) ::: Daniel was not killed by the Spanish Nationalists.\n\"\"\""
    ]
  },
  {
    "id": 120,
    "context": [
      "Federico Garcia Lorca was a talented Spanish poet and he supported the Popular Front.",
      "The Spanish Nationalists opposed anyone who supported the Popular Front",
      "Talented poets are popular.",
      "Spanish Nationalists killed anyone who they opposed and were popular.",
      "Daniel supported the Popular Front but was not popular."
    ],
    "question": "Lorca was killed by the Spanish Nationalists.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nSpanish(x) ::: x is Spanish.\nPoet(x) ::: x is a poet.\nSupports(x, y) ::: x supports y.\nPopularFront(x) ::: x supports the Popular Front.\nOppose(x, y) ::: x opposes y.\nTalented(x) ::: x is talented.\nPopular(x) ::: x is popular.\nKilledBy(x, y) ::: x is killed by y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nSpanish(federico) ∧ Poet(federico) ∧ Talented(federico) ∧ Supports(federico, popularFront) ::: Federico Garcia Lorca was a talented Spanish poet and he supported the Popular Front.\n∀x ((SpanishNationalists(x) ∧ Oppose(x, popularFront)) → ¬Supports(y, popularFront)) ::: The Spanish Nationalists opposed anyone who supported the Popular Front.\n∀x (Talented(x) → Popular(x)) ::: Talented poets are popular.\n∀x ((SpanishNationalists(x) ∧ Oppose(x, y) ∧ Popular(y)) → KilledBy(y, x)) ::: Spanish Nationalists killed anyone who they opposed and were popular.\nSupports(daniel, popularFront) ∧ ¬Popular(daniel) ::: Daniel supported the Popular Front but was not popular.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nKilledBy(lorca, spanishNationalists) ::: Lorca was killed by the Spanish Nationalists.\n\"\"\""
    ]
  },
  {
    "id": 978,
    "context": [
      "People either drink kombucha every day or drink Coca-Cola or Pepsi products every day.",
      "If people drink Coca-Cola or Pepsi products every day, then they grew up with extremely busy parents who did not have time to pack them lunch.",
      "If people drink Coca-Cola or Pepsi products every day, then they have to visit the dentist frequently.",
      "If people grew up with extremely busy parents who did not have time to pack them lunch, then they have erratic and diverse eating habits.",
      "If people have erratic and diverse eating habits, then they do not have consistent everyday routines and like sticking to a solid schedule.",
      "Franny either both grew up with extremely busy parents who did not have time to pack her lunch and has consistent everyday routines and like sticking to a solid schedule, or she neither grew up with extremely busy parents who did not have time to pack her lunch nor has consistent everyday routines and likes sticking to a schedule.  "
    ],
    "question": "Franny has to visit the dentist frequently.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nDrinkKombucha(x) ::: x drinks kombucha every day.\nDrinkCocaCola(x) ::: x drinks Coca-Cola products every day.\nDrinkPepsi(x) ::: x drinks Pepsi products every day.\nBusyParents(x) ::: x grew up with extremely busy parents who did not have time to pack lunch.\nVisitDentist(x) ::: x has to visit the dentist frequently.\nErraticEatingHabits(x) ::: x has erratic and diverse eating habits.\nConsistentRoutines(x) ::: x has consistent everyday routines and likes sticking to a solid schedule.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (DrinkKombucha(x) ∨ DrinkCocaCola(x) ∨ DrinkPepsi(x)) ::: People either drink kombucha every day or drink Coca-Cola or Pepsi products every day.\n∀x ((DrinkCocaCola(x) ∨ DrinkPepsi(x)) → BusyParents(x)) ::: If people drink Coca-Cola or Pepsi products every day, then they grew up with extremely busy parents who did not have time to pack them lunch.\n∀x ((DrinkCocaCola(x) ∨ DrinkPepsi(x)) → VisitDentist(x)) ::: If people drink Coca-Cola or Pepsi products every day, then they have to visit the dentist frequently.\n∀x (BusyParents(x) → ErraticEatingHabits(x)) ::: If people grew up with extremely busy parents who did not have time to pack them lunch, then they have erratic and diverse eating habits.\n∀x (ErraticEatingHabits(x) → ¬ConsistentRoutines(x)) ::: If people have erratic and diverse eating habits, then they do not have consistent everyday routines and like sticking to a solid schedule.\n(BusyParents(franny) ∧ ConsistentRoutines(franny)) ⊕ ¬(BusyParents(franny) ∨ ConsistentRoutines(franny)) ::: Franny either both grew up with extremely busy parents who did not have time to pack her lunch and has consistent everyday routines and likes sticking to a solid schedule, or she neither grew up with extremely busy parents who did not have time to pack her lunch nor has consistent everyday routines and likes sticking to a schedule.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nVisitDentist(franny) ::: Franny has to visit the dentist frequently.\n\"\"\""
    ]
  },
  {
    "id": 979,
    "context": [
      "People either drink kombucha every day or drink Coca-Cola or Pepsi products every day.",
      "If people drink Coca-Cola or Pepsi products every day, then they grew up with extremely busy parents who did not have time to pack them lunch.",
      "If people drink Coca-Cola or Pepsi products every day, then they have to visit the dentist frequently.",
      "If people grew up with extremely busy parents who did not have time to pack them lunch, then they have erratic and diverse eating habits.",
      "If people have erratic and diverse eating habits, then they do not have consistent everyday routines and like sticking to a solid schedule.",
      "Franny either both grew up with extremely busy parents who did not have time to pack her lunch and has consistent everyday routines and like sticking to a solid schedule, or she neither grew up with extremely busy parents who did not have time to pack her lunch nor has consistent everyday routines and likes sticking to a schedule.  "
    ],
    "question": "If Franny either both grew up with extremely busy parents who did not have time to pack her lunch and drink kombucha every day or neither grew up with extremely busy parents who did not have time to pack her lunch nor drink kombucha every day, then Franny neither visits the dentist frequently nor drinks Coca Cola or Pepsi products every day.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nDrinkKombucha(x) ::: x drinks kombucha every day.\nDrinkCocaCola(x) ::: x drinks Coca-Cola products every day.\nDrinkPepsi(x) ::: x drinks Pepsi products every day.\nBusyParents(x) ::: x grew up with extremely busy parents who did not have time to pack lunch.\nVisitDentist(x) ::: x has to visit the dentist frequently.\nEatingHabits(x) ::: x has erratic and diverse eating habits.\nConsistentRoutines(x) ::: x has consistent everyday routines and likes sticking to a solid schedule.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (DrinkKombucha(x) ∨ DrinkCocaCola(x) ∨ DrinkPepsi(x)) ::: People either drink kombucha every day or drink Coca-Cola or Pepsi products every day.\n∀x (DrinkCocaCola(x) ∨ DrinkPepsi(x) → BusyParents(x)) ::: If people drink Coca-Cola or Pepsi products every day, then they grew up with extremely busy parents who did not have time to pack them lunch.\n∀x (DrinkCocaCola(x) ∨ DrinkPepsi(x) → VisitDentist(x)) ::: If people drink Coca-Cola or Pepsi products every day, then they have to visit the dentist frequently.\n∀x (BusyParents(x) → EatingHabits(x)) ::: If people grew up with extremely busy parents who did not have time to pack them lunch, then they have erratic and diverse eating habits.\n∀x (EatingHabits(x) → ¬ConsistentRoutines(x)) ::: If people have erratic and diverse eating habits, then they do not have consistent everyday routines and like sticking to a solid schedule.\n(BusyParents(franny) ∧ ConsistentRoutines(franny)) ⊕ ¬(BusyParents(franny) ∨ ConsistentRoutines(franny)) ::: Franny either both grew up with extremely busy parents who did not have time to pack her lunch and has consistent everyday routines and likes sticking to a solid schedule, or she neither grew up with extremely busy parents who did not have time to pack her lunch nor has consistent everyday routines and likes sticking to a schedule.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n((BusyParents(franny) ∧ DrinkKombucha(franny)) ∨ ¬(BusyParents(franny) ∨ DrinkKombucha(franny))) → (¬VisitDentist(franny) ∧ ¬DrinkCocaCola(franny) ∧ ¬DrinkPepsi(franny)) ::: If Franny either both grew up with extremely busy parents who did not have time to pack her lunch and drink kombucha every day or neither grew up with extremely busy parents who did not have time to pack her lunch nor drink kombucha every day, then Franny neither visits the dentist frequently nor drinks Coca Cola or Pepsi products every day.\n\"\"\""
    ]
  },
  {
    "id": 980,
    "context": [
      "People either drink kombucha every day or drink Coca-Cola or Pepsi products every day.",
      "If people drink Coca-Cola or Pepsi products every day, then they grew up with extremely busy parents who did not have time to pack them lunch.",
      "If people drink Coca-Cola or Pepsi products every day, then they have to visit the dentist frequently.",
      "If people grew up with extremely busy parents who did not have time to pack them lunch, then they have erratic and diverse eating habits.",
      "If people have erratic and diverse eating habits, then they do not have consistent everyday routines and like sticking to a solid schedule.",
      "Franny either both grew up with extremely busy parents who did not have time to pack her lunch and has consistent everyday routines and like sticking to a solid schedule, or she neither grew up with extremely busy parents who did not have time to pack her lunch nor has consistent everyday routines and likes sticking to a schedule.  "
    ],
    "question": "If Franny either visits the dentist frequently or drinks kombucha every day, then Franny both visits the dentist frequently and drinks Coca-Cola or Pepsi products every day.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nDrinkKombucha(x) ::: x drinks kombucha every day.\nDrinkCocaCola(x) ::: x drinks Coca-Cola products every day.\nDrinkPepsi(x) ::: x drinks Pepsi products every day.\nBusyParents(x) ::: x grew up with extremely busy parents who did not have time to pack lunch.\nVisitDentist(x) ::: x has to visit the dentist frequently.\nEatingHabits(x) ::: x has erratic and diverse eating habits.\nConsistentRoutines(x) ::: x has consistent everyday routines and likes sticking to a solid schedule.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (DrinkKombucha(x) ∨ DrinkCocaCola(x) ∨ DrinkPepsi(x)) ::: People either drink kombucha every day or drink Coca-Cola or Pepsi products every day.\n∀x ((DrinkCocaCola(x) ∨ DrinkPepsi(x)) → BusyParents(x)) ::: If people drink Coca-Cola or Pepsi products every day, then they grew up with extremely busy parents who did not have time to pack them lunch.\n∀x ((DrinkCocaCola(x) ∨ DrinkPepsi(x)) → VisitDentist(x)) ::: If people drink Coca-Cola or Pepsi products every day, then they have to visit the dentist frequently.\n∀x (BusyParents(x) → EatingHabits(x)) ::: If people grew up with extremely busy parents who did not have time to pack them lunch, then they have erratic and diverse eating habits.\n∀x (EatingHabits(x) → ¬ConsistentRoutines(x)) ::: If people have erratic and diverse eating habits, then they do not have consistent everyday routines and like sticking to a solid schedule.\n(BusyParents(franny) ∧ ConsistentRoutines(franny)) ⊕ ¬(BusyParents(franny) ∨ ConsistentRoutines(franny)) ::: Franny either both grew up with extremely busy parents who did not have time to pack her lunch and has consistent everyday routines and likes sticking to a solid schedule, or she neither grew up with extremely busy parents who did not have time to pack her lunch nor has consistent everyday routines and likes sticking to a schedule.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n(VisitDentist(franny) ∨ DrinkKombucha(franny)) → (VisitDentist(franny) ∧ (DrinkCocaCola(franny) ∨ DrinkPepsi(franny))) ::: If Franny either visits the dentist frequently or drinks kombucha every day, then Franny both visits the dentist frequently and drinks Coca-Cola or Pepsi products every day.\n\"\"\""
    ]
  },
  {
    "id": 63,
    "context": [
      "If a customer subscribes to AMC A List, then he/she can watch 3 movies every week without any additional fees. ",
      "Some customers go to cinemas every week. ",
      "Customers who prefer TV series will not watch TV series in cinemas.",
      "James watches TV series in cinemas. ",
      "James subscribes to AMC A List.",
      "Peter prefers TV series."
    ],
    "question": "James is not able to watch 3 movies every week without any additional fees.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nSubscribes(x, y) ::: x subscribes to y.\nWatchMovies(x, y) ::: x watches y movies.\nGoToCinemas(x) ::: x goes to cinemas.\nPrefer(x, y) ::: x prefers y.\nWatchTVSeriesInCinemas(x) ::: x watches TV series in cinemas.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Subscribes(x, AMC A List) → WatchMovies(x, 3)) ::: If a customer subscribes to AMC A List, then he/she can watch 3 movies every week without any additional fees.\n∃x (GoToCinemas(x)) ::: Some customers go to cinemas every week.\n∀x (Prefer(x, TVSeries) → ¬WatchTVSeriesInCinemas(x)) ::: Customers who prefer TV series will not watch TV series in cinemas.\nWatchTVSeriesInCinemas(james) ::: James watches TV series in cinemas.\nSubscribes(james, AMC A List) ::: James subscribes to AMC A List.\nPrefer(peter, TVSeries) ::: Peter prefers TV series.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬WatchMovies(james, 3) ::: James is not able to watch 3 movies every week without any additional fees.\n\"\"\""
    ]
  },
  {
    "id": 64,
    "context": [
      "If a customer subscribes to AMC A List, then he/she can watch 3 movies every week without any additional fees. ",
      "Some customers go to cinemas every week. ",
      "Customers who prefer TV series will not watch TV series in cinemas.",
      "James watches TV series in cinemas. ",
      "James subscribes to AMC A List.",
      "Peter prefers TV series."
    ],
    "question": "James goes to cinemas every week.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nSubscribes(x, y) ::: x subscribes to y.\nWatchMovies(x, y) ::: x can watch y movies every week without any additional fees.\nGoToCinemas(x) ::: x goes to cinemas every week.\nPrefer(x, y) ::: x prefers y.\nWatchTVSeries(x, y) ::: x watches y TV series.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Subscribes(x, AMC A List) → WatchMovies(x, 3)) ::: If a customer subscribes to AMC A List, then he/she can watch 3 movies every week without any additional fees.\n∃x GoToCinemas(x) ::: Some customers go to cinemas every week.\n∀x (Prefer(x, TV Series) → ¬WatchTVSeries(x, cinemas)) ::: Customers who prefer TV series will not watch TV series in cinemas.\nWatchTVSeries(james, cinemas) ::: James watches TV series in cinemas.\nSubscribes(james, AMC A List) ::: James subscribes to AMC A List.\nPrefer(peter, TV Series) ::: Peter prefers TV series.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nGoToCinemas(james) ::: James goes to cinemas every week.\n\"\"\""
    ]
  },
  {
    "id": 65,
    "context": [
      "If a customer subscribes to AMC A List, then he/she can watch 3 movies every week without any additional fees. ",
      "Some customers go to cinemas every week. ",
      "Customers who prefer TV series will not watch TV series in cinemas.",
      "James watches TV series in cinemas. ",
      "James subscribes to AMC A List.",
      "Peter prefers TV series."
    ],
    "question": "Peter will not watch TV series in cinemas.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nSubscribes(x, y) ::: x subscribes to y.\nWatchMovies(x, y) ::: x can watch y movies every week without any additional fees.\nGoToCinema(x) ::: x goes to cinemas every week.\nPrefer(x, y) ::: x prefers y.\nWatchTVSeries(x, y) ::: x watches y TV series.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Subscribes(x, AMC A List) → WatchMovies(x, 3)) ::: If a customer subscribes to AMC A List, then he/she can watch 3 movies every week without any additional fees.\n∃x GoToCinema(x) ::: Some customers go to cinemas every week.\n∀x (Prefer(x, TV Series) → ¬WatchTVSeries(x, cinemas)) ::: Customers who prefer TV series will not watch TV series in cinemas.\nWatchTVSeries(james, cinemas) ::: James watches TV series in cinemas.\nSubscribes(james, AMC A List) ::: James subscribes to AMC A List.\nPrefer(peter, TV Series) ::: Peter prefers TV series.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬WatchTVSeries(peter, cinemas) ::: Peter will not watch TV series in cinemas.\n\"\"\""
    ]
  },
  {
    "id": 724,
    "context": [
      "Bulbophyllum attenuatum is in the genus bulbophyllum.",
      "All bulbophyllum are orchids."
    ],
    "question": "Bulbophyllum attenuatum is not an orchid.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nInGenus(x, y) ::: x is in the genus y.\nOrchid(x) ::: x is an orchid.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nInGenus(bulbophyllum_attenuatum, bulbophyllum) ::: Bulbophyllum attenuatum is in the genus bulbophyllum.\n∀x (InGenus(x, bulbophyllum) → Orchid(x)) ::: All bulbophyllum are orchids.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬Orchid(bulbophyllum_attenuatum) ::: Bulbophyllum attenuatum is not an orchid.\n\"\"\""
    ]
  },
  {
    "id": 470,
    "context": [
      "There are eight federal districts of Russia: Central, Northwestern, Southern, North Caucasian, Volga, Ural, Siberian and Far Eastern.",
      "The Central federal district has the largest population among all federal districts in Russia.",
      "Moscow is the administrative center of the Central federal district.",
      "Yekaterinburg is the administrative center of the Ural federal district.",
      "Vladivostok is the administrative center of the Far Eastern federal district.",
      "The Far Eastern federal district has the largest area among all federal districts in Russia.",
      "Some federal districts of Russia were established in 2000."
    ],
    "question": "Vladivostok is the administrative center of the federal district with the largest area.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nFederalDistrict(x) ::: x is a federal district of Russia.\nHasLargestPopulation(x) ::: x has the largest population among all federal districts in Russia.\nHasLargestArea(x) ::: x has the largest area among all federal districts in Russia.\nAdministrativeCenter(x, y) ::: y is the administrative center of federal district x.\nEstablished(x, y) ::: x was established in year y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nFederalDistrict(central) ∧ FederalDistrict(northwestern) ∧ FederalDistrict(southern) ∧ FederalDistrict(northCaucasian) ∧ FederalDistrict(volga) ∧ FederalDistrict(ural) ∧ FederalDistrict(siberian) ∧ FederalDistrict(farEastern) ::: There are eight federal districts of Russia: Central, Northwestern, Southern, North Caucasian, Volga, Ural, Siberian and Far Eastern.\nHasLargestPopulation(central) ::: The Central federal district has the largest population among all federal districts in Russia.\nAdministrativeCenter(moscow, central) ::: Moscow is the administrative center of the Central federal district.\nAdministrativeCenter(yekaterinburg, ural) ::: Yekaterinburg is the administrative center of the Ural federal district.\nAdministrativeCenter(vladivostok, farEastern) ::: Vladivostok is the administrative center of the Far Eastern federal district.\nHasLargestArea(farEastern) ::: The Far Eastern federal district has the largest area among all federal districts in Russia.\n∃x (FederalDistrict(x) ∧ Established(x, year2000)) ::: Some federal districts of Russia were established in 2000.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nAdministrativeCenter(vladivostok, x) ∧ HasLargestArea(x) ::: Vladivostok is the administrative center of the federal district with the largest area.\n\"\"\""
    ]
  },
  {
    "id": 471,
    "context": [
      "There are eight federal districts of Russia: Central, Northwestern, Southern, North Caucasian, Volga, Ural, Siberian and Far Eastern.",
      "The Central federal district has the largest population among all federal districts in Russia.",
      "Moscow is the administrative center of the Central federal district.",
      "Yekaterinburg is the administrative center of the Ural federal district.",
      "Vladivostok is the administrative center of the Far Eastern federal district.",
      "The Far Eastern federal district has the largest area among all federal districts in Russia.",
      "Some federal districts of Russia were established in 2000."
    ],
    "question": "Moscow is the administrative center of the federal district with the largest population.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nFederalDistrict(x) ::: x is a federal district of Russia.\nHasPopulation(x, y) ::: x has a population of y.\nAdministrativeCenter(x, y) ::: y is the administrative center of federal district x.\nLargestPopulation(x) ::: x has the largest population among all federal districts in Russia.\nEstablished(x, y) ::: x was established in year y.\nHasArea(x, y) ::: x has an area of y.\nLargestArea(x) ::: x has the largest area among all federal districts in Russia.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nFederalDistrict(central) ∧ FederalDistrict(northwestern) ∧ FederalDistrict(southern) ∧ FederalDistrict(northCaucasian) ∧ FederalDistrict(volga) ∧ FederalDistrict(ural) ∧ FederalDistrict(siberian) ∧ FederalDistrict(farEastern) ::: There are eight federal districts of Russia: Central, Northwestern, Southern, North Caucasian, Volga, Ural, Siberian and Far Eastern.\nHasPopulation(central, largest) ::: The Central federal district has the largest population among all federal districts in Russia.\nAdministrativeCenter(moscow, central) ::: Moscow is the administrative center of the Central federal district.\nAdministrativeCenter(yekaterinburg, ural) ::: Yekaterinburg is the administrative center of the Ural federal district.\nAdministrativeCenter(vladivostok, farEastern) ::: Vladivostok is the administrative center of the Far Eastern federal district.\nHasArea(farEastern, largest) ::: The Far Eastern federal district has the largest area among all federal districts in Russia.\n∃x (FederalDistrict(x) ∧ Established(x, year2000)) ::: Some federal districts of Russia were established in 2000.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nAdministrativeCenter(moscow, x) ∧ LargestPopulation(x) ::: Moscow is the administrative center of the federal district with the largest population.\n\"\"\""
    ]
  },
  {
    "id": 472,
    "context": [
      "There are eight federal districts of Russia: Central, Northwestern, Southern, North Caucasian, Volga, Ural, Siberian and Far Eastern.",
      "The Central federal district has the largest population among all federal districts in Russia.",
      "Moscow is the administrative center of the Central federal district.",
      "Yekaterinburg is the administrative center of the Ural federal district.",
      "Vladivostok is the administrative center of the Far Eastern federal district.",
      "The Far Eastern federal district has the largest area among all federal districts in Russia.",
      "Some federal districts of Russia were established in 2000."
    ],
    "question": "The Northwestern federal district was established in 2000.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nFederalDistrict(x) ::: x is a federal district of Russia.\nHasLargestPopulation(x) ::: x has the largest population among all federal districts in Russia.\nHasLargestArea(x) ::: x has the largest area among all federal districts in Russia.\nAdministrativeCenter(x, y) ::: y is the administrative center of federal district x.\nEstablished(x, y) ::: federal district x was established in year y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nFederalDistrict(central) ∧ FederalDistrict(northwestern) ∧ FederalDistrict(southern) ∧ FederalDistrict(northCaucasian) ∧ FederalDistrict(volga) ∧ FederalDistrict(ural) ∧ FederalDistrict(siberian) ∧ FederalDistrict(farEastern) ::: There are eight federal districts of Russia: Central, Northwestern, Southern, North Caucasian, Volga, Ural, Siberian and Far Eastern.\nHasLargestPopulation(central) ::: The Central federal district has the largest population among all federal districts in Russia.\nAdministrativeCenter(moscow, central) ::: Moscow is the administrative center of the Central federal district.\nAdministrativeCenter(yekaterinburg, ural) ::: Yekaterinburg is the administrative center of the Ural federal district.\nAdministrativeCenter(vladivostok, farEastern) ::: Vladivostok is the administrative center of the Far Eastern federal district.\nHasLargestArea(farEastern) ::: The Far Eastern federal district has the largest area among all federal districts in Russia.\n∃x (FederalDistrict(x) ∧ Established(x, year2000)) ::: Some federal districts of Russia were established in 2000.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nEstablished(northwestern, year2000) ::: The Northwestern federal district was established in 2000.\n\"\"\""
    ]
  },
  {
    "id": 815,
    "context": [
      "All cancers are malignant tumors.",
      "No malignant tumor can be treated at home.",
      "All colorectal cancer is cancer.",
      "Having a cold can be treated at home.",
      "Breast cancer is neither having a cold nor a malignant tumor (exclusive)."
    ],
    "question": "Breast cancer can be treated at home.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nCancer(x) ::: x is a cancer.\nMalignant(x) ::: x is a malignant tumor.\nTreatedAtHome(x) ::: x can be treated at home.\nColorectalCancer(x) ::: x is colorectal cancer.\nCold(x) ::: x is a cold.\nBreastCancer(x) ::: x is breast cancer.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Cancer(x) → Malignant(x)) ::: All cancers are malignant tumors.\n∀x (Malignant(x) → ¬TreatedAtHome(x)) ::: No malignant tumor can be treated at home.\n∀x (ColorectalCancer(x) → Cancer(x)) ::: All colorectal cancer is cancer.\nTreatedAtHome(cold) ::: Having a cold can be treated at home.\n¬(Cold(breastCancer) ∨ Malignant(breastCancer)) ⊕ BreastCancer(breastCancer) ::: Breast cancer is neither having a cold nor a malignant tumor (exclusive).\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nTreatedAtHome(breastCancer) ::: Breast cancer can be treated at home.\n\"\"\""
    ]
  },
  {
    "id": 816,
    "context": [
      "All cancers are malignant tumors.",
      "No malignant tumor can be treated at home.",
      "All colorectal cancer is cancer.",
      "Having a cold can be treated at home.",
      "Breast cancer is neither having a cold nor a malignant tumor (exclusive)."
    ],
    "question": "Breast cancer is colorectal cancer.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nCancer(x) ::: x is a cancer.\nMalignant(x) ::: x is a malignant tumor.\nTreatedAtHome(x) ::: x can be treated at home.\nColorectalCancer(x) ::: x is colorectal cancer.\nCold(x) ::: x is a cold.\nBreastCancer(x) ::: x is breast cancer.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Cancer(x) → Malignant(x)) ::: All cancers are malignant tumors.\n∀x (Malignant(x) → ¬TreatedAtHome(x)) ::: No malignant tumor can be treated at home.\n∀x (ColorectalCancer(x) → Cancer(x)) ::: All colorectal cancer is cancer.\nTreatedAtHome(cold) ::: Having a cold can be treated at home.\n¬(Cold(breastCancer) ∨ Malignant(breastCancer)) ⊕ ¬(Cold(breastCancer) ∧ Malignant(breastCancer)) ::: Breast cancer is neither having a cold nor a malignant tumor (exclusive).\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nColorectalCancer(breastCancer) ::: Breast cancer is colorectal cancer.\n\"\"\""
    ]
  },
  {
    "id": 817,
    "context": [
      "All cancers are malignant tumors.",
      "No malignant tumor can be treated at home.",
      "All colorectal cancer is cancer.",
      "Having a cold can be treated at home.",
      "Breast cancer is neither having a cold nor a malignant tumor (exclusive)."
    ],
    "question": "Breast cancer is not colorectal cancer.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nCancer(x) ::: x is a cancer.\nMalignant(x) ::: x is a malignant tumor.\nTreatedAtHome(x) ::: x can be treated at home.\nColorectalCancer(x) ::: x is colorectal cancer.\nCold(x) ::: x is a cold.\nBreastCancer(x) ::: x is breast cancer.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Cancer(x) → Malignant(x)) ::: All cancers are malignant tumors.\n∀x (Malignant(x) → ¬TreatedAtHome(x)) ::: No malignant tumor can be treated at home.\n∀x (ColorectalCancer(x) → Cancer(x)) ::: All colorectal cancer is cancer.\nTreatedAtHome(cold) ::: Having a cold can be treated at home.\n¬(Cold(breastCancer) ∨ Malignant(breastCancer)) ⊕ ¬(Cold(breastCancer) ∧ Malignant(breastCancer)) ::: Breast cancer is neither having a cold nor a malignant tumor (exclusive).\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬ColorectalCancer(breastCancer) ::: Breast cancer is not colorectal cancer.\n\"\"\""
    ]
  },
  {
    "id": 818,
    "context": [
      "All cancers are malignant tumors.",
      "No malignant tumor can be treated at home.",
      "All colorectal cancer is cancer.",
      "Having a cold can be treated at home.",
      "Breast cancer is neither having a cold nor a malignant tumor (exclusive)."
    ],
    "question": "Breast cancer is colorectal cancer or a malignant tumor.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nCancer(x) ::: x is a cancer.\nMalignant(x) ::: x is a malignant tumor.\nTreatedAtHome(x) ::: x can be treated at home.\nColorectalCancer(x) ::: x is colorectal cancer.\nCold(x) ::: x is a cold.\nBreastCancer(x) ::: x is breast cancer.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Cancer(x) → Malignant(x)) ::: All cancers are malignant tumors.\n∀x (Malignant(x) → ¬TreatedAtHome(x)) ::: No malignant tumor can be treated at home.\n∀x (ColorectalCancer(x) → Cancer(x)) ::: All colorectal cancer is cancer.\nTreatedAtHome(cold) ::: Having a cold can be treated at home.\n¬(Cold(breastCancer) ∨ Malignant(breastCancer)) ∧ (Cold(breastCancer) ⊕ Malignant(breastCancer)) ::: Breast cancer is neither having a cold nor a malignant tumor (exclusive).\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nColorectalCancer(breastCancer) ∨ Malignant(breastCancer) ::: Breast cancer is colorectal cancer or a malignant tumor.\n\"\"\""
    ]
  },
  {
    "id": 819,
    "context": [
      "All cancers are malignant tumors.",
      "No malignant tumor can be treated at home.",
      "All colorectal cancer is cancer.",
      "Having a cold can be treated at home.",
      "Breast cancer is neither having a cold nor a malignant tumor (exclusive)."
    ],
    "question": "Breast cancer is colorectal cancer and a cancer.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nCancer(x) ::: x is a cancer.\nMalignant(x) ::: x is a malignant tumor.\nTreatedAtHome(x) ::: x can be treated at home.\nColorectalCancer(x) ::: x is colorectal cancer.\nCold(x) ::: x is a cold.\nBreastCancer(x) ::: x is breast cancer.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Cancer(x) → Malignant(x)) ::: All cancers are malignant tumors.\n∀x (Malignant(x) → ¬TreatedAtHome(x)) ::: No malignant tumor can be treated at home.\n∀x (ColorectalCancer(x) → Cancer(x)) ::: All colorectal cancer is cancer.\nTreatedAtHome(cold) ::: Having a cold can be treated at home.\n¬(Cold(breastCancer) ∨ Malignant(breastCancer)) ⊕ BreastCancer(breastCancer) ::: Breast cancer is neither having a cold nor a malignant tumor (exclusive).\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nColorectalCancer(breastCancer) ∧ Cancer(breastCancer) ::: Breast cancer is colorectal cancer and a cancer.\n\"\"\""
    ]
  },
  {
    "id": 820,
    "context": [
      "All cancers are malignant tumors.",
      "No malignant tumor can be treated at home.",
      "All colorectal cancer is cancer.",
      "Having a cold can be treated at home.",
      "Breast cancer is neither having a cold nor a malignant tumor (exclusive)."
    ],
    "question": "If breast cancer is not colorectal cancer, then breast cancer is a malignant tumor.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nCancer(x) ::: x is a cancer.\nMalignant(x) ::: x is a malignant tumor.\nTreatedAtHome(x) ::: x can be treated at home.\nColorectalCancer(x) ::: x is colorectal cancer.\nCold(x) ::: x is a cold.\nBreastCancer(x) ::: x is breast cancer.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Cancer(x) → Malignant(x)) ::: All cancers are malignant tumors.\n∀x (Malignant(x) → ¬TreatedAtHome(x)) ::: No malignant tumor can be treated at home.\n∀x (ColorectalCancer(x) → Cancer(x)) ::: All colorectal cancer is cancer.\nTreatedAtHome(cold) ::: Having a cold can be treated at home.\n¬(Cold(breastCancer) ∨ Malignant(breastCancer)) ∧ (Cold(breastCancer) ⊕ Malignant(breastCancer)) ::: Breast cancer is neither having a cold nor a malignant tumor (exclusive).\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬ColorectalCancer(breastCancer) → Malignant(breastCancer) ::: If breast cancer is not colorectal cancer, then breast cancer is a malignant tumor.\n\"\"\""
    ]
  },
  {
    "id": 752,
    "context": [
      "I should not worry about things outside of my control.",
      "Traffic is outside of my control."
    ],
    "question": "I should not worry about traffic.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nWorry(x, y) ::: x worries about y.\nControl(x, y) ::: x has control over y.\nTraffic(x) ::: x is traffic.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Control(x, y) → ¬Worry(x, y)) ::: I should not worry about things outside of my control.\nControl(me, traffic) ::: Traffic is outside of my control.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬Worry(me, traffic) ::: I should not worry about traffic.\n\"\"\""
    ]
  },
  {
    "id": 342,
    "context": [
      "Roversi is an Italian surname.",
      "Alba Roversi uses Roversi as a surname.",
      "Paolo Roversi uses Roversi as a surname.",
      "Roberto Roversi uses Roversi as a surname.",
      "Paolo Roversi is a photographer.",
      "A photographer is a professional or an amateur."
    ],
    "question": "Alba Roversi uses an Italian surname.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nItalian(x) ::: x is Italian.\nSurname(x) ::: x is a surname.\nUses(x, y) ::: x uses y.\nPhotographer(x) ::: x is a photographer.\nProfessional(x) ::: x is a professional.\nAmateur(x) ::: x is an amateur.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nItalian(roversi) ∧ Surname(roversi) ::: Roversi is an Italian surname.\nUses(alba, roversi) ::: Alba Roversi uses Roversi as a surname.\nUses(paolo, roversi) ::: Paolo Roversi uses Roversi as a surname.\nUses(roberto, roversi) ::: Roberto Roversi uses Roversi as a surname.\nPhotographer(paolo) ::: Paolo Roversi is a photographer.\n∀x (Photographer(x) → (Professional(x) ∨ Amateur(x))) ::: A photographer is a professional or an amateur.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nUses(alba, roversi) ∧ Italian(roversi) ::: Alba Roversi uses an Italian surname.\n\"\"\""
    ]
  },
  {
    "id": 343,
    "context": [
      "Roversi is an Italian surname.",
      "Alba Roversi uses Roversi as a surname.",
      "Paolo Roversi uses Roversi as a surname.",
      "Roberto Roversi uses Roversi as a surname.",
      "Paolo Roversi is a photographer.",
      "A photographer is a professional or an amateur."
    ],
    "question": "There are no photographers using an Italian surname.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nItalian(x) ::: x is Italian.\nSurname(x, y) ::: x uses y as a surname.\nPhotographer(x) ::: x is a photographer.\nProfessional(x) ::: x is a professional.\nAmateur(x) ::: x is an amateur.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nItalian(roversi) ∧ Surname(alba, roversi) ∧ Surname(paolo, roversi) ∧ Surname(roberto, roversi) ::: Roversi is an Italian surname. Alba Roversi uses Roversi as a surname. Paolo Roversi uses Roversi as a surname. Roberto Roversi uses Roversi as a surname.\nPhotographer(paolo) ::: Paolo Roversi is a photographer.\n∀x (Photographer(x) → (Professional(x) ∨ Amateur(x))) ::: A photographer is a professional or an amateur.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬∃x (Photographer(x) ∧ Italian(surname(x))) ::: There are no photographers using an Italian surname.\n\"\"\""
    ]
  },
  {
    "id": 344,
    "context": [
      "Roversi is an Italian surname.",
      "Alba Roversi uses Roversi as a surname.",
      "Paolo Roversi uses Roversi as a surname.",
      "Roberto Roversi uses Roversi as a surname.",
      "Paolo Roversi is a photographer.",
      "A photographer is a professional or an amateur."
    ],
    "question": "Paolo is an amateur photographer.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nItalian(x) ::: x is Italian.\nSurname(x, y) ::: x uses y as a surname.\nPhotographer(x) ::: x is a photographer.\nProfessional(x) ::: x is a professional.\nAmateur(x) ::: x is an amateur.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nItalian(roversi) ∧ Surname(alba, roversi) ∧ Surname(paolo, roversi) ∧ Surname(roberto, roversi) ::: Roversi is an Italian surname.\nSurname(alba, roversi) ::: Alba Roversi uses Roversi as a surname.\nSurname(paolo, roversi) ::: Paolo Roversi uses Roversi as a surname.\nSurname(roberto, roversi) ::: Roberto Roversi uses Roversi as a surname.\nPhotographer(paolo) ::: Paolo Roversi is a photographer.\n∀x (Photographer(x) → (Professional(x) ∨ Amateur(x))) ::: A photographer is a professional or an amateur.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nAmateur(paolo) ::: Paolo is an amateur photographer.\n\"\"\""
    ]
  },
  {
    "id": 677,
    "context": [
      "Zaha Hadid is a British-Iraqi architect, artist and designer.",
      "Zaha Hadid was born on 31 October 1950 in Baghdad, Iraq.",
      "Hadid was a visiting professor of Architectural Design at the Yale School of Architecture.",
      "Max is an aspiring architecture student, and he plans to apply to Yale School of Architecture. "
    ],
    "question": "Hadid became a UK citizen later in her life.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nBritish(x) ::: x is British.\nIraqi(x) ::: x is Iraqi.\nArchitect(x) ::: x is an architect.\nArtist(x) ::: x is an artist.\nDesigner(x) ::: x is a designer.\nBorn(x, y, z) ::: x was born on y in z.\nProfessor(x, y) ::: x is a professor of y.\nVisitingProfessor(x, y, z) ::: x is a visiting professor of y at z.\nStudent(x) ::: x is a student.\nApply(x, y) ::: x plans to apply to y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nBritish(zaha) ∧ Iraqi(zaha) ∧ Architect(zaha) ∧ Artist(zaha) ∧ Designer(zaha) ::: Zaha Hadid is a British-Iraqi architect, artist, and designer.\nBorn(zaha, 31October1950, Baghdad) ::: Zaha Hadid was born on 31 October 1950 in Baghdad, Iraq.\nVisitingProfessor(hadid, ArchitecturalDesign, YaleSchoolOfArchitecture) ::: Hadid was a visiting professor of Architectural Design at the Yale School of Architecture.\nStudent(max) ∧ Apply(max, YaleSchoolOfArchitecture) ::: Max is an aspiring architecture student, and he plans to apply to Yale School of Architecture.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n∅ ::: Hadid became a UK citizen later in her life.\n\"\"\""
    ]
  },
  {
    "id": 678,
    "context": [
      "Zaha Hadid is a British-Iraqi architect, artist and designer.",
      "Zaha Hadid was born on 31 October 1950 in Baghdad, Iraq.",
      "Hadid was a visiting professor of Architectural Design at the Yale School of Architecture.",
      "Max is an aspiring architecture student, and he plans to apply to Yale School of Architecture. "
    ],
    "question": "Hadid did some work in interior design.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nArchitect(x) ::: x is an architect.\nArtist(x) ::: x is an artist.\nDesigner(x) ::: x is a designer.\nBorn(x, y, z) ::: x was born on y in z.\nProfessor(x, y) ::: x is a professor of y.\nVisitingProfessor(x, y, z) ::: x is a visiting professor of y at z.\nStudent(x) ::: x is a student.\nAspiring(x) ::: x is aspiring.\nApply(x, y) ::: x plans to apply to y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nBritish(zaha) ∧ Iraqi(zaha) ∧ Architect(zaha) ∧ Artist(zaha) ∧ Designer(zaha) ::: Zaha Hadid is a British-Iraqi architect, artist, and designer.\nBorn(zaha, date1950, Baghdad) ::: Zaha Hadid was born on 31 October 1950 in Baghdad, Iraq.\nVisitingProfessor(hadid, ArchitecturalDesign, YaleSchoolOfArchitecture) ::: Hadid was a visiting professor of Architectural Design at the Yale School of Architecture.\nStudent(max) ∧ Aspiring(max) ∧ Apply(max, YaleSchoolOfArchitecture) ::: Max is an aspiring architecture student, and he plans to apply to Yale School of Architecture.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n∅ ::: Hadid did some work in interior design.\n\"\"\""
    ]
  },
  {
    "id": 679,
    "context": [
      "Zaha Hadid is a British-Iraqi architect, artist and designer.",
      "Zaha Hadid was born on 31 October 1950 in Baghdad, Iraq.",
      "Hadid was a visiting professor of Architectural Design at the Yale School of Architecture.",
      "Max is an aspiring architecture student, and he plans to apply to Yale School of Architecture. "
    ],
    "question": "Hadid was born in 1982.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nArchitect(x) ::: x is an architect.\nArtist(x) ::: x is an artist.\nDesigner(x) ::: x is a designer.\nBorn(x, y) ::: x was born on date y.\nProfessor(x, y) ::: x is a professor of subject y.\nStudent(x) ::: x is a student.\nApply(x, y) ::: x plans to apply to school y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nBritishIraqi(zahaHadid) ∧ Architect(zahaHadid) ∧ Artist(zahaHadid) ∧ Designer(zahaHadid) ::: Zaha Hadid is a British-Iraqi architect, artist, and designer.\nBorn(zahaHadid, October31, 1950) ∧ Born(zahaHadid, Baghdad, Iraq) ::: Zaha Hadid was born on 31 October 1950 in Baghdad, Iraq.\nProfessor(zahaHadid, ArchitecturalDesign, YaleSchoolOfArchitecture) ::: Hadid was a visiting professor of Architectural Design at the Yale School of Architecture.\nStudent(max) ∧ Apply(max, YaleSchoolOfArchitecture) ::: Max is an aspiring architecture student, and he plans to apply to Yale School of Architecture.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬Born(hadid, 1982) ::: Hadid was not born in 1982.\n\"\"\""
    ]
  },
  {
    "id": 680,
    "context": [
      "Zaha Hadid is a British-Iraqi architect, artist and designer.",
      "Zaha Hadid was born on 31 October 1950 in Baghdad, Iraq.",
      "Hadid was a visiting professor of Architectural Design at the Yale School of Architecture.",
      "Max is an aspiring architecture student, and he plans to apply to Yale School of Architecture. "
    ],
    "question": "Max admires Zaha Hadid.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nArchitect(x) ::: x is an architect.\nArtist(x) ::: x is an artist.\nDesigner(x) ::: x is a designer.\nBornOn(x, y) ::: x was born on date y.\nProfessor(x, y) ::: x is a professor of subject y.\nStudent(x) ::: x is a student.\nAspiring(x) ::: x is aspiring.\nApplyTo(x, y) ::: x plans to apply to y.\nAdmire(x, y) ::: x admires y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nBritishIraqi(zahaHadid) ∧ Architect(zahaHadid) ∧ Artist(zahaHadid) ∧ Designer(zahaHadid) ::: Zaha Hadid is a British-Iraqi architect, artist and designer.\nBornOn(zahaHadid, date1950-10-31) ∧ BornIn(zahaHadid, baghdad, iraq) ::: Zaha Hadid was born on 31 October 1950 in Baghdad, Iraq.\nProfessor(zahaHadid, architecturalDesign) ∧ At(zahaHadid, yaleSchoolOfArchitecture) ::: Hadid was a visiting professor of Architectural Design at the Yale School of Architecture.\nStudent(max) ∧ Aspiring(max) ∧ ApplyTo(max, yaleSchoolOfArchitecture) ::: Max is an aspiring architecture student, and he plans to apply to Yale School of Architecture.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nAdmire(max, zahaHadid) ::: Max admires Zaha Hadid.\n\"\"\""
    ]
  },
  {
    "id": 1081,
    "context": [
      "Something is either an invasive neuroimaging technique or a noninvasive neuroimaging technique. ",
      "All noninvasive neuroimaging techniques provide a spatial resolution of brains.",
      "If a technique provides a spatial resolution of brains, then it is a measurement of brain activity. ",
      "All measurements of brain activity are used by neuroscience researchers.",
      "FMRI is either a measurement of brain activity or a noninvasive neuroimaging technique."
    ],
    "question": "FMRI provides a spatial resolution of brains.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nInvasive(x) ::: x is an invasive neuroimaging technique.\nNoninvasive(x) ::: x is a noninvasive neuroimaging technique.\nSpatialResolution(x) ::: x provides a spatial resolution of brains.\nMeasurement(x) ::: x is a measurement of brain activity.\nUsedBy(x, y) ::: x is used by y.\nFMRI(x) ::: x is an FMRI technique.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Invasive(x) ⊕ Noninvasive(x)) ::: Something is either an invasive neuroimaging technique or a noninvasive neuroimaging technique.\n∀x (Noninvasive(x) → SpatialResolution(x)) ::: All noninvasive neuroimaging techniques provide a spatial resolution of brains.\n∀x (SpatialResolution(x) → Measurement(x)) ::: If a technique provides a spatial resolution of brains, then it is a measurement of brain activity.\n∀x (Measurement(x) → UsedBy(x, neuroscienceResearchers)) ::: All measurements of brain activity are used by neuroscience researchers.\n(FMRI(fMRI) ⊕ Measurement(fMRI)) ::: FMRI is either a measurement of brain activity or a noninvasive neuroimaging technique.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nSpatialResolution(FMRI) ::: FMRI provides a spatial resolution of brains.\n\"\"\""
    ]
  },
  {
    "id": 1082,
    "context": [
      "Something is either an invasive neuroimaging technique or a noninvasive neuroimaging technique. ",
      "All noninvasive neuroimaging techniques provide a spatial resolution of brains.",
      "If a technique provides a spatial resolution of brains, then it is a measurement of brain activity. ",
      "All measurements of brain activity are used by neuroscience researchers.",
      "FMRI is either a measurement of brain activity or a noninvasive neuroimaging technique."
    ],
    "question": "FMRI is an invasive neuroimaging technique and is used by neuroscience researchers.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nInvasive(x) ::: x is an invasive neuroimaging technique.\nNoninvasive(x) ::: x is a noninvasive neuroimaging technique.\nSpatialResolution(x) ::: x provides a spatial resolution of brains.\nMeasurement(x) ::: x is a measurement of brain activity.\nUsedBy(x, y) ::: x is used by y.\nFMRI(x) ::: x is an FMRI technique.\nNeuroscienceResearcher(x) ::: x is a neuroscience researcher.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Invasive(x) ⊕ Noninvasive(x)) ::: Something is either an invasive neuroimaging technique or a noninvasive neuroimaging technique.\n∀x (Noninvasive(x) → SpatialResolution(x)) ::: All noninvasive neuroimaging techniques provide a spatial resolution of brains.\n∀x (SpatialResolution(x) → Measurement(x)) ::: If a technique provides a spatial resolution of brains, then it is a measurement of brain activity.\n∀x (Measurement(x) → UsedBy(x, neuroscienceResearchers)) ::: All measurements of brain activity are used by neuroscience researchers.\n(FMRI(fMRI) ⊕ Measurement(fMRI)) ::: FMRI is either a measurement of brain activity or a noninvasive neuroimaging technique.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nInvasive(FMRI) ∧ UsedBy(FMRI, neuroscienceResearchers) ::: FMRI is an invasive neuroimaging technique and is used by neuroscience researchers.\n\"\"\""
    ]
  },
  {
    "id": 1083,
    "context": [
      "Something is either an invasive neuroimaging technique or a noninvasive neuroimaging technique. ",
      "All noninvasive neuroimaging techniques provide a spatial resolution of brains.",
      "If a technique provides a spatial resolution of brains, then it is a measurement of brain activity. ",
      "All measurements of brain activity are used by neuroscience researchers.",
      "FMRI is either a measurement of brain activity or a noninvasive neuroimaging technique."
    ],
    "question": "FMRI is either an invasive neuroimaging technique or is used by neuroscience researchers.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nInvasive(x) ::: x is an invasive neuroimaging technique.\nNoninvasive(x) ::: x is a noninvasive neuroimaging technique.\nSpatialResolution(x) ::: x provides a spatial resolution of brains.\nMeasurement(x) ::: x is a measurement of brain activity.\nUsedBy(x, y) ::: x is used by y.\nFMRI(x) ::: x is an FMRI technique.\nNeuroscienceResearcher(x) ::: x is a neuroscience researcher.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nInvasive(x) ⊕ Noninvasive(x) ::: Something is either an invasive neuroimaging technique or a noninvasive neuroimaging technique.\n∀x (Noninvasive(x) → SpatialResolution(x)) ::: All noninvasive neuroimaging techniques provide a spatial resolution of brains.\n∀x (SpatialResolution(x) → Measurement(x)) ::: If a technique provides a spatial resolution of brains, then it is a measurement of brain activity.\n∀x (Measurement(x) → UsedBy(x, neuroscienceResearchers)) ::: All measurements of brain activity are used by neuroscience researchers.\nFMRI(fMRI) ⊕ Measurement(fMRI) ∨ Noninvasive(fMRI) ::: FMRI is either a measurement of brain activity or a noninvasive neuroimaging technique.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nInvasive(FMRI) ∨ UsedBy(FMRI, neuroscienceResearchers) ::: FMRI is either an invasive neuroimaging technique or is used by neuroscience researchers.\n\"\"\""
    ]
  },
  {
    "id": 1084,
    "context": [
      "Something is either an invasive neuroimaging technique or a noninvasive neuroimaging technique. ",
      "All noninvasive neuroimaging techniques provide a spatial resolution of brains.",
      "If a technique provides a spatial resolution of brains, then it is a measurement of brain activity. ",
      "All measurements of brain activity are used by neuroscience researchers.",
      "FMRI is either a measurement of brain activity or a noninvasive neuroimaging technique."
    ],
    "question": "If fMRI is not an invasive neuroimaging technique and used by neuroscience researchers, then fMRI is neither a noninvasive neuroimaging technique nor provides a spatial resolution of brains.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nInvasive(x) ::: x is an invasive neuroimaging technique.\nNoninvasive(x) ::: x is a noninvasive neuroimaging technique.\nSpatialResolution(x) ::: x provides a spatial resolution of brains.\nMeasurement(x) ::: x is a measurement of brain activity.\nUsedBy(x, y) ::: x is used by y.\nNeuroscienceResearcher(x) ::: x is a neuroscience researcher.\nFMRI(x) ::: x is an fMRI technique.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Invasive(x) ⊕ Noninvasive(x)) ::: Something is either an invasive neuroimaging technique or a noninvasive neuroimaging technique.\n∀x (Noninvasive(x) → SpatialResolution(x)) ::: All noninvasive neuroimaging techniques provide a spatial resolution of brains.\n∀x (SpatialResolution(x) → Measurement(x)) ::: If a technique provides a spatial resolution of brains, then it is a measurement of brain activity.\n∀x (Measurement(x) → UsedBy(x, NeuroscienceResearcher)) ::: All measurements of brain activity are used by neuroscience researchers.\n(FMRI(fMRI) ⊕ Measurement(fMRI)) ::: FMRI is either a measurement of brain activity or a noninvasive neuroimaging technique.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬(Invasive(fMRI) ∧ UsedBy(fMRI, NeuroscienceResearcher)) → ¬(Noninvasive(fMRI) ∨ SpatialResolution(fMRI)) ::: If fMRI is not an invasive neuroimaging technique and used by neuroscience researchers, then fMRI is neither a noninvasive neuroimaging technique nor provides a spatial resolution of brains.\n\"\"\""
    ]
  },
  {
    "id": 1258,
    "context": [
      "Either present their work at the conference or provide a tutorial session at the conference. ",
      "All who present their work at the conference will attend in person. ",
      "All those providing a tutorial session at the conference are invited to join the club. ",
      "All who attend the conference in person are provided with souvenirs. ",
      "All invited to join the club are provided with delicious meals. ",
      "All provided with delicious meals are happy to communicate with each other during the dinner. ",
      "All provided with delicious meals are invited to take a photo with the audience. ",
      "James does not attend the conference in person and is not provided with souvenirs."
    ],
    "question": "James is provided with souvenirs.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nPresent(x) ::: x presents their work at the conference.\nTutorial(x) ::: x provides a tutorial session at the conference.\nAttend(x) ::: x attends the conference in person.\nClub(x) ::: x is invited to join the club.\nSouvenirs(x) ::: x is provided with souvenirs.\nMeals(x) ::: x is provided with delicious meals.\nCommunicate(x) ::: x is happy to communicate with each other during the dinner.\nPhoto(x) ::: x is invited to take a photo with the audience.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nPresent(x) ∨ Tutorial(x) ::: Either present their work at the conference or provide a tutorial session at the conference.\n∀x (Present(x) → Attend(x)) ::: All who present their work at the conference will attend in person.\n∀x (Tutorial(x) → Club(x)) ::: All those providing a tutorial session at the conference are invited to join the club.\n∀x (Attend(x) → Souvenirs(x)) ::: All who attend the conference in person are provided with souvenirs.\n∀x (Club(x) → Meals(x)) ::: All invited to join the club are provided with delicious meals.\n∀x (Meals(x) → Communicate(x)) ::: All provided with delicious meals are happy to communicate with each other during the dinner.\n∀x (Meals(x) → Photo(x)) ::: All provided with delicious meals are invited to take a photo with the audience.\n¬(Attend(james)) ∧ ¬(Souvenirs(james)) ::: James does not attend the conference in person and is not provided with souvenirs.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬Souvenirs(james) ::: James is provided with souvenirs.\n\"\"\""
    ]
  },
  {
    "id": 1259,
    "context": [
      "Either present their work at the conference or provide a tutorial session at the conference. ",
      "All who present their work at the conference will attend in person. ",
      "All those providing a tutorial session at the conference are invited to join the club. ",
      "All who attend the conference in person are provided with souvenirs. ",
      "All invited to join the club are provided with delicious meals. ",
      "All provided with delicious meals are happy to communicate with each other during the dinner. ",
      "All provided with delicious meals are invited to take a photo with the audience. ",
      "James does not attend the conference in person and is not provided with souvenirs."
    ],
    "question": "James is not provided with souvenirs.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nPresent(x) ::: x presents their work at the conference.\nTutorial(x) ::: x provides a tutorial session at the conference.\nAttendInPerson(x) ::: x attends the conference in person.\nInvite(x) ::: x is invited to join the club.\nProvideSouvenirs(x) ::: x is provided with souvenirs.\nDeliciousMeals(x) ::: x is provided with delicious meals.\nCommunicate(x) ::: x is happy to communicate with each other during the dinner.\nTakePhoto(x) ::: x is invited to take a photo with the audience.\nJames(x) ::: x is James.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Present(x) ∨ Tutorial(x)) ::: Either present their work at the conference or provide a tutorial session at the conference.\n∀x (Present(x) → AttendInPerson(x)) ::: All who present their work at the conference will attend in person.\n∀x (Tutorial(x) → Invite(x)) ::: All those providing a tutorial session at the conference are invited to join the club.\n∀x (AttendInPerson(x) → ProvideSouvenirs(x)) ::: All who attend the conference in person are provided with souvenirs.\n∀x (Invite(x) → DeliciousMeals(x)) ::: All invited to join the club are provided with delicious meals.\n∀x (DeliciousMeals(x) → Communicate(x)) ::: All provided with delicious meals are happy to communicate with each other during the dinner.\n∀x (DeliciousMeals(x) → TakePhoto(x)) ::: All provided with delicious meals are invited to take a photo with the audience.\n¬(AttendInPerson(james)) ∧ ¬(ProvideSouvenirs(james)) ::: James does not attend the conference in person and is not provided with souvenirs.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬ProvideSouvenirs(james) ::: James is not provided with souvenirs.\n\"\"\""
    ]
  },
  {
    "id": 1260,
    "context": [
      "Either present their work at the conference or provide a tutorial session at the conference. ",
      "All who present their work at the conference will attend in person. ",
      "All those providing a tutorial session at the conference are invited to join the club. ",
      "All who attend the conference in person are provided with souvenirs. ",
      "All invited to join the club are provided with delicious meals. ",
      "All provided with delicious meals are happy to communicate with each other during the dinner. ",
      "All provided with delicious meals are invited to take a photo with the audience. ",
      "James does not attend the conference in person and is not provided with souvenirs."
    ],
    "question": "James is invited to take a photo with the audience and is happy to communicate with each other at the dinner.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nPresent(x) ::: x presents their work at the conference.\nTutorial(x) ::: x provides a tutorial session at the conference.\nAttend(x) ::: x attends the conference in person.\nClubMember(x) ::: x is invited to join the club.\nSouvenirs(x) ::: x is provided with souvenirs.\nDeliciousMeals(x) ::: x is provided with delicious meals.\nCommunicate(x) ::: x is happy to communicate with each other during the dinner.\nTakePhoto(x) ::: x is invited to take a photo with the audience.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Present(x) ∨ Tutorial(x)) ::: Either present their work at the conference or provide a tutorial session at the conference.\n∀x (Present(x) → Attend(x)) ::: All who present their work at the conference will attend in person.\n∀x (Tutorial(x) → ClubMember(x)) ::: All those providing a tutorial session at the conference are invited to join the club.\n∀x (Attend(x) → Souvenirs(x)) ::: All who attend the conference in person are provided with souvenirs.\n∀x (ClubMember(x) → DeliciousMeals(x)) ::: All invited to join the club are provided with delicious meals.\n∀x (DeliciousMeals(x) → Communicate(x)) ::: All provided with delicious meals are happy to communicate with each other during the dinner.\n∀x (DeliciousMeals(x) → TakePhoto(x)) ::: All provided with delicious meals are invited to take a photo with the audience.\n¬(Attend(james) ∧ Souvenirs(james)) ::: James does not attend the conference in person and is not provided with souvenirs.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nTakePhoto(james) ∧ Communicate(james) ::: James is invited to take a photo with the audience and is happy to communicate with each other at the dinner.\n\"\"\""
    ]
  },
  {
    "id": 1261,
    "context": [
      "Either present their work at the conference or provide a tutorial session at the conference. ",
      "All who present their work at the conference will attend in person. ",
      "All those providing a tutorial session at the conference are invited to join the club. ",
      "All who attend the conference in person are provided with souvenirs. ",
      "All invited to join the club are provided with delicious meals. ",
      "All provided with delicious meals are happy to communicate with each other during the dinner. ",
      "All provided with delicious meals are invited to take a photo with the audience. ",
      "James does not attend the conference in person and is not provided with souvenirs."
    ],
    "question": "James is invited to take a photo with the audience or is happy to communicate with each other during the dinner.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nPresent(x) ::: x presents their work at the conference.\nTutorial(x) ::: x provides a tutorial session at the conference.\nAttend(x) ::: x attends the conference in person.\nClub(x) ::: x is invited to join the club.\nSouvenirs(x) ::: x is provided with souvenirs.\nDeliciousMeals(x) ::: x is provided with delicious meals.\nCommunicate(x) ::: x is happy to communicate with each other during the dinner.\nTakePhoto(x) ::: x is invited to take a photo with the audience.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Present(x) ∨ Tutorial(x)) ::: Either present their work at the conference or provide a tutorial session at the conference.\n∀x (Present(x) → Attend(x)) ::: All who present their work at the conference will attend in person.\n∀x (Tutorial(x) → Club(x)) ::: All those providing a tutorial session at the conference are invited to join the club.\n∀x (Attend(x) → Souvenirs(x)) ::: All who attend the conference in person are provided with souvenirs.\n∀x (Club(x) → DeliciousMeals(x)) ::: All invited to join the club are provided with delicious meals.\n∀x (DeliciousMeals(x) → Communicate(x)) ::: All provided with delicious meals are happy to communicate with each other during the dinner.\n∀x (DeliciousMeals(x) → TakePhoto(x)) ::: All provided with delicious meals are invited to take a photo with the audience.\n¬(Attend(james) ∧ Souvenirs(james)) ::: James does not attend the conference in person and is not provided with souvenirs.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nTakePhoto(james) ∨ Communicate(james) ::: James is invited to take a photo with the audience or is happy to communicate with each other during the dinner.\n\"\"\""
    ]
  },
  {
    "id": 1262,
    "context": [
      "Either present their work at the conference or provide a tutorial session at the conference. ",
      "All who present their work at the conference will attend in person. ",
      "All those providing a tutorial session at the conference are invited to join the club. ",
      "All who attend the conference in person are provided with souvenirs. ",
      "All invited to join the club are provided with delicious meals. ",
      "All provided with delicious meals are happy to communicate with each other during the dinner. ",
      "All provided with delicious meals are invited to take a photo with the audience. ",
      "James does not attend the conference in person and is not provided with souvenirs."
    ],
    "question": "James is either invited to take a photo with the audience or happy to communicate with each other during the dinner.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nPresent(x) ::: x presents their work at the conference.\nTutorial(x) ::: x provides a tutorial session at the conference.\nAttend(x) ::: x attends the conference in person.\nClub(x) ::: x is invited to join the club.\nSouvenirs(x) ::: x is provided with souvenirs.\nDeliciousMeals(x) ::: x is provided with delicious meals.\nCommunicate(x) ::: x is happy to communicate with each other during the dinner.\nPhoto(x) ::: x is invited to take a photo with the audience.\nJames(x) ::: x is James.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nPresent(x) ∨ Tutorial(x) ::: Either present their work at the conference or provide a tutorial session at the conference.\n∀x (Present(x) → Attend(x)) ::: All who present their work at the conference will attend in person.\n∀x (Tutorial(x) → Club(x)) ::: All those providing a tutorial session at the conference are invited to join the club.\n∀x (Attend(x) → Souvenirs(x)) ::: All who attend the conference in person are provided with souvenirs.\n∀x (Club(x) → DeliciousMeals(x)) ::: All invited to join the club are provided with delicious meals.\n∀x (DeliciousMeals(x) → Communicate(x)) ::: All provided with delicious meals are happy to communicate with each other during the dinner.\n∀x (DeliciousMeals(x) → Photo(x)) ::: All provided with delicious meals are invited to take a photo with the audience.\n¬(Attend(James)) ∧ ¬(Souvenirs(James)) ::: James does not attend the conference in person and is not provided with souvenirs.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nPhoto(James) ∨ Communicate(James) ::: James is either invited to take a photo with the audience or happy to communicate with each other during the dinner.\n\"\"\""
    ]
  },
  {
    "id": 38,
    "context": [
      "The USS Salem is a heavy cruiser built for the United States navy.",
      "The last heavy cruiser to enter service was the USS Salem.",
      "The USS Salem is a museum ship.",
      "Museum ships are open to the public.",
      "The USS Salem served in the Atlantic and Mediterranean."
    ],
    "question": "The USS Salem is open to the public.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nHeavyCruiser(x) ::: x is a heavy cruiser.\nBuiltFor(x, y) ::: x is built for y.\nLastToEnterService(x) ::: x is the last heavy cruiser to enter service.\nMuseumShip(x) ::: x is a museum ship.\nOpenToPublic(x) ::: x is open to the public.\nServedIn(x, y) ::: x served in y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nHeavyCruiser(ussSalem) ∧ BuiltFor(ussSalem, USN) ::: The USS Salem is a heavy cruiser built for the United States navy.\nLastToEnterService(ussSalem) ::: The last heavy cruiser to enter service was the USS Salem.\nMuseumShip(ussSalem) ::: The USS Salem is a museum ship.\n∀x (MuseumShip(x) → OpenToPublic(x)) ::: Museum ships are open to the public.\nServedIn(ussSalem, Atlantic) ∧ ServedIn(ussSalem, Mediterranean) ::: The USS Salem served in the Atlantic and Mediterranean.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nOpenToPublic(ussSalem) ::: The USS Salem is open to the public.\n\"\"\""
    ]
  },
  {
    "id": 39,
    "context": [
      "The USS Salem is a heavy cruiser built for the United States navy.",
      "The last heavy cruiser to enter service was the USS Salem.",
      "The USS Salem is a museum ship.",
      "Museum ships are open to the public.",
      "The USS Salem served in the Atlantic and Mediterranean."
    ],
    "question": "There is a museum ship open to the public that served in the Mediterranean.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nHeavyCruiser(x) ::: x is a heavy cruiser.\nBuiltFor(x, y) ::: x is built for y.\nLastToEnterService(x) ::: x is the last heavy cruiser to enter service.\nMuseumShip(x) ::: x is a museum ship.\nOpenToPublic(x) ::: x is open to the public.\nServedIn(x, y) ::: x served in y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nHeavyCruiser(ussSalem) ∧ BuiltFor(ussSalem, USN) ::: The USS Salem is a heavy cruiser built for the United States navy.\nLastToEnterService(ussSalem) ::: The last heavy cruiser to enter service was the USS Salem.\nMuseumShip(ussSalem) ::: The USS Salem is a museum ship.\n∀x (MuseumShip(x) → OpenToPublic(x)) ::: Museum ships are open to the public.\nServedIn(ussSalem, Atlantic) ∧ ServedIn(ussSalem, Mediterranean) ::: The USS Salem served in the Atlantic and Mediterranean.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n∃x (MuseumShip(x) ∧ OpenToPublic(x) ∧ ServedIn(x, Mediterranean)) ::: There is a museum ship open to the public that served in the Mediterranean.\n\"\"\""
    ]
  },
  {
    "id": 40,
    "context": [
      "The USS Salem is a heavy cruiser built for the United States navy.",
      "The last heavy cruiser to enter service was the USS Salem.",
      "The USS Salem is a museum ship.",
      "Museum ships are open to the public.",
      "The USS Salem served in the Atlantic and Mediterranean."
    ],
    "question": "The USS Salem was not the last heavy cruiser to enter service.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nHeavyCruiser(x) ::: x is a heavy cruiser.\nBuiltFor(x, y) ::: x is built for y.\nLastToEnterService(x) ::: x is the last heavy cruiser to enter service.\nMuseumShip(x) ::: x is a museum ship.\nOpenToPublic(x) ::: x is open to the public.\nServedIn(x, y) ::: x served in y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nHeavyCruiser(ussSalem) ∧ BuiltFor(ussSalem, USN) ::: The USS Salem is a heavy cruiser built for the United States navy.\nLastToEnterService(ussSalem) ::: The last heavy cruiser to enter service was the USS Salem.\nMuseumShip(ussSalem) ::: The USS Salem is a museum ship.\n∀x (MuseumShip(x) → OpenToPublic(x)) ::: Museum ships are open to the public.\nServedIn(ussSalem, atlantic) ∧ ServedIn(ussSalem, mediterranean) ::: The USS Salem served in the Atlantic and Mediterranean.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬LastToEnterService(ussSalem) ::: The USS Salem was not the last heavy cruiser to enter service.\n\"\"\""
    ]
  },
  {
    "id": 415,
    "context": [
      "TS Leda was a good passenger and cargo vessel.",
      "TS Leda was the first Norweigian vessel that was built with stabilizers.",
      "Stabilizers are mechanical devices that are only on ships that have powerful steam turbine engines.",
      " To be a good passenger and cargo vessel, ships must be quiet and good at sea.",
      "Some ships that are quiet and good at sea have powerful steam turbine engines."
    ],
    "question": "TS Leda was quiet and good at sea.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nVessel(x) ::: x is a vessel.\nPassenger(x) ::: x is a passenger vessel.\nCargo(x) ::: x is a cargo vessel.\nBuiltWithStabilizers(x) ::: x was built with stabilizers.\nMechanicalDevice(x) ::: x is a mechanical device.\nOn(x, y) ::: x is on y.\nShip(x) ::: x is a ship.\nPowerfulSteamTurbineEngine(x) ::: x has a powerful steam turbine engine.\nQuiet(x) ::: x is quiet.\nGoodAtSea(x) ::: x is good at sea.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nVessel(TS Leda) ∧ Passenger(TS Leda) ∧ Cargo(TS Leda) ::: TS Leda was a good passenger and cargo vessel.\nBuiltWithStabilizers(TS Leda) ∧ ¬∃y (Vessel(y) ∧ BuiltWithStabilizers(y) ∧ y != TS Leda) ::: TS Leda was the first Norwegian vessel that was built with stabilizers.\n∀x (MechanicalDevice(x) → (∃y (Ship(y) ∧ PowerfulSteamTurbineEngine(y) ∧ On(x, y)))) ::: Stabilizers are mechanical devices that are only on ships that have powerful steam turbine engines.\n∀x (Vessel(x) ∧ Passenger(x) ∧ Cargo(x) → (Quiet(x) ∧ GoodAtSea(x))) ::: To be a good passenger and cargo vessel, ships must be quiet and good at sea.\n∃x (Ship(x) ∧ Quiet(x) ∧ GoodAtSea(x) ∧ PowerfulSteamTurbineEngine(x)) ::: Some ships that are quiet and good at sea have powerful steam turbine engines.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nQuiet(TS Leda) ∧ GoodAtSea(TS Leda) ::: TS Leda was quiet and good at sea.\n\"\"\""
    ]
  },
  {
    "id": 416,
    "context": [
      "TS Leda was a good passenger and cargo vessel.",
      "TS Leda was the first Norweigian vessel that was built with stabilizers.",
      "Stabilizers are mechanical devices that are only on ships that have powerful steam turbine engines.",
      " To be a good passenger and cargo vessel, ships must be quiet and good at sea.",
      "Some ships that are quiet and good at sea have powerful steam turbine engines."
    ],
    "question": "TS Leda had powerful steam turbine engines.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nGood(x) ::: x is a good passenger and cargo vessel.\nBuiltWithStabilizers(x) ::: x was built with stabilizers.\nMechanicalDevice(x) ::: x is a mechanical device.\nOn(x, y) ::: x is on y.\nShip(x) ::: x is a ship.\nPowerfulSteamTurbineEngine(x) ::: x has powerful steam turbine engines.\nQuiet(x) ::: x is quiet.\nGoodAtSea(x) ::: x is good at sea.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nGood(TS Leda) ∧ Ship(TS Leda) ::: TS Leda was a good passenger and cargo vessel.\nBuiltWithStabilizers(TS Leda) ∧ Ship(TS Leda) ∧ Norwegian(TS Leda) ::: TS Leda was the first Norwegian vessel that was built with stabilizers.\n∀x (MechanicalDevice(x) → (∃y (Ship(y) ∧ PowerfulSteamTurbineEngine(y) ∧ On(x, y)))) ::: Stabilizers are mechanical devices that are only on ships that have powerful steam turbine engines.\n∀x (Good(x) → (Quiet(x) ∧ GoodAtSea(x))) ::: To be a good passenger and cargo vessel, ships must be quiet and good at sea.\n∃x (Quiet(x) ∧ GoodAtSea(x) ∧ PowerfulSteamTurbineEngine(x)) ::: Some ships that are quiet and good at sea have powerful steam turbine engines.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nPowerfulSteamTurbineEngine(TS Leda) ::: TS Leda had powerful steam turbine engines.\n\"\"\""
    ]
  },
  {
    "id": 417,
    "context": [
      "TS Leda was a good passenger and cargo vessel.",
      "TS Leda was the first Norweigian vessel that was built with stabilizers.",
      "Stabilizers are mechanical devices that are only on ships that have powerful steam turbine engines.",
      " To be a good passenger and cargo vessel, ships must be quiet and good at sea.",
      "Some ships that are quiet and good at sea have powerful steam turbine engines."
    ],
    "question": "TS Leda was not a Norweigian vessel.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nGood(x) ::: x is a good passenger and cargo vessel.\nNorwegian(x) ::: x is a Norwegian vessel.\nBuiltWithStabilizers(x) ::: x was built with stabilizers.\nMechanicalDevice(x) ::: x is a mechanical device.\nOn(x, y) ::: x is on y.\nShip(x) ::: x is a ship.\nPowerfulSteamTurbineEngine(x) ::: x has powerful steam turbine engines.\nQuiet(x) ::: x is quiet.\nGoodAtSea(x) ::: x is good at sea.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nGood(TS Leda) ∧ Ship(TS Leda) ::: TS Leda was a good passenger and cargo vessel.\nNorwegian(TS Leda) ∧ BuiltWithStabilizers(TS Leda) ::: TS Leda was the first Norwegian vessel that was built with stabilizers.\n∀x (Stabilizers(x) ↔ (MechanicalDevice(x) ∧ On(x, Ship(x)) ∧ PowerfulSteamTurbineEngine(Ship(x)))) ::: Stabilizers are mechanical devices that are only on ships that have powerful steam turbine engines.\n∀x (Good(x) → (Quiet(x) ∧ GoodAtSea(x))) ::: To be a good passenger and cargo vessel, ships must be quiet and good at sea.\n∃x (Quiet(x) ∧ GoodAtSea(x) ∧ PowerfulSteamTurbineEngine(x)) ::: Some ships that are quiet and good at sea have powerful steam turbine engines.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬Norwegian(TS Leda) ::: TS Leda was not a Norwegian vessel.\n\"\"\""
    ]
  },
  {
    "id": 555,
    "context": [
      "Rosa was born in Santiago. ",
      "Santiago is the capital and largest city of Chile.",
      "Rosa is the daughter of a Catalan building contractor, Jose.",
      "Jose has a Chilean wife, Carmen.",
      "A building contractor is responsible for the day-to-day oversight of a construction site. "
    ],
    "question": "Rosa was born in the largest city of Chile.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nBornIn(x, y) ::: x was born in y.\nCapital(x, y) ::: x is the capital of y.\nLargestCity(x, y) ::: x is the largest city of y.\nDaughterOf(x, y) ::: x is the daughter of y.\nBuildingContractor(x) ::: x is a building contractor.\nOversight(x, y) ::: x is responsible for the day-to-day oversight of y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nBornIn(rosa, santiago) ::: Rosa was born in Santiago.\nCapital(santiago, chile) ∧ LargestCity(santiago, chile) ::: Santiago is the capital and largest city of Chile.\nDaughterOf(rosa, jose) ∧ BuildingContractor(jose) ∧ Oversight(jose, constructionSite) ::: Rosa is the daughter of a Catalan building contractor, Jose, who is responsible for the day-to-day oversight of a construction site.\nChilean(carmen) ∧ WifeOf(carmen, jose) ::: Jose has a Chilean wife, Carmen.\n∀x (BuildingContractor(x) → Oversight(x, constructionSite)) ::: A building contractor is responsible for the day-to-day oversight of a construction site.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nBornIn(rosa, santiago) ∧ LargestCity(santiago, chile) ::: Rosa was born in the largest city of Chile.\n\"\"\""
    ]
  },
  {
    "id": 556,
    "context": [
      "Rosa was born in Santiago. ",
      "Santiago is the capital and largest city of Chile.",
      "Rosa is the daughter of a Catalan building contractor, Jose.",
      "Jose has a Chilean wife, Carmen.",
      "A building contractor is responsible for the day-to-day oversight of a construction site. "
    ],
    "question": "Neither of Rosa's parents is Chilean.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nBornIn(x, y) ::: x was born in y.\nCapital(x, y) ::: x is the capital of y.\nLargestCity(x, y) ::: x is the largest city of y.\nDaughterOf(x, y) ::: x is the daughter of y.\nBuildingContractor(x) ::: x is a building contractor.\nResponsibleFor(x, y) ::: x is responsible for the day-to-day oversight of y.\nWife(x, y) ::: x is the wife of y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nBornIn(rosa, santiago) ::: Rosa was born in Santiago.\nCapital(santiago, chile) ∧ LargestCity(santiago, chile) ::: Santiago is the capital and largest city of Chile.\nDaughterOf(rosa, jose) ∧ BuildingContractor(jose) ∧ ResponsibleFor(jose, constructionSite) ::: Rosa is the daughter of a Catalan building contractor, Jose, who is responsible for the day-to-day oversight of a construction site.\nWife(carmen, jose) ∧ Chilean(carmen) ::: Jose has a Chilean wife, Carmen.\n∀x (BuildingContractor(x) → ResponsibleFor(x, constructionSite)) ::: A building contractor is responsible for the day-to-day oversight of a construction site.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬Chilean(jose) ∧ ¬Chilean(carmen) ::: Neither of Rosa's parents is Chilean.\n\"\"\""
    ]
  },
  {
    "id": 557,
    "context": [
      "Rosa was born in Santiago. ",
      "Santiago is the capital and largest city of Chile.",
      "Rosa is the daughter of a Catalan building contractor, Jose.",
      "Jose has a Chilean wife, Carmen.",
      "A building contractor is responsible for the day-to-day oversight of a construction site. "
    ],
    "question": "Rosa is the daughter of someone who is responsible for the oversight of traffic.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nBornIn(x, y) ::: x was born in y.\nCapital(x, y) ::: x is the capital of y.\nLargestCity(x, y) ::: x is the largest city of y.\nDaughterOf(x, y) ::: x is the daughter of y.\nBuildingContractor(x) ::: x is a building contractor.\nResponsibleFor(x, y) ::: x is responsible for the oversight of y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nBornIn(rosa, santiago) ::: Rosa was born in Santiago.\nCapital(santiago, chile) ∧ LargestCity(santiago, chile) ::: Santiago is the capital and largest city of Chile.\nDaughterOf(rosa, jose) ∧ BuildingContractor(jose) ∧ ResponsibleFor(jose, constructionSite) ::: Rosa is the daughter of a Catalan building contractor, Jose, who is responsible for the day-to-day oversight of a construction site.\nChilean(carmen) ∧ WifeOf(carmen, jose) ::: Jose has a Chilean wife, Carmen.\n∀x (BuildingContractor(x) → ResponsibleFor(x, constructionSite)) ::: A building contractor is responsible for the day-to-day oversight of a construction site.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n∃x (DaughterOf(rosa, x) ∧ ResponsibleFor(x, traffic)) ::: Rosa is the daughter of someone who is responsible for the oversight of traffic.\n\"\"\""
    ]
  },
  {
    "id": 105,
    "context": [
      "Tyga is a rapper.",
      "Rappers release rap albums.",
      "Tyga released the Well Done 3 album.",
      "Rappers are not opera singers."
    ],
    "question": "Well Done 3 is a rap album.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nRapper(x) ::: x is a rapper.\nRelease(x, y) ::: x releases y.\nAlbum(x) ::: x is an album.\nOperaSinger(x) ::: x is an opera singer.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nRapper(tyga) ::: Tyga is a rapper.\n∀x (Rapper(x) → Release(x, rapAlbum)) ::: Rappers release rap albums.\nRelease(tyga, wellDone3) ::: Tyga released the Well Done 3 album.\n∀x (Rapper(x) → ¬OperaSinger(x)) ::: Rappers are not opera singers.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nAlbum(wellDone3) ∧ Release(tyga, wellDone3) ::: Well Done 3 is a rap album.\n\"\"\""
    ]
  },
  {
    "id": 106,
    "context": [
      "Tyga is a rapper.",
      "Rappers release rap albums.",
      "Tyga released the Well Done 3 album.",
      "Rappers are not opera singers."
    ],
    "question": "Tyga is an opera singer.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nRapper(x) ::: x is a rapper.\nRelease(x, y) ::: x releases y.\nAlbum(x) ::: x is an album.\nOperaSinger(x) ::: x is an opera singer.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nRapper(tyga) ::: Tyga is a rapper.\n∀x (Rapper(x) → Release(x, rapAlbum)) ::: Rappers release rap albums.\nRelease(tyga, wellDone3) ::: Tyga released the Well Done 3 album.\n∀x (Rapper(x) → ¬OperaSinger(x)) ::: Rappers are not opera singers.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬OperaSinger(tyga) ::: Tyga is not an opera singer.\n\"\"\""
    ]
  },
  {
    "id": 107,
    "context": [
      "Tyga is a rapper.",
      "Rappers release rap albums.",
      "Tyga released the Well Done 3 album.",
      "Rappers are not opera singers."
    ],
    "question": "Well Done 3 is worth listening.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nRapper(x) ::: x is a rapper.\nRelease(x, y) ::: x releases y.\nAlbum(x) ::: x is an album.\nOperaSinger(x) ::: x is an opera singer.\nListenWorthy(x) ::: x is worth listening.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nRapper(tyga) ::: Tyga is a rapper.\n∀x (Rapper(x) → Release(x, Album(rap))) ::: Rappers release rap albums.\nRelease(tyga, WellDone3) ::: Tyga released the Well Done 3 album.\n∀x (Rapper(x) → ¬OperaSinger(x)) ::: Rappers are not opera singers.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nListenWorthy(WellDone3) ::: Well Done 3 is worth listening.\n\"\"\""
    ]
  },
  {
    "id": 293,
    "context": [
      "Deborah Wallace is a Scottish born actress, playwright and producer.",
      "Psyche is a play based on the life of James Miranda Barry.",
      "Homesick, Psyche and The Void are plays from Deborah Wallace.",
      "Deborah Wallace co-produced Gasland."
    ],
    "question": "Gasland was coproduced by the same person Homesick is from.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nScottish(x) ::: x is Scottish born.\nActress(x) ::: x is an actress.\nPlaywright(x) ::: x is a playwright.\nProducer(x) ::: x is a producer.\nPlay(x) ::: x is a play.\nBasedOn(x, y) ::: x is based on y.\nFrom(x, y) ::: x is from y.\nCoproduced(x, y) ::: x was co-produced by y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nScottish(deborahWallace) ∧ Actress(deborahWallace) ∧ Playwright(deborahWallace) ∧ Producer(deborahWallace) ::: Deborah Wallace is a Scottish born actress, playwright, and producer.\nPlay(psyche) ∧ BasedOn(psyche, jamesMirandaBarry) ::: Psyche is a play based on the life of James Miranda Barry.\nPlay(homesick) ∧ Play(psyche) ∧ Play(theVoid) ∧ From(homesick, deborahWallace) ∧ From(psyche, deborahWallace) ∧ From(theVoid, deborahWallace) ::: Homesick, Psyche, and The Void are plays from Deborah Wallace.\nCoproduced(deborahWallace, gasland) ::: Deborah Wallace co-produced Gasland.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nCoproduced(gasland, homesick) ::: Gasland was co-produced by the same person Homesick is from.\n\"\"\""
    ]
  },
  {
    "id": 294,
    "context": [
      "Deborah Wallace is a Scottish born actress, playwright and producer.",
      "Psyche is a play based on the life of James Miranda Barry.",
      "Homesick, Psyche and The Void are plays from Deborah Wallace.",
      "Deborah Wallace co-produced Gasland."
    ],
    "question": "There isn't a play from Deborah Wallace that is based on the life of James Miranda Barry.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nScottish(x) ::: x is Scottish born.\nActress(x) ::: x is an actress.\nPlaywright(x) ::: x is a playwright.\nProducer(x) ::: x is a producer.\nPlay(x) ::: x is a play.\nBasedOn(x, y) ::: x is based on the life of y.\nProducedBy(x, y) ::: x is produced by y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nScottish(deborahWallace) ∧ Actress(deborahWallace) ∧ Playwright(deborahWallace) ∧ Producer(deborahWallace) ::: Deborah Wallace is a Scottish born actress, playwright, and producer.\nPlay(psyche) ∧ BasedOn(psyche, jamesMirandaBarry) ::: Psyche is a play based on the life of James Miranda Barry.\nPlay(homesick) ∧ Play(psyche) ∧ Play(theVoid) ∧ ProducedBy(deborahWallace, homesick) ∧ ProducedBy(deborahWallace, psyche) ∧ ProducedBy(deborahWallace, theVoid) ::: Homesick, Psyche, and The Void are plays from Deborah Wallace.\nProducedBy(deborahWallace, gasland) ::: Deborah Wallace co-produced Gasland.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬∃x (Play(x) ∧ ProducedBy(deborahWallace, x) ∧ BasedOn(x, jamesMirandaBarry)) ::: There isn't a play from Deborah Wallace that is based on the life of James Miranda Barry.\n\"\"\""
    ]
  },
  {
    "id": 295,
    "context": [
      "Deborah Wallace is a Scottish born actress, playwright and producer.",
      "Psyche is a play based on the life of James Miranda Barry.",
      "Homesick, Psyche and The Void are plays from Deborah Wallace.",
      "Deborah Wallace co-produced Gasland."
    ],
    "question": "Gasland is a play.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nScottish(x) ::: x is Scottish born.\nActress(x) ::: x is an actress.\nPlaywright(x) ::: x is a playwright.\nProducer(x) ::: x is a producer.\nPlay(x) ::: x is a play.\nBasedOn(x, y) ::: x is based on y.\nFrom(x, y) ::: x is from y.\nCoProduced(x, y) ::: x co-produced y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nScottish(deborahWallace) ∧ Actress(deborahWallace) ∧ Playwright(deborahWallace) ∧ Producer(deborahWallace) ::: Deborah Wallace is a Scottish born actress, playwright and producer.\nPlay(psyche) ∧ BasedOn(psyche, jamesMirandaBarry) ::: Psyche is a play based on the life of James Miranda Barry.\nFrom(homesick, deborahWallace) ∧ From(psyche, deborahWallace) ∧ From(theVoid, deborahWallace) ::: Homesick, Psyche and The Void are plays from Deborah Wallace.\nCoProduced(deborahWallace, gasland) ::: Deborah Wallace co-produced Gasland.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n∃x (Play(x) ∧ CoProduced(deborahWallace, x)) ::: Gasland is a play.\n\"\"\""
    ]
  },
  {
    "id": 1297,
    "context": [
      "If an animal needs a large territory, then it travels far.",
      "Everything that eats a lot needs a large territory.",
      "If something is a big animal, then it will eat a lot.",
      "All bears are big animals.",
      "Larry is a big animal."
    ],
    "question": "Larry is a bear.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nNeedsLargeTerritory(x) ::: x needs a large territory.\nTravelsFar(x) ::: x travels far.\nEatsALot(x) ::: x eats a lot.\nBigAnimal(x) ::: x is a big animal.\nBear(x) ::: x is a bear.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (NeedsLargeTerritory(x) → TravelsFar(x)) ::: If an animal needs a large territory, then it travels far.\n∀x (EatsALot(x) → NeedsLargeTerritory(x)) ::: Everything that eats a lot needs a large territory.\n∀x (BigAnimal(x) → EatsALot(x)) ::: If something is a big animal, then it will eat a lot.\n∀x (Bear(x) → BigAnimal(x)) ::: All bears are big animals.\nBigAnimal(larry) ::: Larry is a big animal.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nBear(larry) ::: Larry is a bear.\n\"\"\""
    ]
  },
  {
    "id": 1298,
    "context": [
      "If an animal needs a large territory, then it travels far.",
      "Everything that eats a lot needs a large territory.",
      "If something is a big animal, then it will eat a lot.",
      "All bears are big animals.",
      "Larry is a big animal."
    ],
    "question": "Larry is neither a bear nor travels far.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nNeedsLargeTerritory(x) ::: x needs a large territory.\nTravelsFar(x) ::: x travels far.\nEatsALot(x) ::: x eats a lot.\nBigAnimal(x) ::: x is a big animal.\nBear(x) ::: x is a bear.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (NeedsLargeTerritory(x) → TravelsFar(x)) ::: If an animal needs a large territory, then it travels far.\n∀x (EatsALot(x) → NeedsLargeTerritory(x)) ::: Everything that eats a lot needs a large territory.\n∀x (BigAnimal(x) → EatsALot(x)) ::: If something is a big animal, then it will eat a lot.\n∀x (Bear(x) → BigAnimal(x)) ::: All bears are big animals.\nBigAnimal(larry) ::: Larry is a big animal.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬(Bear(larry) ∨ TravelsFar(larry)) ::: Larry is neither a bear nor travels far.\n\"\"\""
    ]
  },
  {
    "id": 1299,
    "context": [
      "If an animal needs a large territory, then it travels far.",
      "Everything that eats a lot needs a large territory.",
      "If something is a big animal, then it will eat a lot.",
      "All bears are big animals.",
      "Larry is a big animal."
    ],
    "question": "If Larry either travels far or needs a large territory, then Larry is a bear.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nLargeTerritory(x) ::: x needs a large territory.\nTravelsFar(x) ::: x travels far.\nEatsALot(x) ::: x eats a lot.\nBigAnimal(x) ::: x is a big animal.\nBear(x) ::: x is a bear.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (LargeTerritory(x) → TravelsFar(x)) ::: If an animal needs a large territory, then it travels far.\n∀x (EatsALot(x) → LargeTerritory(x)) ::: Everything that eats a lot needs a large territory.\n∀x (BigAnimal(x) → EatsALot(x)) ::: If something is a big animal, then it will eat a lot.\n∀x (Bear(x) → BigAnimal(x)) ::: All bears are big animals.\nBigAnimal(larry) ::: Larry is a big animal.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n(TravelsFar(larry) ∨ LargeTerritory(larry)) → Bear(larry) ::: If Larry either travels far or needs a large territory, then Larry is a bear.\n\"\"\""
    ]
  },
  {
    "id": 1335,
    "context": [
      "No criminal is kind. ",
      "All person who breaks the law is a criminals.",
      "People are either kind or evil.",
      "If someone is evil, then they are ugly.",
      "If someone is evil, then they are cold-blood.",
      "If Garry is either evil and ugly or neither evil nor ugly, then Garry is not evil."
    ],
    "question": "Garry is ugly.",
    "answer": "C",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nCriminal(x) ::: x is a criminal.\nKind(x) ::: x is kind.\nBreaksLaw(x) ::: x breaks the law.\nEvil(x) ::: x is evil.\nUgly(x) ::: x is ugly.\nColdBlood(x) ::: x is cold-blooded.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Criminal(x) → ¬Kind(x)) ::: No criminal is kind.\n∀x (BreaksLaw(x) → Criminal(x)) ::: All person who breaks the law is a criminal.\n∀x (Kind(x) ⊕ Evil(x)) ::: People are either kind or evil.\n∀x (Evil(x) → Ugly(x)) ::: If someone is evil, then they are ugly.\n∀x (Evil(x) → ColdBlood(x)) ::: If someone is evil, then they are cold-blooded.\n(Evil(garry) ∧ Ugly(garry)) ⊕ ¬(Evil(garry) ∨ Ugly(garry)) ::: If Garry is either evil and ugly or neither evil nor ugly, then Garry is not evil.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nUgly(garry) ::: Garry is ugly.\n\"\"\""
    ]
  },
  {
    "id": 1336,
    "context": [
      "No criminal is kind. ",
      "All person who breaks the law is a criminals.",
      "People are either kind or evil.",
      "If someone is evil, then they are ugly.",
      "If someone is evil, then they are cold-blood.",
      "If Garry is either evil and ugly or neither evil nor ugly, then Garry is not evil."
    ],
    "question": "Garry is cold-blooded and breaks the law.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nCriminal(x) ::: x is a criminal.\nKind(x) ::: x is kind.\nBreaksLaw(x) ::: x breaks the law.\nEvil(x) ::: x is evil.\nUgly(x) ::: x is ugly.\nColdBlooded(x) ::: x is cold-blooded.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Criminal(x) → ¬Kind(x)) ::: No criminal is kind.\n∀x (BreaksLaw(x) → Criminal(x)) ::: All person who breaks the law is a criminal.\n∀x (Kind(x) ⊕ Evil(x)) ::: People are either kind or evil.\n∀x (Evil(x) → Ugly(x)) ::: If someone is evil, then they are ugly.\n∀x (Evil(x) → ColdBlooded(x)) ::: If someone is evil, then they are cold-blooded.\n(Evil(garry) ∧ Ugly(garry)) ⊕ ¬(Evil(garry) ∨ Ugly(garry)) → ¬Evil(garry) ::: If Garry is either evil and ugly or neither evil nor ugly, then Garry is not evil.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nColdBlooded(garry) ∧ BreaksLaw(garry) ::: Garry is cold-blooded and breaks the law.\n\"\"\""
    ]
  },
  {
    "id": 1337,
    "context": [
      "No criminal is kind. ",
      "All person who breaks the law is a criminals.",
      "People are either kind or evil.",
      "If someone is evil, then they are ugly.",
      "If someone is evil, then they are cold-blood.",
      "If Garry is either evil and ugly or neither evil nor ugly, then Garry is not evil."
    ],
    "question": "If Garry is evil or breaks the law, then Garry is not both a criminal and breaking the law.",
    "answer": "A",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nCriminal(x) ::: x is a criminal.\nKind(x) ::: x is kind.\nBreaksLaw(x) ::: x breaks the law.\nEvil(x) ::: x is evil.\nUgly(x) ::: x is ugly.\nColdBlood(x) ::: x is cold-blooded.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\n∀x (Criminal(x) → ¬Kind(x)) ::: No criminal is kind.\n∀x (BreaksLaw(x) → Criminal(x)) ::: All person who breaks the law is a criminal.\n∀x (Kind(x) ⊕ Evil(x)) ::: People are either kind or evil.\n∀x (Evil(x) → Ugly(x)) ::: If someone is evil, then they are ugly.\n∀x (Evil(x) → ColdBlood(x)) ::: If someone is evil, then they are cold-blooded.\n(Evil(garry) ∧ Ugly(garry)) ⊕ ¬(Evil(garry) ∨ Ugly(garry)) ::: If Garry is either evil and ugly or neither evil nor ugly, then Garry is not evil.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n(Evil(garry) ∨ BreaksLaw(garry)) → ¬(Criminal(garry) ∧ BreaksLaw(garry)) ::: If Garry is evil or breaks the law, then Garry is not both a criminal and breaking the law.\n\"\"\""
    ]
  },
  {
    "id": 402,
    "context": [
      "Phoneix's music is classified under the indie pop genre.",
      "Phoenix is a band from France.",
      "French bands write songs in French or in English.",
      "Aside from indie pop, pop rock and synth-pop are two other genres of music.",
      "Phoneix has no songs in French."
    ],
    "question": "Phoenix makes pop rock music.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nClassifiedUnder(x, y) ::: x's music is classified under genre y.\nBand(x) ::: x is a band.\nFrom(x, y) ::: x is from country y.\nWriteIn(x, y) ::: x writes songs in language y.\nGenre(x) ::: x is a genre of music.\nHasSongIn(x, y) ::: x has songs in language y.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nClassifiedUnder(phoneix, indiePop) ::: Phoneix's music is classified under the indie pop genre.\nBand(phoenix) ∧ From(phoenix, france) ::: Phoenix is a band from France.\n∀x (Band(x) ∧ From(x, france) → (WriteIn(x, french) ∨ WriteIn(x, english))) ::: French bands write songs in French or in English.\nGenre(popRock) ∧ Genre(synthPop) ∧ ¬(Genre(indiePop) ∧ Genre(popRock) ∧ Genre(synthPop)) ::: Aside from indie pop, pop rock and synth-pop are two other genres of music.\n¬HasSongIn(phoneix, french) ::: Phoneix has no songs in French.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\nClassifiedUnder(phoenix, popRock) ::: Phoenix makes pop rock music.\n\"\"\""
    ]
  },
  {
    "id": 403,
    "context": [
      "Phoneix's music is classified under the indie pop genre.",
      "Phoenix is a band from France.",
      "French bands write songs in French or in English.",
      "Aside from indie pop, pop rock and synth-pop are two other genres of music.",
      "Phoneix has no songs in French."
    ],
    "question": "Phoenix has songs in French.",
    "answer": "B",
    "raw_logic_programs": [
      "First-Order-Logic Predicates:\n\"\"\"\nClassifiedUnder(x, y) ::: x's music is classified under genre y.\nBand(x) ::: x is a band.\nFrom(x, y) ::: x is from country y.\nWriteIn(x, y) ::: x writes songs in language y.\nGenre(x) ::: x is a genre of music.\n\"\"\"\nFirst-Order-Logic Premises:\n\"\"\"\nClassifiedUnder(phoneix, indiePop) ::: Phoneix's music is classified under the indie pop genre.\nBand(phoenix) ∧ From(phoenix, france) ::: Phoenix is a band from France.\n∀x (Band(x) ∧ From(x, france) → (WriteIn(x, french) ∨ WriteIn(x, english))) ::: French bands write songs in French or in English.\nGenre(popRock) ∧ Genre(synthPop) ∧ ¬(Genre(indiePop) ∧ Genre(popRock) ∧ Genre(synthPop)) ::: Aside from indie pop, pop rock and synth-pop are two other genres of music.\n¬WriteIn(phoneix, french) ::: Phoneix has no songs in French.\n\"\"\"\nFirst-Order-Logic Question:\n\"\"\"\n¬WriteIn(phoneix, french) ::: Phoenix has songs in French.\n\"\"\""
    ]
  }
]