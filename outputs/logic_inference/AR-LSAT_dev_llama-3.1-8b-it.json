[
  {
    "id": 39,
    "nl_problem": {
      "context": "Each of the seven members of the board of directors—Guzman, Hawking, Lepp, Miyauchi, Upchurch, Wharton, and Zhu—serves on exactly one of two committees—the finance committee or the incentives committee. Only board members serve on these committees. Committee membership is consistent with the following conditions: If Guzman serves on the finance committee, then Hawking serves on the incentives committee. If Lepp serves on the finance committee, then Miyauchi and Upchurch both serve on the incentives committee. Wharton serves on a different committee from the one on which Zhu serves. Upchurch serves on a different committee from the one on which Guzman serves. If Zhu serves on the finance committee, so does Hawking.",
      "question": "If Guzman serves on the incentives committee, then which one of the following must be true?",
      "options": [
        "A) Hawking serves on the finance committee.",
        "B) Lepp serves on the incentives committee.",
        "C) Miyauchi serves on the finance committee.",
        "D) Wharton serves on the incentives committee.",
        "E) Zhu serves on the finance committee."
      ]
    },
    "answer": "B",
    "logic_problem": {
      "program": "(set-logic ALL)\n\n; Declare sorts for people and committees\n(declare-datatypes ((People 0)) (((Guzman) (Hawking) (Lepp) (Miyauchi) (Upchurch) (Wharton) (Zhu))))\n(declare-datatypes ((Committees 0)) (((finance) (incentives))))\n\n; Declare the serves function\n(declare-fun serves (People Committees) Bool)\n\n; Helper function for counting - returns 1 if true, 0 if false\n(define-fun to-int ((b Bool)) Int\n  (ite b 1 0))\n\n; Constraint: each person serves on exactly one committee\n(assert (forall ((p People))\n    (= (+ (to-int (and (= (serves p finance) true) (serves p incentives)))\n          (to-int (and (= (serves p finance) false) (= (serves p incentives) false)))) 1)))\n\n; Constraint: If Guzman serves on the finance committee, then Hawking serves on the incentives committee\n(assert (=> (serves Guzman finance) (serves Hawking incentives)))\n\n; Constraint: If Lepp serves on the finance committee, then Miyauchi and Upchurch both serve on the incentives committee\n(assert (=> (serves Lepp finance)\n           (and (serves Miyauchi incentives)\n                (serves Upchurch incentives))))\n\n; Constraint: Wharton serves on a different committee from the one on which Zhu serves\n(assert (or (not (and (serves Wharton finance) (serves Zhu finance)))\n           (not (and (serves Wharton incentives) (serves Zhu incentives)))))\n\n; Constraint: Upchurch serves on a different committee from the one on which Guzman serves\n(assert (or (not (and (serves Upchurch finance) (serves Guzman finance)))\n           (not (and (serves Upchurch incentives) (serves Guzman incentives)))))\n\n; Constraint: If Zhu serves on the finance committee, so does Hawking\n(assert (=> (serves Zhu finance) (serves Hawking finance)))\n\n; Check each option\n(push)\n(assert (not (serves Guzman finance)))\n(assert (serves Guzman incentives))\n(assert (serves Hawking finance))\n(check-sat)\n(pop)\n\n(push)\n(assert (not (serves Guzman finance)))\n(assert (serves Guzman incentives))\n(assert (serves Lepp incentives))\n(check-sat)\n(pop)\n\n(push)\n(assert (not (serves Guzman finance)))\n(assert (serves Guzman incentives))\n(assert (serves Miyauchi finance))\n(check-sat)\n(pop)\n\n(push)\n(assert (not (serves Guzman finance)))\n(assert (serves Guzman incentives))\n(assert (serves Wharton incentives))\n(check-sat)\n(pop)\n\n(push)\n(assert (not (serves Guzman finance)))\n(assert (serves Guzman incentives))\n(assert (serves Zhu finance))\n(check-sat)\n(pop)\n\n(exit)",
      "type": "sat",
      "perplexity": [
        1.1213550567626953,
        1.0596306324005127
      ],
      "answer": "B",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "No Output"
    },
    "logic_problem_gcd": {
      "declarations": [
        "(declare-datatypes ((Committees 0)) (((finance) (incentives))))",
        "(declare-datatypes ((BoardMembers 0)) (((Guzman) (Hawking) (Lepp) (Miyauchi) (Upchurch) (Wharton) (Zhu))))",
        "(declare-fun serves (BoardMembers Committees) Bool)"
      ],
      "constraints": [
        "(forall ((b BoardMembers) (c Committees)) (=> (and (serves b finance) (serves Guzman finance)) (serves Hawking incentives)))",
        "(forall ((b BoardMembers) (c Committees)) (=> (and (serves b finance) (serves Lepp finance)) (and (serves Miyauchi incentives) (serves Upchurch incentives))))",
        "(forall ((b BoardMembers) (c Committees)) (=> (serves Wharton finance) (not (serves Zhu finance))))",
        "(forall ((b BoardMembers) (c Committees)) (=> (serves Upchurch finance) (not (serves Guzman finance))))",
        "(forall ((b BoardMembers) (c Committees)) (=> (and (serves Zhu finance) (serves b finance)) (serves Hawking finance)))",
        "(forall ((b BoardMembers)) (=> (serves b finance) (not (serves b incentives))))",
        "(forall ((b BoardMembers)) (=> (serves b incentives) (not (serves b finance))))",
        "(forall ((b BoardMembers)) (not (and (serves b finance) (serves b incentives))))",
        "(forall ((b BoardMembers)) (= (ite (serves b finance) 1 0) 1))",
        "(forall ((b BoardMembers)) (= (ite (serves b incentives) 1 0) 1))"
      ],
      "options": [
        "(not (exists ((c Committees)) (and (serves Guzman incentives) (serves Hawking finance))))",
        "(not (exists ((c Committees)) (and (serves Guzman incentives) (serves Lepp incentives))))",
        "(not (exists ((c Committees)) (and (serves Guzman incentives) (serves Miyauchi finance))))",
        "(not (exists ((c Committees)) (and (serves Guzman incentives) (serves Wharton incentives))))",
        "(not (exists ((c Committees)) (and (serves Guzman incentives) (serves Zhu finance))))"
      ],
      "type": "sat",
      "perplexity": 1.6445813179016113,
      "answer": "B",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "SyntaxError: invalid syntax. Perhaps you forgot a comma?"
    }
  },
  {
    "id": 0,
    "nl_problem": {
      "context": "Four boys—Fred, Juan, Marc, and Paul—and three girls—Nita, Rachel, and Trisha—will be assigned to a row of five adjacent lockers, numbered consecutively 1 through 5, arranged along a straight wall. The following conditions govern the assignment of lockers to the seven children: Each locker must be assigned to either one or two children, and each child must be assigned to exactly one locker. Each shared locker must be assigned to one girl and one boy. Juan must share a locker, but Rachel cannot share a locker. Nita's locker cannot be adjacent to Trisha's locker. Fred must be assigned to locker 3.",
      "question": "Which one of the following is a complete and accurate list of the children who must be among those assigned to shared lockers?",
      "options": [
        "A) Fred, Juan",
        "B) Juan, Paul",
        "C) Juan, Marc, Paul",
        "D) Juan, Marc, Trisha",
        "E) Juan, Nita, Trisha"
      ]
    },
    "answer": "E",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((Children 0)) (((Fred) (Juan) (Marc) (Paul) (Nita) (Rachel) (Trisha))))",
        "(declare-datatypes ((Lockers 0)) (((locker1) (locker2) (locker3) (locker4) (locker5))))",
        "(declare-datatypes ((Genders 0)) (((boy) (girl))))",
        "(declare-fun assigned (Children Lockers) Bool)",
        "(define-fun to-int ((b Bool)) Int (ite b 1 0))",
        "(declare-fun shared (Lockers) Bool)"
      ],
      "constraints": [
        "(forall ((l Lockers)) (or (not (assigned Fred l)) (not (assigned Juan l)) (not (assigned Marc l)) (not (assigned Paul l)) (not (assigned Nita l)) (not (assigned Rachel l)) (not (assigned Trisha l)) (let ((child1 (ite (assigned Fred l) Fred Juan)) (child2 (ite (and (assigned Fred l) (not (assigned Juan l))) Marc Paul))) (or (= (to-int (assigned child1 l)) 1) (= (to-int (assigned child1 l)) 1) (= (to-int (assigned child1 l)) 1) (= (to-int (assigned child1 l)) 1) (= (to-int (assigned child1 l)) 1) (= (to-int (assigned child1 l)) 1) (= (to-int (assigned child2 l)) 1)))))",
        "(forall ((c Children)) (not (or (assigned c locker1) (assigned c locker2) (assigned c locker3) (assigned c locker4) (assigned c locker5) (let ((l1 (ite (assigned c locker1) 1 0)) (l2 (ite (assigned c locker2) 1 0)) (l3 (ite (assigned c locker3) 1 0)) (l4 (ite (assigned c locker4) 1 0)) (l5 (ite (assigned c locker5) 1 0))) (= (+ l1 l2 l3 l4 l5) 1))))))",
        "(forall ((l Lockers)) (let ((shared1 (ite (assigned Juan l) 1 0)) (shared2 (ite (assigned Marc l) 1 0)) (shared3 (ite (assigned Paul l) 1 0)) (shared4 (ite (assigned Nita l) 1 0)) (shared5 (ite (assigned Rachel l) 1 0)) (shared6 (ite (assigned Trisha l) 1 0))) (or (= (shared l) 0) (and (not (shared l)) (= (to-int (ite (and (shared l) (= (to-int (assigned Nita l)) 1) (= (to-int (assigned Juan l)) 1)) (boy girl) (boy boy))) 1) (= (to-int (ite (and (shared l) (= (to-int (assigned Nita l)) 1) (= (to-int (assigned Juan l)) 1)) (boy girl) (boy boy))) 1) (= (to-int (ite (and (shared l) (= (to-int (assigned Nita l)) 1) (= (to-int (assigned Juan l)) 1)) (boy girl) (boy boy))) 1) (= (to-int (ite (and (shared l) (= (to-int (assigned Nita l)) 1) (= (to-int (assigned Juan l)) 1)) (boy girl) (boy boy))) 1) (= (to-int (ite (and (shared l) (= (to-int (assigned Nita l)) 1) (= (to-int (assigned Juan l)) 1)) (boy girl) (boy boy))) 1) (= (to-int (ite (and (shared l) (= (to-int (assigned Nita l)) 1) (= (to-int (assigned Juan l)) 1)) (boy girl) (boy boy))) 1)))))",
        "(shared locker2)",
        "(not (shared locker2))",
        "(not (shared locker3))",
        "(not (shared locker4))",
        "(not (shared locker5))",
        "(not (and (shared locker2) (shared locker3)))",
        "(assigned Fred locker3)",
        "(or (and (shared locker2) (shared locker3) (not (shared locker4)) (not (shared locker5)) (assigned Fred locker3) (assigned Juan locker2) (not (assigned Marc locker2)) (not (assigned Paul locker2))) (and (not (shared locker2)) (not (shared locker3)) (shared locker4) (not (shared locker5)) (assigned Fred locker3) (not (assigned Juan locker4)) (not (assigned Marc locker4)) (assigned Paul locker4)))",
        "(or (and (shared locker2) (not (shared locker3)) (shared locker4) (not (shared locker5)) (assigned Fred locker3) (assigned Juan locker2) (assigned Marc locker3) (assigned Paul locker3)) (and (not (shared locker2)) (not (shared locker3)) (not (shared locker4)) (shared locker5) (assigned Fred locker3) (assigned Juan locker5) (assigned Marc locker5) (not (assigned Paul locker5))))",
        "(or (and (shared locker2) (shared locker3) (not (shared locker4)) (shared locker5) (assigned Fred locker3) (assigned Juan locker2) (assigned Marc locker5) (assigned Paul locker3)) (and (not (shared locker2)) (not (shared locker3)) (not (shared locker4)) (not (shared locker5)) (assigned Fred locker3) (assigned Juan locker4) (not (assigned Marc locker4)) (assigned Paul locker4)))",
        "(or (and (shared locker2) (shared locker3) (not (shared locker4)) (shared locker5) (assigned Fred locker3) (assigned Juan locker2) (assigned Marc locker5) (assigned Trisha locker2)) (and (not (shared locker2)) (not (shared locker3)) (not (shared locker4)) (not (shared locker5)) (assigned Fred locker3) (assigned Juan locker4) (not (assigned Marc locker4)) (assigned Nita locker4)))",
        "(or (and (shared locker2) (not (shared locker3)) (not (shared locker4)) (shared locker5) (assigned Fred locker3) (assigned Juan locker2) (assigned Marc locker5) (assigned Nita locker2)) (and (not (shared locker2)) (not (shared locker3)) (not (shared locker4)) (shared locker5) (assigned Fred locker3) (assigned Juan locker5) (assigned Marc locker5) (assigned Trisha locker5)))"
      ],
      "options": [
        "(or (and (shared locker2) (shared locker3) (not (shared locker4)) (not (shared locker5)) (assigned Fred locker3) (assigned Juan locker2) (not (assigned Marc locker2)) (not (assigned Paul locker2))) (and (not (shared locker2)) (not (shared locker3)) (shared locker4) (not (shared locker5)) (assigned Fred locker3) (not (assigned Juan locker4)) (not (assigned Marc locker4)) (assigned Paul locker4)))",
        "(or (and (shared locker2) (not (shared locker3)) (shared locker4) (not (shared locker5)) (assigned Fred locker3) (assigned Juan locker2) (assigned Marc locker3) (assigned Paul locker3)) (and (not (shared locker2)) (not (shared locker3)) (not (shared locker4)) (shared locker5) (assigned Fred locker3) (assigned Juan locker5) (assigned Marc locker5) (not (assigned Paul locker5))))",
        "(or (and (shared locker2) (shared locker3) (not (shared locker4)) (shared locker5) (assigned Fred locker3) (assigned Juan locker2) (assigned Marc locker5) (assigned Paul locker3)) (and (not (shared locker2)) (not (shared locker3)) (not (shared locker4)) (not (shared locker5)) (assigned Fred locker3) (assigned Juan locker4) (not (assigned Marc locker4)) (assigned Paul locker4)))",
        "(or (and (shared locker2) (shared locker3) (not (shared locker4)) (shared locker5) (assigned Fred locker3) (assigned Juan locker2) (assigned Marc locker5) (assigned Trisha locker2)) (and (not (shared locker2)) (not (shared locker3)) (not (shared locker4)) (not (shared locker5)) (assigned Fred locker3) (assigned Juan locker4) (not (assigned Marc locker4)) (assigned Nita locker4)))",
        "(or (and (shared locker2) (not (shared locker3)) (not (shared locker4)) (shared locker5) (assigned Fred locker3) (assigned Juan locker2) (assigned Marc locker5) (assigned Nita locker2)) (and (not (shared locker2)) (not (shared locker3)) (not (shared locker4)) (shared locker5) (assigned Fred locker3) (assigned Juan locker5) (assigned Marc locker5) (assigned Trisha locker5)))"
      ],
      "type": "sat",
      "perplexity": [
        1.1485391855239868,
        1.0225040912628174
      ],
      "answer": "E",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "SyntaxError: unmatched ')'"
    }
  },
  {
    "id": 1,
    "nl_problem": {
      "context": "Four boys—Fred, Juan, Marc, and Paul—and three girls—Nita, Rachel, and Trisha—will be assigned to a row of five adjacent lockers, numbered consecutively 1 through 5, arranged along a straight wall. The following conditions govern the assignment of lockers to the seven children: Each locker must be assigned to either one or two children, and each child must be assigned to exactly one locker. Each shared locker must be assigned to one girl and one boy. Juan must share a locker, but Rachel cannot share a locker. Nita's locker cannot be adjacent to Trisha's locker. Fred must be assigned to locker 3.",
      "question": "If Trisha is assigned to locker 3 and Marc alone is assigned to locker 1, then which one of the following must be true?",
      "options": [
        "A) Juan is assigned to locker 4.",
        "B) Juan is assigned to locker 5.",
        "C) Paul is assigned to locker 2.",
        "D) Rachel is assigned to locker 2.",
        "E) Rachel is assigned to locker 5."
      ]
    },
    "answer": "B",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((Children 0)) (((Fred) (Juan) (Marc) (Paul) (Nita) (Rachel) (Trisha))))",
        "(declare-datatypes ((Lockers 0)) (((1) (2) (3) (4) (5))))",
        "(declare-datatypes ((Genders 0)) (((boy) (girl))))",
        "(declare-fun assigned (Children Lockers) (Genders Bool))"
      ],
      "constraints": [
        "(forall ((l Lockers)) (let ((p1 (assigned ?p1 l)) (p2 (assigned ?p2 l))) (= (ite p1 p2 (ite p2 p1 0)) 1)))",
        "(forall ((c Children)) (exists ((l Lockers)) (assigned c l)))",
        "(forall ((l Lockers)) (let ((p1 (assigned ?p1 l)) (p2 (assigned ?p2 l))) (and (ite p1 p2 (let ((g1 (gender ?p1)) (g2 (gender ?p2))) (ite (and (= g1 girl) (= g2 boy)) true false))) (ite p2 p1 (let ((g1 (gender ?p2)) (g2 (gender ?p1)) (g1 (gender ?p2)) (g2 (gender ?p1))) (ite (and (= g1 girl) (= g2 boy)) true false)))))",
        "(exists ((l Lockers)) (and (assigned Juan l) (not (assigned Rachel l))))",
        "(forall ((l Lockers)) (not (and (assigned ?p l) (assigned ?q l) (distinct ?p Rachel) (distinct ?q Rachel))))",
        "(forall ((l Lockers)) (let ((p1 (assigned Nita l)) (p2 (assigned Trisha l)) (l1 (ite (= l 1) 2 (ite (= l 5) 4 (ite (ite (< l 4) (< l (+ l 1)) (ite (> l 2) (> l (+ l -1))) l) (+ l 1))))) (l2 (ite (= l 2) 1 (ite (= l 4) 3 (ite (ite (< l 4) (< l (+ l 1)) (ite (> l 2) (> l (+ l -1))) l) (+ l 1)) 5))) (not (and p1 p2 (or (= l l1) (= l l2))))))",
        "(assigned Fred 3)",
        "(assigned Trisha 3)",
        "(forall ((l Lockers)) (not (assigned Marc l)) (ite (not (= l 1)) true (assigned Marc l)))"
      ],
      "options": [
        "(assigned Juan 4)",
        "(assigned Juan 5)",
        "(assigned Paul 2)",
        "(assigned Rachel 2)",
        "(assigned Rachel 5)"
      ],
      "type": "sat",
      "perplexity": [
        1.2838796377182007,
        1.0648943185806274
      ],
      "answer": "B",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "SyntaxError: invalid syntax. Perhaps you forgot a comma?"
    }
  },
  {
    "id": 2,
    "nl_problem": {
      "context": "Four boys—Fred, Juan, Marc, and Paul—and three girls—Nita, Rachel, and Trisha—will be assigned to a row of five adjacent lockers, numbered consecutively 1 through 5, arranged along a straight wall. The following conditions govern the assignment of lockers to the seven children: Each locker must be assigned to either one or two children, and each child must be assigned to exactly one locker. Each shared locker must be assigned to one girl and one boy. Juan must share a locker, but Rachel cannot share a locker. Nita's locker cannot be adjacent to Trisha's locker. Fred must be assigned to locker 3.",
      "question": "If the four boys are assigned to consecutively numbered lockers and Juan is assigned to locker 5, then which one of the following is a complete and accurate list of lockers each of which CANNOT be a shared locker?",
      "options": [
        "A) locker 2",
        "B) locker 4",
        "C) locker 1, locker 2",
        "D) locker 1, locker 4",
        "E) locker 2, locker 4"
      ]
    },
    "answer": "D",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((People 0)) (((Fred) (Juan) (Marc) (Paul) (Nita) (Rachel) (Trisha))))",
        "(declare-datatypes ((Lockers 0)) (((locker1) (locker2) (locker3) (locker4) (locker5))))",
        "(declare-fun assigns (People Lockers) Bool)"
      ],
      "constraints": [
        "(forall ((l Lockers)) (or (not (exists ((p People)) (and (assigns p l) (assigns p l)))) (exists ((p People) (q People)) (and (assigns p l) (assigns q l) (distinct p q)))))",
        "(forall ((p People)) (exists ((l Lockers)) (assigns p l)))",
        "(forall ((l Lockers) (p People) (q People)) (=> (and (assigns p l) (assigns q l) (distinct p q)) (or (and (and (member p '(Nita Rachel Trisha)) (member q '(Fred Juan Marc Paul))) (distinct (assigns p (locker1)) (assigns q (locker1))) (distinct (assigns p (locker1)) (assigns q (locker2))) (distinct (assigns p (locker2)) (assigns q (locker2))) (distinct (assigns p (locker1)) (assigns q (locker3))) (distinct (assigns p (locker3)) (assigns q (locker3))) (distinct (assigns p (locker2)) (assigns q (locker4))) (distinct (assigns p (locker4)) (assigns q (locker4))) (distinct (assigns p (locker3)) (assigns q (locker5))) (distinct (assigns p (locker5)) (assigns q (locker5)))))",
        "(exists ((p People) (q People)) (and (assigns p (locker5)) (assigns q (locker5)) (distinct p q) (or (and (member p '(Nita Rachel Trisha)) (member q '(Fred Juan Marc Paul))) (and (member p '(Fred Juan Marc Paul)) (member q '(Nita Rachel Trisha))))))",
        "(not (exists ((p People) (q People)) (and (assigns p (locker5)) (assigns q (locker5)) (distinct p q) (and (member p '(Nita Rachel Trisha)) (member q '(Nita Rachel Trisha)))))",
        "(not (or (and (assigns Nita (locker2)) (assigns Trisha (locker3))) (and (assigns Nita (locker3)) (assigns Trisha (locker2))) (and (assigns Nita (locker3)) (assigns Trisha (locker4))) (and (assigns Nita (locker4)) (assigns Trisha (locker3)))))",
        "(assigns Fred (locker3))"
      ],
      "options": [
        "(not (exists ((l Lockers)) (and (assigns Paul l) (assigns Juan l))))",
        "(not (exists ((l Lockers)) (and (assigns Paul l) (assigns Marc l))))",
        "(not (exists ((l Lockers)) (and (assigns Paul l) (assigns Fred l))))",
        "(not (exists ((l Lockers)) (and (assigns Juan l) (assigns Marc l))))",
        "(not (exists ((l Lockers)) (and (assigns Juan l) (assigns Fred l))))"
      ],
      "type": "unsat",
      "perplexity": [
        1.0472279787063599,
        1.0543460845947266
      ],
      "answer": "D",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "SyntaxError: invalid syntax. Perhaps you forgot a comma?"
    }
  },
  {
    "id": 3,
    "nl_problem": {
      "context": "Four boys—Fred, Juan, Marc, and Paul—and three girls—Nita, Rachel, and Trisha—will be assigned to a row of five adjacent lockers, numbered consecutively 1 through 5, arranged along a straight wall. The following conditions govern the assignment of lockers to the seven children: Each locker must be assigned to either one or two children, and each child must be assigned to exactly one locker. Each shared locker must be assigned to one girl and one boy. Juan must share a locker, but Rachel cannot share a locker. Nita's locker cannot be adjacent to Trisha's locker. Fred must be assigned to locker 3.",
      "question": "Once Rachel has been assigned to a locker, what is the maximum number of different lockers each of which could be the locker to which Juan is assigned?",
      "options": [
        "A) one",
        "B) two",
        "C) three",
        "D) four",
        "E) five"
      ]
    },
    "answer": "C",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((Children 0)) (((Fred) (Juan) (Marc) (Paul) (Nita) (Rachel) (Trisha)))",
        "(declare-datatypes ((Lockers 0)) (((locker1) (locker2) (locker3) (locker4) (locker5)))",
        "(declare-fun assigns (Children Lockers) Bool)",
        "(define-fun to-int ((b Bool)) Int (ite b 1 0))"
      ],
      "constraints": [
        "(forall ((l Lockers)) (let ((c1 (to-int (exists ((c Children)) (assigns c l)))) (c2 (to-int (exists ((c1 c2 Children)) (and (assigns c1 l) (assigns c2 l))))) (c3 (to-int (exists ((c1 c2 c3 Children)) (and (assigns c1 l) (assigns c2 l) (assigns c3 l))))) (c4 (to-int (exists ((c1 c2 c3 c4 Children)) (and (assigns c1 l) (assigns c2 l) (assigns c3 l) (assigns c4 l))))) (or (= c1 1) (= c2 1) (= c3 1) (= c4 1))))",
        "(forall ((c Children)) (= (+ (to-int (assigns c locker1)) (to-int (assigns c locker2)) (to-int (assigns c locker3)) (to-int (assigns c locker4)) (to-int (assigns c locker5))) 1))",
        "(forall ((l Lockers)) (let ((g (to-int (exists ((g Children)) (and (member g '(Nita Rachel Trisha)) (assigns g l)))) (b (to-int (exists ((b Children)) (and (member b '(Fred Juan Marc Paul)) (assigns b l)))) (gb (to-int (exists ((g b Children)) (and (member g '(Nita Rachel Trisha)) (member b '(Fred Juan Marc Paul)) (assigns g l) (assigns b l))))) (= (+ g b gb) 1)))",
        "(exists ((g Children)) (and (member g '(Nita Rachel Trisha)) (exists ((b Children)) (and (member b '(Fred Juan Marc Paul)) (assigns g locker2) (assigns b locker2))))",
        "(forall ((l Lockers)) (not (exists ((g b Children)) (and (member g '(Nita Rachel Trisha)) (member b '(Fred Juan Marc Paul)) (assigns g l) (assigns b l))))",
        "(forall ((l1 Lockers) (l2 Lockers)) (or (= l1 l2) (not (and (assigns Nita l1) (assigns Trisha l2) (or (= (+ abs (- (ite (equal l1 locker3) 1 0) (ite (equal l2 locker3) 1 0)) 0) 1) (= (+ abs (- (ite (equal l1 locker1) 1 0) (ite (equal l2 locker5) 1 0)) 0) 1)))))",
        "(assigns Fred locker3)",
        "(exists ((r Lockers)) (assigns Rachel r))"
      ],
      "options": [
        "5"
      ],
      "type": "sat",
      "perplexity": [
        1.2050117254257202,
        1.0550175905227661
      ],
      "answer": "C",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "SyntaxError: invalid syntax. Perhaps you forgot a comma?"
    }
  },
  {
    "id": 4,
    "nl_problem": {
      "context": "Four boys—Fred, Juan, Marc, and Paul—and three girls—Nita, Rachel, and Trisha—will be assigned to a row of five adjacent lockers, numbered consecutively 1 through 5, arranged along a straight wall. The following conditions govern the assignment of lockers to the seven children: Each locker must be assigned to either one or two children, and each child must be assigned to exactly one locker. Each shared locker must be assigned to one girl and one boy. Juan must share a locker, but Rachel cannot share a locker. Nita's locker cannot be adjacent to Trisha's locker. Fred must be assigned to locker 3.",
      "question": "If the first three lockers are assigned to girls, which one of the following must be true?",
      "options": [
        "A) Juan is assigned to locker 1.",
        "B) Nita is assigned to locker 3.",
        "C) Trisha is assigned to locker 1.",
        "D) Juan is assigned to the same locker as Trisha.",
        "E) Paul is assigned to the same locker as Trisha."
      ]
    },
    "answer": "A",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((Lockers 0)) (((1) (2) (3) (4) (5))))",
        "(declare-datatypes ((People 0)) (((Fred) (Juan) (Marc) (Paul) (Nita) (Rachel) (Trisha)))",
        "(declare-fun assigned (Lockers People) Bool)",
        "(define-fun to-int ((b Bool)) Int (ite b 1 0))"
      ],
      "constraints": [
        "(forall ((l Lockers)) (=> (not (= (to-int (assigned l Juan)) 0)) (= (to-int (assigned l Nita)) 0)) (=> (not (= (to-int (assigned l Nita)) 0)) (= (to-int (assigned l Juan)) 0)))",
        "(forall ((p People)) (= (or (assigned 1 p) (assigned 2 p) (assigned 3 p) (assigned 4 p) (assigned 5 p)) 1))",
        "(forall ((l Lockers)) (let ((g (ite (ite (ite (ite (= l 1) (= l 2) (= l 3) (= l 4)) (= l 5)) 1) (= l 1)) (ite (ite (ite (ite (= l 1) (= l 2) (= l 3) (= l 4)) (= l 5)) 1) (= l 1)) (ite (ite (ite (ite (= l 1) (= l 2) (= l 3) (= l 4)) (= l 5)) 1) (= l 1)) (ite (ite (ite (ite (= l 1) (= l 2) (= l 3) (= l 4)) (= l 5)) 1) (= l 1)) (ite (ite (ite (ite (= l 1) (= l 2) (= l 3) (= l 4)) (= l 5)) 1) (= l 1))) (b (ite (ite (ite (ite (= l 1) (= l 2) (= l 3) (= l 4)) (= l 5)) 1) (= l 1)) (ite (ite (ite (ite (= l 1) (= l 2) (= l 3) (= l 4)) (= l 5)) 1) (= l 1)) (ite (ite (ite (ite (= l 1) (= l 2) (= l 3) (= l 4)) (= l 5)) 1) (= l 1)) (ite (ite (ite (ite (= l 1) (= l 2) (= l 3) (= l 4)) (= l 5)) 1) (= l 1)) (ite (ite (ite (ite (= l 1) (= l 2) (= l 3) (= l 4)) (= l 5)) 1) (= l 1))))) (=> (exists ((g Girl) (b Boy)) (= (assigned l g) (assigned l b))) (= (exists ((g Girl) (b Boy)) (= (assigned l g) (assigned l b))) 1)))",
        "(exists ((g Girl) (b Boy)) (and (not (= g Nita)) (not (= g Rachel)) (not (= b Fred)) (not (= b Marc)) (not (= b Paul)) (assigned 1 (and g b))))",
        "(forall ((l Lockers)) (let ((g (ite (ite (ite (ite (= l 1) (= l 2) (= l 3) (= l 4)) (= l 5)) 1) (= l 1)) (ite (ite (ite (ite (= l 1) (= l 2) (= l 3) (= l 4)) (= l 5)) 1) (= l 1)) (ite (ite (ite (ite (= l 1) (= l 2) (= l 3) (= l 4)) (= l 5)) 1) (= l 1)) (ite (ite (ite (ite (= l 1) (= l 2) (= l 3) (= l 4)) (= l 5)) 1) (= l 1)) (ite (ite (ite (ite (= l 1) (= l 2) (= l 3) (= l 4)) (= l 5)) 1) (= l 1))) (g (ite (ite (ite (ite (= l 1) (= l 2) (= l 3) (= l 4)) (= l 5)) 1) (= l 1)) (ite (ite (ite (ite (= l 1) (= l 2) (= l 3) (= l 4)) (= l 5)) 1) (= l 1)) (ite (ite (ite (ite (= l 1) (= l 2) (= l 3) (= l 4)) (= l 5)) 1) (= l 1)) (ite (ite (ite (ite (= l 1) (= l 2) (= l 3) (= l 4)) (= l 5)) 1) (= l 1)) (ite (ite (ite (ite (= l 1) (= l 2) (= l 3) (= l 4)) (= l 5)) 1) (= l 1))))) (=> (exists ((g Girl) (b Boy)) (= (assigned l g) (assigned l b))) (not (= g Rachel))))",
        "(forall ((l Lockers)) (=> (and (= (assigned (ite (ite (ite (ite (= l 1) (= l 2) (= l 3) (= l 4)) (= l 5)) 1) (= l 1)) Nita) (= (assigned (ite (ite (ite (ite (= l 1) (= l 2) (= l 3) (= l 4)) (= l 5)) 1) (= l 1)) Trisha) (= l (ite (ite (ite (ite (= l 1) (= l 2) (= l 3) (= l 4)) (= l 5)) 1) (= l 1))))) (not (= l (ite (ite (ite (ite (= l 1) (= l 2) (= l 3) (= l 4)) (= l 5)) 1) (= l 1)))))",
        "(assigned 3 Fred)"
      ],
      "options": [
        "(assigned 1 Juan)",
        "(assigned 3 Nita)",
        "(assigned 1 Trisha)",
        "(and (assigned 1 Juan) (= (assigned 1 Trisha)))",
        "(and (assigned 1 Trisha) (assigned 1 Paul))"
      ],
      "type": "unsat",
      "perplexity": [
        1.1793639659881592,
        1.0341565608978271
      ],
      "answer": "A",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "SyntaxError: invalid syntax. Perhaps you forgot a comma?"
    }
  },
  {
    "id": 5,
    "nl_problem": {
      "context": "Four boys—Fred, Juan, Marc, and Paul—and three girls—Nita, Rachel, and Trisha—will be assigned to a row of five adjacent lockers, numbered consecutively 1 through 5, arranged along a straight wall. The following conditions govern the assignment of lockers to the seven children: Each locker must be assigned to either one or two children, and each child must be assigned to exactly one locker. Each shared locker must be assigned to one girl and one boy. Juan must share a locker, but Rachel cannot share a locker. Nita's locker cannot be adjacent to Trisha's locker. Fred must be assigned to locker 3.",
      "question": "If lockers 1 and 2 are each assigned to one boy and are not shared lockers, then locker 4 must be assigned to",
      "options": [
        "A) Juan",
        "B) Paul",
        "C) Rachel",
        "D) Juan and Nita",
        "E) Marc and Trisha"
      ]
    },
    "answer": "C",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((Children 0)) (((Fred) (Juan) (Marc) (Paul) (Nita) (Rachel) (Trisha))))",
        "(declare-datatypes ((Lockers 0)) (((locker_1) (locker_2) (locker_3) (locker_4) (locker_5))))",
        "(declare-fun assigned (Children Lockers) Bool)",
        "(define-fun to-int ((b Bool)) Int (ite b 1 0))"
      ],
      "constraints": [
        "(forall ((l Lockers)) (= (+ (to-int (assigned Fred l)) (to-int (assigned Juan l)) (to-int (assigned Marc l)) (to-int (assigned Paul l)) (to-int (assigned Nita l)) (to-int (assigned Rachel l)) (to-int (assigned Trisha l))) 1))",
        "(forall ((c Children)) (= (+ (to-int (assigned c locker_1)) (to-int (assigned c locker_2)) (to-int (assigned c locker_3)) (to-int (assigned c locker_4)) (to-int (assigned c locker_5))) 1))",
        "(forall ((l Lockers)) (=> (and (= (to-int (assigned Fred l)) 1) (= (to-int (assigned Juan l)) 1)) (and (= (to-int (assigned Nita l)) 1) (= (to-int (assigned Rachel l)) 0))) (=> (and (= (to-int (assigned Juan l)) 1) (= (to-int (assigned Paul l)) 1)) (and (= (to-int (assigned Nita l)) 0) (= (to-int (assigned Trisha l)) 1))) (=> (and (= (to-int (assigned Marc l)) 1) (= (to-int (assigned Trisha l)) 1)) (and (= (to-int (assigned Rachel l)) 0) (= (to-int (assigned Paul l)) 0)))))",
        "(or (exists ((l Lockers)) (and (= (to-int (assigned Juan l)) 1) (= (to-int (assigned Nita l)) 1))) (exists ((l Lockers)) (and (= (to-int (assigned Juan l)) 1) (= (to-int (assigned Trisha l)) 1))) (not (exists ((l Lockers)) (and (= (to-int (assigned Rachel l)) 1) (= (to-int (_ l)) 1)))))",
        "(not (or (= (to-int (assigned Nita locker_1)) 1 (to-int (assigned Trisha locker_1)) 1) (= (to-int (assigned Nita locker_1)) 1 (to-int (assigned Trisha locker_5)) 1) (= (to-int (assigned Nita locker_5)) 1 (to-int (assigned Trisha locker_1)) 1) (= (to-int (assigned Nita locker_5)) 1 (to-int (assigned Trisha locker_5)) 1)))",
        "(= (to-int (assigned Fred locker_3)) 1)"
      ],
      "options": [
        "(not (exists ((l Lockers)) (= (and (assigned (if l locker_1 then Fred else Juan) l) (assigned (if l locker_2 then Fred else Juan) l)) (and (assigned (if l locker_4 then Fred else Juan) l) (assigned (if l locker_4 then Fred else Juan) l)))))",
        "(not (exists ((l Lockers)) (= (and (assigned (if l locker_1 then Fred else Juan) l) (assigned (if l locker_2 then Fred else Juan) l)) (and (assigned (if l locker_4 then Fred else Juan) l) (assigned (if l locker_4 then Fred else Paul) l)))))",
        "(not (exists ((l Lockers)) (= (and (assigned (if l locker_1 then Fred else Juan) l) (assigned (if l locker_2 then Fred else Juan) l)) (and (assigned (if l locker_4 then Fred else Juan) l) (assigned (if l locker_4 then Fred else Rachel) l)))))",
        "(not (exists ((l Lockers)) (= (and (assigned (if l locker_1 then Fred else Juan) l) (assigned (if l locker_2 then Fred else Juan) l)) (and (assigned (if l locker_4 then Fred else Juan) l) (assigned (if l locker_4 then Fred else Juan) l)))))",
        "(not (exists ((l Lockers)) (= (and (assigned (if l locker_1 then Fred else Juan) l) (assigned (if l locker_2 then Fred else Juan) l)) (and (assigned (if l locker_4 then Fred else Juan) l) (assigned (if l locker_4 then Fred else Nita) l)))))",
        "(not (exists ((l Lockers)) (= (and (assigned (if l locker_1 then Fred else Juan) l) (assigned (if l locker_2 then Fred else Juan) l)) (and (assigned (if l locker_4 then Fred else Juan) l) (assigned (if l locker_4 then Fred else Trisha) l)))))",
        "(not (exists ((l Lockers)) (= (and (assigned (if l locker_1 then Fred else Juan) l) (assigned (if l locker_2 then Fred else Juan) l)) (and (= (to-int (assigned (if l locker_4 then Fred else Juan) l)) 1) (= (to-int (assigned (if l locker_4 then Fred else Juan) l)) 1))))))"
      ],
      "type": "unsat",
      "perplexity": [
        1.08984375,
        1.0402041673660278
      ],
      "answer": "C",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "SyntaxError: unmatched ')'"
    }
  },
  {
    "id": 6,
    "nl_problem": {
      "context": "A music store carries exactly ten types of CDs—both new and used of each of jazz, opera, pop, rap, and soul. The store is having a sale on some of these types of CDs. The following conditions must apply: Used pop is on sale; new opera is not. If both types of pop are on sale, then all soul is. If both types of jazz are on sale, then no rap is. If neither type of jazz is on sale, then new pop is. If either type of rap is on sale, then no soul is.",
      "question": "Which one of the following could be a complete and accurate list of the types of CDs that are on sale?",
      "options": [
        "A) new jazz, used jazz, used opera, used pop, new rap",
        "B) new jazz, used pop, used rap, new soul",
        "C) used opera, used pop, new rap, used rap",
        "D) used opera, new pop, used pop, new soul",
        "E) used jazz, used pop, new soul, used soul"
      ]
    },
    "answer": "E",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((CDs 0)) (((jazz_new) (jazz_used) (opera_new) (opera_used) (pop_new) (pop_used) (rap_new) (rap_used) (soul_new) (soul_used))))",
        "(declare-fun on-sale (CDs) Bool)",
        "(define-fun to-int ((b Bool)) Int (ite b 1 0))"
      ],
      "constraints": [
        "(on-sale pop_used)",
        "(not (on-sale opera_new))",
        "=> (and (on-sale pop_new) (on-sale pop_used)) (and (on-sale soul_new) (on-sale soul_used))",
        "=> (and (on-sale jazz_new) (on-sale jazz_used)) (not (or (on-sale rap_new) (on-sale rap_used)))",
        "=> (not (or (on-sale jazz_new) (on-sale jazz_used))) (on-sale pop_new)",
        "=> (or (on-sale rap_new) (on-sale rap_used)) (not (or (on-sale soul_new) (on-sale soul_used)))"
      ],
      "options": [
        "(and (on-sale jazz_new) (on-sale jazz_used) (not (on-sale opera_used)) (on-sale pop_used) (not (or (on-sale rap_new) (on-sale rap_used))))",
        "(and (on-sale jazz_new) (not (on-sale pop_used)) (not (on-sale rap_used)) (on-sale soul_new))",
        "(and (not (on-sale jazz_used)) (not (on-sale opera_new)) (not (on-sale rap_new)) (on-sale used_pop) (not (on-sale used_soul)))",
        "(and (not (on-sale opera_used)) (on-sale pop_new) (on-sale used_pop) (not (on-sale used_soul)))",
        "(and (on-sale jazz_used) (on-sale used_pop) (not (on-sale used_soul)))"
      ],
      "type": "sat",
      "perplexity": [
        1.1228500604629517,
        1.0833368301391602
      ],
      "answer": "E",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "SyntaxError: invalid syntax. Perhaps you forgot a comma?"
    }
  },
  {
    "id": 7,
    "nl_problem": {
      "context": "A music store carries exactly ten types of CDs—both new and used of each of jazz, opera, pop, rap, and soul. The store is having a sale on some of these types of CDs. The following conditions must apply: Used pop is on sale; new opera is not. If both types of pop are on sale, then all soul is. If both types of jazz are on sale, then no rap is. If neither type of jazz is on sale, then new pop is. If either type of rap is on sale, then no soul is.",
      "question": "If new soul is not on sale, then which one of the following must be true?",
      "options": [
        "A) New rap is not on sale.",
        "B) New rap is on sale.",
        "C) Used opera is not on sale.",
        "D) At least one type of jazz is not on sale.",
        "E) At least one type of pop is not on sale."
      ]
    },
    "answer": "E",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((CDTypes 0)) (((jazz) (opera) (pop) (rap) (soul))))",
        "(declare-fun on-sale (CDTypes) Bool)"
      ],
      "constraints": [
        "(on-sale pop)",
        "(not (on-sale opera))",
        "(forall ((p1 Bool) (p2 Bool)) (=> (and (on-sale pop) (on-sale (pop))) (on-sale soul)))",
        "(forall ((j1 Bool) (j2 Bool)) (=> (and (on-sale (jazz)) (on-sale (jazz))) (not (on-sale rap))))",
        "(forall ((j1 Bool) (j2 Bool)) (=> (and (not (on-sale (jazz))) (not (on-sale (jazz)))) (on-sale pop)))",
        "(forall ((r1 Bool) (r2 Bool)) (=> (or (on-sale rap) (on-sale rap)) (not (on-sale soul))))",
        "(not (on-sale (soul)))",
        "(not (on-sale (rap)))"
      ],
      "options": [
        "(not (on-sale (soul)))",
        "(on-sale (rap))",
        "(not (on-sale (opera)))",
        "(exists ((j CDTypes) (j2 CDTypes)) (and (not (on-sale j)) (not (on-sale j2))))",
        "(exists ((p CDTypes) (p2 CDTypes)) (and (not (on-sale p)) (not (on-sale p2))))"
      ],
      "type": "unsat",
      "perplexity": [
        1.1995501518249512,
        1.1124298572540283
      ],
      "answer": "E",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "SyntaxError: invalid syntax. Perhaps you forgot a comma?"
    }
  },
  {
    "id": 8,
    "nl_problem": {
      "context": "A music store carries exactly ten types of CDs—both new and used of each of jazz, opera, pop, rap, and soul. The store is having a sale on some of these types of CDs. The following conditions must apply: Used pop is on sale; new opera is not. If both types of pop are on sale, then all soul is. If both types of jazz are on sale, then no rap is. If neither type of jazz is on sale, then new pop is. If either type of rap is on sale, then no soul is.",
      "question": "If both types of jazz are on sale, then which one of the following is the minimum number of types of new CDs that could be included in the sale?",
      "options": [
        "A) one",
        "B) two",
        "C) three",
        "D) four",
        "E) five"
      ]
    },
    "answer": "A",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((CDs 0)) (((jazz_new) (jazz_used) (opera_new) (opera_used) (pop_new) (pop_used) (rap_new) (rap_used) (soul_new) (soul_used))))",
        "(declare-datatypes ((SaleStatus 0)) (((new) (used))))",
        "(declare-fun on_sale (CDs SaleStatus) Bool)",
        "(define-fun to-int ((b Bool)) Int (ite b 1 0))"
      ],
      "constraints": [
        "(on_sale pop_used new)",
        "(not (on_sale opera_new new))",
        "(forall ((s SaleStatus)) (=> (and (on_sale pop_new new) (on_sale pop_used new)) (and (on_sale soul_new s) (on_sale soul_used s))))",
        "(forall ((s SaleStatus)) (=> (and (on_sale jazz_new new) (on_sale jazz_used new)) (not (on_sale rap_new s) (not (on_sale rap_used s)))))",
        "(forall ((s SaleStatus)) (=> (and (not (on_sale jazz_new new)) (not (on_sale jazz_used new))) (on_sale pop_new s)))",
        "(forall ((s SaleStatus)) (=> (or (on_sale rap_new s) (on_sale rap_used s)) (not (on_sale soul_new s) (not (on_sale soul_used s)))))"
      ],
      "options": [
        "(not (exists ((c CDs)) (and (on_sale (if jazz_new c jazz_used) new) (on-sale (if jazz_new c jazz_used) used) (not (exists ((c2 CDs)) (and (on_sale (if new c2 new) new) (on_sale (if new c2 new) used)))))))",
        "(not (exists ((c CDs)) (and (on_sale (if new c new) new) (on_sale (if new c new) used) (not (exists ((c2 CDs)) (and (on_sale (if new c2 new) new) (on_sale (if new c2 new) used)))))))",
        "(not (exists ((c CDs)) (and (on_sale (if new c new) new) (on_sale (if new c new) used) (not (exists ((c2 CDs)) (and (on_sale (if new c2 new) new) (on_sale (if new c2 new) used)))))))",
        "(not (exists ((c CDs)) (and (on_sale (if new c new) new) (on_sale (if new c new) used) (not (exists ((c2 CDs)) (and (on_sale (if new c2 new) new) (on_sale (if new c2 new) used)))))))",
        "(not (exists ((c CDs)) (and (on_sale (if new c new) new) (on_sale (if new c new) used) (not (exists ((c2 CDs)) (and (on_sale (if new c2 new) new) (on_sale (if new c2 new) used)))))))"
      ],
      "type": "sat",
      "perplexity": [
        1.1278038024902344,
        1.0595537424087524
      ],
      "answer": "A",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "SyntaxError: invalid syntax. Perhaps you forgot a comma?"
    }
  },
  {
    "id": 9,
    "nl_problem": {
      "context": "A music store carries exactly ten types of CDs—both new and used of each of jazz, opera, pop, rap, and soul. The store is having a sale on some of these types of CDs. The following conditions must apply: Used pop is on sale; new opera is not. If both types of pop are on sale, then all soul is. If both types of jazz are on sale, then no rap is. If neither type of jazz is on sale, then new pop is. If either type of rap is on sale, then no soul is.",
      "question": "Which one of the following CANNOT be true?",
      "options": [
        "A) Neither type of opera and neither type of rap is on sale.",
        "B) Neither type of jazz and neither type of opera is on sale.",
        "C) Neither type of opera and neither type of soul is on sale.",
        "D) Neither type of jazz and neither type of soul is on sale.",
        "E) Neither type of jazz and neither type of rap is on sale."
      ]
    },
    "answer": "D",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((CDTypes 0)) (((jazz) (opera) (pop) (rap) (soul))))",
        "(declare-fun on-sale (CDTypes) Bool)",
        "(define-fun to-int ((b Bool)) Int (ite b 1 0))"
      ],
      "constraints": [
        "(on-sale pop)",
        "(not (on-sale opera))",
        "(/= (and (on-sale (pop_used)) (on-sale (pop_new))) (on-sale soul))",
        "(/= (and (on-sale (jazz_used)) (on-sale (jazz_new))) (not (on-sale rap)))",
        "(=> (and (not (on-sale (jazz_used))) (not (on-sale (jazz_new)))) (on-sale (pop_new)))",
        "(/= (or (on-sale (rap_used)) (on-sale (rap_new))) (not (on-sale soul)))",
        "(not (and (not (on-sale opera)) (not (on-sale rap))))",
        "(not (and (not (on-sale jazz)) (not (on-sale opera))))",
        "(not (and (not (on-sale opera)) (not (on-sale soul))))",
        "(not (and (not (on-sale jazz)) (not (on-sale soul))))",
        "(not (and (not (on-sale jazz)) (not (on-sale rap))))"
      ],
      "options": [
        "(not (and (not (on-sale opera)) (not (on-sale rap))))",
        "(not (and (not (on-sale jazz)) (not (on-sale opera))))",
        "(not (and (not (on-sale opera)) (not (on-sale soul))))",
        "(not (and (not (on-sale jazz)) (not (on-sale soul))))",
        "(not (and (not (on-sale jazz)) (not (on-sale rap))))"
      ],
      "type": [
        {
          "option": "(not (and (not (on-sale opera)) (not (on-sale rap))))",
          "type": "sat"
        },
        {
          "option": "(not (and (not (on-sale jazz)) (not (on-sale opera))))",
          "type": "sat"
        },
        {
          "option": "(not (and (not (on-sale opera)) (not (on-sale soul))))",
          "type": "unsat"
        },
        {
          "option": "(not (and (not (on-sale jazz)) (not (on-sale soul))))",
          "type": "unsat"
        },
        {
          "option": "(not (and (not (on-sale jazz)) (not (on-sale rap))))",
          "type": "unsat"
        }
      ],
      "perplexity": [
        1.0918631553649902,
        1.0971059799194336
      ],
      "answer": "D",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "SyntaxError: invalid syntax. Perhaps you forgot a comma?"
    }
  },
  {
    "id": 10,
    "nl_problem": {
      "context": "A music store carries exactly ten types of CDs—both new and used of each of jazz, opera, pop, rap, and soul. The store is having a sale on some of these types of CDs. The following conditions must apply: Used pop is on sale; new opera is not. If both types of pop are on sale, then all soul is. If both types of jazz are on sale, then no rap is. If neither type of jazz is on sale, then new pop is. If either type of rap is on sale, then no soul is.",
      "question": "If neither type of jazz is on sale, then each of the following must be true EXCEPT:",
      "options": [
        "A) Used opera is on sale.",
        "B) New rap is not on sale.",
        "C) Used rap is not on sale.",
        "D) New soul is on sale.",
        "E) Used soul is on sale."
      ]
    },
    "answer": "A",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((CDTypes 0)) (((jazz) (opera) (pop) (rap) (soul))))",
        "(declare-fun on_sale (CDTypes) Bool)"
      ],
      "constraints": [
        "(on_sale pop)",
        "(not (on_sale (ite true opera false)))",
        "(forall ((m CDTypes)) (=> (and (on_sale pop) (on_sale (ite true pop false))) (on_sale (ite true soul false))))",
        "(forall ((m CDTypes)) (=> (and (on_sale jazz) (on_sale (ite true jazz false))) (not (on_sale (ite true rap false)))))",
        "(forall ((m CDTypes)) (=> (not (and (on_sale jazz) (on_sale (ite true jazz false)))) (on_sale (ite true pop false))))",
        "(forall ((m CDTypes)) (=> (or (on_sale rap) (on_sale (ite true rap false))) (not (on_sale (ite true soul false)))))"
      ],
      "options": [
        "(not (on_sale (ite true opera false)))",
        "(on_sale (ite true jazz false))",
        "(on_sale (ite true pop false))",
        "(not (on_sale (ite true rap false)))",
        "(on_sale (ite true soul false))"
      ],
      "type": "unsat",
      "perplexity": [
        1.1229333877563477,
        1.1445057392120361
      ],
      "answer": "A",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "SyntaxError: invalid syntax. Perhaps you forgot a comma?"
    }
  },
  {
    "id": 11,
    "nl_problem": {
      "context": "A music store carries exactly ten types of CDs—both new and used of each of jazz, opera, pop, rap, and soul. The store is having a sale on some of these types of CDs. The following conditions must apply: Used pop is on sale; new opera is not. If both types of pop are on sale, then all soul is. If both types of jazz are on sale, then no rap is. If neither type of jazz is on sale, then new pop is. If either type of rap is on sale, then no soul is.",
      "question": "If new soul is the only type of new CD on sale, then which one of the following CANNOT be true?",
      "options": [
        "A) Used jazz is not on sale.",
        "B) Used opera is not on sale.",
        "C) Used rap is not on sale.",
        "D) Used soul is on sale.",
        "E) Used soul is not on sale."
      ]
    },
    "answer": "A",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((CDTypes 0)) (((jazz) (opera) (pop) (rap) (soul))))",
        "(declare-fun on-sale (CDTypes) Bool)",
        "(define-fun to-int ((b Bool)) Int (ite b 1 0))"
      ],
      "constraints": [
        "(on-sale pop)",
        "(not (on-sale (distinct pop opera)))",
        "(forall ((m CDTypes)) (=> (= (on-sale pop) (on-sale (distinct pop opera))) (on-sale soul)))",
        "(forall ((m CDTypes)) (=> (= (on-sale (distinct jazz opera)) (on-sale (distinct jazz (distinct opera rap)))) (not (on-sale rap))))",
        "(forall ((m CDTypes)) (=> (not (on-sale (distinct jazz opera))) (on-sale (distinct new pop))))",
        "(forall ((m CDTypes)) (=> (or (on-sale (distinct jazz opera)) (on-sale (distinct (distinct jazz opera) rap))) (not (on-sale soul))))",
        "(= (+ (to-int (on-sale new jazz)) (to-int (on-sale new opera)) (to-int (on-sale new pop)) (to-int (on-sale new rap)) (to-int (on-sale new soul))) 1)"
      ],
      "options": [
        "(not (on-sale (distinct used jazz)))",
        "(not (on-sale (distinct used opera)))",
        "(not (on-sale (distinct used rap)))",
        "(on-sale (distinct used soul))",
        "(not (on-sale (distinct used soul)))"
      ],
      "type": "unsat",
      "perplexity": [
        1.1552857160568237,
        1.109891653060913
      ],
      "answer": "A",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "SyntaxError: invalid syntax. Perhaps you forgot a comma?"
    }
  },
  {
    "id": 12,
    "nl_problem": {
      "context": "A music store carries exactly ten types of CDs—both new and used of each of jazz, opera, pop, rap, and soul. The store is having a sale on some of these types of CDs. The following conditions must apply: Used pop is on sale; new opera is not. If both types of pop are on sale, then all soul is. If both types of jazz are on sale, then no rap is. If neither type of jazz is on sale, then new pop is. If either type of rap is on sale, then no soul is.",
      "question": "If exactly four of the five types of used CDs are the only CDs on sale, then which one of the following could be true?",
      "options": [
        "A) Used jazz is not on sale.",
        "B) Used opera is not on sale.",
        "C) Used rap is not on sale.",
        "D) Neither type of jazz is on sale.",
        "E) Neither type of rap and neither type of soul is on sale."
      ]
    },
    "answer": "C",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((CDTypes 0)) (((jazz) (opera) (pop) (rap) (soul))))",
        "(declare-datatypes ((CDStatus 0)) (((new) (used))))",
        "(declare-fun on-sale (CDStatus CDTypes) Bool)",
        "(define-fun to-int ((b Bool)) Int (ite b 1 0))"
      ],
      "constraints": [
        "(on-sale used pop)",
        "(not (on-sale new opera))",
        "(forall ((s1 CDStatus) (s2 CDStatus)) (=> (and (on-sale s1 pop) (on-sale s2 pop)) (on-sale s1 soul)))",
        "(forall ((s1 CDStatus) (s2 CDStatus)) (=> (and (on-sale s1 jazz) (on-sale s2 jazz)) (not (on-sale s1 rap))))",
        "(forall ((s1 CDStatus) (s2 CDStatus)) (=> (and (not (on-sale s1 jazz)) (not (on-sale s2 jazz))) (on-sale s1 pop)))",
        "(forall ((s1 CDStatus) (s2 CDStatus)) (=> (or (on-sale s1 rap) (on-sale s2 rap)) (not (on-sale s1 soul))))",
        "(= (+ (to-int (on-sale used jazz)) (to-int (on-sale used opera)) (to-int (on-sale used pop)) (to-int (on-sale used rap)) (to-int (on-sale used soul))) 4)"
      ],
      "options": [
        "(not (on-sale used jazz))",
        "(not (on-sale used opera))",
        "(not (on-sale used rap))",
        "(not (or (on-sale used jazz) (on-sale used rap)))",
        "(not (and (not (on-sale used jazz)) (not (on-sale used rap))))"
      ],
      "type": "unsat",
      "perplexity": [
        1.0848517417907715,
        1.0761311054229736
      ],
      "answer": "C",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "SyntaxError: invalid syntax. Perhaps you forgot a comma?"
    }
  },
  {
    "id": 13,
    "nl_problem": {
      "context": "During a single week, from Monday through Friday, tours will be conducted of a company's three divisions—Operations, Production, and Sales. Exactly five tours will be conducted that week, one each day. The schedule of tours for the week must conform to the following restrictions: Each division is toured at least once. The Operations division is not toured on Monday. The Production division is not toured on Wednesday. The Sales division is toured on two consecutive days, and on no other days. If the Operations division is toured on Thursday, then the Production division is toured on Friday.",
      "question": "Which one of the following CANNOT be true of the week's tour schedule?",
      "options": [
        "A) The division that is toured on Monday is also toured on Tuesday.",
        "B) The division that is toured on Monday is also toured on Friday.",
        "C) The division that is toured on Tuesday is also toured on Thursday.",
        "D) The division that is toured on Wednesday is also toured on Friday.",
        "E) The division that is toured on Thursday is also toured on Friday."
      ]
    },
    "answer": "C",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((Divisions 0)) (((Operations) (Production) (Sales))))",
        "(declare-datatypes ((Days 0)) (((Monday) (Tuesday) (Wednesday) (Thursday) (Friday))))",
        "(declare-fun tours (Divisions Days) Bool)",
        "(define-fun to-int ((b Bool)) Int (ite b 1 0))"
      ],
      "constraints": [
        "(forall ((d Divisions)) (>= (+ (to-int (tours d Monday)) (to-int (tours d Tuesday)) (to-int (tours d Wednesday)) (to-int (tours d Thursday)) (to-int (tours d Friday))) 1))",
        "(not (tours Operations Monday))",
        "(not (tours Production Wednesday))",
        "(forall ((d1 Days) (d2 Days)) (let ((sales1 (tours Sales d1)) (sales2 (tours Sales d2))) (and (= d1 Tuesday (ite sales1 (= d2 Wednesday) d2)) (ite d1 Friday (not sales1)))))",
        "(forall ((d1 Days) (d2 Days)) (let ((ops-thursday (tours Operations Thursday)) (prod-friday (tours Production Friday))) (and (ite ops-thursday (= d1 Thursday) d2) (ite ops-thursday prod-friday (not prod-friday)))))"
      ],
      "options": [
        "(not (forall ((m Days)) (= (tours (ite (not (tours Operations m)) Operations (ite (not (tours Production m)) Production Sales)) m)))",
        "(not (forall ((m Days)) (= (tours (ite (not (tours Production m)) Production (ite (not (tours Sales m)) Sales Operations)) m)))",
        "(not (forall ((m Days)) (= (tours (ite (not (tours Operations m)) Operations (ite (not (tours Sales m)) Sales Production)) m)))",
        "(not (forall ((m Days)) (= (tours (ite (not (tours Production m)) Production (ite (not (tours Operations m)) Operations Sales)) m)))",
        "(not (forall ((m Days)) (= (tours (ite (not (tours Sales m)) Sales (ite (not (tours Operations m)) Operations Production)) m)))"
      ],
      "type": "sat",
      "perplexity": [
        1.1724332571029663,
        1.077622413635254
      ],
      "answer": "C",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "SyntaxError: invalid syntax. Perhaps you forgot a comma?"
    }
  },
  {
    "id": 14,
    "nl_problem": {
      "context": "During a single week, from Monday through Friday, tours will be conducted of a company's three divisions—Operations, Production, and Sales. Exactly five tours will be conducted that week, one each day. The schedule of tours for the week must conform to the following restrictions: Each division is toured at least once. The Operations division is not toured on Monday. The Production division is not toured on Wednesday. The Sales division is toured on two consecutive days, and on no other days. If the Operations division is toured on Thursday, then the Production division is toured on Friday.",
      "question": "If in addition to the Sales division one other division is toured on two consecutive days, then it could be true of the week's tour schedule both that the",
      "options": [
        "A) Production division is toured on Monday and that the Operations division is toured on Thursday",
        "B) Production division is toured on Tuesday and that the Sales division is toured on Wednesday",
        "C) Operations division is toured on Tuesday and that the Production division is toured on Friday",
        "D) Sales division is toured on Monday and that the Operations division is toured on Friday",
        "E) Sales division is toured on Wednesday and that the Production division is toured on Friday"
      ]
    },
    "answer": "B",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((Days 0)) (((Monday) (Tuesday) (Wednesday) (Thursday) (Friday))))",
        "(declare-datatypes ((Divisions 0)) (((Operations) (Production) (Sales))))",
        "(declare-fun toured (Days Divisions) Bool)",
        "(define-fun to-int ((b Bool)) Int (ite b 1 0))"
      ],
      "constraints": [
        ">= (+ (to-int (and (toured Monday Operations) (toured Tuesday Operations) (toured Wednesday Operations) (toured Thursday Operations) (toured Friday Operations))) (to-int (and (toured Monday Production) (toured Tuesday Production) (toured Wednesday Production) (toured Thursday Production) (toured Friday Production))) (to-int (and (toured Monday Sales) (toured Tuesday Sales) (toured Wednesday Sales) (toured Thursday Sales) (toured Friday Sales)))) 3",
        "not (toured Monday Operations)",
        "not (toured Wednesday Production)",
        "or (= (toured Monday Sales) (toured Tuesday Sales)) (= (toured Tuesday Sales) (toured Wednesday Sales)) (= (toured Wednesday Sales) (toured Thursday Sales)) (= (toured Thursday Sales) (toured Friday Sales))",
        "or (not (= (toured Monday Sales) (toured Tuesday Sales))) (not (= (toured Tuesday Sales) (toured Wednesday Sales))) (not (= (toured Wednesday Sales) (toured Thursday Sales))) (not (= (toured Thursday Sales) (toured Friday Sales)))",
        "=> (toured Thursday Operations) (toured Friday Production)"
      ],
      "options": [
        "(forall ((d Days)) (= (toured d Production) (toured (ite (or (= d Monday) (= d Tuesday)) Wednesday d) Operations)))",
        "(forall ((d Days)) (= (toured d Operations) (toured (ite (or (= d Monday) (= d Tuesday)) Wednesday d) Production)))",
        "(forall ((d Days)) (= (toured d Production) (toured (ite (or (= d Monday) (= d Tuesday)) Wednesday d) Sales)))",
        "(forall ((d Days)) (= (toured d Sales) (toured (ite (or (= d Monday) (= d Tuesday)) Wednesday d) Production)))",
        "(forall ((d Days)) (= (toured d Operations) (toured (ite (or (= d Monday) (= d Tuesday)) Wednesday d) Sales)))",
        "(forall ((d Days)) (= (toured d Sales) (toured (ite (or (= d Monday) (= d Tuesday)) Wednesday d) Operations)))",
        "(forall ((d Days)) (= (toured d Sales) (toured (ite (or (= d Monday) (= d Tuesday)) Wednesday d) Production)))",
        "(forall ((d Days)) (= (toured d Production) (toured (ite (or (= d Monday) (= d Tuesday)) Wednesday d) Sales)))"
      ],
      "type": "sat",
      "perplexity": [
        1.0684130191802979,
        1.0669968128204346
      ],
      "answer": "B",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "SyntaxError: invalid syntax"
    }
  },
  {
    "id": 15,
    "nl_problem": {
      "context": "During a single week, from Monday through Friday, tours will be conducted of a company's three divisions—Operations, Production, and Sales. Exactly five tours will be conducted that week, one each day. The schedule of tours for the week must conform to the following restrictions: Each division is toured at least once. The Operations division is not toured on Monday. The Production division is not toured on Wednesday. The Sales division is toured on two consecutive days, and on no other days. If the Operations division is toured on Thursday, then the Production division is toured on Friday.",
      "question": "If in the week's tour schedule the division that is toured on Tuesday is also toured on Friday, then for which one of the following days must a tour of the Production division be scheduled?",
      "options": [
        "A) Monday",
        "B) Tuesday",
        "C) Wednesday",
        "D) Thursday",
        "E) Friday"
      ]
    },
    "answer": "A",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((Days 0)) (((Monday) (Tuesday) (Wednesday) (Thursday) (Friday))))",
        "(declare-datatypes ((Divisions 0)) (((Operations) (Production) (Sales))))",
        "(declare-fun tours (Days Divisions) Bool)"
      ],
      "constraints": [
        "(= (+ (to-int (tours Monday Operations)) (to-int (tours Monday Production)) (to-int (tours Monday Sales)) (to-int (tours Tuesday Operations)) (to-int (tours Tuesday Production)) (to-int (tours Tuesday Sales)) (to-int (tours Wednesday Operations)) (to-int (tours Wednesday Production)) (to-int (tours Wednesday Sales)) (to-int (tours Thursday Operations)) (to-int (tours Thursday Production)) (to-int (tours Thursday Sales)) (to-int (tours Friday Operations)) (to-int (tours Friday Production)) (to-int (tours Friday Sales))) 5))",
        "(forall ((d Days)) (=> (distinct d Monday) (> (+ (to-int (tours d Operations)) (to-int (tours d Production)) (to-int (tours d Sales))) 0)))",
        "(not (tours Monday Operations))",
        "(not (tours Wednesday Production))",
        "(or (and (tours Tuesday Sales) (tours Wednesday Sales) (not (tours Monday Sales)) (not (tours Thursday Sales)) (not (tours Friday Sales))) (and (tours Wednesday Sales) (tours Thursday Sales) (not (tours Monday Sales)) (not (tours Tuesday Sales)) (not (tours Friday Sales))) (and (tours Thursday Sales) (tours Friday Sales) (not (tours Monday Sales)) (not (tours Tuesday Sales)) (not (tours Wednesday Sales))))",
        "(=> (tours Thursday Operations) (tours Friday Production))",
        "(forall ((m Days)) (= (tours Tuesday m) (tours Friday m)))",
        "(forall ((m Days)) (distinct (tours Tuesday Production) (tours m Production)))"
      ],
      "options": [
        "(forall ((m Days)) (= (tours Tuesday m) (tours Friday m)))",
        "(forall ((m Days)) (= (tours Tuesday m) (tours Friday m)))",
        "(=> (tours Tuesday Operations) (tours Friday Operations))",
        "(=> (tours Tuesday Production) (tours Friday Production))"
      ],
      "type": "sat",
      "perplexity": [
        1.1125882863998413,
        1.1515367031097412
      ],
      "answer": "A",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "SyntaxError: unmatched ')'"
    }
  },
  {
    "id": 16,
    "nl_problem": {
      "context": "During a single week, from Monday through Friday, tours will be conducted of a company's three divisions—Operations, Production, and Sales. Exactly five tours will be conducted that week, one each day. The schedule of tours for the week must conform to the following restrictions: Each division is toured at least once. The Operations division is not toured on Monday. The Production division is not toured on Wednesday. The Sales division is toured on two consecutive days, and on no other days. If the Operations division is toured on Thursday, then the Production division is toured on Friday.",
      "question": "If in the week's tour schedule the division that is toured on Monday is not the division that is toured on Tuesday, then which one of the following could be true of the week's schedule?",
      "options": [
        "A) A tour of the Sales division is scheduled for some day earlier in the week than is any tour of the Production division.",
        "B) A tour of the Operations division is scheduled for some day earlier in the week than is any tour of the Production division.",
        "C) The Sales division is toured on Monday.",
        "D) The Production division is toured on Tuesday.",
        "E) The Operations division is toured on Wednesday."
      ]
    },
    "answer": "E",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((Days 0)) (((Monday) (Tuesday) (Wednesday) (Thursday) (Friday))))",
        "(declare-datatypes ((Divisions 0)) (((Operations) (Production) (Sales))))",
        "(declare-fun tours (Days Divisions) Bool)",
        "(define-fun to-int ((b Bool)) Int (ite b 1 0))"
      ],
      "constraints": [
        "(forall ((d Divisions)) (>= (+ (to-int (tours Monday d)) (to-int (tours Tuesday d)) (to-int (tours Wednesday d)) (to-int (tours Thursday d)) (to-int (tours Friday d))) 1))",
        "(not (tours Monday Operations))",
        "(not (tours Wednesday Production))",
        "(exists ((m Days)) (and (= (tours m Sales) (tours (ite (= m Wednesday) Thursday Monday))) (forall ((d Days)) (or (not (= m d)) (not (= (tours d Sales) (tours (ite (= d Wednesday) Thursday Monday))))))))",
        "(=> (tours Thursday Operations) (tours Friday Production))"
      ],
      "options": [
        "(exists ((d Days)) (and (not (= (tours Monday Production) (tours Tuesday Production))) (forall ((e Days)) (or (not (= e Monday)) (not (= e Tuesday)) (not (= (tours e Production) (tours d Production)))))))",
        "(exists ((d Days)) (and (not (= (tours Monday Production) (tours Tuesday Production))) (forall ((e Days)) (or (not (= e Monday)) (not (= e Tuesday)) (not (= (tours e Production) (tours d Production)))))))",
        "(tours Monday Sales)",
        "(tours Tuesday Production)",
        "(tours Wednesday Operations)"
      ],
      "type": "sat",
      "perplexity": [
        1.169829249382019,
        1.0869708061218262
      ],
      "answer": "E",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "SyntaxError: invalid syntax. Perhaps you forgot a comma?"
    }
  },
  {
    "id": 17,
    "nl_problem": {
      "context": "During a single week, from Monday through Friday, tours will be conducted of a company's three divisions—Operations, Production, and Sales. Exactly five tours will be conducted that week, one each day. The schedule of tours for the week must conform to the following restrictions: Each division is toured at least once. The Operations division is not toured on Monday. The Production division is not toured on Wednesday. The Sales division is toured on two consecutive days, and on no other days. If the Operations division is toured on Thursday, then the Production division is toured on Friday.",
      "question": "If in the week's tour schedule the division that is toured on Tuesday is also toured on Wednesday, then which one of the following must be true of the week's tour schedule?",
      "options": [
        "A) The Production division is toured on Monday.",
        "B) The Operations division is toured on Tuesday.",
        "C) The Sales division is toured on Wednesday.",
        "D) The Sales division is toured on Thursday.",
        "E) The Production division is toured on Friday."
      ]
    },
    "answer": "A",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((Days 0)) (((Monday) (Tuesday) (Wednesday) (Thursday) (Friday))))",
        "(declare-datatypes ((Divisions 0)) (((Operations) (Production) (Sales))))",
        "(declare-fun tours (Days) Divisions)"
      ],
      "constraints": [
        "(>= (+ (ite (= (tours Monday) Operations) 1 0) (ite (= (tours Monday) Production) 1 0) (ite (= (tours Monday) Sales) 1 0) (ite (= (tours Tuesday) Operations) 1 0) (ite (= (tours Tuesday) Production) 1 0) (ite (= (tours Tuesday) Sales) 1 0) (ite (= (tours Wednesday) Operations) 1 0) (ite (= (tours Wednesday) Production) 1 0) (ite (= (tours Wednesday) Sales) 1 0) (ite (= (tours Thursday) Operations) 1 0) (ite (= (tours Thursday) Production) 1 0) (ite (= (tours Thursday) Sales) 1 0) (ite (= (tours Friday) Operations) 1 0) (ite (= (tours Friday) Production) 1 0) (ite (= (tours Friday) Sales) 1 0)) 3))",
        "(not (= (tours Monday) Operations))",
        "(not (= (tours Wednesday) Production))",
        "(forall ((d Days)) (or (= (tours d) Sales) (= (tours (ite (< d Wednesday) (if (< d Monday) d (+ d 1)) d)) Sales)))",
        "(forall ((d Days)) (=> (= (tours Thursday) Operations) (= (tours Friday) Production)))",
        "(forall ((m Days)) (= (tours Tuesday) (tours Wednesday)))"
      ],
      "options": [
        "=(tours Monday) Production",
        "=(tours Tuesday) Operations",
        "=(tours Wednesday) Sales",
        "=(tours Thursday) Sales",
        "=(tours Friday) Production"
      ],
      "type": "sat",
      "perplexity": [
        1.160722017288208,
        1.0923866033554077
      ],
      "answer": "A",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "SyntaxError: unmatched ')'"
    }
  },
  {
    "id": 18,
    "nl_problem": {
      "context": "A crew of up to five workers is to install a partition in at most three days. The crew completes five tasks in this order: framing, wallboarding, taping, sanding, priming. The crew is selected from the following list, which specifies exactly the tasks each person can do: George: taping Helena: sanding, priming Inga: framing, priming Kelly: framing, sanding Leanda: wallboarding, taping Maricita: sanding Olaf: wallboarding, priming The following conditions must apply: At least one task is done each day. Taping and priming are done on different days. Each crew member does at least one task during the installation, but no more than one task a day. Each task is done by exactly one worker, completed the day it is started and before the next task begins.",
      "question": "Which one of the following could be a complete and accurate list of the members of the crew?",
      "options": [
        "A) George, Helena, Inga, Kelly",
        "B) George, Helena, Kelly, Leanda",
        "C) Helena, Inga, Kelly, Olaf",
        "D) Helena, Inga, Maricita, Olaf",
        "E) George, Helena, Leanda, Maricita, Olaf"
      ]
    },
    "answer": "B",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((Tasks 0)) (((framing) (wallboarding) (taping) (sanding) (priming))))",
        "(declare-datatypes ((Workers 0)) (((George) (Helena) (Inga) (Kelly) (Leanda) (Maricita) (Olaf))))",
        "(declare-datatypes ((Days 0)) (((day1) (day2) (day3))))",
        "(declare-fun assigns (Workers Tasks) Bool)",
        "(define-fun to-int ((b Bool)) Int (ite b 1 0))"
      ],
      "constraints": [
        "(forall ((d Days)) (>= (+ (to-int (exists ((w Workers)) (assigns w framing d))) (to-int (exists ((w Workers)) (assigns w wallboarding d))) (to-int (exists ((w Workers)) (assigns w taping d))) (to-int (exists ((w Workers)) (assigns w sanding d))) (to-int (exists ((w Workers)) (assigns w priming d)))) 1))",
        "(forall ((d1 Days) (d2 Days)) (and (not (= d1 d2)) (forall ((w Workers)) (=> (and (assigns w taping d1) (assigns w priming d2)) false))))",
        "(forall ((d Days) (w Workers)) (= (to-int (exists ((t Tasks)) (assigns w t d))) (ite (= 1 (to-int (exists ((t Tasks)) (assigns w t d)))) 1 0)))",
        "(forall ((d Days) (t Tasks) (w1 Workers) (w2 Workers)) (=> (and (assigns w1 t d) (assigns w2 t d)) false))",
        "(forall ((w Workers) (t Tasks)) (ite (and (w w George) (t t taping)) (= (assigns w t day1) true) (ite (and (w w Helena) (or (t t sanding) (t t priming))) (= (assigns w t day1) true) (ite (and (w w Inga) (or (t t framing) (t t priming))) (= (assigns w t day1) true) (ite (and (w w Kelly) (or (t t framing) (t t sanding))) (= (assigns w t day1) true) (ite (and (w w Leanda) (or (t t wallboarding) (t t taping))) (= (assigns w t day1) true) (ite (and (w w Maricita) (or (t t sanding) (t t priming))) (= (assigns w t day1) true) (ite (and (w w Olaf) (or (t t wallboarding) (t t priming))) (= (assigns w t day1) true) false)))))"
      ],
      "options": [
        "(forall ((t Tasks) (d Days)) (ite (and (d d day1) (t t taping)) (= (assigns George t d) true) (ite (and (d d day1) (t t sanding)) (= (assigns Helena t d) true) (ite (and (d d day1) (t t framing)) (= (assigns Inga t d) true) (ite (and (d d day1) (t t wallboarding)) (= (assigns Leanda t d) true) false)))))",
        "(forall ((t Tasks) (d Days)) (ite (and (d d day1) (t t sanding)) (= (assigns Helena t d) true) (ite (and (d d day1) (t t framing)) (= (assigns Inga t d) true) (ite (and (d d day1) (t t wallboarding)) (= (assigns Olaf t d) true) false))))",
        "(forall ((t Tasks) (d Days)) (ite (and (d d day1) (t t taping)) (= (assigns George t d) true) (ite (and (d d day1) (t t sanding)) (= (assigns Helena t d) true) (ite (and (d d day1) (t t framing)) (= (assigns Leanda t d) true) (ite (and (d d day1) (t t sanding)) (= (assigns Maricita t d) true) (ite (and (d d day1) (t t wallboarding)) (= (assigns Olaf t d) true) false)))))"
      ],
      "type": "sat",
      "perplexity": [
        1.0728610754013062,
        1.050083875656128
      ],
      "answer": "B",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "SyntaxError: invalid syntax. Perhaps you forgot a comma?"
    }
  },
  {
    "id": 19,
    "nl_problem": {
      "context": "A crew of up to five workers is to install a partition in at most three days. The crew completes five tasks in this order: framing, wallboarding, taping, sanding, priming. The crew is selected from the following list, which specifies exactly the tasks each person can do: George: taping Helena: sanding, priming Inga: framing, priming Kelly: framing, sanding Leanda: wallboarding, taping Maricita: sanding Olaf: wallboarding, priming The following conditions must apply: At least one task is done each day. Taping and priming are done on different days. Each crew member does at least one task during the installation, but no more than one task a day. Each task is done by exactly one worker, completed the day it is started and before the next task begins.",
      "question": "If the installation takes three days, and if the same two crew members work on the first and third days, then which one of the following could be the pair of crew members who work on those two days?",
      "options": [
        "A) Helena and Inga",
        "B) Inga and Kelly",
        "C) Inga and Leanda",
        "D) Kelly and Olaf",
        "E) Leanda and Olaf"
      ]
    },
    "answer": "D",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((Workers 0)) (((George) (Helena) (Inga) (Kelly) (Leanda) (Maricita) (Olaf))))",
        "(declare-datatypes ((Tasks 0)) (((framing) (wallboarding) (taping) (sanding) (priming))))",
        "(declare-fun assigned (Workers Tasks Int) Bool)",
        "(define-fun to-int ((b Bool)) Int (ite b 1 0))"
      ],
      "constraints": [
        "(forall ((day Int)) (>= (+ (to-int (assigned George framing day)) (to-int (assigned Helena sanding day)) (to-int (assigned Inga framing day)) (to-int (assigned Kelly sanding day)) (to-int (assigned Leanda wallboarding day)) (to-int (assigned Maricita sanding day)) (to-int (assigned Olaf priming day))) 1))",
        "(forall ((day1 Int) (day2 Int)) (=> (and (assigned George taping day1) (assigned _ priming day2)) (distinct day1 day2)))",
        "(forall ((w Workers)) (>= (+ (to-int (assigned w framing 1)) (to-int (assigned w framing 2)) (to-int (assigned w framing 3)) (to-int (assigned w wallboarding 1)) (to-int (assigned w wallboarding 2)) (to-int (assigned w wallboarding 3)) (to-int (assigned w taping 1)) (to-int (assigned w taping 2)) (to-int (assigned w taping 3)) (to-int (assigned w sanding 1)) (to-int (assigned w sanding 2)) (to-int (assigned w sanding 3)) (to-int (assigned w priming 1)) (to-int (assigned w priming 2)) (to-int (assigned w priming 3))) 1))",
        "(forall ((w Workers) (day Int)) (<= (+ (to-int (assigned w framing day)) (to-int (assigned w wallboarding day)) (to-int (assigned w taping day)) (to-int (assigned w sanding day)) (to-int (assigned w priming day))) 1))",
        "(forall ((task Tasks) (day1 Int) (day2 Int)) (=> (and (assigned w1 task day1) (assigned w2 task day2)) (distinct w1 w2)))",
        "(forall ((w Workers) (day Int)) (<= (+ (to-int (assigned w framing day)) (to-int (assigned w wallboarding day)) (to-int (assigned w taping day)) (to-int (assigned w sanding day)) (to-int (assigned w priming day))) 1))",
        "(= 3 (distinct 1 2 3))"
      ],
      "options": [
        "(distinct (assigned George framing 1) (assigned Inga framing 1))",
        "(distinct (assigned George framing 3) (assigned Inga framing 3))",
        "(forall ((day Int)) (distinct (assigned George taping day) (assigned Inga taping day)))",
        "(forall ((day Int)) (distinct (assigned George priming day) (assigned Inga priming day)))",
        "(distinct (assigned Inga framing 1) (assigned Kelly framing 1))",
        "(distinct (assigned Inga framing 3) (assigned Kelly framing 3))",
        "(forall ((day Int)) (distinct (assigned Inga taping day) (assigned Kelly taping day)))",
        "(forall ((day Int)) (distinct (assigned Inga priming day) (assigned Kelly priming day)))",
        "(distinct (assigned Inga framing 1) (assigned Leanda framing 1))",
        "(distinct (assigned Inga framing 3) (assigned Leanda framing 3))",
        "(forall ((day Int)) (distinct (assigned Inga taping day) (assigned Leanda taping day)))",
        "(forall ((day Int)) (distinct (assigned Inga priming day) (assigned Leanda priming day)))",
        "(distinct (assigned Kelly framing 1) (assigned Olaf framing 1))",
        "(distinct (assigned Kelly framing 3) (assigned Olaf framing 3))",
        "(forall ((day Int)) (distinct (assigned Kelly taping day) (assigned Olaf taping day)))",
        "(forall ((day Int)) (distinct (assigned Kelly priming day) (assigned Olaf priming day)))",
        "(distinct (assigned Leanda framing 1) (assigned Olaf framing 1))",
        "(distinct (assigned Leanda framing 3) (assigned Olaf framing 3))",
        "(forall ((day Int)) (distinct (assigned Leanda taping day) (assigned Olaf taping day)))",
        "(forall ((day Int)) (distinct (assigned Leanda priming day) (assigned Olaf priming day)))"
      ],
      "type": "sat",
      "perplexity": [
        1.07017183303833,
        1.0377883911132812
      ],
      "answer": "D",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "SyntaxError: invalid syntax. Perhaps you forgot a comma?"
    }
  },
  {
    "id": 20,
    "nl_problem": {
      "context": "A crew of up to five workers is to install a partition in at most three days. The crew completes five tasks in this order: framing, wallboarding, taping, sanding, priming. The crew is selected from the following list, which specifies exactly the tasks each person can do: George: taping Helena: sanding, priming Inga: framing, priming Kelly: framing, sanding Leanda: wallboarding, taping Maricita: sanding Olaf: wallboarding, priming The following conditions must apply: At least one task is done each day. Taping and priming are done on different days. Each crew member does at least one task during the installation, but no more than one task a day. Each task is done by exactly one worker, completed the day it is started and before the next task begins.",
      "question": "Each of the following could be a complete and accurate list of the members of the crew EXCEPT:",
      "options": [
        "A) Helena, Inga, Kelly, Maricita",
        "B) Inga, Kelly, Leanda, Olaf",
        "C) George, Helena, Inga, Leanda",
        "D) Inga, Leanda, Maricita, Olaf",
        "E) Kelly, Leanda, Maricita, Olaf"
      ]
    },
    "answer": "A",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((Days 0)) (((d1) (d2) (d3))))",
        "(declare-datatypes ((Tasks 0)) (((framing) (wallboarding) (taping) (sanding) (priming))))",
        "(declare-datatypes ((People 0)) (((George) (Helena) (Inga) (Kelly) (Leanda) (Maricita) (Olaf))))",
        "(declare-fun crew (Days) (People))",
        "(declare-fun task (Tasks Days) (People))"
      ],
      "constraints": [
        "(forall ((d Days)) (> (+ (to-int (task framing d)) (to-int (task wallboarding d)) (to-int (task taping d)) (to-int (task sanding d)) (to-int (task priming d))) 0))",
        "(not (forall ((d Days)) (= (task taping d) (task priming d))))",
        "(forall ((p People)) (> (+ (to-int (task framing (d1) p)) (to-int (task framing (d2) p)) (to-int (task framing (d3) p)) (to-int (task wallboarding (d1) p)) (to-int (task wallboarding (d2) p)) (to-int (task wallboarding (d3) p)) (to-int (task taping (d1) p)) (to-int (task taping (d2) p)) (to-int (task taping (d3) p)) (to-int (task sanding (d1) p)) (to-int (task sanding (d2) p)) (to-int (task sanding (d3) p)) (to-int (task priming (d1) p)) (to-int (task priming (d2) p)) (to-int (task priming (d3) p)) 1))",
        "(forall ((d Days)) (<= (+ (to-int (task framing d)) (to-int (task wallboarding d)) (to-int (task taping d)) (to-int (task sanding d)) (to-int (task priming d))) 1))",
        "(forall ((d Days) (t Tasks)) (= (+ (to-int (task t d)) (to-int (task (ite (< t framing) t (ite (< t wallboarding) t (ite (< t taping) t (ite (< t sanding) t (ite (< t priming) t (ite (< t t) t (ite (not (> t t)) t))))))) (inc d))) (to-int (task t (inc d)))))"
      ],
      "options": [
        "(forall ((d Days)) (= (crew d) (crewA d)))",
        "(forall ((d Days)) (= (crew d) (crewB d)))",
        "(forall ((d Days)) (= (crew d) (crewC d)))",
        "(forall ((d Days)) (= (crew d) (crewD d)))",
        "(forall ((d Days)) (= (crew d) (crewE d)))"
      ],
      "type": "sat",
      "perplexity": [
        1.0897821187973022,
        1.0643163919448853
      ],
      "answer": "A",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "SyntaxError: invalid syntax. Perhaps you forgot a comma?"
    }
  },
  {
    "id": 21,
    "nl_problem": {
      "context": "A crew of up to five workers is to install a partition in at most three days. The crew completes five tasks in this order: framing, wallboarding, taping, sanding, priming. The crew is selected from the following list, which specifies exactly the tasks each person can do: George: taping Helena: sanding, priming Inga: framing, priming Kelly: framing, sanding Leanda: wallboarding, taping Maricita: sanding Olaf: wallboarding, priming The following conditions must apply: At least one task is done each day. Taping and priming are done on different days. Each crew member does at least one task during the installation, but no more than one task a day. Each task is done by exactly one worker, completed the day it is started and before the next task begins.",
      "question": "If the installation takes three days, and if the sanding is done on the third day, then which one of the following could be a list of all the crew members who work on the second day?",
      "options": [
        "A) Inga",
        "B) Kelly",
        "C) Olaf",
        "D) George and Helena",
        "E) Leanda and Olaf"
      ]
    },
    "answer": "E",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((People 0)) (((George) (Helena) (Inga) (Kelly) (Leanda) (Maricita) (Olaf))))",
        "(declare-datatypes ((Days 0)) (((day1) (day2) (day3))))",
        "(declare-datatypes ((Tasks 0)) (((framing) (wallboarding) (taping) (sanding) (priming))))",
        "(declare-fun assigned (People Days Tasks) Bool)",
        "(define-fun to-int ((b Bool)) Int (ite b 1 0))"
      ],
      "constraints": [
        "(forall ((d Days)) (>= (+ (to-int (assigned George d framing)) (to-int (assigned Helena d sanding)) (to-int (assigned Inga d framing)) (to-int (assigned Inga d priming)) (to-int (assigned Kelly d framing)) (to-int (assigned Kelly d sanding)) (to-int (assigned Leanda d wallboarding)) (to-int (assigned Leanda d taping)) (to-int (assigned Maricita d sanding)) (to-int (assigned Olaf d wallboarding)) (to-int (assigned Olaf d priming)) 1)))",
        "(forall ((d Days)) (not (and (= (assigned George d taping) true) (= (assigned _ d priming) true))))",
        "(forall ((p People)) (>= (+ (to-int (assigned p day1 framing)) (to-int (assigned p day1 wallboarding)) (to-int (assigned p day1 taping)) (to-int (assigned p day1 sanding)) (to-int (assigned p day1 priming)) (to-int (assigned p day2 framing)) (to-int (assigned p day2 wallboarding)) (to-int (assigned p day2 taping)) (to-int (assigned p day2 sanding)) (to-int (assigned p day2 priming)) (to-int (assigned p day3 framing)) (to-int (assigned p day3 wallboarding)) (to-int (assigned p day3 taping)) (to-int (assigned p day3 sanding)) (to-int (assigned p day3 priming))) 1))",
        "(forall ((d Days) (t Tasks)) (= 1 (+ (to-int (assigned George d t)) (to-int (assigned Helena d t)) (to-int (assigned Inga d t)) (to-int (assigned Kelly d t)) (to-int (assigned Leanda d t)) (to-int (assigned Maricita d t)) (to-int (assigned Olaf d t)))))",
        "(forall ((d Days) (t Tasks) (p People)) (implies (and (= (assigned p d t) true) (not (= (assigned p (select (ite (not (= d day3) true) (ite (= d day2) day3 day2) day2)) t) true))) (= (assigned p d t) true)))",
        "(forall ((d Days)) (= 3 (ite (not (= d day3) true) (ite (= d day2) 1 0) 1)))",
        "(assigned Maricita day3 sanding)"
      ],
      "options": [
        "(= (ite (not (= d day3) true) (ite (= d day2) day3 day2) day2) day2)",
        "(assigned George day2 taping)",
        "(not (assigned _ day2 priming))",
        "(assigned Kelly day2 taping)",
        "(not (assigned _ day2 priming))",
        "(assigned Olaf day2 taping)",
        "(not (assigned _ day2 priming))",
        "(assigned George day2 sanding)",
        "(assigned Helena day2 sanding)",
        "(assigned Kelly day2 sanding)",
        "(not (assigned _ day2 taping))",
        "(not (assigned _ day2 framing))",
        "(not (assigned _ day2 wallboarding))",
        "(not (assigned _ day2 priming))"
      ],
      "type": "sat",
      "perplexity": [
        1.1494563817977905,
        1.059403657913208
      ],
      "answer": "E",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "SyntaxError: invalid syntax. Perhaps you forgot a comma?"
    }
  },
  {
    "id": 22,
    "nl_problem": {
      "context": "A crew of up to five workers is to install a partition in at most three days. The crew completes five tasks in this order: framing, wallboarding, taping, sanding, priming. The crew is selected from the following list, which specifies exactly the tasks each person can do: George: taping Helena: sanding, priming Inga: framing, priming Kelly: framing, sanding Leanda: wallboarding, taping Maricita: sanding Olaf: wallboarding, priming The following conditions must apply: At least one task is done each day. Taping and priming are done on different days. Each crew member does at least one task during the installation, but no more than one task a day. Each task is done by exactly one worker, completed the day it is started and before the next task begins.",
      "question": "Which one of the following could be a pair of members of the crew both of whom work on the same days as each other and each of whom perform two tasks?",
      "options": [
        "A) George and Maricita",
        "B) Helena and Kelly",
        "C) Inga and Leanda",
        "D) Kelly and Leanda",
        "E) Leanda and Olaf"
      ]
    },
    "answer": "D",
    "logic_problem": {
      "perplexity": [
        1.1366013288497925,
        2615.87939453125
      ],
      "answer": "D",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "No Output"
    }
  },
  {
    "id": 23,
    "nl_problem": {
      "context": "A closet contains exactly six hangers—1, 2, 3, 4, 5, and 6—hanging, in that order, from left to right. It also contains exactly six dresses—one gauze, one linen, one polyester, one rayon, one silk, and one wool—a different dress on each of the hangers, in an order satisfying the following conditions: The gauze dress is on a lower-numbered hanger than the polyester dress. The rayon dress is on hanger 1 or hanger 6. Either the wool dress or the silk dress is on hanger 3. The linen dress hangs immediately to the right of the silk dress.",
      "question": "Which one of the following could be an accurate matching of the hangers to the fabrics of the dresses that hang on them?",
      "options": [
        "A) 1: wool; 2: gauze; 3: silk; 4: linen; 5: polyester; 6: rayon",
        "B) 1: rayon; 2: wool; 3: gauze; 4: silk; 5: linen; 6: polyester",
        "C) 1: polyester; 2: gauze; 3: wool; 4: silk; 5: linen; 6: rayon",
        "D) 1: linen; 2: silk; 3: wool; 4: gauze; 5: polyester; 6: rayon",
        "E) 1: gauze; 2: rayon; 3: silk; 4: linen; 5: wool; 6: polyester"
      ]
    },
    "answer": "A",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((Hangers 0)) (((h1) (h2) (h3) (h4) (h5) (h6))))",
        "(declare-datatypes ((Fabrics 0)) (((gauze) (linen) (polyester) (rayon) (silk) (wool))))",
        "(declare-fun dresses (Hangers) Fabrics)",
        "(define-fun to-int ((b Bool)) Int (ite b 1 0))"
      ],
      "constraints": [
        "(forall ((h Hangers)) (=> (not (= h h1)) (<= (ite (= (dresses h1) gauze) 1 0) (ite (= (dresses h) polyester) 1 0)))))",
        "(or (= (dresses h1) rayon) (= (dresses h6) rayon))",
        "(or (= (dresses h3) wool) (= (dresses h3) silk))",
        "(forall ((h Hangers)) (=> (not (= h h1)) (or (not (= h h4)) (and (= (dresses h3) silk) (= (dresses h) linen)))))"
      ],
      "options": [
        "(= (dresses h1) wool) (= (dresses h2) gauze) (= (dresses h3) silk) (= (dresses h4) linen) (= (dresses h5) polyester) (= (dresses h6) rayon)",
        "(= (dresses h1) rayon) (= (dresses h2) wool) (= (dresses h3) gauze) (= (dresses h4) silk) (= (dresses h5) linen) (= (dresses h6) polyester)",
        "(= (dresses h1) polyester) (= (dresses h2) gauze) (= (dresses h3) wool) (= (dresses h4) silk) (= (dresses h5) linen) (= (dresses h6) rayon)",
        "(= (dresses h1) linen) (= (dresses h2) silk) (= (dresses h3) wool) (= (dresses h4) gauze) (= (dresses h5) polyester) (= (dresses h6) rayon)",
        "(= (dresses h1) gauze) (= (dresses h2) rayon) (= (dresses h3) silk) (= (dresses h4) linen) (= (dresses h5) wool) (= (dresses h6) polyester)"
      ],
      "type": "unsat",
      "perplexity": [
        1.1121485233306885,
        1.0841530561447144
      ],
      "answer": "A",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "SyntaxError: unmatched ')'"
    }
  },
  {
    "id": 24,
    "nl_problem": {
      "context": "A closet contains exactly six hangers—1, 2, 3, 4, 5, and 6—hanging, in that order, from left to right. It also contains exactly six dresses—one gauze, one linen, one polyester, one rayon, one silk, and one wool—a different dress on each of the hangers, in an order satisfying the following conditions: The gauze dress is on a lower-numbered hanger than the polyester dress. The rayon dress is on hanger 1 or hanger 6. Either the wool dress or the silk dress is on hanger 3. The linen dress hangs immediately to the right of the silk dress.",
      "question": "If both the silk dress and the gauze dress are on odd-numbered hangers, then which one of the following could be true?",
      "options": [
        "A) The polyester dress is on hanger 1.",
        "B) The wool dress is on hanger 2.",
        "C) The polyester dress is on hanger 4.",
        "D) The linen dress is on hanger 5.",
        "E) The wool dress is on hanger 6."
      ]
    },
    "answer": "B",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((Hangers 0)) (((h1) (h2) (h3) (h4) (h5) (h6))))",
        "(declare-datatypes ((Dresses 0)) (((gauze) (linen) (polyester) (rayon) (silk) (wool))))",
        "(declare-fun hanger_dress (Hangers) Dresses)",
        "(define-fun odd? ((n Int)) Bool (= (mod n 2) 1))"
      ],
      "constraints": [
        "(forall ((h Hangers)) (=> (< (select h 0) (select (select h 0) 0)) (= (hanger_dress h) polyester)))",
        "(forall ((h Hangers)) (=> (= (hanger_dress (select h 0)) silk) (= (hanger_dress h) linen)))",
        "(or (= (hanger_dress h1) rayon) (= (hanger_dress h6) rayon))",
        "(or (= (hanger_dress h3) wool) (= (hanger_dress h3) silk))",
        "(forall ((h Hangers)) (=> (and (odd? (select (hanger_dress h) 0)) (odd? (select (hanger_dress h1) 0))) (or (= (hanger_dress h4) polyester) (= (hanger_dress h2) wool) (= (hanger_dress h5) linen) (= (hanger_dress h6) wool))))"
      ],
      "options": [
        "(not (= (hanger_dress h1) polyester))",
        "(not (= (hanger_dress h2) wool))",
        "(not (= (hanger_dress h4) polyester))",
        "(not (= (hanger_dress h5) linen))",
        "(not (= (hanger_dress h6) wool))"
      ],
      "type": "sat",
      "perplexity": [
        1.1367615461349487,
        1.0884981155395508
      ],
      "answer": "B",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "SyntaxError: invalid syntax. Perhaps you forgot a comma?"
    }
  },
  {
    "id": 25,
    "nl_problem": {
      "context": "A closet contains exactly six hangers—1, 2, 3, 4, 5, and 6—hanging, in that order, from left to right. It also contains exactly six dresses—one gauze, one linen, one polyester, one rayon, one silk, and one wool—a different dress on each of the hangers, in an order satisfying the following conditions: The gauze dress is on a lower-numbered hanger than the polyester dress. The rayon dress is on hanger 1 or hanger 6. Either the wool dress or the silk dress is on hanger 3. The linen dress hangs immediately to the right of the silk dress.",
      "question": "If the silk dress is on an even-numbered hanger, which one of the following could be on the hanger immediately to its left?",
      "options": [
        "A) the gauze dress",
        "B) the linen dress",
        "C) the polyester dress",
        "D) the rayon dress",
        "E) the wool dress"
      ]
    },
    "answer": "E",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((Hangers 0)) (((hanger1) (hanger2) (hanger3) (hanger4) (hanger5) (hanger6))))",
        "(declare-datatypes ((Dresses 0)) (((gauze) (linen) (polyester) (rayon) (silk) (wool))))",
        "(declare-fun on (Hangers Dresses) Bool)",
        "(define-fun to-int ((b Bool)) Int (ite b 1 0))"
      ],
      "constraints": [
        "(forall ((h Hangers)) (=> (on h gauze) (=> (not (on h polyester)) (not (hanger4 h)) (not (hanger5 h)))))",
        "(forall ((h Hangers)) (=> (on h rayon) (or (hanger1 h) (hanger6 h))))",
        "(forall ((h Hangers)) (=> (or (on h wool) (on h silk)) (hanger3 h)))",
        "(forall ((h Hangers)) (=> (on h silk) (=> (not (on h linen)) (hanger4 h))))",
        "(forall ((h Hangers)) (=> (on h silk) (or (hanger2 h) (hanger4 h) (hanger6 h))))"
      ],
      "options": [
        "(forall ((h Hangers)) (=> (on (ite (hanger2 h) hanger1 hanger3) gauze) true))",
        "(forall ((h Hangers)) (=> (on (ite (hanger2 h) hanger1 hanger3) linen) true))",
        "(forall ((h Hangers)) (=> (on (ite (hanger2 h) hanger1 hanger3) polyester) true))",
        "(forall ((h Hangers)) (=> (on (ite (hanger2 h) hanger1 hanger3) rayon) true))",
        "(forall ((h Hangers)) (=> (on (ite (hanger2 h) hanger1 hanger3) wool) true))"
      ],
      "type": "sat",
      "perplexity": [
        1.1522870063781738,
        1.0834883451461792
      ],
      "answer": "E",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "SyntaxError: invalid syntax. Perhaps you forgot a comma?"
    }
  },
  {
    "id": 26,
    "nl_problem": {
      "context": "A closet contains exactly six hangers—1, 2, 3, 4, 5, and 6—hanging, in that order, from left to right. It also contains exactly six dresses—one gauze, one linen, one polyester, one rayon, one silk, and one wool—a different dress on each of the hangers, in an order satisfying the following conditions: The gauze dress is on a lower-numbered hanger than the polyester dress. The rayon dress is on hanger 1 or hanger 6. Either the wool dress or the silk dress is on hanger 3. The linen dress hangs immediately to the right of the silk dress.",
      "question": "If the polyester dress is on hanger 2, then which one of the following must be true?",
      "options": [
        "A) The silk dress is on hanger 1.",
        "B) The wool dress is on hanger 3.",
        "C) The linen dress is on hanger 4.",
        "D) The linen dress is on hanger 5.",
        "E) The rayon dress is on hanger 6."
      ]
    },
    "answer": "E",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((Hangers 0)) (((hanger1) (hanger2) (hanger3) (hanger4) (hanger5) (hanger6))))",
        "(declare-datatypes ((Dresses 0)) (((gauze) (linen) (polyester) (rayon) (silk) (wool))))",
        "(declare-fun on (Hangers Dresses) Bool)",
        "(define-fun to-int ((b Bool)) Int (ite b 1 0))"
      ],
      "constraints": [
        "(forall ((h Hangers)) (=> (on h gauze) (<= h hanger2)))",
        "(forall ((h Hangers)) (=> (on h rayon) (or (= h hanger1) (= h hanger6))))",
        "(forall ((h Hangers)) (=> (not (on h wool)) (on h silk)))",
        "(forall ((h Hangers)) (=> (on h silk) (=> (not (on (ite (> h hanger3) h hanger3) linen)) (on h linen))))"
      ],
      "options": [
        "(assert (on hanger2 polyester))",
        "(assert (on hanger2 polyester))",
        "(assert (on hanger2 polyester))",
        "(assert (on hanger2 polyester))",
        "(assert (on hanger2 polyester))"
      ],
      "type": [
        "sat",
        "unsat",
        "unsat",
        "unsat",
        "unsat"
      ],
      "perplexity": [
        1.1116095781326294,
        1.1498180627822876
      ],
      "answer": "E",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "SyntaxError: invalid syntax. Perhaps you forgot a comma?"
    }
  },
  {
    "id": 27,
    "nl_problem": {
      "context": "A closet contains exactly six hangers—1, 2, 3, 4, 5, and 6—hanging, in that order, from left to right. It also contains exactly six dresses—one gauze, one linen, one polyester, one rayon, one silk, and one wool—a different dress on each of the hangers, in an order satisfying the following conditions: The gauze dress is on a lower-numbered hanger than the polyester dress. The rayon dress is on hanger 1 or hanger 6. Either the wool dress or the silk dress is on hanger 3. The linen dress hangs immediately to the right of the silk dress.",
      "question": "Which one of the following CANNOT be true?",
      "options": [
        "A) The linen dress hangs immediately next to the gauze dress.",
        "B) The polyester dress hangs immediately to the right of the rayon dress.",
        "C) The rayon dress hangs immediately to the left of the wool dress.",
        "D) The silk dress is on a lower-numbered hanger than the gauze dress.",
        "E) The wool dress is on a higher-numbered hanger than the rayon dress."
      ]
    },
    "answer": "B",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((Hangers 0)) (((h1) (h2) (h3) (h4) (h5) (h6))))",
        "(declare-datatypes ((Dresses 0)) (((gauze) (linen) (polyester) (rayon) (silk) (wool))))",
        "(declare-fun on (Hangers Dresses) Bool)",
        "(define-fun to-int ((b Bool)) Int (ite b 1 0))"
      ],
      "constraints": [
        "(forall ((h Hangers)) (=> (on gauze h) (or (= h h1) (= h h2) (= h h3) (= h h4) (not (= h h5)) (not (= h h6)))))",
        "(forall ((h Hangers)) (or (and (on rayon h) (= h h1)) (and (on rayon h) (= h h6))))",
        "(or (on wool h3) (on silk h3))",
        "(forall ((h Hangers)) (=> (and (on linen h) (on silk h)) (not (= h h1)) (not (= h h2)) (not (= h h4)) (not (= h h5)) (not (= h h6))))"
      ],
      "options": [
        "(=> (on linen h1) (on gauze h1))",
        "(=> (on polyester h2) (on rayon h1))",
        "(=> (on rayon h1) (on wool h3))",
        "(=> (on silk h2) (on gauze h2))",
        "(=> (on wool h5) (on rayon h6))"
      ],
      "type": [
        {
          "option": "A",
          "solution": "unsat"
        },
        {
          "option": "B",
          "solution": "sat"
        },
        {
          "option": "C",
          "solution": "sat"
        },
        {
          "option": "D",
          "solution": "sat"
        },
        {
          "option": "E",
          "solution": "sat"
        }
      ],
      "perplexity": [
        1.1287810802459717,
        1.098054051399231
      ],
      "answer": "B",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "SyntaxError: invalid syntax. Perhaps you forgot a comma?"
    }
  },
  {
    "id": 28,
    "nl_problem": {
      "context": "A closet contains exactly six hangers—1, 2, 3, 4, 5, and 6—hanging, in that order, from left to right. It also contains exactly six dresses—one gauze, one linen, one polyester, one rayon, one silk, and one wool—a different dress on each of the hangers, in an order satisfying the following conditions: The gauze dress is on a lower-numbered hanger than the polyester dress. The rayon dress is on hanger 1 or hanger 6. Either the wool dress or the silk dress is on hanger 3. The linen dress hangs immediately to the right of the silk dress.",
      "question": "Which one of the following CANNOT hang immediately next to the rayon dress?",
      "options": [
        "A) the gauze dress",
        "B) the linen dress",
        "C) the polyester dress",
        "D) the silk dress",
        "E) the wool dress"
      ]
    },
    "answer": "D",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((Hangers 0)) (((hanger1) (hanger2) (hanger3) (hanger4) (hanger5) (hanger6))))",
        "(declare-datatypes ((Dresses 0)) (((gauze) (linen) (polyester) (rayon) (silk) (wool))))",
        "(declare-fun hanger_of (Dresses) Hangers)",
        "(define-fun equals ((x Hangers) (y Hangers)) Bool (ite (= x hanger1) (= y hanger1) (ite (= x hanger2) (= y hanger2) (ite (= x hanger3) (= y hanger3) (ite (= x hanger4) (= y hanger4) (ite (= x hanger5) (= y hanger5) (= x hanger6)))))))",
        "(define-fun adjacent ((x Hangers) (y Hangers)) Bool (or (equals x hanger1) (equals y hanger1) (or (equals x hanger2) (equals y hanger2)) (or (equals x hanger3) (equals y hanger3)) (or (equals x hanger4) (equals y hanger4)) (or (equals x hanger5) (equals y hanger5))))"
      ],
      "constraints": [
        "(forall ((d Dresses)) (not (and (equals (hanger_of d) hanger4) (= (hanger_of d) (hanger_of polyester)))))",
        "(forall ((d Dresses)) (or (= (hanger_of d) hanger1) (= (hanger_of d) hanger6)))",
        "(forall ((d Dresses)) (or (= (hanger_of d) hanger3) (= (hanger_of d) hanger3)))",
        "(forall ((d Dresses)) (not (adjacent (hanger_of linen) (hanger_of silk))))"
      ],
      "options": [
        "(exists ((d Dresses)) (not (adjacent (hanger_of d) (hanger_of rayon))))",
        "(not (exists ((d Dresses)) (not (adjacent (hanger_of d) (hanger_of rayon)))))",
        "(exists ((d Dresses)) (not (adjacent (hanger_of gauze) (hanger_of rayon))))",
        "(not (exists ((d Dresses)) (not (adjacent (hanger_of gauze) (hanger_of rayon)))))",
        "(exists ((d Dresses)) (not (adjacent (hanger_of linen) (hanger_of rayon))))",
        "(not (exists ((d Dresses)) (not (adjacent (hanger_of linen) (hanger_of rayon)))))",
        "(exists ((d Dresses)) (not (adjacent (hanger_of polyester) (hanger_of rayon))))",
        "(not (exists ((d Dresses)) (not (adjacent (hanger_of polyester) (hanger_of rayon)))))",
        "(exists ((d Dresses)) (not (adjacent (hanger_of silk) (hanger_of rayon))))",
        "(not (exists ((d Dresses)) (not (adjacent (hanger_of silk) (hanger_of rayon)))))",
        "(exists ((d Dresses)) (not (adjacent (hanger_of wool) (hanger_of rayon))))",
        "(not (exists ((d Dresses)) (not (adjacent (hanger_of wool) (hanger_of rayon)))))"
      ],
      "type": "unsat",
      "perplexity": [
        1.155895709991455,
        1.0499286651611328
      ],
      "answer": "D",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "SyntaxError: invalid syntax. Perhaps you forgot a comma?"
    }
  },
  {
    "id": 29,
    "nl_problem": {
      "context": "A closet contains exactly six hangers—1, 2, 3, 4, 5, and 6—hanging, in that order, from left to right. It also contains exactly six dresses—one gauze, one linen, one polyester, one rayon, one silk, and one wool—a different dress on each of the hangers, in an order satisfying the following conditions: The gauze dress is on a lower-numbered hanger than the polyester dress. The rayon dress is on hanger 1 or hanger 6. Either the wool dress or the silk dress is on hanger 3. The linen dress hangs immediately to the right of the silk dress.",
      "question": "Assume that the original condition that the linen dress hangs immediately to the right of the silk dress is replaced by the condition that the wool dress hangs immediately to the right of the silk dress. If all the other initial conditions remain in effect, which one of the following must be false?",
      "options": [
        "A) The linen dress is on hanger 1.",
        "B) The gauze dress is on hanger 2.",
        "C) The wool dress is on hanger 4.",
        "D) The silk dress is on hanger 5.",
        "E) The polyester dress is on hanger 6."
      ]
    },
    "answer": "D",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((Hangers 0)) (((1) (2) (3) (4) (5) (6))))",
        "(declare-datatypes ((Dresses 0)) (((gauze) (linen) (polyester) (rayon) (silk) (wool))))",
        "(declare-fun on (Hangers Dresses) Bool)",
        "(define-fun before (a b) Bool (or (< a b) (and (= a b) (not (= b 6)))))"
      ],
      "constraints": [
        "(before (gauze) (polyester))",
        "(or (= (on 1 rayon) true) (= (on 6 rayon) true))",
        "(or (= (on 3 wool) true) (= (on 3 silk) true))",
        "(and (on (ite (on 5 silk) 6 5) linen) (not (on 6 linen)))",
        "(and (on (ite (on 5 silk) 6 5) wool) (not (on 6 wool)))"
      ],
      "options": [
        "(not (= (on 1 linen) true))",
        "(not (= (on 2 gauze) true))",
        "(not (= (on 4 wool) true))",
        "(not (= (on 5 silk) true))",
        "(not (= (on 6 polyester) true))"
      ],
      "type": [
        {
          "sat": 4,
          "unsat": 3
        }
      ],
      "perplexity": [
        1.1284812688827515,
        1.1523405313491821
      ],
      "answer": "D",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "SyntaxError: invalid syntax"
    }
  },
  {
    "id": 30,
    "nl_problem": {
      "context": "At a children's festival, exactly four songs are performed, each exactly once: \"Night's All Right,\" \"Question Man,\" \"Rhino Rock,\" and \"Sammy.\" The songs are performed consecutively, each on a different one of exactly four instruments: flute, guitar, harmonica, or keyboard. The songs are performed in accordance with the following: The first song performed is not performed on the flute. If \"Sammy\" is performed on the keyboard, then \"Rhino Rock\" is performed on the harmonica. If \"Question Man\" is performed on the keyboard, then \"Night's All Right\" is performed on the flute. The song performed on the keyboard immediately follows \"Rhino Rock\" and immediately precedes \"Night's All Right.\"",
      "question": "Which one of the following could be an accurate matching of the four songs performed at the festival with the instruments on which they are performed, listed in order from the first song performed to the last?",
      "options": [
        "A) \"Night's All Right\": guitar;\" Question Man\": keyboard; \"Sammy\": guitar;\" Rhino Rock\": flute",
        "B) \"Question Man\": guitar;\" Rhino Rock\": harmonica; \"Sammy\": keyboard;\" Night's All Right\": flute",
        "C) \"Rhino Rock\": flute;\" Question Man\": keyboard; \"Night's All Right\": harmonica;\" Sammy\": guitar",
        "D) \"Sammy\": harmonica;\" Night's All Right\": guitar; \"Question Man\": keyboard;\" Rhino Rock\": flute",
        "E) \"Sammy\": harmonica;\" Rhino Rock\": guitar; \"Question Man\": flute;\" Night's All Right\": keyboard"
      ]
    },
    "answer": "B",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((Songs 0)) (((Night's_All_Right) (Question_Man) (Rhino_Rock) (Sammy))))",
        "(declare-datatypes ((Instruments 0)) (((flute) (guitar) (harmonica) (keyboard))))",
        "(declare-datatypes ((Positions 0)) (((pos1) (pos2) (pos3) (pos4))))",
        "(declare-fun played (Songs Positions Instruments) Bool)"
      ],
      "constraints": [
        "(= (+ (to-int (played Night's_All_Right pos1 guitar)) (to-int (played Question_Man pos2 guitar)) (to-int (played Rhino_Rock pos3 guitar)) (to-int (played Sammy pos4 guitar)) (to-int (played Night's_All_Right pos1 flute)) (to-int (played Question_Man pos2 flute)) (to-int (played Rhino_Rock pos3 flute)) (to-int (played Sammy pos4 flute)) (to-int (played Night's_All_Right pos1 harmonica)) (to-int (played Question_Man pos2 harmonica)) (to-int (played Rhino_Rock pos3 harmonica)) (to-int (played Sammy pos4 harmonica)) (to-int (played Night's_All_Right pos1 keyboard)) (to-int (played Question_Man pos2 keyboard)) (to-int (played Rhino_Rock pos3 keyboard)) (to-int (played Sammy pos4 keyboard)) ) 1)",
        "(not (played Night's_All_Right pos1 flute))",
        "(forall ((p Positions) (i Instruments)) (=> (and (played Sammy p keyboard) (distinct p pos1) (distinct p pos2)) (played Rhino_Rock p harmonica)))",
        "(forall ((p Positions) (i Instruments)) (=> (and (played Question_Man p keyboard) (distinct p pos1) (distinct p pos2)) (played Night's_All_Right p flute)))",
        "(forall ((p Positions) (i Instruments)) (=> (and (played Rhino_Rock (ite (and (played Sammy p keyboard) (distinct p pos1) (distinct p pos2)) (ite (and (played Question_Man p keyboard) (distinct p pos1) (distinct p pos2)) pos3 p)) i) (played Night's_All_Right (ite (and (played Sammy p keyboard) (distinct p pos1) (distinct p pos2)) (ite (and (played Question_Man p keyboard) (distinct p pos1) (distinct p pos2)) pos4 (ite (and (played Sammy p keyboard) (distinct p pos1) (distinct p pos2)) (ite (and (played Question_Man p keyboard) (distinct p pos1) (distinct p pos2)) pos3 p)))) i)))))"
      ],
      "options": [
        "(forall ((p Positions)) (played Night's_All_Right p guitar) (played Question_Man p keyboard) (played Sammy p guitar) (played Rhino_Rock p flute))",
        "(forall ((p Positions)) (played Question_Man p guitar) (played Rhino_Rock p harmonica) (played Sammy p keyboard) (played Night's_All_Right p flute))",
        "(forall ((p Positions)) (played Rhino_Rock p flute) (played Question_Man p keyboard) (played Night's_All_Right p harmonica) (played Sammy p guitar))",
        "(forall ((p Positions)) (played Sammy p harmonica) (played Night's_All_Right p guitar) (played Question_Man p keyboard) (played Rhino_Rock p flute))",
        "(forall ((p Positions)) (played Sammy p harmonica) (played Rhino_Rock p guitar) (played Question_Man p flute) (played Night's_All_Right p keyboard))"
      ],
      "type": "sat",
      "perplexity": [
        1.0825928449630737,
        1.0503132343292236
      ],
      "answer": "B",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "SyntaxError: unterminated string literal (detected at line 9)"
    }
  },
  {
    "id": 31,
    "nl_problem": {
      "context": "At a children's festival, exactly four songs are performed, each exactly once: \"Night's All Right,\" \"Question Man,\" \"Rhino Rock,\" and \"Sammy.\" The songs are performed consecutively, each on a different one of exactly four instruments: flute, guitar, harmonica, or keyboard. The songs are performed in accordance with the following: The first song performed is not performed on the flute. If \"Sammy\" is performed on the keyboard, then \"Rhino Rock\" is performed on the harmonica. If \"Question Man\" is performed on the keyboard, then \"Night's All Right\" is performed on the flute. The song performed on the keyboard immediately follows \"Rhino Rock\" and immediately precedes \"Night's All Right.\"",
      "question": "Which one of the following could be true?",
      "options": [
        "A) \"Question Man\" immediately follows the song performed on the keyboard.",
        "B) \"Night's All Right\" immediately precedes the song performed on the keyboard.",
        "C) \"Question Man\" immediately precedes the song performed on the guitar.",
        "D) \"Rhino Rock\" immediately precedes the song performed on the harmonica.",
        "E) \"Sammy\" immediately precedes the song performed on the guitar."
      ]
    },
    "answer": "E",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((Songs 0)) (((Night_s_All_Right) (Question_Man) (Rhino_Rock) (Sammy)))",
        "(declare-datatypes ((Instruments 0)) (((flute) (guitar) (harmonica) (keyboard)))",
        "(declare-fun performs (Songs Instruments) Bool)",
        "(define-fun to-int ((b Bool)) Int (ite b 1 0))"
      ],
      "constraints": [
        "(forall ((s Songs)) (= (to-int (performs s flute)) 1 (to-int (performs s guitar)) 1 (to-int (performs s harmonica)) 1 (to-int (performs s keyboard)) 1))",
        "(forall ((s Songs)) (or (and (performs s flute) (performs (ite (= s Night_s_All_Right) Question_Man Rhino_Rock) guitar) (performs (ite (= s Rhino_Rock) Sammy Question_Man) keyboard) (performs (ite (= s Question_Man) Sammy Night_s_All_Right) harmonica)) (and (performs s guitar) (performs (ite (= s Night_s_All_Right) Question_Man Rhino_Rock) flute) (performs (ite (= s Rhino_Rock) Sammy Question_Man) keyboard) (performs (ite (= s Question_Man) Sammy Night_s_All_Right) harmonica)) (and (performs s harmonica) (performs (ite (= s Night_s_All_Right) Question_Man Rhino_Rock) guitar) (performs (ite (= s Rhino_Rock) Sammy Question_Man) keyboard) (performs (ite (= s Question_Man) Sammy Night_s_All_Right) flute)) (and (performs s keyboard) (performs (ite (= s Night_s_All_Right) Question_Man Rhino_Rock) guitar) (performs (ite (= s Rhino_Rock) Sammy Question_Man) flute) (performs (ite (= s Question_Man) Sammy Night_s_All_Right) harmonica))))",
        "(forall ((s Songs)) (=> (performs s flute) (not (= s Night_s_All_Right))))",
        "(forall ((s Songs)) (=> (and (performs s keyboard) (= s Sammy)) (performs Rhino_Rock harmonica)))",
        "(forall ((s Songs)) (=> (and (performs s keyboard) (= s Question_Man)) (performs Night_s_All_Right flute)))",
        "(forall ((s Songs)) (=> (and (performs Rhino_Rock guitar) (performs (ite (= s Sammy) Sammy Question_Man) keyboard) (performs (ite (= s Question_Man) Sammy Night_s_All_Right) flute)) (not (performs (ite (= s Sammy) Sammy Question_Man) flute)) (not (performs (ite (= s Question_Man) Sammy Night_s_All_Right) guitar))))"
      ],
      "options": [
        "(= (performs Question_Man (ite (= (performs (ite (= Sammy Sammy) Rhino_Rock Question_Man) keyboard) True) guitar flute))",
        "(= (performs Night_s_All_Right (ite (= (performs (ite (= Sammy Sammy) Rhino_Rock Question_Man) keyboard) True) guitar flute))",
        "(= (performs Question_Man (ite (= (performs (ite (= Sammy Sammy) Rhino_Rock Question_Man) guitar) True) flute harmonica))",
        "(= (performs Rhino_Rock (ite (= (performs (ite (= Sammy Sammy) Rhino_Rock Question_Man) guitar) True) flute harmonica))",
        "(= (performs Sammy (ite (= (performs (ite (= Sammy Sammy) Rhino_Rock Question_Man) guitar) True) flute harmonica))"
      ],
      "type": "unsat",
      "perplexity": [
        1.1326165199279785,
        1.0501046180725098
      ],
      "answer": "E",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "SyntaxError: invalid syntax. Perhaps you forgot a comma?"
    }
  },
  {
    "id": 32,
    "nl_problem": {
      "context": "At a children's festival, exactly four songs are performed, each exactly once: \"Night's All Right,\" \"Question Man,\" \"Rhino Rock,\" and \"Sammy.\" The songs are performed consecutively, each on a different one of exactly four instruments: flute, guitar, harmonica, or keyboard. The songs are performed in accordance with the following: The first song performed is not performed on the flute. If \"Sammy\" is performed on the keyboard, then \"Rhino Rock\" is performed on the harmonica. If \"Question Man\" is performed on the keyboard, then \"Night's All Right\" is performed on the flute. The song performed on the keyboard immediately follows \"Rhino Rock\" and immediately precedes \"Night's All Right.\"",
      "question": "Which one of the following CANNOT be true of the song performed on the flute?",
      "options": [
        "A) It immediately precedes \"Question Man.\"",
        "B) It immediately follows \"Question Man.\"",
        "C) It immediately precedes \"Rhino Rock.\"",
        "D) It immediately follows \"Night's All Right.\"",
        "E) It immediately follows \"Sammy.\""
      ]
    },
    "answer": "C",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((Songs 0)) (((Night's_All_Right) (Question_Man) (Rhino_Rock) (Sammy))))",
        "(declare-datatypes ((Instruments 0)) (((flute) (guitar) (harmonica) (keyboard)))",
        "(declare-datatypes ((Positions 0)) (((first) (second) (third) (fourth))))",
        "(declare-fun instrument (Songs) Instruments)",
        "(declare-fun position (Songs) Positions)"
      ],
      "constraints": [
        "(not (= (instrument Night's_All_Right) flute))",
        "(or (= (instrument Sammy) keyboard) (= (instrument Rhino_Rock) harmonica))",
        "(or (= (instrument Question_Man) keyboard) (= (instrument Night's_All_Right) flute))",
        "(and (= (position Rhino_Rock) second) (= (position Night's_All_Right) third) (= (instrument Sammy) keyboard))"
      ],
      "options": [
        "(and (= (position Night's_All_Right) first) (= (position Question_Man) second))",
        "(and (= (position Rhino_Rock) first) (= (position Night's_All_Right) second))",
        "(and (= (position Rhino_Rock) second) (= (position Night's_All_Right) third))",
        "(and (= (position Rhino_Rock) third) (= (position Night's_All_Right) fourth))",
        "(and (= (position Rhino_Rock) second) (= (position Sammy) third))"
      ],
      "type": "sat",
      "perplexity": [
        1.1393035650253296,
        1.1466137170791626
      ],
      "answer": "C",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "SyntaxError: unterminated string literal (detected at line 8)"
    }
  },
  {
    "id": 33,
    "nl_problem": {
      "context": "At a children's festival, exactly four songs are performed, each exactly once: \"Night's All Right,\" \"Question Man,\" \"Rhino Rock,\" and \"Sammy.\" The songs are performed consecutively, each on a different one of exactly four instruments: flute, guitar, harmonica, or keyboard. The songs are performed in accordance with the following: The first song performed is not performed on the flute. If \"Sammy\" is performed on the keyboard, then \"Rhino Rock\" is performed on the harmonica. If \"Question Man\" is performed on the keyboard, then \"Night's All Right\" is performed on the flute. The song performed on the keyboard immediately follows \"Rhino Rock\" and immediately precedes \"Night's All Right.\"",
      "question": "If \"Rhino Rock\" is the second song performed at the festival, then which one of the following could be true?",
      "options": [
        "A) The first song performed is performed on the keyboard.",
        "B) The third song performed is performed on the guitar.",
        "C) The third song performed is performed on the flute.",
        "D) \"Night's All Right\" is performed on the guitar.",
        "E) \"Rhino Rock\" is performed on the guitar."
      ]
    },
    "answer": "E",
    "logic_problem": {
      "smtlib2": {
        "declarations": [
          "(declare-datatypes ((Songs 0)) (((night_all_right) (question_man) (rhino_rock) (sammy)))",
          "(declare-datatypes ((Instruments 0)) (((flute) (guitar) (harmonica) (keyboard)))",
          "(declare-fun performed (Songs Instruments) Bool)",
          "(define-fun to-int ((b Bool)) Int (ite b 1 0))"
        ],
        "constraints": [
          "(= (to-int (performed night_all_right flute)) (to-int (performed question_man guitar)) (to-int (performed rhino_rock harmonica)) (to-int (performed sammy keyboard)))",
          "(forall ((s Songs) (i Instruments)) (let ((p1 (performed night_all_right flute)) (p2 (performed question_man guitar)) (p3 (performed rhino_rock harmonica)) (p4 (performed sammy keyboard))) (ite (and s i) (ite (= i flute) (ite (= s night_all_right) p1 (ite (= s question_man) (ite (= i guitar) p2 false) false)) false) (ite (= i guitar) (ite (= s question_man) (ite (= i flute) (ite (= s night_all_right) p1 false) false) false) (ite (= i harmonica) (ite (= s rhino_rock) (ite (= i keyboard) (ite (= s night_all_right) (ite (= i flute) p1 false) false) false) false) false)) false)))",
          "(not (performed night_all_right flute))",
          "(forall ((i Instruments)) (=> (performed sammy keyboard) (performed rhino_rock harmonica)))",
          "(forall ((i Instruments)) (=> (performed question_man keyboard) (performed night_all_right flute)))",
          "(forall ((i Instruments)) (=> (and (performed rhino_rock i) (performed night_all_right (ite (not (= i keyboard)) i keyboard))) (performed sammy keyboard)))",
          "(forall ((m Songs)) (= (performed (ite (= m night_all_right) question_man (ite (= m question_man) rhino_rock (ite (= m rhino_rock) sammy night_all_right))) guitar))",
          "(forall ((m Songs)) (= (performed (ite (= m night_all_right) question_man (ite (= m question_man) rhino_rock (ite (= m rhino_rock) sammy night_all_right))) flute))",
          "(forall ((m Songs)) (= (performed (ite (= m night_all_right) question_man (ite (= m question_man) rhino_rock (ite (= m rhino_rock) sammy night_all_right))) guitar) (performed night_all_right guitar)))",
          "(forall ((m Songs)) (= (performed (ite (= m night_all_right) question_man (ite (= m question_man) rhino_rock (ite (= m rhino_rock) sammy night_all_right))) guitar) (performed rhino_rock guitar)))"
        ],
        "options": [
          "(forall ((m Songs)) (= (performed (ite (= m night_all_right) question_man (ite (= m question_man) rhino_rock (ite (= m rhino_rock) sammy night_all_right))) guitar))",
          "(forall ((m Songs)) (= (performed (ite (= m night_all_right) question_man (ite (= m question_man) rhino_rock (ite (= m rhino_rock) sammy night_all_right))) flute))",
          "(forall ((m Songs)) (= (performed (ite (= m night_all_right) question_man (ite (= m question_man) rhino_rock (ite (= m rhino_rock) sammy night_all_right))) guitar) (performed night_all_right guitar))",
          "(forall ((m Songs)) (= (performed (ite (= m night_all_right) question_man (ite (= m question_man) rhino_rock (ite (= m rhino_rock) sammy night_all_right))) guitar) (performed rhino_rock guitar)))"
        ],
        "type": "sat"
      },
      "perplexity": [
        1.1328480243682861,
        1.0670011043548584
      ],
      "answer": "E",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "No Output"
    }
  },
  {
    "id": 34,
    "nl_problem": {
      "context": "At a children's festival, exactly four songs are performed, each exactly once: \"Night's All Right,\" \"Question Man,\" \"Rhino Rock,\" and \"Sammy.\" The songs are performed consecutively, each on a different one of exactly four instruments: flute, guitar, harmonica, or keyboard. The songs are performed in accordance with the following: The first song performed is not performed on the flute. If \"Sammy\" is performed on the keyboard, then \"Rhino Rock\" is performed on the harmonica. If \"Question Man\" is performed on the keyboard, then \"Night's All Right\" is performed on the flute. The song performed on the keyboard immediately follows \"Rhino Rock\" and immediately precedes \"Night's All Right.\"",
      "question": "If \"Question Man\" is the third song performed at the festival, then each of the following could be true EXCEPT:",
      "options": [
        "A) \"Question Man\" is performed on the guitar.",
        "B) \"Question Man\" is performed on the keyboard.",
        "C) \"Rhino Rock\" is performed on the guitar.",
        "D) \"Sammy\" is performed on the guitar.",
        "E) \"Sammy\" is performed on the harmonica."
      ]
    },
    "answer": "A",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((Songs 0)) (((Night_s_All_Right) (Question_Man) (Rhino_Rock) (Sammy)))",
        "(declare-datatypes ((Instruments 0)) (((flute) (guitar) (harmonica) (keyboard)))",
        "(declare-fun song_performed (Songs) (Instruments))",
        "(define-fun to-int ((b Bool)) Int (ite b 1 0))"
      ],
      "constraints": [
        "(not (= (song_performed Night_s_All_Right) flute))",
        "(or (and (not (= (song_performed Sammy) keyboard)) (not (= (song_performed Rhino_Rock) harmonica))) (and (= (song_performed Sammy) keyboard) (= (song_performed Rhino_Rock) harmonica)))",
        "(or (and (not (= (song_performed Question_Man) keyboard)) (not (= (song_performed Night_s_All_Right) flute))) (and (= (song_performed Question_Man) keyboard) (= (song_performed Night_s_All_Right) flute)))",
        "(or (and (= (song_performed Rhino_Rock) (ite (= (song_performed keyboard) guitar) guitar (ite (= (song_performed keyboard) harmonica) harmonica (ite (= (song_performed keyboard) keyboard) keyboard flute)))) (= (song_performed Night_s_All_Right) (ite (= (song_performed keyboard) guitar) guitar (ite (= (song_performed keyboard) harmonica) harmonica (ite (= (song_performed keyboard) keyboard) keyboard flute)))) (and (= (song_performed Night_s_All_Right) (ite (= (song_performed keyboard) guitar) guitar (ite (= (song_performed keyboard) harmonica) harmonica (ite (= (song_performed keyboard) keyboard) keyboard flute)))) (= (song_performed Rhino_Rock) (ite (= (song_performed keyboard) guitar) guitar (ite (= (song_performed keyboard) harmonica) harmonica (ite (= (song_performed keyboard) keyboard) keyboard flute)))))",
        "(= (+ (to-int (not (= (song_performed Night_s_All_Right) (song_performed Question_Man)))) (to-int (not (= (song_performed Night_s_All_Right) (song_performed Rhino_Rock)))) (to-int (not (= (song_performed Night_s_All_Right) (song_performed Sammy)))) (to-int (not (= (song_performed Question_Man) (song_performed Rhino_Rock)))) (to-int (not (= (song_performed Question_Man) (song_performed Sammy)))) (to-int (not (= (song_performed Rhino_Rock) (song_performed Sammy)))) 1)"
      ],
      "options": [
        "(not (= (song_performed Question_Man) guitar))",
        "(not (= (song_performed Question_Man) keyboard))",
        "(not (= (song_performed Rhino_Rock) guitar))",
        "(not (= (song_performed Sammy) guitar))",
        "(not (= (song_performed Sammy) harmonica))"
      ],
      "type": "unsat",
      "perplexity": [
        1.1348230838775635,
        1.0621871948242188
      ],
      "answer": "A",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "SyntaxError: invalid syntax"
    }
  },
  {
    "id": 35,
    "nl_problem": {
      "context": "Each of the seven members of the board of directors—Guzman, Hawking, Lepp, Miyauchi, Upchurch, Wharton, and Zhu—serves on exactly one of two committees—the finance committee or the incentives committee. Only board members serve on these committees. Committee membership is consistent with the following conditions: If Guzman serves on the finance committee, then Hawking serves on the incentives committee. If Lepp serves on the finance committee, then Miyauchi and Upchurch both serve on the incentives committee. Wharton serves on a different committee from the one on which Zhu serves. Upchurch serves on a different committee from the one on which Guzman serves. If Zhu serves on the finance committee, so does Hawking.",
      "question": "Which one of the following could be a complete and accurate list of the members of the finance committee?",
      "options": [
        "A) Guzman, Hawking, Miyauchi, Wharton",
        "B) Guzman, Lepp, Zhu",
        "C) Hawking, Miyauchi, Zhu",
        "D) Hawking, Upchurch, Wharton, Zhu",
        "E) Miyauchi, Upchurch, Wharton"
      ]
    },
    "answer": "E",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((People 0)) (((Guzman) (Hawking) (Lepp) (Miyauchi) (Upchurch) (Wharton) (Zhu))))",
        "(declare-datatypes ((Committees 0)) (((finance) (incentives))))",
        "(declare-fun serves (People Committees) Bool)"
      ],
      "constraints": [
        "(=> (serves Guzman finance) (serves Hawking incentives))",
        "(=> (serves Lepp finance) (and (serves Miyauchi incentives) (serves Upchurch incentives)))",
        "(not (= (serves Wharton finance) (serves Zhu finance)))",
        "(not (= (serves Upchurch finance) (serves Guzman finance)))",
        "(=> (serves Zhu finance) (serves Hawking finance))"
      ],
      "options": [
        "(forall ((c Committees)) (or (= (serves Guzman c) (serves Hawking c)) (= (serves Guzman c) (serves Miyauchi c)) (= (serves Guzman c) (serves Zhu c))))",
        "(forall ((c Committees)) (or (= (serves Guzman c) (serves Wharton c)) (= (serves Guzman c) (serves Upchurch c))))",
        "(forall ((c Committees)) (or (= (serves Guzman c) (serves Lepp c)) (= (serves Guzman c) (serves Miyauchi c)) (= (serves Guzman c) (serves Zhu c))))",
        "(forall ((c Committees)) (or (= (serves Guzman c) (serves Hawking c)) (= (serves Guzman c) (serves Upchurch c))))",
        "(forall ((c Committees)) (or (= (serves Hawking c) (serves Miyauchi c)) (= (serves Hawking c) (serves Zhu c))))",
        "(forall ((c Committees)) (or (= (serves Miyauchi c) (serves Hawking c)) (= (serves Miyauchi c) (serves Wharton c))))",
        "(forall ((c Committees)) (or (= (serves Hawking c) (serves Upchurch c)) (= (serves Hawking c) (serves Zhu c))))",
        "(forall ((c Committees)) (or (= (serves Upchurch c) (serves Wharton c)) (= (serves Upchurch c) (serves Zhu c))))",
        "(forall ((c Committees)) (or (= (serves Zhu c) (serves Lepp c)) (= (serves Zhu c) (serves Wharton c))))",
        "(forall ((c Committees)) (or (= (serves Zhu c) (serves Miyauchi c)) (= (serves Zhu c) (serves Hawking c))))",
        "(forall ((c Committees)) (or (= (serves Wharton c) (serves Miyauchi c)) (= (serves Wharton c) (serves Lepp c))))",
        "(forall ((c Committees)) (or (= (serves Lepp c) (serves Zhu c)) (= (serves Lepp c) (serves Upchurch c))))",
        "(forall ((c Committees)) (or (= (serves Lepp c) (serves Hawking c)) (= (serves Lepp c) (serves Zhu c))))",
        "(forall ((c Committees)) (or (= (serves Miyauchi c) (serves Upchurch c)) (= (serves Miyauchi c) (serves Zhu c))))",
        "(forall ((c Committees)) (or (= (serves Miyauchi c) (serves Wharton c)) (= (serves Miyauchi c) (serves Hawking c))))",
        "(forall ((c Committees)) (or (= (serves Upchurch c) (serves Zhu c)) (= (serves Upchurch c) (serves Wharton c))))",
        "(forall ((c Committees)) (or (= (serves Upchurch c) (serves Lepp c)) (= (serves Upchurch c) (serves Guzman c))))",
        "(forall ((c Committees)) (or (= (serves Guzman c) (serves Zhu c)) (= (serves Guzman c) (serves Upchurch c))))",
        "(forall ((c Committees)) (or (= (serves Guzman c) (serves Wharton c)) (= (serves Guzman c) (serves Lepp c))))"
      ],
      "type": "unsat",
      "perplexity": [
        1.1637017726898193,
        1.114715576171875
      ],
      "answer": "E",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "SyntaxError: invalid syntax"
    }
  },
  {
    "id": 36,
    "nl_problem": {
      "context": "Each of the seven members of the board of directors—Guzman, Hawking, Lepp, Miyauchi, Upchurch, Wharton, and Zhu—serves on exactly one of two committees—the finance committee or the incentives committee. Only board members serve on these committees. Committee membership is consistent with the following conditions: If Guzman serves on the finance committee, then Hawking serves on the incentives committee. If Lepp serves on the finance committee, then Miyauchi and Upchurch both serve on the incentives committee. Wharton serves on a different committee from the one on which Zhu serves. Upchurch serves on a different committee from the one on which Guzman serves. If Zhu serves on the finance committee, so does Hawking.",
      "question": "Which one of the following pairs of board members CANNOT both serve on the incentives committee?",
      "options": [
        "A) Guzman and Hawking",
        "B) Guzman and Wharton",
        "C) Hawking and Wharton",
        "D) Miyauchi and Upchurch",
        "E) Miyauchi and Wharton"
      ]
    },
    "answer": "C",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((BoardMembers 0)) (((Guzman) (Hawking) (Lepp) (Miyauchi) (Upchurch) (Wharton) (Zhu))))",
        "(declare-datatypes ((Committees 0)) (((finance committee) (incentives committee)))",
        "(declare-fun serves (BoardMembers Committees) Bool)"
      ],
      "constraints": [
        "(forall ((c Committees)) (ite (= (serves Guzman finance committee) true) (not (= (serves Hawking incentives committee) true)) (= (serves Hawking incentives committee) true)))",
        "(forall ((c Committees)) (ite (= (serves Lepp finance committee) true) (and (= (serves Miyauchi incentives committee) true) (= (serves Upchurch incentives committee) true)) (not (and (= (serves Miyauchi incentives committee) true) (= (serves Upchurch incentives committee) true)))))",
        "(not (= (serves Wharton finance committee) (serves Zhu finance committee)))",
        "(not (= (serves Upchurch finance committee) (serves Guzman finance committee)))",
        "(forall ((c Committees)) (ite (= (serves Zhu finance committee) true) (= (serves Hawking finance committee) true) (not (= (serves Hawking finance committee) true))))"
      ],
      "options": [
        "(not (forall ((c Committees)) (= (serves Guzman c) (serves Hawking c))))",
        "(not (forall ((c Committees)) (= (serves Guzman c) (serves Wharton c))))",
        "(not (forall ((c Committees)) (= (serves Hawking c) (serves Wharton c))))",
        "(not (forall ((c Committees)) (= (serves Miyauchi c) (serves Upchurch c))))",
        "(not (forall ((c Committees)) (= (serves Miyauchi c) (serves Wharton c))))"
      ],
      "type": "unsat",
      "perplexity": [
        1.1042158603668213,
        1.09285569190979
      ],
      "answer": "C",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "SyntaxError: invalid syntax"
    }
  },
  {
    "id": 37,
    "nl_problem": {
      "context": "Each of the seven members of the board of directors—Guzman, Hawking, Lepp, Miyauchi, Upchurch, Wharton, and Zhu—serves on exactly one of two committees—the finance committee or the incentives committee. Only board members serve on these committees. Committee membership is consistent with the following conditions: If Guzman serves on the finance committee, then Hawking serves on the incentives committee. If Lepp serves on the finance committee, then Miyauchi and Upchurch both serve on the incentives committee. Wharton serves on a different committee from the one on which Zhu serves. Upchurch serves on a different committee from the one on which Guzman serves. If Zhu serves on the finance committee, so does Hawking.",
      "question": "What is the maximum number of members on the finance committee?",
      "options": [
        "A) two",
        "B) three",
        "C) four",
        "D) five",
        "E) six"
      ]
    },
    "answer": "C",
    "logic_problem": {
      "perplexity": [
        1.0559508800506592,
        1251725.25
      ],
      "answer": "C",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "No Output"
    }
  },
  {
    "id": 38,
    "nl_problem": {
      "context": "Each of the seven members of the board of directors—Guzman, Hawking, Lepp, Miyauchi, Upchurch, Wharton, and Zhu—serves on exactly one of two committees—the finance committee or the incentives committee. Only board members serve on these committees. Committee membership is consistent with the following conditions: If Guzman serves on the finance committee, then Hawking serves on the incentives committee. If Lepp serves on the finance committee, then Miyauchi and Upchurch both serve on the incentives committee. Wharton serves on a different committee from the one on which Zhu serves. Upchurch serves on a different committee from the one on which Guzman serves. If Zhu serves on the finance committee, so does Hawking.",
      "question": "If Miyauchi and Wharton both serve on the finance committee, then which one of the following could be true?",
      "options": [
        "A) Guzman and Lepp both serve on the finance committee.",
        "B) Guzman and Upchurch both serve on the incentives committee.",
        "C) Hawking and Zhu both serve on the finance committee.",
        "D) Lepp and Upchurch both serve on the incentives committee.",
        "E) Zhu and Upchurch both serve on the finance committee."
      ]
    },
    "answer": "D",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((People 0)) (((Guzman) (Hawking) (Lepp) (Miyauchi) (Upchurch) (Wharton) (Zhu))))",
        "(declare-datatypes ((Committees 0)) (((finance) (incentives))))",
        "(declare-fun serves (People Committees) Bool)",
        "(define-fun to-int ((b Bool)) Int (ite b 1 0))"
      ],
      "constraints": [
        "(forall ((p People)) (= (+ (to-int (serves p finance)) (to-int (serves p incentives))) 1))",
        "(=> (serves Guzman finance) (serves Hawking incentives))",
        "(=> (serves Lepp finance) (and (serves Miyauchi incentives) (serves Upchurch incentives)))",
        "(or (not (serves Wharton finance)) (not (serves Zhu finance)) (not (serves Wharton incentives)) (not (serves Zhu incentives)))",
        "(or (not (serves Upchurch finance)) (not (serves Guzman finance)) (not (serves Upchurch incentives)) (not (serves Guzman incentives)))",
        "(=> (serves Zhu finance) (serves Hawking finance))"
      ],
      "options": [
        "(serves Miyauchi finance) (serves Wharton finance)",
        "(serves Miyauchi finance) (serves Wharton finance)",
        "(serves Guzman incentives) (serves Upchurch incentives)",
        "(serves Miyauchi finance) (serves Wharton finance)",
        "(serves Lepp incentives) (serves Upchurch incentives)",
        "(serves Miyauchi finance) (serves Wharton finance)"
      ],
      "type": "unsat",
      "perplexity": [
        1.1672718524932861,
        1.1299383640289307
      ],
      "answer": "D",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "SyntaxError: invalid syntax. Perhaps you forgot a comma?"
    }
  },
  {
    "id": 40,
    "nl_problem": {
      "context": "Eight people—Fiona, George, Harriet, Ingrid, Karl, Manuel, Olivia, and Peter—are sitting, evenly spaced, around a circular picnic table. Any two of them are said to be sitting directly across from one another if and only if there are exactly three other people sitting between them, counting in either direction around the table. The following conditions apply: Fiona sits directly across from George. Harriet sits immediately next to neither Fiona nor Karl. Ingrid sits immediately next to, and immediately clockwise from, Olivia.",
      "question": "Which one of the following could be the order in which four of the people are seated, with no one else seated between them, counting clockwise around the table?",
      "options": [
        "A) George, Peter, Karl, Fiona",
        "B) Harriet, Olivia, Ingrid, Karl",
        "C) Ingrid, Fiona, Peter, Manuel",
        "D) Olivia, Manuel, Karl, George",
        "E) Peter, Harriet, Karl, Fiona"
      ]
    },
    "answer": "C",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((People 0)) (((Fiona) (George) (Harriet) (Ingrid) (Karl) (Manuel) (Olivia) (Peter)))",
        "(declare-fun next (People People) Bool)",
        "(declare-fun across (People People) Bool)",
        "(define-fun to-int ((b Bool)) Int (ite b 1 0))"
      ],
      "constraints": [
        "(across Fiona George)",
        "(and (next Ingrid Olivia) (next Olivia Ingrid))",
        "(forall ((p People)) (or (not (next Harriet Fiona)) (not (next Harriet Karl))))"
      ],
      "options": [
        "(exists ((s1 People) (s2 People) (s3 People) (s4 People)) (and (not (across s1 s2)) (not (across s2 s3)) (not (across s3 s4)) (not (across s4 s1)) (= (next s1 s2) (next s2 s3)) (= (next s2 s3) (next s3 s4)) (= (next s3 s4) (next s4 s1)) (or (= (across s1 s3) true) (= (across s1 s4) true) (= (across s2 s4) true))))",
        "(forall ((m Meals)) (= (next s1 s2) (next m m)))",
        "(check-sat)",
        "(assert (= s1 Peter))",
        "(assert (= s2 Harriet))",
        "(assert (= s3 Karl))",
        "(assert (= s4 Fiona))",
        "(check-sat)",
        "(pop)"
      ],
      "type": "sat",
      "perplexity": [
        1.0867305994033813,
        1.0359991788864136
      ],
      "answer": "C",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "SyntaxError: invalid syntax. Perhaps you forgot a comma?"
    }
  },
  {
    "id": 41,
    "nl_problem": {
      "context": "Eight people—Fiona, George, Harriet, Ingrid, Karl, Manuel, Olivia, and Peter—are sitting, evenly spaced, around a circular picnic table. Any two of them are said to be sitting directly across from one another if and only if there are exactly three other people sitting between them, counting in either direction around the table. The following conditions apply: Fiona sits directly across from George. Harriet sits immediately next to neither Fiona nor Karl. Ingrid sits immediately next to, and immediately clockwise from, Olivia.",
      "question": "If Harriet and Olivia each sits immediately next to George, then which one of the following could be the two people each of whom sits immediately next to Peter?",
      "options": [
        "A) Fiona and Karl",
        "B) Fiona and Olivia",
        "C) Harriet and Ingrid",
        "D) Harriet and Karl",
        "E) Karl and Manuel"
      ]
    },
    "answer": "D",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((People 0)) (((Fiona) (George) (Harriet) (Ingrid) (Karl) (Manuel) (Olivia) (Peter))))",
        "(declare-datatypes ((Directions 0)) (((clockwise) (counterclockwise))))",
        "(declare-fun sits (People People) Bool)"
      ],
      "constraints": [
        "(= (sits Fiona George) true)",
        "(forall ((d Directions)) (or (not (and (sits Harriet (ite d clockwise Fiona (ite d clockwise Karl Fiona))) d)) (not (and (sits Harriet (ite d clockwise Karl (ite d clockwise Fiona Karl))) d))))",
        "(forall ((d Directions)) (and (ite d clockwise (sits Ingrid Olivia) (sits Olivia Ingrid)) d))",
        "(define-fun next-to-peter ((p People) (d Directions)) Bool (or (ite d clockwise (sits p Peter) (sits Peter p)) (ite d clockwise (sits p (ite d clockwise Peter (ite d clockwise (ite d clockwise Peter (ite d clockwise Peter (ite d clockwise (ite d clockwise Peter (ite d clockwise Peter Karl)))))))) (ite d clockwise Karl (ite d clockwise (ite d clockwise Peter Karl)))))))) (ite d clockwise (ite d clockwise Peter Karl)) (ite d clockwise (ite d clockwise (ite d clockwise (ite d clockwise Peter Karl)))))",
        "(forall ((d Directions)) (or (and (next-to-peter Fiona d) (next-to-peter Karl d)) (not (next-to-peter Fiona d)) (not (next-to-peter Karl d))))",
        "(forall ((d Directions)) (or (and (next-to-peter Fiona d) (next-to-peter Olivia d)) (not (next-to-peter Fiona d)) (not (next-to-peter Olivia d))))",
        "(forall ((d Directions)) (or (and (next-to-peter Harriet d) (next-to-peter Ingrid d)) (not (next-to-peter Harriet d)) (not (next-to-peter Ingrid d))))",
        "(forall ((d Directions)) (or (and (next-to-peter Harriet d) (next-to-peter Karl d)) (not (next-to-peter Harriet d)) (not (next-to-peter Karl d))))",
        "(forall ((d Directions)) (or (and (next-to-peter Karl d) (next-to-peter Manuel d)) (not (next-to-peter Karl d)) (not (next-to-peter Manuel d))))"
      ],
      "options": [],
      "type": "sat",
      "perplexity": [
        1.21661376953125,
        1.0807615518569946
      ],
      "answer": "D",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "SyntaxError: unmatched ')'"
    }
  },
  {
    "id": 42,
    "nl_problem": {
      "context": "Eight people—Fiona, George, Harriet, Ingrid, Karl, Manuel, Olivia, and Peter—are sitting, evenly spaced, around a circular picnic table. Any two of them are said to be sitting directly across from one another if and only if there are exactly three other people sitting between them, counting in either direction around the table. The following conditions apply: Fiona sits directly across from George. Harriet sits immediately next to neither Fiona nor Karl. Ingrid sits immediately next to, and immediately clockwise from, Olivia.",
      "question": "If George does not sit immediately next to Harriet, then which one of the following could be the two people each of whom sits immediately next to Manuel?",
      "options": [
        "A) Fiona and Harriet",
        "B) Fiona and Peter",
        "C) George and Karl",
        "D) George and Peter",
        "E) Harriet and Peter"
      ]
    },
    "answer": "A",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((People 0)) (((Fiona) (George) (Harriet) (Ingrid) (Karl) (Manuel) (Olivia) (Peter))))",
        "(define-fun next ((p People) (q People)) Bool (ite (= p Fiona) (= q George) (ite (= p George) (= q Fiona) (ite (= p Harriet) Karl (ite (= p Karl) Harriet (ite (= p Ingrid) Olivia (ite (= p Olivia) Ingrid (ite (= p Manuel) Peter (ite (= p Peter) Manuel (ite (= p Harriet) Karl (ite (= p Karl) Harriet (ite (= p Ingrid) Olivia (ite (= p Olivia) Ingrid (ite (= p George) Peter (ite (= p Peter) George (ite (= p Fiona) Olivia (ite (= p Olivia) Fiona (ite (= p Manuel) Karl (ite (= p Karl) Manuel (ite (= p Peter) Ingrid (ite (= p Ingrid) Peter (ite (= p George) Harriet (ite (= p Harriet) George (ite (= p Karl) Fiona (ite (= p Fiona) Karl (ite (= p Olivia) Manuel (ite (= p Manuel) Olivia (ite (= p Harriet) George (ite (= p George) Harriet (ite (= p Ingrid) Karl (ite (= p Karl) Ingrid (ite (= p Peter) Harriet (ite (= p Harriet) Peter (ite (= p Fiona) Ingrid (ite (= p Ingrid) Fiona (ite (= p Manuel) George (ite (= p George) Manuel true))))))))))))))))))))))))))))))))))))))))",
        "(define-fun adjacent ((p People) (q People)) Bool (= (ite (next p q) 1 0) 1))"
      ],
      "constraints": [
        "(= (adjacent Fiona George) true)",
        "(forall ((p People)) (and (not (adjacent Harriet p)) (not (adjacent p Fiona)) (not (adjacent p Karl))))",
        "(and (= (adjacent Ingrid Olivia) true) (= (next Ingrid Olivia) true))"
      ],
      "options": [
        "(not (adjacent George Harriet))",
        "(forall ((p People)) (= (adjacent Manuel p) (adjacent (next Manuel p) p)))",
        "(forall ((p People)) (= (adjacent Manuel p) (adjacent (ite (= p Fiona) Karl p) p)))",
        "(forall ((p People)) (= (adjacent Manuel p) (adjacent (ite (= p George) Peter p) p)))",
        "(forall ((p People)) (= (adjacent Manuel p) (adjacent (ite (= p Harriet) Peter p) p)))",
        "(forall ((p People)) (= (adjacent Manuel p) (adjacent (ite (= p Peter) Harriet p) p)))"
      ],
      "type": "sat",
      "perplexity": [
        1.1530531644821167,
        1.0721018314361572
      ],
      "answer": "A",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "SyntaxError: invalid syntax"
    }
  },
  {
    "id": 43,
    "nl_problem": {
      "context": "Eight people—Fiona, George, Harriet, Ingrid, Karl, Manuel, Olivia, and Peter—are sitting, evenly spaced, around a circular picnic table. Any two of them are said to be sitting directly across from one another if and only if there are exactly three other people sitting between them, counting in either direction around the table. The following conditions apply: Fiona sits directly across from George. Harriet sits immediately next to neither Fiona nor Karl. Ingrid sits immediately next to, and immediately clockwise from, Olivia.",
      "question": "If Manuel sits immediately next to Olivia, then which one of the following people must sit immediately next to Fiona?",
      "options": [
        "A) Harriet",
        "B) Ingrid",
        "C) Karl",
        "D) Manuel",
        "E) Peter"
      ]
    },
    "answer": "C",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((People 0)) (((Fiona) (George) (Harriet) (Ingrid) (Karl) (Manuel) (Olivia) (Peter))))",
        "(declare-fun sits (People People) Bool)"
      ],
      "constraints": [
        "(exists ((x People)) (and (sits Fiona x) (sits x George)))",
        "(not (or (and (sits Harriet Fiona) (sits Fiona Karl)) (and (sits Harriet Karl) (sits Karl Fiona))))",
        "(and (sits Ingrid Olivia) (sits Olivia Ingrid))",
        "(exists ((x People)) (and (sits Manuel x) (sits x Olivia)))",
        "(= (sits Olivia Peter) true)"
      ],
      "options": [
        "(exists ((x People)) (and (sits x Fiona) (sits x Harriet)))",
        "(exists ((x People)) (and (sits x Fiona) (sits x Ingrid)))",
        "(exists ((x People)) (and (sits x Fiona) (sits x Karl)))",
        "(exists ((x People)) (and (sits x Fiona) (sits x Manuel)))",
        "(exists ((x People)) (and (sits x Fiona) (sits x Peter)))"
      ],
      "type": "unsat",
      "perplexity": [
        1.2670838832855225,
        1.1436741352081299
      ],
      "answer": "C",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "SyntaxError: invalid syntax. Perhaps you forgot a comma?"
    }
  },
  {
    "id": 44,
    "nl_problem": {
      "context": "Eight people—Fiona, George, Harriet, Ingrid, Karl, Manuel, Olivia, and Peter—are sitting, evenly spaced, around a circular picnic table. Any two of them are said to be sitting directly across from one another if and only if there are exactly three other people sitting between them, counting in either direction around the table. The following conditions apply: Fiona sits directly across from George. Harriet sits immediately next to neither Fiona nor Karl. Ingrid sits immediately next to, and immediately clockwise from, Olivia.",
      "question": "What is the minimum possible number of people sitting between Ingrid and Manuel, counting clockwise from Ingrid around the table?",
      "options": [
        "A) zero",
        "B) one",
        "C) two",
        "D) three",
        "E) four"
      ]
    },
    "answer": "A",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((People 0)) (((Fiona) (George) (Harriet) (Ingrid) (Karl) (Manuel) (Olivia) (Peter))))",
        "(declare-fun sits (People People) Bool)",
        "(define-fun distance ((p1 People) (p2 People)) Int (ite (= p1 p2) 0 (ite (< (distance p1 Fiona) (distance p2 Fiona)) (- (distance p1 Fiona) (distance p2 Fiona)) (- (distance p1 Fiona) (distance p2 Fiona)))))"
      ],
      "constraints": [
        "(not (= (distance Fiona George) 1))",
        "(not (or (= (distance Harriet Fiona) 1) (= (distance Harriet Karl) 1)))",
        "(and (= (distance Ingrid Olivia) 1) (not (= (distance Ingrid (ite (= (distance Olivia Fiona) (ite (= (distance Fiona Karl) 1) 2 (ite (= (distance Fiona Karl) 2) 1 (- (distance Fiona Karl) 1)))) (- 4)) 1)))",
        "(forall ((m People)) (not (= (distance Ingrid m) 0)))"
      ],
      "options": [
        "(= (distance Ingrid Manuel) 0)",
        "(= (distance Ingrid Manuel) 1)",
        "(= (distance Ingrid Manuel) 2)",
        "(= (distance Ingrid Manuel) 3)",
        "(= (distance Ingrid Manuel) 4)"
      ],
      "type": "sat",
      "perplexity": [
        1.154281497001648,
        1.1994129419326782
      ],
      "answer": "A",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "SyntaxError: invalid syntax"
    }
  },
  {
    "id": 45,
    "nl_problem": {
      "context": "Eight people—Fiona, George, Harriet, Ingrid, Karl, Manuel, Olivia, and Peter—are sitting, evenly spaced, around a circular picnic table. Any two of them are said to be sitting directly across from one another if and only if there are exactly three other people sitting between them, counting in either direction around the table. The following conditions apply: Fiona sits directly across from George. Harriet sits immediately next to neither Fiona nor Karl. Ingrid sits immediately next to, and immediately clockwise from, Olivia.",
      "question": "If Karl sits directly across from Ingrid, then each of the following people could sit immediately next to Olivia EXCEPT:",
      "options": [
        "A) Fiona",
        "B) George",
        "C) Harriet",
        "D) Manuel",
        "E) Peter"
      ]
    },
    "answer": "B",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((People 0)) (((Fiona) (George) (Harriet) (Ingrid) (Karl) (Manuel) (Olivia) (Peter))))",
        "(declare-fun sits (People People) Bool)",
        "(define-fun distance ((p1 People) (p2 People)) Int (ite (= (sits p1 p2) true) 3 0))"
      ],
      "constraints": [
        "(sits Fiona George)",
        "(not (and (sits Harriet Fiona) (not (and (distance Harriet Fiona) (= (distance Harriet Fiona) 1)))))",
        "(not (and (sits Harriet Karl) (not (and (distance Harriet Karl) (= (distance Harriet Karl) 1)))))",
        "(and (sits Ingrid Olivia) (not (and (sits Ingrid (not Olivia)) (not (and (distance Ingrid (not Olivia)) (= (distance Ingrid (not Olivia)) 1)))))"
      ],
      "options": [
        "(sits Karl Ingrid)",
        "(not (or (sits Olivia Fiona) (sits Olivia George) (sits Olivia Harriet) (sits Olivia Manuel) (sits Olivia Peter)))"
      ],
      "type": "unsat",
      "perplexity": [
        1.2902847528457642,
        1.1379077434539795
      ],
      "answer": "B",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "SyntaxError: invalid syntax. Perhaps you forgot a comma?"
    }
  },
  {
    "id": 46,
    "nl_problem": {
      "context": "Eight people—Fiona, George, Harriet, Ingrid, Karl, Manuel, Olivia, and Peter—are sitting, evenly spaced, around a circular picnic table. Any two of them are said to be sitting directly across from one another if and only if there are exactly three other people sitting between them, counting in either direction around the table. The following conditions apply: Fiona sits directly across from George. Harriet sits immediately next to neither Fiona nor Karl. Ingrid sits immediately next to, and immediately clockwise from, Olivia.",
      "question": "If Karl sits directly across from Harriet, then what is the minimum possible number of people sitting between George and Karl, counting clockwise from George to Karl?",
      "options": [
        "A) zero",
        "B) one",
        "C) two",
        "D) three",
        "E) four"
      ]
    },
    "answer": "C",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((People 0)) (((Fiona) (George) (Harriet) (Ingrid) (Karl) (Manuel) (Olivia) (Peter))))",
        "(declare-fun sits (People People) Bool)"
      ],
      "constraints": [
        "(forall ((h People) (i People) (j People)) (= (and (sits h Fiona) (sits i George)) (not (or (sits h George) (sits i Fiona)))))",
        "(forall ((h People) (i People) (j People)) (not (or (and (sits h Harriet) (sits i Fiona)) (and (sits h Harriet) (sits i Karl)) (and (sits h Fiona) (sits i Harriet)) (and (sits h Karl) (sits i Harriet)))))",
        "(forall ((h People) (i People) (j People)) (and (sits h Ingrid) (sits i Olivia) (sits j Ingrid)))",
        "(forall ((h People) (i People) (j People)) (= (and (sits h Karl) (sits i Harriet)) (not (or (sits h Harriet) (sits i Karl)))))"
      ],
      "options": [
        "(not (> (dist George Karl) 0))",
        "(not (> (dist George Karl) 1))",
        "(not (> (dist George Karl) 2))",
        "(not (> (dist George Karl) 3))",
        "(not (> (dist George Karl) 4))"
      ],
      "type": "sat",
      "perplexity": [
        1.2556674480438232,
        1.1017602682113647
      ],
      "answer": "C",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "SyntaxError: invalid syntax. Perhaps you forgot a comma?"
    }
  },
  {
    "id": 47,
    "nl_problem": {
      "context": "Each of seven candidates for the position of judge—Hamadi, Jefferson, Kurtz, Li, McDonnell, Ortiz, and Perkins—will be appointed to an open position on one of two courts—the appellate court or the trial court. There are three open positions on the appellate court and six open positions on the trial court, but not all of them will be filled at this time. The judicial appointments will conform to the following conditions: Li must be appointed to the appellate court. Kurtz must be appointed to the trial court. Hamadi cannot be appointed to the same court as Perkins.",
      "question": "Which one of the following is an acceptable set of appointments of candidates to courts?",
      "options": [
        "A) appellate: Hamadi, Ortiz trial: Jefferson, Kurtz, Li, McDonnell, Perkins",
        "B) appellate: Hamadi, Li, Perkins trial: Jefferson, Kurtz, McDonnell, Ortiz",
        "C) appellate: Kurtz, Li, Perkins trial: Hamadi, Jefferson, McDonnell, Ortiz",
        "D) appellate: Li, McDonnell, Ortiz trial: Hamadi, Jefferson, Kurtz, Perkins",
        "E) appellate: Li, Perkins trial: Hamadi, Jefferson, Kurtz, McDonnell, Ortiz"
      ]
    },
    "answer": "E",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((Candidates 0)) (((Hamadi) (Jefferson) (Kurtz) (Li) (McDonnell) (Ortiz) (Perkins)))",
        "(declare-datatypes ((Courts 0)) (((appellate) (trial))))",
        "(declare-fun appointed (Candidates Courts) Bool)"
      ],
      "constraints": [
        "(appointed Li appellate)",
        "(appointed Kurtz trial)",
        "(forall ((c Courts)) (=> (appointed Hamadi c) (not (appointed Perkins c))))"
      ],
      "options": [
        "(and (appointed Hamadi appellate) (appointed Ortiz appellate) (appointed Jefferson trial) (appointed Kurtz trial) (appointed Li trial) (appointed McDonnell trial) (appointed Perkins trial))",
        "(and (appointed Hamadi appellate) (appointed Li appellate) (appointed Perkins appellate) (appointed Jefferson trial) (appointed Kurtz trial) (appointed McDonnell trial) (appointed Ortiz trial))",
        "(and (appointed Kurtz appellate) (appointed Li appellate) (appointed Perkins appellate) (appointed Hamadi trial) (appointed Jefferson trial) (appointed McDonnell trial) (appointed Ortiz trial))",
        "(and (appointed Li appellate) (appointed McDonnell appellate) (appointed Ortiz appellate) (appointed Hamadi trial) (appointed Jefferson trial) (appointed Kurtz trial) (appointed Perkins trial))",
        "(and (appointed Li appellate) (appointed Perkins appellate) (appointed Hamadi trial) (appointed Jefferson trial) (appointed Kurtz trial) (appointed McDonnell trial) (appointed Ortiz trial))"
      ],
      "type": "sat",
      "perplexity": [
        1.0483109951019287,
        1.1025282144546509
      ],
      "answer": "E",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "SyntaxError: invalid syntax. Perhaps you forgot a comma?"
    }
  },
  {
    "id": 48,
    "nl_problem": {
      "context": "Each of seven candidates for the position of judge—Hamadi, Jefferson, Kurtz, Li, McDonnell, Ortiz, and Perkins—will be appointed to an open position on one of two courts—the appellate court or the trial court. There are three open positions on the appellate court and six open positions on the trial court, but not all of them will be filled at this time. The judicial appointments will conform to the following conditions: Li must be appointed to the appellate court. Kurtz must be appointed to the trial court. Hamadi cannot be appointed to the same court as Perkins.",
      "question": "Which one of the following CANNOT be true?",
      "options": [
        "A) Hamadi and McDonnell are both appointed to the appellate court.",
        "B) McDonnell and Ortiz are both appointed to the appellate court.",
        "C) Ortiz and Perkins are both appointed to the appellate court.",
        "D) Hamadi and Jefferson are both appointed to the trial court.",
        "E) Ortiz and Perkins are both appointed to the trial court."
      ]
    },
    "answer": "B",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((Candidates 0)) (((Hamadi) (Jefferson) (Kurtz) (Li) (McDonnell) (Ortiz) (Perkins))))",
        "(declare-datatypes ((Courts 0)) (((appellate_court) (trial_court))))",
        "(declare-fun appointed (Candidates Courts) Bool)",
        "(define-fun to-int ((b Bool)) Int (ite b 1 0))"
      ],
      "constraints": [
        "(appointed Li appellate_court)",
        "(appointed Kurtz trial_court)",
        "(not (and (appointed Hamadi appellate_court) (appointed Perkins appellate_court)))",
        "(not (and (appointed Hamadi trial_court) (appointed Perkins trial_court)))"
      ],
      "options": [
        "(not (and (appointed Hamadi appellate_court) (appointed McDonnell appellate_court)))",
        "(not (and (appointed McDonnell appellate_court) (appointed Ortiz appellate_court)))",
        "(not (and (appointed Ortiz appellate_court) (appointed Perkins appellate_court)))",
        "(not (and (appointed Hamadi trial_court) (appointed Jefferson trial_court)))",
        "(not (and (appointed Ortiz trial_court) (appointed Perkins trial_court)))"
      ],
      "type": "unsat",
      "perplexity": [
        1.1740471124649048,
        1.1441783905029297
      ],
      "answer": "B",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "SyntaxError: invalid syntax. Perhaps you forgot a comma?"
    }
  },
  {
    "id": 49,
    "nl_problem": {
      "context": "Each of seven candidates for the position of judge—Hamadi, Jefferson, Kurtz, Li, McDonnell, Ortiz, and Perkins—will be appointed to an open position on one of two courts—the appellate court or the trial court. There are three open positions on the appellate court and six open positions on the trial court, but not all of them will be filled at this time. The judicial appointments will conform to the following conditions: Li must be appointed to the appellate court. Kurtz must be appointed to the trial court. Hamadi cannot be appointed to the same court as Perkins.",
      "question": "Which one of the following CANNOT be true?",
      "options": [
        "A) Jefferson and McDonnell are both appointed to the appellate court.",
        "B) Jefferson and McDonnell are both appointed to the trial court.",
        "C) McDonnell and Ortiz are both appointed to the trial court.",
        "D) McDonnell and Perkins are both appointed to the appellate court.",
        "E) McDonnell and Perkins are both appointed to the trial court."
      ]
    },
    "answer": "A",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((Candidates 0)) (((Hamadi) (Jefferson) (Kurtz) (Li) (McDonnell) (Ortiz) (Perkins))))",
        "(declare-datatypes ((Courts 0)) (((appellate_court) (trial_court))))",
        "(declare-fun appointed (Candidates Courts) Bool)"
      ],
      "constraints": [
        "(forall ((c Candidates)) (=> (appointed Li appellate_court) true))",
        "(forall ((c Candidates)) (=> (appointed Kurtz trial_court) true))",
        "(forall ((c Candidates)) (=> (appointed Hamadi appellate_court) (not (appointed Perkins appellate_court))) (=> (appointed Hamadi trial_court) (not (appointed Perkins trial_court))))"
      ],
      "options": [
        "(forall ((m Candidates)) (=> (appointed Jefferson appellate_court) (appointed McDonnell appellate_court)))",
        "(forall ((m Candidates)) (=> (appointed Jefferson trial_court) (appointed McDonnell trial_court)))",
        "(forall ((m Candidates)) (=> (appointed McDonnell trial_court) (appointed Ortiz trial_court)))",
        "(forall ((m Candidates)) (=> (appointed McDonnell appellate_court) (appointed Perkins appellate_court)))",
        "(forall ((m Candidates)) (=> (appointed McDonnell trial_court) (appointed Perkins trial_court)))"
      ],
      "type": "sat",
      "perplexity": [
        1.1082767248153687,
        1.1298599243164062
      ],
      "answer": "A",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "SyntaxError: invalid syntax"
    }
  },
  {
    "id": 50,
    "nl_problem": {
      "context": "Each of seven candidates for the position of judge—Hamadi, Jefferson, Kurtz, Li, McDonnell, Ortiz, and Perkins—will be appointed to an open position on one of two courts—the appellate court or the trial court. There are three open positions on the appellate court and six open positions on the trial court, but not all of them will be filled at this time. The judicial appointments will conform to the following conditions: Li must be appointed to the appellate court. Kurtz must be appointed to the trial court. Hamadi cannot be appointed to the same court as Perkins.",
      "question": "If Ortiz is appointed to the appellate court, which one of the following must be true?",
      "options": [
        "A) Hamadi is appointed to the appellate court.",
        "B) Jefferson is appointed to the appellate court.",
        "C) Jefferson is appointed to the trial court.",
        "D) Perkins is appointed to the appellate court.",
        "E) Perkins is appointed to the trial court."
      ]
    },
    "answer": "C",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((Courts 0)) (((appellate) (trial))))",
        "(declare-datatypes ((Candidates 0)) (((Hamadi) (Jefferson) (Kurtz) (Li) (McDonnell) (Ortiz) (Perkins))))",
        "(declare-fun assigned (Candidates Courts) Bool)",
        "(define-fun to-int ((b Bool)) Int (ite b 1 0))"
      ],
      "constraints": [
        "(>= (+ (to-int (assigned Li appellate)) (to-int (assigned Jefferson appellate)) (to-int (assigned Kurtz appellate)) (to-int (assigned McDonnell appellate)) (to-int (assigned Ortiz appellate)) (to-int (assigned Perkins appellate))) 3)",
        "(>= (+ (to-int (assigned Hamadi trial)) (to-int (assigned Jefferson trial)) (to-int (assigned Kurtz trial)) (to-int (assigned Li trial)) (to-int (assigned McDonnell trial)) (to-int (assigned Ortiz trial)) (to-int (assigned Perkins trial))) 6)",
        "(assigned Li appellate)",
        "(assigned Kurtz trial)",
        "(forall ((c Courts)) (=> (assigned Hamadi c) (not (assigned Perkins c))))",
        "(assigned Ortiz appellate)"
      ],
      "options": [
        "(assigned Hamadi appellate)",
        "(assigned Jefferson appellate)",
        "(assigned Jefferson trial)",
        "(assigned Perkins appellate)",
        "(assigned Perkins trial)"
      ],
      "type": "unsat",
      "perplexity": [
        1.1612062454223633,
        1.1313241720199585
      ],
      "answer": "C",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "SyntaxError: invalid syntax"
    }
  },
  {
    "id": 51,
    "nl_problem": {
      "context": "Each of seven candidates for the position of judge—Hamadi, Jefferson, Kurtz, Li, McDonnell, Ortiz, and Perkins—will be appointed to an open position on one of two courts—the appellate court or the trial court. There are three open positions on the appellate court and six open positions on the trial court, but not all of them will be filled at this time. The judicial appointments will conform to the following conditions: Li must be appointed to the appellate court. Kurtz must be appointed to the trial court. Hamadi cannot be appointed to the same court as Perkins.",
      "question": "Which one of the following, if substituted for the condition that Hamadi cannot be appointed to the same court as Perkins, would have the same effect on the appointments of the seven candidates?",
      "options": [
        "A) Hamadi and Perkins cannot both be appointed to the appellate court.",
        "B) If Hamadi is not appointed to the trial court, then Perkins must be.",
        "C) If Perkins is appointed to the same court as Jefferson, then Hamadi cannot be.",
        "D) If Hamadi is appointed to the same court as Li, then Perkins must be appointed to the same court as Kurtz.",
        "E) No three of Hamadi, Kurtz, Li, and Perkins can be appointed to the same court as each other."
      ]
    },
    "answer": "E",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((Candidates 0)) (((Hamadi) (Jefferson) (Kurtz) (Li) (McDonnell) (Ortiz) (Perkins)))",
        "(declare-datatypes ((Courts 0)) (((appellate) (trial))))",
        "(declare-datatypes ((Positions 0)) (((open1) (open2) (open3) (open4) (open5) (open6))))",
        "(declare-fun appointed (Candidates Courts) Positions)",
        "(define-fun equal ((a Positions) (b Positions)) Bool (= a b))"
      ],
      "constraints": [
        "(exists ((m Positions)) (and (= (appointed Li appellate) m) (equal m open1) (or (not (exists ((p Positions)) (= (appointed p appellate) open2))) (not (exists ((p Positions)) (= (appointed p appellate) open3)))))",
        "(exists ((m Positions)) (and (= (appointed Kurtz trial) m) (equal m open1) (or (not (exists ((p Positions)) (= (appointed p trial) open2))) (not (exists ((p Positions)) (= (appointed p trial) open3))) (not (exists ((p Positions)) (= (appointed p trial) open4))))))",
        "(forall ((c Courts)) (forall ((p1 Positions) (p2 Positions)) (not (and (= (appointed Hamadi c) p1) (= (appointed Perkins c) p2) (or (equal p1 p2) (= p1 open1) (= p2 open1)))))",
        "(forall ((c Courts)) (forall ((p1 Positions) (p2 Positions)) (not (and (= (appointed Hamadi c) p1) (= (appointed Perkins c) p2) (equal p1 open1) (not (exists ((p Positions)) (= (appointed p appellate) open1)))))))",
        "(forall ((c Courts)) (forall ((p1 Positions) (p2 Positions)) (not (and (= (appointed Hamadi c) p1) (= (appointed Perkins c) p2) (not (= (appointed Hamadi trial) p1)) (= (appointed Perkins trial) p2)))))",
        "(forall ((c Courts)) (forall ((p1 Positions) (p2 Positions)) (not (and (= (appointed Hamadi c) p1) (= (appointed Perkins c) p2) (not (= (appointed Perkins appellate) p2)) (= (appointed Jefferson appellate) p2)))))",
        "(forall ((c Courts)) (forall ((p1 Positions) (p2 Positions)) (not (and (= (appointed Hamadi c) p1) (= (appointed Perkins c) p2) (= (appointed Hamadi appellate) p1) (= (appointed Li appellate) p3) (= (appointed Perkins appellate) p4) (= (appointed Kurtz trial) p5)))))",
        "(forall ((c Courts)) (forall ((p1 Positions) (p2 Positions)) (not (and (= (appointed Hamadi c) p1) (= (appointed Perkins c) p2) (= (appointed Hamadi appellate) p1) (= (appointed Li appellate) p1) (= (appointed Perkins appellate) p3) (= (appointed Kurtz trial) p4)))))",
        "(forall ((c Courts)) (forall ((p1 Positions) (p2 Positions) (p3 Positions) (p4 Positions)) (not (and (= (appointed Hamadi c) p1) (= (appointed Perkins c) p2) (= (appointed Hamadi appellate) p1) (= (appointed Li appellate) p3) (= (appointed Kurtz trial) p4) (or (equal p3 p4) (= p3 open1) (= p4 open1)))))"
      ],
      "options": [
        "(forall ((c Courts)) (forall ((p1 Positions) (p2 Positions)) (not (and (= (appointed Hamadi c) p1) (= (appointed Perkins c) p2) (equal p1 open1) (not (exists ((p Positions)) (= (appointed p appellate) open1)))))))",
        "(forall ((c Courts)) (forall ((p1 Positions) (p2 Positions)) (not (and (= (appointed Hamadi c) p1) (= (appointed Perkins c) p2) (not (= (appointed Hamadi trial) p1)) (= (appointed Perkins trial) p2)))))",
        "(forall ((c Courts)) (forall ((p1 Positions) (p2 Positions)) (not (and (= (appointed Hamadi c) p1) (= (appointed Perkins c) p2) (not (= (appointed Perkins appellate) p2)) (= (appointed Jefferson appellate) p2)))))",
        "(forall ((c Courts)) (forall ((p1 Positions) (p2 Positions)) (not (and (= (appointed Hamadi c) p1) (= (appointed Perkins c) p2) (= (appointed Hamadi appellate) p1) (= (appointed Li appellate) p3) (= (appointed Perkins appellate) p4) (= (appointed Kurtz trial) p5)))))",
        "(forall ((c Courts)) (forall ((p1 Positions) (p2 Positions)) (not (and (= (appointed Hamadi c) p1) (= (appointed Perkins c) p2) (= (appointed Hamadi appellate) p1) (= (appointed Li appellate) p1) (= (appointed Perkins appellate) p3) (= (appointed Kurtz trial) p4)))))",
        "(forall ((c Courts)) (forall ((p1 Positions) (p2 Positions) (p3 Positions) (p4 Positions)) (not (and (= (appointed Hamadi c) p1) (= (appointed Perkins c) p2) (= (appointed Hamadi appellate) p1) (= (appointed Li appellate) p3) (= (appointed Kurtz trial) p4) (or (equal p3 p4) (= p3 open1) (= p4 open1)))))"
      ],
      "type": "unsat",
      "perplexity": [
        1.1317569017410278,
        1.0299638509750366
      ],
      "answer": "E",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "SyntaxError: invalid syntax"
    }
  },
  {
    "id": 52,
    "nl_problem": {
      "context": "Exactly six members of a skydiving team—Larue, Ohba, Pei, Trevino, Weiss, and Zacny—each dive exactly once, one at a time, from a plane, consistent with the following conditions: Trevino dives from the plane at some time before Weiss does. Larue dives from the plane either first or last. Neither Weiss nor Zacny dives from the plane last. Pei dives from the plane at some time after either Ohba or Larue but not both.",
      "question": "Which one of the following could be an accurate list of the members in the order in which they dive from the plane, from first to last?",
      "options": [
        "A) Larue, Trevino, Ohba, Zacny, Pei, Weiss",
        "B) Larue, Trevino, Pei, Zacny, Weiss, Ohba",
        "C) Weiss, Ohba, Trevino, Zacny, Pei, Larue",
        "D) Trevino, Weiss, Pei, Ohba, Zacny, Larue",
        "E) Trevino, Weiss, Zacny, Larue, Pei, Ohba"
      ]
    },
    "answer": "B"
  },
  {
    "id": 53,
    "nl_problem": {
      "context": "Exactly six members of a skydiving team—Larue, Ohba, Pei, Trevino, Weiss, and Zacny—each dive exactly once, one at a time, from a plane, consistent with the following conditions: Trevino dives from the plane at some time before Weiss does. Larue dives from the plane either first or last. Neither Weiss nor Zacny dives from the plane last. Pei dives from the plane at some time after either Ohba or Larue but not both.",
      "question": "Which one of the following must be true?",
      "options": [
        "A) At least two of the members dive from the plane after Larue.",
        "B) At least two of the members dive from the plane after Ohba.",
        "C) At least two of the members dive from the plane after Pei.",
        "D) At least two of the members dive from the plane after Trevino.",
        "E) At least two of the members dive from the plane after Weiss."
      ]
    },
    "answer": "D",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((TeamMembers 0)) (((Larue) (Ohba) (Pei) (Trevino) (Weiss) (Zacny))))",
        "(declare-datatypes ((Times 0)) (((t0) (t1) (t2) (t3) (t4) (t5))))",
        "(declare-fun dives (TeamMembers Times) Bool)"
      ],
      "constraints": [
        "(exists ((t1 Times) (t2 Times)) (and (dives Trevino t1) (dives Weiss t2) (< t1 t2)))",
        "(or (= (dives Larue t0) true) (= (dives Larue t5) true))",
        "(not (and (= (dives Weiss t5) true) (not (= (dives Zacny t5) true))))",
        "(not (and (= (dives Zacny t5) true) (not (= (dives Weiss t5) true))))",
        "(exists ((t1 Times) (t2 Times) (t3 Times)) (and (or (and (not (= t1 t2)) (and (dives Ohba t1) (dives Pei t2))) (and (not (= t2 t3)) (and (dives Larue t2) (dives Pei t3)))) (not (exists ((t4 Times)) (and (not (= t4 t1)) (and (dives Ohba t4) (dives Larue t4)))))))"
      ],
      "options": [
        "(>= 2 (ite (ite (dives Larue t0) 0 1) (ite (ite (dives (ite (not (= t1 t2)) Ohba Larue) t1) 0 1) (ite (ite (dives (ite (not (= t2 t3)) Pei Larue) t2) 0 1) 0 1)))",
        "(>= 2 (ite (ite (dives Ohba t0) 0 1) (ite (ite (dives (ite (not (= t1 t2)) Larue Ohba) t1) 0 1) (ite (ite (dives (ite (not (= t2 t3)) Pei Ohba) t2) 0 1) 0 1)))",
        "(>= 2 (ite (ite (dives Pei t0) 0 1) (ite (ite (dives (ite (not (= t1 t2)) Larue Pei) t1) 0 1) (ite (ite (dives (ite (not (= t2 t3)) Ohba Pei) t2) 0 1) 0 1)))",
        "(>= 2 (ite (ite (dives Trevino t0) 0 1) (ite (ite (dives (ite (not (= t1 t2)) Weiss Trevino) t1) 0 1) (ite (ite (dives (ite (not (= t2 t3)) Pei Trevino) t2) 0 1) 0 1)))",
        "(>= 2 (ite (ite (dives Weiss t0) 0 1) (ite (ite (dives (ite (not (= t1 t2)) Trevino Weiss) t1) 0 1) (ite (ite (dives (ite (not (= t2 t3)) Pei Weiss) t2) 0 1) 0 1)))"
      ],
      "type": {
        "A": "sat",
        "B": "unsat",
        "C": "unsat",
        "D": "sat",
        "E": "unsat"
      },
      "perplexity": [
        1.1133480072021484,
        1.0521528720855713
      ],
      "answer": "D",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "SyntaxError: invalid syntax. Perhaps you forgot a comma?"
    }
  },
  {
    "id": 54,
    "nl_problem": {
      "context": "Exactly six members of a skydiving team—Larue, Ohba, Pei, Trevino, Weiss, and Zacny—each dive exactly once, one at a time, from a plane, consistent with the following conditions: Trevino dives from the plane at some time before Weiss does. Larue dives from the plane either first or last. Neither Weiss nor Zacny dives from the plane last. Pei dives from the plane at some time after either Ohba or Larue but not both.",
      "question": "If Larue dives from the plane last, then each of the following could be true EXCEPT:",
      "options": [
        "A) Trevino dives from the plane fourth.",
        "B) Weiss dives from the plane fourth.",
        "C) Ohba dives from the plane fifth.",
        "D) Pei dives from the plane fifth.",
        "E) Zacny dives from the plane fifth."
      ]
    },
    "answer": "C",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((TeamMembers 0)) (((Larue) (Ohba) (Pei) (Trevino) (Weiss) (Zacny))))",
        "(declare-datatypes ((Positions 0)) (((first) (second) (third) (fourth) (fifth) (last))))",
        "(declare-fun dives (TeamMembers Positions) Bool)",
        "(define-fun to-int ((b Bool)) Int (ite b 1 0))"
      ],
      "constraints": [
        "(or (= (dives Larue first) true) (= (dives Larue last) true))",
        "(forall ((p Positions)) (=> (= (dives Trevino p) true) (not (= p fourth))))",
        "(forall ((p Positions)) (and (not (= (dives Weiss last) true)) (not (= (dives Zacny last) true))))",
        "(forall ((p Positions)) (=> (= (dives Pei p) true) (or (= (dives Ohba (ite (= p fifth) first second)) true) (= (dives Larue (ite (= p fifth) first second)) true))))"
      ],
      "options": [
        "(= (dives Larue last) true) (assert (= (dives Trevino fourth) true))",
        "(= (dives Larue last) true) (assert (= (dives Weiss fourth) true))",
        "(= (dives Larue last) true) (assert (= (dives Ohba fifth) true))",
        "(= (dives Larue last) true) (assert (= (dives Pei fifth) true))",
        "(= (dives Larue last) true) (assert (= (dives Zacny fifth) true))"
      ],
      "type": "unsat",
      "perplexity": [
        1.210945963859558,
        1.1049145460128784
      ],
      "answer": "C",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "SyntaxError: invalid syntax"
    }
  },
  {
    "id": 55,
    "nl_problem": {
      "context": "Exactly six members of a skydiving team—Larue, Ohba, Pei, Trevino, Weiss, and Zacny—each dive exactly once, one at a time, from a plane, consistent with the following conditions: Trevino dives from the plane at some time before Weiss does. Larue dives from the plane either first or last. Neither Weiss nor Zacny dives from the plane last. Pei dives from the plane at some time after either Ohba or Larue but not both.",
      "question": "If Zacny dives from the plane immediately after Weiss, then which one of the following must be false?",
      "options": [
        "A) Larue dives from the plane first.",
        "B) Trevino dives from the plane third.",
        "C) Zacny dives from the plane third.",
        "D) Pei dives from the plane fourth.",
        "E) Zacny dives from the plane fourth."
      ]
    },
    "answer": "D",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((Team_members 0)) (((Larue) (Ohba) (Pei) (Trevino) (Weiss) (Zacny))))",
        "(declare-datatypes ((Positions 0)) (((first) (second) (third) (fourth) (fifth) (sixth))))",
        "(declare-fun dives (Team_members Positions) Bool)",
        "(define-fun to-int ((b Bool)) Int (ite b 1 0))"
      ],
      "constraints": [
        "(forall ((p Positions)) (=> (dives Trevino p) (< p (ite (dives Weiss sixth) fifth fourth))))",
        "(forall ((p Positions)) (or (= p first) (= p sixth)))",
        "(forall ((p Positions)) (=> (or (dives Weiss p) (dives Zacny p)) (not (= p sixth))))",
        "(forall ((p Positions)) (=> (or (dives Ohba p) (dives Larue p)) (> p (ite (or (dives Ohba p) (dives Larue p)) p sixth))))"
      ],
      "options": [
        "(forall ((p Positions)) (not (or (and (= p first) (= p fourth)))))",
        "(forall ((p Positions)) (not (or (and (= p third) (= p fourth)))))",
        "(forall ((p Positions)) (not (or (and (= p fourth) (= p fourth)))))",
        "(forall ((p Positions)) (not (or (and (= p fourth) (= p fourth)))))",
        "(forall ((p Positions)) (not (or (and (= p fourth) (= p fourth)))))"
      ],
      "type": "unsat",
      "perplexity": [
        1.174479603767395,
        1.1041812896728516
      ],
      "answer": "D",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "SyntaxError: invalid syntax. Perhaps you forgot a comma?"
    }
  },
  {
    "id": 56,
    "nl_problem": {
      "context": "Exactly six members of a skydiving team—Larue, Ohba, Pei, Trevino, Weiss, and Zacny—each dive exactly once, one at a time, from a plane, consistent with the following conditions: Trevino dives from the plane at some time before Weiss does. Larue dives from the plane either first or last. Neither Weiss nor Zacny dives from the plane last. Pei dives from the plane at some time after either Ohba or Larue but not both.",
      "question": "If Trevino dives from the plane immediately after Larue, then each of the following could be true EXCEPT:",
      "options": [
        "A) Ohba dives from the plane third.",
        "B) Weiss dives from the plane third.",
        "C) Zacny dives from the plane third.",
        "D) Pei dives from the plane fourth.",
        "E) Weiss dives from the plane fourth."
      ]
    },
    "answer": "A",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((Skydivers 0)) (((Larue) (Ohba) (Pei) (Trevino) (Weiss) (Zacny))))",
        "(declare-datatypes ((Times 0)) (((first) (second) (third) (fourth) (fifth))))",
        "(declare-fun at (Skydivers Times) Bool)",
        "(define-fun to-int ((b Bool)) Int (ite b 1 0))"
      ],
      "constraints": [
        "(exists ((t Times)) (and (at Trevino t) (at Weiss (ite (> t fourth) fourth (ite (> t third) third (> t second) second)))))",
        "(or (at Larue first) (at Larue fifth))",
        "(not (or (at Weiss fifth) (at Zacny fifth)))",
        "(exists ((t Times)) (exists ((o Skydivers)) (and (at Pei t) (at o (ite (at Pei fourth) fifth (> t fourth) fourth)) (ite (at Pei fourth) (> t fifth) (> t fourth)))))"
      ],
      "options": [
        "(and (at Trevino (ite (at Larue fourth) fifth fourth)) (at Larue (ite (at Trevino fourth) fifth fourth)))",
        "(not (at Ohba third))",
        "(not (at Weiss third))",
        "(not (at Zacny third))",
        "(not (at Pei fourth))",
        "(not (at Weiss fourth))"
      ],
      "type": "unsat",
      "perplexity": [
        1.1577255725860596,
        1.1047990322113037
      ],
      "answer": "A",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "SyntaxError: invalid syntax. Perhaps you forgot a comma?"
    }
  },
  {
    "id": 57,
    "nl_problem": {
      "context": "A company's six vehicles—a hatchback, a limousine, a pickup, a roadster, a sedan, and a van—are serviced during a certain week—Monday through Saturday—one vehicle per day. The following conditions must apply: At least one of the vehicles is serviced later in the week than the hatchback. The roadster is serviced later in the week than the van and earlier in the week than the hatchback. Either the pickup and the van are serviced on consecutive days, or the pickup and the sedan are serviced on consecutive days, but not both. The sedan is serviced earlier in the week than the pickup or earlier in the week than the limousine, but not both.",
      "question": "Which one of the following could be the order in which the vehicles are serviced, from Monday through Saturday?",
      "options": [
        "A) the hatchback, the pickup, the sedan, the limousine, the van, the roadster",
        "B) the pickup, the sedan, the van, the roadster, the hatchback, the limousine",
        "C) the pickup, the van, the sedan, the roadster, the limousine, the hatchback",
        "D) the van, the roadster, the pickup, the hatchback, the sedan, the limousine",
        "E) the van, the sedan, the pickup, the roadster, the hatchback, the limousine"
      ]
    },
    "answer": "B",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((Days 0)) (((Monday) (Tuesday) (Wednesday) (Thursday) (Friday) (Saturday))))",
        "(declare-datatypes ((Vehicles 0)) (((hatchback) (limousine) (pickup) (roadster) (sedan) (van))))",
        "(declare-fun serviced (Vehicles Days) Bool)",
        "(define-fun comes-after ((a Days) (b Days)) Bool (ite (= a Monday) false (ite (= b Saturday) true (ite (= a b) false (ite (> a b) true false)))))"
      ],
      "constraints": [
        "(exists ((v Vehicles) (d Days)) (and (not (serviced hatchback d)) (comes-after d (day-of hatchback))))",
        "(forall ((d Days)) (and (=> (comes-after van d) (comes-after d (day-of roadster))) (=> (comes-after (day-of roadster) d) (comes-after d (day-of hatchback)))))",
        "(or (exists ((d Days)) (and (serviced pickup d) (serviced van (ite (= d Tuesday) Monday d)) (not (exists ((d2 Days)) (and (serviced pickup d2) (serviced van (ite (= d2 Tuesday) Monday d2))))))) (exists ((d Days)) (and (serviced pickup d) (serviced sedan (ite (= d Tuesday) Monday d)) (not (exists ((d2 Days)) (and (serviced pickup d2) (serviced sedan (ite (= d2 Tuesday) Monday d2))))))))",
        "(forall ((d Days)) (and (=> (serviced sedan d) (serviced pickup (ite (= d Thursday) Wednesday d))) (=> (serviced sedan d) (serviced limousine (ite (= d Thursday) Wednesday d))) (not (exists ((d2 Days)) (and (serviced sedan d2) (serviced pickup (ite (= d2 Thursday) Wednesday d2)) (serviced limousine (ite (= d2 Thursday) Wednesday d2)))))"
      ],
      "options": [
        "(and (serviced hatchback Monday) (serviced pickup Tuesday) (serviced sedan Wednesday) (serviced limousine Thursday) (serviced van Friday) (serviced roadster Saturday))",
        "(and (serviced hatchback Monday) (serviced pickup Monday) (serviced sedan Tuesday) (serviced limousine Thursday) (serviced van Friday) (serviced roadster Saturday))",
        "(and (serviced hatchback Monday) (serviced van Monday) (serviced roadster Tuesday) (serviced pickup Wednesday) (serviced sedan Thursday) (serviced limousine Saturday))",
        "(and (serviced hatchback Monday) (serviced van Monday) (serviced sedan Tuesday) (serviced pickup Wednesday) (serviced roadster Thursday) (serviced limousine Saturday))"
      ],
      "type": "sat",
      "perplexity": [
        1.1243983507156372,
        1.064959168434143
      ],
      "answer": "B",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "SyntaxError: invalid syntax. Perhaps you forgot a comma?"
    }
  },
  {
    "id": 58,
    "nl_problem": {
      "context": "A company's six vehicles—a hatchback, a limousine, a pickup, a roadster, a sedan, and a van—are serviced during a certain week—Monday through Saturday—one vehicle per day. The following conditions must apply: At least one of the vehicles is serviced later in the week than the hatchback. The roadster is serviced later in the week than the van and earlier in the week than the hatchback. Either the pickup and the van are serviced on consecutive days, or the pickup and the sedan are serviced on consecutive days, but not both. The sedan is serviced earlier in the week than the pickup or earlier in the week than the limousine, but not both.",
      "question": "Which one of the following CANNOT be the vehicle serviced on Thursday?",
      "options": [
        "A) the hatchback",
        "B) the limousine",
        "C) the pickup",
        "D) the sedan",
        "E) the van"
      ]
    },
    "answer": "E",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((Days 0)) (((Monday) (Tuesday) (Wednesday) (Thursday) (Friday) (Saturday))))",
        "(declare-datatypes ((Vehicles 0)) (((hatchback) (limousine) (pickup) (roadster) (sedan) (van))))",
        "(declare-fun serviced (Days Vehicles) Bool)",
        "(define-fun to-int ((b Bool)) Int (ite b 1 0))"
      ],
      "constraints": [
        "(>= (+ (to-int (serviced Friday hatchback)) (to-int (serviced Saturday hatchback))) 1)",
        "(and (> (to-int (serviced roadster van)) 0) (< (to-int (serviced van hatchback)) (to-int (serviced roadster hatchback))))",
        "(or (and (= (+ (to-int (serviced Monday pickup)) (to-int (serviced Tuesday van))) 1)) (and (= (+ (to-int (serviced Monday pickup)) (to-int (serviced Tuesday sedan))) 1) (not (= (+ (to-int (serviced Monday pickup)) (to-int (serviced Tuesday van))) 1))))",
        "(or (< (to-int (serviced sedan pickup)) (to-int (serviced pickup pickup))) (< (to-int (serviced sedan limousine)) (to-int (serviced limousine limousine))))",
        "(not (and (< (to-int (serviced sedan pickup)) (to-int (serviced pickup pickup))) (< (to-int (serviced sedan limousine)) (to-int (serviced limousine limousine)))))"
      ],
      "options": [
        "(not (serviced Thursday hatchback))",
        "(not (serviced Thursday limousine))",
        "(not (serviced Thursday pickup))",
        "(not (serviced Thursday sedan))",
        "(not (serviced Thursday van))"
      ],
      "type": "unsat",
      "perplexity": [
        1.2080210447311401,
        1.0981749296188354
      ],
      "answer": "E",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "SyntaxError: invalid syntax"
    }
  },
  {
    "id": 59,
    "nl_problem": {
      "context": "A company's six vehicles—a hatchback, a limousine, a pickup, a roadster, a sedan, and a van—are serviced during a certain week—Monday through Saturday—one vehicle per day. The following conditions must apply: At least one of the vehicles is serviced later in the week than the hatchback. The roadster is serviced later in the week than the van and earlier in the week than the hatchback. Either the pickup and the van are serviced on consecutive days, or the pickup and the sedan are serviced on consecutive days, but not both. The sedan is serviced earlier in the week than the pickup or earlier in the week than the limousine, but not both.",
      "question": "If neither the pickup nor the limousine is serviced on Monday, then which one of the following must be true?",
      "options": [
        "A) The hatchback and the limousine are serviced on consecutive days.",
        "B) The hatchback and the sedan are serviced on consecutive days.",
        "C) The van is serviced on Monday.",
        "D) The limousine is serviced on Saturday.",
        "E) The pickup is serviced on Saturday."
      ]
    },
    "answer": "C",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((Vehicles 0)) (((hatchback) (limousine) (pickup) (roadster) (sedan) (van))))",
        "(declare-datatypes ((Days 0)) (((Monday) (Tuesday) (Wednesday) (Thursday) (Friday) (Saturday))))",
        "(declare-fun serviced (Vehicles Days) Bool)",
        "(define-fun to-int ((b Bool)) Int (ite b 1 0))"
      ],
      "constraints": [
        "(exists ((d Days)) (and (> d Monday) (serviced hatchback Monday) (not (serviced hatchback d))))",
        "(and (< (serviced van Wednesday) (serviced roadster Wednesday)) (< (serviced roadster Tuesday) (serviced hatchback Tuesday)))",
        "(or (and (or (= (serviced pickup Tuesday) (serviced van Monday)) (= (serviced pickup Monday) (serviced van Tuesday))) (not (and (or (= (serviced pickup Tuesday) (serviced van Monday)) (= (serviced pickup Monday) (serviced van Tuesday))) (or (= (serviced pickup Tuesday) (serviced sedan Monday)) (= (serviced pickup Monday) (serviced sedan Tuesday)))))",
        "(and (or (= (serviced pickup Tuesday) (serviced sedan Monday)) (= (serviced pickup Monday) (serviced sedan Tuesday))) (not (and (or (= (serviced pickup Tuesday) (serviced sedan Monday)) (= (serviced pickup Monday) (serviced sedan Tuesday))) (or (= (serviced pickup Tuesday) (serviced van Monday)) (= (serviced pickup Monday) (serviced van Tuesday)))))))",
        "(and (< (serviced pickup Wednesday) (serviced sedan Wednesday)) (< (serviced sedan Wednesday) (serviced limousine Wednesday)) (not (and (< (serviced pickup Wednesday) (serviced sedan Wednesday)) (< (serviced sedan Wednesday) (serviced limousine Wednesday)))))"
      ],
      "options": [
        "(not (exists ((m Vehicles)) (and (not (serviced m Monday)) (not (serviced limousine Monday)))) (or (= (serviced hatchback Tuesday) (serviced limousine Tuesday)) (= (serviced hatchback Tuesday) (serviced sedan Tuesday))))",
        "(not (exists ((m Vehicles)) (and (not (serviced m Monday)) (not (serviced limousine Monday)))) (or (= (serviced hatchback Wednesday) (serviced sedan Wednesday)) (= (serviced hatchback Wednesday) (serviced sedan Tuesday))))",
        "(not (exists ((m Vehicles)) (and (not (serviced m Monday)) (not (serviced limousine Monday)))) (= (serviced van Monday) true))",
        "(not (exists ((m Vehicles)) (and (not (serviced m Monday)) (not (serviced limousine Monday)))) (= (serviced limousine Saturday) true))",
        "(not (exists ((m Vehicles)) (and (not (serviced m Monday)) (not (serviced limousine Monday)))) (= (serviced pickup Saturday) true))"
      ],
      "type": "sat",
      "perplexity": [
        1.1045706272125244,
        1.0783421993255615
      ],
      "answer": "C",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "SyntaxError: invalid syntax. Perhaps you forgot a comma?"
    }
  },
  {
    "id": 60,
    "nl_problem": {
      "context": "A company's six vehicles—a hatchback, a limousine, a pickup, a roadster, a sedan, and a van—are serviced during a certain week—Monday through Saturday—one vehicle per day. The following conditions must apply: At least one of the vehicles is serviced later in the week than the hatchback. The roadster is serviced later in the week than the van and earlier in the week than the hatchback. Either the pickup and the van are serviced on consecutive days, or the pickup and the sedan are serviced on consecutive days, but not both. The sedan is serviced earlier in the week than the pickup or earlier in the week than the limousine, but not both.",
      "question": "If the limousine is not serviced on Saturday, then each of the following could be true EXCEPT:",
      "options": [
        "A) The limousine is serviced on Monday.",
        "B) The roadster is serviced on Tuesday.",
        "C) The hatchback is serviced on Wednesday.",
        "D) The roadster is serviced on Wednesday.",
        "E) The sedan is serviced on Wednesday."
      ]
    },
    "answer": "E",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((Vehicles 0)) (((hatchback) (limousine) (pickup) (roadster) (sedan) (van))))",
        "(declare-datatypes ((Days 0)) (((Monday) (Tuesday) (Wednesday) (Thursday) (Friday) (Saturday))))",
        "(declare-fun serviced (Vehicles Days) Bool)",
        "(define-fun to-int ((b Bool)) Int (ite b 1 0))"
      ],
      "constraints": [
        "(exists ((d Days)) (and (> d Monday) (not (serviced hatchback d))))",
        "(forall ((d Days)) (=> (serviced van d) (< d (serviced roadster d))))",
        "(forall ((d Days)) (=> (serviced roadster d) (< d (serviced hatchback d))))",
        "(or (and (exists ((d Days)) (and (not (serviced pickup d)) (not (serviced van d)) (not (= (serviced van (if (serviced pickup (ite d Monday Tuesday)) d d))))) (exists ((d Days)) (and (not (serviced pickup d)) (not (serviced sedan d)) (not (= (serviced sedan (if (serviced pickup (ite d Monday Tuesday)) d d))))) (and (exists ((d Days)) (and (not (serviced van d)) (not (serviced pickup d)) (not (= (serviced pickup (if (serviced van (ite d Monday Tuesday)) d d))))) (exists ((d Days)) (and (not (serviced sedan d)) (not (serviced pickup d)) (not (= (serviced pickup (if (serviced sedan (ite d Monday Tuesday)) d d))))))))",
        "(or (forall ((d Days)) (=> (serviced sedan d) (not (or (< d (serviced pickup d)) (< d (serviced limousine d))))) (forall ((d Days)) (=> (serviced limousine d) (not (or (< d (serviced sedan d)) (< d (serviced pickup d)))))",
        "(not (serviced limousine Saturday))",
        "(not (serviced limousine Monday))"
      ],
      "options": [
        "(not (serviced limousine Saturday))",
        "(not (serviced roadster Tuesday))",
        "(not (serviced hatchback Wednesday))",
        "(not (serviced roadster Wednesday))",
        "(not (serviced sedan Wednesday))"
      ],
      "type": "unsat",
      "perplexity": [
        1.1306992769241333,
        1.0884978771209717
      ],
      "answer": "E",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "SyntaxError: invalid syntax. Perhaps you forgot a comma?"
    }
  },
  {
    "id": 61,
    "nl_problem": {
      "context": "A company's six vehicles—a hatchback, a limousine, a pickup, a roadster, a sedan, and a van—are serviced during a certain week—Monday through Saturday—one vehicle per day. The following conditions must apply: At least one of the vehicles is serviced later in the week than the hatchback. The roadster is serviced later in the week than the van and earlier in the week than the hatchback. Either the pickup and the van are serviced on consecutive days, or the pickup and the sedan are serviced on consecutive days, but not both. The sedan is serviced earlier in the week than the pickup or earlier in the week than the limousine, but not both.",
      "question": "If the sedan is serviced earlier in the week than the pickup, then which one of the following could be true?",
      "options": [
        "A) The limousine is serviced on Wednesday.",
        "B) The sedan is serviced on Wednesday.",
        "C) The van is serviced on Wednesday.",
        "D) The hatchback is serviced on Friday.",
        "E) The limousine is serviced on Saturday."
      ]
    },
    "answer": "A",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((Vehicles 0)) (((hatchback) (limousine) (pickup) (roadster) (sedan) (van))))",
        "(declare-datatypes ((Days 0)) (((Monday) (Tuesday) (Wednesday) (Thursday) (Friday) (Saturday))))",
        "(declare-fun serviced (Vehicles Days) Bool)",
        "(define-fun to-int ((b Bool)) Int (ite b 1 0))"
      ],
      "constraints": [
        "(exists ((d Days)) (> (to-int (serviced hatchback d)) (+ (to-int (serviced hatchback Monday)) (to-int (serviced hatchback Tuesday)) (to-int (serviced hatchback Wednesday)) (to-int (serviced hatchback Thursday)) (to-int (serviced hatchback Friday)))))",
        "(and (> (to-int (serviced van _)) (to-int (serviced roadster _))) (< (to-int (serviced hatchback _)) (to-int (serviced roadster _))))",
        "(or (= (to-int (serviced pickup Wednesday)) (+ (to-int (serviced pickup Monday)) (to-int (serviced van Tuesday)))) (= (to-int (serviced pickup Wednesday)) (+ (to-int (serviced pickup Tuesday)) (to-int (serviced sedan Wednesday)))) (not (and (= (to-int (serviced pickup Wednesday)) (+ (to-int (serviced pickup Monday)) (to-int (serviced van Tuesday)))) (= (to-int (serviced pickup Wednesday)) (+ (to-int (serviced pickup Tuesday)) (to-int (serviced sedan Wednesday)))))))",
        "(or (< (to-int (serviced sedan _)) (to-int (serviced pickup _))) (< (to-int (serviced sedan _)) (to-int (serviced limousine _))))",
        "(not (and (< (to-int (serviced sedan _)) (to-int (serviced pickup _))) (< (to-int (serviced sedan _)) (to-int (serviced limousine _)))))"
      ],
      "options": [
        "(= (to-int (serviced sedan _)) (to-int (serviced pickup _)))",
        "(not (serviced limousine Wednesday))",
        "(not (serviced sedan Wednesday))",
        "(not (serviced van Wednesday))",
        "(not (serviced hatchback Friday))",
        "(not (serviced limousine Saturday))"
      ],
      "type": "sat",
      "perplexity": [
        1.1365890502929688,
        1.0722322463989258
      ],
      "answer": "A",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "SyntaxError: invalid syntax. Perhaps you forgot a comma?"
    }
  },
  {
    "id": 62,
    "nl_problem": {
      "context": "A company's six vehicles—a hatchback, a limousine, a pickup, a roadster, a sedan, and a van—are serviced during a certain week—Monday through Saturday—one vehicle per day. The following conditions must apply: At least one of the vehicles is serviced later in the week than the hatchback. The roadster is serviced later in the week than the van and earlier in the week than the hatchback. Either the pickup and the van are serviced on consecutive days, or the pickup and the sedan are serviced on consecutive days, but not both. The sedan is serviced earlier in the week than the pickup or earlier in the week than the limousine, but not both.",
      "question": "If the limousine is serviced on Saturday, then which one of the following must be true?",
      "options": [
        "A) The pickup is serviced earlier in the week than the roadster.",
        "B) The pickup is serviced earlier in the week than the sedan.",
        "C) The sedan is serviced earlier in the week than the roadster.",
        "D) The hatchback and the limousine are serviced on consecutive days.",
        "E) The roadster and the hatchback are serviced on consecutive days."
      ]
    },
    "answer": "B",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((Days 0)) (((monday) (tuesday) (wednesday) (thursday) (friday) (saturday))))",
        "(declare-datatypes ((Vehicles 0)) (((hatchback) (limousine) (pickup) (roadster) (sedan) (van))))",
        "(declare-fun serviced (Days Vehicles) Bool)",
        "(define-fun later (A B) Bool (and (= A saturday) (= B monday) (or (distinct A B) (distinct B saturday))))",
        "(define-fun consecutive (A B) Bool (and (distinct A B) (or (and (= A monday) (= B tuesday)) (and (= A tuesday) (= B wednesday)) (and (= A wednesday) (= B thursday)) (and (= A thursday) (= B friday)) (and (= A friday) (= B saturday)))))"
      ],
      "constraints": [
        "(exists ((v Vehicles)) (later v hatchback))",
        "(and (later roadster van) (later hatchback roadster))",
        "(or (consecutive pickup van) (consecutive pickup sedan) (not (and (consecutive pickup van) (consecutive pickup sedan))))",
        "(or (later sedan pickup) (later sedan limousine) (not (and (later sedan pickup) (later sedan limousine))))",
        "(= (serviced saturday limousine) true)"
      ],
      "options": [
        "(exists ((m Days)) (= (serviced m pickup) (serviced m roadster)))",
        "(exists ((m Days)) (= (serviced m pickup) (serviced m sedan)))",
        "(exists ((m Days)) (= (serviced m sedan) (serviced m roadster)))",
        "(exists ((m Days)) (= (serviced m hatchback) (serviced m limousine)))",
        "(exists ((m Days)) (= (serviced m roadster) (serviced m hatchback)))"
      ],
      "type": [
        {
          "option": 0,
          "type": "sat"
        },
        {
          "option": 1,
          "type": "sat"
        },
        {
          "option": 2,
          "type": "sat"
        },
        {
          "option": 3,
          "type": "unsat"
        },
        {
          "option": 4,
          "type": "sat"
        }
      ],
      "perplexity": [
        1.1734986305236816,
        1.0845412015914917
      ],
      "answer": "B",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "SyntaxError: invalid syntax. Perhaps you forgot a comma?"
    }
  },
  {
    "id": 63,
    "nl_problem": {
      "context": "A company's six vehicles—a hatchback, a limousine, a pickup, a roadster, a sedan, and a van—are serviced during a certain week—Monday through Saturday—one vehicle per day. The following conditions must apply: At least one of the vehicles is serviced later in the week than the hatchback. The roadster is serviced later in the week than the van and earlier in the week than the hatchback. Either the pickup and the van are serviced on consecutive days, or the pickup and the sedan are serviced on consecutive days, but not both. The sedan is serviced earlier in the week than the pickup or earlier in the week than the limousine, but not both.",
      "question": "Which one of the following could be the list of the vehicles serviced on Tuesday, Wednesday, and Friday, listed in that order?",
      "options": [
        "A) the pickup, the hatchback, the limousine",
        "B) the pickup, the roadster, the hatchback",
        "C) the sedan, the limousine, the hatchback",
        "D) the van, the limousine, the hatchback",
        "E) the van, the roadster, the limousine"
      ]
    },
    "answer": "B",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((Days 0)) (((Monday) (Tuesday) (Wednesday) (Thursday) (Friday) (Saturday))))",
        "(declare-datatypes ((Vehicles 0)) (((hatchback) (limousine) (pickup) (roadster) (sedan) (van))))",
        "(declare-fun serviced (Vehicles Days) Bool)"
      ],
      "constraints": [
        "(exists ((v Vehicles) (d Days)) (and (> d Monday) (not (serviced hatchback d))))",
        "(forall ((d Days)) (=> (and (serviced van d) (serviced roadster d)) (not (serviced roadster (ite (= d Monday) Wednesday Tuesday)))))",
        "(forall ((d Days)) (=> (and (serviced roadster d) (serviced hatchback d)) (not (serviced hatchback (ite (= d Monday) Wednesday Tuesday)))))",
        "(forall ((d Days)) (=> (and (serviced roadster d) (not (serviced hatchback d))) (not (serviced hatchback (ite (= d Monday) Wednesday Tuesday)))))",
        "(or (and (exists ((d Days)) (and (serviced pickup d) (serviced van (ite (= d Monday) Tuesday Wednesday))))))",
        "(forall ((d Days)) (=> (and (serviced sedan d) (serviced pickup (ite (= d Monday) Thursday Friday))) (not (serviced limousine d))))",
        "(forall ((d Days)) (=> (and (serviced sedan d) (serviced limousine (ite (= d Monday) Thursday Friday))) (not (serviced pickup d))))",
        "(= (serviced pickup Tuesday) (serviced hatchback Wednesday) (serviced limousine Friday))",
        "(= (serviced pickup Tuesday) (serviced roadster Wednesday) (serviced hatchback Friday))",
        "(= (serviced sedan Tuesday) (serviced limousine Wednesday) (serviced hatchback Friday))",
        "(= (serviced van Tuesday) (serviced limousine Wednesday) (serviced hatchback Friday))",
        "(= (serviced van Tuesday) (serviced roadster Wednesday) (serviced limousine Friday))"
      ],
      "options": [
        "(= (serviced pickup Tuesday) (serviced hatchback Wednesday) (serviced limousine Friday))",
        "(= (serviced pickup Tuesday) (serviced roadster Wednesday) (serviced hatchback Friday))",
        "(= (serviced sedan Tuesday) (serviced limousine Wednesday) (serviced hatchback Friday))",
        "(= (serviced van Tuesday) (serviced limousine Wednesday) (serviced hatchback Friday))",
        "(= (serviced van Tuesday) (serviced roadster Wednesday) (serviced limousine Friday))"
      ],
      "type": "sat",
      "perplexity": [
        1.1341263055801392,
        1.0722039937973022
      ],
      "answer": "B",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "SyntaxError: invalid syntax. Perhaps you forgot a comma?"
    }
  },
  {
    "id": 64,
    "nl_problem": {
      "context": "A street entertainer has six boxes stacked one on top of the other and numbered consecutively 1 through 6, from the lowest box up to the highest. Each box contains a single ball, and each ball is one of three colors—green, red, or white. Onlookers are to guess the color of each ball in each box, given that the following conditions hold: There are more red balls than white balls. There is a box containing a green ball that is lower in the stack than any box that contains a red ball. There is a white ball in a box that is immediately below a box that contains a green ball.",
      "question": "If there are exactly two white balls, then which one of the following boxes could contain a green ball?",
      "options": [
        "A) box 1",
        "B) box 3",
        "C) box 4",
        "D) box 5",
        "E) box 6"
      ]
    },
    "answer": "B",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((Boxes 0)) (((box1) (box2) (box3) (box4) (box5) (box6))))",
        "(declare-datatypes ((Balls 0)) (((red) (green) (white)))",
        "(declare-fun contains (Boxes Balls) Bool)"
      ],
      "constraints": [
        ">= (+ (ite (contains box1 red) 1 0) (ite (contains box2 red) 1 0) (ite (contains box3 red) 1 0) (ite (contains box4 red) 1 0) (ite (contains box5 red) 1 0) (ite (contains box6 red) 1 0)) (+ (ite (contains box1 white) 1 0) (ite (contains box2 white) 1 0) (ite (contains box3 white) 1 0) (ite (contains box4 white) 1 0) (ite (contains box5 white) 1 0) (ite (contains box6 white) 1 0)))",
        "(exists ((g Boxes)) (exists ((r Boxes)) (and (contains g green) (contains r red) (< (ite (eq g box1) 1 0) (ite (eq r box1) 1 0)))))",
        "(exists ((w Boxes) (g Boxes)) (exists ((x Boxes)) (and (contains w white) (contains x green) (ite (eq w box1) (= x box2) (ite (eq w box2) (= x box3) (ite (eq w box3) (= x box4) (ite (eq w box4) (= x box5) (ite (eq w box5) (= x box6) (= 0 1)))))))))",
        "=(+ (ite (contains box1 white) 1 0) (ite (contains box2 white) 1 0) (ite (contains box3 white) 1 0) (ite (contains box4 white) 1 0) (ite (contains box5 white) 1 0) (ite (contains box6 white) 1 0)) 2"
      ],
      "options": [
        "(or (contains box1 green) (contains box2 green))",
        "(or (contains box3 green) (contains box4 green))",
        "(or (contains box5 green) (contains box6 green))"
      ],
      "type": "sat",
      "perplexity": [
        1.1259963512420654,
        1.0804684162139893
      ],
      "answer": "B",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "SyntaxError: unmatched ')'"
    }
  },
  {
    "id": 65,
    "nl_problem": {
      "context": "A street entertainer has six boxes stacked one on top of the other and numbered consecutively 1 through 6, from the lowest box up to the highest. Each box contains a single ball, and each ball is one of three colors—green, red, or white. Onlookers are to guess the color of each ball in each box, given that the following conditions hold: There are more red balls than white balls. There is a box containing a green ball that is lower in the stack than any box that contains a red ball. There is a white ball in a box that is immediately below a box that contains a green ball.",
      "question": "If there are green balls in boxes 5 and 6, then which one of the following could be true?",
      "options": [
        "A) There are red balls in boxes 1 and 4.",
        "B) There are red balls in boxes 2 and 4.",
        "C) There is a white ball in box 1.",
        "D) There is a white ball in box 2.",
        "E) There is a white ball in box 3."
      ]
    },
    "answer": "C",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((Boxes 0)) (((box1) (box2) (box3) (box4) (box5) (box6))))",
        "(declare-datatypes ((Colors 0)) (((green) (red) (white))))",
        "(declare-fun has-color (Boxes Colors) Bool)"
      ],
      "constraints": [
        ">(+ (ite (has-color box1 red) 1 0) (ite (has-color box2 red) 1 0) (ite (has-color box3 red) 1 0) (ite (has-color box4 red) 1 0) (ite (has-color box5 red) 1 0) (ite (has-color box6 red) 1 0) (+ (ite (has-color box1 white) 1 0) (ite (has-color box2 white) 1 0) (ite (has-color box3 white) 1 0) (ite (has-color box4 white) 1 0) (ite (has-color box5 white) 1 0) (ite (has-color box6 white) 1 0)))",
        "(forall ((b Boxes) (r Boxes)) (= (has-color b green) (or (not (has-color r red)) (< b r))))",
        "(forall ((b Boxes) (b' Boxes)) (= (has-color b' white) (=> (and (has-color b' green) (= (+ (ite (has-color box1 green) 1 0) (ite (has-color box2 green) 1 0) (ite (has-color box3 green) 1 0) (ite (has-color box4 green) 1 0) (ite (has-color box5 green) 1 0) (ite (has-color box6 green) 1 0)) (+ (ite (has-color box1 green) 1 0) (ite (has-color box2 green) 1 0) (ite (has-color box3 green) 1 0) (ite (has-color box4 green) 1 0) (ite (has-color box5 green) 1 0) (ite (has-color box6 green) 1 0)) b') b'))))",
        "(and (has-color box5 green) (has-color box6 green))"
      ],
      "options": [
        "(forall ((m Boxes)) (ite (has-color m red) (= (+ (ite (has-color m red) 1 0) (ite (has-color m red) 1 0)) 2)))",
        "(forall ((m Boxes)) (ite (has-color m red) (= (+ (ite (has-color m red) 1 0) (ite (has-color m red) 1 0)) 2)))",
        "(forall ((m Boxes)) (= (has-color m white) (= m box1)))",
        "(forall ((m Boxes)) (= (has-color m white) (= m box2)))",
        "(forall ((m Boxes)) (= (has-color m white) (= m box3)))"
      ],
      "type": "sat",
      "perplexity": [
        1.103345513343811,
        1.0729484558105469
      ],
      "answer": "C",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "SyntaxError: unterminated string literal (detected at line 10)"
    }
  },
  {
    "id": 66,
    "nl_problem": {
      "context": "A street entertainer has six boxes stacked one on top of the other and numbered consecutively 1 through 6, from the lowest box up to the highest. Each box contains a single ball, and each ball is one of three colors—green, red, or white. Onlookers are to guess the color of each ball in each box, given that the following conditions hold: There are more red balls than white balls. There is a box containing a green ball that is lower in the stack than any box that contains a red ball. There is a white ball in a box that is immediately below a box that contains a green ball.",
      "question": "The ball in which one of the following boxes must be the same color as at least one of the other balls?",
      "options": [
        "A) box 2",
        "B) box 3",
        "C) box 4",
        "D) box 5",
        "E) box 6"
      ]
    },
    "answer": "E",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((Boxes 0)) (((box1) (box2) (box3) (box4) (box5) (box6))))",
        "(declare-datatypes ((Colors 0)) (((green) (red) (white))))",
        "(declare-fun contains (Boxes) (Colors Bool))"
      ],
      "constraints": [
        ">(+ (ite (contains box1 red) 1 0) (ite (contains box2 red) 1 0) (ite (contains box3 red) 1 0) (ite (contains box4 red) 1 0) (ite (contains box5 red) 1 0) (ite (contains box6 red) 1 0) (+ (ite (contains box1 white) 1 0) (ite (contains box2 white) 1 0) (ite (contains box3 white) 1 0) (ite (contains box4 white) 1 0) (ite (contains box5 white) 1 0) (ite (contains box6 white) 1 0)))",
        "(forall ((x Boxes) (y Boxes)) (=> (and (contains x green) (contains y red)) (< x y)))",
        "(forall ((x Boxes) (y Boxes)) (=> (and (< x y) (contains y green)) (ite (< x box4) (ite (contains x white) true false) (contains box4 white))))"
      ],
      "options": [
        "(= (ite (contains box2 green) green (ite (contains box2 red) red white)))",
        "(= (ite (contains box3 green) green (ite (contains box3 red) red white)))",
        "(= (ite (contains box4 green) green (ite (contains box4 red) red white)))",
        "(= (ite (contains box5 green) green (ite (contains box5 red) red white)))",
        "(= (ite (contains box6 green) green (ite (contains box6 red) red white)))"
      ],
      "type": "sat",
      "perplexity": [
        1.1046348810195923,
        1.0998104810714722
      ],
      "answer": "E",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "SyntaxError: invalid syntax"
    }
  },
  {
    "id": 67,
    "nl_problem": {
      "context": "A street entertainer has six boxes stacked one on top of the other and numbered consecutively 1 through 6, from the lowest box up to the highest. Each box contains a single ball, and each ball is one of three colors—green, red, or white. Onlookers are to guess the color of each ball in each box, given that the following conditions hold: There are more red balls than white balls. There is a box containing a green ball that is lower in the stack than any box that contains a red ball. There is a white ball in a box that is immediately below a box that contains a green ball.",
      "question": "Which one of the following must be true?",
      "options": [
        "A) There is a green ball in a box that is lower than box 4.",
        "B) There is a green ball in a box that is higher than box 4.",
        "C) There is a red ball in a box that is lower than box 4.",
        "D) There is a red ball in a box that is higher than box 4.",
        "E) There is a white ball in a box that is lower than box 4."
      ]
    },
    "answer": "A",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((Colors 0)) (((green) (red) (white))))",
        "(declare-datatypes ((Boxes 0)) (((box1) (box2) (box3) (box4) (box5) (box6))))",
        "(declare-fun contains (Boxes Colors) Bool)"
      ],
      "constraints": [
        "(> (+ (ite (contains box1 red) 1 0) (ite (contains box2 red) 1 0) (ite (contains box3 red) 1 0) (ite (contains box4 red) 1 0) (ite (contains box5 red) 1 0) (ite (contains box6 red) 1 0)) (+ (ite (contains box1 white) 1 0) (ite (contains box2 white) 1 0) (ite (contains box3 white) 1 0) (ite (contains box4 white) 1 0) (ite (contains box5 white) 1 0) (ite (contains box6 white) 1 0)))",
        "(forall ((b Boxes) (g Boxes)) (=> (and (contains b green) (not (contains g red))) (< b g)))",
        "(forall ((b Boxes) (g Boxes)) (=> (and (contains (if b box3 then box4 else box5) white) (contains b green)) (< b (if b box3 then box4 else box5))))"
      ],
      "options": [
        "(exists ((b Boxes)) (and (contains b green) (< b box4)))",
        "(exists ((b Boxes)) (and (contains b green) (> b box4)))",
        "(exists ((b Boxes)) (and (contains b red) (< b box4)))",
        "(exists ((b Boxes)) (and (contains b red) (> b box4)))",
        "(exists ((b Boxes)) (and (contains b white) (< b box4)))"
      ],
      "type": "sat",
      "perplexity": [
        1.1528048515319824,
        1.0996474027633667
      ],
      "answer": "A",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "SyntaxError: invalid syntax"
    }
  },
  {
    "id": 68,
    "nl_problem": {
      "context": "A street entertainer has six boxes stacked one on top of the other and numbered consecutively 1 through 6, from the lowest box up to the highest. Each box contains a single ball, and each ball is one of three colors—green, red, or white. Onlookers are to guess the color of each ball in each box, given that the following conditions hold: There are more red balls than white balls. There is a box containing a green ball that is lower in the stack than any box that contains a red ball. There is a white ball in a box that is immediately below a box that contains a green ball.",
      "question": "If there are red balls in boxes 2 and 3, then which one of the following could be true?",
      "options": [
        "A) There is a red ball in box 1.",
        "B) There is a white ball in box 1.",
        "C) There is a green ball in box 4.",
        "D) There is a red ball in box 5.",
        "E) There is a white ball in box 6."
      ]
    },
    "answer": "C",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((Boxes 0)) (((box1) (box2) (box3) (box4) (box5) (box6))))",
        "(declare-datatypes ((Colors 0)) (((red) (green) (white))))",
        "(declare-fun contains (Boxes Colors) Bool)",
        "(define-fun to-int ((b Bool)) Int (ite b 1 0))"
      ],
      "constraints": [
        "(> (+ (to-int (contains box1 red)) (to-int (contains box2 red)) (to-int (contains box3 red)) (to-int (contains box4 red)) (to-int (contains box5 red)) (to-int (contains box6 red))) (+ (to-int (contains box1 white)) (to-int (contains box2 white)) (to-int (contains box3 white)) (to-int (contains box4 white)) (to-int (contains box5 white)) (to-int (contains box6 white))))",
        "(and (exists ((b Boxes)) (exists ((c Colors)) (and (= c green) (contains b c) (forall ((x Boxes)) (=> (contains x red) (> x b))))) (exists ((b Boxes) (c Colors)) (and (= c green) (contains b c) (exists ((x Boxes)) (and (= b (+ x 1)) (contains x white)))))",
        "(forall ((b Boxes) (c Colors)) (or (not (and (= c red) (contains b c) (and (= b box2) (= c red)))) (not (and (= c red) (contains b c) (and (= b box1))))) (not (and (= c red) (contains b c) (and (= b box3))))) (not (and (= c red) (contains b c) (and (= b box4))))) (not (and (= c red) (contains b c) (and (= b box5))))) (not (and (= c red) (contains b c) (and (= b box6)))))",
        "(forall ((b Boxes) (c Colors)) (or (not (and (= c red) (contains b c) (and (= b box2) (= c red))))) (not (and (= c red) (contains b c) (and (= b box3))))) (not (and (= c red) (contains b c) (and (= b box4))))) (not (and (= c red) (contains b c) (and (= b box5))))) (not (and (= c red) (contains b c) (and (= b box6)))))",
        "(forall ((b Boxes) (c Colors)) (or (not (and (= c red) (contains b c) (and (= b box2) (= c red))))) (not (and (= c red) (contains b c) (and (= b box3))))) (not (and (= c red) (contains b c) (and (= b box4))))) (not (and (= c red) (contains b c) (and (= b box5))))) (not (and (= c red) (contains b c) (and (= b box6)))))",
        "(forall ((b Boxes) (c Colors)) (or (not (and (= c red) (contains b c) (and (= b box2) (= c red))))) (not (and (= c red) (contains b c) (and (= b box3))))) (not (and (= c red) (contains b c) (and (= b box4))))) (not (and (= c red) (contains b c) (and (= b box5))))) (not (and (= c red) (contains b c) (and (= b box6))))))",
        "(forall ((b Boxes) (c Colors)) (or (not (and (= c red) (contains b c) (and (= b box2) (= c red))))) (not (and (= c red) (contains b c) (and (= b box3))))) (not (and (= c red) (contains b c) (and (= b box4))))) (not (and (= c red) (contains b c) (and (= b box5))))) (not (and (= c red) (contains b c) (and (= b box6)))))"
      ],
      "options": [],
      "type": "sat",
      "perplexity": [
        1.0889620780944824,
        1.074556589126587
      ],
      "answer": "C",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "SyntaxError: unmatched ')'"
    }
  },
  {
    "id": 69,
    "nl_problem": {
      "context": "A street entertainer has six boxes stacked one on top of the other and numbered consecutively 1 through 6, from the lowest box up to the highest. Each box contains a single ball, and each ball is one of three colors—green, red, or white. Onlookers are to guess the color of each ball in each box, given that the following conditions hold: There are more red balls than white balls. There is a box containing a green ball that is lower in the stack than any box that contains a red ball. There is a white ball in a box that is immediately below a box that contains a green ball.",
      "question": "If boxes 2, 3, and 4 all contain balls that are the same color as each other, then which one of the following must be true?",
      "options": [
        "A) Exactly two of the boxes contain a green ball.",
        "B) Exactly three of the boxes contain a green ball.",
        "C) Exactly three of the boxes contain a red ball.",
        "D) Exactly one of the boxes contains a white ball.",
        "E) Exactly two of the boxes contain a white ball."
      ]
    },
    "answer": "D",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((Boxes 0)) (((box1) (box2) (box3) (box4) (box5) (box6))))",
        "(declare-datatypes ((Colors 0)) (((green) (red) (white))))",
        "(declare-fun in-box (Boxes Colors) Bool)",
        "(define-fun to-int ((b Bool)) Int (ite b 1 0))"
      ],
      "constraints": [
        ">(+ (to-int (in-box box1 red)) (to-int (in-box box2 red)) (to-int (in-box box3 red)) (to-int (in-box box4 red)) (to-int (in-box box5 red)) (to-int (in-box box6 red)) (+ (to-int (in-box box1 white)) (to-int (in-box box2 white)) (to-int (in-box box3 white)) (to-int (in-box box4 white)) (to-int (in-box box5 white)) (to-int (in-box box6 white))))",
        "(forall ((b1 Boxes) (b2 Boxes) (c Colors)) (=> (and (in-box b1 green) (in-box b2 red)) (< b1 b2)))",
        "(forall ((b1 Boxes) (b2 Boxes) (c Colors)) (=> (and (in-box b1 green) (in-box b2 green) (= (+ (to-int (in-box b1 green)) 1) (to-int (in-box b2 green)))) (= b2 (+ b1 1))))",
        "(forall ((c Colors)) (and (= (in-box box2 c) (in-box box3 c)) (= (in-box box3 c) (in-box box4 c))))"
      ],
      "options": [
        "(forall ((b Boxes)) (= (to-int (in-box b green)) (ite (= b box1) 1 0) + (ite (= b box5) 1 0))))",
        "(forall ((b Boxes)) (= (to-int (in-box b green)) (ite (= b box2) 1 0) + (ite (= b box3) 1 0) + (ite (= b box4) 1 0))))",
        "(forall ((b Boxes)) (= (to-int (in-box b red)) (ite (= b box1) 1 0) + (ite (= b box5) 1 0))))",
        "(forall ((b Boxes)) (= (to-int (in-box b white)) (ite (= b box1) 1 0) + (ite (= b box2) 1 0)))",
        "(forall ((b Boxes)) (= (to-int (in-box b white)) (ite (= b box2) 1 0) + (ite (= b box3) 1 0) + (ite (= b box4) 1 0))))"
      ],
      "type": "sat",
      "perplexity": [
        1.15855073928833,
        1.0601834058761597
      ],
      "answer": "D",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "SyntaxError: unmatched ')'"
    }
  },
  {
    "id": 70,
    "nl_problem": {
      "context": "A professor must determine the order in which five of her students—Fernando, Ginny, Hakim, Juanita, and Kevin—will perform in an upcoming piano recital. Each student performs one piece, and no two performances overlap. The following constraints apply: Ginny must perform earlier than Fernando. Kevin must perform earlier than Hakim and Juanita. Hakim must perform either immediately before or immediately after Fernando.",
      "question": "Which one of the following could be the order, from first to last, in which the students perform?",
      "options": [
        "A) Ginny, Fernando, Hakim, Kevin, Juanita",
        "B) Ginny, Juanita, Kevin, Hakim, Fernando",
        "C) Ginny, Kevin, Hakim, Juanita, Fernando",
        "D) Kevin, Ginny, Juanita, Fernando, Hakim",
        "E) Kevin, Juanita, Fernando, Hakim, Ginny"
      ]
    },
    "answer": "D",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((Students 0)) (((Fernando) (Ginny) (Hakim) (Juanita) (Kevin))))",
        "(declare-fun performs (Students) Int)",
        "(define-fun to-int ((b Bool)) Int (ite b 1 0))"
      ],
      "constraints": [
        "(not (= (performs Ginny) (performs Fernando)))",
        "(and (< (performs Kevin) (performs Hakim)) (< (performs Kevin) (performs Juanita)))",
        "(or (= (performs Hakim) (- (performs Fernando) 1)) (= (performs Hakim) (+ (performs Fernando) 1)))"
      ],
      "options": [
        "(forall ((s Students)) (and (= (performs Ginny) (performs s)) (= (performs s) (performs s))))",
        "(= (performs Fernando) (+ (performs Hakim) 1))",
        "(= (performs Kevin) (- (performs Juanita) 2))"
      ],
      "type": "sat",
      "perplexity": [
        1.0964412689208984,
        1.1746931076049805
      ],
      "answer": "D",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "SyntaxError: invalid syntax"
    }
  },
  {
    "id": 71,
    "nl_problem": {
      "context": "A professor must determine the order in which five of her students—Fernando, Ginny, Hakim, Juanita, and Kevin—will perform in an upcoming piano recital. Each student performs one piece, and no two performances overlap. The following constraints apply: Ginny must perform earlier than Fernando. Kevin must perform earlier than Hakim and Juanita. Hakim must perform either immediately before or immediately after Fernando.",
      "question": "If Juanita performs earlier than Ginny, then which one of the following could be true?",
      "options": [
        "A) Fernando performs fourth.",
        "B) Ginny performs second.",
        "C) Hakim performs third.",
        "D) Juanita performs third.",
        "E) Kevin performs second."
      ]
    },
    "answer": "A",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((Students 0)) (((Fernando) (Ginny) (Hakim) (Juanita) (Kevin))))",
        "(declare-datatypes ((Performances 0)) (((piece1) (piece2) (piece3) (piece4) (piece5))))",
        "(declare-fun performance (Students Performances) Bool)",
        "(define-fun to-int ((b Bool)) Int (ite b 1 0))"
      ],
      "constraints": [
        "(forall ((p Performances)) (=> (performance Ginny p) (not (performance Fernando p))))",
        "(forall ((p Performances)) (=> (performance Kevin p) (not (and (performance Hakim p) (performance Juanita p)))))",
        "(forall ((p Performances)) (or (and (performance Hakim (ite (= p piece1) piece2 piece1)) (performance Fernando (ite (= p piece1) piece2 piece1))) (and (performance Fernando (ite (= p piece1) piece2 piece1)) (performance Hakim (ite (= p piece1) piece2 piece1)))))",
        "(not (performance Ginny piece1))",
        "(forall ((s Students)) (= (+ (to-int (performance s piece1)) (to-int (performance s piece2)) (to-int (performance s piece3)) (to-int (performance s piece4)) (to-int (performance s piece5))) 1))"
      ],
      "options": [
        "(not (= (performance Juanita piece3) (performance Ginny piece3)))",
        "(not (= (performance Juanita piece4) (performance Ginny piece4)))",
        "(not (= (performance Juanita piece5) (performance Ginny piece5)))",
        "(= (performance Fernando piece4) true)"
      ],
      "type": "sat",
      "perplexity": [
        1.181323528289795,
        1.1102099418640137
      ],
      "answer": "A",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "SyntaxError: invalid syntax. Perhaps you forgot a comma?"
    }
  },
  {
    "id": 72,
    "nl_problem": {
      "context": "A professor must determine the order in which five of her students—Fernando, Ginny, Hakim, Juanita, and Kevin—will perform in an upcoming piano recital. Each student performs one piece, and no two performances overlap. The following constraints apply: Ginny must perform earlier than Fernando. Kevin must perform earlier than Hakim and Juanita. Hakim must perform either immediately before or immediately after Fernando.",
      "question": "Which one of the following CANNOT be true?",
      "options": [
        "A) Fernando performs immediately before Juanita.",
        "B) Ginny performs immediately before Hakim.",
        "C) Hakim performs immediately before Ginny.",
        "D) Juanita performs immediately before Ginny.",
        "E) Kevin performs immediately before Hakim."
      ]
    },
    "answer": "C",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((Students 0)) (((Fernando) (Ginny) (Hakim) (Juanita) (Kevin))))",
        "(declare-datatypes ((Pieces 0)) (((piece1) (piece2) (piece3) (piece4) (piece5))))",
        "(declare-fun performs (Students Pieces) Bool)",
        "(define-fun to-int ((b Bool)) Int (ite b 1 0))"
      ],
      "constraints": [
        "(forall ((s Students)) (>= (+ (to-int (performs s piece1)) (to-int (performs s piece2)) (to-int (performs s piece3)) (to-int (performs s piece4)) (to-int (performs s piece5))) 1))",
        "(forall ((p Pieces)) (=> (performs Ginny p) (performs Fernando (ite (= p piece1) piece2 piece1))))",
        "(forall ((p Pieces)) (=> (performs Kevin p) (and (performs Hakim (ite (= p piece1) piece2 piece1)) (performs Juanita (ite (= p piece1) piece2 piece1)))))",
        "(forall ((p Pieces)) (or (= p (ite (performs Hakim (ite (= (ite (performs Fernando (ite (= p piece1) piece2 piece1)) piece1) piece2) piece3) piece1) piece2)) (= p (ite (performs Hakim (ite (= (ite (performs Fernando (ite (= p piece1) piece2 piece1)) piece1) piece2) piece3) piece1) piece4))))"
      ],
      "options": [
        "(not (forall ((m Pieces)) (= (performs Fernando m) (ite (performs Juanita (ite (= m piece1) piece2 piece1)) piece2 piece1))))",
        "(not (forall ((m Pieces)) (= (performs Ginny m) (ite (performs Hakim (ite (= m piece1) piece2 piece1)) piece2 piece1))))",
        "(not (forall ((m Pieces)) (= (performs Hakim m) (ite (performs Ginny (ite (= m piece1) piece2 piece1)) piece2 piece1))))",
        "(not (forall ((m Pieces)) (= (performs Juanita m) (ite (performs Ginny (ite (= m piece1) piece2 piece1)) piece2 piece1))))",
        "(not (forall ((m Pieces)) (= (performs Kevin m) (ite (performs Hakim (ite (= m piece1) piece2 piece1)) piece2 piece1))))"
      ],
      "type": "sat",
      "perplexity": [
        1.0912024974822998,
        1.0676004886627197
      ],
      "answer": "C",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "SyntaxError: invalid syntax. Perhaps you forgot a comma?"
    }
  },
  {
    "id": 73,
    "nl_problem": {
      "context": "A professor must determine the order in which five of her students—Fernando, Ginny, Hakim, Juanita, and Kevin—will perform in an upcoming piano recital. Each student performs one piece, and no two performances overlap. The following constraints apply: Ginny must perform earlier than Fernando. Kevin must perform earlier than Hakim and Juanita. Hakim must perform either immediately before or immediately after Fernando.",
      "question": "The order in which the students perform is fully determined if which one of the following is true?",
      "options": [
        "A) Fernando performs immediately before Hakim.",
        "B) Ginny performs immediately before Fernando.",
        "C) Hakim performs immediately before Juanita.",
        "D) Juanita performs immediately before Hakim.",
        "E) Kevin performs immediately before Fernando."
      ]
    },
    "answer": "E",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((Students 0)) (((Fernando) (Ginny) (Hakim) (Juanita) (Kevin))))",
        "(declare-datatypes ((Pieces 0)) (((piece1) (piece2) (piece3) (piece4) (piece5))))",
        "(declare-fun performs (Students Pieces) Bool)",
        "(define-fun to-int ((b Bool)) Int (ite b 1 0))"
      ],
      "constraints": [
        "(forall ((s Students)) (>= (+ (to-int (performs s piece1)) (to-int (performs s piece2)) (to-int (performs s piece3)) (to-int (performs s piece4)) (to-int (performs s piece5))) 1))",
        "(forall ((m Pieces)) (=> (performs Ginny m) (not (exists ((n Pieces)) (and (performs Fernando n) (> n m)))))",
        "(forall ((m Pieces)) (=> (performs Kevin m) (not (exists ((n Pieces)) (and (performs Hakim n) (> n m)))))",
        "(forall ((m Pieces)) (=> (performs Kevin m) (not (exists ((n Pieces)) (and (performs Juanita n) (> n m)))))",
        "(forall ((m Pieces)) (or (and (performs Hakim m) (not (exists ((n Pieces)) (and (performs Fernando n) (= n (+ m 1))))))"
      ],
      "options": [
        "(forall ((m Pieces)) (= m (+ (performs Fernando m) 1)))",
        "(forall ((m Pieces)) (exists ((n Pieces)) (and (performs Ginny m) (performs Fernando n) (= n (+ m 1)))))",
        "(forall ((m Pieces)) (exists ((n Pieces)) (and (performs Hakim m) (performs Juanita n) (= n (+ m 1)))))",
        "(forall ((m Pieces)) (exists ((n Pieces)) (and (performs Juanita m) (performs Hakim n) (= n (+ m 1)))))",
        "(forall ((m Pieces)) (exists ((n Pieces)) (and (performs Kevin m) (performs Fernando n) (= n (+ m 1)))))"
      ],
      "type": "sat",
      "perplexity": [
        1.1062915325164795,
        1.0883173942565918
      ],
      "answer": "E",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "SyntaxError: invalid syntax. Perhaps you forgot a comma?"
    }
  },
  {
    "id": 74,
    "nl_problem": {
      "context": "A professor must determine the order in which five of her students—Fernando, Ginny, Hakim, Juanita, and Kevin—will perform in an upcoming piano recital. Each student performs one piece, and no two performances overlap. The following constraints apply: Ginny must perform earlier than Fernando. Kevin must perform earlier than Hakim and Juanita. Hakim must perform either immediately before or immediately after Fernando.",
      "question": "How many of the students are there any one of whom could perform fourth?",
      "options": [
        "A) one",
        "B) two",
        "C) three",
        "D) four",
        "E) five"
      ]
    },
    "answer": "B",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((Students 0)) (((Fernando) (Ginny) (Hakim) (Juanita) (Kevin))))",
        "(declare-fun performs (Students) Int)"
      ],
      "constraints": [
        "(forall ((s Students)) (<= (performs s) 4))",
        "(< (performs Ginny) (performs Fernando))",
        "(and (< (performs Kevin) (performs Hakim)) (< (performs Kevin) (performs Juanita)))",
        "(or (= (performs Hakim) (- (performs Fernando) 1)) (= (performs Hakim) (+ (performs Fernando) 1)))"
      ],
      "options": [
        "(= (exists ((f Fernando) (g Ginny) (h Hakim) (j Juanita) (k Kevin)) (and (<= 1 f) (<= 1 g) (<= 1 h) (<= 1 j) (<= 1 k) (<= (performs g) (performs f)) (<= (performs k) (performs h)) (<= (performs k) (performs j)) (or (= (performs h) (- (performs f) 1)) (= (performs h) (+ (performs f) 1)))) 1))",
        "(= (exists ((f Fernando) (g Ginny) (h Hakim) (j Juanita) (k Kevin)) (and (<= 1 f) (<= 1 g) (<= 1 h) (<= 1 j) (<= 1 k) (<= (performs g) (performs f)) (<= (performs k) (performs h)) (<= (performs k) (performs j)) (or (= (performs h) (- (performs f) 1)) (= (performs h) (+ (performs f) 1)))) 2))",
        "(= (exists ((f Fernando) (g Ginny) (h Hakim) (j Juanita) (k Kevin)) (and (<= 1 f) (<= 1 g) (<= 1 h) (<= 1 j) (<= 1 k) (<= (performs g) (performs f)) (<= (performs k) (performs h)) (<= (performs k) (performs j)) (or (= (performs h) (- (performs f) 1)) (= (performs h) (+ (performs f) 1)))) 3))",
        "(= (exists ((f Fernando) (g Ginny) (h Hakim) (j Juanita) (k Kevin)) (and (<= 1 f) (<= 1 g) (<= 1 h) (<= 1 j) (<= 1 k) (<= (performs g) (performs f)) (<= (performs k) (performs h)) (<= (performs k) (performs j)) (or (= (performs h) (- (performs f) 1)) (= (performs h) (+ (performs f) 1)))) 4))",
        "(= (exists ((f Fernando) (g Ginny) (h Hakim) (j Juanita) (k Kevin)) (and (<= 1 f) (<= 1 g) (<= 1 h) (<= 1 j) (<= 1 k) (<= (performs g) (performs f)) (<= (performs k) (performs h)) (<= (performs k) (performs j)) (or (= (performs h) (- (performs f) 1)) (= (performs h) (+ (performs f) 1)))) 5))"
      ],
      "type": "sat",
      "perplexity": [
        1.1174381971359253,
        1.0488237142562866
      ],
      "answer": "B",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "SyntaxError: invalid syntax. Perhaps you forgot a comma?"
    }
  },
  {
    "id": 75,
    "nl_problem": {
      "context": "As part of an open house at a crafts studio, three teachers—Jiang, Kudrow, and Lanning—will give six consecutive presentations on six different subjects. Jiang will present on needlework and origami; Kudrow on pottery, stenciling, and textile making; and Lanning on woodworking. The order of their presentations will meet the following conditions: Kudrow cannot give two presentations in a row. The presentation on stenciling must be given earlier than the one on origami. The presentation on textile making must be given earlier than the one on woodworking.",
      "question": "Which one of the following could be the order of the presentations, from first to sixth?",
      "options": [
        "A) stenciling, origami, needlework, textile making, pottery, woodworking",
        "B) stenciling, origami, pottery, woodworking, needlework, textile making",
        "C) stenciling, origami, textile making, woodworking, needlework, pottery",
        "D) textile making, origami, stenciling, woodworking, needlework, pottery",
        "E) textile making, stenciling, woodworking, needlework, pottery, origami"
      ]
    },
    "answer": "C",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((Presentations 0)) (((needlework) (origami) (pottery) (stenciling) (textile_making) (woodworking))))",
        "(declare-datatypes ((Teachers 0)) (((Jiang) (Kudrow) (Lanning))))",
        "(declare-fun order (Teachers Presentations) Presentations)"
      ],
      "constraints": [
        "(forall ((t Teachers) (p Presentations) (i Int)) (=> (and (distinct (order t) (order (ite (<= i 3) (ite (distinct t Kudrow) t Kudrow) (ite (distinct t Lanning) t Kudrow) (ite (distinct t Jiang) t Lanning))) (order (ite (<= i 3) (ite (distinct t Kudrow) t Kudrow) (ite (distinct t Lanning) t Kudrow) (ite (distinct t Jiang) t Lanning))) (<= i 5)) (not (distinct (order (ite (<= i 3) (ite (distinct t Kudrow) t Kudrow) (ite (distinct t Lanning) t Kudrow) (ite (distinct t Jiang) t Lanning))) (order (ite (<= (ite (<= i 3) (ite (distinct t Kudrow) t Kudrow) (ite (distinct t Lanning) t Kudrow) (ite (distinct t Jiang) t Lanning)) 5) (ite (<= (ite (<= i 3) (ite (distinct t Kudrow) t Kudrow) (ite (distinct t Lanning) t Kudrow) (ite (distinct t Jiang) t Lanning)) 5) (ite (distinct t Kudrow) t Kudrow) (ite (distinct t Lanning) t Kudrow)) (ite (distinct t Jiang) t Lanning)))))",
        "(forall ((t Teachers)) (not (= (order t) origami)))",
        "(forall ((t Teachers)) (not (= (order t) woodworking)))"
      ],
      "options": [
        "(= (order Jiang) stenciling)",
        "(= (order (ite (distinct Kudrow Jiang) Kudrow Lanning)) origami)",
        "(= (order (ite (distinct Kudrow (ite (distinct Kudrow Jiang) Kudrow Lanning)) (ite (distinct Lanning Jiang) Kudrow Lanning) (ite (distinct Jiang Kudrow) Kudrow Lanning))) needlework)",
        "(= (order (ite (distinct Kudrow (ite (distinct Kudrow (ite (distinct Kudrow Jiang) Kudrow Lanning)) (ite (distinct Lanning Jiang) Kudrow Lanning) (ite (distinct Jiang Kudrow) Kudrow Lanning))) (ite (distinct Lanning (ite (distinct Kudrow (ite (distinct Kudrow Jiang) Kudrow Lanning)) (ite (distinct Lanning Jiang) Kudrow Lanning) (ite (distinct Jiang Kudrow) Kudrow Lanning))) (ite (distinct Jiang Kudrow) (ite (distinct Kudrow (ite (distinct Kudrow Jiang) Kudrow Lanning)) (ite (distinct Lanning Jiang) Kudrow Lanning) (ite (distinct Jiang Kudrow) Kudrow Lanning))) (ite (distinct Kudrow (ite (distinct Kudrow Jiang) Kudrow Lanning)) (ite (distinct Lanning Jiang) Kudrow Lanning) (ite (distinct Jiang Kudrow) Kudrow Lanning))))) textile_making)",
        "(= (order (ite (distinct Kudrow (ite (distinct Kudrow (ite (distinct Kudrow (ite (distinct Kudrow Jiang) Kudrow Lanning)) (ite (distinct Lanning Jiang) Kudrow Lanning) (ite (distinct Jiang Kudrow) Kudrow Lanning))) (ite (distinct Lanning (ite (distinct Kudrow (ite (distinct Kudrow Jiang) Kudrow Lanning)) (ite (distinct Lanning Jiang) Kudrow Lanning) (ite (distinct Jiang Kudrow) Kudrow Lanning))) (ite (distinct Jiang Kudrow) (ite (distinct Kudrow (ite (distinct Kudrow Jiang) Kudrow Lanning)) (ite (distinct Lanning Jiang) Kudrow Lanning) (ite (distinct Jiang Kudrow) Kudrow Lanning))) (ite (distinct Kudrow (ite (distinct Kudrow Jiang) Kudrow Lanning)) (ite (distinct Lanning Jiang) Kudrow Lanning) (ite (distinct Jiang Kudrow) Kudrow Lanning))))) woodworking)"
      ],
      "type": "sat",
      "perplexity": [
        1.0775244235992432,
        1.040771722793579
      ],
      "answer": "C",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "SyntaxError: invalid syntax. Perhaps you forgot a comma?"
    }
  },
  {
    "id": 76,
    "nl_problem": {
      "context": "As part of an open house at a crafts studio, three teachers—Jiang, Kudrow, and Lanning—will give six consecutive presentations on six different subjects. Jiang will present on needlework and origami; Kudrow on pottery, stenciling, and textile making; and Lanning on woodworking. The order of their presentations will meet the following conditions: Kudrow cannot give two presentations in a row. The presentation on stenciling must be given earlier than the one on origami. The presentation on textile making must be given earlier than the one on woodworking.",
      "question": "If textile making is presented fifth, which one of the following could be true?",
      "options": [
        "A) Needlework is presented sixth.",
        "B) Pottery is presented fourth.",
        "C) Stenciling is presented second.",
        "D) Stenciling is presented third.",
        "E) Woodworking is presented second."
      ]
    },
    "answer": "D",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((Teachers 0)) (((Jiang) (Kudrow) (Lanning))))",
        "(declare-datatypes ((Subjects 0)) (((needlework) (origami) (pottery) (stenciling) (textile_making) (woodworking))))",
        "(declare-fun presents (Teachers Subjects) Bool)",
        "(define-fun to-int ((b Bool)) Int (ite b 1 0))"
      ],
      "constraints": [
        "(= (presents Jiang needlework) true)",
        "(= (presents Jiang origami) true)",
        "(= (presents Kudrow pottery) true)",
        "(= (presents Kudrow stenciling) true)",
        "(= (presents Kudrow textile_making) true)",
        "(= (presents Lanning woodworking) true)",
        "(forall ((t1 Teachers) (t2 Teachers) (s1 Subjects) (s2 Subjects)) (=> (and (presents t1 s1) (presents t2 s2) (= t1 Kudrow) (= t2 Kudrow)) (not (= s1 s2))))",
        "(forall ((t1 Teachers) (t2 Teachers) (s1 Subjects) (s2 Subjects)) (=> (and (presents t1 s1) (presents t2 s2) (= t1 Kudrow) (= t2 Jiang) (= s1 origami) (= s2 stenciling)) false))",
        "(forall ((t1 Teachers) (t2 Teachers) (s1 Subjects) (s2 Subjects)) (=> (and (presents t1 s1) (presents t2 s2) (= t1 Kudrow) (= t2 Lanning) (= s1 woodworking) (= s2 textile_making)) false))"
      ],
      "options": [
        "(= (presents Kudrow textile_making) true)",
        "(= (presents Jiang needlework) true)",
        "(= (presents Jiang origami) false)",
        "(= (presents Kudrow pottery) false)",
        "(= (presents Kudrow stenciling) false)",
        "(= (presents Kudrow stenciling) false)",
        "(= (presents Lanning woodworking) false)",
        "(= (presents Kudrow stenciling) false)",
        "(= (presents Lanning woodworking) false)"
      ],
      "type": [
        "sat",
        "unsat",
        "unsat",
        "unsat",
        "unsat",
        "unsat",
        "unsat",
        "unsat"
      ],
      "perplexity": [
        1.083092451095581,
        1.0874502658843994
      ],
      "answer": "D",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "SyntaxError: invalid syntax"
    }
  },
  {
    "id": 77,
    "nl_problem": {
      "context": "As part of an open house at a crafts studio, three teachers—Jiang, Kudrow, and Lanning—will give six consecutive presentations on six different subjects. Jiang will present on needlework and origami; Kudrow on pottery, stenciling, and textile making; and Lanning on woodworking. The order of their presentations will meet the following conditions: Kudrow cannot give two presentations in a row. The presentation on stenciling must be given earlier than the one on origami. The presentation on textile making must be given earlier than the one on woodworking.",
      "question": "If needlework is presented first, which one of the following could be true?",
      "options": [
        "A) Origami is presented sixth.",
        "B) Pottery is presented second.",
        "C) Stenciling is presented third.",
        "D) Textile making is presented fifth.",
        "E) Woodworking is presented third."
      ]
    },
    "answer": "E",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((Teachers 0)) (((Jiang) (Kudrow) (Lanning))))",
        "(declare-datatypes ((Subjects 0)) (((needlework) (origami) (pottery) (stenciling) (textile_making) (woodworking))))",
        "(declare-fun next ((Teachers) (Int)) Teachers)",
        "(declare-fun current ((Int)) Teachers)"
      ],
      "constraints": [
        "(forall ((i Int)) (and (distinct (current i) Jiang) (= (current (+ i 1)) Jiang)))",
        "(forall ((i Int)) (and (distinct (current (+ i 2)) Jiang) (distinct (current (+ i 3)) Jiang) (distinct (current (+ i 4)) Jiang)))",
        "(forall ((i Int)) (and (distinct (current (+ i 5)) Jiang) (= (current (+ i 6)) Lanning)))",
        "(forall ((i Int)) (distinct (current i) (current (+ i 1))))",
        "(forall ((i Int)) (and (not (= (current (+ i 3)) origami)) (> i (ite (= (current i) origami) 4 0))))",
        "(forall ((i Int)) (and (not (= (current (+ i 4)) woodworking)) (> i (ite (= (current i) woodworking) 5 0))))"
      ],
      "options": [
        "(= (next 0 Jiang) Jiang)",
        "(distinct (next 1 Jiang) Kudrow)",
        "(= (next 2 Kudrow) Kudrow)",
        "(= (next 3 Kudrow) stenciling)",
        "(= (next 4 Kudrow) textile_making)",
        "(distinct (next 5 Kudrow) origami)",
        "(distinct (next 6 Kudrow) woodworking)",
        "(= (next 0 Jiang) Jiang)",
        "(distinct (next 1 Jiang) Kudrow)",
        "(= (next 2 Kudrow) Kudrow)",
        "(= (next 3 Kudrow) pottery)",
        "(= (next 4 Kudrow) textile_making)",
        "(= (next 5 Kudrow) origami)",
        "(= (next 6 Kudrow) woodworking)",
        "(= (next 0 Jiang) Jiang)",
        "(distinct (next 1 Jiang) Kudrow)",
        "(= (next 2 Jiang) Kudrow)",
        "(= (next 3 Kudrow) stenciling)",
        "(distinct (next 4 Kudrow) origami)",
        "(= (next 5 Kudrow) textile_making)",
        "(distinct (next 6 Kudrow) woodworking)",
        "(= (next 0 Jiang) Jiang)",
        "(distinct (next 1 Jiang) Kudrow)",
        "(= (next 2 Jiang) Kudrow)",
        "(= (next 3 Kudrow) pottery)",
        "(distinct (next 4 Kudrow) textile_making)",
        "(= (next 5 Kudrow) origami)",
        "(distinct (next 6 Kudrow) woodworking)",
        "(= (next 0 Jiang) Jiang)",
        "(distinct (next 1 Jiang) Kudrow)",
        "(= (next 2 Jiang) Kudrow)",
        "(= (next 3 Kudrow) stenciling)",
        "(= (next 4 Kudrow) textile_making)",
        "(= (next 5 Jiang) woodworking)",
        "(distinct (next 6 Jiang) origami)"
      ],
      "type": "unsat",
      "perplexity": [
        1.3018989562988281,
        1.0655317306518555
      ],
      "answer": "E",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "SyntaxError: invalid syntax. Perhaps you forgot a comma?"
    }
  },
  {
    "id": 78,
    "nl_problem": {
      "context": "As part of an open house at a crafts studio, three teachers—Jiang, Kudrow, and Lanning—will give six consecutive presentations on six different subjects. Jiang will present on needlework and origami; Kudrow on pottery, stenciling, and textile making; and Lanning on woodworking. The order of their presentations will meet the following conditions: Kudrow cannot give two presentations in a row. The presentation on stenciling must be given earlier than the one on origami. The presentation on textile making must be given earlier than the one on woodworking.",
      "question": "Jiang CANNOT give both",
      "options": [
        "A) the first and third presentations",
        "B) the first and fourth presentations",
        "C) the first and fifth presentations",
        "D) the second and third presentations",
        "E) the second and fourth presentations"
      ]
    },
    "answer": "B",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((Teachers 0)) (((Jiang) (Kudrow) (Lanning))))",
        "(declare-datatypes ((Subjects 0)) (((needlework) (origami) (pottery) (stenciling) (textile_making) (woodworking))))",
        "(declare-fun gives (Teachers Subjects Int) Bool)"
      ],
      "constraints": [
        "(forall ((t Int)) (=> (>= t 0) (and (gives Jiang needlework t) (gives Jiang origami t))))",
        "(forall ((t Int)) (=> (>= t 0) (and (gives Kudrow pottery t) (or (and (gives Kudrow stenciling (+ t 1)) (not (gives Kudrow stenciling t))) (gives Kudrow textile_making t) (gives Kudrow textile_making (+ t 1))))))",
        "(forall ((t Int)) (=> (>= t 0) (gives Lanning woodworking t)))",
        "(forall ((t Int)) (=> (>= t 0) (or (< t 2) (not (and (gives Kudrow (+ t 1) needlework) (gives Kudrow (+ t 1) pottery) (gives Kudrow (+ t 1) stenciling) (gives Kudrow (+ t 1) textile_making) (gives Kudrow (+ t 1) woodworking) (gives Kudrow (+ t 1) origami))))))",
        "(forall ((t Int)) (=> (>= t 0) (or (< t 2) (=> (gives Kudrow stenciling t) (< (ite (gives Jiang origami (+ t 1)) 1 0) (ite (gives Kudrow origami (+ t 1)) 1 0))))))",
        "(forall ((t Int)) (=> (>= t 0) (or (< t 2) (=> (gives Kudrow textile_making t) (< (ite (gives Lanning woodworking (+ t 1)) 1 0) (ite (gives Kudrow woodworking (+ t 1)) 1 0)))))"
      ],
      "options": [
        "(forall ((t Int)) (=> (>= t 0) (or (and (= t 0) (not (gives Jiang origami 1)) (not (gives Jiang origami 2))) (and (= t 1) (not (gives Jiang origami 0)) (not (gives Jiang origami 2))) (and (= t 2) (not (gives Jiang origami 0)) (not (gives Jiang origami 1)))))"
      ],
      "type": "unsat",
      "perplexity": [
        1.1515253782272339,
        1.0750035047531128
      ],
      "answer": "B",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "SyntaxError: invalid syntax. Perhaps you forgot a comma?"
    }
  },
  {
    "id": 79,
    "nl_problem": {
      "context": "As part of an open house at a crafts studio, three teachers—Jiang, Kudrow, and Lanning—will give six consecutive presentations on six different subjects. Jiang will present on needlework and origami; Kudrow on pottery, stenciling, and textile making; and Lanning on woodworking. The order of their presentations will meet the following conditions: Kudrow cannot give two presentations in a row. The presentation on stenciling must be given earlier than the one on origami. The presentation on textile making must be given earlier than the one on woodworking.",
      "question": "If needlework is presented sixth, which one of the following must be true?",
      "options": [
        "A) Origami is presented fourth.",
        "B) Pottery is presented fifth.",
        "C) Stenciling is presented third.",
        "D) Textile making is presented first.",
        "E) Woodworking is presented fourth."
      ]
    },
    "answer": "B"
  },
  {
    "id": 80,
    "nl_problem": {
      "context": "As part of an open house at a crafts studio, three teachers—Jiang, Kudrow, and Lanning—will give six consecutive presentations on six different subjects. Jiang will present on needlework and origami; Kudrow on pottery, stenciling, and textile making; and Lanning on woodworking. The order of their presentations will meet the following conditions: Kudrow cannot give two presentations in a row. The presentation on stenciling must be given earlier than the one on origami. The presentation on textile making must be given earlier than the one on woodworking.",
      "question": "Which one of the following CANNOT be the subject of the second presentation?",
      "options": [
        "A) needlework",
        "B) origami",
        "C) pottery",
        "D) textile making",
        "E) woodworking"
      ]
    },
    "answer": "C",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((Teachers 0)) (((Jiang) (Kudrow) (Lanning))))",
        "(declare-datatypes ((Subjects 0)) (((needlework) (origami) (pottery) (stenciling) (textile_making) (woodworking))))",
        "(declare-fun presents (Teachers Int) Subjects)"
      ],
      "constraints": [
        "(= (presents Jiang 0) needlework)",
        "(= (presents Jiang 1) origami)",
        "(or (= (presents Kudrow 2) pottery) (= (presents Kudrow 2) stenciling) (= (presents Kudrow 2) textile_making))",
        "(or (= (presents Kudrow 3) pottery) (= (presents Kudrow 3) stenciling) (= (presents Kudrow 3) textile_making))",
        "(or (= (presents Kudrow 4) pottery) (= (presents Kudrow 4) stenciling) (= (presents Kudrow 4) textile_making))",
        "(= (presents Lanning 5) woodworking)",
        "(forall ((i Int)) (or (= i 0) (distinct (presents Kudrow i) (presents Kudrow (+ i 1)))))",
        "(forall ((i Int)) (or (= i 0) (or (distinct (presents Jiang i) (presents Kudrow (+ i 1))) (distinct (presents Kudrow (+ i 1)) (presents Jiang (+ i 1))))))",
        "(forall ((i Int)) (or (= i 0) (or (distinct (presents Lanning i) (presents Kudrow (+ i 1))) (distinct (presents Kudrow (+ i 1)) (presents Lanning (+ i 1)))))"
      ],
      "options": [
        "(distinct (presents Kudrow 1) needlework)",
        "(distinct (presents Kudrow 1) origami)",
        "(distinct (presents Kudrow 1) pottery)",
        "(distinct (presents Kudrow 1) textile_making)",
        "(distinct (presents Kudrow 1) woodworking)"
      ],
      "type": "unsat",
      "perplexity": [
        1.1018279790878296,
        1.0716255903244019
      ],
      "answer": "C",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "SyntaxError: invalid syntax"
    }
  },
  {
    "id": 81,
    "nl_problem": {
      "context": "The organizer of a luncheon will select exactly five foods to be served from among exactly eight foods: two desserts—F and G; three main courses—N, O, and P; three side dishes—T, V, and W. Only F, N, and T are hot foods. The following requirements will be satisfied: At least one dessert, at least one main course, and at least one side dish must be selected. At least one hot food must be selected. If either P or W is selected, both must be selected. If G is selected, O must be selected. If N is selected, V cannot be selected.",
      "question": "Which one of the following is a list of foods that could be the foods selected?",
      "options": [
        "A) F, N, O, T, V",
        "B) F, O, P, T, W",
        "C) G, N, P, T, W",
        "D) G, O, P, T, V",
        "E) G, O, P, V, W"
      ]
    },
    "answer": "B",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((Foods 0)) (((F) (G) (N) (O) (P) (T) (V) (W))))",
        "(declare-fun selected (Foods) Bool)",
        "(define-fun to-int ((b Bool)) Int (ite b 1 0))"
      ],
      "constraints": [
        ">(+ (to-int (selected F)) (to-int (selected G)) 0)",
        ">(+ (to-int (selected N)) (to-int (selected O)) (to-int (selected P)) 0)",
        ">(+ (to-int (selected T)) (to-int (selected V)) (to-int (selected W)) 0)",
        ">(+ (to-int (selected F)) (to-int (selected N)) (to-int (selected T)) 0)",
        "(or (and (selected P) (selected W)) (not (or (selected P) (selected W))))",
        "=> (selected G) (selected O)",
        "(or (not (selected N)) (not (selected V)))"
      ],
      "options": [
        "(selected F)",
        "(selected N)",
        "(selected O)",
        "(selected T)",
        "(not (selected V))",
        "(selected F)",
        "(selected O)",
        "(selected P)",
        "(selected T)",
        "(selected W)",
        "(selected G)",
        "(selected N)",
        "(selected P)",
        "(selected T)",
        "(selected W)",
        "(selected G)",
        "(selected O)",
        "(selected P)",
        "(selected T)",
        "(selected V)",
        "(selected G)",
        "(selected O)",
        "(selected P)",
        "(selected V)",
        "(selected W)"
      ],
      "type": "sat, unsat",
      "perplexity": [
        1.0633299350738525,
        1.1196472644805908
      ],
      "answer": "B",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "SyntaxError: invalid syntax"
    }
  },
  {
    "id": 82,
    "nl_problem": {
      "context": "The organizer of a luncheon will select exactly five foods to be served from among exactly eight foods: two desserts—F and G; three main courses—N, O, and P; three side dishes—T, V, and W. Only F, N, and T are hot foods. The following requirements will be satisfied: At least one dessert, at least one main course, and at least one side dish must be selected. At least one hot food must be selected. If either P or W is selected, both must be selected. If G is selected, O must be selected. If N is selected, V cannot be selected.",
      "question": "Which one of the following is a pair of foods of which the organizer of the luncheon must select at least one?",
      "options": [
        "A) F, T",
        "B) G, O",
        "C) N, T",
        "D) O, P",
        "E) V, W"
      ]
    },
    "answer": "D",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((Foods 0)) (((F) (G) (N) (O) (P) (T) (V) (W))))",
        "(declare-fun selects (Foods) Bool)",
        "(define-fun to-int ((b Bool)) Int (ite b 1 0))"
      ],
      "constraints": [
        ">= (+ (to-int (selects F)) (to-int (selects G))) 1",
        ">= (+ (to-int (selects N)) (to-int (selects O)) (to-int (selects P))) 1",
        ">= (+ (to-int (selects T)) (to-int (selects V)) (to-int (selects W))) 1",
        ">= (+ (to-int (selects F)) (to-int (selects N)) (to-int (selects T))) 1",
        "(forall ((p Bool) (w Bool)) (=> (or p w) (= p w)))",
        "(forall ((p Bool) (w Bool)) (=> (and (selects P) (selects W)) (= p w)))",
        "(forall ((g Bool) (o Bool)) (=> (selects G) (selects O)))",
        "(forall ((n Bool) (v Bool)) (=> (selects N) (not (selects V))))"
      ],
      "options": [
        "(forall ((f Bool) (t Bool)) (= (and f t) (selects F, T)))",
        "(forall ((g Bool) (o Bool)) (= (and g o) (selects G, O)))",
        "(forall ((n Bool) (t Bool)) (= (and n t) (selects N, T)))",
        "(forall ((o Bool) (p Bool)) (= (and o p) (selects O, P)))",
        "(forall ((v Bool) (w Bool)) (= (and v w) (selects V, W)))"
      ],
      "type": "sat",
      "perplexity": [
        1.0814018249511719,
        1.0829310417175293
      ],
      "answer": "D",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "SyntaxError: invalid syntax"
    }
  },
  {
    "id": 83,
    "nl_problem": {
      "context": "The organizer of a luncheon will select exactly five foods to be served from among exactly eight foods: two desserts—F and G; three main courses—N, O, and P; three side dishes—T, V, and W. Only F, N, and T are hot foods. The following requirements will be satisfied: At least one dessert, at least one main course, and at least one side dish must be selected. At least one hot food must be selected. If either P or W is selected, both must be selected. If G is selected, O must be selected. If N is selected, V cannot be selected.",
      "question": "If O is the only main course selected, then which one of the following CANNOT be selected?",
      "options": [
        "A) F",
        "B) G",
        "C) T",
        "D) V",
        "E) W"
      ]
    },
    "answer": "E",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((Foods 0)) (((F) (G) (N) (O) (P) (T) (V) (W))))",
        "(declare-datatypes ((Requirements 0)) (((at_least_one_dessert) (at_least_one_main_course) (at_least_one_side_dish) (at_least_one_hot_food) (if_P_and_W_then_P_and_W) (if_G_then_O) (if_N_then_not_V))))",
        "(declare-fun selects (Foods Requirements) Bool)",
        "(define-fun to-int ((b Bool)) Int (ite b 1 0))"
      ],
      "constraints": [
        ">= (+ (to-int (and (selects F at_least_one_dessert))) (to-int (and (selects G at_least_one_dessert))) (to-int (and (selects N at_least_one_dessert) (and (selects O at_least_one_dessert) (and (selects P at_least_one_dessert)))) (to-int (and (selects T at_least_one_side_dish) (and (selects V at_least_one_side_dish) (and (selects W at_least_one_side_dish))))) 1)",
        ">= (+ (to-int (and (selects F at_least_one_hot_food))) (to-int (and (selects N at_least_one_hot_food))) (to-int (and (selects T at_least_one_hot_food))) 1)",
        "(forall ((r Requirements)) (=> (and (selects P r) (selects W r)) (and (selects P r) (selects W r))))",
        "(forall ((r Requirements)) (=> (selects G r) (selects O r)))",
        "(forall ((r Requirements)) (=> (selects N r) (not (selects V r))))",
        "(and (not (selects N (selects O at_least_one_main_course))) (not (selects P (selects O at_least_one_main_course))) (selects O (selects O at_least_one_main_course)))"
      ],
      "options": [
        "(not (selects G (selects O at_least_one_dessert)))",
        "(selects T (selects O at_least_one_side_dish))",
        "(selects V (selects O at_least_one_side_dish))",
        "(not (selects W (selects O at_least_one_side_dish)))"
      ],
      "type": "unsat",
      "perplexity": [
        1.1013671159744263,
        1.0711909532546997
      ],
      "answer": "E",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "SyntaxError: invalid syntax"
    }
  },
  {
    "id": 84,
    "nl_problem": {
      "context": "The organizer of a luncheon will select exactly five foods to be served from among exactly eight foods: two desserts—F and G; three main courses—N, O, and P; three side dishes—T, V, and W. Only F, N, and T are hot foods. The following requirements will be satisfied: At least one dessert, at least one main course, and at least one side dish must be selected. At least one hot food must be selected. If either P or W is selected, both must be selected. If G is selected, O must be selected. If N is selected, V cannot be selected.",
      "question": "If F is not selected, which one of the following could be true?",
      "options": [
        "A) P is the only main course selected.",
        "B) T is the only side dish selected.",
        "C) Exactly two hot foods are selected.",
        "D) Exactly three main courses are selected.",
        "E) Exactly three side dishes are selected."
      ]
    },
    "answer": "D",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((Foods 0)) (((F) (G) (N) (O) (P) (T) (V) (W))))",
        "(define-fun to-int ((b Bool)) Int (ite b 1 0))",
        "(declare-fun selected (Foods) Bool)"
      ],
      "constraints": [
        ">= (+ (to-int (selected F)) (to-int (selected G)) (to-int (selected N)) (to-int (selected O)) (to-int (selected P)) (to-int (selected T)) (to-int (selected V)) (to-int (selected W))) 3",
        ">= (+ (to-int (and (selected F) (selected F))) (to-int (and (selected N) (selected N))) (to-int (and (selected T) (selected T)))) 1",
        "=> (or (selected P) (selected W)) (and (selected P) (selected W))",
        "=> (selected G) (selected O)",
        "=> (selected N) (not (selected V))"
      ],
      "options": [
        "(not (selected F)) => (not (selected P))",
        "(not (selected F)) => (not (selected T))",
        "(not (selected F)) => (not (= (to-int (+ (to-int (selected N)) (to-int (selected T)) (to-int (selected V)))) 2))",
        "(not (selected F)) => (not (selected O))",
        "(not (selected F)) => (not (selected W))",
        "(not (selected F)) => (not (selected T))",
        "(not (selected F)) => (not (= (to-int (+ (to-int (selected N)) (to-int (selected T)) (to-int (selected V)))) 2))",
        "(not (selected F)) => (not (selected O))",
        "(not (selected F)) => (not (selected W))",
        "(not (selected F)) => (not (selected W))",
        "(not (selected F)) => (not (selected W))",
        "(not (selected F)) => (not (selected W))"
      ],
      "type": "unsat",
      "perplexity": [
        1.1350220441818237,
        1.1032040119171143
      ],
      "answer": "D",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "SyntaxError: invalid syntax"
    }
  },
  {
    "id": 85,
    "nl_problem": {
      "context": "The organizer of a luncheon will select exactly five foods to be served from among exactly eight foods: two desserts—F and G; three main courses—N, O, and P; three side dishes—T, V, and W. Only F, N, and T are hot foods. The following requirements will be satisfied: At least one dessert, at least one main course, and at least one side dish must be selected. At least one hot food must be selected. If either P or W is selected, both must be selected. If G is selected, O must be selected. If N is selected, V cannot be selected.",
      "question": "If T and V are the only side dishes selected, then which one of the following is a pair of foods each of which must be selected?",
      "options": [
        "A) F and G",
        "B) F and N",
        "C) F and P",
        "D) N and O",
        "E) O and P"
      ]
    },
    "answer": "A",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((Foods 0)) (((F) (G) (N) (O) (P) (T) (V) (W))))",
        "(declare-fun selected (Foods) Bool)",
        "(define-fun to-int ((b Bool)) Int (ite b 1 0))"
      ],
      "constraints": [
        "(>= (+ (to-int (selected F)) (to-int (selected G)) (to-int (selected N)) (to-int (selected O)) (to-int (selected P)) (to-int (selected T)) (to-int (selected V)) (to-int (selected W))) 3)",
        "(>= (+ (to-int (selected F)) (to-int (selected N)) (to-int (selected T))) 1)",
        "(=> (or (selected P) (selected W)) (and (selected P) (selected W)))",
        "(=> (selected G) (selected O))",
        "(=> (selected N) (not (selected V)))",
        "(= (+ (to-int (selected T)) (to-int (selected V))) 2)"
      ],
      "options": [
        "(= (selected F) (selected G))",
        "(= (selected F) (selected N))",
        "(= (selected F) (selected P))",
        "(= (selected N) (selected O))",
        "(= (selected O) (selected P))"
      ],
      "type": "sat",
      "perplexity": [
        1.181628704071045,
        1.1308388710021973
      ],
      "answer": "A",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "SyntaxError: invalid syntax"
    }
  },
  {
    "id": 86,
    "nl_problem": {
      "context": "A television programming director is scheduling a three-hour block of programs beginning at 1 P.M. The programs that are to fill this time block include an hour-long program called Generations and four half-hour programs: Roamin', Sundown, Terry, and Waterloo. The programs will be shown one after the other, each program shown exactly once. The schedule must meet the following constraints: Generations starts on the hour rather than the half hour. Terry starts on the half hour rather than the hour. Roamin' is shown earlier than Sundown. If Waterloo is shown earlier than Terry, it is shown immediately before Terry.",
      "question": "Which one of the following could be the order in which the programs are shown, from earliest to latest?",
      "options": [
        "A) Generations, Roamin', Waterloo, Terry, Sundown",
        "B) Roamin', Sundown, Waterloo, Terry, Generations",
        "C) Roamin', Terry, Waterloo, Generations, Sundown",
        "D) Waterloo, Roamin', Sundown, Terry, Generations",
        "E) Waterloo, Terry, Sundown, Roamin', Generations"
      ]
    },
    "answer": "B",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((Programs 0)) (((Generations) (Roamin) (Sundown) (Terry) (Waterloo))))",
        "(declare-datatypes ((TimeSlots 0)) (((one) (half))))",
        "(declare-fun schedule (Programs) TimeSlots)",
        "(define-fun to-int ((b Bool)) Int (ite b 1 0))"
      ],
      "constraints": [
        "(= (schedule Generations) one)",
        "(= (schedule Terry) half)",
        "(or (< (schedule Roamin) (schedule Sundown)) (= (schedule Roamin) (schedule Sundown)))",
        "(or (and (< (schedule Waterloo) (schedule Terry)) (= (+ (to-int (= (schedule Waterloo) one)) (to-int (= (schedule Terry) one))) 1)) (not (and (< (schedule Waterloo) (schedule Terry)) (= (+ (to-int (= (schedule Waterloo) one)) (to-int (= (schedule Terry) one))) 1))))))",
        "(= (schedule Generations) one)",
        "(= (schedule Roamin) one)",
        "(= (schedule Waterloo) half)",
        "(= (schedule Terry) half)",
        "(= (schedule Sundown) one)",
        "(= (schedule Roamin) one)",
        "(= (schedule Sundown) half)",
        "(= (schedule Waterloo) half)",
        "(= (schedule Terry) one)",
        "(= (schedule Generations) one)",
        "(= (schedule Roamin) one)",
        "(= (schedule Terry) half)",
        "(= (schedule Waterloo) one)",
        "(= (schedule Generations) half)",
        "(= (schedule Sundown) one)",
        "(= (schedule Waterloo) one)",
        "(= (schedule Roamin) one)",
        "(= (schedule Sundown) half)",
        "(= (schedule Terry) one)",
        "(= (schedule Generations) half)",
        "(= (schedule Waterloo) one)",
        "(= (schedule Terry) half)",
        "(= (schedule Sundown) one)",
        "(= (schedule Roamin) half)",
        "(= (schedule Generations) half)"
      ],
      "options": [
        "(= (schedule Generations) one)",
        "(= (schedule Roamin) one)",
        "(= (schedule Waterloo) half)",
        "(= (schedule Terry) half)",
        "(= (schedule Sundown) one)"
      ],
      "type": "sat",
      "perplexity": [
        1.1408721208572388,
        1.0846680402755737
      ],
      "answer": "B",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "SyntaxError: unmatched ')'"
    }
  },
  {
    "id": 87,
    "nl_problem": {
      "context": "A television programming director is scheduling a three-hour block of programs beginning at 1 P.M. The programs that are to fill this time block include an hour-long program called Generations and four half-hour programs: Roamin', Sundown, Terry, and Waterloo. The programs will be shown one after the other, each program shown exactly once. The schedule must meet the following constraints: Generations starts on the hour rather than the half hour. Terry starts on the half hour rather than the hour. Roamin' is shown earlier than Sundown. If Waterloo is shown earlier than Terry, it is shown immediately before Terry.",
      "question": "If Waterloo is the first program, then how many orders are there in which the remaining programs could be shown?",
      "options": [
        "A) one",
        "B) two",
        "C) three",
        "D) four",
        "E) five"
      ]
    },
    "answer": "B",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((Programs 0)) (((Generations) (Roamin) (Sundown) (Terry) (Waterloo))))",
        "(declare-datatypes ((Times 0)) (((hour_1pm) (hour_2pm) (hour_3pm))))",
        "(declare-fun schedule (Programs Times) Program)"
      ],
      "constraints": [
        "(forall ((t Times)) (not (and (schedule Generations t) (= t hour_2pm))))",
        "(forall ((t Times)) (not (and (schedule Terry t) (= t hour_2pm))))",
        "(forall ((t Times)) (not (and (schedule Roamin t) (schedule Sundown t) (= t hour_2pm))))",
        "(forall ((t Times)) (=> (and (schedule Waterloo t) (schedule Terry t) (< t hour_2pm)) (= t hour_1pm)))",
        "(= (schedule Waterloo hour_1pm) Waterloo)"
      ],
      "options": [
        "(not (schedule Terry hour_2pm))",
        "(not (schedule Sundown hour_2pm))",
        "(not (schedule Roamin hour_2pm))",
        "(not (schedule Generations hour_2pm))",
        "(= (schedule Terry hour_2pm) Terry)",
        "(= (schedule Roamin hour_2pm) Roamin)",
        "(= (schedule Sundown hour_2pm) Sundown)",
        "(= (schedule Generations hour_2pm) Generations)"
      ],
      "type": "unsat",
      "perplexity": [
        1.2244819402694702,
        1.1245996952056885
      ],
      "answer": "B",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "SyntaxError: invalid syntax. Perhaps you forgot a comma?"
    }
  },
  {
    "id": 88,
    "nl_problem": {
      "context": "A television programming director is scheduling a three-hour block of programs beginning at 1 P.M. The programs that are to fill this time block include an hour-long program called Generations and four half-hour programs: Roamin', Sundown, Terry, and Waterloo. The programs will be shown one after the other, each program shown exactly once. The schedule must meet the following constraints: Generations starts on the hour rather than the half hour. Terry starts on the half hour rather than the hour. Roamin' is shown earlier than Sundown. If Waterloo is shown earlier than Terry, it is shown immediately before Terry.",
      "question": "If Roamin' is the second program, then each of the following could be true EXCEPT:",
      "options": [
        "A) Sundown is the third program.",
        "B) Sundown is the fourth program.",
        "C) Terry is the fifth program.",
        "D) Waterloo is the third program.",
        "E) Waterloo is the fifth program."
      ]
    },
    "answer": "D",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((Programs 0)) (((Generations) (Roamin) (Sundown) (Terry) (Waterloo))))",
        "(declare-datatypes ((TimeSlots 0)) (((hour1) (half_hour1) (hour2) (half_hour2) (hour3))))",
        "(declare-fun shown (Programs TimeSlots) Bool)"
      ],
      "constraints": [
        "(forall ((t TimeSlots)) (or (and (not (shown Generations half_hour1)) (shown Generations hour1)) (and (shown Generations half_hour1) (not (shown Generations hour1)))))",
        "(forall ((t TimeSlots)) (or (and (not (shown Terry half_hour1)) (shown Terry hour1)) (and (shown Terry half_hour1) (not (shown Terry hour1)))))",
        "(forall ((t TimeSlots)) (or (and (shown Roamin hour1) (not (shown Sundown hour1)) (not (shown Sundown half_hour1))) (and (shown Sundown hour1) (not (shown Roamin hour1)) (not (shown Roamin half_hour1))) (and (shown Roamin half_hour1) (not (shown Sundown half_hour1))) (and (shown Sundown half_hour1) (not (shown Roamin half_hour1)))))",
        "(forall ((t TimeSlots)) (or (and (shown Waterloo half_hour1) (shown Terry hour1)) (and (shown Waterloo hour1) (not (shown Terry hour1))) (and (not (shown Waterloo half_hour1)) (not (shown Waterloo hour1)))))",
        "(= (or (and (shown Roamin half_hour1) (not (shown Roamin hour1))) (not (shown Roamin half_hour1))) true)"
      ],
      "options": [
        "(not (forall ((t TimeSlots)) (or (and (shown Sundown hour1) (not (shown Sundown half_hour1))) (and (shown Roamin hour1) (not (shown Roamin half_hour1))))))",
        "(not (forall ((t TimeSlots)) (or (and (shown Sundown hour1) (not (shown Sundown half_hour1))) (and (shown Roamin hour1) (not (shown Roamin half_hour1)) (and (shown Terry hour1) (not (shown Terry half_hour1)))))))",
        "(not (forall ((t TimeSlots)) (or (and (shown Sundown hour1) (not (shown Sundown half_hour1))) (and (shown Roamin hour1) (not (shown Roamin half_hour1)) (and (shown Terry half_hour1) (not (shown Terry hour1)))))))",
        "(not (forall ((t TimeSlots)) (or (and (shown Sundown hour1) (not (shown Sundown half_hour1))) (and (shown Roamin hour1) (not (shown Roamin half_hour1)) (and (shown Terry half_hour1) (not (shown Terry hour1)) (and (shown Waterloo hour1) (not (shown Waterloo half_hour1))))))))",
        "(not (forall ((t TimeSlots)) (or (and (shown Sundown hour1) (not (shown Sundown half_hour1))) (and (shown Roamin hour1) (not (shown Roamin half_hour1)) (and (shown Terry half_hour1) (not (shown Terry hour1)) (and (shown Waterloo half_hour1) (shown Terry hour1)))))"
      ],
      "type": [
        "unsat",
        "unsat",
        "unsat",
        "unsat",
        "sat"
      ],
      "perplexity": [
        1.109923243522644,
        1.0540956258773804
      ],
      "answer": "D",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "SyntaxError: invalid syntax. Perhaps you forgot a comma?"
    }
  },
  {
    "id": 89,
    "nl_problem": {
      "context": "A television programming director is scheduling a three-hour block of programs beginning at 1 P.M. The programs that are to fill this time block include an hour-long program called Generations and four half-hour programs: Roamin', Sundown, Terry, and Waterloo. The programs will be shown one after the other, each program shown exactly once. The schedule must meet the following constraints: Generations starts on the hour rather than the half hour. Terry starts on the half hour rather than the hour. Roamin' is shown earlier than Sundown. If Waterloo is shown earlier than Terry, it is shown immediately before Terry.",
      "question": "If Sundown is the third program, then which one of the following must be true?",
      "options": [
        "A) Generations is the first program.",
        "B) Roamin' is the first program.",
        "C) Roamin' is the second program.",
        "D) Terry is the fifth program.",
        "E) Waterloo is the fourth program."
      ]
    },
    "answer": "E",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((Programs 0)) (((Generations) (Roamin') (Sundown) (Terry) (Waterloo))))",
        "(declare-fun starts (Programs) Int)"
      ],
      "constraints": [
        ">= (starts Generations) 0",
        "(even (starts Terry))",
        "<= (starts Roamin') (starts Sundown)",
        "(forall ((p Program)) (=> (and (<= (starts Waterloo) (starts Terry)) (not (= (starts Waterloo) (starts Terry)))) (= (+ (starts Waterloo) 1) (starts Terry))))"
      ],
      "options": [
        "(not (= (starts Generations) 0))",
        "(not (= (starts Roamin') 0))",
        "(not (= (starts Roamin') 1))",
        "(not (= (starts Terry) 4))",
        "(not (= (starts Waterloo) 3))"
      ],
      "type": "unsat",
      "perplexity": [
        1.1835689544677734,
        1.2004783153533936
      ],
      "answer": "E",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "SyntaxError: unterminated string literal (detected at line 10)"
    }
  },
  {
    "id": 90,
    "nl_problem": {
      "context": "A television programming director is scheduling a three-hour block of programs beginning at 1 P.M. The programs that are to fill this time block include an hour-long program called Generations and four half-hour programs: Roamin', Sundown, Terry, and Waterloo. The programs will be shown one after the other, each program shown exactly once. The schedule must meet the following constraints: Generations starts on the hour rather than the half hour. Terry starts on the half hour rather than the hour. Roamin' is shown earlier than Sundown. If Waterloo is shown earlier than Terry, it is shown immediately before Terry.",
      "question": "If Generations is the third program, then which one of the following could be true?",
      "options": [
        "A) Roamin' is the second program.",
        "B) Roamin' is the fifth program.",
        "C) Sundown is the fourth program.",
        "D) Terry is the fourth program.",
        "E) Waterloo is the second program."
      ]
    },
    "answer": "C",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((Time 0)) (((1pm) (1h30m) (2h) (2h30m) (3h))))",
        "(declare-datatypes ((Programs 0)) (((Generations) (Roamin) (Sundown) (Terry) (Waterloo))))",
        "(declare-fun starts (Time) Programs)",
        "(define-fun to-int ((b Bool)) Int (ite b 1 0))"
      ],
      "constraints": [
        "(or (= (starts 1pm) Generations) (= (starts 2h) Generations) (= (starts 3h) Generations))",
        "(or (= (starts 1h30m) Terry) (= (starts 2h30m) Terry))",
        "(forall ((t Time)) (=> (< 1pm t) (or (< (starts t) Sundown) (and (= (starts t) Sundown) (or (= (starts 1pm) Roamin) (= (starts 2h) Roamin))))))",
        "(forall ((t Time)) (=> (< (starts 1h30m) t) (=> (< (starts t) (starts 1h30m)) (= (starts t) Waterloo))))",
        "(not (= (starts 2h) Generations))",
        "(= (starts 2h) Terry)",
        "(not (= (starts 1h30m) Roamin))",
        "(not (= (starts 2h30m) Sundown))",
        "(not (= (starts 1pm) Waterloo))",
        "(or (= (starts 2h) Roamin) (= (starts 3h) Roamin))"
      ],
      "options": [
        "(not (= (starts 1h30m) Sundown))",
        "(= (starts 2h30m) Sundown)"
      ],
      "type": "sat",
      "perplexity": [
        1.1303545236587524,
        1.1088844537734985
      ],
      "answer": "C",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "SyntaxError: invalid decimal literal"
    }
  },
  {
    "id": 91,
    "nl_problem": {
      "context": "A television programming director is scheduling a three-hour block of programs beginning at 1 P.M. The programs that are to fill this time block include an hour-long program called Generations and four half-hour programs: Roamin', Sundown, Terry, and Waterloo. The programs will be shown one after the other, each program shown exactly once. The schedule must meet the following constraints: Generations starts on the hour rather than the half hour. Terry starts on the half hour rather than the hour. Roamin' is shown earlier than Sundown. If Waterloo is shown earlier than Terry, it is shown immediately before Terry.",
      "question": "Which one of the following CANNOT be true?",
      "options": [
        "A) Sundown is shown immediately before Generations.",
        "B) Waterloo is shown immediately before Roamin'.",
        "C) Generations is shown immediately before Sundown.",
        "D) Roamin' is shown immediately before Terry.",
        "E) Terry is shown immediately before Waterloo."
      ]
    },
    "answer": "B",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((Programs 0)) (((Roamin') (Sundown) (Terry) (Generations) (Waterloo))))",
        "(declare-datatypes ((Times 0)) (((hour) (half_hour))))",
        "(declare-fun shown (Programs Times) Bool)",
        "(define-fun to-int ((b Bool)) Int (ite b 1 0))"
      ],
      "constraints": [
        "(forall ((p Program)) (distinct (shown p hour) (shown p half_hour)))",
        "(not (shown Generations half_hour))",
        "(not (shown Terry hour))",
        "(or (and (shown Roamin' hour) (not (shown Sundown hour))) (and (not (shown Roamin' hour)) (shown Sundown hour)))",
        "(or (not (shown Waterloo hour)) (not (shown Terry half_hour)) (and (shown Waterloo half_hour) (not (shown Roamin' half_hour))))"
      ],
      "options": [
        "(= (shown Sundown hour) (shown Generations half_hour))",
        "(= (shown Waterloo half_hour) (shown Roamin' hour))",
        "(= (shown Generations hour) (shown Sundown half_hour))",
        "(= (shown Roamin' half_hour) (shown Terry hour))",
        "(= (shown Terry half_hour) (shown Waterloo hour))"
      ],
      "type": "unknown",
      "perplexity": [
        1.2206857204437256,
        1.130717396736145
      ],
      "answer": "B",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "SyntaxError: unmatched ')'"
    }
  },
  {
    "id": 92,
    "nl_problem": {
      "context": "A television programming director is scheduling a three-hour block of programs beginning at 1 P.M. The programs that are to fill this time block include an hour-long program called Generations and four half-hour programs: Roamin', Sundown, Terry, and Waterloo. The programs will be shown one after the other, each program shown exactly once. The schedule must meet the following constraints: Generations starts on the hour rather than the half hour. Terry starts on the half hour rather than the hour. Roamin' is shown earlier than Sundown. If Waterloo is shown earlier than Terry, it is shown immediately before Terry.",
      "question": "Which one of the following, if substituted for the constraint that Generations starts on the hour rather than the half hour, would have the same effect in determining the order in which the programs are shown?",
      "options": [
        "A) Generations is not shown immediately before Terry.",
        "B) Generations is either the first program or the fifth.",
        "C) Generations is neither the second program nor the fourth.",
        "D) If Generations is shown third, then Roamin' is shown first.",
        "E) If Generations is not shown first, then it is shown later than Terry."
      ]
    },
    "answer": "C",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((Programs 0)) (((Generations) (Roamin) (Sundown) (Terry) (Waterloo))))",
        "(declare-fun shown ((Programs) (Int)) Bool)",
        "(define-fun to-int ((b Bool)) Int (ite b 1 0))"
      ],
      "constraints": [
        "(forall ((t Int)) (not (= (shown Generations t) (= t 1))))",
        "(forall ((t Int)) (not (= (shown Terry t) (= t 0))))",
        "(forall ((t1 Int) (t2 Int)) (=> (and (< t1 t2) (shown Roamin t1) (shown Sundown t2)) t1))",
        "(forall ((t1 Int) (t2 Int)) (=> (and (< t1 t2) (shown Waterloo t1) (shown Terry t2)) (= t1 (ite (< t1 1) (+ 1 t1) t2))))"
      ],
      "options": [
        "(forall ((t Int)) (not (or (= (shown Generations t) (= t 1)) (= (shown Generations t) (= t 0)))))",
        "(forall ((t Int)) (or (or (= t 1) (= t 5)) (not (= (shown Generations t) (= t 0)))))",
        "(forall ((t Int)) (not (or (or (= t 1) (= t 4)) (= (shown Generations t) (= t 0)))))",
        "(forall ((t1 Int)) (=> (and (= t1 3) (= (shown Generations t1) true)) (= (shown Roamin 0) true)))",
        "(forall ((t1 Int)) (=> (and (not (= t1 1)) (and (= (shown Generations t1) true) (< t1 1))) (> t1 1)))"
      ],
      "type": "sat",
      "perplexity": [
        1.2005447149276733,
        1.0801674127578735
      ],
      "answer": "C",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "SyntaxError: invalid syntax. Perhaps you forgot a comma?"
    }
  },
  {
    "id": 93,
    "nl_problem": {
      "context": "Five students—Manolo, Nadia, Owen, Peng, and Rana—are each to deliver exactly one speech. Speeches are on exactly one of two topics—friendship and liberty. Each student has only one major: two major in geology, two in history, and one in journalism. The following conditions must apply: Exactly two of the students speak on friendship. A geology major and a history major speak on friendship. Manolo speaks on friendship. Rana speaks on liberty. Neither Peng nor Rana is a geology major. Nadia is a geology major.",
      "question": "Which one of the following could be a list of the majors of Manolo, Nadia, Owen, Peng, and Rana, respectively?",
      "options": [
        "A) geology, geology, journalism, journalism, history",
        "B) geology, geology, history, history, history",
        "C) history, geology, geology, journalism, history",
        "D) history, geology, journalism, geology, history",
        "E) history, history, geology, journalism, history"
      ]
    },
    "answer": "C",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((Students 0)) (((Manolo) (Nadia) (Owen) (Peng) (Rana))))",
        "(declare-datatypes ((Majors 0)) (((geology) (history) (journalism))))",
        "(declare-datatypes ((Speeches 0)) (((friendship) (liberty))))",
        "(declare-fun delivers (Students Speeches) Bool)",
        "(declare-fun majors (Students Majors) Bool)",
        "(define-fun to-int ((b Bool)) Int (ite b 1 0))"
      ],
      "constraints": [
        "(= (+ (to-int (delivers Manolo friendship)) (to-int (delivers Nadia friendship)) (to-int (delivers Owen friendship)) (to-int (delivers Peng friendship)) (to-int (delivers Rana friendship))) 2)",
        "(or (= (and (majors ?x geology) (majors ?x friendship)) true) (= (and (majors ?x history) (majors ?x friendship)) true))",
        "(delivers Manolo friendship)",
        "(delivers Rana liberty)",
        "(and (not (majors Peng geology)) (not (majors Rana geology)))",
        "(majors Nadia geology)"
      ],
      "options": [
        "(majors Manolo history)",
        "(majors Nadia geology)",
        "(majors Owen journalism)",
        "(majors Peng geology)",
        "(majors Rana history)"
      ],
      "type": "unsat",
      "perplexity": [
        1.1577610969543457,
        1.0998094081878662
      ],
      "answer": "C",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "SyntaxError: invalid syntax"
    }
  },
  {
    "id": 94,
    "nl_problem": {
      "context": "Five students—Manolo, Nadia, Owen, Peng, and Rana—are each to deliver exactly one speech. Speeches are on exactly one of two topics—friendship and liberty. Each student has only one major: two major in geology, two in history, and one in journalism. The following conditions must apply: Exactly two of the students speak on friendship. A geology major and a history major speak on friendship. Manolo speaks on friendship. Rana speaks on liberty. Neither Peng nor Rana is a geology major. Nadia is a geology major.",
      "question": "If Peng speaks on friendship, then which one of the following could be true?",
      "options": [
        "A) Manolo is a history major.",
        "B) Nadia speaks on friendship.",
        "C) Owen speaks on friendship.",
        "D) Owen is a journalism major.",
        "E) Peng is a journalism major."
      ]
    },
    "answer": "D",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((Students 0)) (((Manolo) (Nadia) (Owen) (Peng) (Rana))))",
        "(declare-datatypes ((Speeches 0)) (((friendship) (liberty))))",
        "(declare-fun speaks (Students Speeches) Bool)",
        "(declare-fun major (Students) String)"
      ],
      "constraints": [
        "(= (+ (ite (speaks Manolo friendship) 1 0) (ite (speaks Nadia friendship) 1 0) (ite (speaks Owen friendship) 1 0) (ite (speaks Peng friendship) 1 0) (ite (speaks Rana friendship) 1 0)) 2)",
        "(or (and (is-geology-major? Manolo) (speaks Manolo friendship)) (and (is-geology-major? Nadia) (speaks Nadia friendship)) (and (is-history-major? Manolo) (speaks Manolo friendship)) (and (is-history-major? Nadia) (speaks Nadia friendship)))",
        "(speaks Manolo friendship)",
        "(not (speaks Rana friendship))",
        "(not (and (is-geology-major? Peng) (ite (speaks Peng friendship) true false)))",
        "(not (and (is-geology-major? Rana) (ite (speaks Rana friendship) true false)))",
        "(is-geology-major? Nadia)"
      ],
      "options": [
        "(speaks Peng friendship)",
        "(is-history-major? Manolo)",
        "(speaks Peng friendship) (speaks Nadia friendship)",
        "(speaks Peng friendship)",
        "(is-journalism-major? Owen)",
        "(speaks Peng friendship)",
        "(is-journalism-major? Peng)"
      ],
      "type": "unsat",
      "perplexity": [
        1.1217607259750366,
        1.1173895597457886
      ],
      "answer": "D",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "SyntaxError: invalid syntax"
    }
  },
  {
    "id": 95,
    "nl_problem": {
      "context": "Five students—Manolo, Nadia, Owen, Peng, and Rana—are each to deliver exactly one speech. Speeches are on exactly one of two topics—friendship and liberty. Each student has only one major: two major in geology, two in history, and one in journalism. The following conditions must apply: Exactly two of the students speak on friendship. A geology major and a history major speak on friendship. Manolo speaks on friendship. Rana speaks on liberty. Neither Peng nor Rana is a geology major. Nadia is a geology major.",
      "question": "If Owen is a geology major who speaks on friendship, then which one of the following must be true?",
      "options": [
        "A) Manolo is a history major.",
        "B) Nadia speaks on friendship.",
        "C) Peng speaks on friendship.",
        "D) Peng is a history major.",
        "E) Rana is a journalism major."
      ]
    },
    "answer": "A",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((Students 0)) (((Manolo) (Nadia) (Owen) (Peng) (Rana))))",
        "(declare-datatypes ((Speeches 0)) (((friendship) (liberty))))",
        "(declare-datatypes ((Majors 0)) (((geology) (history) (journalism))))",
        "(declare-fun speaks (Students Speeches) Bool)",
        "(define-fun to-int ((b Bool)) Int (ite b 1 0))",
        "(declare-fun major (Students Majors) Bool)"
      ],
      "constraints": [
        "(= (+ (to-int (speaks Manolo friendship)) (to-int (speaks Nadia friendship)) (to-int (speaks Owen friendship)) (to-int (speaks Peng friendship)) (to-int (speaks Rana friendship))) 2)",
        "(exists ((g Students) (h Students)) (and (major g geology) (major h history) (speaks g friendship) (speaks h friendship) (distinct g h)))",
        "(speaks Manolo friendship)",
        "(speaks Rana liberty)",
        "(forall ((m Majors)) (not (and (major Peng m) (= m geology))) (not (and (major Rana m) (= m geology))))",
        "(major Nadia geology)"
      ],
      "options": [
        "(speaks Owen friendship)",
        "(not (major Owen history))",
        "(or (= (major Manolo history) true) (= (major Peng history) true))",
        "(speaks Owen friendship)",
        "(not (major Owen history))",
        "(not (or (= (major Manolo history) true) (= (major Peng history) true)))",
        "(speaks Owen friendship)",
        "(not (major Owen history))",
        "(major Manolo history)",
        "(speaks Owen friendship)",
        "(not (major Owen history))",
        "(speaks Nadia friendship)",
        "(speaks Owen friendship)",
        "(not (major Owen history))",
        "(speaks Peng friendship)",
        "(speaks Owen friendship)",
        "(not (major Owen history))",
        "(major Peng history)",
        "(speaks Owen friendship)",
        "(not (major Owen history))",
        "(major Rana journalism)"
      ],
      "type": "sat",
      "perplexity": [
        1.1180799007415771,
        1.0720512866973877
      ],
      "answer": "A",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "SyntaxError: invalid syntax"
    }
  },
  {
    "id": 96,
    "nl_problem": {
      "context": "Five students—Manolo, Nadia, Owen, Peng, and Rana—are each to deliver exactly one speech. Speeches are on exactly one of two topics—friendship and liberty. Each student has only one major: two major in geology, two in history, and one in journalism. The following conditions must apply: Exactly two of the students speak on friendship. A geology major and a history major speak on friendship. Manolo speaks on friendship. Rana speaks on liberty. Neither Peng nor Rana is a geology major. Nadia is a geology major.",
      "question": "If Nadia speaks on friendship, then which one of the following must be false?",
      "options": [
        "A) Manolo is a geology major.",
        "B) Manolo is a history major.",
        "C) Owen is a geology major.",
        "D) Peng is a history major.",
        "E) Rana is a history major."
      ]
    },
    "answer": "A",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((Students 0)) (((Manolo) (Nadia) (Owen) (Peng) (Rana))))",
        "(declare-datatypes ((Speeches 0)) (((friendship) (liberty))))",
        "(declare-datatypes ((Majors 0)) (((geology) (history) (journalism))))",
        "(declare-fun speaks (Students Speeches) Bool)",
        "(declare-fun major (Students Majors) Bool)",
        "(define-fun to-int ((b Bool)) Int (ite b 1 0))"
      ],
      "constraints": [
        "(and (= (+ (to-int (speaks Manolo friendship)) (to-int (speaks Nadia friendship)) (to-int (speaks Owen friendship)) (to-int (speaks Peng friendship)) (to-int (speaks Rana friendship))) 2) (distinct Manolo Nadia) (distinct Nadia Owen) (distinct Owen Peng) (distinct Peng Rana))",
        "(or (and (= (major Manolo geology) true) (= (major Nadia geology) true)) (and (= (major Nadia geology) true) (= (major Owen geology) true)) (and (= (major Owen geology) true) (= (major Peng geology) true)) (and (= (major Peng geology) true) (= (major Rana geology) true)) (and (= (major Nadia history) true) (= (major Owen history) true)) (and (= (major Owen history) true) (= (major Peng history) true)) (and (= (major Peng history) true) (= (major Rana history) true)) (and (= (major Nadia history) true) (= (major Peng history) true)) (and (= (major Manolo history) true) (= (major Nadia history) true)))",
        "(speaks Manolo friendship)",
        "(speaks Rana liberty)",
        "(or (not (major Peng geology)) (not (major Rana geology)))",
        "(major Nadia geology)"
      ],
      "options": [
        "(major Manolo geology)",
        "(not (speaks Manolo history))",
        "(not (speaks Manolo journalism))",
        "(major Manolo geology)",
        "(not (speaks Manolo history))",
        "(speaks Manolo journalism)",
        "(major Manolo geology)",
        "(speaks Manolo history)",
        "(not (speaks Manolo journalism))",
        "(major Manolo geology)",
        "(speaks Manolo history)",
        "(speaks Manolo journalism)",
        "(not (major Manolo geology))",
        "(not (speaks Manolo history))",
        "(not (speaks Manolo journalism))",
        "(not (major Manolo geology))",
        "(not (speaks Manolo history))",
        "(speaks Manolo journalism)",
        "(not (major Manolo geology))",
        "(speaks Manolo history)",
        "(not (speaks Manolo journalism))"
      ],
      "type": [
        "sat",
        "unsat",
        "unsat",
        "unsat",
        "unsat",
        "unsat",
        "unsat",
        "unsat",
        "unsat",
        "unsat",
        "unsat",
        "unsat",
        "unsat",
        "unsat",
        "unsat",
        "unsat",
        "unsat",
        "unsat",
        "unsat"
      ],
      "perplexity": [
        1.0917279720306396,
        1.0549136400222778
      ],
      "answer": "A",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "SyntaxError: invalid syntax"
    }
  },
  {
    "id": 97,
    "nl_problem": {
      "context": "Five students—Manolo, Nadia, Owen, Peng, and Rana—are each to deliver exactly one speech. Speeches are on exactly one of two topics—friendship and liberty. Each student has only one major: two major in geology, two in history, and one in journalism. The following conditions must apply: Exactly two of the students speak on friendship. A geology major and a history major speak on friendship. Manolo speaks on friendship. Rana speaks on liberty. Neither Peng nor Rana is a geology major. Nadia is a geology major.",
      "question": "Rana must be a journalism major if which one of the following is true?",
      "options": [
        "A) Manolo is a geology major and Peng is a history major.",
        "B) Owen is a geology major and Manolo is a history major.",
        "C) Owen is a geology major and Peng is a history major.",
        "D) Both Manolo and Nadia speak on friendship.",
        "E) Both Manolo and Peng speak on friendship."
      ]
    },
    "answer": "C",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((Students 0)) (((Manolo) (Nadia) (Owen) (Peng) (Rana))))",
        "(declare-datatypes ((Speeches 0)) (((friendship) (liberty))))",
        "(declare-datatypes ((Majors 0)) (((geology) (history) (journalism))))",
        "(declare-fun speaks (Students Speeches) Bool)",
        "(declare-fun major (Students) Majors)",
        "(define-fun to-int ((b Bool)) Int (ite b 1 0))"
      ],
      "constraints": [
        "(and (= (+ (to-int (speaks Manolo friendship)) (to-int (speaks Nadia friendship)) (to-int (speaks Owen friendship)) (to-int (speaks Peng friendship)) (to-int (speaks Rana friendship))) 2) (distinct Manolo Nadia Owen Peng Rana))",
        "(exists ((m Majors)) (and (major Manolo m) (major Nadia (if (not (= m geology)) geology history)) (speaks Manolo friendship)))",
        "(speaks Manolo friendship)",
        "(speaks Rana liberty)",
        "(not (and (major Peng geology) (major Rana geology)))",
        "(= (major Nadia geology) true)"
      ],
      "options": [
        "(and (= (major Manolo geology) true) (= (major Peng history) true))",
        "(not (= (major Rana journalism) true))",
        "(and (= (major Owen geology) true) (= (major Manolo history) true))",
        "(not (= (major Rana journalism) true))",
        "(and (= (major Owen geology) true) (= (major Peng history) true))",
        "(not (= (major Rana journalism) true))",
        "(and (= (speaks Manolo friendship) true) (= (speaks Nadia friendship) true))",
        "(= (major Rana journalism) true)",
        "(and (= (speaks Manolo friendship) true) (= (speaks Peng friendship) true))",
        "(= (major Rana journalism) true)"
      ],
      "type": "unsat",
      "perplexity": [
        1.1309969425201416,
        1.0782113075256348
      ],
      "answer": "C",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "SyntaxError: invalid syntax"
    }
  },
  {
    "id": 98,
    "nl_problem": {
      "context": "Each of exactly seven professors—Powell, Shihab, Taylor, Vaughan, Wood, Young, and Zabel—gives exactly one guest lecture in the literary theory course. The lectures are ordered from first through seventh, and their order must conform to the following: Powell lectures before Wood. Taylor lectures before Shihab. Vaughan lectures before Zabel. Shihab is no later than third. Young is not seventh. Powell lectures first if, but only if, Young lectures before Vaughan.",
      "question": "Which one of the following could be the order in which the professors lecture, from first to last?",
      "options": [
        "A) Powell, Young, Taylor, Shihab, Vaughan, Zabel, Wood",
        "B) Taylor, Powell, Shihab, Wood, Vaughan, Young, Zabel",
        "C) Taylor, Vaughan, Shihab, Wood, Powell, Young, Zabel",
        "D) Vaughan, Taylor, Shihab, Powell, Wood, Zabel, Young",
        "E) Young, Taylor, Shihab, Powell, Vaughan, Zabel, Wood"
      ]
    },
    "answer": "B",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((Professors 0)) (((Powell) (Shihab) (Taylor) (Vaughan) (Wood) (Young) (Zabel))))",
        "(declare-datatypes ((Lectures 0)) (((1) (2) (3) (4) (5) (6) (7))))",
        "(declare-fun lectures (Professors Lectures) Bool)",
        "(define-fun to-int ((b Bool)) Int (ite b 1 0))"
      ],
      "constraints": [
        "(forall ((l Lectures)) (=> (lectures Powell l) (or (= l 1) (or (= l 2) (or (= l 3) (or (= l 4) (or (= l 5) (or (= l 6) (= l 7))))))))))",
        "(forall ((l Lectures)) (=> (lectures Taylor l) (or (= l 1) (or (= l 2) (or (= l 3) (or (= l 4) (or (= l 5) (or (= l 6) (= l 7)))))))))",
        "(forall ((l Lectures)) (=> (lectures Vaughan l) (or (= l 1) (or (= l 2) (or (= l 3) (or (= l 4) (or (= l 5) (or (= l 6) (= l 7)))))))))",
        "(forall ((l Lectures)) (=> (lectures Shihab l) (or (= l 1) (or (= l 2) (or (= l 3) (not (>= l 4)))))))",
        "(forall ((l Lectures)) (not (and (lectures Young l) (= l 7))))",
        "(forall ((l Lectures)) (=> (and (lectures Young (ite (lectures Young l) l 1)) (lectures Vaughan (ite (lectures Young l) l 1))) (lectures Powell l)))"
      ],
      "options": [
        "(forall ((l Lectures)) (= (lectures Powell l) (and (or (= l 1) (or (= l 2) (or (= l 3) (or (= l 4) (or (= l 5) (or (= l 6) (= l 7))))))) (or (= l 2) (or (= l 3) (or (= l 4) (or (= l 5) (or (= l 6) (= l 7)))))) (or (= l 3) (or (= l 4) (or (= l 5) (or (= l 6) (= l 7)))) (or (= l 4) (or (= l 5) (or (= l 6) (= l 7)))) (or (= l 5) (or (= l 6) (= l 7))) (or (= l 6) (= l 7)) (not (= l 7))))))",
        "(assert (lectures Young (ite (lectures Young (ite (lectures Young l) l 1)) l 1)))",
        "(assert (lectures Vaughan (ite (lectures Young (ite (lectures Young l) l 1)) l 1)))",
        "(forall ((l Lectures)) (= (lectures Taylor l) (and (or (= l 1) (or (= l 2) (or (= l 3) (or (= l 4) (or (= l 5) (or (= l 6) (= l 7))))))) (or (= l 2) (or (= l 3) (or (= l 4) (or (= l 5) (or (= l 6) (= l 7))))) (or (= l 3) (or (= l 4) (or (= l 5) (or (= l 6) (= l 7))))) (or (= l 4) (or (= l 5) (or (= l 6) (= l 7)))) (or (= l 5) (or (= l 6) (= l 7))) (or (= l 6) (= l 7)) (not (= l 7))))))",
        "(assert (lectures Powell (ite (lectures Young (ite (lectures Young l) l 1)) l 1)))",
        "(forall ((l Lectures)) (= (lectures Shihab l) (and (or (= l 1) (or (= l 2) (or (= l 3) (not (>= l 4)))))) (or (= l 2) (or (= l 3) (not (>= l 4)))) (or (= l 3) (not (>= l 4))) (not (>= l 4)))))",
        "(forall ((l Lectures)) (= (lectures Young l) (ite (lectures Young l) l 1)))",
        "(assert (lectures Powell (ite (lectures Young l) l 1)))"
      ],
      "type": "unsat",
      "perplexity": [
        1.169251799583435,
        1.0492533445358276
      ],
      "answer": "B",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "SyntaxError: unmatched ')'"
    }
  },
  {
    "id": 99,
    "nl_problem": {
      "context": "Each of exactly seven professors—Powell, Shihab, Taylor, Vaughan, Wood, Young, and Zabel—gives exactly one guest lecture in the literary theory course. The lectures are ordered from first through seventh, and their order must conform to the following: Powell lectures before Wood. Taylor lectures before Shihab. Vaughan lectures before Zabel. Shihab is no later than third. Young is not seventh. Powell lectures first if, but only if, Young lectures before Vaughan.",
      "question": "Which one of the following could lecture first?",
      "options": [
        "A) Shihab",
        "B) Vaughan",
        "C) Wood",
        "D) Young",
        "E) Zabel"
      ]
    },
    "answer": "B",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((Professors 0)) (((Powell) (Shihab) (Taylor) (Vaughan) (Wood) (Young) (Zabel))))",
        "(declare-datatypes ((Lectures 0)) (((first) (second) (third) (fourth) (fifth) (sixth) (seventh))))",
        "(declare-fun lectures (Professors Lectures) Bool)",
        "(define-fun to-int ((b Bool)) Int (ite b 1 0))"
      ],
      "constraints": [
        "(forall ((l Lectures)) (=> (lectures Powell l) (not (lectures Wood l))))",
        "(forall ((l Lectures)) (=> (lectures Taylor l) (not (lectures Shihab l))))",
        "(forall ((l Lectures)) (=> (lectures Vaughan l) (not (lectures Zabel l))))",
        "(forall ((l Lectures)) (=> (not (<= (lectures Shihab l) third)) (<= l third)))",
        "(not (lectures Young seventh))",
        "(forall ((l Lectures)) (=> (and (lectures Young l) (<= l Vaughan)) (<= l first)))"
      ],
      "options": [
        "(lectures Shihab first)",
        "(lectures Vaughan first)",
        "(lectures Wood first)",
        "(lectures Young first)",
        "(lectures Zabel first)"
      ],
      "type": "sat",
      "perplexity": [
        1.2106032371520996,
        1.118789553642273
      ],
      "answer": "B",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "SyntaxError: invalid syntax. Perhaps you forgot a comma?"
    }
  },
  {
    "id": 100,
    "nl_problem": {
      "context": "Each of exactly seven professors—Powell, Shihab, Taylor, Vaughan, Wood, Young, and Zabel—gives exactly one guest lecture in the literary theory course. The lectures are ordered from first through seventh, and their order must conform to the following: Powell lectures before Wood. Taylor lectures before Shihab. Vaughan lectures before Zabel. Shihab is no later than third. Young is not seventh. Powell lectures first if, but only if, Young lectures before Vaughan.",
      "question": "Which one of the following CANNOT given the second guest lecture?",
      "options": [
        "A) Powell",
        "B) Shihab",
        "C) Taylor",
        "D) Vaughan",
        "E) Wood"
      ]
    },
    "answer": "E",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((Professors 0)) (((Powell) (Shihab) (Taylor) (Vaughan) (Wood) (Young) (Zabel))))",
        "(declare-fun gives (Professors) Int)"
      ],
      "constraints": [
        "(forall ((p Professors)) (=> (= (gives p) 1) (not (= (gives Wood) 1))))",
        "(forall ((p Professors)) (=> (>= (gives Taylor) (gives p)) (= (gives Shihab) 2)))",
        "(forall ((p Professors)) (=> (>= (gives Vaughan) (gives p)) (= (gives Zabel) 5)))",
        "(forall ((p Professors)) (=> (= (gives Shihab) 2) (or (= (gives Shihab) 1) (= (gives Shihab) 3))))",
        "(forall ((p Professors)) (not (= (gives Young) 6)))",
        "(forall ((p Professors)) (=> (= (gives Powell) 1) (and (= (gives Young) 2) (= (gives Vaughan) 3))))"
      ],
      "options": [
        "(not (= (gives (choose-unknown Powell)) 2))",
        "(not (= (gives (choose-unknown Shihab)) 2))",
        "(not (= (gives (choose-unknown Taylor)) 2))",
        "(not (= (gives (choose-unknown Vaughan)) 2))",
        "(not (= (gives (choose-unknown Wood)) 2))"
      ],
      "type": "sat",
      "perplexity": [
        1.221130609512329,
        1.1155645847320557
      ],
      "answer": "E",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "SyntaxError: invalid syntax. Perhaps you forgot a comma?"
    }
  },
  {
    "id": 101,
    "nl_problem": {
      "context": "Each of exactly seven professors—Powell, Shihab, Taylor, Vaughan, Wood, Young, and Zabel—gives exactly one guest lecture in the literary theory course. The lectures are ordered from first through seventh, and their order must conform to the following: Powell lectures before Wood. Taylor lectures before Shihab. Vaughan lectures before Zabel. Shihab is no later than third. Young is not seventh. Powell lectures first if, but only if, Young lectures before Vaughan.",
      "question": "If Shihab lectures second and Zabel lectures fourth, then which one of the following could be true?",
      "options": [
        "A) Powell lectures sixth",
        "B) Taylor lectures third",
        "C) Vaughan lectures fifth",
        "D) Wood lectures fifth",
        "E) Young lectures third"
      ]
    },
    "answer": "A",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((Professors 0)) (((Powell) (Shihab) (Taylor) (Vaughan) (Wood) (Young) (Zabel))))",
        "(declare-datatypes ((Lectures 0)) (((1st) (2nd) (3rd) (4th) (5th) (6th) (7th))))",
        "(declare-fun lectures (Professors) Lectures)"
      ],
      "constraints": [
        "(not (= (lectures Powell) (lectures Wood)))",
        "(not (= (lectures Taylor) (lectures Shihab)))",
        "(not (= (lectures Vaughan) (lectures Zabel)))",
        "(or (= (lectures Shihab) 1st) (= (lectures Shihab) 2nd) (= (lectures Shihab) 3rd))",
        "(not (= (lectures Young) 7th))",
        "(or (= (lectures Powell) 1st) (and (= (lectures Young) 1st) (= (lectures Vaughan) 2nd) (not (= (lectures Powell) 1st))))"
      ],
      "options": [
        "(not (= (lectures Powell) 6th))",
        "(not (= (lectures Taylor) 3rd))",
        "(not (= (lectures Vaughan) 5th))",
        "(not (= (lectures Wood) 5th))",
        "(not (= (lectures Young) 3rd))"
      ],
      "type": "sat",
      "perplexity": [
        1.06653892993927,
        1.1084381341934204
      ],
      "answer": "A",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "SyntaxError: invalid decimal literal"
    }
  },
  {
    "id": 102,
    "nl_problem": {
      "context": "Each of exactly seven professors—Powell, Shihab, Taylor, Vaughan, Wood, Young, and Zabel—gives exactly one guest lecture in the literary theory course. The lectures are ordered from first through seventh, and their order must conform to the following: Powell lectures before Wood. Taylor lectures before Shihab. Vaughan lectures before Zabel. Shihab is no later than third. Young is not seventh. Powell lectures first if, but only if, Young lectures before Vaughan.",
      "question": "Which one of the following CANNOT be the guest lecture that Vaughan gives?",
      "options": [
        "A) second",
        "B) third",
        "C) fourth",
        "D) sixth",
        "E) seventh"
      ]
    },
    "answer": "E",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((Professors 0)) (((Powell) (Shihab) (Taylor) (Vaughan) (Wood) (Young) (Zabel))))",
        "(declare-datatypes ((Lectures 0)) (((first) (second) (third) (fourth) (fifth) (sixth) (seventh))))",
        "(declare-fun gives (Professors Lectures) Bool)",
        "(define-fun to-int ((b Bool)) Int (ite b 1 0))"
      ],
      "constraints": [
        "(forall ((l Lectures)) (=> (gives Powell l) (ite (= l first) true (exists ((l2 Lectures)) (= (ite (< l l2) true false) (gives Wood l2)))))",
        "(forall ((l Lectures)) (=> (gives Taylor l) (ite (= l first) true (exists ((l2 Lectures)) (= (ite (< l l2) true false) (gives Shihab l2)))))",
        "(forall ((l Lectures)) (=> (gives Vaughan l) (ite (= l first) true (exists ((l2 Lectures)) (= (ite (< l l2) true false) (gives Zabel l2)))))",
        "(forall ((l Lectures)) (ite (= l first) true (ite (= l second) true (ite (= l third) true (not (gives Shihab l)))))",
        "(not (gives Young seventh))",
        "(forall ((l Lectures)) (=> (and (= l first) (gives Young first)) (not (gives Powell second))) (forall ((l2 Lectures)) (=> (and (= l first) (gives Young l2)) (= l2 second))))"
      ],
      "options": [
        "(not (gives Vaughan second))",
        "(not (gives Vaughan third))",
        "(not (gives Vaughan fourth))",
        "(not (gives Vaughan sixth))",
        "(not (gives Vaughan seventh))"
      ],
      "type": "unsat",
      "perplexity": [
        1.1191773414611816,
        1.0906201601028442
      ],
      "answer": "E",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "SyntaxError: invalid syntax. Perhaps you forgot a comma?"
    }
  },
  {
    "id": 103,
    "nl_problem": {
      "context": "Each of exactly seven professors—Powell, Shihab, Taylor, Vaughan, Wood, Young, and Zabel—gives exactly one guest lecture in the literary theory course. The lectures are ordered from first through seventh, and their order must conform to the following: Powell lectures before Wood. Taylor lectures before Shihab. Vaughan lectures before Zabel. Shihab is no later than third. Young is not seventh. Powell lectures first if, but only if, Young lectures before Vaughan.",
      "question": "If Young lectures fourth and Taylor lectures first, then which one of the following must be true?",
      "options": [
        "A) Powell lectures no earlier than sixth",
        "B) Shihab lectures second.",
        "C) Vaughan lectures no later than third.",
        "D) Wood lectures seventh.",
        "E) Zabel lectures no earlier than sixth."
      ]
    },
    "answer": "E",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((Professors 0)) (((Powell) (Shihab) (Taylor) (Vaughan) (Wood) (Young) (Zabel))))",
        "(declare-datatypes ((Lectures 0)) (((first) (second) (third) (fourth) (fifth) (sixth) (seventh))))",
        "(declare-fun lecturers (Professors Lectures) Bool)",
        "(define-fun to-int ((b Bool)) Int (ite b 1 0))"
      ],
      "constraints": [
        "(forall ((l Lectures)) (=> (lecturers Powell l) (not (lecturers Wood (if (= l second) second first))))))",
        "(forall ((l Lectures)) (=> (lecturers Taylor l) (not (lecturers Shihab (if (= l second) second first)))))",
        "(forall ((l Lectures)) (=> (lecturers Vaughan l) (not (lecturers Zabel (if (= l second) second first)))))",
        "(forall ((l Lectures)) (=> (lecturers Shihab l) (or (<= l third) (<= l second))))",
        "(not (and (lecturers Young seventh) true))",
        "(forall ((l Lectures)) (=> (lecturers Young l) (ite (or (and (lecturers Young first) (not (lecturers Vaughan first))) (and (lecturers Young second) (not (lecturers Vaughan second))) (and (lecturers Young third) (not (lecturers Vaughan third))) (and (lecturers Young fourth) (not (lecturers Vaughan fourth))) (and (lecturers Young fifth) (not (lecturers Vaughan fifth))) (and (lecturers Young sixth) (not (lecturers Vaughan sixth))) (lecturers Powell l))))))"
      ],
      "options": [
        "(forall ((l Lectures)) (or (and (lecturers Powell sixth) (not (lecturers Powell fifth))) (and (lecturers Powell seventh) true)))",
        "(forall ((l Lectures)) (or (and (lecturers Shihab second) (not (lecturers Shihab first))) (and (lecturers Shihab third) (not (lecturers Shihab second)))))",
        "(forall ((l Lectures)) (or (and (lecturers Vaughan second) (not (lecturers Vaughan third))) (and (lecturers Vaughan third) true)))",
        "(forall ((l Lectures)) (or (and (lecturers Wood seventh) (not (lecturers Wood sixth))) (and (lecturers Wood sixth) (not (lecturers Wood fifth)))))",
        "(forall ((l Lectures)) (or (and (lecturers Zabel sixth) (not (lecturers Zabel fifth))) (and (lecturers Zabel seventh) true)))"
      ],
      "type": "sat",
      "perplexity": [
        1.1527639627456665,
        1.0635159015655518
      ],
      "answer": "E",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "SyntaxError: unmatched ')'"
    }
  },
  {
    "id": 104,
    "nl_problem": {
      "context": "Each of exactly seven professors—Powell, Shihab, Taylor, Vaughan, Wood, Young, and Zabel—gives exactly one guest lecture in the literary theory course. The lectures are ordered from first through seventh, and their order must conform to the following: Powell lectures before Wood. Taylor lectures before Shihab. Vaughan lectures before Zabel. Shihab is no later than third. Young is not seventh. Powell lectures first if, but only if, Young lectures before Vaughan.",
      "question": "If Zabel lectures fourth, then which one of the following could be true?",
      "options": [
        "A) Powell lectures second.",
        "B) Powell lectures seventh.",
        "C) Wood lectures third.",
        "D) Young lectures second.",
        "E) Young lectures sixth."
      ]
    },
    "answer": "E",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((Professors 0)) (((Powell) (Shihab) (Taylor) (Vaughan) (Wood) (Young) (Zabel))))",
        "(declare-datatypes ((Lectures 0)) (((first) (second) (third) (fourth) (fifth) (sixth) (seventh))))",
        "(declare-fun lecturers (Professors Lectures) Bool)"
      ],
      "constraints": [
        "(forall ((l Lectures)) (=> (lecturers Powell l) (not (lecturers Wood (if (= l second) first second)))))",
        "(forall ((l Lectures)) (=> (lecturers Taylor l) (not (lecturers Shihab (if (= l third) l first)))))",
        "(forall ((l Lectures)) (=> (lecturers Vaughan l) (not (lecturers Zabel (if (= l fourth) l first)))))",
        "(forall ((l Lectures)) (=> (lecturers Shihab l) (or (or (or (or (or (or (or (not (= l fourth)) (not (= l fifth))) (not (= l sixth))) (not (= l seventh))) (not (= l fifth))) (not (= l sixth))) (not (= l seventh))) (not (= l sixth))) (not (= l seventh)))))",
        "(forall ((l Lectures)) (not (and (lecturers Young seventh) (= l seventh))))",
        "(forall ((l Lectures)) (=> (lecturers Powell l) (or (and (lecturers Young (if (= l first) l second)) (not (lecturers Vaughan (if (= l first) l second)))) (not (= l first)))))",
        "(= (lecturers Zabel fourth) true)"
      ],
      "options": [
        "(lecturers Powell second)",
        "(lecturers Powell seventh)",
        "(lecturers Wood third)",
        "(lecturers Young second)",
        "(lecturers Young sixth)"
      ],
      "type": "sat",
      "perplexity": [
        1.1388556957244873,
        1.1548608541488647
      ],
      "answer": "E",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "SyntaxError: unmatched ')'"
    }
  },
  {
    "id": 105,
    "nl_problem": {
      "context": "A toy retailer is opening a small satellite store with exactly three aisles, numbered from 1 (lowest) to 3 (highest). Six sections—Fantasy, Hobbies, Music, Puzzles, Reading, and Science—will each be confined to exactly one aisle, with each aisle containing at least one of the sections. The following conditions hold: Reading must be located in the same aisle as either Fantasy or Music. Fantasy must be located in a lower-numbered aisle than both Music and Puzzles. Science must be located in a lower-numbered aisle than Puzzles. Science cannot be located in a lower-numbered aisle than Hobbies.",
      "question": "If aisle 1 contains Hobbies only, which one of the following could be true?",
      "options": [
        "A) Fantasy is located in aisle 3.",
        "B) Music is located in aisle 2.",
        "C) Puzzles is located in aisle 2.",
        "D) Reading is located in aisle 3.",
        "E) Science is located in aisle 3."
      ]
    },
    "answer": "D",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((Aisles 0)) (((aisle_1) (aisle_2) (aisle_3))))",
        "(declare-datatypes ((Sections 0)) (((Fantasy) (Hobbies) (Music) (Puzzles) (Reading) (Science)))",
        "(declare-fun loc (Aisles Sections) Bool)",
        "(define-fun to-int ((b Bool)) Int (ite b 1 0))"
      ],
      "constraints": [
        "(forall ((a Aisles)) (>= (+ (to-int (loc a Fantasy)) (to-int (loc a Hobbies)) (to-int (loc a Music)) (to-int (loc a Puzzles)) (to-int (loc a Reading)) (to-int (loc a Science))) 1))",
        "(or (= (loc aisle_1 Reading) (loc aisle_1 Fantasy)) (= (loc aisle_1 Reading) (loc aisle_1 Music)) (= (loc aisle_2 Reading) (loc aisle_2 Fantasy)) (= (loc aisle_2 Reading) (loc aisle_2 Music)) (= (loc aisle_3 Reading) (loc aisle_3 Fantasy)) (= (loc aisle_3 Reading) (loc aisle_3 Music)))",
        "(and (not (loc aisle_1 Fantasy)) (not (and (loc aisle_2 Fantasy) (loc aisle_2 Music))) (not (and (loc aisle_2 Fantasy) (loc aisle_2 Puzzles))) (not (and (loc aisle_2 Fantasy) (loc aisle_2 Science))))",
        "(or (not (loc aisle_1 Science)) (not (and (loc aisle_2 Science) (loc aisle_2 Puzzles))))",
        "(or (not (loc aisle_1 Science)) (not (loc aisle_1 Hobbies)))",
        "(not (loc aisle_2 Hobbies))",
        "(not (loc aisle_3 Hobbies))"
      ],
      "options": [
        "(loc aisle_3 Fantasy)",
        "(loc aisle_2 Music)",
        "(loc aisle_2 Puzzles)",
        "(loc aisle_3 Reading)",
        "(loc aisle_3 Science)"
      ],
      "type": "unsat",
      "perplexity": [
        1.1420320272445679,
        1.091455340385437
      ],
      "answer": "D",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "SyntaxError: invalid syntax. Perhaps you forgot a comma?"
    }
  },
  {
    "id": 106,
    "nl_problem": {
      "context": "A toy retailer is opening a small satellite store with exactly three aisles, numbered from 1 (lowest) to 3 (highest). Six sections—Fantasy, Hobbies, Music, Puzzles, Reading, and Science—will each be confined to exactly one aisle, with each aisle containing at least one of the sections. The following conditions hold: Reading must be located in the same aisle as either Fantasy or Music. Fantasy must be located in a lower-numbered aisle than both Music and Puzzles. Science must be located in a lower-numbered aisle than Puzzles. Science cannot be located in a lower-numbered aisle than Hobbies.",
      "question": "If aisle 3 contains Puzzles only, which one of the following must be true?",
      "options": [
        "A) Fantasy is located in aisle 1.",
        "B) Hobbies is located in aisle 1.",
        "C) Music is located in aisle 1.",
        "D) Reading is located in aisle 1.",
        "E) Science is located in aisle 2."
      ]
    },
    "answer": "A",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((Aisles 0)) (((aisle_1) (aisle_2) (aisle_3))))",
        "(declare-datatypes ((Sections 0)) (((Fantasy) (Hobbies) (Music) (Puzzles) (Reading) (Science))))",
        "(declare-fun location (Aisles Sections) Bool)",
        "(define-fun to-int ((b Bool)) Int (ite b 1 0))"
      ],
      "constraints": [
        "(or (forall ((m Aisles)) (= (location m Reading) (location m Fantasy))) (forall ((m Aisles)) (= (location m Reading) (location m Music))))",
        "(forall ((m Aisles)) (=> (= m aisle_1) (and (= (location m Fantasy) true) (not (location m Music)) (not (location m Puzzles)))))",
        "(forall ((m Aisles)) (=> (= m aisle_2) (and (location m Fantasy) (not (location m Music)) (not (location m Puzzles)))))",
        "(forall ((m Aisles)) (=> (= m aisle_3) (and (location m Fantasy) (location m Music) (location m Puzzles))))",
        "(forall ((m Aisles)) (=> (and (not (= m aisle_1)) (location m Science) (not (location m Puzzles))) false))",
        "(forall ((m Aisles)) (=> (and (not (= m aisle_1)) (not (location m Hobbies)) (location m Science)) false))",
        "(forall ((m Aisles)) (= (location m Puzzles) (location aisle_3 Puzzles)))",
        "(forall ((m Aisles)) (= (location m Fantasy) (location aisle_1 Fantasy)))",
        "(forall ((m Aisles)) (= (location m Hobbies) (location aisle_1 Hobbies)))",
        "(forall ((m Aisles)) (= (location m Music) (location aisle_1 Music)))",
        "(forall ((m Aisles)) (= (location m Reading) (location aisle_1 Reading)))",
        "(forall ((m Aisles)) (= (location m Science) (location aisle_2 Science)))"
      ],
      "options": [],
      "type": "sat",
      "perplexity": [
        1.116213083267212,
        1.0815895795822144
      ],
      "answer": "A",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "SyntaxError: invalid syntax"
    }
  },
  {
    "id": 107,
    "nl_problem": {
      "context": "A toy retailer is opening a small satellite store with exactly three aisles, numbered from 1 (lowest) to 3 (highest). Six sections—Fantasy, Hobbies, Music, Puzzles, Reading, and Science—will each be confined to exactly one aisle, with each aisle containing at least one of the sections. The following conditions hold: Reading must be located in the same aisle as either Fantasy or Music. Fantasy must be located in a lower-numbered aisle than both Music and Puzzles. Science must be located in a lower-numbered aisle than Puzzles. Science cannot be located in a lower-numbered aisle than Hobbies.",
      "question": "If each aisle contains exactly two of the six sections, then Science must be located in the same aisle as",
      "options": [
        "A) Fantasy",
        "B) Hobbies",
        "C) Music",
        "D) Puzzles",
        "E) Reading"
      ]
    },
    "answer": "B",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((Aisles 0)) (((Aisle1) (Aisle2) (Aisle3))))",
        "(declare-datatypes ((Sections 0)) (((Fantasy) (Hobbies) (Music) (Puzzles) (Reading) (Science))))",
        "(declare-fun contains (Aisles Sections) Bool)",
        "(define-fun to-int ((b Bool)) Int (ite b 1 0))"
      ],
      "constraints": [
        "(forall ((a Aisles)) (>= (+ (to-int (contains a Fantasy)) (to-int (contains a Hobbies)) (to-int (contains a Music)) (to-int (contains a Puzzles)) (to-int (contains a Reading)) (to-int (contains a Science))) 1))",
        "(forall ((a Aisles)) (or (and (contains a Reading) (contains a Fantasy)) (and (contains a Reading) (contains a Music))))",
        "(forall ((a1 Aisles) (a2 Aisles)) (=> (and (contains a1 Fantasy) (contains a2 Music) (contains a2 Puzzles)) (not (and (= a1 Aisle2) (= a2 Aisle3)))))",
        "(forall ((a1 Aisles) (a2 Aisles)) (=> (and (contains a1 Science) (contains a2 Puzzles)) (not (and (= a1 Aisle3) (= a2 Aisle3)))))",
        "(forall ((a1 Aisles) (a2 Aisles)) (=> (and (contains a1 Science) (contains a2 Hobbies)) (not (and (= a1 Aisle2) (= a2 Aisle1)))))"
      ],
      "options": [
        "(forall ((a Aisles)) (= (contains a Science) (contains a Fantasy)))",
        "(forall ((a Aisles)) (= (contains a Science) (contains a Hobbies)))",
        "(forall ((a Aisles)) (= (contains a Science) (contains a Music)))",
        "(forall ((a Aisles)) (= (contains a Science) (contains a Puzzles)))",
        "(forall ((a Aisles)) (= (contains a Science) (contains a Reading)))"
      ],
      "type": "unsat",
      "perplexity": [
        1.1146819591522217,
        1.0788925886154175
      ],
      "answer": "B",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "SyntaxError: invalid syntax. Perhaps you forgot a comma?"
    }
  },
  {
    "id": 108,
    "nl_problem": {
      "context": "A toy retailer is opening a small satellite store with exactly three aisles, numbered from 1 (lowest) to 3 (highest). Six sections—Fantasy, Hobbies, Music, Puzzles, Reading, and Science—will each be confined to exactly one aisle, with each aisle containing at least one of the sections. The following conditions hold: Reading must be located in the same aisle as either Fantasy or Music. Fantasy must be located in a lower-numbered aisle than both Music and Puzzles. Science must be located in a lower-numbered aisle than Puzzles. Science cannot be located in a lower-numbered aisle than Hobbies.",
      "question": "Which one of the following CANNOT be the list of the sections located in aisle 2?",
      "options": [
        "A) Hobbies, Music",
        "B) Music, Reading",
        "C) Music, Science",
        "D) Hobbies, Music, Science",
        "E) Music, Reading, Science"
      ]
    },
    "answer": "A",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((Aisles 0)) (((aisle1) (aisle2) (aisle3))))",
        "(declare-datatypes ((Sections 0)) (((Fantasy) (Hobbies) (Music) (Puzzles) (Reading) (Science))))",
        "(declare-fun located (Aisles Sections) Bool)",
        "(define-fun to-int ((b Bool)) Int (ite b 1 0))"
      ],
      "constraints": [
        "(forall ((a Aisles)) (>= (+ (to-int (located a Fantasy)) (to-int (located a Hobbies)) (to-int (located a Music)) (to-int (located a Puzzles)) (to-int (located a Reading)) (to-int (located a Science))) 1))",
        "(or (= (located aisle2 Reading) (located aisle2 Fantasy)) (= (located aisle2 Reading) (located aisle2 Music)))",
        "(and (not (= (located aisle1 Fantasy) (located aisle1 Music))) (not (= (located aisle1 Fantasy) (located aisle1 Puzzles))) (not (= (located aisle1 Fantasy) (located aisle2 Music))) (not (= (located aisle1 Fantasy) (located aisle2 Puzzles))) (not (= (located aisle2 Fantasy) (located aisle2 Music))) (not (= (located aisle2 Fantasy) (located aisle2 Puzzles))))",
        "(and (not (= (located aisle1 Science) (located aisle1 Puzzles))) (not (= (located aisle1 Science) (located aisle2 Puzzles))) (not (= (located aisle2 Science) (located aisle2 Puzzles))))",
        "(or (= (located aisle1 Science) (located aisle1 Hobbies)) (= (located aisle2 Science) (located aisle1 Hobbies)))"
      ],
      "options": [
        "(not (located aisle2 Hobbies Music))",
        "(not (located aisle2 Music Reading))",
        "(not (located aisle2 Music Science))",
        "(not (located aisle2 Hobbies Music Science))",
        "(not (located aisle2 Music Reading Science))"
      ],
      "type": "unsat",
      "perplexity": [
        1.0816097259521484,
        1.0845239162445068
      ],
      "answer": "A",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "SyntaxError: invalid syntax. Perhaps you forgot a comma?"
    }
  },
  {
    "id": 109,
    "nl_problem": {
      "context": "A toy retailer is opening a small satellite store with exactly three aisles, numbered from 1 (lowest) to 3 (highest). Six sections—Fantasy, Hobbies, Music, Puzzles, Reading, and Science—will each be confined to exactly one aisle, with each aisle containing at least one of the sections. The following conditions hold: Reading must be located in the same aisle as either Fantasy or Music. Fantasy must be located in a lower-numbered aisle than both Music and Puzzles. Science must be located in a lower-numbered aisle than Puzzles. Science cannot be located in a lower-numbered aisle than Hobbies.",
      "question": "If aisle 2 contains Science only, then each of the following must be true EXCEPT:",
      "options": [
        "A) Fantasy is located in aisle 1.",
        "B) Hobbies is located in aisle 1.",
        "C) Music is located in aisle 3.",
        "D) Puzzles is located in aisle 3.",
        "E) Reading is located in aisle 1."
      ]
    },
    "answer": "E",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((Aisles 0)) (((aisle1) (aisle2) (aisle3))))",
        "(declare-datatypes ((Sections 0)) (((Fantasy) (Hobbies) (Music) (Puzzles) (Reading) (Science))))",
        "(declare-fun in (Aisles Sections) Bool)",
        "(define-fun to-int ((b Bool)) Int (ite b 1 0))"
      ],
      "constraints": [
        "(or (= (in aisle1 Reading) (in aisle1 Fantasy)) (= (in aisle1 Reading) (in aisle1 Music)))",
        "(and (not (in aisle1 Fantasy)) (or (in aisle2 Fantasy) (in aisle3 Fantasy)) (and (not (in aisle1 Music)) (or (in aisle2 Music) (in aisle3 Music)) (not (in aisle1 Puzzles)) (or (in aisle2 Puzzles) (in aisle3 Puzzles))))",
        "(and (not (in aisle1 Science)) (or (in aisle2 Science) (in aisle3 Science)) (or (in aisle2 Puzzles) (in aisle3 Puzzles)) (or (not (in aisle2 Puzzles)) (not (in aisle3 Puzzles))))",
        "(or (in aisle2 Science) (in aisle3 Science))"
      ],
      "options": [
        "(in aisle2 Science)",
        "(not (in aisle1 Fantasy))",
        "(not (in aisle1 Hobbies))",
        "(not (in aisle1 Music))",
        "(not (in aisle1 Puzzles))",
        "(not (in aisle1 Reading))"
      ],
      "type": "unsat",
      "perplexity": [
        1.1192139387130737,
        1.1067112684249878
      ],
      "answer": "E",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "SyntaxError: invalid syntax"
    }
  },
  {
    "id": 110,
    "nl_problem": {
      "context": "Millville has created three new development zones: Z1, Z2, and Z3. Within these zones, subzones can be designated for housing, industrial, or retail use, with no subzone designated for more than one use. By city regulation, a total of no more than three subzones can be designated for each of the three uses. The following restrictions are in place: Retail subzones are not allowed in Z1. No more than two subzones for housing are allowed in any particular zone. No more than one retail subzone is allowed in any zone in which a subzone is designated for housing. Industrial subzones are not allowed in any zone in which a subzone is designated for housing or three subzones are designated for retail use.",
      "question": "Which one of the following is an allowable way of designating subzones within the three zones?",
      "options": [
        "A) Z1: no designated subzones Z2: one housing subzone, two retail subzones Z3: one industrial subzone, one retail subzone",
        "B) Z1: one housing subzone, one industrial subzone Z2: two housing subzones, one retail subzone Z3: one industrial subzone, one retail subzone",
        "C) Z1: one housing subzone, one retail subzone Z2: two housing subzones, one retail subzone Z3: one industrial subzone, one retail subzone",
        "D) Z1: one industrial subzone Z2: three housing subzones Z3: three retail subzones",
        "E) Z1: one industrial subzone Z2: two housing subzones, one retail subzone Z3: one industrial subzone, two retail subzones"
      ]
    },
    "answer": "E",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((Zones 0)) (((Z1) (Z2) (Z3))))",
        "(declare-datatypes ((Uses 0)) (((housing) (industrial) (retail))))",
        "(declare-fun subzone_designations (Zones Uses) Bool)"
      ],
      "constraints": [
        "(forall ((u Uses)) (>= (+ (to-int (subzone_designations Z1 u)) (to-int (subzone_designations Z2 u)) (to-int (subzone_designations Z3 u))) 3))",
        "(forall ((u Uses)) (=> (and (distinct retail u) (subzone_designations Z1 u)) false))",
        "(forall ((z Zones)) (<= (+ (to-int (subzone_designations z housing)) (to-int (subzone_designations Z2 housing))) 2))",
        "(forall ((z Zones)) (=> (and (subzone_designations z housing) (subzone_designations z retail)) false))",
        "(forall ((z Zones)) (=> (or (subzone_designations z housing) (>= (+ (to-int (subzone_designations Z1 retail)) (to-int (subzone_designations Z2 retail)) (to-int (subzone_designations Z3 retail))) 3)) (not (subzone_designations z industrial))))"
      ],
      "options": [
        "(not (subzone_designations Z1 housing))",
        "(not (subzone_designations Z1 industrial))",
        "(not (subzone_designations Z2 housing))",
        "(= (subzone_designations Z2 retail) true)",
        "(= (subzone_designations Z3 retail) true)",
        "(= (subzone_designations Z3 industrial) true)"
      ],
      "type": "sat",
      "perplexity": [
        1.1678106784820557,
        1.1154013872146606
      ],
      "answer": "E",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "SyntaxError: invalid syntax. Perhaps you forgot a comma?"
    }
  },
  {
    "id": 111,
    "nl_problem": {
      "context": "Millville has created three new development zones: Z1, Z2, and Z3. Within these zones, subzones can be designated for housing, industrial, or retail use, with no subzone designated for more than one use. By city regulation, a total of no more than three subzones can be designated for each of the three uses. The following restrictions are in place: Retail subzones are not allowed in Z1. No more than two subzones for housing are allowed in any particular zone. No more than one retail subzone is allowed in any zone in which a subzone is designated for housing. Industrial subzones are not allowed in any zone in which a subzone is designated for housing or three subzones are designated for retail use.",
      "question": "Which one of the following CANNOT be true within a single zone?",
      "options": [
        "A) Two subzones are designated, one housing and one retail.",
        "B) Two subzones are designated, one industrial and one retail.",
        "C) Three subzones are designated, all of them retail.",
        "D) Four subzones are designated, none of them industrial.",
        "E) Four subzones are designated, two retail and two industrial."
      ]
    },
    "answer": "D",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((Zones 0)) (((Z1) (Z2) (Z3))))",
        "(declare-datatypes ((Uses 0)) (((housing) (industrial) (retail))))",
        "(declare-fun designated (Zones Uses) Bool)"
      ],
      "constraints": [
        "(forall ((u Uses)) (<= (+ (ite (designated Z1 u) 1 0) (ite (designated Z2 u) 1 0) (ite (designated Z3 u) 1 0)) 3))",
        "(not (designated Z1 retail))",
        "(forall ((z Zones)) (<= (+ (ite (designated z housing) 1 0) (ite (designated (if (= z Z1) Z2 Z1) housing) 1 0) (ite (designated (if (= z Z2) Z3 Z2) housing) 1 0) (ite (designated (if (= z Z3) Z1 Z3) housing) 1 0)) 2))",
        "(forall ((z Zones)) (<= (+ (ite (designated z housing) 1 0) (ite (designated z retail) 1 0)) 1))",
        "(forall ((z Zones)) (<= (+ (ite (designated z housing) 1 0) (ite (designated z industrial) 1 0) (ite (designated (if (= z Z1) Z2 Z1) retail) 1 0) (ite (designated (if (= z Z2) Z3 Z2) retail) 1 0) (ite (designated (if (= z Z3) Z1 Z3) retail) 1 0) (ite (designated z retail) 1 0)) 2))"
      ],
      "options": [
        "(and (= (designated Z1 housing) true) (= (designated Z1 retail) true))",
        "(and (= (designated Z1 industrial) true) (= (designated Z1 retail) true))",
        "(and (= (designated Z1 retail) true) (= (designated Z1 retail) true) (= (designated Z1 retail) true))",
        "(and (= (designated Z1 housing) true) (= (designated Z1 housing) true) (= (designated Z1 industrial) true))",
        "(and (= (designated Z1 housing) true) (= (designated Z1 industrial) true) (= (designated Z1 retail) true) (= (designated Z1 housing) true) (= (designated Z1 retail) true))"
      ],
      "type": "sat",
      "perplexity": [
        1.0979728698730469,
        1.0673556327819824
      ],
      "answer": "D",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "SyntaxError: invalid syntax. Perhaps you forgot a comma?"
    }
  },
  {
    "id": 112,
    "nl_problem": {
      "context": "Millville has created three new development zones: Z1, Z2, and Z3. Within these zones, subzones can be designated for housing, industrial, or retail use, with no subzone designated for more than one use. By city regulation, a total of no more than three subzones can be designated for each of the three uses. The following restrictions are in place: Retail subzones are not allowed in Z1. No more than two subzones for housing are allowed in any particular zone. No more than one retail subzone is allowed in any zone in which a subzone is designated for housing. Industrial subzones are not allowed in any zone in which a subzone is designated for housing or three subzones are designated for retail use.",
      "question": "What is the maximum number of designated subzones allowed in Z3?",
      "options": [
        "A) 2",
        "B) 3",
        "C) 4",
        "D) 5",
        "E) 6"
      ]
    },
    "answer": "D",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((Zones 0)) (((Z1) (Z2) (Z3))))",
        "(declare-datatypes ((Uses 0)) (((housing) (industrial) (retail)))",
        "(declare-fun designated (Zones Uses) Bool)",
        "(define-fun to-int ((b Bool)) Int (ite b 1 0))"
      ],
      "constraints": [
        "(forall ((z Zones) (u1 Uses) (u2 Uses) (u3 Uses)) (<= (+ (to-int (and (designated z u1) (designated z u2))) (to-int (and (designated z u1) (designated z u3))) (to-int (and (designated z u2) (designated z u3)))) 1))",
        "(forall ((u Uses)) (<= (+ (to-int (exists ((z Zones)) (designated z u))) 3)))",
        "(forall ((u Uses)) (=> (designated Z1 u) (not (= u retail))))",
        "(forall ((z Zones)) (<= (+ (to-int (exists ((u Uses)) (and (designated z u) (= u housing))))) 2))",
        "(forall ((z Zones)) (=> (exists ((u Uses)) (and (designated z u) (= u housing))) (<= (+ (to-int (exists ((v Uses)) (and (designated z v) (= v retail))))) 1)))",
        "(forall ((z Zones)) (=> (or (exists ((u Uses)) (and (designated z u) (= u housing))) (<= (+ (to-int (exists ((u Uses)) (designated z u))) 3)) (= (exists ((u Uses)) (designated z u)) retail) (not (= (exists ((u Uses)) (and (designated z u) (= u industrial))) true))))))",
        "(forall ((z Zones)) (=> (exists ((u Uses)) (and (designated z u) (= u industrial))) (not (= (exists ((u Uses)) (and (designated z u) (= u retail))) true)))"
      ],
      "options": [
        "(= (+ (to-int (exists ((z Zones)) (designated z housing))) (to-int (exists ((z Zones)) (designated z industrial))) (to-int (exists ((z Zones)) (designated z retail)))) 2)",
        "(= (+ (to-int (exists ((z Zones)) (designated z housing))) (to-int (exists ((z Zones)) (designated z industrial))) (to-int (exists ((z Zones)) (designated z retail)))) 3)",
        "(= (+ (to-int (exists ((z Zones)) (designated z housing))) (to-int (exists ((z Zones)) (designated z industrial))) (to-int (exists ((z Zones)) (designated z retail)))) 4)",
        "(= (+ (to-int (exists ((z Zones)) (designated z housing))) (to-int (exists ((z Zones)) (designated z industrial))) (to-int (exists ((z Zones)) (designated z retail)))) 5)",
        "(= (+ (to-int (exists ((z Zones)) (designated z housing))) (to-int (exists ((z Zones)) (designated z industrial))) (to-int (exists ((z Zones)) (designated z retail)))) 6)"
      ],
      "type": "sat",
      "perplexity": [
        1.1296194791793823,
        1.0751724243164062
      ],
      "answer": "D",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "SyntaxError: unmatched ')'"
    }
  },
  {
    "id": 113,
    "nl_problem": {
      "context": "Millville has created three new development zones: Z1, Z2, and Z3. Within these zones, subzones can be designated for housing, industrial, or retail use, with no subzone designated for more than one use. By city regulation, a total of no more than three subzones can be designated for each of the three uses. The following restrictions are in place: Retail subzones are not allowed in Z1. No more than two subzones for housing are allowed in any particular zone. No more than one retail subzone is allowed in any zone in which a subzone is designated for housing. Industrial subzones are not allowed in any zone in which a subzone is designated for housing or three subzones are designated for retail use.",
      "question": "If three subzones are designated for each use, then which one of the following is allowed?",
      "options": [
        "A) Exactly one subzone in Z3 is designated for industrial use and exactly one subzone in Z3 is designated for retail use.",
        "B) Exactly two subzones in Z2 are designated for housing.",
        "C) Three subzones in Z1 are designated for industrial use.",
        "D) Three subzones in Z2 are designated for industrial use and exactly one subzone in Z2 is designated for retail use.",
        "E) Three subzones in Z3 are designated for retail use."
      ]
    },
    "answer": "B",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((Zones 0)) (((Z1) (Z2) (Z3))))",
        "(declare-datatypes ((Uses 0)) (((housing) (industrial) (retail))))",
        "(declare-fun subzones (Zones Uses) Int)",
        "(define-fun to-int ((b Bool)) Int (ite b 1 0))"
      ],
      "constraints": [
        "(forall ((u Uses)) (>= (+ (to-int (>= (subzones Z1 u) 0)) (to-int (>= (subzones Z2 u) 0)) (to-int (>= (subzones Z3 u) 0))) 3))",
        "(forall ((u Uses)) (=> (= u retail) (= (subzones Z1 u) 0)))",
        "(forall ((z Zones)) (>= (to-int (<= (subzones z housing) 2)) 1))",
        "(forall ((z Zones)) (=> (>= (subzones z housing) 1) (= (subzones z retail) 0)))",
        "(forall ((z Zones)) (=> (or (>= (subzones z housing) 1) (>= (subzones z retail) 3)) (= (subzones z industrial) 0)))"
      ],
      "options": [
        "(= (subzones Z3 industrial) 1)",
        "(= (subzones Z3 retail) 1)",
        "(= (subzones Z2 housing) 2)",
        "(= (subzones Z1 industrial) 3)",
        "(= (subzones Z2 industrial) 3)",
        "(= (subzones Z2 retail) 1)",
        "(= (subzones Z3 retail) 3)"
      ],
      "type": "unsat",
      "perplexity": [
        1.0936861038208008,
        1.0950850248336792
      ],
      "answer": "B",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "SyntaxError: invalid syntax. Perhaps you forgot a comma?"
    }
  },
  {
    "id": 114,
    "nl_problem": {
      "context": "Millville has created three new development zones: Z1, Z2, and Z3. Within these zones, subzones can be designated for housing, industrial, or retail use, with no subzone designated for more than one use. By city regulation, a total of no more than three subzones can be designated for each of the three uses. The following restrictions are in place: Retail subzones are not allowed in Z1. No more than two subzones for housing are allowed in any particular zone. No more than one retail subzone is allowed in any zone in which a subzone is designated for housing. Industrial subzones are not allowed in any zone in which a subzone is designated for housing or three subzones are designated for retail use.",
      "question": "If one subzone in each of the zones is designated for industrial use, then which one of the following is allowed?",
      "options": [
        "A) More subzones are designated for retail use in Z2 than in Z3.",
        "B) A subzone in one of the zones is designated for housing.",
        "C) Exactly two subzones are designated in Z1.",
        "D) Exactly three subzones each are designated in Z2 and Z3.",
        "E) Exactly four subzones are designated in Z3."
      ]
    },
    "answer": "A",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((Zones 0)) (((Z1) (Z2) (Z3))))",
        "(declare-datatypes ((SubzoneUses 0)) (((housing) (industrial) (retail))))",
        "(declare-fun designated (Zones SubzoneUses) Bool)",
        "(define-fun to-int ((b Bool)) Int (ite b 1 0))"
      ],
      "constraints": [
        "(forall ((u SubzoneUses)) (>= (+ (to-int (designated Z1 u)) (to-int (designated Z2 u)) (to-int (designated Z3 u))) 0))",
        "(not (designated Z1 retail))",
        "(forall ((z Zones)) (<= (+ (to-int (designated z housing)) (to-int (designated z industrial)) (to-int (designated z retail))) 2))",
        "(forall ((z Zones)) (<= (+ (to-int (and (designated z housing) (designated z retail))) (to-int (designated z industrial)) (to-int (designated z retail))) 1))",
        "(forall ((z Zones)) (<= (+ (to-int (and (designated z housing) (designated z industrial))) (to-int (and (designated z retail) (designated z retail) (designated z retail))) (to-int (designated z industrial))) 0))"
      ],
      "options": [
        "(= (designated Z1 industrial) true)",
        "(= (designated Z2 retail) (> (designated Z2 retail) (designated Z3 retail)))",
        "(= (designated Z1 housing) true)",
        "(= (designated Z1 subzone-uses) 2)",
        "(and (= (designated Z2 subzone-uses) 3) (= (designated Z3 subzone-uses) 3))",
        "(= (designated Z3 subzone-uses) 4)"
      ],
      "type": "unsat",
      "perplexity": [
        1.158532977104187,
        1.0963385105133057
      ],
      "answer": "A",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "SyntaxError: invalid syntax. Perhaps you forgot a comma?"
    }
  },
  {
    "id": 115,
    "nl_problem": {
      "context": "Millville has created three new development zones: Z1, Z2, and Z3. Within these zones, subzones can be designated for housing, industrial, or retail use, with no subzone designated for more than one use. By city regulation, a total of no more than three subzones can be designated for each of the three uses. The following restrictions are in place: Retail subzones are not allowed in Z1. No more than two subzones for housing are allowed in any particular zone. No more than one retail subzone is allowed in any zone in which a subzone is designated for housing. Industrial subzones are not allowed in any zone in which a subzone is designated for housing or three subzones are designated for retail use.",
      "question": "If three subzones in all are designated for retail use and a subzone in Z2 is designated for housing, then which one of the following is allowed?",
      "options": [
        "A) Two subzones in Z1 are designated for housing.",
        "B) More subzones are designated for industrial use in Z2 than in Z3.",
        "C) More subzones are designated for retail use in Z2 than in Z3.",
        "D) The same number of subzones are designated for retail use in Z2 and Z3.",
        "E) A subzone in Z3 is designated for housing."
      ]
    },
    "answer": "A",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((Zones 0)) (((Z1) (Z2) (Z3))))",
        "(declare-datatypes ((Uses 0)) (((housing) (industrial) (retail))))",
        "(declare-fun designated (Zones Uses) Bool)",
        "(define-fun to-int ((b Bool)) Int (ite b 1 0))"
      ],
      "constraints": [
        "(forall ((u Uses)) (>= (+ (to-int (designated Z1 u)) (to-int (designated Z2 u)) (to-int (designated Z3 u))) 3))",
        "(forall ((u Uses)) (=> (distinct u retail) (= (designated Z1 retail) false)))",
        "(forall ((z Zones)) (<= (+ (to-int (designated z housing)) (to-int (designated (if (= z Z1) Z2 Z1) housing)) (to-int (designated (if (= z Z2) Z1 Z2) housing))) 2))",
        "(forall ((z Zones)) (=> (designated z housing) (<= (+ (to-int (designated z retail)) (to-int (designated (if (= z Z1) Z2 Z1) retail)) (to-int (designated (if (= z Z2) Z1 Z2) retail))) 1)))",
        "(forall ((z Zones)) (=> (or (designated z housing) (= (+ (to-int (designated z retail)) (to-int (designated (if (= z Z1) Z2 Z1) retail)) (to-int (designated (if (= z Z2) Z1 Z2) retail))) 3)) (designated z industrial)))",
        "(= (+ (to-int (designated Z1 retail)) (to-int (designated Z2 retail)) (to-int (designated Z3 retail))) 3)",
        "(designated Z2 housing)"
      ],
      "options": [
        "(= (designated Z1 housing) true)",
        " (= (+ (to-int (designated Z2 industrial)) (to-int (designated Z3 industrial))) (+ (to-int (designated Z2 industrial)) (to-int (designated Z3 industrial)))))",
        " (= (+ (to-int (designated Z2 retail)) (to-int (designated Z3 retail))) (+ (to-int (designated Z2 retail)) (to-int (designated Z3 retail)))))",
        "(= (designated Z3 housing) true)"
      ],
      "type": "sat",
      "perplexity": [
        1.0788878202438354,
        1.0736384391784668
      ],
      "answer": "A",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "SyntaxError: unmatched ')'"
    }
  },
  {
    "id": 116,
    "nl_problem": {
      "context": "A researcher is studying seven manuscripts—F, G, H, L, M, P, and S—to determine their relative ages. It is known that no two manuscripts were written at the same time. The researcher has also determined the following: H was written earlier than S but later than F. P was the next manuscript written after G. At least four of the manuscripts were written earlier than L. At least four of the manuscripts were written later than M. H was not written fifth.",
      "question": "Which one of the following could be the order in which the manuscripts were written, from first to last?",
      "options": [
        "A) F, M, G, H, P, L, S",
        "B) G, P, M, F, H, S, L",
        "C) H, F, M, G, P, L, S",
        "D) L, F, M, G, P, H, S",
        "E) M, F, H, S, L, G, P"
      ]
    },
    "answer": "E",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((Manuscripts 0)) (((F) (G) (H) (L) (M) (P) (S))))",
        "(declare-fun written-after (Manuscripts Manuscripts) Bool)"
      ],
      "constraints": [
        "(forall ((m1 Manuscripts) (m2 Manuscripts)) (= (> (written-after m1 m2) (written-after m2 m1))))",
        "(and (= (written-after F H) true) (= (written-after H S) true))",
        "(= (written-after G P) true)",
        "(>= (+ (ite (written-after F L) 1 0) (ite (written-after G L) 1 0) (ite (written-after H L) 1 0) (ite (written-after M L) 1 0) (ite (written-after P L) 1 0) (ite (written-after S L) 1 0)) 4)",
        "(>= (+ (ite (written-after F M) 1 0) (ite (written-after G M) 1 0) (ite (written-after H M) 1 0) (ite (written-after L M) 1 0) (ite (written-after P M) 1 0) (ite (written-after S M) 1 0)) 4)",
        "(not (and (= (written-after F H) true) (= (written-after H G) true) (= (written-after G P) true) (= (written-after P L) true)))"
      ],
      "options": [
        "(written-after F M) (written-after M G) (written-after G H) (written-after H P) (written-after P L) (written-after L S)",
        "(written-after G P) (written-after P M) (written-after M F) (written-after F H) (written-after H S) (written-after S L)",
        "(written-after H F) (written-after F M) (written-after M G) (written-after G P) (written-after P L) (written-after L S)",
        "(written-after L F) (written-after F M) (written-after M G) (written-after G P) (written-after P H) (written-after H S)",
        "(written-after M F) (written-after F H) (written-after H S) (written-after S L) (written-after L G) (written-after G P)"
      ],
      "type": [
        "sat",
        "sat",
        "sat",
        "sat",
        "sat"
      ],
      "perplexity": [
        1.0732132196426392,
        1.0870883464813232
      ],
      "answer": "E",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "SyntaxError: invalid syntax. Perhaps you forgot a comma?"
    }
  },
  {
    "id": 117,
    "nl_problem": {
      "context": "A researcher is studying seven manuscripts—F, G, H, L, M, P, and S—to determine their relative ages. It is known that no two manuscripts were written at the same time. The researcher has also determined the following: H was written earlier than S but later than F. P was the next manuscript written after G. At least four of the manuscripts were written earlier than L. At least four of the manuscripts were written later than M. H was not written fifth.",
      "question": "Which one of the following manuscripts CANNOT have been written third?",
      "options": [
        "A) S",
        "B) P",
        "C) M",
        "D) H",
        "E) G"
      ]
    },
    "answer": "A",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((Manuscripts 0)) (((F) (G) (H) (L) (M) (P) (S))))",
        "(declare-fun written (Manuscripts Manuscripts) Bool)",
        "(define-fun to-int ((b Bool)) Int (ite b 1 0))"
      ],
      "constraints": [
        "(forall ((m1 Manuscripts) (m2 Manuscripts)) (not (= m1 m2)))",
        "(and (< (+ (to-int (and (written F H) (written H F))) (to-int (and (written F S) (written S F)))) (+ (to-int (and (written H S) (written S H))) (to-int (and (written S F) (written F S))))) true)",
        "(and (< (+ (to-int (and (written G P) (written P G))) (to-int (and (written P G) (written G P)))) (+ (to-int (and (written G F) (written F G))) (to-int (and (written F G) (written G F))))) true)",
        "(>= (+ (to-int (and (written F L) (written L F))) (to-int (and (written G L) (written L G))) (to-int (and (written H L) (written L H))) (to-int (and (written M L) (written L M))) (to-int (and (written P L) (written L P))) (to-int (and (written S L) (written L S)))) 4)",
        "(>= (+ (to-int (and (written F M) (written M F))) (to-int (and (written G M) (written M G))) (to-int (and (written H M) (written M H))) (to-int (and (written P M) (written M P))) (to-int (and (written S M) (written M S)))) 4)",
        "(not (or (= (+ (to-int (and (written F H) (written H F))) (to-int (and (written G H) (written H G))) (to-int (and (written M H) (written H M))) (to-int (and (written P H) (written H P))) (to-int (and (written S H) (written H S))) 4) (= (+ (to-int (and (written F H) (written H F))) (to-int (and (written G H) (written H G))) (to-int (and (written M H) (written H M))) (to-int (and (written P H) (written H P))) (to-int (and (written S H) (written H S))) 5) (= (+ (to-int (and (written F H) (written H F))) (to-int (and (written G H) (written H G))) (to-int (and (written M H) (written H M))) (to-int (and (written P H) (written H P))) (to-int (and (written S H) (written H S))) 6))) true)"
      ],
      "options": [
        "(not (or (= (written H S) true) (= (written S H) true)))",
        "(not (or (= (written H P) true) (= (written P H) true)))",
        "(not (or (= (written H M) true) (= (written M H) true)))",
        "(not (or (= (written H G) true) (= (written G H) true)))"
      ],
      "type": "sat",
      "perplexity": [
        1.0879734754562378,
        1.048397183418274
      ],
      "answer": "A",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "SyntaxError: invalid syntax. Perhaps you forgot a comma?"
    }
  },
  {
    "id": 118,
    "nl_problem": {
      "context": "A researcher is studying seven manuscripts—F, G, H, L, M, P, and S—to determine their relative ages. It is known that no two manuscripts were written at the same time. The researcher has also determined the following: H was written earlier than S but later than F. P was the next manuscript written after G. At least four of the manuscripts were written earlier than L. At least four of the manuscripts were written later than M. H was not written fifth.",
      "question": "If H was the next manuscript written after M, which one of the following could be true?",
      "options": [
        "A) F was written second.",
        "B) G was written third.",
        "C) H was written fourth.",
        "D) P was written third.",
        "E) S was written fourth."
      ]
    },
    "answer": "E",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((Manuscripts 0)) (((F) (G) (H) (L) (M) (P) (S))))",
        "(declare-fun written-after (Manuscripts Manuscripts) Bool)",
        "(define-fun to-int ((b Bool)) Int (ite b 1 0))"
      ],
      "constraints": [
        "(forall ((m1 Manuscripts) (m2 Manuscripts)) (not (= m1 m2)))",
        "(and (written-after H S) (written-after F H))",
        "(written-after P G)",
        "(>= (+ (to-int (written-after F L)) (to-int (written-after G L)) (to-int (written-after H L)) (to-int (written-after M L)) (to-int (written-after P L)) (to-int (written-after S L))) 4)",
        "(>= (+ (to-int (written-after F M)) (to-int (written-after G M)) (to-int (written-after H M)) (to-int (written-after L M)) (to-int (written-after P M)) (to-int (written-after S M))) 4)",
        "(not (written-after F H))"
      ],
      "options": [
        "(written-after H M)",
        "(= (written-after F F) true)",
        "(= (written-after G G) true)",
        "(= (written-after H H) true)",
        "(= (written-after P P) true)",
        "(= (written-after S S) true)"
      ],
      "type": "unsat",
      "perplexity": [
        1.169955849647522,
        1.1083483695983887
      ],
      "answer": "E",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "SyntaxError: invalid syntax. Perhaps you forgot a comma?"
    }
  },
  {
    "id": 119,
    "nl_problem": {
      "context": "A researcher is studying seven manuscripts—F, G, H, L, M, P, and S—to determine their relative ages. It is known that no two manuscripts were written at the same time. The researcher has also determined the following: H was written earlier than S but later than F. P was the next manuscript written after G. At least four of the manuscripts were written earlier than L. At least four of the manuscripts were written later than M. H was not written fifth.",
      "question": "Which one of the following manuscripts CANNOT have been written fourth?",
      "options": [
        "A) F",
        "B) G",
        "C) H",
        "D) P",
        "E) S"
      ]
    },
    "answer": "D",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((Manuscripts 0)) (((F) (G) (H) (L) (M) (P) (S))))",
        "(declare-fun written (Manuscripts) Int)"
      ],
      "constraints": [
        "(forall ((m1 Manuscripts) (m2 Manuscripts)) (and (< 0 (written m1)) (< (written m1) (written m2))))",
        "(and (< (written F) (written H)) (< (written H) (written S)))",
        "(< (written G) (written P))",
        "(>= (+ (to-int (< (written F) (written L))) (to-int (< (written G) (written L))) (to-int (< (written H) (written L))) (to-int (< (written M) (written L))) (to-int (< (written P) (written L))) (to-int (< (written S) (written L)))) 4)",
        "(>= (+ (to-int (> (written F) (written M))) (to-int (> (written G) (written M))) (to-int (> (written H) (written M))) (to-int (> (written L) (written M))) (to-int (> (written P) (written M))) (to-int (> (written S) (written M)))) 4)",
        "(not (= (written H) 4))"
      ],
      "options": [
        "(not (= (written F) 4))",
        "(not (= (written G) 4))",
        "(not (= (written H) 4))",
        "(not (= (written P) 4))",
        "(not (= (written S) 4))"
      ],
      "type": "sat",
      "perplexity": [
        1.0655341148376465,
        1.0978515148162842
      ],
      "answer": "D",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "SyntaxError: invalid syntax. Perhaps you forgot a comma?"
    }
  },
  {
    "id": 120,
    "nl_problem": {
      "context": "A researcher is studying seven manuscripts—F, G, H, L, M, P, and S—to determine their relative ages. It is known that no two manuscripts were written at the same time. The researcher has also determined the following: H was written earlier than S but later than F. P was the next manuscript written after G. At least four of the manuscripts were written earlier than L. At least four of the manuscripts were written later than M. H was not written fifth.",
      "question": "If P was written earlier than H, then any of the following could be true EXCEPT:",
      "options": [
        "A) F was written first.",
        "B) G was written third.",
        "C) H was written sixth.",
        "D) L was written seventh.",
        "E) M was written second."
      ]
    },
    "answer": "D",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((Manuscripts 0)) (((F) (G) (H) (L) (M) (P) (S))))",
        "(declare-fun before (Manuscripts Manuscripts) Bool)",
        "(define-fun to-int ((b Bool)) Int (ite b 1 0))"
      ],
      "constraints": [
        "(forall ((a Manuscripts) (b Manuscripts)) (=> (before a b) (not (= a b))))",
        "(and (before F H) (before H S))",
        "(before G P)",
        ">= (+ (to-int (before F L)) (to-int (before G L)) (to-int (before H L)) (to-int (before M L)) (to-int (before P L)) (to-int (before S L))) 4",
        ">= (+ (to-int (before F M)) (to-int (before G M)) (to-int (before H M)) (to-int (before L M)) (to-int (before P M)) (to-int (before S M))) 4",
        "(not (= (+ 1 (to-int (before F H)) (to-int (before G H)) (to-int (before M H)) (to-int (before P H)) (to-int (before S H))) 5))"
      ],
      "options": [
        "(not (before P H))",
        "(before F P)",
        "(before P L)",
        "(not (or (before F L) (before G L) (before H L) (before M L)))",
        "(before F P)",
        "(before P L)",
        "(not (or (before F L) (before G L) (before H L)))",
        "(before M L)",
        "(before F P)",
        "(before P L)",
        "(not (or (before F L) (before G L) (before M L)))",
        "(before H L)",
        "(before F P)",
        "(before P L)",
        "(not (or (before F L) (before G L)))",
        "(before H L)",
        "(before M L)",
        "(before F P)",
        "(before P L)",
        "(not (or (before F L)))",
        "(before H L)",
        "(before M L)",
        "(before G L)",
        "(before F P)",
        "(before P L)",
        "(not (or (before H L) (before M L)))",
        "(before G L)",
        "(before F L)"
      ],
      "type": "unsat",
      "perplexity": [
        1.124014973640442,
        1.0842878818511963
      ],
      "answer": "D",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "SyntaxError: invalid syntax. Perhaps you forgot a comma?"
    }
  },
  {
    "id": 121,
    "nl_problem": {
      "context": "Exactly six petri dishes—labeled dish 1 through dish 6—are to be stored in an otherwise empty refrigerator. There are three available shelves—the bottom shelf, the middle shelf, and the top shelf. The placement of the dishes must be consistent with the following conditions: No more than three dishes are stored on any shelf. Dish 2 is stored at least one shelf above dish 6. Dish 6 is stored either one shelf above or one shelf below dish 5. Dish 1 is not stored on the same shelf as dish 4.",
      "question": "Which one of the following is an acceptable placement of dishes on the bottom, middle, and top shelves?",
      "options": [
        "A) bottom: dish 1 middle: dish 6 top: dishes 2, 3, 4, 5",
        "B) bottom: dishes 1, 3 middle: dish 6 top: dishes 2, 4, 5",
        "C) bottom: dish 2 middle: dishes 4, 6 top: dishes 1, 3, 5",
        "D) bottom: dishes 3, 5 middle: dish 6 top: dishes 1, 2, 4",
        "E) bottom: dishes 4, 6 middle: dishes 1, 3 top: dishes 2, 5"
      ]
    },
    "answer": "B",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((Dishes 0)) (((dish 1) (dish 2) (dish 3) (dish 4) (dish 5) (dish 6))))",
        "(declare-datatypes ((Shelves 0)) (((bottom) (middle) (top))))",
        "(declare-fun stored (Dishes Shelves) Bool)",
        "(define-fun to-int ((b Bool)) Int (ite b 1 0))"
      ],
      "constraints": [
        "(forall ((s Shelves)) (<= (+ (to-int (stored dish 1 s)) (to-int (stored dish 2 s)) (to-int (stored dish 3 s)) (to-int (stored dish 4 s)) (to-int (stored dish 5 s)) (to-int (stored dish 6 s))) 3))",
        "(forall ((s Shelves)) (=> (or (= s bottom) (= s middle)) (= (stored dish 2 s) (not (stored dish 6 (if (= s middle) top bottom))))))",
        "(forall ((s Shelves)) (or (= (stored dish 6 s) (not (stored dish 5 (if (= s middle) top bottom)))) (= (stored dish 6 s) (not (stored dish 5 (if (= s middle) bottom top))))))",
        "(forall ((s Shelves)) (not (and (stored dish 1 s) (stored dish 4 s))))"
      ],
      "options": [
        "(assert (= (stored dish 1 bottom) true))",
        "(assert (= (stored dish 2 middle) true))",
        "(assert (= (stored dish 3 middle) false))",
        "(assert (= (stored dish 4 middle) false))",
        "(assert (= (stored dish 5 middle) true))",
        "(assert (= (stored dish 6 middle) true))",
        "(check-sat)"
      ],
      "type": "unsat",
      "perplexity": [
        1.0642350912094116,
        1.2549684047698975
      ],
      "answer": "B",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "SyntaxError: invalid syntax. Perhaps you forgot a comma?"
    }
  },
  {
    "id": 122,
    "nl_problem": {
      "context": "Exactly six petri dishes—labeled dish 1 through dish 6—are to be stored in an otherwise empty refrigerator. There are three available shelves—the bottom shelf, the middle shelf, and the top shelf. The placement of the dishes must be consistent with the following conditions: No more than three dishes are stored on any shelf. Dish 2 is stored at least one shelf above dish 6. Dish 6 is stored either one shelf above or one shelf below dish 5. Dish 1 is not stored on the same shelf as dish 4.",
      "question": "If dish 6 is the only dish stored on the bottom shelf, which one of the following could be the list of dishes that are stored together on the middle shelf?",
      "options": [
        "A) dish 1, dish 3",
        "B) dish 2, dish 4",
        "C) dish 2, dish 3",
        "D) dish 3, dish 5",
        "E) dish 4, dish 5"
      ]
    },
    "answer": "E",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((Dishes 0)) (((dish_1) (dish_2) (dish_3) (dish_4) (dish_5) (dish_6))))",
        "(declare-datatypes ((Shelves 0)) (((bottom) (middle) (top))))",
        "(declare-fun stored_on (Dishes Shelves) Bool)",
        "(define-fun to-int ((b Bool)) Int (ite b 1 0))"
      ],
      "constraints": [
        "(forall ((s Shelves)) (>= (+ (to-int (stored_on dish_1 s)) (to-int (stored_on dish_2 s)) (to-int (stored_on dish_3 s)) (to-int (stored_on dish_4 s)) (to-int (stored_on dish_5 s)) (to-int (stored_on dish_6 s))) 3))",
        "(forall ((s1 Shelves) (s2 Shelves)) (or (and (stored_on dish_2 s2) (not (stored_on dish_2 s1)) (not (eq s1 s2))) (and (not (stored_on dish_2 s2)) (stored_on dish_2 s1))))",
        "(forall ((s1 Shelves) (s2 Shelves)) (or (and (stored_on dish_6 s2) (not (stored_on dish_6 s1)) (not (eq s1 s2)) (not (eq s2 top)) (not (eq s2 bottom))) (and (not (stored_on dish_6 s2)) (stored_on dish_6 s1)) (and (stored_on dish_6 s2) (not (stored_on dish_6 s1)) (not (eq s1 s2)) (not (eq s2 middle)) (eq s1 top)) (and (not (stored_on dish_6 s2)) (stored_on dish_6 s1) (eq s2 bottom))))",
        "(forall ((s Shelves)) (or (not (stored_on dish_1 s)) (not (stored_on dish_4 s))))"
      ],
      "options": [
        "(= (stored_on dish_1 middle) (stored_on dish_3 middle))",
        "(= (stored_on dish_2 middle) (stored_on dish_4 middle))",
        "(= (stored_on dish_2 middle) (stored_on dish_3 middle))",
        "(= (stored_on dish_3 middle) (stored_on dish_5 middle))",
        "(= (stored_on dish_4 middle) (stored_on dish_5 middle))"
      ],
      "type": "unsat",
      "perplexity": [
        1.1656707525253296,
        1.0784815549850464
      ],
      "answer": "E",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "SyntaxError: invalid syntax. Perhaps you forgot a comma?"
    }
  },
  {
    "id": 123,
    "nl_problem": {
      "context": "Exactly six petri dishes—labeled dish 1 through dish 6—are to be stored in an otherwise empty refrigerator. There are three available shelves—the bottom shelf, the middle shelf, and the top shelf. The placement of the dishes must be consistent with the following conditions: No more than three dishes are stored on any shelf. Dish 2 is stored at least one shelf above dish 6. Dish 6 is stored either one shelf above or one shelf below dish 5. Dish 1 is not stored on the same shelf as dish 4.",
      "question": "If dish 1, dish 2, and dish 3 are stored on the same shelf as each other, which one of the following could be true?",
      "options": [
        "A) Exactly one of the dishes is stored on the top shelf.",
        "B) Exactly two of the dishes are stored on the top shelf.",
        "C) Exactly two of the dishes are stored on the middle shelf.",
        "D) Exactly three of the dishes are stored on the middle shelf.",
        "E) Exactly three of the dishes are stored on the bottom shelf."
      ]
    },
    "answer": "C",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((Shelves 0)) (((bottom) (middle) (top))))",
        "(declare-datatypes ((Dishes 0)) (((dish_1) (dish_2) (dish_3) (dish_4) (dish_5) (dish_6))))",
        "(declare-fun stored_on (Dishes Shelves) Bool)",
        "(define-fun to-int ((b Bool)) Int (ite b 1 0))"
      ],
      "constraints": [
        "(forall ((s Shelves)) (<= (+ (to-int (stored_on dish_1 s)) (to-int (stored_on dish_2 s)) (to-int (stored_on dish_3 s)) (to-int (stored_on dish_4 s)) (to-int (stored_on dish_5 s)) (to-int (stored_on dish_6 s))) 3))",
        "(or (= (stored_on dish_2 top) true) (and (= (stored_on dish_2 middle) true) (not (= (stored_on dish_6 middle) true))) (and (= (stored_on dish_2 bottom) true) (not (and (= (stored_on dish_6 middle) true) (= (stored_on dish_6 bottom) true))))))",
        "(or (and (= (stored_on dish_6 middle) true) (= (stored_on dish_5 top) true)) (and (= (stored_on dish_6 middle) true) (= (stored_on dish_5 bottom) true)) (and (= (stored_on dish_6 top) true) (= (stored_on dish_5 middle) true)) (and (= (stored_on dish_6 top) true) (= (stored_on dish_5 bottom) true)) (and (= (stored_on dish_6 bottom) true) (= (stored_on dish_5 middle) true)) (and (= (stored_on dish_6 bottom) true) (= (stored_on dish_5 top) true)))",
        "(forall ((s Shelves)) (not (and (= (stored_on dish_1 s) true) (= (stored_on dish_4 s) true))))"
      ],
      "options": [
        "(= (stored_on dish_1 middle) true) (stored_on dish_2 middle) true (stored_on dish_3 middle) true",
        "(exists ((m Shelves)) (and (= (stored_on dish_1 m) true) (= (stored_on dish_2 m) true) (= (stored_on dish_3 m) true) (or (= (to-int (and (= (stored_on dish_1 top) true) (= (stored_on dish_1 top) true))) 1) (= (to-int (and (= (stored_on dish_1 top) true) (= (stored_on dish_1 top) true))) 2))))",
        "(exists ((m Shelves)) (and (= (stored_on dish_1 m) true) (= (stored_on dish_2 m) true) (= (stored_on dish_3 m) true) (or (= (to-int (and (= (stored_on dish_1 middle) true) (= (stored_on dish_1 middle) true))) 1) (= (to-int (and (= (stored_on dish_1 middle) true) (= (stored_on dish_1 middle) true))) 2))))",
        "(exists ((m Shelves)) (and (= (stored_on dish_1 m) true) (= (stored_on dish_2 m) true) (= (stored_on dish_3 m) true) (= (to-int (and (= (stored_on dish_1 middle) true) (= (stored_on dish_1 middle) true))) 2)))",
        "(exists ((m Shelves)) (and (= (stored_on dish_1 m) true) (= (stored_on dish_2 m) true) (= (stored_on dish_3 m) true) (= (to-int (and (= (stored_on dish_1 middle) true) (= (stored_on dish_1 middle) true))) 3)))",
        "(exists ((m Shelves)) (and (= (stored_on dish_1 m) true) (= (stored_on dish_2 m) true) (= (stored_on dish_3 m) true) (= (to-int (and (= (stored_on dish_1 bottom) true) (= (stored_on dish_1 bottom) true))) 3)))"
      ],
      "type": "unsat",
      "perplexity": [
        1.1025432348251343,
        1.0368119478225708
      ],
      "answer": "C",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "SyntaxError: unmatched ')'"
    }
  },
  {
    "id": 124,
    "nl_problem": {
      "context": "Exactly six petri dishes—labeled dish 1 through dish 6—are to be stored in an otherwise empty refrigerator. There are three available shelves—the bottom shelf, the middle shelf, and the top shelf. The placement of the dishes must be consistent with the following conditions: No more than three dishes are stored on any shelf. Dish 2 is stored at least one shelf above dish 6. Dish 6 is stored either one shelf above or one shelf below dish 5. Dish 1 is not stored on the same shelf as dish 4.",
      "question": "If exactly one of the shelves has no dish stored on it, which one of the following must be true?",
      "options": [
        "A) Exactly three of the dishes are stored on the bottom shelf.",
        "B) Exactly three of the dishes are stored on the middle shelf.",
        "C) Dish 1 is stored on the same shelf as dish 5.",
        "D) Dish 2 is stored on the same shelf as dish 3.",
        "E) Dish 4 is stored on the same shelf as dish 5."
      ]
    },
    "answer": "B",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((Shelves 0)) (((bottom_shelf) (middle_shelf) (top_shelf))))",
        "(declare-datatypes ((Dishes 0)) (((dish_1) (dish_2) (dish_3) (dish_4) (dish_5) (dish_6))))",
        "(declare-fun stored (Shelves Dishes) Bool)"
      ],
      "constraints": [
        "(forall ((s Shelves)) (<= (+ (to-int (stored s dish_1)) (to-int (stored s dish_2)) (to-int (stored s dish_3)) (to-int (stored s dish_4)) (to-int (stored s dish_5)) (to-int (stored s dish_6))) 3))",
        "(forall ((s Shelves)) (=> (or (= s bottom_shelf) (= s middle_shelf)) (or (not (stored s dish_2)) (stored (if (= s bottom_shelf) middle_shelf top_shelf) dish_2))))",
        "(forall ((s Shelves)) (=> (and (or (= s bottom_shelf) (= s middle_shelf)) (or (not (stored s dish_6)) (stored (if (= s bottom_shelf) middle_shelf top_shelf) dish_6))) (or (not (stored s dish_5)) (stored (if (= s bottom_shelf) middle_shelf top_shelf) dish_5))))",
        "(forall ((s Shelves)) (=> (and (and (not (not (or (= s bottom_shelf) (= s middle_shelf)))) (or (not (stored s dish_1)) (stored s dish_1)) (or (not (stored s dish_4)) (stored s dish_4))) (not (= (stored s dish_1) (stored s dish_4)))) (not (= (stored s dish_1) (stored s dish_4)))))"
      ],
      "options": [
        "(forall ((m Shelves)) (<= (to-int (stored m dish_1)) 3))",
        "(forall ((m Shelves)) (<= (to-int (stored m dish_2)) 3))",
        "(forall ((m Shelves)) (= (stored m dish_1) (stored m dish_5)))",
        "(forall ((m Shelves)) (= (stored m dish_2) (stored m dish_3)))",
        "(forall ((m Shelves)) (= (stored m dish_4) (stored m dish_5)))"
      ],
      "type": "unsat",
      "perplexity": [
        1.2086775302886963,
        1.0823272466659546
      ],
      "answer": "B",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "SyntaxError: invalid syntax. Perhaps you forgot a comma?"
    }
  },
  {
    "id": 125,
    "nl_problem": {
      "context": "Exactly six petri dishes—labeled dish 1 through dish 6—are to be stored in an otherwise empty refrigerator. There are three available shelves—the bottom shelf, the middle shelf, and the top shelf. The placement of the dishes must be consistent with the following conditions: No more than three dishes are stored on any shelf. Dish 2 is stored at least one shelf above dish 6. Dish 6 is stored either one shelf above or one shelf below dish 5. Dish 1 is not stored on the same shelf as dish 4.",
      "question": "If dish 5 is the only dish stored on the bottom shelf and if exactly two of the dishes are stored on the middle shelf, then which one of the following is a pair of dishes that must be among the dishes stored on the top shelf?",
      "options": [
        "A) dish 1 and dish 2",
        "B) dish 1 and dish 6",
        "C) dish 2 and dish 3",
        "D) dish 2 and dish 4",
        "E) dish 3 and dish 4"
      ]
    },
    "answer": "C",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((Dishes 0)) (((dish1) (dish2) (dish3) (dish4) (dish5) (dish6))))",
        "(declare-datatypes ((Shelves 0)) (((bottom) (middle) (top))))",
        "(declare-fun stored-on (Dishes Shelves) Bool)",
        "(define-fun to-int ((b Bool)) Int (ite b 1 0))"
      ],
      "constraints": [
        "(forall ((s Shelves)) (<= (+ (to-int (stored-on dish1 s)) (to-int (stored-on dish2 s)) (to-int (stored-on dish3 s)) (to-int (stored-on dish4 s)) (to-int (stored-on dish5 s)) (to-int (stored-on dish6 s))) 3))",
        "(forall ((s Shelves)) (=> (stored-on dish6 s) (or (not (stored-on dish2 s)) (distinct (store-on dish2 top) (store-on dish6 top)))))",
        "(forall ((s Shelves)) (=> (not (stored-on dish5 s)) (or (distinct (store-on dish6 s) (store-on dish5 s)) (distinct (store-on dish6 s) (store-on dish5 bottom)))))",
        "(forall ((s Shelves)) (=> (and (stored-on dish1 s) (stored-on dish4 s)) false))",
        "(= (to-int (stored-on dish5 bottom)) 1)",
        "(= (to-int (stored-on dish1 bottom)) 0)",
        "(= (to-int (stored-on dish2 bottom)) 0)",
        "(= (to-int (stored-on dish3 bottom)) 0)",
        "(= (to-int (stored-on dish4 bottom)) 0)",
        "(= (to-int (stored-on dish6 bottom)) 0)",
        "(= (+ (to-int (stored-on dish1 middle)) (to-int (stored-on dish2 middle)) (to-int (stored-on dish3 middle)) (to-int (stored-on dish4 middle)) (to-int (stored-on dish5 middle)) (to-int (stored-on dish6 middle))) 2)"
      ],
      "options": [
        "(= (to-int (stored-on dish1 top)) 1)",
        "(= (to-int (stored-on dish2 top)) 1)",
        "(= (to-int (stored-on dish6 top)) 1)",
        "(= (to-int (stored-on dish1 top)) 1)",
        "(= (to-int (stored-on dish6 top)) 1)",
        "(= (to-int (stored-on dish2 top)) 1)",
        "(= (to-int (stored-on dish4 top)) 1)"
      ],
      "type": "sat",
      "perplexity": [
        1.0899897813796997,
        1.0744723081588745
      ],
      "answer": "C",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "SyntaxError: invalid syntax. Perhaps you forgot a comma?"
    }
  },
  {
    "id": 126,
    "nl_problem": {
      "context": "Exactly six petri dishes—labeled dish 1 through dish 6—are to be stored in an otherwise empty refrigerator. There are three available shelves—the bottom shelf, the middle shelf, and the top shelf. The placement of the dishes must be consistent with the following conditions: No more than three dishes are stored on any shelf. Dish 2 is stored at least one shelf above dish 6. Dish 6 is stored either one shelf above or one shelf below dish 5. Dish 1 is not stored on the same shelf as dish 4.",
      "question": "If exactly one of the dishes is stored on the middle shelf, which one of the following could be the list of dishes stored on the top shelf?",
      "options": [
        "A) dish 1, dish 2",
        "B) dish 1, dish 5",
        "C) dish 2, dish 3",
        "D) dish 3, dish 4",
        "E) dish 3, dish 5"
      ]
    },
    "answer": "A",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((Dishes 0)) (((dish1) (dish2) (dish3) (dish4) (dish5) (dish6))))",
        "(declare-datatypes ((Shelves 0)) (((bottom_shelf) (middle_shelf) (top_shelf))))",
        "(declare-fun stored-on (Dishes Shelves) Bool)",
        "(define-fun to-int ((b Bool)) Int (ite b 1 0))"
      ],
      "constraints": [
        "(forall ((s Shelves)) (<= (+ (to-int (stored-on dish1 s)) (to-int (stored-on dish2 s)) (to-int (stored-on dish3 s)) (to-int (stored-on dish4 s)) (to-int (stored-on dish5 s)) (to-int (stored-on dish6 s))) 3))",
        "(forall ((s Shelves)) (or (and (not (stored-on dish2 bottom_shelf)) (not (stored-on dish2 middle_shelf)) (stored-on dish2 top_shelf)) (and (not (stored-on dish2 bottom_shelf)) (stored-on dish2 middle_shelf)) (stored-on dish2 top_shelf)))",
        "(or (and (not (stored-on dish6 bottom_shelf)) (not (stored-on dish6 top_shelf)) (stored-on dish5 bottom_shelf)) (and (not (stored-on dish6 bottom_shelf)) (not (stored-on dish6 top_shelf)) (stored-on dish5 middle_shelf)) (and (not (stored-on dish6 bottom_shelf)) (stored-on dish6 top_shelf) (not (stored-on dish5 top_shelf))) (and (not (stored-on dish6 bottom_shelf)) (stored-on dish6 top_shelf) (stored-on dish5 middle_shelf)) (and (stored-on dish6 bottom_shelf) (not (stored-on dish5 bottom_shelf)) (not (stored-on dish5 middle_shelf))) (and (stored-on dish6 bottom_shelf) (not (stored-on dish5 bottom_shelf)) (stored-on dish5 top_shelf)))",
        "(forall ((s Shelves)) (or (not (stored-on dish1 s)) (not (stored-on dish4 s))))",
        "(= (+ (to-int (stored-on dish1 middle_shelf)) (to-int (stored-on dish2 middle_shelf)) (to-int (stored-on dish3 middle_shelf)) (to-int (stored-on dish4 middle_shelf)) (to-int (stored-on dish5 middle_shelf)) (to-int (stored-on dish6 middle_shelf))) 1))"
      ],
      "options": [
        "(forall ((d Dishes)) (or (= (stored-on dish1 top_shelf) d) (= (stored-on dish2 top_shelf) d)))",
        "(forall ((d Dishes)) (or (= (stored-on dish1 top_shelf) d) (= (stored-on dish5 top_shelf) d)))",
        "(forall ((d Dishes)) (or (= (stored-on dish2 top_shelf) d) (= (stored-on dish3 top_shelf) d)))",
        "(forall ((d Dishes)) (or (= (stored-on dish3 top_shelf) d) (= (stored-on dish4 top_shelf) d)))",
        "(forall ((d Dishes)) (or (= (stored-on dish3 top_shelf) d) (= (stored-on dish5 top_shelf) d)))"
      ],
      "type": [
        "sat",
        "unsat",
        "unsat",
        "unsat",
        "unsat"
      ],
      "perplexity": [
        1.0729352235794067,
        1.052164077758789
      ],
      "answer": "A",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "SyntaxError: unmatched ')'"
    }
  },
  {
    "id": 127,
    "nl_problem": {
      "context": "A company operates vending machines in four schools: Ferndale, Gladstone, Hafford, and Isley. The company delivers juices in one of its two trucks and snacks in the other truck. Each week, exactly one delivery of juices and exactly one delivery of snacks is made to each school, subject to the following conditions: Snacks must be delivered to Ferndale at some time before they are delivered to Hafford. Gladstone cannot be the fourth school to which juices are delivered. Gladstone must be the third school to which snacks are delivered. The first school to which juices are delivered must be the fourth one to which snacks are delivered.",
      "question": "Which one of the following could be the schedule of deliveries to the schools, from the first to the fourth?",
      "options": [
        "A) Juices: Hafford, Ferndale, Gladstone, Isley Snacks: Ferndale, Isley, Gladstone, Hafford",
        "B) Juices: Hafford, Isley, Ferndale, Gladstone Snacks: Isley, Ferndale, Gladstone, Hafford",
        "C) Juices: Isley, Ferndale, Gladstone, Hafford Snacks: Hafford, Ferndale, Gladstone, Isley",
        "D) Juices: Isley, Gladstone, Ferndale, Hafford Snacks: Ferndale, Gladstone, Hafford, Isley",
        "E) Juices: Isley, Hafford, Gladstone, Ferndale Snacks: Ferndale, Isley, Gladstone, Hafford"
      ]
    },
    "answer": "A",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((Schools 0)) (((Ferndale) (Gladstone) (Hafford) (Isley))))",
        "(declare-datatypes ((Deliveries 0)) (((juices) (snacks))))",
        "(declare-fun delivered-in (Schools Deliveries) Bool)",
        "(define-fun to-int ((b Bool)) Int (ite b 1 0))"
      ],
      "constraints": [
        "(forall ((s Schools)) (= (ite (= 1 (+ (to-int (delivered-in s juices)) (to-int (delivered-in s snacks)))) 1 0) (ite (= 1 (+ (to-int (delivered-in Ferndale juices)) (to-int (delivered-in Ferndale snacks)))) 1 0) (ite (= 1 (+ (to-int (delivered-in Gladstone juices)) (to-int (delivered-in Gladstone snacks)))) 1 0) (ite (= 1 (+ (to-int (delivered-in Hafford juices)) (to-int (delivered-in Hafford snacks)))) 1 0) (ite (= 1 (+ (to-int (delivered-in Isley juices)) (to-int (delivered-in Isley snacks)))) 1 0)))",
        "(forall ((s Schools)) (=> (delivered-in Ferndale snacks) (ite (delivered-in Hafford snacks) (not (delivered-in Ferndale snacks)) true)))",
        "(forall ((s Schools)) (=> (ite (delivered-in Ferndale juices) 1 0) (ite (delivered-in Hafford juices) 1 0) (ite (delivered-in Isley juices) 1 0) (ite (delivered-in Gladstone juices) 1 0) (ite (ite (ite (ite (ite (delivered-in Ferndale juices) 1 0) (delivered-in Hafford juices) 1 0) (delivered-in Isley juices) 1 0) (delivered-in Gladstone juices) 1 0) 1 0 (ite (delivered-in Isley juices) 1 0))))",
        "(forall ((s Schools)) (=> (ite (delivered-in Ferndale snacks) 1 0) (ite (delivered-in Isley snacks) 1 0) (ite (delivered-in Hafford snacks) 1 0) (ite (delivered-in Gladstone snacks) 1 0) (ite (ite (ite (ite (ite (delivered-in Ferndale snacks) 1 0) (delivered-in Isley snacks) 1 0) (delivered-in Hafford snacks) 1 0) (delivered-in Gladstone snacks) 1 0) 1 0 (ite (delivered-in Hafford snacks) 1 0))))",
        "(forall ((s Schools)) (=> (ite (delivered-in Ferndale juices) 1 0) (ite (delivered-in Hafford juices) 1 0) (ite (delivered-in Isley juices) 1 0) (ite (delivered-in Gladstone juices) 1 0) (ite (ite (ite (ite (delivered-in Ferndale juices) 1 0) (delivered-in Hafford juices) 1 0) (delivered-in Isley juices) 1 0) (delivered-in Gladstone juices) 1 0) 1 0 (ite (ite (ite (ite (delivered-in Ferndale snacks) 1 0) (delivered-in Isley snacks) 1 0) (delivered-in Hafford snacks) 1 0) (delivered-in Gladstone snacks) 1 0)))))",
        "((= (delivered-in Ferndale juices) true) (delivered-in Ferndale snacks) true) (delivered-in Hafford juices) true) (delivered-in Hafford snacks) false) (delivered-in Gladstone juices) false) (delivered-in Gladstone snacks) true) (delivered-in Isley juices) true) (delivered-in Isley snacks) false)",
        "((= (delivered-in Ferndale juices) true) (delivered-in Ferndale snacks) false) (delivered-in Hafford juices) true) (delivered-in Hafford snacks) false) (delivered-in Gladstone juices) true) (delivered-in Gladstone snacks) true) (delivered-in Isley juices) true) (delivered-in Isley snacks) false)",
        "((= (delivered-in Ferndale juices) true) (delivered-in Ferndale snacks) false) (delivered-in Hafford juices) false) (delivered-in Hafford snacks) true) (delivered-in Gladstone juices) false) (delivered-in Gladstone snacks) true) (delivered-in Isley juices) true) (delivered-in Isley snacks) true)",
        "((= (delivered-in Ferndale juices) true) (delivered-in Ferndale snacks) false) (delivered-in Hafford juices) false) (delivered-in Hafford snacks) true) (delivered-in Gladstone juices) false) (delivered-in Gladstone snacks) false) (delivered-in Isley juices) true) (delivered-in Isley snacks) true)",
        "((= (delivered-in Ferndale juices) true) (delivered-in Ferndale snacks) false) (delivered-in Hafford juices) false) (delivered-in Hafford snacks) false) (delivered-in Gladstone juices) false) (delivered-in Gladstone snacks) false) (delivered-in Isley juices) true) (delivered-in Isley snacks) true)"
      ],
      "options": [
        "((= (delivered-in Ferndale juices) true) (delivered-in Ferndale snacks) true) (delivered-in Hafford juices) true) (delivered-in Hafford snacks) false) (delivered-in Gladstone juices) false) (delivered-in Gladstone snacks) true) (delivered-in Isley juices) true) (delivered-in Isley snacks) false)",
        "((= (delivered-in Ferndale juices) true) (delivered-in Ferndale snacks) false) (delivered-in Hafford juices) true) (delivered-in Hafford snacks) false) (delivered-in Gladstone juices) true) (delivered-in Gladstone snacks) true) (delivered-in Isley juices) true) (delivered-in Isley snacks) false)",
        "((= (delivered-in Ferndale juices) true) (delivered-in Ferndale snacks) false) (delivered-in Hafford juices) false) (delivered-in Hafford snacks) true) (delivered-in Gladstone juices) false) (delivered-in Gladstone snacks) true) (delivered-in Isley juices) true) (delivered-in Isley snacks) true)",
        "((= (delivered-in Ferndale juices) true) (delivered-in Ferndale snacks) false) (delivered-in Hafford juices) false) (delivered-in Hafford snacks) true) (delivered-in Gladstone juices) false) (delivered-in Gladstone snacks) false) (delivered-in Isley juices) true) (delivered-in Isley snacks) true)",
        "((= (delivered-in Ferndale juices) true) (delivered-in Ferndale snacks) false) (delivered-in Hafford juices) false) (delivered-in Hafford snacks) false) (delivered-in Gladstone juices) false) (delivered-in Gladstone snacks) false) (delivered-in Isley juices) true) (delivered-in Isley snacks) true)"
      ],
      "type": "sat",
      "perplexity": [
        1.1151617765426636,
        1.0276309251785278
      ],
      "answer": "A",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "SyntaxError: unmatched ')'"
    }
  }
]