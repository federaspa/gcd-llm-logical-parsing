[
  {
    "id": 0,
    "nl_problem": {
      "context": "Four boys—Fred, Juan, Marc, and Paul—and three girls—Nita, Rachel, and Trisha—will be assigned to a row of five adjacent lockers, numbered consecutively 1 through 5, arranged along a straight wall. The following conditions govern the assignment of lockers to the seven children: Each locker must be assigned to either one or two children, and each child must be assigned to exactly one locker. Each shared locker must be assigned to one girl and one boy. Juan must share a locker, but Rachel cannot share a locker. Nita's locker cannot be adjacent to Trisha's locker. Fred must be assigned to locker 3.",
      "question": "Which one of the following is a complete and accurate list of the children who must be among those assigned to shared lockers?",
      "options": [
        "A) Fred, Juan",
        "B) Juan, Paul",
        "C) Juan, Marc, Paul",
        "D) Juan, Marc, Trisha",
        "E) Juan, Nita, Trisha"
      ]
    },
    "answer": "E"
  },
  {
    "id": 1,
    "nl_problem": {
      "context": "Four boys—Fred, Juan, Marc, and Paul—and three girls—Nita, Rachel, and Trisha—will be assigned to a row of five adjacent lockers, numbered consecutively 1 through 5, arranged along a straight wall. The following conditions govern the assignment of lockers to the seven children: Each locker must be assigned to either one or two children, and each child must be assigned to exactly one locker. Each shared locker must be assigned to one girl and one boy. Juan must share a locker, but Rachel cannot share a locker. Nita's locker cannot be adjacent to Trisha's locker. Fred must be assigned to locker 3.",
      "question": "If Trisha is assigned to locker 3 and Marc alone is assigned to locker 1, then which one of the following must be true?",
      "options": [
        "A) Juan is assigned to locker 4.",
        "B) Juan is assigned to locker 5.",
        "C) Paul is assigned to locker 2.",
        "D) Rachel is assigned to locker 2.",
        "E) Rachel is assigned to locker 5."
      ]
    },
    "answer": "B"
  },
  {
    "id": 2,
    "nl_problem": {
      "context": "Four boys—Fred, Juan, Marc, and Paul—and three girls—Nita, Rachel, and Trisha—will be assigned to a row of five adjacent lockers, numbered consecutively 1 through 5, arranged along a straight wall. The following conditions govern the assignment of lockers to the seven children: Each locker must be assigned to either one or two children, and each child must be assigned to exactly one locker. Each shared locker must be assigned to one girl and one boy. Juan must share a locker, but Rachel cannot share a locker. Nita's locker cannot be adjacent to Trisha's locker. Fred must be assigned to locker 3.",
      "question": "If the four boys are assigned to consecutively numbered lockers and Juan is assigned to locker 5, then which one of the following is a complete and accurate list of lockers each of which CANNOT be a shared locker?",
      "options": [
        "A) locker 2",
        "B) locker 4",
        "C) locker 1, locker 2",
        "D) locker 1, locker 4",
        "E) locker 2, locker 4"
      ]
    },
    "answer": "D",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((People 0)) (((Fred) (Juan) (Marc) (Paul) (Nita) (Rachel) (Trisha))))",
        "(declare-datatypes ((Lockers 0)) (((locker1) (locker2) (locker3) (locker4) (locker5))))",
        "(declare-fun assigned (People Lockers) Bool)",
        "(declare-fun shared (Lockers) Bool)"
      ],
      "constraints": [
        "(forall ((l Lockers)) (or (exists ((p People)) (assigned p l)) (forall ((p People)) (not (assigned p l))))",
        "(forall ((p People) (l Lockers)) (let ((x (assigned p l))) (= (or (and (distinct p Nita) x) (and (distinct p Rachel) x)) x)))",
        "(forall ((l Lockers)) (=> (shared l) (or (and (assigned Nita l) (assigned (distinct Nita) l)) (and (assigned Rachel l) (assigned (distinct Rachel) l))))",
        "(forall ((p People) (l Lockers)) (=> (and (distinct l locker3) (distinct p Fred)) (not (assigned p l))))",
        "(forall ((l Lockers)) (=> (and (assigned Juan l) (shared l)) l))",
        "(forall ((l Lockers) (p People)) (let ((x (shared l)) (y (assigned p l))) (or (and x y) (and (not x) (not y)))))",
        "(forall ((l Lockers)) (=> (shared l) (not (or (= l locker1) (= l locker2) (= l locker4) (= l locker5))))",
        "(forall ((l Lockers)) (let ((x (shared l))) (or (and x (= l locker3)) (and (not x) (not (= l locker3)))))",
        "(forall ((l Lockers) (p People)) (let ((x (shared l)) (y (assigned p l))) (or (and x y) (and (not x) (not y)))))",
        "(forall ((l Lockers)) (=> (shared l) (not (or (= l locker1) (= l locker2) (= l locker4) (= l locker5))))",
        "(forall ((l Lockers)) (let ((x (shared l))) (or (and x (= l locker3)) (and (not x) (not (= l locker3)))))",
        "(forall ((l Lockers) (p People)) (let ((x (shared l)) (y (assigned p l))) (or (and x y) (and (not x) (not y)))))"
      ],
      "options": [
        "(forall ((l Lockers)) (let ((x (shared l))) (or (and x (= l locker3)) (and (not x) (not (= l locker3)))))",
        "(declare-const Juan_locker_locker5 Bool)",
        "(declare-fun Juan_locker () Lockers)",
        "(define-fun Juan_locker () Lockers (ite Juan_locker_locker5 locker5 (ite (exists ((l Lockers)) (and (shared l) (distinct l locker5))) locker5 locker1)))",
        "(declare-fun locker_order () (List Lockers))",
        "(define-fun locker_order () (List Lockers) (cons locker1 (cons locker2 (cons locker3 (cons locker4 (cons locker5 (nil)))))))",
        "(declare-const locker1_shared Bool)",
        "(declare-const locker2_shared Bool)",
        "(declare-const locker3_shared Bool)",
        "(declare-const locker4_shared Bool)",
        "(declare-const locker5_shared Bool)",
        "(assert (or (and (not locker1_shared) (not locker2_shared) locker3_shared locker4_shared) (and (not locker1_shared) (not locker2_shared) (not locker3_shared) locker4_shared) (and (not locker1_shared) (not locker2_shared) (not locker3_shared) (not locker4_shared)) (and (not locker1_shared) locker2_shared (not locker3_shared) (not locker4_shared))))",
        "(assert (forall ((l Lockers)) (=> (in l locker_order) (not (shared l)))))"
      ],
      "type": "unsat",
      "perplexity": [
        1.2937440872192383,
        1.0552359819412231
      ],
      "answer": "D",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "No Output"
    }
  },
  {
    "id": 3,
    "nl_problem": {
      "context": "Four boys—Fred, Juan, Marc, and Paul—and three girls—Nita, Rachel, and Trisha—will be assigned to a row of five adjacent lockers, numbered consecutively 1 through 5, arranged along a straight wall. The following conditions govern the assignment of lockers to the seven children: Each locker must be assigned to either one or two children, and each child must be assigned to exactly one locker. Each shared locker must be assigned to one girl and one boy. Juan must share a locker, but Rachel cannot share a locker. Nita's locker cannot be adjacent to Trisha's locker. Fred must be assigned to locker 3.",
      "question": "Once Rachel has been assigned to a locker, what is the maximum number of different lockers each of which could be the locker to which Juan is assigned?",
      "options": [
        "A) one",
        "B) two",
        "C) three",
        "D) four",
        "E) five"
      ]
    },
    "answer": "C",
    "logic_problem": {
      "perplexity": [
        1.1976759433746338,
        398.0821838378906
      ],
      "answer": "C",
      "predicted_answer": "N/A",
      "status": "parsing error",
      "error": ""
    }
  },
  {
    "id": 4,
    "nl_problem": {
      "context": "Four boys—Fred, Juan, Marc, and Paul—and three girls—Nita, Rachel, and Trisha—will be assigned to a row of five adjacent lockers, numbered consecutively 1 through 5, arranged along a straight wall. The following conditions govern the assignment of lockers to the seven children: Each locker must be assigned to either one or two children, and each child must be assigned to exactly one locker. Each shared locker must be assigned to one girl and one boy. Juan must share a locker, but Rachel cannot share a locker. Nita's locker cannot be adjacent to Trisha's locker. Fred must be assigned to locker 3.",
      "question": "If the first three lockers are assigned to girls, which one of the following must be true?",
      "options": [
        "A) Juan is assigned to locker 1.",
        "B) Nita is assigned to locker 3.",
        "C) Trisha is assigned to locker 1.",
        "D) Juan is assigned to the same locker as Trisha.",
        "E) Paul is assigned to the same locker as Trisha."
      ]
    },
    "answer": "A",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((People 0)) (((Fred) (Juan) (Marc) (Paul) (Nita) (Rachel) (Trisha))))",
        "(declare-datatypes ((Lockers 0)) (((locker_1) (locker_2) (locker_3) (locker_4) (locker_5))))",
        "(declare-datatypes ((Boys 0)) (((Fred) (Juan) (Marc) (Paul))))",
        "(declare-datatypes ((Girls 0)) (((Nita) (Rachel) (Trisha))))",
        "(declare-fun assigned (People Lockers) Bool)",
        "(declare-fun shared (Lockers) Bool)",
        "(declare-fun boy (People) Bool)",
        "(declare-fun girl (People) Bool)",
        "(declare-fun adjacent (Lockers Lockers) Bool)",
        "(declare-fun to-int ((b Bool)) Int (ite b 1 0))",
        "(declare-fun count (Lockers) Int)",
        "(declare-fun count_people (Lockers) Int)",
        "(declare-fun count_shared (Lockers) Int)",
        "(declare-fun choose ((l Lockers) (p People)) People)"
      ],
      "constraints": [
        "(forall ((l Lockers)) (= (+ (to-int (assigned _ l)) (to-int (assigned _ l))) (ite (shared l) 2 1)))",
        "(forall ((l Lockers)) (= (+ (to-int (assigned _ l)) (to-int (not (assigned _ l)))) (ite (not (shared l)) 1 2)))",
        "(forall ((l Lockers)) (=> (shared l) (and (girl (choose l (boy _))) (boy (choose l (girl _))))))",
        "(exists ((l Lockers)) (and (shared l) (assigned Juan l) (not (assigned Rachel l))))",
        "(forall ((l Lockers)) (=> (shared l) (not (assigned Rachel l))))",
        "(forall ((l1 Lockers) (l2 Lockers)) (=> (shared l1) (not (and (adjacent l1 l2) (or (girl (choose l1 (boy _))) (boy (choose l1 (girl _)))) (or (girl (choose l2 (boy _))) (boy (choose l2 (girl _)))) (or (= Nita (choose l1 (girl _))) (= Trisha (choose l2 (girl _)))))))",
        "(assigned Fred locker_3)",
        "(forall ((l Lockers) (p People)) (= (to-int (first_three_lockers_girls l p)) (ite (= l locker_1) 1 (ite (= l locker_2) 1 (ite (= l locker_3) 0 1)))))",
        "(forall ((l Lockers) (p People)) (= (to-int (first_three_lockers_girls locker_3 p)) 1))",
        "(forall ((l Lockers) (p People)) (=> (and (forall ((i Lockers)) (= (to-int (first_three_lockers_girls i p)) 1)) (= (to-int (first_three_lockers_girls locker_3 p)) 1)) (or (= (to-int (assigned Juan locker_1)) 1) (= (to-int (assigned Nita locker_3)) 1) (= (to-int (assigned Trisha locker_1)) 1) (= (to-int (and (shared locker_3) (and (girl (choose locker_3 (boy _))) (boy (choose locker_3 (girl _))))) ) 1) (= (to-int (and (shared locker_5) (and (girl (choose locker_5 (boy _))) (boy (choose locker_5 (girl _)))) (or (girl (choose locker_3 (boy _))) (boy (choose locker_3 (girl _)))) (or (= Trisha (choose locker_5 (girl _))) (= Paul (choose locker_5 (boy _)))))) 1)))",
        "(forall ((l Lockers) (p People)) (=> (and (forall ((i Lockers)) (= (to-int (first_three_lockers_girls i p)) 1)) (= (to-int (first_three_lockers_girls locker_3 p)) 1)) (or (not (exists ((m Lockers)) (= (assigned Juan m) true))) (not (exists ((m Lockers)) (= (assigned Nita m) true))) (not (exists ((m Lockers)) (= (assigned Trisha m) true))) (not (exists ((m Lockers)) (and (shared m) (and (girl (choose m (boy _))) (boy (choose m (girl _)))))) (not (exists ((m Lockers)) (and (shared m) (and (girl (choose m (boy _))) (boy (choose m (girl _)))) (or (girl (choose locker_3 (boy _))) (boy (choose locker_3 (girl _)))) (or (= Trisha (choose m (girl _))) (= Paul (choose m (boy _)))))))))"
      ],
      "options": [
        "(forall ((l Lockers) (p People)) (= (to-int (assigned Juan locker_1)) 1))"
      ],
      "type": "unsat",
      "perplexity": [
        1.21808922290802,
        1.0579299926757812
      ],
      "answer": "A",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "No Output"
    }
  },
  {
    "id": 5,
    "nl_problem": {
      "context": "Four boys—Fred, Juan, Marc, and Paul—and three girls—Nita, Rachel, and Trisha—will be assigned to a row of five adjacent lockers, numbered consecutively 1 through 5, arranged along a straight wall. The following conditions govern the assignment of lockers to the seven children: Each locker must be assigned to either one or two children, and each child must be assigned to exactly one locker. Each shared locker must be assigned to one girl and one boy. Juan must share a locker, but Rachel cannot share a locker. Nita's locker cannot be adjacent to Trisha's locker. Fred must be assigned to locker 3.",
      "question": "If lockers 1 and 2 are each assigned to one boy and are not shared lockers, then locker 4 must be assigned to",
      "options": [
        "A) Juan",
        "B) Paul",
        "C) Rachel",
        "D) Juan and Nita",
        "E) Marc and Trisha"
      ]
    },
    "answer": "C",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((People 0)) (((Fred) (Juan) (Marc) (Paul) (Nita) (Rachel) (Trisha))))",
        "(declare-datatypes ((Lockers 0)) (((1) (2) (3) (4) (5))))",
        "(declare-datatypes ((Boys 0)) (((Fred) (Juan) (Marc) (Paul)))",
        "(declare-datatypes ((Girls 0)) (((Nita) (Rachel) (Trisha)))",
        "(declare-fun assigned (People Lockers) Bool)",
        "(declare-fun shares (People People) Bool)",
        "(declare-fun shared (Lockers) Bool)"
      ],
      "constraints": [
        "(forall ((p People) (l Lockers)) (= (and (assigned p l) (assigned p l)) (= (shared p p))))",
        "(forall ((l Lockers)) (or (= (shared l) false) (= (shared l) true)))",
        "(forall ((l Lockers)) (= (shared l) (= (shared l) (and (shared l) true))))",
        "(forall ((l Lockers)) (= (and (= (assigned Juan l) true) (shared l)) true))",
        "(forall ((l Lockers)) (= (and (= (assigned Rachel l) true) (shared l)) false))",
        "(forall ((p People)) (= (and (= (assigned p 3) true) (= p Fred)) true))",
        "(forall ((l Lockers)) (=> (and (= (assigned Nita l) true) (= (assigned Trisha l) true)) (= (and (= (abs (- l 3)) 1) (= (abs (- l 3)) 2))) false))"
      ],
      "options": [
        "(forall ((l1 Lockers) (l2 Lockers) (p1 Boys) (p2 Boys)) (=> (= l1 1) (= l2 2) (not (shared p1 p2)) (= (not (shared (ite (= l1 1) (ite (= l2 1) p1 p2) (ite (= l2 2) p1 p2) (ite (= l2 3) p1 p2) (ite (= l2 4) p1 p2) (ite (= l2 5) p1 p2))))) (= (assigned (ite (= l1 1) p1 p2) 4) (ite (= (ite (= l1 1) p1 p2) Juan) Juan Nita))))"
      ],
      "type": "sat",
      "perplexity": [
        1.24186110496521,
        1.07014000415802
      ],
      "answer": "C",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "No Output"
    }
  },
  {
    "id": 6,
    "nl_problem": {
      "context": "A music store carries exactly ten types of CDs—both new and used of each of jazz, opera, pop, rap, and soul. The store is having a sale on some of these types of CDs. The following conditions must apply: Used pop is on sale; new opera is not. If both types of pop are on sale, then all soul is. If both types of jazz are on sale, then no rap is. If neither type of jazz is on sale, then new pop is. If either type of rap is on sale, then no soul is.",
      "question": "Which one of the following could be a complete and accurate list of the types of CDs that are on sale?",
      "options": [
        "A) new jazz, used jazz, used opera, used pop, new rap",
        "B) new jazz, used pop, used rap, new soul",
        "C) used opera, used pop, new rap, used rap",
        "D) used opera, new pop, used pop, new soul",
        "E) used jazz, used pop, new soul, used soul"
      ]
    },
    "answer": "E",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((CDs 0)) (((jazz) (opera) (pop) (rap) (soul) (new_jazz) (used_jazz) (new_opera) (used_opera) (new_pop) (used_pop) (new_rap) (used_rap) (new_soul) (used_soul))))",
        "(declare-datatypes ((Sale 0)) (((none) (all))))",
        "(define-fun to-int ((b Bool)) Int (ite b 1 0))",
        "(declare-fun on-sale (CDs) Sale)"
      ],
      "constraints": [
        "(and (not (on-sale used_pop)) (not pop-used-on-sale))",
        "(not (on-sale new_opera))",
        "(=> (and pop-used-on-sale-1 pop-used-on-sale-2) (on-sale all))",
        "(=> (and pop-used-on-sale-1 pop-used-on-sale-2) (not (on-sale used_pop)))",
        "(=> (and pop-used-on-sale-1 pop-used-on-sale-2) (not (on-sale new_pop)))",
        "(=> (and jazz-used-on-sale-1 jazz-used-on-sale-2) (not (on-sale used_rap)))",
        "(=> (and jazz-used-on-sale-1 jazz-used-on-sale-2) (not (on-sale new_rap)))",
        "(=> (and (not jazz-used-on-sale-3) (not jazz-used-on-sale-4)) (on-sale new_pop))",
        "(=> (or rap-used-on-sale-1 rap-used-on-sale-2) (not (on-sale used_soul)))",
        "(=> (or rap-used-on-sale-1 rap-used-on-sale-2) (not (on-sale new_soul)))"
      ],
      "options": [
        "(and (on-sale new_jazz) (on-sale used_jazz) (on-sale used_opera) (on-sale used_pop) (on-sale new_rap))",
        "(and (on-sale new_jazz) (on-sale used_pop) (on-sale used_rap) (on-sale new_soul))",
        "(and (on-sale used_opera) (on-sale used_pop) (on-sale new_rap) (on-sale used_rap))",
        "(and (on-sale used_opera) (on-sale new_pop) (on-sale used_pop) (on-sale new_soul))",
        "(and (on-sale used_jazz) (on-sale used_pop) (on-sale new_soul) (on-sale used_soul))"
      ],
      "type": "unsat",
      "perplexity": [
        1.1378679275512695,
        1.0767580270767212
      ],
      "answer": "E",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "No Output"
    }
  },
  {
    "id": 7,
    "nl_problem": {
      "context": "A music store carries exactly ten types of CDs—both new and used of each of jazz, opera, pop, rap, and soul. The store is having a sale on some of these types of CDs. The following conditions must apply: Used pop is on sale; new opera is not. If both types of pop are on sale, then all soul is. If both types of jazz are on sale, then no rap is. If neither type of jazz is on sale, then new pop is. If either type of rap is on sale, then no soul is.",
      "question": "If new soul is not on sale, then which one of the following must be true?",
      "options": [
        "A) New rap is not on sale.",
        "B) New rap is on sale.",
        "C) Used opera is not on sale.",
        "D) At least one type of jazz is not on sale.",
        "E) At least one type of pop is not on sale."
      ]
    },
    "answer": "E",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((Types 0)) (((jazz) (opera) (pop) (rap) (soul))))",
        "(declare-datatypes ((SaleTypes 0)) (((new_jazz) (used_jazz) (new_opera) (used_opera) (new_pop) (used_pop) (new_rap) (used_rap) (new_soul) (used_soul))))",
        "(declare-fun is_on_sale (SaleTypes) Bool)",
        "(declare-fun is_sale_type (SaleTypes Types) Bool)"
      ],
      "constraints": [
        "(is_on_sale used_pop)",
        "(not (is_on_sale new_opera))",
        "(=> (and (is_on_sale new_pop) (is_on_sale used_pop)) (is_on_sale new_soul) (is_on_sale used_soul))",
        "(=> (and (is_on_sale new_jazz) (is_on_sale used_jazz)) (not (is_on_sale new_rap)) (not (is_on_sale used_rap)))",
        "(=> (not (is_on_sale new_jazz)) (not (is_on_sale used_jazz)) (is_on_sale new_pop))",
        "(=> (or (is_on_sale new_rap) (is_on_sale used_rap)) (not (is_on_sale new_soul)) (not (is_on_sale used_soul)))",
        "(not (is_on_sale new_soul))"
      ],
      "options": [
        "(=> (not (is_on_sale new_soul)) (not (is_on_sale new_rap)))",
        "(=> (not (is_on_sale new_soul)) (is_on_sale new_rap))",
        "(=> (not (is_on_sale new_soul)) (not (is_on_sale used_opera)))",
        "(=> (not (is_on_sale new_soul)) (or (not (is_on_sale new_jazz)) (not (is_on_sale used_jazz))))",
        "(=> (not (is_on_sale new_soul)) (or (not (is_on_sale new_pop)) (not (is_on_sale used_pop))))"
      ],
      "type": "unsat",
      "perplexity": [
        1.2013522386550903,
        1.0831456184387207
      ],
      "answer": "E",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "No Output"
    }
  },
  {
    "id": 8,
    "nl_problem": {
      "context": "A music store carries exactly ten types of CDs—both new and used of each of jazz, opera, pop, rap, and soul. The store is having a sale on some of these types of CDs. The following conditions must apply: Used pop is on sale; new opera is not. If both types of pop are on sale, then all soul is. If both types of jazz are on sale, then no rap is. If neither type of jazz is on sale, then new pop is. If either type of rap is on sale, then no soul is.",
      "question": "If both types of jazz are on sale, then which one of the following is the minimum number of types of new CDs that could be included in the sale?",
      "options": [
        "A) one",
        "B) two",
        "C) three",
        "D) four",
        "E) five"
      ]
    },
    "answer": "A",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((CDs 0)) (((jazz_new) (jazz_used) (opera_new) (opera_used) (pop_new) (pop_used) (rap_new) (rap_used) (soul_new) (soul_used))))",
        "(declare-datatypes ((Sale 0)) (((true) (false))))",
        "(declare-fun on_sale (CDs) Sale)",
        "(declare-fun min_new (Sale) Int)",
        "(declare-fun used_pop_sale () Sale)",
        "(declare-fun new_opera_not_sale () Sale)",
        "(declare-fun both_pop_sale () Sale)",
        "(declare-fun both_jazz_sale () Sale)",
        "(declare-fun all_soul_sale () Sale)",
        "(declare-fun no_rap_sale () Sale)",
        "(declare-fun new_pop_sale () Sale)",
        "(declare-fun either_rap_sale () Sale)",
        "(declare-fun no_soul_sale () Sale)",
        "(declare-fun one_new_sale () Sale)",
        "(declare-fun two_new_sale () Sale)",
        "(declare-fun three_new_sale () Sale)",
        "(declare-fun four_new_sale () Sale)",
        "(declare-fun five_new_sale () Sale)"
      ],
      "constraints": [
        "(= (on_sale pop_used) used_pop_sale)",
        "(not (= (on_sale opera_new) new_opera_not_sale))",
        "(=> (and (on_sale pop_new) (on_sale pop_used)) all_soul_sale)",
        "(=> (and (on_sale jazz_new) (on_sale jazz_used)) no_rap_sale)",
        "(=> (not (and (on_sale jazz_new) (on_sale jazz_used))) new_pop_sale)",
        "(=> (on_sale (ite true rap_new false rap_used)) no_soul_sale)",
        "(= (on_sale pop_new) (and (on_sale pop_new) (on_sale pop_used)))",
        "(= (on_sale jazz_new) (or (on_sale jazz_new) (on_sale jazz_used)))",
        "(or (not (and (on_sale jazz_new) (on_sale jazz_used))) all_soul_sale)",
        "(or (not (on_sale jazz_new)) (not no_rap_sale))",
        "(or (and (not both_pop_sale) new_pop_sale) (and no_rap_sale no_soul_sale))"
      ],
      "options": [
        "(<= (ite both_jazz_sale one_new_sale 0) min_new)",
        "(<= (ite (not both_jazz_sale) (ite (and new_pop_sale no_rap_sale) two_new_sale (ite (and (not both_pop_sale) new_pop_sale) three_new_sale (ite either_rap_sale three_new_sale four_new_sale five_new_sale))) 0) min_new)"
      ],
      "type": "unsat",
      "perplexity": [
        1.2629040479660034,
        1.078757643699646
      ],
      "answer": "A",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "No Output"
    }
  },
  {
    "id": 9,
    "nl_problem": {
      "context": "A music store carries exactly ten types of CDs—both new and used of each of jazz, opera, pop, rap, and soul. The store is having a sale on some of these types of CDs. The following conditions must apply: Used pop is on sale; new opera is not. If both types of pop are on sale, then all soul is. If both types of jazz are on sale, then no rap is. If neither type of jazz is on sale, then new pop is. If either type of rap is on sale, then no soul is.",
      "question": "Which one of the following CANNOT be true?",
      "options": [
        "A) Neither type of opera and neither type of rap is on sale.",
        "B) Neither type of jazz and neither type of opera is on sale.",
        "C) Neither type of opera and neither type of soul is on sale.",
        "D) Neither type of jazz and neither type of soul is on sale.",
        "E) Neither type of jazz and neither type of rap is on sale."
      ]
    },
    "answer": "D",
    "logic_problem": {
      "perplexity": [
        1.1130223274230957,
        5723.44775390625
      ],
      "answer": "D",
      "predicted_answer": "N/A",
      "status": "parsing error",
      "error": ""
    }
  },
  {
    "id": 10,
    "nl_problem": {
      "context": "A music store carries exactly ten types of CDs—both new and used of each of jazz, opera, pop, rap, and soul. The store is having a sale on some of these types of CDs. The following conditions must apply: Used pop is on sale; new opera is not. If both types of pop are on sale, then all soul is. If both types of jazz are on sale, then no rap is. If neither type of jazz is on sale, then new pop is. If either type of rap is on sale, then no soul is.",
      "question": "If neither type of jazz is on sale, then each of the following must be true EXCEPT:",
      "options": [
        "A) Used opera is on sale.",
        "B) New rap is not on sale.",
        "C) Used rap is not on sale.",
        "D) New soul is on sale.",
        "E) Used soul is on sale."
      ]
    },
    "answer": "A",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((CDTypes 0)) (((new) (used))))",
        "(declare-datatypes ((CDs 0)) (((jazz) (opera) (pop) (rap) (soul))))",
        "(declare-fun on_sale (CDTypes CDs) Bool)",
        "(declare-fun jazz_used (Bool Bool) Bool)",
        "(declare-fun jazz_new (Bool Bool) Bool)",
        "(declare-fun pop_used (Bool Bool) Bool)",
        "(declare-fun pop_new (Bool Bool) Bool)",
        "(declare-fun rap_used (Bool Bool) Bool)",
        "(declare-fun rap_new (Bool Bool) Bool)",
        "(declare-fun soul_used (Bool Bool) Bool)",
        "(declare-fun soul_new (Bool Bool) Bool)",
        "(declare-fun opera_used (Bool Bool) Bool)",
        "(declare-fun opera_new (Bool Bool) Bool)",
        "(define-fun to-int ((b Bool)) Int (ite b 1 0))"
      ],
      "constraints": [
        " (= (on_sale used pop) True)",
        " (not (= (on_sale new opera) True))",
        " (=> (and (= (on_sale used pop) True) (= (on_sale new pop) True)) (= (on_sale used soul) True))",
        " (=> (= (on_sale used jazz) True) (= (on_sale new rap) False))",
        " (=> (not (= (on_sale used jazz) True)) (= (on_sale new pop) True))",
        " (=> (or (= (on_sale used rap) True) (= (on_sale new rap) True)) (= (on_sale used soul) False))",
        "(define-fun jazz_used (b1 b2) Bool (ite (= b1 True) (= b2 True) False))",
        "(define-fun jazz_new (b1 b2) Bool (ite (= b1 True) (= b2 True) False))",
        "(define-fun pop_used (b1 b2) Bool (ite (= b1 True) (= b2 True) False))",
        "(define-fun pop_new (b1 b2) Bool (ite (= b1 True) (= b2 True) False))",
        "(define-fun rap_used (b1 b2) Bool (ite (= b1 True) (= b2 True) False))",
        "(define-fun rap_new (b1 b2) Bool (ite (= b1 True) (= b2 True) False))",
        "(define-fun soul_used (b1 b2) Bool (ite (= b1 True) (= b2 True) False))",
        "(define-fun soul_new (b1 b2) Bool (ite (= b1 True) (= b2 True) False))",
        "(define-fun opera_used (b1 b2) Bool (ite (= b1 True) (= b2 True) False))",
        "(define-fun opera_new (b1 b2) Bool (ite (= b1 True) (= b2 True) False))"
      ],
      "options": [
        "(not (and (not (= (on_sale used jazz) True)) (= (on_sale new opera) True)))",
        "(not (and (not (= (on_sale used jazz) True)) (= (on_sale new rap) False)))",
        "(not (and (not (= (on_sale used jazz) True)) (= (on_sale used rap) False)))",
        "(not (and (not (= (on_sale used jazz) True)) (= (on_sale used soul) True)))",
        "(not (and (not (= (on_sale used jazz) True)) (= (on_sale used soul) False)))"
      ],
      "type": "unsat",
      "perplexity": [
        1.138293981552124,
        1.045220136642456
      ],
      "answer": "A",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "No Output"
    }
  },
  {
    "id": 11,
    "nl_problem": {
      "context": "A music store carries exactly ten types of CDs—both new and used of each of jazz, opera, pop, rap, and soul. The store is having a sale on some of these types of CDs. The following conditions must apply: Used pop is on sale; new opera is not. If both types of pop are on sale, then all soul is. If both types of jazz are on sale, then no rap is. If neither type of jazz is on sale, then new pop is. If either type of rap is on sale, then no soul is.",
      "question": "If new soul is the only type of new CD on sale, then which one of the following CANNOT be true?",
      "options": [
        "A) Used jazz is not on sale.",
        "B) Used opera is not on sale.",
        "C) Used rap is not on sale.",
        "D) Used soul is on sale.",
        "E) Used soul is not on sale."
      ]
    },
    "answer": "A"
  },
  {
    "id": 12,
    "nl_problem": {
      "context": "A music store carries exactly ten types of CDs—both new and used of each of jazz, opera, pop, rap, and soul. The store is having a sale on some of these types of CDs. The following conditions must apply: Used pop is on sale; new opera is not. If both types of pop are on sale, then all soul is. If both types of jazz are on sale, then no rap is. If neither type of jazz is on sale, then new pop is. If either type of rap is on sale, then no soul is.",
      "question": "If exactly four of the five types of used CDs are the only CDs on sale, then which one of the following could be true?",
      "options": [
        "A) Used jazz is not on sale.",
        "B) Used opera is not on sale.",
        "C) Used rap is not on sale.",
        "D) Neither type of jazz is on sale.",
        "E) Neither type of rap and neither type of soul is on sale."
      ]
    },
    "answer": "C",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((CDs 0)) (((new_jazz) (used_jazz) (new_opera) (used_opera) (new_pop) (used_pop) (new_rap) (used_rap) (new_soul) (used_soul))))",
        "(declare-datatypes ((SaleTypes 0)) (((pop) (jazz) (opera) (rap) (soul))))",
        "(declare-fun on_sale (SaleTypes) Bool)",
        "(declare-fun not_on_sale (SaleTypes) Bool)",
        "(declare-fun to-int ((b Bool)) Int (ite b 1 0))"
      ],
      "constraints": [
        "(forall ((t SaleTypes)) (or (on_sale t) (not_on_sale t)))",
        "(not (and (on_sale pop) (not (on_sale new_pop))))",
        "(not (and (on_sale opera) (on_sale new_opera)))",
        "(forall ((p SaleTypes)) (=> (and (on_sale p) (on_sale pop)) (on_sale soul)))",
        "(forall ((p SaleTypes)) (=> (and (on_sale p) (on_sale jazz)) (not (on_sale rap))))",
        "(forall ((p SaleTypes)) (=> (not (on_sale jazz)) (on_sale new_pop)))",
        "(forall ((p SaleTypes)) (=> (or (on_sale p) (on_sale rap)) (not (on_sale soul))))",
        "(not (and (on_sale used_jazz) (on_sale used_pop) (on_sale used_soul) (not (on_sale used_rap)) (not (on_sale used_opera))))",
        "(forall ((p SaleTypes)) (=> (and (on_sale used_jazz) (on_sale used_pop) (on_sale used_soul) (not (on_sale used_rap)) (not (on_sale used_opera))) (not (on_sale p))))",
        "(forall ((p SaleTypes)) (=> (and (on_sale used_jazz) (on_sale used_pop) (on_sale used_soul) (not (on_sale used_rap)) (not (on_sale used_opera))) (on_sale p)))"
      ],
      "options": [
        "(forall ((p SaleTypes)) (=> (and (on_sale used_jazz) (on_sale used_pop) (on_sale used_soul) (not (on_sale used_rap)) (not (on_sale used_opera))) (not (on_sale p))))",
        "(forall ((p SaleTypes)) (=> (and (on_sale used_jazz) (on_sale used_pop) (on_sale used_soul) (not (on_sale used_rap)) (not (on_sale used_opera))) (on_sale p)))",
        "(forall ((p SaleTypes)) (=> (and (on_sale used_jazz) (on_sale used_pop) (on_sale used_soul) (not (on_sale used_rap)) (not (on_sale used_opera))) (not (on_sale p))))",
        "(forall ((p SaleTypes)) (=> (and (on_sale used_jazz) (on_sale used_pop) (on_sale used_soul) (not (on_sale used_rap)) (not (on_sale used_opera))) (not (on_sale p))))",
        "(forall ((p SaleTypes)) (=> (and (on_sale used_jazz) (on_sale used_pop) (on_sale used_soul) (not (on_sale used_rap)) (not (on_sale used_opera))) (not (on_sale p))))"
      ],
      "type": "sat",
      "perplexity": [
        1.1357414722442627,
        1.0564517974853516
      ],
      "answer": "C",
      "predicted_answer": [
        "sat",
        "sat",
        "sat",
        "sat",
        "sat"
      ],
      "status": "success",
      "error": ""
    }
  },
  {
    "id": 13,
    "nl_problem": {
      "context": "During a single week, from Monday through Friday, tours will be conducted of a company's three divisions—Operations, Production, and Sales. Exactly five tours will be conducted that week, one each day. The schedule of tours for the week must conform to the following restrictions: Each division is toured at least once. The Operations division is not toured on Monday. The Production division is not toured on Wednesday. The Sales division is toured on two consecutive days, and on no other days. If the Operations division is toured on Thursday, then the Production division is toured on Friday.",
      "question": "Which one of the following CANNOT be true of the week's tour schedule?",
      "options": [
        "A) The division that is toured on Monday is also toured on Tuesday.",
        "B) The division that is toured on Monday is also toured on Friday.",
        "C) The division that is toured on Tuesday is also toured on Thursday.",
        "D) The division that is toured on Wednesday is also toured on Friday.",
        "E) The division that is toured on Thursday is also toured on Friday."
      ]
    },
    "answer": "C",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((Days 0)) (((Monday) (Tuesday) (Wednesday) (Thursday) (Friday))))",
        "(declare-datatypes ((Divisions 0)) (((Operations) (Production) (Sales))))",
        "(declare-fun tours (Days Divisions) Bool)",
        "(define-fun to-int ((b Bool)) Int (ite b 1 0))",
        "(declare-fun num_tours (Divisions) Int)"
      ],
      "constraints": [
        "(forall ((d Days) (d2 Divisions)) (= (+ (to-int (tours d d2)) (+ (to-int (tours Tuesday d2)) (to-int (tours Wednesday d2)) (to-int (tours Thursday d2)) (to-int (tours Friday d2))) 0) 1))",
        "(not (tours Monday Operations))",
        "(not (tours Wednesday Production))",
        "(forall ((d Days) (d2 Divisions)) (or (= (tours d d2) (tours (ite (> d 0) (+ d 1) 0) d2)) (and (= (tours (ite (> d 0) (+ d 1) 0) d2) (tours (ite (> d 0) (+ d 1) 0) Sales)) (= (tours (ite (> d 0) (+ d 1) 0) d2) (tours d Sales)))))",
        "(forall ((d Days)) (= (+ (to-int (tours d Operations)) (to-int (tours d Production)) (to-int (tours d Sales))) 1))",
        "(forall ((d Days)) (=> (and (= (tours d Operations) (tours d2 Operations)) (= (tours d Production) (tours d2 Production)) (= (tours d Sales) (tours d2 Sales))) (= d d2)))"
      ],
      "options": [
        "(not (forall ((d Days) (d2 Divisions)) (= (tours d d2) (tours (ite (> d 0) (+ d 1) 0) d2)) (and (= (tours (ite (> d 0) (+ d 1) 0) d2) (tours (ite (> d 0) (+ d 1) 0) d)) (= (tours (ite (> d 0) (+ d 1) 0) d) (tours d)))))",
        "(not (forall ((d Days) (d2 Divisions)) (= (tours d d2) (tours (ite (> d 0) (+ d 1) 0) d2)) (and (= (tours (ite (> d 0) (+ d 1) 0) d2) (tours (ite (> d 0) (+ d 1) 0) d)) (= (tours (ite (> d 0) (+ d 1) 0) d)) (tours d d2)))))",
        "(not (forall ((d Days) (d2 Divisions)) (= (tours d d2) (tours (ite (> d 0) (+ d 1) 0) d2)) (and (= (tours (ite (> d 0) (+ d 1) 0) d2) (tours d)) (= (tours d) (tours (ite (> d 0) (+ d 1) 0) d2))))))",
        "(not (forall ((d Days) (d2 Divisions)) (= (tours d d2) (tours (ite (> d 0) (+ d 1) 0) d2)) (and (= (tours (ite (> d 0) (+ d 1) 0) d2) (tours d)) (= (tours d) (tours (ite (> d 0) (+ d 1) 0) Production))))))",
        "(not (forall ((d Days) (d2 Divisions)) (= (tours d d2) (tours (ite (> d 0) (+ d 1) 0) d2)) (and (= (tours (ite (> d 0) (+ d 1) 0) d2) (tours d)) (= (tours d) (tours (ite (> d 0) (+ d 1) 0) d2)))))"
      ],
      "type": "unsat",
      "perplexity": [
        1.1000202894210815,
        1.0366222858428955
      ],
      "answer": "C",
      "predicted_answer": [
        "unsat",
        "unsat",
        "unsat",
        "unsat",
        "unsat"
      ],
      "status": "success",
      "error": ""
    }
  },
  {
    "id": 14,
    "nl_problem": {
      "context": "During a single week, from Monday through Friday, tours will be conducted of a company's three divisions—Operations, Production, and Sales. Exactly five tours will be conducted that week, one each day. The schedule of tours for the week must conform to the following restrictions: Each division is toured at least once. The Operations division is not toured on Monday. The Production division is not toured on Wednesday. The Sales division is toured on two consecutive days, and on no other days. If the Operations division is toured on Thursday, then the Production division is toured on Friday.",
      "question": "If in addition to the Sales division one other division is toured on two consecutive days, then it could be true of the week's tour schedule both that the",
      "options": [
        "A) Production division is toured on Monday and that the Operations division is toured on Thursday",
        "B) Production division is toured on Tuesday and that the Sales division is toured on Wednesday",
        "C) Operations division is toured on Tuesday and that the Production division is toured on Friday",
        "D) Sales division is toured on Monday and that the Operations division is toured on Friday",
        "E) Sales division is toured on Wednesday and that the Production division is toured on Friday"
      ]
    },
    "answer": "B",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((Divisions 0)) (((Operations) (Production) (Sales))))",
        "(declare-datatypes ((Days 0)) (((Monday) (Tuesday) (Wednesday) (Thursday) (Friday))))",
        "(declare-fun toured (Divisions Days) Bool)",
        "(define-fun to-int ((b Bool)) Int (ite b 1 0))"
      ],
      "constraints": [
        "(forall ((d Divisions)) (> (+ (to-int (tourled d Monday)) (to-int (tourled d Tuesday)) (to-int (tourled d Wednesday)) (to-int (tourled d Thursday)) (to-int (tourled d Friday))) 0))",
        "(not (tourled Operations Monday))",
        "(not (tourled Production Wednesday))",
        "(and (or (= (tourled Sales Monday) (tourled Sales Tuesday)) (= (tourled Sales Tuesday) (tourled Sales Wednesday)) (= (tourled Sales Wednesday) (tourled Sales Thursday)) (= (tourled Sales Thursday) (tourled Sales Friday)) (= (tourled Sales Friday) (tourled Sales Monday))) (not (or (= (tourled Sales Monday) (tourled Sales Thursday)) (= (tourled Sales Monday) (tourled Sales Friday)) (= (tourled Sales Monday) (tourled Sales Wednesday)) (= (tourled Sales Tuesday) (tourled Sales Monday)) (= (tourled Sales Tuesday) (tourled Sales Thursday)) (= (tourled Sales Tuesday) (tourled Sales Friday)) (= (tourled Sales Wednesday) (tourled Sales Monday)) (= (tourled Sales Wednesday) (tourled Sales Tuesday)) (= (tourled Sales Wednesday) (tourled Sales Friday)) (= (tourled Sales Thursday) (tourled Sales Monday)) (= (tourled Sales Thursday) (tourled Sales Tuesday)) (= (tourled Sales Thursday) (tourled Sales Wednesday)) (= (tourled Sales Friday) (tourled Sales Monday)) (= (tourled Sales Friday) (tourled Sales Tuesday)) (= (tourled Sales Friday) (tourled Sales Wednesday)))))",
        "(=> (tourled Operations Thursday) (tourled Production Friday))"
      ],
      "options": [
        "(forall ((d Divisions)) (= (tourled Production Monday) (tourled Operations Thursday)))",
        "(forall ((d Divisions)) (= (tourled Production Tuesday) (tourled Sales Wednesday)))",
        "(forall ((d Divisions)) (= (tourled Operations Tuesday) (tourled Production Friday)))",
        "(forall ((d Divisions)) (= (tourled Sales Monday) (tourled Operations Friday)))",
        "(forall ((d Divisions)) (= (tourled Sales Wednesday) (tourled Production Friday)))"
      ],
      "type": "unsat",
      "perplexity": [
        1.0766220092773438,
        1.059118628501892
      ],
      "answer": "B",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "No Output"
    }
  },
  {
    "id": 15,
    "nl_problem": {
      "context": "During a single week, from Monday through Friday, tours will be conducted of a company's three divisions—Operations, Production, and Sales. Exactly five tours will be conducted that week, one each day. The schedule of tours for the week must conform to the following restrictions: Each division is toured at least once. The Operations division is not toured on Monday. The Production division is not toured on Wednesday. The Sales division is toured on two consecutive days, and on no other days. If the Operations division is toured on Thursday, then the Production division is toured on Friday.",
      "question": "If in the week's tour schedule the division that is toured on Tuesday is also toured on Friday, then for which one of the following days must a tour of the Production division be scheduled?",
      "options": [
        "A) Monday",
        "B) Tuesday",
        "C) Wednesday",
        "D) Thursday",
        "E) Friday"
      ]
    },
    "answer": "A",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((Divisions 0)) (((Operations) (Production) (Sales))))",
        "(declare-datatypes ((Days 0)) (((Monday) (Tuesday) (Wednesday) (Thursday) (Friday))))",
        "(declare-fun tours (Days Divisions) Bool)",
        "(define-fun to-int ((b Bool)) Int (ite b 1 0))"
      ],
      "constraints": [
        "(forall ((d Days)) (>= (+ (to-int (tours d Operations)) (to-int (tours d Production)) (to-int (tours d Sales))) 1))",
        "(not (tours Monday Operations))",
        "(not (tours Wednesday Production))",
        "(let ((Sales-Tuesday (tours Tuesday Sales)) (Sales-Friday (tours Friday Sales))) (and (= Sales-Tuesday Sales-Friday) (not (or Sales-Tuesday (or (not (tours Monday Sales)) (not (tours Tuesday Sales)) (not (tours Wednesday Sales)) (not (tours Thursday Sales))))))",
        "(let ((Operations-Thursday (tours Thursday Operations)) (Production-Friday (tours Friday Production))) (=> Operations-Thursday Production-Friday))"
      ],
      "options": [
        "(forall ((d Days)) (= (tours d Production) (tours Tuesday Production)))",
        "(forall ((d Days)) (distinct d Monday))",
        "(forall ((d Days)) (distinct d Tuesday))",
        "(not (forall ((d Days)) (distinct d Wednesday)))",
        "(not (forall ((d Days)) (distinct d Thursday)))",
        "(forall ((d Days)) (distinct d Friday))"
      ],
      "type": "unsat",
      "perplexity": [
        1.2152745723724365,
        1.1083261966705322
      ],
      "answer": "A",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "No Output"
    }
  },
  {
    "id": 16,
    "nl_problem": {
      "context": "During a single week, from Monday through Friday, tours will be conducted of a company's three divisions—Operations, Production, and Sales. Exactly five tours will be conducted that week, one each day. The schedule of tours for the week must conform to the following restrictions: Each division is toured at least once. The Operations division is not toured on Monday. The Production division is not toured on Wednesday. The Sales division is toured on two consecutive days, and on no other days. If the Operations division is toured on Thursday, then the Production division is toured on Friday.",
      "question": "If in the week's tour schedule the division that is toured on Monday is not the division that is toured on Tuesday, then which one of the following could be true of the week's schedule?",
      "options": [
        "A) A tour of the Sales division is scheduled for some day earlier in the week than is any tour of the Production division.",
        "B) A tour of the Operations division is scheduled for some day earlier in the week than is any tour of the Production division.",
        "C) The Sales division is toured on Monday.",
        "D) The Production division is toured on Tuesday.",
        "E) The Operations division is toured on Wednesday."
      ]
    },
    "answer": "E",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((Days 0)) (((Monday) (Tuesday) (Wednesday) (Thursday) (Friday))))",
        "(declare-datatypes ((Divisions 0)) (((Operations) (Production) (Sales))))",
        "(declare-fun tours (Days Divisions) Bool)"
      ],
      "constraints": [
        "(forall ((d Days) (d' Divisions)) (exists ((d1 Days)) (and (distinct d d1) (or (tours d1 d') (tours d1 (if (= d' Operations) Production else Sales))))))",
        "(not (tours Monday Operations))",
        "(not (tours Wednesday Production))",
        "(forall ((d Days) (d' Divisions)) (=> (and (tours d Sales) (tours (ite (distinct d Wednesday) d else (ite (distinct d Thursday) d else (ite (distinct d Friday) d else d))) Sales)) (or (distinct d Monday) (distinct (ite (distinct d Wednesday) d else (ite (distinct d Thursday) d else (ite (distinct d Friday) d else d))) Wednesday))))",
        "(=> (and (tours Thursday Operations) (tours Thursday Production)) (tours Friday Production))"
      ],
      "options": [
        "(forall ((d Days) (d' Divisions)) (=> (and (distinct (tours Monday) (tours Tuesday)) (or (tours Monday Operations) (tours Monday Production) (tours Monday Sales))) (or (exists ((d1 Days)) (and (< d1 Tuesday) (distinct (tours d1 Production) (tours Tuesday)) (or (tours d1 Sales) (tours Tuesday Sales)))) (exists ((d1 Days)) (and (< d1 Tuesday) (distinct (tours d1 Production) (tours Tuesday)) (or (tours d1 Operations) (tours Tuesday Operations)))) (tours Monday Sales) (tours Tuesday Production) (tours Wednesday Operations))))"
      ],
      "type": "sat",
      "perplexity": [
        1.188025712966919,
        1.0912405252456665
      ],
      "answer": "E",
      "predicted_answer": [
        "sat"
      ],
      "status": "success",
      "error": ""
    }
  },
  {
    "id": 17,
    "nl_problem": {
      "context": "During a single week, from Monday through Friday, tours will be conducted of a company's three divisions—Operations, Production, and Sales. Exactly five tours will be conducted that week, one each day. The schedule of tours for the week must conform to the following restrictions: Each division is toured at least once. The Operations division is not toured on Monday. The Production division is not toured on Wednesday. The Sales division is toured on two consecutive days, and on no other days. If the Operations division is toured on Thursday, then the Production division is toured on Friday.",
      "question": "If in the week's tour schedule the division that is toured on Tuesday is also toured on Wednesday, then which one of the following must be true of the week's tour schedule?",
      "options": [
        "A) The Production division is toured on Monday.",
        "B) The Operations division is toured on Tuesday.",
        "C) The Sales division is toured on Wednesday.",
        "D) The Sales division is toured on Thursday.",
        "E) The Production division is toured on Friday."
      ]
    },
    "answer": "A",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((Days 0)) (((Monday) (Tuesday) (Wednesday) (Thursday) (Friday))))",
        "(declare-datatypes ((Divisions 0)) (((Operations) (Production) (Sales))))",
        "(declare-fun toured (Divisions Days) Bool)"
      ],
      "constraints": [
        "(forall ((d Days)) (exists ((o Operations) (p Production) (s Sales)) (= (and (tourered o d) (tourered p d) (tourered s d)) true)))",
        "(not (tourered Operations Monday))",
        "(not (tourered Production Wednesday))",
        "(and (forall ((d1 Days) (d2 Days)) (=> (and (= d1 Tuesday) (= d2 Wednesday)) (distinct d1 d2))) (forall ((d1 Days) (d2 Days) (d3 Days)) (=> (and (= d1 Tuesday) (= d2 Wednesday) (= d3 Thursday)) (distinct d3 d2)) (forall ((d1 Days) (d2 Days) (d3 Days) (d4 Days) (d5 Days)) (=> (and (= d1 Tuesday) (= d2 Wednesday) (= d3 Thursday) (= d4 Friday)) (distinct d3 d4) (distinct d4 d5))))",
        "(=> (tourered Operations Thursday) (tourered Production Friday))",
        "(forall ((d Days) (d1 Days) (d2 Days)) (=> (and (= d1 Tuesday) (= d2 Wednesday)) (tourered (ite (= d Tuesday) Operations (ite (= d Wednesday) Production Sales)) d))"
      ],
      "options": [
        "(tourered Production Monday)",
        "(tourered Operations Tuesday)",
        "(tourered Sales Wednesday)",
        "(tourered Sales Thursday)",
        "(tourered Production Friday)"
      ],
      "type": "sat",
      "perplexity": [
        1.1220773458480835,
        1.0937082767486572
      ],
      "answer": "A",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "No Output"
    }
  },
  {
    "id": 18,
    "nl_problem": {
      "context": "A crew of up to five workers is to install a partition in at most three days. The crew completes five tasks in this order: framing, wallboarding, taping, sanding, priming. The crew is selected from the following list, which specifies exactly the tasks each person can do: George: taping Helena: sanding, priming Inga: framing, priming Kelly: framing, sanding Leanda: wallboarding, taping Maricita: sanding Olaf: wallboarding, priming The following conditions must apply: At least one task is done each day. Taping and priming are done on different days. Each crew member does at least one task during the installation, but no more than one task a day. Each task is done by exactly one worker, completed the day it is started and before the next task begins.",
      "question": "Which one of the following could be a complete and accurate list of the members of the crew?",
      "options": [
        "A) George, Helena, Inga, Kelly",
        "B) George, Helena, Kelly, Leanda",
        "C) Helena, Inga, Kelly, Olaf",
        "D) Helena, Inga, Maricita, Olaf",
        "E) George, Helena, Leanda, Maricita, Olaf"
      ]
    },
    "answer": "B"
  },
  {
    "id": 19,
    "nl_problem": {
      "context": "A crew of up to five workers is to install a partition in at most three days. The crew completes five tasks in this order: framing, wallboarding, taping, sanding, priming. The crew is selected from the following list, which specifies exactly the tasks each person can do: George: taping Helena: sanding, priming Inga: framing, priming Kelly: framing, sanding Leanda: wallboarding, taping Maricita: sanding Olaf: wallboarding, priming The following conditions must apply: At least one task is done each day. Taping and priming are done on different days. Each crew member does at least one task during the installation, but no more than one task a day. Each task is done by exactly one worker, completed the day it is started and before the next task begins.",
      "question": "If the installation takes three days, and if the same two crew members work on the first and third days, then which one of the following could be the pair of crew members who work on those two days?",
      "options": [
        "A) Helena and Inga",
        "B) Inga and Kelly",
        "C) Inga and Leanda",
        "D) Kelly and Olaf",
        "E) Leanda and Olaf"
      ]
    },
    "answer": "D",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((Workers 0)) (((George) (Helena) (Inga) (Kelly) (Leanda) (Maricita) (Olaf))))",
        "(declare-datatypes ((Tasks 0)) (((framing) (wallboarding) (taping) (sanding) (priming))))",
        "(declare-datatypes ((Days 0)) (((day1) (day2) (day3))))",
        "(declare-fun works (Workers Tasks) Bool)",
        "(declare-fun to-int ((b Bool)) Int (ite b 1 0))",
        "(declare-fun george-capabilities () (Set Tasks))",
        "(declare-fun helena-capabilities () (Set Tasks))",
        "(declare-fun inga-capabilities () (Set Tasks))",
        "(declare-fun kelly-capabilities () (Set Tasks))",
        "(declare-fun leanda-capabilities () (Set Tasks))",
        "(declare-fun maricita-capabilities () (Set Tasks))",
        "(declare-fun olaf-capabilities () (Set Tasks))",
        "(declare-fun worker-capabilities (Workers) (Set Tasks))",
        "(define-fun worker-capabilities (w Workers) (Set Tasks) (ite (distinct w George) (george-capabilities) (ite (distinct w Helena) (helena-capabilities) (ite (distinct w Inga) (inga-capabilities) (ite (distinct w Kelly) (kelly-capabilities) (ite (distinct w Leanda) (leanda-capabilities) (ite (distinct w Maricita) (maricita-capabilities) (olaf-capabilities)))))))",
        "(define-fun works (w Workers t Tasks) Bool (in t (worker-capabilities w)))",
        "(declare-fun george-capabilities () (Set Tasks))",
        "(define-fun george-capabilities () (Set Tasks) (insert taping (insert priming (insert framing (insert wallboarding empty)))))",
        "(declare-fun helena-capabilities () (Set Tasks))",
        "(define-fun helena-capabilities () (Set Tasks) (insert sanding (insert priming empty)))",
        "(declare-fun inga-capabilities () (Set Tasks))",
        "(define-fun inga-capabilities () (Set Tasks) (insert framing (insert priming empty)))",
        "(declare-fun kelly-capabilities () (Set Tasks))",
        "(define-fun kelly-capabilities () (Set Tasks) (insert framing (insert sanding empty)))",
        "(declare-fun leanda-capabilities () (Set Tasks))",
        "(define-fun leanda-capabilities () (Set Tasks) (insert wallboarding (insert taping empty)))",
        "(declare-fun maricita-capabilities () (Set Tasks))",
        "(define-fun maricita-capabilities () (Set Tasks) (insert sanding empty))",
        "(declare-fun olaf-capabilities () (Set Tasks))",
        "(define-fun olaf-capabilities () (Set Tasks) (insert wallboarding (insert priming empty)))"
      ],
      "constraints": [
        "(forall ((d Days)) (> (to-int (exists ((w Workers)) (exists ((t Tasks)) (and (works w t) (= d (ite (works w framing) day1 (ite (works w wallboarding) day2 (ite (works w taping) day3 0)) 0))))) 0))",
        "(not (exists ((d1 Days) (d2 Days)) (and (and (exists ((w Workers)) (exists ((t Tasks)) (and (works w taping) (= d1 (ite (works w framing) day1 (ite (works w wallboarding) day2 (ite (works w taping) day3 0)) 0)))) (exists ((w Workers)) (exists ((t Tasks)) (and (works w priming) (= d2 (ite (works w framing) day1 (ite (works w wallboarding) day2 (ite (works w priming) day3 0)) 0)))) (= d1 d2))))",
        "(forall ((d Days)) (= (to-int (exists ((w Workers)) (exists ((t Tasks)) (and (works w t) (= d (ite (works w framing) day1 (ite (works w wallboarding) day2 (ite (works w t) day3 0)) 0))))) (to-int (exists ((w Workers)) (= d (ite (works w framing) day1 (ite (works w wallboarding) day2 (ite (works w taping) day3 0)) 0))))))",
        "(forall ((w Workers) (t Tasks)) (=> (works w t) (not (exists ((d Days) (d' Days) (t' Tasks)) (and (and (works w t) (= d (ite (works w framing) day1 (ite (works w wallboarding) day2 (ite (works w t) day3 0)) 0)) (not (= d d')) (exists ((w' Workers)) (and (works w' t) (= d' (ite (works w' framing) day1 (ite (works w' wallboarding) day2 (ite (works w' t) day3 0)) 0))))))))",
        "(= (to-int (exists ((w1 Workers) (w2 Workers) (d1 Days) (d2 Days)) (and (= d1 day1) (= d2 day3) (and (and (works w1 taping) (works w2 taping)) (and (works w1 framing) (not (works w2 framing)) (or (not (works w2 wallboarding)) (not (works w1 wallboarding))) (or (not (works w1 priming)) (not (works w2 priming))) (not (= w1 w2)) (not (= w2 w1)))))) 1)"
      ],
      "options": [
        "(forall ((w Workers) (d Days)) (=> (= d day1) (exists ((t Tasks)) (and (works w t) (not (exists ((w' Workers)) (and (works w' t) (= d' day2)))))))",
        "(forall ((w Workers) (d Days)) (=> (= d day2) (exists ((t Tasks)) (and (works w t) (not (exists ((w' Workers)) (and (works w' t) (= d' day1)))))))",
        "(forall ((w Workers) (d Days)) (=> (= d day3) (exists ((t Tasks)) (and (works w t) (not (exists ((w' Workers)) (and (works w' t) (= d' day1)))))))",
        "(forall ((w Workers) (d Days)) (=> (= d day3) (exists ((t Tasks)) (and (works w t) (not (exists ((w' Workers)) (and (works w' t) (= d' day2)))))"
      ],
      "type": "unsat",
      "perplexity": [
        1.2133029699325562,
        1.0382781028747559
      ],
      "answer": "D",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "No Output"
    }
  },
  {
    "id": 20,
    "nl_problem": {
      "context": "A crew of up to five workers is to install a partition in at most three days. The crew completes five tasks in this order: framing, wallboarding, taping, sanding, priming. The crew is selected from the following list, which specifies exactly the tasks each person can do: George: taping Helena: sanding, priming Inga: framing, priming Kelly: framing, sanding Leanda: wallboarding, taping Maricita: sanding Olaf: wallboarding, priming The following conditions must apply: At least one task is done each day. Taping and priming are done on different days. Each crew member does at least one task during the installation, but no more than one task a day. Each task is done by exactly one worker, completed the day it is started and before the next task begins.",
      "question": "Each of the following could be a complete and accurate list of the members of the crew EXCEPT:",
      "options": [
        "A) Helena, Inga, Kelly, Maricita",
        "B) Inga, Kelly, Leanda, Olaf",
        "C) George, Helena, Inga, Leanda",
        "D) Inga, Leanda, Maricita, Olaf",
        "E) Kelly, Leanda, Maricita, Olaf"
      ]
    },
    "answer": "A",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((Workers 0)) (((George) (Helena) (Inga) (Kelly) (Leanda) (Maricita) (Olaf))))",
        "(declare-datatypes ((Tasks 0)) (((framing) (wallboarding) (taping) (sanding) (priming))))",
        "(declare-fun does (Workers Tasks) Bool)",
        "(declare-fun day_of (Workers Tasks) Int)",
        "(declare-fun tasks_per_day (Int) Int)",
        "(declare-fun num_days (Int) Int)",
        "(declare-fun can_do ((Workers Tasks)) Bool)",
        "(declare-fun tasks_done (Int) Bool)"
      ],
      "constraints": [
        "(forall ((w Workers) (t Tasks)) (or (and (can_do w taping) (can_do w framing)) (and (can_do w taping) (can_do w wallboarding)) (and (can_do w taping) (can_do w sanding)) (and (can_do w taping) (can_do w priming)) (and (can_do w taping) (= t taping)) (and (can_do w framing) (can_do w priming)) (and (can_do w framing) (can_do w wallboarding)) (and (can_do w framing) (can_do w sanding)) (and (can_do w wallboarding) (can_do w taping)) (and (can_do w wallboarding) (can_do w priming)) (and (can_do w sanding) (can_do w taping)) (and (can_do w sanding) (can_do w priming)) (and (can_do w priming) (can_do w taping)) (and (can_do w priming) (can_do w wallboarding)) (and (can_do w priming) (can_do w sanding)) (and (can_do w priming) (= t priming))))",
        "(forall ((t Tasks)) (forall ((d Int)) (forall ((w Workers)) (=> (does w t) (= day_of w t d) (= tasks_done d) (= 1 (to-int (does w t)))))), (forall ((d Int)) (= tasks_per_day d (to-int (and (tasks_done d) (= 1 (to-int (tasks_done d))))))), (forall ((d Int)) (= (tasks_done d) (or (exists ((w Workers) (t Tasks)) (and (does w t) (= day_of w t d))) (exists ((w1 Workers) (t1 Tasks)) (exists ((w2 Workers) (t2 Tasks)) (exists ((w3 Workers) (t3 Tasks)) (and (and (and (and (and (not (= day_of w1 t1 d)) (not (= day_of w2 t2 d)) (not (= day_of w3 t3 d)) (= day_of w1 t1 (ite (not (exists ((w4 Workers) (t4 Tasks)) (and (and (and (and (and (not (= day_of w2 t2 (ite (not (exists ((w4 Workers) (t4 Tasks)) (and (and (and (and (and (not (= day_of w3 t3 (ite (not (exists ((w4 Workers) (t4 Tasks)) (and (and (and (and (and (not (= day_of w3 t3 d)) (= day_of w1 t1 d)) (= day_of w3 t3 d)) (= day_of w2 t2 d)) (= day_of w1 t1 (ite (not (exists ((w5 Workers) (t5 Tasks)) (and (and (and (and (not (= day_of w5 t5 d)) (= day_of w1 t1 d)) (= day_of w3 t3 d)) (= day_of w2 t2 d)) (= day_of w1 t1 d)))) d)) (= day_of w3 t3 d)) (= day_of w2 t2 d)) (= day_of w1 t1 d)) (= tasks_done d)) (not (= tasks_done d)) (or (= (tasks_per_day d) 1) (= (tasks_per_day d) 2) (= (tasks_per_day d) 3) (= (tasks_per_day d) 4) (= (tasks_per_day d) 5))))) (and (and (and (and (not (= day_of w3 t3 (ite (not (exists ((w4 Workers) (t4 Tasks)) (and (and (and (and (and (not (= day_of w3 t3 d)) (= day_of w1 t1 d)) (= day_of w3 t3 d)) (= day_of w2 t2 d)) (= day_of w1 t1 (ite (not (exists ((w5 Workers) (t5 Tasks)) (and (and (and (and (not (= day_of w5 t5 d)) (= day_of w1 t1 d)) (= day_of w3 t3 d)) (= day_of w2 t2 d)) (= day_of w1 t1 d)))) d) (= day_of w2 t2 d)) (= day_of w1 t1 d)) (= tasks_done d)) (not (= tasks_done d)) (or (= (tasks_per_day d) 1) (= (tasks_per_day d) 2) (= (tasks_per_day d) 3) (= (tasks_per_day d) 4) (= (tasks_per_day d) 5)))) (and (and (not (= day_of w2 t2 (ite (not (exists ((w4 Workers) (t4 Tasks)) (and (and (and (and (and (not (= day_of w3 t3 (ite (not (exists ((w4 Workers) (t4 Tasks)) (and (and (and (and (and (not (= day_of w3 t3 d)) (= day_of w1 t1 d)) (= day_of w3 t3 d)) (= day_of w2 t2 d)) (= day_of w1 t1 (ite (not (exists ((w5 Workers) (t5 Tasks)) (and (and (and (and (not (= day_of w5 t5 d)) (= day_of w1 t1 d)) (= day_of w3 t3 d)) (= day_of w2 t2 d)) (= day_of w1 t1 d)))) d)) (= day_of w3 t3 d)) (= day_of w2 t2 d)) (= day_of w1 t1 d)) (= tasks_done d)) (not (= tasks_done d)) (or (= (tasks_per_day d) 1) (= (tasks_per_day d) 2) (= (tasks_per_day d) 3) (= (tasks_per_day d) 4) (= (tasks_per_day d) 5)))) (and (and (not (= day_of w1 t1 (ite (not (exists ((w4 Workers) (t4 Tasks)) (and (and (and (and (and (not (= day_of w2 t2 (ite (not (exists ((w4 Workers) (t4 Tasks)) (and (and (and (and (and (not (= day_of w3 t3 (ite (not (exists ((w4 Workers) (t4 Tasks)) (and (and (and (and (and (not (= day_of w3 t3 d)) (= day_of w1 t1 d)) (= day_of w3 t3 d)) (= day_of w2 t2 d)) (= day_of w1 t1 (ite (not (exists ((w5 Workers) (t5 Tasks)) (and (and (and (and (not (= day_of w5 t5 d)) (= day_of w1 t1 d)) (= day_of w3 t3 d)) (= day_of w2 t2 d)) (= day_of w1 t1 d)))) d)) (= day_of w3 t3 d)) (= day_of w2 t2 d)) (= day_of w1 t1 d)) (= tasks_done d)) (not (= tasks_done d)) (or (= (tasks_per_day d) 1) (= (tasks_per_day d) 2) (= (tasks_per_day d) 3) (= (tasks_per_day d) 4) (= (tasks_per_day d) 5)))) (and (and (not (= day_of w2 t2 (ite (not (exists ((w4 Workers) (t4 Tasks)) (and (and (and (and (and (not (= day_of w3 t3 (ite (not (exists ((w4 Workers) (t4 Tasks)) (and (and (and (and (and (not (= day_of w3 t3 d)) (= day_of w1 t1 d)) (= day_of w3 t3 d)) (= day_of w2 t2 d)) (= day_of w1 t1 (ite (not (exists ((w5 Workers) (t5 Tasks)) (and (and (and (and (not (= day_of w5 t5 d)) (= day_of w1 t1 d)) (= day_of w3 t3 d)) (= day_of w2 t2 d)) (= day_of w1 t1 d)))) d)) (= day_of w3 t3 d)) (= day_of w2 t2 d)) (= day_of w1 t1 d)) (= tasks_done d)) (not (= tasks_done d)) (or (= (tasks_per_day d) 1) (= (tasks_per_day d) 2) (= (tasks_per_day d) 3) (= (tasks_per_day d) 4) (= (tasks_per_day d) 5))))) (and (and (not (= day_of w3 t3 (ite (not (exists ((w4 Workers) (t4 Tasks)) (and (and (and (and (and (not (= day_of w3 t3 d)) (= day_of w1 t1 d)) (= day_of w3 t3 d)) (= day_of w2 t2 d)) (= day_of w1 t1 (ite (not (exists ((w5 Workers) (t5 Tasks)) (and (and (and (and (not (= day_of w5 t5 d)) (= day_of w1 t1 d)) (= day_of w3 t3 d)) (= day_of w2 t2 d)) (= day_of w1 t1 d)))) d) (= day_of w2 t2 d)) (= day_of w1 t1 d)) (= tasks_done d)) (not (= tasks_done d)) (or (= (tasks_per_day d) 1) (= (tasks_per_day d) 2) (= (tasks_per_day d) 3) (= (tasks_per_day d) 4) (= (tasks_per_day d) 5))))) (exists ((w4 Workers) (t4 Tasks)) (and (and (and (and (not (= day_of w4 t4 d)) (= day_of w1 t1 d)) (= day_of w3 t3 d)) (= day_of w2 t2 d)) (= day_of w1 t1 (ite (not (exists ((w5 Workers) (t5 Tasks)) (and (and (and (and (not (= day_of w5 t5 d)) (= day_of w1 t1 d)) (= day_of w3 t3 d)) (= day_of w2 t2 d)) (= day_of w1 t1 d)))) d)))) (exists ((w5 Workers) (t5 Tasks)) (and (and (and (and (not (= day_of w5 t5 d)) (= day_of w2 t2 d)) (= day_of w3 t3 d)) (= day_of w1 t1 d)) (= day_of w2 t2 (ite (not (exists ((w4 Workers) (t4 Tasks)) (and (and (and (and (and (not (= day_of w4 t4 d)) (= day_of w1 t1 d)) (= day_of w3 t3 d)) (= day_of w2 t2 d)) (= day_of w1 t1 d)))) d))))) (exists ((w4 Workers) (t4 Tasks)) (and (and (and (and (not (= day_of w4 t4 d)) (= day_of w1 t1 d)) (= day_of w3 t3 d)) (= day_of w2 t2 d)) (= day_of w1 t1 (ite (not (exists ((w5 Workers) (t5 Tasks)) (and (and (and (and (not (= day_of w5 t5 d)) (= day_of w1 t1 d)) (= day_of w3 t3 d)) (= day_of w2 t2 d)) (= day_of w1 t1 d)))) d)))) (exists ((w5 Workers) (t5 Tasks)) (and (and (and (and (not (= day_of w5 t5 d)) (= day_of w2 t2 d)) (= day_of w3 t3 d)) (= day_of w1 t1 d)) (= day_of w2 t2 (ite (not (exists ((w4 Workers) (t4 Tasks)) (and (and (and (and (and (not (= day_of w4 t4 d)) (= day_of w1 t1 d)) (= day_of w3 t3 d)) (= day_of w2 t2 d)) (= day_of w1 t1 d)))) d))))) (exists ((w4 Workers) (t4 Tasks)) (and (and (and (and (not (= day_of w4 t4 d)) (= day_of w1 t1 d)) (= day_of w3 t3 d)) (= day_of w2 t2 d)) (= day_of w1 t1 (ite (not (exists ((w5 Workers) (t5 Tasks)) (and (and (and (and (not (= day_of w5 t5 d)) (= day_of w1 t1 d)) (= day_of w3 t3 d)) (= day_of w2 t2 d)) (= day_of w1 t1 d)))) d)))) (exists ((w5 Workers) (t5 Tasks)) (and (and (and (and (not (= day_of w5 t5 d)) (= day_of w2 t2 d)) (= day_of w3 t3 d)) (= day_of w1 t1 d)) (= day_of w2 t2 (ite (not (exists ((w4 Workers) (t4 Tasks)) (and (and (and (and (and (not (= day_of w4 t4 d)) (= day_of w1 t1 d)) (= day_of w3 t3 d)) (= day_of w2 t2 d)) (= day_of w1 t1 d)))) d))))) (exists ((w4 Workers) (t4 Tasks)) (and (and (and (and (not (= day_of w4 t4 d)) (= day_of w2 t2 d)) (= day_of w3 t3 d)) (= day_of w1 t1 d)) (= day_of w2 t2 (ite (not (exists ((w5 Workers) (t5 Tasks)) (and (and (and (and (not (= day_of w5 t5 d)) (= day_of w2 t2 d)) (= day_of w3 t3 d)) (= day_of w1 t1 d)) (= day_of w2 t2 d)))) d)))) (exists ((w5 Workers) (t5 Tasks)) (and (and (and (and (not (= day_of w5 t5 d)) (= day_of w2 t2 d)) (= day_of w3 t3 d)) (= day_of w1 t1 d)) (= day_of w2 t2 (ite (not (exists ((w4 Workers) (t4 Tasks)) (and (and (and (and (and (not (= day_of w4 t4 d)) (= day_of w2 t2 d)) (= day_of w3 t3 d)) (= day_of w1 t1 d)) (= day_of w2 t2 d)))) d))))) (exists ((w4 Workers) (t4 Tasks)) (and (and (and (and (not (= day_of w4 t4 d)) (= day_of w2 t2 d)) (= day_of w3 t3 d)) (= day_of w1 t1 d)) (= day_of w2 t2 (ite (not (exists ((w5 Workers) (t5 Tasks)) (and (and (and (and (not (= day_of w5 t5 d)) (= day_of w2 t2 d)) (= day_of w3 t3 d)) (= day_of w1 t1 d)) (= day_of w2 t2 d)))) d))))) (exists ((w5 Workers) (t5 Tasks)) (and (and (and (and (not (= day_of w5 t5 d)) (= day_of w2 t2 d)) (= day_of w3 t3 d)) (= day_of w1 t1 d)) (= day_of w2 t2 (ite (not (exists ((w4 Workers) (t4 Tasks)) (and (and (and (and (and (not (= day_of w4 t4 d)) (= day_of w2 t2 d)) (= day_of w3 t3 d)) (= day_of w1 t1 d)) (= day_of w2 t2 d)))) d))))) (not (= tasks_done d)) (or (= (tasks_per_day d) 1) (= (tasks_per_day d) 2) (= (tasks_per_day d) 3) (= (tasks_per_day d) 4) (= (tasks_per_day d) 5))))))))) (forall ((w1 Workers) (w2 Workers) (t Tasks)) (not (and (= (does w1 taping) (does w2 priming)) (= day_of w1 taping (ite (exists ((w4 Workers) (t4 Tasks)) (and (and (and (and (and (not (= day_of w2 t2 (ite (not (exists ((w4 Workers) (t4 Tasks)) (and (and (and (and (and (not (= day_of w3 t3 (ite (not (exists ((w4 Workers) (t4 Tasks)) (and (and (and (and (and (not (= day_of w3 t3 d)) (= day_of w1 t1 d)) (= day_of w3 t3 d)) (= day_of w2 t2 d)) (= day_of w1 t1 (ite (not (exists ((w5 Workers) (t5 Tasks)) (and (and (and (and (not (= day_of w5 t5 d)) (= day_of w1 t1 d)) (= day_of w3 t3 d)) (= day_of w2 t2 d)) (= day_of w1 t1 d)))) d)) (= day_of w3 t3 d)) (= day_of w2 t2 d)) (= day_of w1 t1 d)) (= tasks_done d)) (not (= tasks_done d)) (or (= (tasks_per_day d) 1) (= (tasks_per_day d) 2) (= (tasks_per_day d) 3) (= (tasks_per_day d) 4) (= (tasks_per_day d) 5))))) (and (and (and (and (not (= day_of w3 t3 (ite (not (exists ((w4 Workers) (t4 Tasks)) (and (and (and (and (and (not (= day_of w3 t3 d)) (= day_of w1 t1 d)) (= day_of w3 t3 d)) (= day_of w2 t2 d)) (= day_of w1 t1 (ite (not (exists ((w5 Workers) (t5 Tasks)) (and (and (and (and (not (= day_of w5 t5 d)) (= day_of w1 t1 d)) (= day_of w3 t3 d)) (= day_of w2 t2 d)) (= day_of w1 t1 d)))) d) (= day_of w2 t2 d)) (= day_of w1 t1 d)) (= tasks_done d)) (not (= tasks_done d)) (or (= (tasks_per_day d) 1) (= (tasks_per_day d) 2) (= (tasks_per_day d) 3) (= (tasks_per_day d) 4) (= (tasks_per_day d) 5)))) (and (and (not (= day_of w2 t2 (ite (not (exists ((w4 Workers) (t4 Tasks)) (and (and (and (and (and (not (= day_of w3 t3 (ite (not (exists ((w4 Workers) (t4 Tasks)) (and (and (and (and (and (not (= day_of w3 t3 d)) (= day_of w1 t1 d)) (= day_of w3 t3 d)) (= day_of w2 t2 d)) (= day_of w1 t1 (ite (not (exists ((w5 Workers) (t5 Tasks)) (and (and (and (and (not (= day_of w5 t5 d)) (= day_of w1 t1 d)) (= day_of w3 t3 d)) (= day_of w2 t2 d)) (= day_of w1 t1 d)))) d)) (= day_of w3 t3 d)) (= day_of w2 t2 d)) (= day_of w1 t1 d)) (= tasks_done d)) (not (= tasks_done d)) (or (= (tasks_per_day d) 1) (= (tasks_per_day d) 2) (= (tasks_per_day d) 3) (= (tasks_per_day d) 4) (= (tasks_per_day d) 5))))) (and (and (not (= day_of w1 t1 (ite (not (exists ((w4 Workers) (t4 Tasks)) (and (and (and (and (and (not (= day_of w2 t2 (ite (not (exists ((w4 Workers) (t4 Tasks)) (and (and (and (and (and (not (= day_of w3 t3 (ite (not (exists ((w4 Workers) (t4 Tasks)) (and (and (and (and (and (not (= day_of w3 t3 d)) (= day_of w1 t1 d)) (= day_of w3 t3 d)) (= day_of w2 t2 d)) (= day_of w1 t1 (ite (not (exists ((w5 Workers) (t5 Tasks)) (and (and (and (and (not (= day_of w5 t5 d)) (= day_of w1 t1 d)) (= day_of w3 t3 d)) (= day_of w2 t2 d)) (= day_of w1 t1 d)))) d)) (= day_of w3 t3 d)) (= day_of w2 t2 d)) (= day_of w1 t1 d)) (= tasks_done d)) (not (= tasks_done d)) (or (= (tasks_per_day d) 1) (= (tasks_per_day d) 2) (= (tasks_per_day d) 3) (= (tasks_per_day d) 4) (= (tasks_per_day d) 5)))) (and (and (not (= day_of w2 t2 (ite (not (exists ((w4 Workers) (t4 Tasks)) (and (and (and (and (and (not (= day_of w3 t3 (ite (not (exists ((w4 Workers) (t4 Tasks)) (and (and (and (and (and (not (= day_of w3 t3 d)) (= day_of w1 t1 d)) (= day_of w3 t3 d)) (= day_of w2 t2 d)) (= day_of w1 t1 (ite (not (exists ((w5 Workers) (t5 Tasks)) (and (and (and (and (not (= day_of w5 t5 d)) (= day_of w1 t1 d)) (= day_of w3 t3 d)) (= day_of w2 t2 d)) (= day_of w1 t1 d)))) d)) (= day_of w3 t3 d)) (= day_of w2 t2 d)) (= day_of w1 t1 d)) (= tasks_done d)) (not (= tasks_done d)) (or (= (tasks_per_day d) 1) (= (tasks_per_day d) 2) (= (tasks_per_day d) 3) (= (tasks_per_day d) 4) (= (tasks_per_day d) 5))))) (and (and (not (= day_of w3 t3 (ite (not (exists ((w4 Workers) (t4 Tasks)) (and (and (and (and (and (not (= day_of w3 t3 d)) (= day_of w1 t1 d)) (= day_of w3 t3 d)) (= day_of w2 t2 d)) (= day_of w1 t1 (ite (not (exists ((w5 Workers) (t5 Tasks)) (and (and (and (and (not (= day_of w5 t5 d)) (= day_of w1 t1 d)) (= day_of w3 t3 d)) (= day_of w2 t2 d)) (= day_of w1 t1 d)))) d) (= day_of w2 t2 d)) (= day_of w1 t1 d)) (= tasks_done d)) (not (= tasks_done d)) (or (= (tasks_per_day d) 1) (= (tasks_per_day d) 2) (= (tasks_per_day d) 3) (= (tasks_per_day d) 4) (= (tasks_per_day d) 5))))))))) (forall ((w Workers)) (exists ((t Tasks)) (does w t)))",
        "(forall ((w Workers) (t Tasks) (d Int)) (=> (and (does w t) (= day_of w t d)) (not (exists ((t2 Tasks)) (and (does w t2) (= day_of w t2 d)))))",
        "(forall ((t Tasks)) (exists ((w Workers)) (exists ((d Int)) (and (does w t) (= day_of w t d))))",
        "(= (+ (to-int (can_do George framing)) (to-int (can_do George taping)) (to-int (can_do George sanding)) (to-int (can_do George priming)) (to-int (can_do Helena sanding)) (to-int (can_do Helena priming)) (to-int (can_do Inga framing)) (to-int (can_do Inga priming)) (to-int (can_do Kelly framing)) (to-int (can_do Kelly sanding)) (to-int (can_do Leanda wallboarding)) (to-int (can_do Leanda taping)) (to-int (can_do Maricita sanding)) (to-int (can_do Maricita priming)) (to-int (can_do Olaf wallboarding)) (to-int (can_do Olaf priming))) 5)",
        "(forall ((c Workers) (w1 Workers) (w2 Workers)) (or (not (= w1 c)) (not (= w2 c)) (not (= w1 c)) (not (= w2 c)) (not (= w1 c)) (not (= w2 c)) (not (= w1 c)) (not (= w2 c)) (not (= w1 c)) (not (= w2 c)) (not (= w1 c)) (not (= w2 c)) (not (= w1 c)) (not (= w2 c)) (not (= w1 c)) (not (= w2 c))))",
        "(assert-not (forall ((c Workers) (w1 Workers) (w2 Workers)) (= c (or (and w1 George w2 Inga) (and w1 George w2 Leanda) (and w1 George w2 Olaf) (and w1 Kelly w2 Inga) (and w1 Kelly w2 Leanda) (and w1 Kelly w2 Maricita) (and w1 Kelly w2 Olaf))))",
        "(check-sat)"
      ],
      "options": [
        "(forall ((c Workers) (w1 Workers) (w2 Workers)) (or (not (= w1 c)) (not (= w2 c)) (not (= w1 c)) (not (= w2 c)) (not (= w1 c)) (not (= w2 c)) (not (= w1 c)) (not (= w2 c)) (not (= w1 c)) (not (= w2 c)) (not (= w1 c)) (not (= w2 c)) (not (= w1 c)) (not (= w2 c)) (not (= w1 c)) (not (= w2 c))))",
        "(assert-not (forall ((c Workers) (w1 Workers) (w2 Workers)) (= c (or (and w1 George w2 Inga) (and w1 George w2 Leanda) (and w1 George w2 Olaf) (and w1 Kelly w2 Inga) (and w1 Kelly w2 Leanda) (and w1 Kelly w2 Maricita) (and w1 Kelly w2 Olaf))))",
        "(check-sat)"
      ],
      "type": "unsat",
      "perplexity": [
        1.2027686834335327,
        1.0217567682266235
      ],
      "answer": "A",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "No Output"
    }
  },
  {
    "id": 21,
    "nl_problem": {
      "context": "A crew of up to five workers is to install a partition in at most three days. The crew completes five tasks in this order: framing, wallboarding, taping, sanding, priming. The crew is selected from the following list, which specifies exactly the tasks each person can do: George: taping Helena: sanding, priming Inga: framing, priming Kelly: framing, sanding Leanda: wallboarding, taping Maricita: sanding Olaf: wallboarding, priming The following conditions must apply: At least one task is done each day. Taping and priming are done on different days. Each crew member does at least one task during the installation, but no more than one task a day. Each task is done by exactly one worker, completed the day it is started and before the next task begins.",
      "question": "If the installation takes three days, and if the sanding is done on the third day, then which one of the following could be a list of all the crew members who work on the second day?",
      "options": [
        "A) Inga",
        "B) Kelly",
        "C) Olaf",
        "D) George and Helena",
        "E) Leanda and Olaf"
      ]
    },
    "answer": "E",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((Workers 0)) (((George) (Helena) (Inga) (Kelly) (Leanda) (Maricita) (Olaf))))",
        "(declare-datatypes ((Days 0)) (((day1) (day2) (day3))))",
        "(declare-datatypes ((Tasks 0)) (((framing) (wallboarding) (taping) (sanding) (priming))))",
        "(declare-fun to-int ((b Bool)) Int (ite b 1 0))",
        "(declare-fun works (Workers Tasks) Bool)",
        "(declare-fun tasks_per_day (Days) Int (ite (= day1 %d) 1 (ite (= day2 %d) 2 3)))",
        "(declare-fun tasks_per_worker (Workers) Int (ite (= George %w) 1 (ite (= Helena %w) 2 (ite (= Inga %w) 3 (ite (= Kelly %w) 3 (ite (= Leanda %w) 2 (ite (= Maricita %w) 1 (ite (= Olaf %w) 2 0))))))))",
        "(declare-fun tasks_per_day_worker (Workers Days) Int (ite (= day1 %d) (to-int (works %w framing)) (ite (= day2 %d) (to-int (works %w (ite (= tasks_per_day day2) wallboarding taping))))) (ite (= day3 %d) (to-int (works %w (ite (= tasks_per_day day3) sanding priming)))))",
        "(declare-fun total_tasks (Workers) Int (ite (= George %w) 1 (ite (= Helena %w) 2 (ite (= Inga %w) 3 (ite (= Kelly %w) 3 (ite (= Leanda %w) 2 (ite (= Maricita %w) 1 (ite (= Olaf %w) 2 0)))))))",
        "(declare-fun total_tasks_per_day (Workers Days) Int (ite (= day1 %d) (to-int (works %w framing)) (ite (= day2 %d) (ite (= day2 %d) 2 (+ 1 (to-int (works %w wallboarding)) (to-int (works %w taping)))) (ite (= day2 %d) (+ 1 (to-int (works %w sanding)) (to-int (works %w priming))))) (ite (= day3 %d) (+ 1 (to-int (works %w sanding)) (to-int (works %w priming))) 0)))",
        "(declare-fun day_tasks (Workers Days) Int (ite (= day1 %d) (to-int (works %w framing)) (ite (= day2 %d) (ite (= day2 %d) 2 (+ 1 (to-int (works %w wallboarding)) (to-int (works %w taping)))) (ite (= day2 %d) (+ 1 (to-int (works %w sanding)) (to-int (works %w priming))))) (ite (= day3 %d) (+ 1 (to-int (works %w sanding)) (to-int (works %w priming))) 0)))",
        "(declare-fun option_A () Bool (and (= (to-int (works Inga framing)) 0) (= (to-int (works Inga wallboarding)) 0) (= (to-int (works Inga taping)) 0) (= (to-int (works Inga sanding)) 0) (= (to-int (works Inga priming)) 0)))",
        "(declare-fun option_B () Bool (and (= (to-int (works Kelly framing)) 0) (= (to-int (works Kelly wallboarding)) 0) (= (to-int (works Kelly taping)) 0) (= (to-int (works Kelly sanding)) 0) (= (to-int (works Kelly priming)) 0)))",
        "(declare-fun option_C () Bool (and (= (to-int (works Olaf framing)) 0) (= (to-int (works Olaf wallboarding)) 0) (= (to-int (works Olaf taping)) 0) (= (to-int (works Olaf sanding)) 0) (= (to-int (works Olaf priming)) 0)))",
        "(declare-fun option_D () Bool (and (= (to-int (works George framing)) 0) (= (to-int (works George wallboarding)) 0) (= (to-int (works George taping)) 0) (= (to-int (works George sanding)) 0) (= (to-int (works George priming)) 0) (= (to-int (works Helena framing)) 0) (= (to-int (works Helena wallboarding)) 0) (= (to-int (works Helena taping)) 0) (= (to-int (works Helena sanding)) 0) (= (to-int (works Helena priming)) 0)))",
        "(declare-fun option_E () Bool (and (= (to-int (works Leanda framing)) 0) (= (to-int (works Leanda wallboarding)) 0) (= (to-int (works Leanda taping)) 0) (= (to-int (works Leanda sanding)) 0) (= (to-int (works Leanda priming)) 0) (= (to-int (works Olaf framing)) 0) (= (to-int (works Olaf wallboarding)) 0) (= (to-int (works Olaf taping)) 0) (= (to-int (works Olaf sanding)) 0) (= (to-int (works Olaf priming)) 0)))",
        "(declare-fun works_E () Bool (and (not (forall ((%d Days) (%w1 Workers)) (or (= %w1 Inga) (= %w1 Kelly) (= %w1 Olaf) (not (ite (= day2 %d) (ite (= day2 %d) 2 (+ 1 (to-int (works %w1 wallboarding)) (to-int (works %w1 taping))) (ite (= day2 %d) (+ 1 (to-int (works %w1 sanding)) (to-int (works %w1 priming))))) (ite (= day3 %d) (+ 1 (to-int (works %w1 sanding)) (to-int (works %w1 priming))) 0))))) (forall ((%d Days) (%w1 Workers)) (or (= %w1 Inga) (= %w1 Kelly) (= %w1 Olaf) (= (ite (= day2 %d) (ite (= day2 %d) 2 (+ 1 (to-int (works %w1 wallboarding)) (to-int (works %w1 taping))) (ite (= day2 %d) (+ 1 (to-int (works %w1 sanding)) (to-int (works %w1 priming))))) (ite (= day3 %d) (+ 1 (to-int (works %w1 sanding)) (to-int (works %w1 priming))) 0)) 0))) (forall ((%w1 Workers)) (not (ite (= Inga %w1) (ite (= day2 day2) (ite (= day2 day2) 2 (+ 1 (to-int (works Inga wallboarding)) (to-int (works Inga taping))) (ite (= day2 day2) (+ 1 (to-int (works Inga sanding)) (to-int (works Inga priming)))) (ite (= day3 day3) (+ 1 (to-int (works Inga sanding)) (to-int (works Inga priming))) 0)))) 0))"
      ],
      "constraints": [
        "(forall ((%d Days) (%w Workers)) (>= (+ (to-int (works %w framing)) (to-int (works %w wallboarding)) (to-int (works %w taping)) (to-int (works %w sanding)) (to-int (works %w priming))) (tasks_per_day %d)))",
        "(forall ((%d Days) (%w Workers)) (or (= (to-int (works %w taping)) 0) (= (to-int (works %w priming)) 0)))",
        "(forall ((%d Days) (%w Workers)) (<= (+ (to-int (works %w framing)) (to-int (works %w wallboarding)) (to-int (works %w taping)) (to-int (works %w sanding)) (to-int (works %w priming))) (tasks_per_day %d)))",
        "(forall ((%w Workers)) (not (forall ((%d Days)) (>= (+ (to-int (works %w framing)) (to-int (works %w wallboarding)) (to-int (works %w taping)) (to-int (works %w sanding)) (to-int (works %w priming))) (tasks_per_day %d)))))",
        "(forall ((%w Workers)) (not (forall ((%d Days)) (not (or (= (to-int (works %w taping)) 0) (= (to-int (works %w priming)) 0)))))",
        "(forall ((%w Workers)) (not (forall ((%d Days)) (<= (+ (to-int (works %w framing)) (to-int (works %w wallboarding)) (to-int (works %w taping)) (to-int (works %w sanding)) (to-int (works %w priming))) (tasks_per_day %d)))))",
        "(forall ((%d Days) (%w Workers)) (= (tasks_per_day_worker %w %d) (ite (= day1 %d) (to-int (works %w framing)) (ite (= day2 %d) (ite (= day2 %d) 2 (+ 1 (to-int (works %w wallboarding)) (to-int (works %w taping))) (ite (= day2 %d) (+ 1 (to-int (works %w sanding)) (to-int (works %w priming))))) (ite (= day3 %d) (+ 1 (to-int (works %w sanding)) (to-int (works %w priming))) 0))))",
        "(forall ((%w Workers)) (>= (to-int (works %w framing)) 0))",
        "(forall ((%w Workers)) (>= (to-int (works %w wallboarding)) 0))",
        "(forall ((%w Workers)) (>= (to-int (works %w taping)) 0))",
        "(forall ((%w Workers)) (>= (to-int (works %w sanding)) 0))",
        "(forall ((%w Workers)) (>= (to-int (works %w priming)) 0))",
        "(forall ((%w Workers)) (not (forall ((%d Days)) (or (>= (tasks_per_day_worker %w %d) 2) (= (to-int (works %w framing)) 0) (= (to-int (works %w wallboarding)) 0) (= (to-int (works %w taping)) 0) (= (to-int (works %w sanding)) 0) (= (to-int (works %w priming)) 0)))))",
        "(forall ((%d Days) (%w1 Workers) (%w2 Workers)) (or (not (= %w1 %w2)) (not (= (ite (= tasks_per_day_worker %w1 %d) (ite (= tasks_per_day_worker %w2 %d) wallboarding taping) 0) 0))))",
        "(forall ((%d Days) (%w1 Workers) (%w2 Workers)) (or (not (= %w1 %w2)) (not (= (ite (= tasks_per_day_worker %w1 %d) (ite (= tasks_per_day_worker %w2 %d) sanding priming) 0) 0)))"
      ],
      "options": [
        "(declare-fun option_A () Bool (and (= (to-int (works Inga framing)) 0) (= (to-int (works Inga wallboarding)) 0) (= (to-int (works Inga taping)) 0) (= (to-int (works Inga sanding)) 0) (= (to-int (works Inga priming)) 0)))",
        "(declare-fun option_B () Bool (and (= (to-int (works Kelly framing)) 0) (= (to-int (works Kelly wallboarding)) 0) (= (to-int (works Kelly taping)) 0) (= (to-int (works Kelly sanding)) 0) (= (to-int (works Kelly priming)) 0)))",
        "(declare-fun option_C () Bool (and (= (to-int (works Olaf framing)) 0) (= (to-int (works Olaf wallboarding)) 0) (= (to-int (works Olaf taping)) 0) (= (to-int (works Olaf sanding)) 0) (= (to-int (works Olaf priming)) 0)))",
        "(declare-fun option_D () Bool (and (= (to-int (works George framing)) 0) (= (to-int (works George wallboarding)) 0) (= (to-int (works George taping)) 0) (= (to-int (works George sanding)) 0) (= (to-int (works George priming)) 0) (= (to-int (works Helena framing)) 0) (= (to-int (works Helena wallboarding)) 0) (= (to-int (works Helena taping)) 0) (= (to-int (works Helena sanding)) 0) (= (to-int (works Helena priming)) 0)))",
        "(declare-fun option_E () Bool (and (= (to-int (works Leanda framing)) 0) (= (to-int (works Leanda wallboarding)) 0) (= (to-int (works Leanda taping)) 0) (= (to-int (works Leanda sanding)) 0) (= (to-int (works Leanda priming)) 0) (= (to-int (works Olaf framing)) 0) (= (to-int (works Olaf wallboarding)) 0) (= (to-int (works Olaf taping)) 0) (= (to-int (works Olaf sanding)) 0) (= (to-int (works Olaf priming)) 0)))",
        "(declare-fun works_E () Bool (and (not (forall ((%d Days) (%w1 Workers)) (or (= %w1 Inga) (= %w1 Kelly) (= %w1 Olaf) (not (ite (= day2 %d) (ite (= day2 %d) 2 (+ 1 (to-int (works %w1 wallboarding)) (to-int (works %w1 taping))) (ite (= day2 %d) (+ 1 (to-int (works %w1 sanding)) (to-int (works %w1 priming))))) (ite (= day3 %d) (+ 1 (to-int (works %w1 sanding)) (to-int (works %w1 priming))) 0))))) (forall ((%d Days) (%w1 Workers)) (or (= %w1 Inga) (= %w1 Kelly) (= %w1 Olaf) (= (ite (= day2 %d) (ite (= day2 %d) 2 (+ 1 (to-int (works %w1 wallboarding)) (to-int (works %w1 taping))) (ite (= day2 %d) (+ 1 (to-int (works %w1 sanding)) (to-int (works %w1 priming))))) (ite (= day3 %d) (+ 1 (to-int (works %w1 sanding)) (to-int (works %w1 priming))) 0)) 0))) (forall ((%w1 Workers)) (not (ite (= Inga %w1) (ite (= day2 day2) (ite (= day2 day2) 2 (+ 1 (to-int (works Inga wallboarding)) (to-int (works Inga taping))) (ite (= day2 day2) (+ 1 (to-int (works Inga sanding)) (to-int (works Inga priming)))) (ite (= day3 day3) (+ 1 (to-int (works Inga sanding)) (to-int (works Inga priming))) 0)))) 0))"
      ],
      "type": "unsat",
      "perplexity": [
        1.1383520364761353,
        1.0157097578048706
      ],
      "answer": "E",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "No Output"
    }
  },
  {
    "id": 22,
    "nl_problem": {
      "context": "A crew of up to five workers is to install a partition in at most three days. The crew completes five tasks in this order: framing, wallboarding, taping, sanding, priming. The crew is selected from the following list, which specifies exactly the tasks each person can do: George: taping Helena: sanding, priming Inga: framing, priming Kelly: framing, sanding Leanda: wallboarding, taping Maricita: sanding Olaf: wallboarding, priming The following conditions must apply: At least one task is done each day. Taping and priming are done on different days. Each crew member does at least one task during the installation, but no more than one task a day. Each task is done by exactly one worker, completed the day it is started and before the next task begins.",
      "question": "Which one of the following could be a pair of members of the crew both of whom work on the same days as each other and each of whom perform two tasks?",
      "options": [
        "A) George and Maricita",
        "B) Helena and Kelly",
        "C) Inga and Leanda",
        "D) Kelly and Leanda",
        "E) Leanda and Olaf"
      ]
    },
    "answer": "D",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((Workers 0)) (((George) (Helena) (Inga) (Kelly) (Leanda) (Maricita) (Olaf))))",
        "(declare-datatypes ((Tasks 0)) (((framing) (wallboarding) (taping) (sanding) (priming))))",
        "(declare-datatypes ((Days 0)) (((day1) (day2) (day3))))",
        "(declare-fun works_on (Workers Tasks) Bool)",
        "(declare-fun works_on_day (Workers Days Tasks) Bool)"
      ],
      "constraints": [
        "(forall ((w Workers) (d Days)) (= (ite (and (works_on w framing) (and (not (works_on w wallboarding)) (not (works_on w taping)) (not (works_on w sanding)) (not (works_on w priming)))) 1 (ite (and (works_on w wallboarding) (and (not (works_on w framing)) (not (works_on w taping)) (not (works_on w sanding)) (not (works_on w priming)))) 1 (ite (and (works_on w taping) (and (not (works_on w framing)) (not (works_on w wallboarding)) (not (works_on w sanding)) (not (works_on w priming)))) 1 (ite (and (works_on w sanding) (and (not (works_on w framing)) (not (works_on w wallboarding)) (not (works_on w taping)) (not (works_on w priming)))) 1 (ite (and (works_on w priming) (and (not (works_on w framing)) (not (works_on w wallboarding)) (not (works_on w taping)) (not (works_on w sanding)))) 1 0)))))",
        "(forall ((t Tasks)) (let ((d (ite (= t framing) day1 (ite (= t wallboarding) day2 (ite (= t taping) day3 (ite (= t sanding) day1 day2)))))) (let ((w (ite (= t framing) Inga (ite (= t wallboarding) Leanda (ite (= t taping) George (ite (= t sanding) Kelly Olaf))))) (w2 (ite (= t framing) (ite (= d day2) Kelly Inga) (ite (= d day3) Olaf (ite (= d day1) Leanda Inga))(ite (= t wallboarding) (ite (= d day1) Olaf (ite (= d day2) Leanda Inga)) (ite (= d day3) Kelly Olaf))(ite (= t taping) (ite (= d day1) Helena Kelly) (ite (= d day2) Olaf Leanda))(ite (= t sanding) (ite (= d day2) Kelly Inga) (ite (= d day3) Leanda Olaf))(ite (= t priming) (ite (= d day1) Inga Olaf) (ite (= d day2) Leanda Kelly) (ite (= d day3) George Helena))))) (forall ((d1 Days)) (=> (and (= d d1) (works_on w t)) (and (not (works_on w2 t)) (= w w2)))))",
        "(forall ((d1 Days)) (=> (or (works_on_day George d1 taping) (works_on_day George d1 priming)) (not (or (works_on_day Olaf d1 taping) (works_on_day Olaf d1 priming))))",
        "(forall ((d Days)) (or (exists ((t Tasks)) (exists ((w Workers)) (and (works_on w t) (= d day1)))) (exists ((t Tasks)) (exists ((w Workers)) (and (works_on w t) (= d day2)))) (exists ((t Tasks)) (exists ((w Workers)) (and (works_on w t) (= d day3))))",
        "(forall ((w Workers)) (exists ((d Days)) (exists ((t Tasks)) (and (works_on w t) (= d day1) (or (= t framing) (= t wallboarding)))))",
        "(forall ((w Workers)) (exists ((d Days)) (exists ((t Tasks)) (and (works_on w t) (= d day2) (or (= t taping) (= t sanding)))))",
        "(forall ((w Workers)) (exists ((d Days)) (exists ((t Tasks)) (and (works_on w t) (= d day3) (or (= t priming)))))",
        "(forall ((d Days)) (forall ((w1 Workers) (w2 Workers)) (let ((t1 (ite (and (works_on w1 framing) (= d day1)) framing (ite (and (works_on w1 wallboarding) (= d day2)) wallboarding (ite (and (works_on w1 taping) (= d day3)) taping (ite (and (works_on w1 sanding) (= d day1)) sanding (ite (and (works_on w1 priming) (= d day2)) priming framing))))))) (let ((t2 (ite (and (works_on w2 framing) (= d day1)) framing (ite (and (works_on w2 wallboarding) (= d day2)) wallboarding (ite (and (works_on w2 taping) (= d day3)) taping (ite (and (works_on w2 sanding) (= d day1)) sanding (ite (and (works_on w2 priming) (= d day2)) priming framing))))))) (let ((d2 (ite (= t1 framing) day1 (ite (= t1 wallboarding) day2 (ite (= t1 taping) day3 (ite (= t1 sanding) day1 day2))))) (d3 (ite (= t2 framing) day1 (ite (= t2 wallboarding) day2 (ite (= t2 taping) day3 (ite (= t2 sanding) day1 day2)))))) (=> (and (= d d2) (and (= d2 d3) (works_on w1 t1) (works_on w2 t2)) (not (= t1 t2))) (not (and (= d d1) (works_on w1 t1) (works_on w2 t2))))))",
        "(forall ((d Days)) (forall ((w1 Workers) (w2 Workers)) (let ((t1 (ite (and (works_on w1 framing) (= d day1)) framing (ite (and (works_on w1 wallboarding) (= d day2)) wallboarding (ite (and (works_on w1 taping) (= d day3)) taping (ite (and (works_on w1 sanding) (= d day1)) sanding (ite (and (works_on w1 priming) (= d day2)) priming framing))))))) (let ((t2 (ite (and (works_on w2 framing) (= d day1)) framing (ite (and (works_on w2 wallboarding) (= d day2)) wallboarding (ite (and (works_on w2 taping) (= d day3)) taping (ite (and (works_on w2 sanding) (= d day1)) sanding (ite (and (works_on w2 priming) (= d day2)) priming framing))))))) (let ((d2 (ite (= t1 framing) day1 (ite (= t1 wallboarding) day2 (ite (= t1 taping) day3 (ite (= t1 sanding) day1 day2))))) (d3 (ite (= t2 framing) day1 (ite (= t2 wallboarding) day2 (ite (= t2 taping) day3 (ite (= t2 sanding) day1 day2)))))) (=> (and (= d d2) (and (= d2 d3) (works_on w1 t1) (works_on w2 t2)) (not (= t1 t2))) (not (and (= d d1) (works_on w1 t1) (works_on w2 t2)))))",
        "(forall ((p Pair)) (let ((g (ite (or (= p (George Maricita)) (= p (Helena Kelly)) (= p (Inga Leanda)) (= p (Kelly Leanda)) (= p (Leanda Olaf))) George (ite (or (= p (George Maricita)) (= p (Helena Kelly)) (= p (Inga Leanda)) (= p (Kelly Leanda)) (= p (Leanda Olaf))) Helena (ite (or (= p (George Maricita)) (= p (Helena Kelly)) (= p (Inga Leanda)) (= p (Kelly Leanda)) (= p (Leanda Olaf))) Inga (ite (or (= p (George Maricita)) (= p (Helena Kelly)) (= p (Inga Leanda)) (= p (Kelly Leanda)) (= p (Leanda Olaf))) Kelly (ite (or (= p (George Maricita)) (= p (Helena Kelly)) (= p (Inga Leanda)) (= p (Kelly Leanda)) (= p (Leanda Olaf))) Leanda (ite (or (= p (George Maricita)) (= p (Helena Kelly)) (= p (Inga Leanda)) (= p (Kelly Leanda)) (= p (Leanda Olaf))) Maricita (ite (or (= p (George Maricita)) (= p (Helena Kelly)) (= p (Inga Leanda)) (= p (Kelly Leanda)) (= p (Leanda Olaf))) Olaf))))) (let ((l (ite (or (= p (George Maricita)) (= p (Helena Kelly)) (= p (Inga Leanda)) (= p (Kelly Leanda)) (= p (Leanda Olaf))) Maricita (ite (or (= p (George Maricita)) (= p (Helena Kelly)) (= p (Inga Leanda)) (= p (Kelly Leanda)) (= p (Leanda Olaf))) Kelly (ite (or (= p (George Maricita)) (= p (Helena Kelly)) (= p (Inga Leanda)) (= p (Kelly Leanda)) (= p (Leanda Olaf))) Leanda (ite (or (= p (George Maricita)) (= p (Helena Kelly)) (= p (Inga Leanda)) (= p (Kelly Leanda)) (= p (Leanda Olaf))) Olaf (ite (or (= p (George Maricita)) (= p (Helena Kelly)) (= p (Inga Leanda)) (= p (Kelly Leanda)) (= p (Leanda Olaf))) Leanda (ite (or (= p (George Maricita)) (= p (Helena Kelly)) (= p (Inga Leanda)) (= p (Kelly Leanda)) (= p (Leanda Olaf))) Inga))))) (and (= (to-int (forall ((d Days) (t Tasks)) (=> (and (= d day1) (works_on g t)) (exists ((w Workers) (distinct g w)) (and (works_on w t))))) 2) (= (to-int (forall ((d Days) (t Tasks)) (=> (and (= d day2) (works_on g t)) (exists ((w Workers) (distinct g w)) (and (works_on w t))))) 2) (= (to-int (forall ((d Days) (t Tasks)) (=> (and (= d day3) (works_on g t)) (exists ((w Workers) (distinct g w)) (and (works_on w t))))) 2) (= (to-int (forall ((d Days) (t Tasks)) (=> (and (= d day1) (works_on l t)) (exists ((w Workers) (distinct l w)) (and (works_on w t))))) 2) (= (to-int (forall ((d Days) (t Tasks)) (=> (and (= d day2) (works_on l t)) (exists ((w Workers) (distinct l w)) (and (works_on w t))))) 2) (= (to-int (forall ((d Days) (t Tasks)) (=> (and (= d day3) (works_on l t)) (exists ((w Workers) (distinct l w)) (and (works_on w t))))) 2) (= (to-int (forall ((d Days) (t Tasks)) (=> (and (= d day1) (works_on_day g day1 t)) (exists ((w Workers) (distinct g w)) (and (works_on_day w day1 t))))) 2) (= (to-int (forall ((d Days) (t Tasks)) (=> (and (= d day2) (works_on_day g day2 t)) (exists ((w Workers) (distinct g w)) (and (works_on_day w day2 t))))) 2) (= (to-int (forall ((d Days) (t Tasks)) (=> (and (= d day3) (works_on_day g day3 t)) (exists ((w Workers) (distinct g w)) (and (works_on_day w day3 t))))) 2) (= (to-int (forall ((d Days) (t Tasks)) (=> (and (= d day1) (works_on_day l day1 t)) (exists ((w Workers) (distinct l w)) (and (works_on_day w day1 t))))) 2) (= (to-int (forall ((d Days) (t Tasks)) (=> (and (= d day2) (works_on_day l day2 t)) (exists ((w Workers) (distinct l w)) (and (works_on_day w day2 t))))) 2) (= (to-int (forall ((d Days) (t Tasks)) (=> (and (= d day3) (works_on_day l day3 t)) (exists ((w Workers) (distinct l w)) (and (works_on_day w day3 t))))) 2))))))"
      ],
      "options": [
        "(declare-datatypes ((Pair 0)) (((George Maricita) (Helena Kelly) (Inga Leanda) (Kelly Leanda) (Leanda Olaf))))",
        "(forall ((p Pair)) (let ((g (ite (or (= p (George Maricita)) (= p (Helena Kelly)) (= p (Inga Leanda)) (= p (Kelly Leanda)) (= p (Leanda Olaf))) George (ite (or (= p (George Maricita)) (= p (Helena Kelly)) (= p (Inga Leanda)) (= p (Kelly Leanda)) (= p (Leanda Olaf))) Helena (ite (or (= p (George Maricita)) (= p (Helena Kelly)) (= p (Inga Leanda)) (= p (Kelly Leanda)) (= p (Leanda Olaf))) Inga (ite (or (= p (George Maricita)) (= p (Helena Kelly)) (= p (Inga Leanda)) (= p (Kelly Leanda)) (= p (Leanda Olaf))) Kelly (ite (or (= p (George Maricita)) (= p (Helena Kelly)) (= p (Inga Leanda)) (= p (Kelly Leanda)) (= p (Leanda Olaf))) Leanda (ite (or (= p (George Maricita)) (= p (Helena Kelly)) (= p (Inga Leanda)) (= p (Kelly Leanda)) (= p (Leanda Olaf))) Maricita (ite (or (= p (George Maricita)) (= p (Helena Kelly)) (= p (Inga Leanda)) (= p (Kelly Leanda)) (= p (Leanda Olaf))) Olaf))))) (let ((l (ite (or (= p (George Maricita)) (= p (Helena Kelly)) (= p (Inga Leanda)) (= p (Kelly Leanda)) (= p (Leanda Olaf))) Maricita (ite (or (= p (George Maricita)) (= p (Helena Kelly)) (= p (Inga Leanda)) (= p (Kelly Leanda)) (= p (Leanda Olaf))) Kelly (ite (or (= p (George Maricita)) (= p (Helena Kelly)) (= p (Inga Leanda)) (= p (Kelly Leanda)) (= p (Leanda Olaf))) Leanda (ite (or (= p (George Maricita)) (= p (Helena Kelly)) (= p (Inga Leanda)) (= p (Kelly Leanda)) (= p (Leanda Olaf))) Olaf (ite (or (= p (George Maricita)) (= p (Helena Kelly)) (= p (Inga Leanda)) (= p (Kelly Leanda)) (= p (Leanda Olaf))) Leanda (ite (or (= p (George Maricita)) (= p (Helena Kelly)) (= p (Inga Leanda)) (= p (Kelly Leanda)) (= p (Leanda Olaf))) Inga))))) (and (= (to-int (forall ((d Days) (t Tasks)) (=> (and (= d day1) (works_on g t)) (exists ((w Workers) (distinct g w)) (and (works_on w t))))) 2) (= (to-int (forall ((d Days) (t Tasks)) (=> (and (= d day2) (works_on g t)) (exists ((w Workers) (distinct g w)) (and (works_on w t))))) 2) (= (to-int (forall ((d Days) (t Tasks)) (=> (and (= d day3) (works_on g t)) (exists ((w Workers) (distinct g w)) (and (works_on w t))))) 2) (= (to-int (forall ((d Days) (t Tasks)) (=> (and (= d day1) (works_on l t)) (exists ((w Workers) (distinct l w)) (and (works_on w t))))) 2) (= (to-int (forall ((d Days) (t Tasks)) (=> (and (= d day2) (works_on l t)) (exists ((w Workers) (distinct l w)) (and (works_on w t))))) 2) (= (to-int (forall ((d Days) (t Tasks)) (=> (and (= d day3) (works_on l t)) (exists ((w Workers) (distinct l w)) (and (works_on w t))))) 2) (= (to-int (forall ((d Days) (t Tasks)) (=> (and (= d day1) (works_on_day g day1 t)) (exists ((w Workers) (distinct g w)) (and (works_on_day w day1 t))))) 2) (= (to-int (forall ((d Days) (t Tasks)) (=> (and (= d day2) (works_on_day g day2 t)) (exists ((w Workers) (distinct g w)) (and (works_on_day w day2 t))))) 2) (= (to-int (forall ((d Days) (t Tasks)) (=> (and (= d day3) (works_on_day g day3 t)) (exists ((w Workers) (distinct g w)) (and (works_on_day w day3 t))))) 2) (= (to-int (forall ((d Days) (t Tasks)) (=> (and (= d day1) (works_on_day l day1 t)) (exists ((w Workers) (distinct l w)) (and (works_on_day w day1 t))))) 2) (= (to-int (forall ((d Days) (t Tasks)) (=> (and (= d day2) (works_on_day l day2 t)) (exists ((w Workers) (distinct l w)) (and (works_on_day w day2 t))))) 2) (= (to-int (forall ((d Days) (t Tasks)) (=> (and (= d day3) (works_on_day l day3 t)) (exists ((w Workers) (distinct l w)) (and (works_on_day w day3 t))))) 2))))))"
      ],
      "type": "sat",
      "perplexity": [
        1.1328054666519165,
        1.0162489414215088
      ],
      "answer": "D",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "No Output"
    }
  },
  {
    "id": 23,
    "nl_problem": {
      "context": "A closet contains exactly six hangers—1, 2, 3, 4, 5, and 6—hanging, in that order, from left to right. It also contains exactly six dresses—one gauze, one linen, one polyester, one rayon, one silk, and one wool—a different dress on each of the hangers, in an order satisfying the following conditions: The gauze dress is on a lower-numbered hanger than the polyester dress. The rayon dress is on hanger 1 or hanger 6. Either the wool dress or the silk dress is on hanger 3. The linen dress hangs immediately to the right of the silk dress.",
      "question": "Which one of the following could be an accurate matching of the hangers to the fabrics of the dresses that hang on them?",
      "options": [
        "A) 1: wool; 2: gauze; 3: silk; 4: linen; 5: polyester; 6: rayon",
        "B) 1: rayon; 2: wool; 3: gauze; 4: silk; 5: linen; 6: polyester",
        "C) 1: polyester; 2: gauze; 3: wool; 4: silk; 5: linen; 6: rayon",
        "D) 1: linen; 2: silk; 3: wool; 4: gauze; 5: polyester; 6: rayon",
        "E) 1: gauze; 2: rayon; 3: silk; 4: linen; 5: wool; 6: polyester"
      ]
    },
    "answer": "A",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((Hangers 0)) (((1) (2) (3) (4) (5) (6))))",
        "(declare-datatypes ((Fabrics 0)) (((gauze) (linen) (polyester) (rayon) (silk) (wool))))",
        "(declare-fun dresses (Hangers) Fabrics)",
        "(declare-fun less_than (Hangers Hangers) Bool)"
      ],
      "constraints": [
        "(= (dresses 1) rayon)",
        "(or (= (dresses 6) rayon) (= (dresses 6) wool))",
        "(or (= (dresses 3) wool) (= (dresses 3) silk))",
        "(not (less_than 1 (dresses 1)))",
        "(and (= (dresses 3) silk) (not (less_than (dresses 2) (dresses 3))))",
        "(not (less_than 4 (dresses 3)))"
      ],
      "options": [
        "(and (= (dresses 1) wool) (= (dresses 2) gauze) (= (dresses 3) silk) (= (dresses 4) linen) (= (dresses 5) polyester) (= (dresses 6) rayon))",
        "(and (= (dresses 1) rayon) (= (dresses 2) wool) (= (dresses 3) gauze) (= (dresses 4) silk) (= (dresses 5) linen) (= (dresses 6) polyester))",
        "(and (= (dresses 1) polyester) (= (dresses 2) gauze) (= (dresses 3) wool) (= (dresses 4) silk) (= (dresses 5) linen) (= (dresses 6) rayon))",
        "(and (= (dresses 1) linen) (= (dresses 2) silk) (= (dresses 3) wool) (= (dresses 4) gauze) (= (dresses 5) polyester) (= (dresses 6) rayon))",
        "(and (= (dresses 1) gauze) (= (dresses 2) rayon) (= (dresses 3) silk) (= (dresses 4) linen) (= (dresses 5) wool) (= (dresses 6) polyester))"
      ],
      "type": "unsat",
      "perplexity": [
        1.277007818222046,
        1.0757944583892822
      ],
      "answer": "A",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "No Output"
    }
  },
  {
    "id": 24,
    "nl_problem": {
      "context": "A closet contains exactly six hangers—1, 2, 3, 4, 5, and 6—hanging, in that order, from left to right. It also contains exactly six dresses—one gauze, one linen, one polyester, one rayon, one silk, and one wool—a different dress on each of the hangers, in an order satisfying the following conditions: The gauze dress is on a lower-numbered hanger than the polyester dress. The rayon dress is on hanger 1 or hanger 6. Either the wool dress or the silk dress is on hanger 3. The linen dress hangs immediately to the right of the silk dress.",
      "question": "If both the silk dress and the gauze dress are on odd-numbered hangers, then which one of the following could be true?",
      "options": [
        "A) The polyester dress is on hanger 1.",
        "B) The wool dress is on hanger 2.",
        "C) The polyester dress is on hanger 4.",
        "D) The linen dress is on hanger 5.",
        "E) The wool dress is on hanger 6."
      ]
    },
    "answer": "B",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((Hangers 0)) (((1) (2) (3) (4) (5) (6))))",
        "(declare-datatypes ((Dresses 0)) (((gauze) (linen) (polyester) (rayon) (silk) (wool))))",
        "(declare-fun on (Hangers Dresses) Bool)",
        "(declare-fun order (Hangers Dresses) Dresses)",
        "(define-fun to-int ((b Bool)) Int (ite b 1 0))"
      ],
      "constraints": [
        "(forall ((h Hangers)) (not (and (on h gauze) (on (ite (> h 6) 1 6) gauze))))",
        "(forall ((h Hangers)) (or (= h 1) (= h 6) (=> (= h 1) (or (on h rayon) (on (ite (> h 6) 1 6) rayon))))) (and (not (on h rayon)) (not (on (ite (> h 6) 1 6) rayon)))",
        "(forall ((h Hangers)) (and (distinct 3 h) (or (and (on h wool) (on (ite (> h 6) 1 6) silk)) (and (on h silk) (on (ite (> h 6) 1 6) wool))) (and (not (on h wool)) (not (on (ite (> h 6) 1 6) silk)) (and (on h silk) (on (ite (> h 6) 1 6) wool))))))",
        "(forall ((h Hangers)) (distinct (ite (> h 6) 1 6) (ite (> (+ h 1) 6) 1 (+ h 1)))) (and (on (ite (> (+ h 1) 6) 1 (+ h 1)) linen) (on h silk))"
      ],
      "options": [
        "(forall ((h Hangers)) (distinct h 1)) (forall ((h Hangers)) (or (on h polyester) (on (ite (> h 6) 1 6) polyester)) (forall ((h1 Hangers)) (forall ((h2 Hangers)) (forall ((h3 Hangers)) (forall ((h4 Hangers)) (forall ((h5 Hangers)) (forall ((h6 Hangers)) (forall ((d Dresses)) (=> (and (distinct 1 h1) (distinct 2 h2) (distinct 3 h3) (distinct 4 h4) (distinct 5 h5) (distinct 6 h6) (distinct h h1) (distinct h h2) (distinct h h3) (distinct h h4) (distinct h h5) (distinct h h6) (and (on h1 d) (on h2 d) (on h3 d) (on h4 d) (on h5 d) (on h6 d) (not (on h d)) (forall ((x Hangers)) (forall ((y Hangers)) (=> (and (< x h) (distinct x y) (on x d)) (< h y)))) (forall ((x Hangers)) (forall ((y Hangers)) (=> (and (> x h) (distinct x y) (on x d)) (> h y)))) (forall ((x Hangers)) (=> (and (on x d) (not (on h x))) (< h x)))) (forall ((x Hangers)) (=> (and (on x d) (not (on h x))) (> h x))))) (and (distinct h 1) (on h polyester))))))",
        "(forall ((h Hangers)) (distinct h 2)) (forall ((h Hangers)) (or (on h wool) (on (ite (> h 6) 1 6) wool)) (forall ((h1 Hangers)) (forall ((h2 Hangers)) (forall ((h3 Hangers)) (forall ((h4 Hangers)) (forall ((h5 Hangers)) (forall ((h6 Hangers)) (forall ((d Dresses)) (=> (and (distinct 1 h1) (distinct 2 h2) (distinct 3 h3) (distinct 4 h4) (distinct 5 h5) (distinct 6 h6) (distinct h h1) (distinct h h2) (distinct h h3) (distinct h h4) (distinct h h5) (distinct h h6) (and (on h1 d) (on h2 d) (on h3 d) (on h4 d) (on h5 d) (on h6 d) (not (on h d)) (forall ((x Hangers)) (forall ((y Hangers)) (=> (and (< x h) (distinct x y) (on x d)) (< h y)))) (forall ((x Hangers)) (forall ((y Hangers)) (=> (and (> x h) (distinct x y) (on x d)) (> h y)))) (forall ((x Hangers)) (=> (and (on x d) (not (on h x))) (< h x)))) (forall ((x Hangers)) (=> (and (on x d) (not (on h x))) (> h x))))) (and (distinct h 2) (on h wool))))))",
        "(forall ((h Hangers)) (distinct h 4)) (forall ((h Hangers)) (or (on h polyester) (on (ite (> h 6) 1 6) polyester)) (forall ((h1 Hangers)) (forall ((h2 Hangers)) (forall ((h3 Hangers)) (forall ((h4 Hangers)) (forall ((h5 Hangers)) (forall ((h6 Hangers)) (forall ((d Dresses)) (=> (and (distinct 1 h1) (distinct 2 h2) (distinct 3 h3) (distinct 4 h4) (distinct 5 h5) (distinct 6 h6) (distinct h h1) (distinct h h2) (distinct h h3) (distinct h h4) (distinct h h5) (distinct h h6) (and (on h1 d) (on h2 d) (on h3 d) (on h4 d) (on h5 d) (on h6 d) (not (on h d)) (forall ((x Hangers)) (forall ((y Hangers)) (=> (and (< x h) (distinct x y) (on x d)) (< h y)))) (forall ((x Hangers)) (forall ((y Hangers)) (=> (and (> x h) (distinct x y) (on x d)) (> h y)))) (forall ((x Hangers)) (=> (and (on x d) (not (on h x))) (< h x)))) (forall ((x Hangers)) (=> (and (on x d) (not (on h x))) (> h x))))) (and (distinct h 4) (on h polyester))))))",
        "(forall ((h Hangers)) (distinct h 5)) (forall ((h Hangers)) (or (on h linen) (on (ite (> h 6) 1 6) linen)) (forall ((h1 Hangers)) (forall ((h2 Hangers)) (forall ((h3 Hangers)) (forall ((h4 Hangers)) (forall ((h5 Hangers)) (forall ((h6 Hangers)) (forall ((d Dresses)) (=> (and (distinct 1 h1) (distinct 2 h2) (distinct 3 h3) (distinct 4 h4) (distinct 5 h5) (distinct 6 h6) (distinct h h1) (distinct h h2) (distinct h h3) (distinct h h4) (distinct h h5) (distinct h h6) (and (on h1 d) (on h2 d) (on h3 d) (on h4 d) (on h5 d) (on h6 d) (not (on h d)) (forall ((x Hangers)) (forall ((y Hangers)) (=> (and (< x h) (distinct x y) (on x d)) (< h y)))) (forall ((x Hangers)) (forall ((y Hangers)) (=> (and (> x h) (distinct x y) (on x d)) (> h y)))) (forall ((x Hangers)) (=> (and (on x d) (not (on h x))) (< h x)))) (forall ((x Hangers)) (=> (and (on x d) (not (on h x))) (> h x))))) (and (distinct h 5) (on h linen))))))",
        "(forall ((h Hangers)) (distinct h 6)) (forall ((h Hangers)) (or (on h wool) (on (ite (> h 6) 1 6) wool)) (forall ((h1 Hangers)) (forall ((h2 Hangers)) (forall ((h3 Hangers)) (forall ((h4 Hangers)) (forall ((h5 Hangers)) (forall ((h6 Hangers)) (forall ((d Dresses)) (=> (and (distinct 1 h1) (distinct 2 h2) (distinct 3 h3) (distinct 4 h4) (distinct 5 h5) (distinct 6 h6) (distinct h h1) (distinct h h2) (distinct h h3) (distinct h h4) (distinct h h5) (distinct h h6) (and (on h1 d) (on h2 d) (on h3 d) (on h4 d) (on h5 d) (on h6 d) (not (on h d)) (forall ((x Hangers)) (forall ((y Hangers)) (=> (and (< x h) (distinct x y) (on x d)) (< h y)))) (forall ((x Hangers)) (forall ((y Hangers)) (=> (and (> x h) (distinct x y) (on x d)) (> h y)))) (forall ((x Hangers)) (=> (and (on x d) (not (on h x))) (< h x)))) (forall ((x Hangers)) (=> (and (on x d) (not (on h x))) (> h x))))) (and (distinct h 6) (on h wool))))))"
      ],
      "type": "sat",
      "perplexity": [
        1.0744727849960327,
        1.0148720741271973
      ],
      "answer": "B",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "No Output"
    }
  },
  {
    "id": 25,
    "nl_problem": {
      "context": "A closet contains exactly six hangers—1, 2, 3, 4, 5, and 6—hanging, in that order, from left to right. It also contains exactly six dresses—one gauze, one linen, one polyester, one rayon, one silk, and one wool—a different dress on each of the hangers, in an order satisfying the following conditions: The gauze dress is on a lower-numbered hanger than the polyester dress. The rayon dress is on hanger 1 or hanger 6. Either the wool dress or the silk dress is on hanger 3. The linen dress hangs immediately to the right of the silk dress.",
      "question": "If the silk dress is on an even-numbered hanger, which one of the following could be on the hanger immediately to its left?",
      "options": [
        "A) the gauze dress",
        "B) the linen dress",
        "C) the polyester dress",
        "D) the rayon dress",
        "E) the wool dress"
      ]
    },
    "answer": "E",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((Hangers 0)) (((1) (2) (3) (4) (5) (6))))",
        "(declare-datatypes ((Dresses 0)) (((gauze) (linen) (polyester) (rayon) (silk) (wool))))",
        "(declare-fun hanger (Dresses) Hangers)",
        "(declare-fun gauze_hanger () Hangers)",
        "(declare-fun polyester_hanger () Hangers)",
        "(declare-fun rayon_hanger () Hangers)",
        "(declare-fun silk_hanger () Hangers)",
        "(declare-fun wool_hanger () Hangers)",
        "(define-fun hanger-func ((d Dresses)) Hangers (ite (= d gauze) 1 (ite (= d linen) 2 (ite (= d polyester) 3 (ite (= d rayon) 1 (ite (= d silk) 2 (ite (= d wool) 3 0)))))))",
        "(define-fun gauze_hanger-func () Hangers (hanger-func gauze))",
        "(define-fun polyester_hanger-func () Hangers (hanger-func polyester))",
        "(define-fun rayon_hanger-func () Hangers (hanger-func rayon))",
        "(define-fun silk_hanger-func () Hangers (hanger-func silk))",
        "(define-fun wool_hanger-func () Hangers (hanger-func wool))",
        "(define-fun distinct-func ((h1 Hangers) (h2 Hangers)) Bool (ite (= h1 h2) 0 (ite (< h1 h2) 1 0)))",
        "(forall ((h1 Hangers) (h2 Hangers)) (distinct-func h1 h2))"
      ],
      "constraints": [
        "(= gauze_hanger gauze_hanger-func)",
        "(= polyester_hanger polyester_hanger-func)",
        "(= rayon_hanger rayon_hanger-func)",
        "(= silk_hanger silk_hanger-func)",
        "(= wool_hanger wool_hanger-func)",
        "(= (ite (> polyester_hanger gauze_hanger) polyester_hanger gauze_hanger) gauze_hanger)",
        "(= (ite (= rayon_hanger 1) 1 (ite (= rayon_hanger 6) 1 0)) 1)",
        "(or (= wool_hanger 3) (= silk_hanger 3))",
        "(= (ite (= silk_hanger 2) 2 (ite (= silk_hanger 4) 4 (ite (= silk_hanger 6) 6 0))) (ite (= linen_hanger (+ silk_hanger 1)) linen_hanger (ite (> linen_hanger (+ silk_hanger 1)) linen_hanger linen_hanger 0)))"
      ],
      "options": [
        "(forall ((h Hangers)) (ite (= h (+ silk_hanger 1)) (ite (= linen_hanger h) 1 0)))",
        "(forall ((h Hangers)) (distinct (ite (= h (+ silk_hanger 1)) 1 0) (ite (= gauze_hanger h) 1 0)))",
        "(forall ((h Hangers)) (distinct (ite (= h (+ silk_hanger 1)) 1 0) (ite (= polyester_hanger h) 1 0)))",
        "(forall ((h Hangers)) (distinct (ite (= h (+ silk_hanger 1)) 1 0) (ite (= rayon_hanger h) 1 0)))",
        "(forall ((h Hangers)) (distinct (ite (= h (+ silk_hanger 1)) 1 0) (ite (= wool_hanger h) 1 0)))"
      ],
      "type": "sat",
      "perplexity": [
        1.2090580463409424,
        1.059707760810852
      ],
      "answer": "E",
      "predicted_answer": [
        "sat",
        "sat",
        "sat",
        "sat",
        "sat"
      ],
      "status": "success",
      "error": ""
    }
  },
  {
    "id": 26,
    "nl_problem": {
      "context": "A closet contains exactly six hangers—1, 2, 3, 4, 5, and 6—hanging, in that order, from left to right. It also contains exactly six dresses—one gauze, one linen, one polyester, one rayon, one silk, and one wool—a different dress on each of the hangers, in an order satisfying the following conditions: The gauze dress is on a lower-numbered hanger than the polyester dress. The rayon dress is on hanger 1 or hanger 6. Either the wool dress or the silk dress is on hanger 3. The linen dress hangs immediately to the right of the silk dress.",
      "question": "If the polyester dress is on hanger 2, then which one of the following must be true?",
      "options": [
        "A) The silk dress is on hanger 1.",
        "B) The wool dress is on hanger 3.",
        "C) The linen dress is on hanger 4.",
        "D) The linen dress is on hanger 5.",
        "E) The rayon dress is on hanger 6."
      ]
    },
    "answer": "E"
  },
  {
    "id": 27,
    "nl_problem": {
      "context": "A closet contains exactly six hangers—1, 2, 3, 4, 5, and 6—hanging, in that order, from left to right. It also contains exactly six dresses—one gauze, one linen, one polyester, one rayon, one silk, and one wool—a different dress on each of the hangers, in an order satisfying the following conditions: The gauze dress is on a lower-numbered hanger than the polyester dress. The rayon dress is on hanger 1 or hanger 6. Either the wool dress or the silk dress is on hanger 3. The linen dress hangs immediately to the right of the silk dress.",
      "question": "Which one of the following CANNOT be true?",
      "options": [
        "A) The linen dress hangs immediately next to the gauze dress.",
        "B) The polyester dress hangs immediately to the right of the rayon dress.",
        "C) The rayon dress hangs immediately to the left of the wool dress.",
        "D) The silk dress is on a lower-numbered hanger than the gauze dress.",
        "E) The wool dress is on a higher-numbered hanger than the rayon dress."
      ]
    },
    "answer": "B",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((Hangers 0)) (((1) (2) (3) (4) (5) (6))))",
        "(declare-datatypes ((Dresses 0)) (((gauze) (linen) (polyester) (rayon) (silk) (wool)))",
        "(declare-fun dresses-on-hangers (Hangers) Dresses)",
        "(declare-fun next-hanger (Hangers Hangers) Bool)",
        "(define-fun next-hanger-ite ((h1 Hangers) (h2 Hangers)) Bool ...)"
      ],
      "constraints": [
        "(forall ((h Hangers)) (not (and (not (next-hanger-ite (dresses-on-hangers gauze-index h) (dresses-on-hangers polyester-index h))) (= (dresses-on-hangers polyester-index h) polyester)))",
        "(forall ((h Hangers)) (or (= (dresses-on-hangers rayon-index h) rayon) (= (dresses-on-hangers rayon-index h) 6)))",
        "(forall ((h Hangers)) (or (= (dresses-on-hangers wool-index h) wool) (= (dresses-on-hangers silk-index h) silk)))",
        "(forall ((h Hangers)) (and (not (next-hanger-ite (dresses-on-hangers linen-index h) (dresses-on-hangers silk-index h))) (= (dresses-on-hangers linen-index h) linen)))"
      ],
      "options": [
        "(forall ((h Hangers)) (not (and (not (next-hanger-ite (dresses-on-hangers gauze-index h) (dresses-on-hangers linen-index h))) (= (dresses-on-hangers gauze-index h) gauze)))",
        "(forall ((h Hangers)) (not (and (not (next-hanger-ite (dresses-on-hangers rayon-index2 h) (dresses-on-hangers polyester-index h))) (= (dresses-on-hangers rayon-index2 h) rayon)))",
        "(forall ((h Hangers)) (not (and (next-hanger-ite (dresses-on-hangers rayon-index3 h) (dresses-on-hangers wool-index h)) (= (dresses-on-hangers rayon-index3 h) rayon)))",
        "(forall ((h Hangers)) (not (and (not (next-hanger-ite (dresses-on-hangers silk-index2 h) (dresses-on-hangers gauze-index h))) (= (dresses-on-hangers silk-index2 h) silk)))",
        "(forall ((h Hangers)) (not (and (next-hanger-ite (dresses-on-hangers rayon-index h) (dresses-on-hangers wool-index2 h)) (= (dresses-on-hangers wool-index2 h) wool)))"
      ],
      "type": "unsat",
      "perplexity": [
        1.1731446981430054,
        1.0688837766647339
      ],
      "answer": "B",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "No Output"
    }
  },
  {
    "id": 28,
    "nl_problem": {
      "context": "A closet contains exactly six hangers—1, 2, 3, 4, 5, and 6—hanging, in that order, from left to right. It also contains exactly six dresses—one gauze, one linen, one polyester, one rayon, one silk, and one wool—a different dress on each of the hangers, in an order satisfying the following conditions: The gauze dress is on a lower-numbered hanger than the polyester dress. The rayon dress is on hanger 1 or hanger 6. Either the wool dress or the silk dress is on hanger 3. The linen dress hangs immediately to the right of the silk dress.",
      "question": "Which one of the following CANNOT hang immediately next to the rayon dress?",
      "options": [
        "A) the gauze dress",
        "B) the linen dress",
        "C) the polyester dress",
        "D) the silk dress",
        "E) the wool dress"
      ]
    },
    "answer": "D",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((Hangers 0)) (((_1) (_2) (_3) (_4) (_5) (_6))))",
        "(declare-datatypes ((Dresses 0)) (((gauze) (linen) (polyester) (rayon) (silk) (wool))))",
        "(declare-fun on ((Hangers Dresses)) Bool)",
        "(declare-fun hanger-number (Hangers) Int)",
        "(declare-fun dress-type (Dresses) String)",
        "(define-fun hanger-number (h Hangers) Int (ite (= h _1) 1 (ite (= h _2) 2 (ite (= h _3) 3 (ite (= h _4) 4 (ite (= h _5) 5 6)))))",
        "(define-fun on (h Hangers d Dresses) Bool (and (< (hanger-number h) 6) (= 1 (+ (ite (= d gauze) 1 0) (ite (= d linen) 1 0) (ite (= d polyester) 1 0) (ite (= d rayon) 1 0) (ite (= d silk) 1 0) (ite (= d wool) 1 0))))",
        "(define-fun cannot-be-on-hanger-before (d Dresses) Bool (ite (= d gauze) (>= (hanger-number _4) (hanger-number _1)) (ite (= d polyester) (> (hanger-number _1) (hanger-number _4)) true)))",
        "(define-fun cannot-be-on-hanger-1-or-6 (d Dresses) Bool (ite (= d rayon) true (ite (= d rayon) true (> (hanger-number _6) (hanger-number _1)))))",
        "(define-fun cannot-be-on-hanger-3 (d Dresses) Bool (ite (or (= d wool) (= d silk)) true (> (hanger-number _3) (hanger-number _1))))",
        "(define-fun cannot-be-immediately-after-silk (d Dresses) Bool (ite (= d linen) true (> (hanger-number _2) (hanger-number _3))))",
        "(declare-fun option (Dresses) Bool)",
        "(define-fun cannot-hang-next-to-rayon (d Dresses) Bool (and (not (on _1 rayon)) (not (on _6 rayon)) (not (on _1 d)) (not (on _6 d))))",
        "(declare-fun hangers (Dresses) (List Hangers))",
        "(define-fun hangers (d Dresses) (ite (= d gauze) (_ (h _1 gauze) (_ _2 linen) (_ _3 polyester) (_ _4 rayon) (_ _5 silk) (_ _6 wool)) (ite (= d linen) (_ (h _1 gauze) (_ _2 polyester) (_ _3 rayon) (_ _4 silk) (_ _5 wool) (_ _6 linen)) (ite (= d polyester) (_ (h _1 gauze) (_ _2 linen) (_ _3 rayon) (_ _4 silk) (_ _5 wool) (_ _6 polyester)) (ite (= d rayon) (_ (h _1 gauze) (_ _2 linen) (_ _3 silk) (_ _4 wool) (_ _5 polyester) (_ _6 rayon)) (ite (= d silk) (_ (h _1 gauze) (_ _2 linen) (_ _3 rayon) (_ _4 wool) (_ _5 polyester) (_ _6 silk)) (ite (= d wool) (_ (h _1 gauze) (_ _2 linen) (_ _3 rayon) (_ _4 silk) (_ _5 wool) (_ _6 polyester)))))",
        "(declare-fun option-list (Dresses) Bool)",
        "(define-fun option-list (d Dresses) (and (forall ((h Hangers)) (forall ((h2 Hangers)) (not (and (not (on h d)) (not (on h2 d)) (< (hanger-number h) (hanger-number h2)) (= (on h2 d) (on h h d)))))) (forall ((h Hangers)) (forall ((h2 Hangers)) (not (and (not (on h d)) (not (on h2 d)) (< (hanger-number h) (hanger-number h2)) (= (on h2 d) (on h h d)))))) (forall ((h Hangers)) (forall ((h2 Hangers)) (not (and (not (on h d)) (not (on h2 d)) (< (hanger-number h) (hanger-number h2)) (= (on h2 d) (on h h d)))))) (forall ((h Hangers)) (forall ((h2 Hangers)) (not (and (not (on h d)) (not (on h2 d)) (< (hanger-number h) (hanger-number h2)) (= (on h2 d) (on h h d)))))) (forall ((h Hangers)) (forall ((h2 Hangers)) (not (and (not (on h d)) (not (on h2 d)) (< (hanger-number h) (hanger-number h2)) (= (on h2 d) (on h h d)))))) (forall ((h Hangers)) (forall ((h2 Hangers)) (not (and (not (on h d)) (not (on h2 d)) (< (hanger-number h) (hanger-number h2)) (= (on h2 d) (on h h d)))))) (forall ((h Hangers)) (forall ((h2 Hangers)) (not (and (not (on h d)) (not (on h2 d)) (< (hanger-number h) (hanger-number h2)) (= (on h2 d) (on h h d)))))) (forall ((h Hangers)) (forall ((h2 Hangers)) (not (and (not (on h d)) (not (on h2 d)) (< (hanger-number h) (hanger-number h2)) (= (on h2 d) (on h h d)))))) (forall ((h Hangers)) (forall ((h2 Hangers)) (not (and (not (on h d)) (not (on h2 d)) (< (hanger-number h) (hanger-number h2)) (= (on h2 d) (on h h d))))))",
        "(define-fun option-list (d Dresses) (and (forall ((h Hangers)) (forall ((h2 Hangers)) (not (and (not (on h d)) (not (on h2 d)) (< (hanger-number h) (hanger-number h2)) (= (on h2 d) (on h h d)))))) (forall ((h Hangers)) (forall ((h2 Hangers)) (not (and (not (on h d)) (not (on h2 d)) (< (hanger-number h) (hanger-number h2)) (= (on h2 d) (on h h d)))))) (forall ((h Hangers)) (forall ((h2 Hangers)) (not (and (not (on h d)) (not (on h2 d)) (< (hanger-number h) (hanger-number h2)) (= (on h2 d) (on h h d)))))) (forall ((h Hangers)) (forall ((h2 Hangers)) (not (and (not (on h d)) (not (on h2 d)) (< (hanger-number h) (hanger-number h2)) (= (on h2 d) (on h h d)))))) (forall ((h Hangers)) (forall ((h2 Hangers)) (not (and (not (on h d)) (not (on h2 d)) (< (hanger-number h) (hanger-number h2)) (= (on h2 d) (on h h d)))))) (forall ((h Hangers)) (forall ((h2 Hangers)) (not (and (not (on h d)) (not (on h2 d)) (< (hanger-number h) (hanger-number h2)) (= (on h2 d) (on h h d)))))) (forall ((h Hangers)) (forall ((h2 Hangers)) (not (and (not (on h d)) (not (on h2 d)) (< (hanger-number h) (hanger-number h2)) (= (on h2 d) (on h h d)))))) (forall ((h Hangers)) (forall ((h2 Hangers)) (not (and (not (on h d)) (not (on h2 d)) (< (hanger-number h) (hanger-number h2)) (= (on h2 d) (on h h d)))))) (forall ((h Hangers)) (forall ((h2 Hangers)) (not (and (not (on h d)) (not (on h2 d)) (< (hanger-number h) (hanger-number h2)) (= (on h2 d) (on h h d))))))",
        "(declare-fun cannot-hang-next-to-rayon-list (Dresses) Bool)",
        "(define-fun cannot-hang-next-to-rayon-list-1 (d Dresses) (and (forall ((h Hangers)) (forall ((h2 Hangers)) (not (and (not (on h d)) (not (on h2 d)) (< (hanger-number h) (hanger-number h2)) (= (on h2 d) (on h h d)) (not (and (not (on h d)) (not (on h2 d)) (< (hanger-number h) (hanger-number h2)) (= (on h2 d) (on h h d)))))))) cannot-hang-next-to-rayon-list-1 (ite (= d gauze) (ite (= d linen) (ite (= d polyester) (ite (= d rayon) (ite (= d silk) (ite (= d wool) true)) true) true) true) true)))",
        "(assert (forall ((d Dresses)) (or (not (cannot-hang-next-to-rayon d)) (not cannot-hang-next-to-rayon-list-1 d)))",
        "(assert (forall ((d Dresses)) (not (and (not (cannot-hang-next-to-rayon d)) (not cannot-hang-next-to-rayon-list-1 d)))",
        "(check-sat)",
        "(get-model)"
      ],
      "constraints": [
        "(forall ((d Dresses)) (or (not (cannot-hang-next-to-rayon d)) (not cannot-hang-next-to-rayon-list-1 d)))",
        "(forall ((d Dresses)) (not (and (not (cannot-hang-next-to-rayon d)) (not cannot-hang-next-to-rayon-list-1 d)))"
      ],
      "options": [],
      "type": "sat",
      "perplexity": [
        1.1520795822143555,
        1.0225147008895874
      ],
      "answer": "D",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "No Output"
    }
  },
  {
    "id": 29,
    "nl_problem": {
      "context": "A closet contains exactly six hangers—1, 2, 3, 4, 5, and 6—hanging, in that order, from left to right. It also contains exactly six dresses—one gauze, one linen, one polyester, one rayon, one silk, and one wool—a different dress on each of the hangers, in an order satisfying the following conditions: The gauze dress is on a lower-numbered hanger than the polyester dress. The rayon dress is on hanger 1 or hanger 6. Either the wool dress or the silk dress is on hanger 3. The linen dress hangs immediately to the right of the silk dress.",
      "question": "Assume that the original condition that the linen dress hangs immediately to the right of the silk dress is replaced by the condition that the wool dress hangs immediately to the right of the silk dress. If all the other initial conditions remain in effect, which one of the following must be false?",
      "options": [
        "A) The linen dress is on hanger 1.",
        "B) The gauze dress is on hanger 2.",
        "C) The wool dress is on hanger 4.",
        "D) The silk dress is on hanger 5.",
        "E) The polyester dress is on hanger 6."
      ]
    },
    "answer": "D",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((Hangers 0)) (((h1) (h2) (h3) (h4) (h5) (h6))))",
        "(declare-datatypes ((Dresses 0)) (((gauze) (linen) (polyester) (rayon) (silk) (wool)))",
        "(declare-fun dress_on (Hangers Dresses) Bool)",
        "(declare-fun hanger_order (Hangers Hangers) Bool)"
      ],
      "constraints": [
        "(forall ((h1 Hangers) (h2 Hangers)) (=> (dress_on h1 gauze) (=> (dress_on h2 polyester) (< h1 h2))))",
        "(forall ((h1 Hangers)) (=> (dress_on h1 rayon) (or (= h1 h1) (= h1 h6))))",
        "(forall ((h1 Hangers)) (=> (dress_on h1 wool) (or (= h1 h3) (not (dress_on h1 silk)))))",
        "(forall ((h1 Hangers) (h2 Hangers)) (=> (and (dress_on h1 silk) (dress_on h2 wool)) (and (< h1 h2) (not (= h1 h6)))))",
        "(forall ((h1 Hangers)) (= (dress_on h1 linen) false))",
        "(forall ((h1 Hangers)) (= (dress_on h1 gauze) false))",
        "(forall ((h1 Hangers)) (= (dress_on h1 wool) false))",
        "(forall ((h1 Hangers)) (= (dress_on h1 silk) false))",
        "(forall ((h1 Hangers)) (= (dress_on h1 polyester) false))"
      ],
      "options": [
        "(not (= (dress_on h1 linen) false))",
        "(not (= (dress_on h2 gauze) false))",
        "(not (= (dress_on h4 wool) false))",
        "(not (= (dress_on h5 silk) false))",
        "(not (= (dress_on h6 polyester) false))"
      ],
      "type": "unsat",
      "perplexity": [
        1.323553442955017,
        1.0975024700164795
      ],
      "answer": "D",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "No Output"
    }
  },
  {
    "id": 30,
    "nl_problem": {
      "context": "At a children's festival, exactly four songs are performed, each exactly once: \"Night's All Right,\" \"Question Man,\" \"Rhino Rock,\" and \"Sammy.\" The songs are performed consecutively, each on a different one of exactly four instruments: flute, guitar, harmonica, or keyboard. The songs are performed in accordance with the following: The first song performed is not performed on the flute. If \"Sammy\" is performed on the keyboard, then \"Rhino Rock\" is performed on the harmonica. If \"Question Man\" is performed on the keyboard, then \"Night's All Right\" is performed on the flute. The song performed on the keyboard immediately follows \"Rhino Rock\" and immediately precedes \"Night's All Right.\"",
      "question": "Which one of the following could be an accurate matching of the four songs performed at the festival with the instruments on which they are performed, listed in order from the first song performed to the last?",
      "options": [
        "A) \"Night's All Right\": guitar;\" Question Man\": keyboard; \"Sammy\": guitar;\" Rhino Rock\": flute",
        "B) \"Question Man\": guitar;\" Rhino Rock\": harmonica; \"Sammy\": keyboard;\" Night's All Right\": flute",
        "C) \"Rhino Rock\": flute;\" Question Man\": keyboard; \"Night's All Right\": harmonica;\" Sammy\": guitar",
        "D) \"Sammy\": harmonica;\" Night's All Right\": guitar; \"Question Man\": keyboard;\" Rhino Rock\": flute",
        "E) \"Sammy\": harmonica;\" Rhino Rock\": guitar; \"Question Man\": flute;\" Night's All Right\": keyboard"
      ]
    },
    "answer": "B",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((Instruments 0)) (((flute) (guitar) (harmonica) (keyboard))))",
        "(declare-datatypes ((Songs 0)) ((\"Night's All Right\" \"Question Man\" \"Rhino Rock\" \"Sammy\")))",
        "(declare-fun played_on (Songs Instruments) Bool)"
      ],
      "constraints": [
        "(= 4 (counted (lambda ((s Songs)) (ite (played_on s flute) 0 1)) Songs))",
        "(= 4 (counted (lambda ((s Songs)) (ite (played_on s guitar) 0 1)) Songs))",
        "(= 4 (counted (lambda ((s Songs)) (ite (played_on s harmonica) 0 1)) Songs))",
        "(= 4 (counted (lambda ((s Songs)) (ite (played_on s keyboard) 0 1)) Songs))",
        "(forall ((s Songs) (i Instruments)) (= (ite (played_on s i) 1 0) 1))",
        "(not (played_on \"Night's All Right\" flute))",
        "(forall ((s Songs) (i Instruments)) (or (= s \"Night's All Right\") (= s \"Question Man\") (= s \"Rhino Rock\") (= s \"Sammy\"))) and (not (played_on \"Sammy\" keyboard)) -> (played_on \"Rhino Rock\" harmonica)",
        "(forall ((s Songs) (i Instruments)) (or (= s \"Night's All Right\") (= s \"Question Man\") (= s \"Rhino Rock\") (= s \"Sammy\"))) and (not (played_on \"Question Man\" keyboard)) -> (played_on \"Night's All Right\" flute)",
        "(forall ((s Songs) (i Instruments)) (or (= s \"Night's All Right\") (= s \"Question Man\") (= s \"Rhino Rock\") (= s \"Sammy\"))) and (played_on \"Rhino Rock\" i) and (played_on \"Night's All Right\" j) and (not (= i keyboard)) and (not (= j flute)) -> (= j (ite (= i harmonica) flute keyboard))"
      ],
      "options": [
        "(forall ((i1 Instruments) (i2 Instruments) (i3 Instruments) (i4 Instruments)) (= (ite (played_on \"Night's All Right\" i1) 1 0) (ite (played_on \"Question Man\" i2) 1 0) (ite (played_on \"Rhino Rock\" i3) 1 0) (ite (played_on \"Sammy\" i4) 1 0) (ite (and (= i1 flute) (= i2 guitar) (= i3 harmonica) (= i4 keyboard)) 1 0)) 1))",
        "(forall ((i1 Instruments) (i2 Instruments) (i3 Instruments) (i4 Instruments)) (= (ite (played_on \"Night's All Right\" i1) 1 0) (ite (played_on \"Question Man\" i2) 1 0) (ite (played_on \"Rhino Rock\" i3) 1 0) (ite (played_on \"Sammy\" i4) 1 0) (ite (and (= i1 flute) (= i2 guitar) (= i3 harmonica) (= i4 keyboard)) 1 0)) 1))",
        "(forall ((i1 Instruments) (i2 Instruments) (i3 Instruments) (i4 Instruments)) (= (ite (played_on \"Night's All Right\" i1) 1 0) (ite (played_on \"Question Man\" i2) 1 0) (ite (played_on \"Rhino Rock\" i3) 1 0) (ite (played_on \"Sammy\" i4) 1 0) (ite (and (= i1 flute) (= i2 keyboard) (= i3 harmonica) (= i4 guitar)) 1 0)) 1))",
        "(forall ((i1 Instruments) (i2 Instruments) (i3 Instruments) (i4 Instruments)) (= (ite (played_on \"Night's All Right\" i1) 1 0) (ite (played_on \"Question Man\" i2) 1 0) (ite (played_on \"Rhino Rock\" i3) 1 0) (ite (played_on \"Sammy\" i4) 1 0) (ite (and (= i1 flute) (= i2 harmonica) (= i3 guitar) (= i4 keyboard)) 1 0)) 1))",
        "(forall ((i1 Instruments) (i2 Instruments) (i3 Instruments) (i4 Instruments)) (= (ite (played_on \"Night's All Right\" i1) 1 0) (ite (played_on \"Question Man\" i2) 1 0) (ite (played_on \"Rhino Rock\" i3) 1 0) (ite (played_on \"Sammy\" i4) 1 0) (ite (and (= i1 flute) (= i2 guitar) (= i3 guitar) (= i4 keyboard)) 1 0)) 1))"
      ],
      "type": "unsat",
      "perplexity": [
        1.0761257410049438,
        1.033504605293274
      ],
      "answer": "B",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "No Output"
    }
  },
  {
    "id": 31,
    "nl_problem": {
      "context": "At a children's festival, exactly four songs are performed, each exactly once: \"Night's All Right,\" \"Question Man,\" \"Rhino Rock,\" and \"Sammy.\" The songs are performed consecutively, each on a different one of exactly four instruments: flute, guitar, harmonica, or keyboard. The songs are performed in accordance with the following: The first song performed is not performed on the flute. If \"Sammy\" is performed on the keyboard, then \"Rhino Rock\" is performed on the harmonica. If \"Question Man\" is performed on the keyboard, then \"Night's All Right\" is performed on the flute. The song performed on the keyboard immediately follows \"Rhino Rock\" and immediately precedes \"Night's All Right.\"",
      "question": "Which one of the following could be true?",
      "options": [
        "A) \"Question Man\" immediately follows the song performed on the keyboard.",
        "B) \"Night's All Right\" immediately precedes the song performed on the keyboard.",
        "C) \"Question Man\" immediately precedes the song performed on the guitar.",
        "D) \"Rhino Rock\" immediately precedes the song performed on the harmonica.",
        "E) \"Sammy\" immediately precedes the song performed on the guitar."
      ]
    },
    "answer": "E",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((Instruments 0)) (((flute) (guitar) (harmonica) (keyboard))))",
        "(declare-datatypes ((Songs 0)) (((Night's_All_Right) (Question_Man) (Rhino_Rock) (Sammy))))",
        "(declare-fun performed (Songs Instruments) Bool)"
      ],
      "constraints": [
        "(not (performed Night's_All_Right flute))",
        "(=> (performed Sammy keyboard) (performed Rhino_Rock harmonica))",
        "(=> (performed Question_Man keyboard) (performed Night's_All_Right flute))",
        "(and (not (performed Rhino_Rock keyboard)) (not (performed Night's_All_Right keyboard)) (=> (performed Rhino_Rock ?i) (performed ?i keyboard)) (=> (performed ?i keyboard) (performed Night's_All_Right ?j)) (distinct ?i keyboard) (distinct ?j keyboard))"
      ],
      "options": [
        "(=> (performed Rhino_Rock keyboard) (performed Question_Man ?i) (performed ?i keyboard))",
        "(=> (performed ?i keyboard) (performed ?j Night's_All_Right) (performed Night's_All_Right ?j) (performed ?i keyboard))",
        "(=> (performed ?i guitar) (performed ?j Question_Man) (performed Question_Man ?j) (performed ?i guitar))",
        "(=> (performed ?i harmonica) (performed ?j Rhino_Rock) (performed Rhino_Rock ?j) (performed ?i harmonica))",
        "(=> (performed ?i guitar) (performed ?j Sammy) (performed Sammy ?j) (performed ?i guitar))"
      ],
      "type": "unsat",
      "perplexity": [
        1.1837599277496338,
        1.0893563032150269
      ],
      "answer": "E",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "No Output"
    }
  },
  {
    "id": 32,
    "nl_problem": {
      "context": "At a children's festival, exactly four songs are performed, each exactly once: \"Night's All Right,\" \"Question Man,\" \"Rhino Rock,\" and \"Sammy.\" The songs are performed consecutively, each on a different one of exactly four instruments: flute, guitar, harmonica, or keyboard. The songs are performed in accordance with the following: The first song performed is not performed on the flute. If \"Sammy\" is performed on the keyboard, then \"Rhino Rock\" is performed on the harmonica. If \"Question Man\" is performed on the keyboard, then \"Night's All Right\" is performed on the flute. The song performed on the keyboard immediately follows \"Rhino Rock\" and immediately precedes \"Night's All Right.\"",
      "question": "Which one of the following CANNOT be true of the song performed on the flute?",
      "options": [
        "A) It immediately precedes \"Question Man.\"",
        "B) It immediately follows \"Question Man.\"",
        "C) It immediately precedes \"Rhino Rock.\"",
        "D) It immediately follows \"Night's All Right.\"",
        "E) It immediately follows \"Sammy.\""
      ]
    },
    "answer": "C"
  },
  {
    "id": 33,
    "nl_problem": {
      "context": "At a children's festival, exactly four songs are performed, each exactly once: \"Night's All Right,\" \"Question Man,\" \"Rhino Rock,\" and \"Sammy.\" The songs are performed consecutively, each on a different one of exactly four instruments: flute, guitar, harmonica, or keyboard. The songs are performed in accordance with the following: The first song performed is not performed on the flute. If \"Sammy\" is performed on the keyboard, then \"Rhino Rock\" is performed on the harmonica. If \"Question Man\" is performed on the keyboard, then \"Night's All Right\" is performed on the flute. The song performed on the keyboard immediately follows \"Rhino Rock\" and immediately precedes \"Night's All Right.\"",
      "question": "If \"Rhino Rock\" is the second song performed at the festival, then which one of the following could be true?",
      "options": [
        "A) The first song performed is performed on the keyboard.",
        "B) The third song performed is performed on the guitar.",
        "C) The third song performed is performed on the flute.",
        "D) \"Night's All Right\" is performed on the guitar.",
        "E) \"Rhino Rock\" is performed on the guitar."
      ]
    },
    "answer": "E",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((Instruments 0)) (((flute) (guitar) (harmonica) (keyboard))))",
        "(declare-datatypes ((Songs 0)) (((Night's_All_Right) (Question_Man) (Rhino_Rock) (Sammy))))",
        "(declare-fun performed_on (Songs Instruments) Bool)",
        "(declare-fun performed_after (Songs Songs) Bool)",
        "(declare-fun performed_before (Songs Songs) Bool)"
      ],
      "constraints": [
        "(= 4 (count (lambda ((s Songs)) (let ((i (ite (performed_on s flute) 1 0) (ite (performed_on s guitar) 2 0) (ite (performed_on s harmonica) 3 0) (ite (performed_on s keyboard) 4 0))) i))))",
        "(forall ((s Songs)) (let ((i (ite (performed_on s flute) 1 0) (ite (performed_on s guitar) 2 0) (ite (performed_on s harmonica) 3 0) (ite (performed_on s keyboard) 4 0))) (= i 1)))",
        "(forall ((s Songs)) (forall ((r Songs)) (forall ((k Instruments)) (=> (and (performed_after r Rhino_Rock) (performed_before Rhino_Rock s) (performed_on Rhino_Rock k)) (ite (= k keyboard) (performed_on Sammy keyboard) false))))",
        "(forall ((s Songs)) (forall ((r Songs)) (forall ((f Instruments)) (=> (and (performed_after r Question_Man) (performed_before Question_Man s) (performed_on Question_Man f)) (ite (= f keyboard) (performed_on Night's_All_Right flute) false))))",
        "(forall ((s Songs)) (forall ((r Songs)) (forall ((k Instruments)) (=> (and (performed_after Rhino_Rock s) (performed_before Rhino_Rock k)) (ite (= k keyboard) (performed_after Rhino_Rock s) false))))",
        "(forall ((s Songs)) (let ((i (ite (performed_on s flute) 1 0) (ite (performed_on s guitar) 2 0) (ite (performed_on s harmonica) 3 0) (ite (performed_on s keyboard) 4 0))) (not (and (< i 2) (< 4 i)))))",
        "(forall ((s Songs)) (forall ((t Songs)) (let ((i (ite (performed_on s flute) 1 0) (ite (performed_on s guitar) 2 0) (ite (performed_on s harmonica) 3 0) (ite (performed_on s keyboard) 4 0)) (j (ite (performed_on t flute) 1 0) (ite (performed_on t guitar) 2 0) (ite (performed_on t harmonica) 3 0) (ite (performed_on t keyboard) 4 0))) (not (and (= i j) (= s t))))))"
      ],
      "options": [
        "(let (($0 (ite (performed_after Rhino_Rock Night's_All_Right) (ite (performed_on Rhino_Rock guitar) true false) false)) ($1 (ite (performed_before Rhino_Rock Sammy) (ite (performed_on Sammy guitar) true false) false)) ($2 (ite (performed_before Rhino_Rock Question_Man) (ite (performed_on Question_Man guitar) true false) false)) (not (and $0 $1 $2)))",
        "(let (($0 (ite (performed_after Rhino_Rock Night's_All_Right) (ite (performed_on Rhino_Rock flute) true false) false)) ($1 (ite (performed_after Night's_All_Right Sammy) (ite (performed_on Sammy guitar) true false) false)) ($2 (ite (performed_after Sammy Question_Man) (ite (performed_on Question_Man flute) true false) false)) (not (and $0 $1 $2)))",
        "(let (($0 (ite (performed_after Rhino_Rock Night's_All_Right) (ite (performed_on Night's_All_Right guitar) true false) false)) ($1 (ite (performed_after Night's_All_Right Sammy) (ite (performed_on Sammy guitar) true false) false)) ($2 (ite (performed_after Sammy Question_Man) (ite (performed_on Question_Man guitar) true false) false)) (not (and $0 $1 $2)))",
        "(let (($0 (ite (performed_after Rhino_Rock Night's_All_Right) (ite (performed_on Rhino_Rock guitar) true false) false)) ($1 (ite (performed_after Rhino_Rock Sammy) (ite (performed_on Sammy guitar) true false) false)) ($2 (ite (performed_after Sammy Question_Man) (ite (performed_on Question_Man guitar) true false) false)) (not (and $0 $1 $2)))"
      ],
      "type": "sat",
      "perplexity": [
        1.1623624563217163,
        1.0382739305496216
      ],
      "answer": "E",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "No Output"
    }
  },
  {
    "id": 34,
    "nl_problem": {
      "context": "At a children's festival, exactly four songs are performed, each exactly once: \"Night's All Right,\" \"Question Man,\" \"Rhino Rock,\" and \"Sammy.\" The songs are performed consecutively, each on a different one of exactly four instruments: flute, guitar, harmonica, or keyboard. The songs are performed in accordance with the following: The first song performed is not performed on the flute. If \"Sammy\" is performed on the keyboard, then \"Rhino Rock\" is performed on the harmonica. If \"Question Man\" is performed on the keyboard, then \"Night's All Right\" is performed on the flute. The song performed on the keyboard immediately follows \"Rhino Rock\" and immediately precedes \"Night's All Right.\"",
      "question": "If \"Question Man\" is the third song performed at the festival, then each of the following could be true EXCEPT:",
      "options": [
        "A) \"Question Man\" is performed on the guitar.",
        "B) \"Question Man\" is performed on the keyboard.",
        "C) \"Rhino Rock\" is performed on the guitar.",
        "D) \"Sammy\" is performed on the guitar.",
        "E) \"Sammy\" is performed on the harmonica."
      ]
    },
    "answer": "A",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((Instruments 0)) (((flute) (guitar) (harmonica) (keyboard))))",
        "(declare-datatypes ((Songs 0)) (((Night's_All_Right) (Question_Man) (Rhino_Rock) (Sammy))))",
        "(declare-fun performed (Songs Instruments) Bool)"
      ],
      "constraints": [
        "(declare-fun has_performed (Songs) Bool)",
        "(= 4 (count (lambda ((x Songs)) (ite (has_performed x) 1 0)) Songs))",
        "(forall ((x Songs)) (and (ite (has_performed x) 1 0) (= (ite (has_performed x) 1 0) 1)))",
        "(forall ((x Songs)) (ite (has_performed x) (= (ite (has_performed x) 1 0) 1) false))",
        "(forall ((x Songs)) (ite (has_performed x) (ite (= x Night's_All_Right) flute (ite (= x Question_Man) guitar (ite (= x Rhino_Rock) harmonica keyboard)))))",
        "(forall ((x Songs)) (not (ite (has_performed x) (= (ite (has_performed x) 1 0) (ite (= x Night's_All_Right) 1 (ite (= x Question_Man) 1 (ite (= x Rhino_Rock) 1 (ite (= x Sammy) 1 0))))))))",
        "(not (ite (has_performed Night's_All_Right) (= (ite (has_performed Night's_All_Right) 1 0) 1)))",
        "(= (ite (has_performed Sammy) (= (ite (has_performed Sammy) 1 0) (ite (= (instrument Sammy) keyboard) 1 0))) (ite (has_performed Rhino_Rock) (= (ite (has_performed Rhino_Rock) 1 0) (ite (= (instrument Rhino_Rock) harmonica) 1 0))))",
        "(= (ite (has_performed Question_Man) (= (ite (has_performed Question_Man) 1 0) (ite (= (instrument Question_Man) keyboard) 1 0))) (ite (has_performed Night's_All_Right) (= (ite (has_performed Night's_All_Right) 1 0) (ite (= (instrument Night's_All_Right) flute) 1 0))))",
        "(ite (has_performed Sammy) (= (ite (has_performed Sammy) 1 0) (ite (= (ite (has_performed Rhino_Rock) 1 0) (ite (= (instrument Rhino_Rock) harmonica) 1 0)) (ite (= (ite (has_performed Night's_All_Right) 1 0) (ite (= (instrument Night's_All_Right) flute) 1 0)) 1 0))))",
        "(ite (has_performed Sammy) (= (ite (has_performed Sammy) 1 0) (ite (= (ite (has_performed Night's_All_Right) 1 0) (ite (= (instrument Night's_All_Right) flute) 1 0)) 1 (ite (has_performed Sammy) 1 0))))",
        "(ite (has_performed Question_Man) (= (ite (has_performed Question_Man) 1 0) 2))",
        "(ite (has_performed Question_Man) (ite (= (ite (has_performed Question_Man) 1 0) 1) (= (ite (has_performed Question_Man) 1 0) (ite (= (instrument Question_Man) guitar) 1 0))))",
        "(ite (has_performed Question_Man) (ite (= (ite (has_performed Question_Man) 1 0) 1) (= (ite (has_performed Question_Man) 1 0) (ite (= (instrument Question_Man) keyboard) 1 0))))",
        "(ite (has_performed Rhino_Rock) (ite (= (ite (has_performed Rhino_Rock) 1 0) 1) (= (ite (has_performed Rhino_Rock) 1 0) (ite (= (instrument Rhino_Rock) guitar) 1 0))))",
        "(ite (has_performed Sammy) (ite (= (ite (has_performed Sammy) 1 0) 1) (= (ite (has_performed Sammy) 1 0) (ite (= (instrument Sammy) guitar) 1 0))))",
        "(ite (has_performed Sammy) (ite (= (ite (has_performed Sammy) 1 0) 1) (= (ite (has_performed Sammy) 1 0) (ite (= (instrument Sammy) harmonica) 1 0))))"
      ],
      "options": [
        "(ite (has_performed Question_Man) (ite (= (ite (has_performed Question_Man) 1 0) 1) (= (ite (has_performed Question_Man) 1 0) (ite (= (instrument Question_Man) guitar) 1 0))))",
        "(ite (has_performed Question_Man) (ite (= (ite (has_performed Question_Man) 1 0) 1) (= (ite (has_performed Question_Man) 1 0) (ite (= (instrument Question_Man) keyboard) 1 0))))",
        "(ite (has_performed Rhino_Rock) (ite (= (ite (has_performed Rhino_Rock) 1 0) 1) (= (ite (has_performed Rhino_Rock) 1 0) (ite (= (instrument Rhino_Rock) guitar) 1 0))))",
        "(ite (has_performed Sammy) (ite (= (ite (has_performed Sammy) 1 0) 1) (= (ite (has_performed Sammy) 1 0) (ite (= (instrument Sammy) guitar) 1 0))))",
        "(ite (has_performed Sammy) (ite (= (ite (has_performed Sammy) 1 0) 1) (= (ite (has_performed Sammy) 1 0) (ite (= (instrument Sammy) harmonica) 1 0))))"
      ],
      "type": "unsat",
      "perplexity": [
        1.1291548013687134,
        1.0356963872909546
      ],
      "answer": "A",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "No Output"
    }
  },
  {
    "id": 35,
    "nl_problem": {
      "context": "Each of the seven members of the board of directors—Guzman, Hawking, Lepp, Miyauchi, Upchurch, Wharton, and Zhu—serves on exactly one of two committees—the finance committee or the incentives committee. Only board members serve on these committees. Committee membership is consistent with the following conditions: If Guzman serves on the finance committee, then Hawking serves on the incentives committee. If Lepp serves on the finance committee, then Miyauchi and Upchurch both serve on the incentives committee. Wharton serves on a different committee from the one on which Zhu serves. Upchurch serves on a different committee from the one on which Guzman serves. If Zhu serves on the finance committee, so does Hawking.",
      "question": "Which one of the following could be a complete and accurate list of the members of the finance committee?",
      "options": [
        "A) Guzman, Hawking, Miyauchi, Wharton",
        "B) Guzman, Lepp, Zhu",
        "C) Hawking, Miyauchi, Zhu",
        "D) Hawking, Upchurch, Wharton, Zhu",
        "E) Miyauchi, Upchurch, Wharton"
      ]
    },
    "answer": "E",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((BoardMembers 0)) (((Guzman) (Hawking) (Lepp) (Miyauchi) (Upchurch) (Wharton) (Zhu))))",
        "(declare-datatypes ((Committees 0)) (((finance) (incentives))))",
        "(declare-fun serves (BoardMembers Committees) Bool)",
        "(declare-fun to-int ((b Bool)) Int)",
        "(declare-fun count-serves (BoardMembers) Int)",
        "(declare-fun count-committees (BoardMembers) Int)"
      ],
      "constraints": [
        "(= (count-serves b) 1)",
        "(= (count-committees b) 1)",
        "(= (to-int (and (serves b finance) (serves b incentives))) 0)",
        "(= (serves Guzman finance) (serves Hawking incentives))",
        "(= (serves Lepp finance) (and (serves Miyauchi incentives) (serves Upchurch incentives)))",
        "(= (or (not (serves Wharton finance)) (not (serves Zhu finance))) true)",
        "(= (or (not (serves Wharton incentives)) (not (serves Zhu incentives))) true)",
        "(= (or (not (serves Upchurch finance)) (not (serves Guzman finance))) true)",
        "(= (or (not (serves Upchurch incentives)) (not (serves Guzman incentives))) true)",
        "(= (serves Zhu finance) (serves Hawking finance))"
      ],
      "options": [
        "(= (in-list Guzman (list-A) (and (serves Guzman finance) (serves Hawking finance) (serves Miyauchi finance) (serves Wharton finance))) true)",
        "(= (in-list Guzman (list-B) (and (serves Guzman finance) (serves Lepp finance) (serves Zhu finance))) true)",
        "(= (in-list Hawking (list-C) (and (serves Hawking finance) (serves Miyauchi finance) (serves Zhu finance))) true)",
        "(= (in-list Hawking (list-D) (and (serves Hawking finance) (serves Upchurch finance) (serves Wharton finance) (serves Zhu finance))) true)",
        "(= (in-list Miyauchi (list-E) (and (serves Miyauchi finance) (serves Upchurch finance) (serves Wharton finance))) true)",
        "(= (contains-finance-committee (list-A)) true)",
        "(= (contains-finance-committee (list-B)) true)",
        "(= (contains-finance-committee (list-C)) true)",
        "(= (contains-finance-committee (list-D)) true)",
        "(= (contains-finance-committee (list-E)) true)",
        "(= (not (and option-A option-B)) true)",
        "(= (not (and option-A option-C)) true)",
        "(= (not (and option-A option-D)) true)",
        "(= (not (and option-A option-E)) true)",
        "(= (not (and option-B option-C)) true)",
        "(= (not (and option-B option-D)) true)",
        "(= (not (and option-B option-E)) true)",
        "(= (not (and option-C option-D)) true)",
        "(= (not (and option-C option-E)) true)",
        "(= (not (and option-D option-E)) true)",
        "(= (not (and (not option-A) (not option-B) (not option-C) (not option-D) (not option-E))) true)"
      ],
      "type": "unsat",
      "perplexity": [
        1.0361613035202026,
        1.088927984237671
      ],
      "answer": "E",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "No Output"
    }
  },
  {
    "id": 36,
    "nl_problem": {
      "context": "Each of the seven members of the board of directors—Guzman, Hawking, Lepp, Miyauchi, Upchurch, Wharton, and Zhu—serves on exactly one of two committees—the finance committee or the incentives committee. Only board members serve on these committees. Committee membership is consistent with the following conditions: If Guzman serves on the finance committee, then Hawking serves on the incentives committee. If Lepp serves on the finance committee, then Miyauchi and Upchurch both serve on the incentives committee. Wharton serves on a different committee from the one on which Zhu serves. Upchurch serves on a different committee from the one on which Guzman serves. If Zhu serves on the finance committee, so does Hawking.",
      "question": "Which one of the following pairs of board members CANNOT both serve on the incentives committee?",
      "options": [
        "A) Guzman and Hawking",
        "B) Guzman and Wharton",
        "C) Hawking and Wharton",
        "D) Miyauchi and Upchurch",
        "E) Miyauchi and Wharton"
      ]
    },
    "answer": "C"
  },
  {
    "id": 37,
    "nl_problem": {
      "context": "Each of the seven members of the board of directors—Guzman, Hawking, Lepp, Miyauchi, Upchurch, Wharton, and Zhu—serves on exactly one of two committees—the finance committee or the incentives committee. Only board members serve on these committees. Committee membership is consistent with the following conditions: If Guzman serves on the finance committee, then Hawking serves on the incentives committee. If Lepp serves on the finance committee, then Miyauchi and Upchurch both serve on the incentives committee. Wharton serves on a different committee from the one on which Zhu serves. Upchurch serves on a different committee from the one on which Guzman serves. If Zhu serves on the finance committee, so does Hawking.",
      "question": "What is the maximum number of members on the finance committee?",
      "options": [
        "A) two",
        "B) three",
        "C) four",
        "D) five",
        "E) six"
      ]
    },
    "answer": "C",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((Directors 0)) (((Guzman) (Hawking) (Lepp) (Miyauchi) (Upchurch) (Wharton) (Zhu))))",
        "(declare-datatypes ((Committees 0)) (((finance) (incentives))))",
        "(declare-fun serves (Directors Committees) Bool)",
        "(declare-fun to-int ((b Bool)) Int (ite b 1 0))"
      ],
      "constraints": [
        "(forall ((d Directors) (c Committees)) (=> (not (and (serves d finance) (serves d incentives))) (or (= d Guzman) (= d Lepp))))",
        "(forall ((d Directors) (c Committees)) (=> (and (serves d finance) (= d Lepp)) (and (serves Miyauchi incentives) (serves Upchurch incentives))))",
        "(forall ((d1 Directors) (d2 Directors) (c Committees)) (not (= (serves d1 c) (serves d2 c))))",
        "(forall ((d1 Directors) (d2 Directors) (c Committees)) (not (= (serves d1 c) (serves d2 c))))",
        "(forall ((d Directors) (c Committees)) (=> (and (serves d finance) (= d Zhu)) (serves Hawking finance)))",
        "(forall ((d Directors) (c Committees)) (not (and (serves d finance) (serves d incentives))))",
        "(forall ((d Directors)) (or (serves d finance) (serves d incentives)))"
      ],
      "options": [
        "(= (+ (to-int (serves Guzman finance)) (to-int (serves Hawking finance)) (to-int (serves Lepp finance)) (to-int (serves Miyauchi finance)) (to-int (serves Upchurch finance)) (to-int (serves Wharton finance)) (to-int (serves Zhu finance))) 2)",
        "(= (+ (to-int (serves Guzman finance)) (to-int (serves Hawking finance)) (to-int (serves Lepp finance)) (to-int (serves Miyauchi finance)) (to-int (serves Upchurch finance)) (to-int (serves Wharton finance)) (to-int (serves Zhu finance))) 3)",
        "(= (+ (to-int (serves Guzman finance)) (to-int (serves Hawking finance)) (to-int (serves Lepp finance)) (to-int (serves Miyauchi finance)) (to-int (serves Upchurch finance)) (to-int (serves Wharton finance)) (to-int (serves Zhu finance))) 4)",
        "(= (+ (to-int (serves Guzman finance)) (to-int (serves Hawking finance)) (to-int (serves Lepp finance)) (to-int (serves Miyauchi finance)) (to-int (serves Upchurch finance)) (to-int (serves Wharton finance)) (to-int (serves Zhu finance))) 5)",
        "(= (+ (to-int (serves Guzman finance)) (to-int (serves Hawking finance)) (to-int (serves Lepp finance)) (to-int (serves Miyauchi finance)) (to-int (serves Upchurch finance)) (to-int (serves Wharton finance)) (to-int (serves Zhu finance))) 6)"
      ],
      "type": "sat",
      "perplexity": [
        1.1300327777862549,
        1.051783800125122
      ],
      "answer": "C",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "No Output"
    }
  },
  {
    "id": 38,
    "nl_problem": {
      "context": "Each of the seven members of the board of directors—Guzman, Hawking, Lepp, Miyauchi, Upchurch, Wharton, and Zhu—serves on exactly one of two committees—the finance committee or the incentives committee. Only board members serve on these committees. Committee membership is consistent with the following conditions: If Guzman serves on the finance committee, then Hawking serves on the incentives committee. If Lepp serves on the finance committee, then Miyauchi and Upchurch both serve on the incentives committee. Wharton serves on a different committee from the one on which Zhu serves. Upchurch serves on a different committee from the one on which Guzman serves. If Zhu serves on the finance committee, so does Hawking.",
      "question": "If Miyauchi and Wharton both serve on the finance committee, then which one of the following could be true?",
      "options": [
        "A) Guzman and Lepp both serve on the finance committee.",
        "B) Guzman and Upchurch both serve on the incentives committee.",
        "C) Hawking and Zhu both serve on the finance committee.",
        "D) Lepp and Upchurch both serve on the incentives committee.",
        "E) Zhu and Upchurch both serve on the finance committee."
      ]
    },
    "answer": "D",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((BoardMembers 0)) (((Guzman) (Hawking) (Lepp) (Miyauchi) (Upchurch) (Wharton) (Zhu))))",
        "(declare-datatypes ((Committees 0)) (((finance) (incentives))))",
        "(declare-fun serves (BoardMembers Committees) Bool)",
        "(define-fun to-int ((b Bool)) Int (ite b 1 0))",
        "(declare-fun num-committees (BoardMembers) Int)",
        "(declare-fun committee (BoardMembers) Committees)",
        "(declare-fun committee-members (Committees) (list BoardMembers))",
        "(declare-fun has-member ((Committees BoardMembers)) Bool)",
        "(define-fun committee-count ((b BoardMembers) (c Committees)) Int (ite (has-member c b) (to-int (serves b c)) 0))",
        "(define-fun total-committee-count ((b BoardMembers)) Int (ite (= b Guzman) (+ 2 (to-int (serves b finance)) (to-int (serves b incentives))) 1))",
        "(declare-fun distinct-committees ((BoardMembers BoardMembers)) Bool)",
        "(declare-fun consistent-committees (BoardMembers) Bool)",
        "(declare-fun finance-members () (list BoardMembers))",
        "(declare-fun incentives-members () (list BoardMembers))",
        "(define-fun has-finance-member ((b BoardMembers) (l (list BoardMembers))) Bool (or (not (null l)) (ite (not (null l)) (= b (car l)) (has-finance-member b (cdr l)))))",
        "(define-fun has-incentives-member ((b BoardMembers) (l (list BoardMembers))) Bool (or (not (null l)) (ite (not (null l)) (= b (car l)) (has-incentives-member b (cdr l)))))",
        "(declare-fun finance-or-incentives (BoardMembers) Committees)",
        "(declare-fun finance-count () Int)",
        "(declare-fun incentives-count () Int)",
        "(declare-fun finance-or-incentives-count (BoardMembers) Int)",
        "(declare-fun committee-member (BoardMembers Committees) Bool)",
        "(define-fun finance-or-incentives-count-helper ((b BoardMembers) (c Committees)) Int (ite (and (serves b finance) (has-finance-member (committee-members finance) b)) 1 (ite (serves b incentives) 1 0)))",
        "(define-fun finance-or-incentives-count-helper-helper ((b BoardMembers)) Int (ite (= b Guzman) (ite (not (serves b finance)) 2 (ite (not (serves b incentives)) 2 3)) 1))",
        "(declare-fun distinct-committees-helper ((BoardMembers) (Committees)) Bool)",
        "(define-fun distinct-committees-helper ((b BoardMembers) (c Committees)) Bool (ite (distinct-committees Zhu Wharton) (ite (distinct-committees Upchurch Guzman) (ite (distinct-committees Hawking Zhu) true (distinct-committees-helper b c)) (distinct-committees-helper b c))))",
        "(declare-fun all-committees-consistent () Bool)",
        "(define-fun all-committees-consistent-helper ((b BoardMembers)) Bool (ite (distinct-committees Zhu Wharton) (ite (distinct-committees Upchurch Guzman) (ite (distinct-committees Hawking Zhu) (ite (serves Guzman finance) (serves Hawking incentives) true (ite (serves Lepp finance) (distinct-committees Zhu Guzman) true (all-committees-consistent-helper b))) (all-committees-consistent-helper b)) (all-committees-consistent-helper b)))",
        "(declare-fun committee-members-count (Committees) Int)",
        "(declare-fun committee-member-count (Committees BoardMembers) Int)",
        "(define-fun committee-member-count-helper ((c Committees) (b BoardMembers)) Int (ite (has-member c b) 1 0))",
        "(declare-fun consistent-committees-helper ((BoardMembers)) Bool)",
        "(define-fun consistent-committees-helper ((b BoardMembers)) Bool (ite (= b Guzman) (ite (not (serves b finance)) (ite (serves Lepp finance) (ite (serves Upchurch incentives) true (ite (serves Zhu finance) (serves Hawking incentives) true (distinct-committees Zhu Upchurch))) (distinct-committees Zhu Upchurch)) true (consistent-committees-helper b)))",
        "(declare-fun distinct-committees-helper-helper ((BoardMembers BoardMembers)) Bool)",
        "(define-fun distinct-committees-helper-helper ((b1 BoardMembers) (b2 BoardMembers)) Bool (ite (or (= b1 Zhu) (= b1 Wharton)) (ite (or (= b2 Zhu) (= b2 Wharton)) true (ite (distinct-committees b1 b2) (distinct-committees-helper-helper b1 b2) true)) true))",
        "(declare-fun distinct-committees-helper-helper-helper ((BoardMembers BoardMembers)) Bool)",
        "(define-fun distinct-committees-helper-helper-helper ((b1 BoardMembers) (b2 BoardMembers)) Bool (ite (= b1 Upchurch) (ite (or (= b2 Guzman) (= b2 Zhu)) true (distinct-committees-helper-helper-helper b1 b2)) true))",
        "(declare-fun consistent-committees-helper-helper ((BoardMembers) (Committees) (BoardMembers) (Committees)) Bool)",
        "(define-fun consistent-committees-helper-helper ((b BoardMembers) (c Committees) (b1 BoardMembers) (c1 Committees)) Bool (ite (= b Guzman) (ite (not (serves b finance)) (ite (serves Lepp finance) (ite (serves Upchurch incentives) true (ite (serves Zhu finance) (serves Hawking incentives) true (ite (distinct-committees Zhu Upchurch) (ite (serves b1 finance) (ite (not (serves b1 incentives)) (ite (serves Hawking finance) true (ite (serves Lepp incentives) (ite (serves Zhu incentives) true (distinct-committees Zhu b1))) (distinct-committees Zhu b1))) (distinct-committees Zhu b1)))) (distinct-committees Zhu Upchurch))) true (consistent-committees-helper-helper b c b1 c1)))",
        "(declare-fun Miyauchi-Wharton-finance () Bool)",
        "(declare-fun Guzman-Lepp-finance () Bool)",
        "(declare-fun Zhu-Hawking-finance () Bool)",
        "(declare-fun Zhu-Upchurch-finance () Bool)",
        "(declare-fun Lepp-Upchurch-incentives () Bool)",
        "(declare-fun Guzman-Upchurch-incentives () Bool)",
        "(declare-fun Miyauchi-Upchurch-finance () Bool)",
        "(declare-fun Zhu-Hawking-incentives () Bool)",
        "(declare-fun Guzman-Lepp-incentives () Bool)",
        "(define-fun Miyauchi-Wharton-finance-helper () Bool (distinct-committees Zhu Wharton))",
        "(define-fun Guzman-Lepp-finance-helper () Bool (and (serves Guzman finance) (serves Lepp finance)))",
        "(define-fun Zhu-Hawking-finance-helper () Bool (and (serves Zhu finance) (serves Hawking finance)))",
        "(define-fun Zhu-Upchurch-finance-helper () Bool (and (serves Zhu finance) (serves Upchurch finance)))",
        "(define-fun Lepp-Upchurch-incentives-helper () Bool (and (serves Lepp incentives) (serves Upchurch incentives)))",
        "(define-fun Guzman-Upchurch-incentives-helper () Bool (and (serves Guzman incentives) (serves Upchurch incentives)))",
        "(define-fun Miyauchi-Upchurch-finance-helper () Bool (and (serves Miyauchi finance) (serves Upchurch finance)))",
        "(define-fun Zhu-Hawking-incentives-helper () Bool (and (serves Zhu incentives) (serves Hawking incentives)))",
        "(define-fun Guzman-Lepp-incentives-helper () Bool (and (serves Guzman incentives) (serves Lepp incentives)))",
        "(declare-fun correct-answer () Bool)",
        "(declare-fun correct-answer () Bool)",
        "(declare-fun correct-answer () Bool)",
        "(define-fun Miyauchi-Wharton-finance () Bool Miyauchi-Wharton-finance-helper)",
        "(define-fun Miyauchi-Upchurch-finance () Bool Miyauchi-Upchurch-finance-helper)",
        "(define-fun Guzman-Lepp-finance () Bool Guzman-Lepp-finance-helper)",
        "(define-fun Zhu-Hawking-finance () Bool Zhu-Hawking-finance-helper)",
        "(define-fun Zhu-Upchurch-finance () Bool Zhu-Upchurch-finance-helper)",
        "(define-fun Zhu-Hawking-incentives () Bool Zhu-Hawking-incentives-helper)",
        "(define-fun Guzman-Upchurch-incentives () Bool Guzman-Upchurch-incentives-helper)",
        "(define-fun Guzman-Lepp-incentives () Bool Guzman-Lepp-incentives-helper)",
        "(define-fun Lepp-Upchurch-incentives () Bool Lepp-Upchurch-incentives-helper)",
        "(define-fun correct-answer-helper () Bool (ite Miyauchi-Wharton-finance (ite (or Guzman-Lepp-finance Zhu-Hawking-finance Zhu-Upchurch-finance) (ite (and Zhu-Hawking-incentives Guzman-Upchurch-incentives) true (and Lepp-Upchurch-incentives Guzman-Lepp-incentives)) true) true))",
        "(declare-fun sat () Bool)",
        "(assert (consistent-committees-helper Zhu incentives))",
        "(assert (distinct-committees Zhu Upchurch))",
        "(assert (all-committees-consistent))",
        "(assert Miyauchi-Wharton-finance)",
        "(assert (or Guzman-Lepp-finance Zhu-Hawking-finance Zhu-Upchurch-finance))",
        "(assert (or (and Zhu-Hawking-incentives Guzman-Upchurch-incentives) (and Lepp-Upchurch-incentives Guzman-Lepp-incentives)))",
        "(assert (correct-answer-helper))",
        "(assert (or sat (not sat)))",
        "(get-model)",
        "(check-sat)"
      ],
      "constraints": [
        "(assert (consistent-committees-helper Zhu incentives))",
        "(assert (distinct-committees Zhu Upchurch))",
        "(assert (all-committees-consistent))",
        "(assert Miyauchi-Wharton-finance)",
        "(assert (or Guzman-Lepp-finance Zhu-Hawking-finance Zhu-Upchurch-finance))",
        "(assert (or (and Zhu-Hawking-incentives Guzman-Upchurch-incentives) (and Lepp-Upchurch-incentives Guzman-Lepp-incentives)))",
        "(assert (correct-answer-helper))",
        "(assert (or sat (not sat)))"
      ],
      "options": [
        "(assert (or (and Zhu-Hawking-incentives Guzman-Upchurch-incentives) (and Lepp-Upchurch-incentives Guzman-Lepp-incentives)))",
        "(assert (or Guzman-Lepp-finance Zhu-Hawking-finance Zhu-Upchurch-finance))",
        "(assert Miyauchi-Wharton-finance)"
      ],
      "type": "unsat",
      "perplexity": [
        1.2821073532104492,
        1.025976538658142
      ],
      "answer": "D",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "No Output"
    }
  },
  {
    "id": 39,
    "nl_problem": {
      "context": "Each of the seven members of the board of directors—Guzman, Hawking, Lepp, Miyauchi, Upchurch, Wharton, and Zhu—serves on exactly one of two committees—the finance committee or the incentives committee. Only board members serve on these committees. Committee membership is consistent with the following conditions: If Guzman serves on the finance committee, then Hawking serves on the incentives committee. If Lepp serves on the finance committee, then Miyauchi and Upchurch both serve on the incentives committee. Wharton serves on a different committee from the one on which Zhu serves. Upchurch serves on a different committee from the one on which Guzman serves. If Zhu serves on the finance committee, so does Hawking.",
      "question": "If Guzman serves on the incentives committee, then which one of the following must be true?",
      "options": [
        "A) Hawking serves on the finance committee.",
        "B) Lepp serves on the incentives committee.",
        "C) Miyauchi serves on the finance committee.",
        "D) Wharton serves on the incentives committee.",
        "E) Zhu serves on the finance committee."
      ]
    },
    "answer": "B",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((Board_Members 0)) (((Guzman) (Hawking) (Lepp) (Miyauchi) (Upchurch) (Wharton) (Zhu))))",
        "(declare-datatypes ((Committees 0)) (((finance) (incentives))))",
        "(declare-fun serves (Board_Members Committees) Bool)"
      ],
      "constraints": [
        "(forall ((b Board_Members)) (exists ((c Committees)) (and (= b b) (serves b c))))",
        "(forall ((b Board_Members)) (not (exists ((c1 Committees) (c2 Committees)) (= c1 c2) (and (serves b c1) (serves b c2)))))",
        "(:= (serves Guzman finance) (serves Hawking incentives))",
        "(:= (serves Lepp finance) (and (serves Miyauchi incentives) (serves Upchurch incentives)))",
        "(:not (exists ((c1 Committees) (c2 Committees)) (= c1 c2) (and (serves Wharton c1) (serves Zhu c2))))",
        "(:not (exists ((c1 Committees) (c2 Committees)) (= c1 c2) (and (serves Upchurch c1) (serves Guzman c2))))",
        "(:= (serves Zhu finance) (serves Hawking finance))",
        "(:= (serves Guzman incentives) (serves Hawking finance))",
        "(:= (serves Guzman incentives) (serves Lepp incentives))",
        "(:= (serves Guzman incentives) (serves Miyauchi finance))",
        "(:= (serves Guzman incentives) (serves Wharton incentives))",
        "(:= (serves Guzman incentives) (serves Zhu finance))"
      ],
      "options": [
        "(:= (serves Guzman incentives) (serves Hawking finance))",
        "(:= (serves Guzman incentives) (serves Lepp incentives))",
        "(:= (serves Guzman incentives) (serves Miyauchi finance))",
        "(:= (serves Guzman incentives) (serves Wharton incentives))",
        "(:= (serves Guzman incentives) (serves Zhu finance))"
      ],
      "type": "unsat",
      "perplexity": [
        1.1096359491348267,
        1.0959895849227905
      ],
      "answer": "B",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "No Output"
    }
  },
  {
    "id": 40,
    "nl_problem": {
      "context": "Eight people—Fiona, George, Harriet, Ingrid, Karl, Manuel, Olivia, and Peter—are sitting, evenly spaced, around a circular picnic table. Any two of them are said to be sitting directly across from one another if and only if there are exactly three other people sitting between them, counting in either direction around the table. The following conditions apply: Fiona sits directly across from George. Harriet sits immediately next to neither Fiona nor Karl. Ingrid sits immediately next to, and immediately clockwise from, Olivia.",
      "question": "Which one of the following could be the order in which four of the people are seated, with no one else seated between them, counting clockwise around the table?",
      "options": [
        "A) George, Peter, Karl, Fiona",
        "B) Harriet, Olivia, Ingrid, Karl",
        "C) Ingrid, Fiona, Peter, Manuel",
        "D) Olivia, Manuel, Karl, George",
        "E) Peter, Harriet, Karl, Fiona"
      ]
    },
    "answer": "C",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((People 0)) (((Fiona) (George) (Harriet) (Ingrid) (Karl) (Manuel) (Olivia) (Peter))))",
        "(declare-fun sits-after (People People) Bool)",
        "(declare-fun sits-across-from (People People) Bool)"
      ],
      "constraints": [
        "(forall ((p People) (q People)) (not (= (sits-after p q) (sits-after q p))))",
        "(forall ((p People) (q People)) (not (= (sits-across-from p q) (sits-across-from q p))))",
        "(forall ((p People) (q People)) (not (= (sits-after p q) (sits-across-from p q))))",
        "(forall ((p People) (q People)) (= (sits-across-from p q) (and (not (= p q)) (exists ((x People) (y People)) (= (and (sits-after p x) (sits-after q y)) (or (and (sits-after x q) (sits-after y p)) (and (sits-after p q) (sits-after x y))))))))",
        "(sits-across-from Fiona George)",
        "(forall ((q People)) (not (and (sits-after q Fiona) (distinct q Karl))))",
        "(forall ((q People)) (and (= (sits-after q Olivia) (or (distinct q Ingrid) (distinct q Karl))) (= (sits-after q Ingrid) (or (distinct q Ingrid) (distinct q Karl)))))",
        "(distinct (sits-after George Peter) (sits-after George Karl)) (distinct (sits-after George Peter) (sits-across-from George Peter)) (distinct (sits-after George Karl) (sits-after Karl George)) (distinct (sits-after George Karl) (sits-across-from George Karl))",
        "(forall ((p People) (q People) (r People) (s People)) (or (= (distinct p q) (distinct q r)) (distinct p r)))",
        "(forall ((p People) (q People) (r People)) (or (= (distinct p q) (distinct q r)) (distinct p r)))",
        "(forall ((p People)) (not (and (sits-after Karl p) (distinct p George))))",
        "(forall ((p People)) (not (and (sits-after Karl p) (distinct p Peter))))"
      ],
      "options": [
        "(forall ((p People)) (forall ((q People)) (forall ((r People)) (forall ((s People)) (and (sits-after p q) (sits-after q r) (sits-after r s) (= p George) (= q Peter) (= r Karl) (= s Fiona)))))",
        "(forall ((p People)) (forall ((q People)) (forall ((r People)) (forall ((s People)) (and (sits-after p q) (sits-after q r) (sits-after r s) (= p Harriet) (= q Olivia) (= r Ingrid) (= s Karl)))))",
        "(forall ((p People)) (forall ((q People)) (forall ((r People)) (forall ((s People)) (and (sits-after p q) (sits-after q r) (sits-after r s) (= p Ingrid) (= q Fiona) (= r Peter) (= s Manuel)))))",
        "(forall ((p People)) (forall ((q People)) (forall ((r People)) (forall ((s People)) (and (sits-after p q) (sits-after q r) (sits-after r s) (= p Olivia) (= q Manuel) (= r Karl) (= s George)))))",
        "(forall ((p People)) (forall ((q People)) (forall ((r People)) (forall ((s People)) (and (sits-after p q) (sits-after q r) (sits-after r s) (= p Peter) (= q Harriet) (= r Karl) (= s Fiona))))"
      ],
      "type": "sat",
      "perplexity": [
        1.199347972869873,
        1.0512045621871948
      ],
      "answer": "C",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "No Output"
    }
  },
  {
    "id": 41,
    "nl_problem": {
      "context": "Eight people—Fiona, George, Harriet, Ingrid, Karl, Manuel, Olivia, and Peter—are sitting, evenly spaced, around a circular picnic table. Any two of them are said to be sitting directly across from one another if and only if there are exactly three other people sitting between them, counting in either direction around the table. The following conditions apply: Fiona sits directly across from George. Harriet sits immediately next to neither Fiona nor Karl. Ingrid sits immediately next to, and immediately clockwise from, Olivia.",
      "question": "If Harriet and Olivia each sits immediately next to George, then which one of the following could be the two people each of whom sits immediately next to Peter?",
      "options": [
        "A) Fiona and Karl",
        "B) Fiona and Olivia",
        "C) Harriet and Ingrid",
        "D) Harriet and Karl",
        "E) Karl and Manuel"
      ]
    },
    "answer": "D",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((People 0)) (((Fiona) (George) (Harriet) (Ingrid) (Karl) (Manuel) (Olivia) (Peter))))",
        "(declare-datatypes ((Position 0)) (((North) (Northeast) (East) (Southeast) (South) (Southwest) (West) (Northwest))))",
        "(declare-fun sits (People Position) Bool)",
        "(declare-fun sits-across (People People) Bool)"
      ],
      "constraints": [
        "(define-fun sits-clockwise ((p1 People) (p2 People)) Bool ...)",
        "(define-fun sits-counterclockwise ((p1 People) (p2 People)) Bool ...)",
        "(define-fun sits-directly-across ((p1 People) (p2 People)) Bool ...)",
        "(define-fun sits-immediately-next-to-clockwise ((p1 People) (p2 People) Position) Bool ...)",
        "(define-fun sits-immediately-next-to-counterclockwise ((p1 People) (p2 People) Position) Bool ...)",
        "(define-fun sits-next ((p1 People) (p2 People)) Position ...)",
        "(define-fun sits-next-clockwise ((p1 People) (p2 People)) Position ...)",
        "(define-fun sits-next-counterclockwise ((p1 People) (p2 People)) Position ...)",
        "(define-fun sits-between ((p1 People) (p2 People)) Position ...)",
        "(define-fun sits-between-counterclockwise ((p1 People) (p2 People)) Position ...)",
        "(define-fun sits-counterclockwise-between ((p1 People) (p2 People)) Position ...)",
        "(define-fun sits-clockwise-between ((p1 People) (p2 People)) Position ...)",
        "(define-fun sits-adjacent-to ((p1 People) (p2 People)) Bool ...)",
        "(define-fun sits-across ((p1 People) (p2 People)) Bool ...)",
        "(define-fun sits-sits-directly-across ((p1 People) (p2 People)) Bool ...)",
        "(define-fun sits-between ((p1 People) (p2 People)) Position ...)",
        "(define-fun sits-between-counterclockwise ((p1 People) (p2 People)) Position ...)",
        "(define-fun sits-between-counterclockwise ((p1 People) (p2 People)) Position ...)",
        "(define-fun sits-between-counterclockwise ((p1 People) (p2 People)) Position ...)",
        "(define-fun sits-between ((p1 People) (p2 People)) Position ...)",
        "(define-fun sits-between-counterclockwise ((p1 People) (p2 People)) Position ...)",
        "(define-fun sits-between-counterclockwise ((p1 People) (p2 People)) Position ...)",
        "(define-fun sits-between-counterclockwise ((p1 People) (p2 People)) Position ...)",
        "(define-fun sits-between-counterclockwise ((p1 People) (p2 People)) Position ...)",
        "(define-fun sits-between-counterclockwise ((p1 People) (p2 People)) Position ...)"
      ],
      "options": [
        "(assert (= (sits Olivia Northwest) true))",
        "(assert (= (sits George East) true))",
        "(assert (= (sits Manuel Northeast) true))",
        "(assert (= (sits Harriet South) true))",
        "(assert (= (sits Fiona North) true))",
        "(assert (= (sits Ingrid West) true))",
        "(assert (= (sits Karl Southwest) true))",
        "(assert (= (sits Peter Southeast) true))"
      ],
      "type": "unsat",
      "perplexity": [
        1.044836163520813,
        1.135750651359558
      ],
      "answer": "D",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "No Output"
    }
  },
  {
    "id": 42,
    "nl_problem": {
      "context": "Eight people—Fiona, George, Harriet, Ingrid, Karl, Manuel, Olivia, and Peter—are sitting, evenly spaced, around a circular picnic table. Any two of them are said to be sitting directly across from one another if and only if there are exactly three other people sitting between them, counting in either direction around the table. The following conditions apply: Fiona sits directly across from George. Harriet sits immediately next to neither Fiona nor Karl. Ingrid sits immediately next to, and immediately clockwise from, Olivia.",
      "question": "If George does not sit immediately next to Harriet, then which one of the following could be the two people each of whom sits immediately next to Manuel?",
      "options": [
        "A) Fiona and Harriet",
        "B) Fiona and Peter",
        "C) George and Karl",
        "D) George and Peter",
        "E) Harriet and Peter"
      ]
    },
    "answer": "A",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((People 0)) (((Fiona) (George) (Harriet) (Ingrid) (Karl) (Manuel) (Olivia) (Peter))))",
        "(declare-datatypes ((Indices 0)) (((0) (1) (2) (3) (4) (5) (6) (7))))",
        "(declare-fun sits (People Indices People) Bool)",
        "(declare-fun adjacent (People Indices People Indices) Bool)",
        "(define-fun to-int ((b Bool)) Int (ite b 1 0))",
        "(define-fun is-direct-across ((i Int) (j Int) (p People) (q People)) Bool (let ((m (+ i 4))) (or (and (= m j) (distinct p q)) (and (distinct m i) (distinct m j) (distinct p q)))))",
        "(define-fun is-adjacent ((i Int) (j Int) (p People) (q People)) Bool (or (= (ite (and (< i j) (= (- j i) 1)) 1 0) 1) (= (ite (and (>= i j) (= (- i j) 1)) 1 0) 1)))"
      ],
      "constraints": [
        "(forall ((i Indices) (p People)) (distinct p (ite (= i 0) Fiona (ite (= i 1) George (ite (= i 2) Harriet (ite (= i 3) Ingrid (ite (= i 4) Karl (ite (= i 5) Manuel (ite (= i 6) Olivia (ite (= i 7) Peter)))))))))))",
        "(forall ((i Indices) (j Indices) (p People) (q People) (r People)) (implies (adjacent p i q j) (distinct i j)))",
        "(forall ((i Indices) (p People) (q People)) (implies (is-direct-across i j p q) (adjacent p i q j) (adjacent q j p i)))",
        "(forall ((i Indices) (p People)) (implies (distinct i 2) (adjacent p i (ite (= i 0) Fiona (ite (= i 1) George (ite (= i 2) Harriet (ite (= i 3) Ingrid (ite (= i 4) Karl (ite (= i 5) Manuel (ite (= i 6) Olivia (ite (= i 7) Peter))))))))))))",
        "(forall ((i Indices) (j Indices) (p People) (q People)) (implies (distinct i j) (is-adjacent i j p q) (adjacent p i q j)))",
        "(forall ((i Indices) (p People) (q People)) (implies (is-adjacent i j p q) (distinct p q)))",
        "(ite (= (ite (= (ite (= (ite (= (ite (= (ite (= 0 0) Fiona) George) Harriet) false) true) 0) 0) 1) 1 (ite (ite (= (ite (= (ite (= 0 0) Fiona) George) Harriet) false) true) 0) 0) 0) 0) (ite (ite (= (ite (= (ite (= 1 1) George) Harriet) false) true) 0) 0) 0) 0) (= (ite (= 0 0) 0) 0) (= 3 1))",
        "(forall ((i Indices) (p People) (q People)) (implies (distinct p q) (is-direct-across i j p q) (adjacent p i q j)))",
        "(ite (= (ite (= (ite (= (ite (= 0 0) Fiona) George) Harriet) false) true) 0) 0) (ite (ite (= (ite (= 1 1) George) Harriet) false) true) 0) (ite (ite (= 3 1) true) 1 0) (ite (ite (= (ite (= (ite (= 2 2) Harriet) Karl) false) true) 0) 0) 0))",
        "(forall ((i Indices) (p People)) (implies (distinct i 6) (adjacent p i (ite (= i 0) Fiona (ite (= i 1) George (ite (= i 2) Harriet (ite (= i 3) Ingrid (ite (= i 4) Karl (ite (= i 5) Manuel (ite (= i 6) Olivia (ite (= i 7) Peter))))))))))))",
        "(forall ((i Indices) (p People)) (implies (distinct i 5) (adjacent p i (ite (= i 0) Fiona (ite (= i 1) George (ite (= i 2) Harriet (ite (= i 3) Ingrid (ite (= i 4) Karl (ite (= i 5) Manuel (ite (= i 6) Olivia (ite (= i 7) Peter))))))))))))",
        "(forall ((i Indices) (p People)) (implies (distinct i 3) (adjacent p i (ite (= i 0) Fiona (ite (= i 1) George (ite (= i 2) Harriet (ite (= i 3) Ingrid (ite (= i 4) Karl (ite (= i 5) Manuel (ite (= i 6) Olivia (ite (= i 7) Peter))))))))))))",
        "(forall ((i Indices) (p People)) (implies (distinct i 4) (adjacent p i (ite (= i 0) Fiona (ite (= i 1) George (ite (= i 2) Harriet (ite (= i 3) Ingrid (ite (= i 4) Karl (ite (= i 5) Manuel (ite (= i 6) Olivia (ite (= i 7) Peter))))))))))))",
        "(forall ((i Indices) (j Indices) (p People) (q People)) (implies (adjacent p i q j) (ite (ite (= i j) 1 0) 0) (ite (ite (= j i) 1 0) 0)))",
        "(forall ((i Indices) (j Indices) (p People) (q People)) (implies (adjacent p i q j) (ite (ite (= i j) 1 0) 0) (ite (ite (= j i) 1 0) 0)))",
        "(forall ((i Indices) (p People) (q People)) (implies (distinct p q) (is-adjacent i j p q) (adjacent p i q j)))",
        "(forall ((i Indices) (j Indices) (p People) (q People)) (implies (adjacent p i q j) (distinct p q)))",
        "(forall ((i Indices) (p People) (q People)) (implies (is-adjacent i j p q) (adjacent p i q j)))",
        "(forall ((i Indices) (j Indices) (p People) (q People)) (implies (adjacent p i q j) (is-adjacent i j p q)))",
        "(forall ((i Indices) (j Indices) (p People) (q People)) (implies (adjacent p i q j) (adjacent q j p i)))",
        "(forall ((i Indices) (p People) (q People)) (implies (adjacent p i q i) (is-direct-across i i p q)))",
        "(forall ((i Indices) (j Indices) (p People) (q People)) (implies (is-adjacent i j p q) (adjacent p i q j)))"
      ],
      "options": [
        "(not (exists ((i Indices)) (exists ((j Indices)) (exists ((p People)) (exists ((q People)) (adjacent p i q j) (= p Fiona) (= q Harriet)))))",
        "(not (exists ((i Indices)) (exists ((j Indices)) (exists ((p People)) (exists ((q People)) (adjacent p i q j) (= p Fiona) (= q Peter)))))",
        "(not (exists ((i Indices)) (exists ((j Indices)) (exists ((p People)) (exists ((q People)) (adjacent p i q j) (= p George) (= q Karl))))",
        "(not (exists ((i Indices)) (exists ((j Indices)) (exists ((p People)) (exists ((q People)) (adjacent p i q j) (= p George) (= q Peter))))",
        "(not (exists ((i Indices)) (exists ((j Indices)) (exists ((p People)) (exists ((q People)) (adjacent p i q j) (= p Harriet) (= q Peter)))))"
      ],
      "type": "unsat",
      "perplexity": [
        1.2155084609985352,
        1.0259621143341064
      ],
      "answer": "A",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "No Output"
    }
  },
  {
    "id": 43,
    "nl_problem": {
      "context": "Eight people—Fiona, George, Harriet, Ingrid, Karl, Manuel, Olivia, and Peter—are sitting, evenly spaced, around a circular picnic table. Any two of them are said to be sitting directly across from one another if and only if there are exactly three other people sitting between them, counting in either direction around the table. The following conditions apply: Fiona sits directly across from George. Harriet sits immediately next to neither Fiona nor Karl. Ingrid sits immediately next to, and immediately clockwise from, Olivia.",
      "question": "If Manuel sits immediately next to Olivia, then which one of the following people must sit immediately next to Fiona?",
      "options": [
        "A) Harriet",
        "B) Ingrid",
        "C) Karl",
        "D) Manuel",
        "E) Peter"
      ]
    },
    "answer": "C",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((People 0)) (((Fiona) (George) (Harriet) (Ingrid) (Karl) (Manuel) (Olivia) (Peter))))",
        "(declare-datatypes ((Positions 0)) (((position Fiona) (position George) (position Harriet) (position Ingrid) (position Karl) (position Manuel) (position Olivia) (position Peter))))",
        "(declare-fun sits (People Positions) Bool)",
        "(declare-fun position (People) Positions)",
        "(define-fun count-between (p1 p2) Int (ite (sits p2 (ite (< (- p1 p2) 0) (- p1 p2) (- p2 p1))) 0 1))"
      ],
      "constraints": [
        " (= (count-between Fiona George) 3)",
        " (not (and (< (count-between Fiona Harriet) 1) (< (count-between Karl Harriet) 1)))",
        " (and (= (count-between Ingrid Olivia) 1) (= (ite (< (- (position Ingrid) (position Olivia)) 0) (- (position Ingrid) (position Olivia)) (- (position Olivia) (position Ingrid))) 1))"
      ],
      "options": [
        " (=> (and (sits Manuel (position Olivia)) (= (count-between Fiona Harriet) 1)) (= (count-between Fiona (ite (< (- (position Karl) (position Fiona)) 0) (- (position Karl) (position Fiona)) (- (position Fiona) (position Karl))) 1))",
        " (=> (and (sits Manuel (position Olivia)) (= (count-between Fiona Harriet) 1)) (= (count-between Fiona (ite (< (- (position Ingrid) (position Fiona)) 0) (- (position Ingrid) (position Fiona)) (- (position Fiona) (position Ingrid))) 1))",
        " (=> (and (sits Manuel (position Olivia)) (= (count-between Fiona Harriet) 1)) (= (count-between Fiona (ite (< (- (position Manuel) (position Fiona)) 0) (- (position Manuel) (position Fiona)) (- (position Fiona) (position Manuel))) 1))",
        " (=> (and (sits Manuel (position Olivia)) (= (count-between Fiona Harriet) 1)) (= (count-between Fiona (ite (< (- (position Peter) (position Fiona)) 0) (- (position Peter) (position Fiona)) (- (position Fiona) (position Peter))) 1))"
      ],
      "type": "unsat",
      "perplexity": [
        1.2315024137496948,
        1.0730986595153809
      ],
      "answer": "C",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "No Output"
    }
  },
  {
    "id": 44,
    "nl_problem": {
      "context": "Eight people—Fiona, George, Harriet, Ingrid, Karl, Manuel, Olivia, and Peter—are sitting, evenly spaced, around a circular picnic table. Any two of them are said to be sitting directly across from one another if and only if there are exactly three other people sitting between them, counting in either direction around the table. The following conditions apply: Fiona sits directly across from George. Harriet sits immediately next to neither Fiona nor Karl. Ingrid sits immediately next to, and immediately clockwise from, Olivia.",
      "question": "What is the minimum possible number of people sitting between Ingrid and Manuel, counting clockwise from Ingrid around the table?",
      "options": [
        "A) zero",
        "B) one",
        "C) two",
        "D) three",
        "E) four"
      ]
    },
    "answer": "A",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((People 0)) (((Fiona) (George) (Harriet) (Ingrid) (Karl) (Manuel) (Olivia) (Peter))))",
        "(declare-fun sits-next-to (People People) Bool)",
        "(declare-fun sits-across (People People) Bool)",
        "(declare-fun between (People People) Int)",
        "(declare-fun index (People) Int)"
      ],
      "constraints": [
        "(declare-fun f-index () Int)",
        "(declare-fun g-index () Int)",
        "(declare-fun h-index () Int)",
        "(declare-fun i-index () Int)",
        "(declare-fun k-index () Int)",
        "(declare-fun m-index () Int)",
        "(declare-fun o-index () Int)",
        "(declare-fun p-index () Int)",
        "(define-fun sits-directly-across ((p People) (q People)) Bool (= (+ (index p) (index q)) 3))",
        "(assert (sits-directly-across Fiona George))",
        "(assert (= (index Ingrid) (+ 1 (index Olivia))))",
        "(assert (sits-next-to Ingrid Olivia))",
        "(assert (not (= (index Ingrid) (index Olivia))))",
        "(assert (not (sits-next-to Harriet Fiona)))",
        "(assert (not (sits-next-to Harriet Karl)))",
        "(assert (not (= (index Fiona) (index George))))",
        "(assert (not (= (index Fiona) (index Harriet))))",
        "(assert (not (= (index Fiona) (index Ingrid))))",
        "(assert (not (= (index Fiona) (index Karl))))",
        "(assert (not (= (index Fiona) (index Manuel))))",
        "(assert (not (= (index Fiona) (index Olivia))))",
        "(assert (not (= (index Fiona) (index Peter))))",
        "(assert (not (= (index George) (index Harriet))))",
        "(assert (not (= (index George) (index Ingrid))))",
        "(assert (not (= (index George) (index Karl))))",
        "(assert (not (= (index George) (index Manuel))))",
        "(assert (not (= (index George) (index Olivia))))",
        "(assert (not (= (index George) (index Peter))))",
        "(assert (not (= (index Harriet) (index Ingrid))))",
        "(assert (not (= (index Harriet) (index Karl))))",
        "(assert (not (= (index Harriet) (index Manuel))))",
        "(assert (not (= (index Harriet) (index Olivia))))",
        "(assert (not (= (index Harriet) (index Peter))))",
        "(assert (not (= (index Ingrid) (index Karl))))",
        "(assert (not (= (index Ingrid) (index Manuel))))",
        "(assert (not (= (index Ingrid) (index Olivia))))",
        "(assert (not (= (index Ingrid) (index Peter))))",
        "(assert (not (= (index Karl) (index Manuel))))",
        "(assert (not (= (index Karl) (index Olivia))))",
        "(assert (not (= (index Karl) (index Peter))))",
        "(assert (not (= (index Manuel) (index Olivia))))",
        "(assert (not (= (index Manuel) (index Peter))))",
        "(assert (not (and (sits-next-to p1 p2) (= (index p1) (index p2)))))",
        "(assert (not (and (sits-across p1 p2) (= (index p1) (index p2)))))",
        "(define-fun between ((p People) (q People)) Int (ite (= (index p) (+ 1 (index q))) 1 (ite (> (index p) (index q)) (- (index p) (index q)) (- (+ 8 (index q)) (index p)))))",
        "(assert (or (= (between Ingrid Manuel) 0) (= (between Ingrid Manuel) 1) (= (between Ingrid Manuel) 2) (= (between Ingrid Manuel) 3) (= (between Ingrid Manuel) 4)))"
      ],
      "options": [
        "(= (between Ingrid Manuel) 0)",
        "(= (between Ingrid Manuel) 1)",
        "(= (between Ingrid Manuel) 2)",
        "(= (between Ingrid Manuel) 3)",
        "(= (between Ingrid Manuel) 4)"
      ],
      "type": "unsat",
      "perplexity": [
        1.1830711364746094,
        1.0422630310058594
      ],
      "answer": "A",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "No Output"
    }
  },
  {
    "id": 45,
    "nl_problem": {
      "context": "Eight people—Fiona, George, Harriet, Ingrid, Karl, Manuel, Olivia, and Peter—are sitting, evenly spaced, around a circular picnic table. Any two of them are said to be sitting directly across from one another if and only if there are exactly three other people sitting between them, counting in either direction around the table. The following conditions apply: Fiona sits directly across from George. Harriet sits immediately next to neither Fiona nor Karl. Ingrid sits immediately next to, and immediately clockwise from, Olivia.",
      "question": "If Karl sits directly across from Ingrid, then each of the following people could sit immediately next to Olivia EXCEPT:",
      "options": [
        "A) Fiona",
        "B) George",
        "C) Harriet",
        "D) Manuel",
        "E) Peter"
      ]
    },
    "answer": "B",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((People 0)) (((Fiona) (George) (Harriet) (Ingrid) (Karl) (Manuel) (Olivia) (Peter))))",
        "(declare-datatypes ((Positions 0)) (((f1) (f2) (f3) (f4) (f5) (f6) (f7) (f8))))",
        "(declare-fun sits (People Positions) Bool)"
      ],
      "constraints": [
        "(define-fun dist' ((p1 People) (p2 People)) Int ...)",
        "(define-fun is-direct-across ((p1 People) (p2 People)) Bool ...)",
        "(define-fun is-immediately-next-to ((p1 People) (p2 People)) Bool ...)",
        "(define-fun is-immediately-clockwise-from ((p1 People) (p2 People)) Bool ...)",
        "(define-fun is-sitting-between ((p1 People) (p2 People) (p3 People)) Bool ...)",
        "(define-fun condition1 () Bool (and (is-direct-across Fiona George) (not (is-immediately-next-to Fiona George))))",
        "(define-fun condition2 () Bool (forall ((p People)) (not (is-immediately-next-to Harriet p))))",
        "(define-fun condition3 () Bool (forall ((p People)) (or (is-immediately-clockwise-from p Olivia) (is-immediately-next-to p Olivia))))",
        "(define-fun Karl-sits-across-from-Ingrid () Bool (is-direct-across Karl Ingrid))",
        "(define-fun option-choice (p People) Bool (forall ((q People)) (or (is-sitting-between p Olivia q) (and (distinct p q) (= (mod (dist' p q) 8) 7) ...)))",
        "(assert (forall ((p People)) (not (and Karl-sits-across-from-Ingrid (option-choice p Olivia)))))"
      ],
      "options": [
        "(define-fun option () Bool (forall ((p People)) (distinct p Olivia)))"
      ],
      "type": "unsat",
      "perplexity": [
        1.1832404136657715,
        1.1167465448379517
      ],
      "answer": "B",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "No Output"
    }
  },
  {
    "id": 46,
    "nl_problem": {
      "context": "Eight people—Fiona, George, Harriet, Ingrid, Karl, Manuel, Olivia, and Peter—are sitting, evenly spaced, around a circular picnic table. Any two of them are said to be sitting directly across from one another if and only if there are exactly three other people sitting between them, counting in either direction around the table. The following conditions apply: Fiona sits directly across from George. Harriet sits immediately next to neither Fiona nor Karl. Ingrid sits immediately next to, and immediately clockwise from, Olivia.",
      "question": "If Karl sits directly across from Harriet, then what is the minimum possible number of people sitting between George and Karl, counting clockwise from George to Karl?",
      "options": [
        "A) zero",
        "B) one",
        "C) two",
        "D) three",
        "E) four"
      ]
    },
    "answer": "C",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((People 0)) (((Fiona) (George) (Harriet) (Ingrid) (Karl) (Manuel) (Olivia) (Peter))))",
        "(declare-datatypes ((Table 0)) (((Fiona) (George) (Harriet) (Ingrid) (Karl) (Manuel) (Olivia) (Peter))))",
        "(declare-fun sits_between (People People People) Bool)",
        "(declare-fun sits_across (People People) Bool)",
        "(declare-fun sits_next_to (People People) Bool)",
        "(define-fun count_sits_between ((p1 People) (p2 People)) Int (ite (and (= p1 Fiona) (= p2 George)) 3 (ite (and (= p1 Fiona) (= p2 Karl)) 4 (ite (and (= p1 George) (= p2 Karl)) 3 0))))"
      ],
      "constraints": [
        "(assert (sits_across f g))",
        "(assert (not (sits_next_to f h)))",
        "(assert (not (sits_next_to k h)))",
        "(assert (and (sits_next_to i o) (sits_next_to o i)))",
        "(assert (>= (count_sits_between g k) 3))"
      ],
      "options": [
        "(<= (count_sits_between g k) 3)",
        "(<= (count_sits_between g k) 4)",
        "(<= (count_sits_between g k) 1)",
        "(<= (count_sits_between g k) 2)"
      ],
      "type": "unsat",
      "perplexity": [
        1.4765162467956543,
        1.141632080078125
      ],
      "answer": "C",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "No Output"
    }
  },
  {
    "id": 47,
    "nl_problem": {
      "context": "Each of seven candidates for the position of judge—Hamadi, Jefferson, Kurtz, Li, McDonnell, Ortiz, and Perkins—will be appointed to an open position on one of two courts—the appellate court or the trial court. There are three open positions on the appellate court and six open positions on the trial court, but not all of them will be filled at this time. The judicial appointments will conform to the following conditions: Li must be appointed to the appellate court. Kurtz must be appointed to the trial court. Hamadi cannot be appointed to the same court as Perkins.",
      "question": "Which one of the following is an acceptable set of appointments of candidates to courts?",
      "options": [
        "A) appellate: Hamadi, Ortiz trial: Jefferson, Kurtz, Li, McDonnell, Perkins",
        "B) appellate: Hamadi, Li, Perkins trial: Jefferson, Kurtz, McDonnell, Ortiz",
        "C) appellate: Kurtz, Li, Perkins trial: Hamadi, Jefferson, McDonnell, Ortiz",
        "D) appellate: Li, McDonnell, Ortiz trial: Hamadi, Jefferson, Kurtz, Perkins",
        "E) appellate: Li, Perkins trial: Hamadi, Jefferson, Kurtz, McDonnell, Ortiz"
      ]
    },
    "answer": "E",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((Candidates 0)) (((Hamadi) (Jefferson) (Kurtz) (Li) (McDonnell) (Ortiz) (Perkins))))",
        "(declare-datatypes ((Courts 0)) (((appellate) (trial))))",
        "(declare-fun appointed (Candidates Courts) Bool)"
      ],
      "constraints": [
        "(forall ((c Candidates) (court Courts)) (<= (+ (ite (appointed c appellate) 1 0) (ite (appointed c trial) 1 0)) 3))",
        "(forall ((c Candidates)) (= (appointed Li appellate) true))",
        "(forall ((c Candidates)) (= (appointed Kurtz trial) true))",
        "(forall ((c Candidates) (d Candidates)) (not (= (appointed c appellate) (appointed d appellate)) (not (= c Perkins)) (not (= d Perkins))))"
      ],
      "options": [
        "(forall ((a Candidates)) (forall ((b Candidates)) (forall ((c Candidates)) (forall ((d Candidates)) (forall ((e Candidates)) (forall ((f Candidates)) (forall ((g Candidates)) (forall ((x Candidates)) (forall ((y Candidates)) (forall ((z Candidates)) (forall ((w Candidates)) (forall ((m Courts)) (and (appointed a appellate) (appointed b appellate) (appointed c appellate) (appointed d trial) (appointed e trial) (appointed f trial) (appointed g trial)))))))) (forall ((x Candidates)) (forall ((y Candidates)) (forall ((z Candidates)) (forall ((w Candidates)) (= (and (or (= a Hamadi) (= a Ortiz) (= a Li) (= a Perkins)) (or (= b Jefferson) (= b Kurtz) (= b Li) (= b McDonnell) (= b Perkins) (= b Ortiz)) (or (= c Jefferson) (= c Kurtz) (= c McDonnell) (= c Ortiz)) (or (= d Hamadi) (= d Jefferson) (= d Kurtz) (= d McDonnell) (= d Ortiz)) (or (= e Hamadi) (= e Kurtz) (= e McDonnell) (= e Perkins)) (or (= f Hamadi) (= f Jefferson) (= f McDonnell) (= f Ortiz)) (or (= g Hamadi) (= g Jefferson) (= g Kurtz) (= g McDonnell))) (forall ((m Courts)) (= (or (= (appointed x m) a) (= (appointed x m) b) (= (appointed x m) c) (= (appointed x m) d) (= (appointed x m) e) (= (appointed x m) f) (= (appointed x m) g)) (= (or (= (appointed y m) a) (= (appointed y m) b) (= (appointed y m) c) (= (appointed y m) d) (= (appointed y m) e) (= (appointed y m) f) (= (appointed y m) g)) (or (= (appointed z m) a) (= (appointed z m) b) (= (appointed z m) c) (= (appointed z m) d) (= (appointed z m) e) (= (appointed z m) f) (= (appointed z m) g)) (or (= (appointed w m) a) (= (appointed w m) b) (= (appointed w m) c) (= (appointed w m) d) (= (appointed w m) e) (= (appointed w m) f) (= (appointed w m) g))))))))))))))",
        "(forall ((a Candidates)) (forall ((b Candidates)) (forall ((c Candidates)) (forall ((d Candidates)) (forall ((e Candidates)) (forall ((f Candidates)) (forall ((g Candidates)) (forall ((x Candidates)) (forall ((y Candidates)) (forall ((z Candidates)) (forall ((w Candidates)) (forall ((m Courts)) (= (or (= (appointed x m) a) (= (appointed x m) b) (= (appointed x m) c) (= (appointed x m) d) (= (appointed x m) e) (= (appointed x m) f) (= (appointed x m) g)) (= (or (= (appointed y m) a) (= (appointed y m) b) (= (appointed y m) c) (= (appointed y m) d) (= (appointed y m) e) (= (appointed y m) f) (= (appointed y m) g)) (or (= (appointed z m) a) (= (appointed z m) b) (= (appointed z m) c) (= (appointed z m) d) (= (appointed z m) e) (= (appointed z m) f) (= (appointed z m) g)) (or (= (appointed w m) a) (= (appointed w m) b) (= (appointed w m) c) (= (appointed w m) d) (= (appointed w m) e) (= (appointed w m) f) (= (appointed w m) g))))))))))))))))))"
      ],
      "type": "unsat",
      "perplexity": [
        1.1126501560211182,
        1.0399456024169922
      ],
      "answer": "E",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "No Output"
    }
  },
  {
    "id": 48,
    "nl_problem": {
      "context": "Each of seven candidates for the position of judge—Hamadi, Jefferson, Kurtz, Li, McDonnell, Ortiz, and Perkins—will be appointed to an open position on one of two courts—the appellate court or the trial court. There are three open positions on the appellate court and six open positions on the trial court, but not all of them will be filled at this time. The judicial appointments will conform to the following conditions: Li must be appointed to the appellate court. Kurtz must be appointed to the trial court. Hamadi cannot be appointed to the same court as Perkins.",
      "question": "Which one of the following CANNOT be true?",
      "options": [
        "A) Hamadi and McDonnell are both appointed to the appellate court.",
        "B) McDonnell and Ortiz are both appointed to the appellate court.",
        "C) Ortiz and Perkins are both appointed to the appellate court.",
        "D) Hamadi and Jefferson are both appointed to the trial court.",
        "E) Ortiz and Perkins are both appointed to the trial court."
      ]
    },
    "answer": "B",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((Candidates 0)) (((Hamadi) (Jefferson) (Kurtz) (Li) (McDonnell) (Ortiz) (Perkins))))",
        "(declare-datatypes ((Courts 0)) (((appellate_court) (trial_court))))",
        "(declare-fun appointed (Candidates Courts) Bool)"
      ],
      "constraints": [
        "(= num_appellate_positions (ite appellate_court 1 0))",
        "(= num_trial_positions (ite trial_court 1 0))",
        "(= (to-int (appointed Li appellate_court)) (to-int appellate_court))",
        "(= (to-int (appointed Kurtz trial_court)) (to-int trial_court))",
        "(not (and appellate_court (appointed Perkins appellate_court)))",
        "(not (and trial_court (appointed Perkins trial_court)))",
        "(not (and appellate_court (appointed Hamadi appellate_court) (appointed Perkins appellate_court)))",
        "(not (and trial_court (appointed Hamadi trial_court) (appointed Perkins trial_court)))"
      ],
      "options": [
        "(= (to-int (appellate_court)) (to-int (appointed Hamadi appellate_court)))",
        "(= (to-int (appellate_court)) (to-int (appointed McDonnell appellate_court)))",
        "(= (to-int (appellate_court)) (to-int (appointed Ortiz appellate_court)))",
        "(= (to-int (trial_court)) (to-int (appointed Hamadi trial_court)))",
        "(= (to-int (trial_court)) (to-int (appointed Jefferson trial_court)))",
        "(= (to-int (trial_court)) (to-int (appointed Ortiz trial_court)))",
        "(= (to-int (trial_court)) (to-int (appointed Perkins trial_court)))"
      ],
      "type": "unsat",
      "perplexity": [
        1.1826926469802856,
        1.127615213394165
      ],
      "answer": "B",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "No Output"
    }
  },
  {
    "id": 49,
    "nl_problem": {
      "context": "Each of seven candidates for the position of judge—Hamadi, Jefferson, Kurtz, Li, McDonnell, Ortiz, and Perkins—will be appointed to an open position on one of two courts—the appellate court or the trial court. There are three open positions on the appellate court and six open positions on the trial court, but not all of them will be filled at this time. The judicial appointments will conform to the following conditions: Li must be appointed to the appellate court. Kurtz must be appointed to the trial court. Hamadi cannot be appointed to the same court as Perkins.",
      "question": "Which one of the following CANNOT be true?",
      "options": [
        "A) Jefferson and McDonnell are both appointed to the appellate court.",
        "B) Jefferson and McDonnell are both appointed to the trial court.",
        "C) McDonnell and Ortiz are both appointed to the trial court.",
        "D) McDonnell and Perkins are both appointed to the appellate court.",
        "E) McDonnell and Perkins are both appointed to the trial court."
      ]
    },
    "answer": "A",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((Candidates 0)) (((Hamadi) (Jefferson) (Kurtz) (Li) (McDonnell) (Ortiz) (Perkins))))",
        "(declare-datatypes ((Courts 0)) (((appellate) (trial))))",
        "(declare-fun is_judge (Candidates Courts) Bool)",
        "(declare-fun num_appellate_positions () Int)",
        "(declare-fun num_trial_positions () Int)"
      ],
      "constraints": [
        "(>= num_appellate_positions 3)",
        "(>= num_trial_positions 6)",
        "(= (is_judge Li appellate) true)",
        "(= (is_judge Kurtz trial) true)",
        "(not (and (= (is_judge Hamadi appellate) true) (= (is_judge Perkins appellate) true)))",
        "(forall ((m Candidates) (n Candidates) (c Courts)) (= (to-int (and (distinct m n) (= (is_judge m c) true) (= (is_judge n c) true))) (to-int (= (is_judge m c) true))))",
        "(define-fun to-int ((b Bool)) Int (ite b 1 0))",
        "(forall ((m Candidates) (n Candidates) (c Courts)) (= (to-int (and (distinct m n) (= (is_judge m c) true) (= (is_judge n c) true))) (to-int (= (is_judge m c) true))))",
        "(define-fun num_judges (c Courts) Int (ite (= c appellate) num_appellate_positions num_trial_positions))",
        "(define-fun is_full (c Courts) Bool (= (num_judges c) (ite (= c appellate) 3 6)))",
        "(and (= (is_judge Jefferson appellate) true) (= (is_judge McDonnell appellate) true) (not (is_full appellate)))",
        "(and (= (is_judge Jefferson trial) true) (= (is_judge McDonnell trial) true) (not (is_full trial)))",
        "(and (= (is_judge McDonnell trial) true) (= (is_judge Ortiz trial) true) (not (is_full trial)))",
        "(and (= (is_judge McDonnell appellate) true) (= (is_judge Perkins appellate) true) (not (is_full appellate)))",
        "(and (= (is_judge McDonnell trial) true) (= (is_judge Perkins trial) true) (not (is_full trial)))"
      ],
      "options": [
        "(not (and (= (is_judge Jefferson appellate) true) (= (is_judge McDonnell appellate) true)))",
        "(not (and (= (is_judge Jefferson trial) true) (= (is_judge McDonnell trial) true)))",
        "(not (and (= (is_judge McDonnell trial) true) (= (is_judge Ortiz trial) true)))",
        "(not (and (= (is_judge McDonnell appellate) true) (= (is_judge Perkins appellate) true)))",
        "(not (and (= (is_judge McDonnell trial) true) (= (is_judge Perkins trial) true)))"
      ],
      "type": "unsat",
      "perplexity": [
        1.1492177248001099,
        1.0654391050338745
      ],
      "answer": "A",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "No Output"
    }
  },
  {
    "id": 50,
    "nl_problem": {
      "context": "Each of seven candidates for the position of judge—Hamadi, Jefferson, Kurtz, Li, McDonnell, Ortiz, and Perkins—will be appointed to an open position on one of two courts—the appellate court or the trial court. There are three open positions on the appellate court and six open positions on the trial court, but not all of them will be filled at this time. The judicial appointments will conform to the following conditions: Li must be appointed to the appellate court. Kurtz must be appointed to the trial court. Hamadi cannot be appointed to the same court as Perkins.",
      "question": "If Ortiz is appointed to the appellate court, which one of the following must be true?",
      "options": [
        "A) Hamadi is appointed to the appellate court.",
        "B) Jefferson is appointed to the appellate court.",
        "C) Jefferson is appointed to the trial court.",
        "D) Perkins is appointed to the appellate court.",
        "E) Perkins is appointed to the trial court."
      ]
    },
    "answer": "C",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((Courts 0)) (((appellate_court) (trial_court))))",
        "(declare-datatypes ((Candidates 0)) (((Hamadi) (Jefferson) (Kurtz) (Li) (McDonnell) (Ortiz) (Perkins))))",
        "(declare-fun appointed (Candidates Courts) Bool)",
        "(define-fun to-int ((b Bool)) Int (ite b 1 0))"
      ],
      "constraints": [
        "(= num_appellate_open 3)",
        "(= num_trial_open 6)",
        "(= num_appellate_open (to-int (and (appointed Li appellate_court) True)))",
        "(= num_trial_open (to-int (and (appointed Kurtz trial_court) True)))",
        "(= num_appellate_open2 (ite (appointed Ortiz appellate_court) 1 0))",
        "(= num_trial_open2 (ite (appointed Ortiz appellate_court) 1 0))",
        "(= (+ num_appellate_open2 num_trial_open2) (ite (appointed Ortiz appellate_court) 9 7))",
        "(= (ite (appointed Ortiz appellate_court) (ite (ite (appointed Perkins appellate_court) True False) (ite (ite Ortiz_appellate 1 0) (ite (appointed Hamadi appellate_court) True False) False) False) True False) A)",
        "(= (ite (appointed Ortiz appellate_court) (ite (ite (appointed Perkins appellate_court) True False) (ite (ite Ortiz_appellate 1 0) (ite (appointed Jefferson appellate_court) True False) False) False) True False) B)",
        "(= (ite (appointed Ortiz appellate_court) (ite (ite (appointed Perkins appellate_court) True False) (ite (ite Ortiz_appellate 1 0) (ite (appointed Jefferson trial_court) True False) False) False) True False) C)",
        "(= (ite (appointed Ortiz appellate_court) (ite (ite (appointed Perkins appellate_court) True False) (ite (ite Ortiz_appellate 1 0) (ite (appointed Perkins appellate_court) True False) False) False) True False) D)",
        "(= (ite (appointed Ortiz appellate_court) (ite (ite (appointed Perkins appellate_court) True False) (ite (ite Ortiz_appellate 1 0) (ite (appointed Perkins trial_court) True False) False) False) True False) E)",
        "A",
        "B",
        "C",
        "D",
        "E"
      ],
      "options": [
        "(check-sat)"
      ],
      "type": "sat",
      "perplexity": [
        1.1346486806869507,
        1.07625412940979
      ],
      "answer": "C",
      "predicted_answer": [
        "sat"
      ],
      "status": "success",
      "error": ""
    }
  },
  {
    "id": 51,
    "nl_problem": {
      "context": "Each of seven candidates for the position of judge—Hamadi, Jefferson, Kurtz, Li, McDonnell, Ortiz, and Perkins—will be appointed to an open position on one of two courts—the appellate court or the trial court. There are three open positions on the appellate court and six open positions on the trial court, but not all of them will be filled at this time. The judicial appointments will conform to the following conditions: Li must be appointed to the appellate court. Kurtz must be appointed to the trial court. Hamadi cannot be appointed to the same court as Perkins.",
      "question": "Which one of the following, if substituted for the condition that Hamadi cannot be appointed to the same court as Perkins, would have the same effect on the appointments of the seven candidates?",
      "options": [
        "A) Hamadi and Perkins cannot both be appointed to the appellate court.",
        "B) If Hamadi is not appointed to the trial court, then Perkins must be.",
        "C) If Perkins is appointed to the same court as Jefferson, then Hamadi cannot be.",
        "D) If Hamadi is appointed to the same court as Li, then Perkins must be appointed to the same court as Kurtz.",
        "E) No three of Hamadi, Kurtz, Li, and Perkins can be appointed to the same court as each other."
      ]
    },
    "answer": "E",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((Candidates 0)) (((Hamadi) (Jefferson) (Kurtz) (Li) (McDonnell) (Ortiz) (Perkins))))",
        "(declare-datatypes ((Courts 0)) (((appellate) (trial))))",
        "(declare-fun appointed (Candidates Courts) Bool)",
        "(declare-fun count_appellate (Candidates) Int)",
        "(declare-fun count_trial (Candidates) Int)",
        "(declare-fun num_appellate () Int)",
        "(declare-fun num_trial () Int)",
        "(declare-fun Li_appellate () Bool)",
        "(declare-fun Kurtz_trial () Bool)",
        "(declare-fun Hamadi_Perkins_same_court () Bool)",
        "(declare-fun Hamadi_and_Perkins_appellate () Bool)",
        "(declare-fun Perkins_must_be_trial_if_Hamadi_is_not () Bool)",
        "(declare-fun Perkins_must_be_if_Hamadi_and_Li_same_court () Bool)",
        "(declare-fun no_three_same_court () Bool)",
        "(declare-fun option_A () Bool)",
        "(declare-fun option_B () Bool)",
        "(declare-fun option_C () Bool)",
        "(declare-fun option_D () Bool)",
        "(declare-fun option_E () Bool)"
      ],
      "constraints": [
        "Li_appellate",
        "Kurtz_trial",
        "(forall ((c Candidates)) (>= (count_court c) 0))",
        "(forall ((c Candidates)) (<= (count_court c) 1))",
        "(forall ((c Candidates) (m Courts)) (=> (and (appointed c appellate) (appointed c trial)) (distinct m appellate trial)))",
        "(not (exists ((c Candidates)) (and (appointed c appellate) (appointed c trial))))",
        "(forall ((c Candidates)) (=> (appointed c appellate) (<= (count_appellate (remove c (Candidates))) (+ num_appellate 1))))",
        "(forall ((c Candidates)) (=> (appointed c trial) (<= (count_trial (remove c (Candidates))) (+ num_trial 1))))",
        "(forall ((c Candidates)) (=> (not (appointed c appellate)) (<= (count_appellate (remove c (Candidates))) num_appellate)))",
        "(forall ((c Candidates)) (=> (not (appointed c trial)) (<= (count_trial (remove c (Candidates))) num_trial)))",
        "Hamadi_Perkins_same_court",
        "(or option_A option_B option_C option_D option_E)"
      ],
      "options": [
        "option_A",
        "option_B",
        "option_C",
        "option_D",
        "option_E"
      ],
      "type": "unsat",
      "perplexity": [
        1.2376964092254639,
        1.0783016681671143
      ],
      "answer": "E",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "No Output"
    }
  },
  {
    "id": 52,
    "nl_problem": {
      "context": "Exactly six members of a skydiving team—Larue, Ohba, Pei, Trevino, Weiss, and Zacny—each dive exactly once, one at a time, from a plane, consistent with the following conditions: Trevino dives from the plane at some time before Weiss does. Larue dives from the plane either first or last. Neither Weiss nor Zacny dives from the plane last. Pei dives from the plane at some time after either Ohba or Larue but not both.",
      "question": "Which one of the following could be an accurate list of the members in the order in which they dive from the plane, from first to last?",
      "options": [
        "A) Larue, Trevino, Ohba, Zacny, Pei, Weiss",
        "B) Larue, Trevino, Pei, Zacny, Weiss, Ohba",
        "C) Weiss, Ohba, Trevino, Zacny, Pei, Larue",
        "D) Trevino, Weiss, Pei, Ohba, Zacny, Larue",
        "E) Trevino, Weiss, Zacny, Larue, Pei, Ohba"
      ]
    },
    "answer": "B",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((Members 0)) (((Larue) (Ohba) (Pei) (Trevino) (Weiss) (Zacny))))",
        "(declare-fun dives (Members) Bool)",
        "(declare-fun before (Members Members) Bool)",
        "(declare-fun last (Members) Bool)",
        "(declare-fun first (Members) Bool)"
      ],
      "constraints": [
        "(forall ((m Members)) (not (and (before Larue m) (before m Larue))))",
        "(forall ((m1 Members) (m2 Members)) (<= (+ (ite (before m1 m2) 1 0) (ite (before m2 m1) 1 0)) 1))",
        "(forall ((m Members)) (or (= Larue m) (= Zacny m) (= Ohba m) (= Pei m) (= Trevino m) (= Weiss m)))",
        "(forall ((m Members)) (not (and (before Pei m) (before m Pei))))",
        "(forall ((m Members)) (not (and (before Ohba m) (before m Ohba))))",
        "(forall ((m Members)) (not (and (before Zacny m) (before m Zacny))))",
        "(forall ((m1 Members) (m2 Members)) (= (ite (before m1 m2) true false) (ite (before m2 m1) true false)))",
        "(forall ((m1 Members) (m2 Members)) (not (and (before m1 m2) (before m2 m1))))",
        "(forall ((m Members)) (= (first m) Larue))",
        "(forall ((m Members)) (= (last m) Zacny))",
        "(forall ((m1 Members) (m2 Members)) (= (ite (before m1 m2) true false) (ite (before m2 m1) false true)))",
        "(forall ((m Members)) (or (= (dives m) true) (= (dives m) false)))",
        "(forall ((m1 Members) (m2 Members)) (<= (+ (ite (before m1 m2) 1 0) (ite (before m2 m1) 1 0)) 1))"
      ],
      "options": [],
      "type": "unsat",
      "perplexity": [
        1.042470932006836,
        1.2720005512237549
      ],
      "answer": "B",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "No Output"
    }
  },
  {
    "id": 53,
    "nl_problem": {
      "context": "Exactly six members of a skydiving team—Larue, Ohba, Pei, Trevino, Weiss, and Zacny—each dive exactly once, one at a time, from a plane, consistent with the following conditions: Trevino dives from the plane at some time before Weiss does. Larue dives from the plane either first or last. Neither Weiss nor Zacny dives from the plane last. Pei dives from the plane at some time after either Ohba or Larue but not both.",
      "question": "Which one of the following must be true?",
      "options": [
        "A) At least two of the members dive from the plane after Larue.",
        "B) At least two of the members dive from the plane after Ohba.",
        "C) At least two of the members dive from the plane after Pei.",
        "D) At least two of the members dive from the plane after Trevino.",
        "E) At least two of the members dive from the plane after Weiss."
      ]
    },
    "answer": "D",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((Team 0)) (((Larue) (Ohba) (Pei) (Trevino) (Weiss) (Zacny))))",
        "(declare-fun dives (Team) Int)"
      ],
      "constraints": [
        "(or (= (dives Larue) 1) (= (dives Larue) 5))",
        "(<= (dives Trevino) (dives Weiss))",
        "(not (= (dives Weiss) 5))",
        "(not (= (dives Zacny) 5))",
        "(and (>= (dives Pei) (ite (= (dives Ohba) 1) (ite (= (dives Larue) 1) 2 2) (ite (= (dives Larue) 1) 2 3))) (not (and (= (dives Pei) (ite (= (dives Ohba) 1) (ite (= (dives Larue) 1) 2 2) (ite (= (dives Larue) 1) 2 3))) (= (dives Ohba) (ite (= (dives Larue) 1) 2 2)))))",
        "(and (>= (dives Pei) (ite (= (dives Larue) 1) 2 2)) (not (and (= (dives Pei) (ite (= (dives Larue) 1) 2 2)) (= (dives Larue) 1))))"
      ],
      "options": [
        "(at_least_two_after_larue)",
        "(at_least_two_after_ohba)",
        "(at_least_two_after_pei)",
        "(at_least_two_after_trevino)",
        "(at_least_two_after_weiss)"
      ],
      "type": "sat",
      "perplexity": [
        1.1120659112930298,
        1.1073296070098877
      ],
      "answer": "D",
      "predicted_answer": [
        "sat",
        "sat",
        "sat",
        "sat",
        "sat"
      ],
      "status": "success",
      "error": ""
    }
  },
  {
    "id": 54,
    "nl_problem": {
      "context": "Exactly six members of a skydiving team—Larue, Ohba, Pei, Trevino, Weiss, and Zacny—each dive exactly once, one at a time, from a plane, consistent with the following conditions: Trevino dives from the plane at some time before Weiss does. Larue dives from the plane either first or last. Neither Weiss nor Zacny dives from the plane last. Pei dives from the plane at some time after either Ohba or Larue but not both.",
      "question": "If Larue dives from the plane last, then each of the following could be true EXCEPT:",
      "options": [
        "A) Trevino dives from the plane fourth.",
        "B) Weiss dives from the plane fourth.",
        "C) Ohba dives from the plane fifth.",
        "D) Pei dives from the plane fifth.",
        "E) Zacny dives from the plane fifth."
      ]
    },
    "answer": "C"
  },
  {
    "id": 55,
    "nl_problem": {
      "context": "Exactly six members of a skydiving team—Larue, Ohba, Pei, Trevino, Weiss, and Zacny—each dive exactly once, one at a time, from a plane, consistent with the following conditions: Trevino dives from the plane at some time before Weiss does. Larue dives from the plane either first or last. Neither Weiss nor Zacny dives from the plane last. Pei dives from the plane at some time after either Ohba or Larue but not both.",
      "question": "If Zacny dives from the plane immediately after Weiss, then which one of the following must be false?",
      "options": [
        "A) Larue dives from the plane first.",
        "B) Trevino dives from the plane third.",
        "C) Zacny dives from the plane third.",
        "D) Pei dives from the plane fourth.",
        "E) Zacny dives from the plane fourth."
      ]
    },
    "answer": "D",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((People 0)) (((Larue) (Ohba) (Pei) (Trevino) (Weiss) (Zacny))))",
        "(declare-fun dives (People Int) Bool)",
        "(declare-const time (Int))",
        "(declare-fun last_dive (People) Int)",
        "(declare-fun after (People People) Bool)",
        "(declare-fun before (People People) Bool)",
        "(declare-fun at_time (People Int) Bool)",
        "(declare-fun last_time (People) Int)"
      ],
      "constraints": [
        "(= (last_dive Larue) time)",
        "(forall ((p People)) (= (last_dive p) (last_time p)))",
        "(forall ((p People)) (= (last_time p) (if (= p Weiss) (- time 1) (if (= p Zacny) (- time 1) time))))",
        "(forall ((p People)) (or (= p Larue) (= p Zacny) (= (last_dive p) time)))",
        "(forall ((p People) (q People)) (= (after p q) (not (before q p))))",
        "(forall ((p People)) (and (exists ((t Int)) (= (at_time p t) true)) (forall ((t1 Int)) (=> (at_time p t1) (= t t1)))))",
        "(forall ((p People) (q People)) (=> (and (before p q) (before q p)) false))",
        "(forall ((p People)) (= (before Trevino Weiss) true))",
        "(forall ((p People)) (= (after Pei (if (= p Ohba) Ohba Larue)) true))"
      ],
      "options": [
        "(forall ((t Int)) (=> (and (= (at_time Zacny t) true) (= (at_time Weiss (- t 1)) true)) (not (and (at_time Larue 0) true))))",
        "(forall ((t Int)) (=> (and (= (at_time Zacny t) true) (= (at_time Weiss (- t 1)) true)) (not (and (at_time Trevino 2) true))))",
        "(forall ((t Int)) (=> (and (= (at_time Zacny t) true) (= (at_time Weiss (- t 1)) true)) (not (and (at_time Zacny 2) true))))",
        "(forall ((t Int)) (=> (and (= (at_time Zacny t) true) (= (at_time Weiss (- t 1)) true)) (not (and (at_time Pei 3) true))))",
        "(forall ((t Int)) (=> (and (= (at_time Zacny t) true) (= (at_time Weiss (- t 1)) true)) (not (and (at_time Zacny 3) true))))"
      ],
      "type": "unsat",
      "perplexity": [
        1.25493323802948,
        1.0753270387649536
      ],
      "answer": "D",
      "predicted_answer": [
        "unsat",
        "unsat",
        "unsat",
        "unsat",
        "unsat"
      ],
      "status": "success",
      "error": ""
    }
  },
  {
    "id": 56,
    "nl_problem": {
      "context": "Exactly six members of a skydiving team—Larue, Ohba, Pei, Trevino, Weiss, and Zacny—each dive exactly once, one at a time, from a plane, consistent with the following conditions: Trevino dives from the plane at some time before Weiss does. Larue dives from the plane either first or last. Neither Weiss nor Zacny dives from the plane last. Pei dives from the plane at some time after either Ohba or Larue but not both.",
      "question": "If Trevino dives from the plane immediately after Larue, then each of the following could be true EXCEPT:",
      "options": [
        "A) Ohba dives from the plane third.",
        "B) Weiss dives from the plane third.",
        "C) Zacny dives from the plane third.",
        "D) Pei dives from the plane fourth.",
        "E) Weiss dives from the plane fourth."
      ]
    },
    "answer": "A",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((Skydivers 0)) (((Larue) (Ohba) (Pei) (Trevino) (Weiss) (Zacny))))",
        "(declare-datatypes ((Positions 0)) (((first) (second) (third) (fourth) (fifth) (last))))",
        "(declare-fun div_order (Skydivers) Positions)",
        "(declare-fun is_before (Positions Positions) Bool)",
        "(define-fun Trevino_before_Weiss (x Positions y Positions) Bool (and (< x y) (is_before (div_order Trevino) (div_order Weiss))))",
        "(define-fun Larue_first_or_last (x Positions y Positions) Bool (or (= x first) (= x last)))",
        "(define-fun Weiss_not_last (x Positions y Positions) Bool (and (not (= x last)) (not (= y last))))",
        "(define-fun Pei_after_Ohba_or_Larue (x Positions y Positions) Bool (or (and (is_before x (div_order Ohba)) (not (is_before x (div_order Larue)))) (and (is_before x (div_order Larue)) (not (is_before x (div_order Ohba)))))"
      ],
      "constraints": [
        "(forall ((t Skydivers)) (exists ((x Positions)) (= (div_order t) x)))",
        "(forall ((x Positions) (y Positions)) (=> (is_before x y) (< x y)))",
        "(forall ((x Positions) (y Positions)) (Trevino_before_Weiss x y))",
        "(forall ((x Positions)) (Larue_first_or_last x (div_order Larue)))",
        "(forall ((x Positions) (y Positions)) (Weiss_not_last x y))",
        "(forall ((x Positions) (y Positions)) (Pei_after_Ohba_or_Larue x y))"
      ],
      "options": [
        "(exists ((x Positions) (y Positions)) (= (div_order Ohba) third))",
        "(exists ((x Positions) (y Positions)) (= (div_order Weiss) third))",
        "(exists ((x Positions) (y Positions)) (= (div_order Zacny) third))",
        "(exists ((x Positions) (y Positions)) (= (div_order Pei) fourth))",
        "(exists ((x Positions) (y Positions)) (= (div_order Weiss) fourth))"
      ],
      "type": "unsat",
      "perplexity": [
        1.205954909324646,
        1.069290280342102
      ],
      "answer": "A",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "No Output"
    }
  },
  {
    "id": 57,
    "nl_problem": {
      "context": "A company's six vehicles—a hatchback, a limousine, a pickup, a roadster, a sedan, and a van—are serviced during a certain week—Monday through Saturday—one vehicle per day. The following conditions must apply: At least one of the vehicles is serviced later in the week than the hatchback. The roadster is serviced later in the week than the van and earlier in the week than the hatchback. Either the pickup and the van are serviced on consecutive days, or the pickup and the sedan are serviced on consecutive days, but not both. The sedan is serviced earlier in the week than the pickup or earlier in the week than the limousine, but not both.",
      "question": "Which one of the following could be the order in which the vehicles are serviced, from Monday through Saturday?",
      "options": [
        "A) the hatchback, the pickup, the sedan, the limousine, the van, the roadster",
        "B) the pickup, the sedan, the van, the roadster, the hatchback, the limousine",
        "C) the pickup, the van, the sedan, the roadster, the limousine, the hatchback",
        "D) the van, the roadster, the pickup, the hatchback, the sedan, the limousine",
        "E) the van, the sedan, the pickup, the roadster, the hatchback, the limousine"
      ]
    },
    "answer": "B",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((Vehicles 0)) (((hatchback) (limousine) (pickup) (roadster) (sedan) (van))))",
        "(declare-datatypes ((Days 0)) (((monday) (tuesday) (wednesday) (thursday) (friday) (saturday))))",
        "(declare-fun serviced (Vehicles Days) Bool)",
        "(declare-fun later (Vehicles Vehicles) Bool)",
        "(define-fun to-int ((b Bool)) Int (ite b 1 0))",
        "(define-fun in-order ((v1 Vehicles) (v2 Vehicles)) Bool (and (not (later v2 v1)) (not (later v1 v2))))"
      ],
      "constraints": [
        "(forall ((d Days)) (> (ite (serviced hatchback d) 1 0) (ite (serviced v Vehicles d) 1 0) : (forall ((v Vehicles)) (not (serviced v monday))))))",
        "(and (later van roadster) (later hatchback roadster))",
        "(or (= (ite (serviced pickup d) 1 0) (ite (serviced van d) 1 0) : (forall ((d Days)) (= d (+ d 1)))) (= (ite (serviced pickup d) 1 0) (ite (serviced sedan d) 1 0) : (forall ((d Days)) (= d (+ d 1)))) (not (= (ite (serviced pickup d) 1 0) (ite (serviced van d) 1 0) : (forall ((d Days)) (= d (+ d 1))) (= (ite (serviced pickup d) 1 0) (ite (serviced sedan d) 1 0) : (forall ((d Days)) (= d (+ d 1)))) : (forall ((d Days)) : (forall ((v Vehicles)) (not (serviced v monday)))))))",
        "(or (later sedan pickup) (later sedan limousine)) (not (and (later sedan pickup) (later sedan limousine)))"
      ],
      "options": [
        "(forall ((d Days)) (= (ite (serviced hatchback d) 1 0) (ite (serviced pickup d) 1 0) : (forall ((v Vehicles)) (not (serviced v monday)))) (ite (serviced hatchback (+ d 1)) 1 0) : (forall ((v Vehicles)) (not (serviced v monday)))))",
        "(forall ((d Days)) (= (ite (serviced pickup d) 1 0) (ite (serviced sedan d) 1 0) : (forall ((v Vehicles)) (not (serviced v monday)))) (ite (serviced pickup (+ d 1)) 1 0) : (forall ((v Vehicles)) (not (serviced v monday)))))",
        "(forall ((d Days)) (= (ite (serviced pickup d) 1 0) (ite (serviced van d) 1 0) : (forall ((v Vehicles)) (not (serviced v monday)))) (ite (serviced pickup (+ d 1)) 1 0) : (forall ((v Vehicles)) (not (serviced v monday)))))",
        "(forall ((d Days)) (= (ite (serviced van d) 1 0) (ite (serviced roadster d) 1 0) : (forall ((v Vehicles)) (not (serviced v monday)))) (ite (serviced van (+ d 1)) 1 0) : (forall ((v Vehicles)) (not (serviced v monday)))))",
        "(forall ((d Days)) (= (ite (serviced van d) 1 0) (ite (serviced sedan d) 1 0) : (forall ((v Vehicles)) (not (serviced v monday)))) (ite (serviced van (+ d 1)) 1 0) : (forall ((v Vehicles)) (not (serviced v monday)))))"
      ],
      "type": "sat",
      "perplexity": [
        1.0996087789535522,
        1.0377084016799927
      ],
      "answer": "B",
      "predicted_answer": [
        "sat",
        "sat",
        "sat",
        "sat",
        "sat"
      ],
      "status": "success",
      "error": ""
    }
  },
  {
    "id": 58,
    "nl_problem": {
      "context": "A company's six vehicles—a hatchback, a limousine, a pickup, a roadster, a sedan, and a van—are serviced during a certain week—Monday through Saturday—one vehicle per day. The following conditions must apply: At least one of the vehicles is serviced later in the week than the hatchback. The roadster is serviced later in the week than the van and earlier in the week than the hatchback. Either the pickup and the van are serviced on consecutive days, or the pickup and the sedan are serviced on consecutive days, but not both. The sedan is serviced earlier in the week than the pickup or earlier in the week than the limousine, but not both.",
      "question": "Which one of the following CANNOT be the vehicle serviced on Thursday?",
      "options": [
        "A) the hatchback",
        "B) the limousine",
        "C) the pickup",
        "D) the sedan",
        "E) the van"
      ]
    },
    "answer": "E",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((Vehicles 0)) (((hatchback) (limousine) (pickup) (roadster) (sedan) (van))))",
        "(declare-datatypes ((Days 0)) (((monday) (tuesday) (wednesday) (thursday) (friday) (saturday))))",
        "(declare-fun serviced (Vehicles Days) Bool)",
        "(declare-fun later (Vehicles Vehicles) Bool)",
        "(define-fun to-int ((b Bool)) Int (ite b 1 0))"
      ],
      "constraints": [
        "(forall ((v Vehicles)) (not (= (to-int (serviced v monday)) (to-int (serviced v saturday))))",
        "(forall ((v Vehicles)) (= (to-int (serviced v monday)) (ite (< v hatchback) 0 1)))",
        "(forall ((v Vehicles)) (= (to-int (serviced v monday)) (ite (< v roadster) 0 1)))",
        "(forall ((v Vehicles)) (= (to-int (serviced v monday)) (ite (< v van) 0 1)))",
        "(forall ((v Vehicles) (d Days)) (= (to-int (serviced v d)) (ite (< v hatchback) 0 1)))",
        "(forall ((v1 Vehicles) (v2 Vehicles)) (implies (later v1 v2) (not (later v2 v1))))",
        "(define-fun pickup-van-consecutive ((v Vehicles) (d Days)) Bool (= (to-int (serviced v d)) (ite (ite (< v pickup) 1 0) (+ 1 (ite (< v van) 1 0)) 0)))",
        "(define-fun pickup-sedan-consecutive ((v Vehicles) (d Days)) Bool (= (to-int (serviced v d)) (ite (ite (< v pickup) 1 0) (+ 1 (ite (< v sedan) 1 0)) 0)))",
        "(forall ((d Days)) (not (= (ite (< d monday) 0 (ite (pickup-van-consecutive van d) 1 0)) (ite (< d monday) 0 (ite (pickup-sedan-consecutive sedan d) 1 0)))))",
        "(forall ((v Vehicles)) (or (not (= (to-int (serviced v monday)) (ite (< v roadster) 1 0))) (not (= (to-int (serviced v monday)) (ite (< v hatchback) 1 0))) (not (= (to-int (serviced v monday)) (ite (< v van) 1 0)))))",
        "(forall ((v Vehicles)) (or (not (= (to-int (serviced v monday)) (ite (< v sedan) 1 0))) (not (= (to-int (serviced v monday)) (ite (< v pickup) 1 0))) (not (= (to-int (serviced v monday)) (ite (< v limousine) 1 0)))))"
      ],
      "options": [
        "(forall ((v Vehicles)) (not (= (to-int (serviced v thursday)) (ite (< v hatchback) 1 0))))",
        "(forall ((v Vehicles)) (not (= (to-int (serviced v thursday)) (ite (< v limousine) 1 0))))",
        "(forall ((v Vehicles)) (not (= (to-int (serviced v thursday)) (ite (< v pickup) 1 0))))",
        "(forall ((v Vehicles)) (not (= (to-int (serviced v thursday)) (ite (< v sedan) 1 0))))",
        "(forall ((v Vehicles)) (not (= (to-int (serviced v thursday)) (ite (< v van) 1 0))))"
      ],
      "type": "unsat",
      "perplexity": [
        1.1640422344207764,
        1.0407052040100098
      ],
      "answer": "E",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "No Output"
    }
  },
  {
    "id": 59,
    "nl_problem": {
      "context": "A company's six vehicles—a hatchback, a limousine, a pickup, a roadster, a sedan, and a van—are serviced during a certain week—Monday through Saturday—one vehicle per day. The following conditions must apply: At least one of the vehicles is serviced later in the week than the hatchback. The roadster is serviced later in the week than the van and earlier in the week than the hatchback. Either the pickup and the van are serviced on consecutive days, or the pickup and the sedan are serviced on consecutive days, but not both. The sedan is serviced earlier in the week than the pickup or earlier in the week than the limousine, but not both.",
      "question": "If neither the pickup nor the limousine is serviced on Monday, then which one of the following must be true?",
      "options": [
        "A) The hatchback and the limousine are serviced on consecutive days.",
        "B) The hatchback and the sedan are serviced on consecutive days.",
        "C) The van is serviced on Monday.",
        "D) The limousine is serviced on Saturday.",
        "E) The pickup is serviced on Saturday."
      ]
    },
    "answer": "C",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((Vehicles 0)) (((hatchback) (limousine) (pickup) (roadster) (sedan) (van))))",
        "(declare-datatypes ((Days 0)) (((monday) (tuesday) (wednesday) (thursday) (friday) (saturday))))",
        "(declare-fun serviced (Vehicles Days) Bool)"
      ],
      "constraints": [
        "(exists ((v Vehicles)) (> (+ (ite (serviced v tuesday) 1 0) (ite (serviced v wednesday) 1 0) (ite (serviced v thursday) 1 0) (ite (serviced v friday) 1 0) (ite (serviced v saturday) 1 0)) (ite (serviced hatchback tuesday) 1 0)))",
        "(and (> (+ (ite (serviced roadster wednesday) 1 0) (ite (serviced roadster thursday) 1 0) (ite (serviced roadster friday) 1 0) (ite (serviced roadster saturday) 1 0)) (ite (serviced van wednesday) 1 0)) (> (ite (serviced hatchback monday) 1 0) (+ (ite (serviced roadster tuesday) 1 0) (ite (serviced roadster monday) 1 0)))))",
        "(or (and (and (ite (serviced pickup tuesday) 1 0) (ite (serviced pickup monday) 0 1)) (ite (serviced van tuesday) 1 0)) (and (and (ite (serviced pickup tuesday) 1 0) (ite (serviced pickup monday) 0 1)) (ite (serviced sedan tuesday) 1 0)) (not (and (and (ite (serviced pickup tuesday) 1 0) (ite (serviced pickup monday) 0 1)) (ite (serviced van tuesday) 1 0) (ite (serviced sedan tuesday) 1 0))))",
        "(and (> (ite (serviced sedan monday) 1 0) (+ (ite (serviced pickup monday) 1 0) (ite (serviced pickup tuesday) 1 0) (ite (serviced pickup wednesday) 1 0) (ite (serviced pickup thursday) 1 0) (ite (serviced pickup friday) 1 0) (ite (serviced pickup saturday) 1 0))) (> (ite (serviced sedan monday) 1 0) (+ (ite (serviced limousine monday) 1 0) (ite (serviced limousine tuesday) 1 0) (ite (serviced limousine wednesday) 1 0) (ite (serviced limousine thursday) 1 0) (ite (serviced limousine friday) 1 0) (ite (serviced limousine saturday) 1 0)))) (not (and (> (ite (serviced sedan monday) 1 0) (+ (ite (serviced pickup monday) 1 0) (ite (serviced pickup tuesday) 1 0) (ite (serviced pickup wednesday) 1 0) (ite (serviced pickup thursday) 1 0) (ite (serviced pickup friday) 1 0) (ite (serviced pickup saturday) 1 0))) (> (ite (serviced sedan monday) 1 0) (+ (ite (serviced limousine monday) 1 0) (ite (serviced limousine tuesday) 1 0) (ite (serviced limousine wednesday) 1 0) (ite (serviced limousine thursday) 1 0) (ite (serviced limousine friday) 1 0) (ite (serviced limousine saturday) 1 0))))))",
        "(not (or (serviced pickup monday) (serviced limousine monday)))"
      ],
      "options": [
        "(forall ((d Days)) (= correct_option (ite (and (ite (serviced hatchback monday) 1 0) (ite (serviced limousine tuesday) 1 0)) 1 0)))",
        "(forall ((d Days)) (= correct_option (ite (and (ite (serviced hatchback monday) 1 0) (ite (serviced sedan tuesday) 1 0)) 1 0)))",
        "(forall ((d Days)) (= correct_option (ite (ite (serviced van monday) 1 0) 1 0)))",
        "(forall ((d Days)) (= correct_option (ite (ite (serviced limousine saturday) 1 0) 1 0)))",
        "(forall ((d Days)) (= correct_option (ite (ite (serviced pickup saturday) 1 0) 1 0)))"
      ],
      "type": "sat",
      "perplexity": [
        1.098639726638794,
        1.0417852401733398
      ],
      "answer": "C",
      "predicted_answer": [
        "sat",
        "sat",
        "sat",
        "sat",
        "sat"
      ],
      "status": "success",
      "error": ""
    }
  },
  {
    "id": 60,
    "nl_problem": {
      "context": "A company's six vehicles—a hatchback, a limousine, a pickup, a roadster, a sedan, and a van—are serviced during a certain week—Monday through Saturday—one vehicle per day. The following conditions must apply: At least one of the vehicles is serviced later in the week than the hatchback. The roadster is serviced later in the week than the van and earlier in the week than the hatchback. Either the pickup and the van are serviced on consecutive days, or the pickup and the sedan are serviced on consecutive days, but not both. The sedan is serviced earlier in the week than the pickup or earlier in the week than the limousine, but not both.",
      "question": "If the limousine is not serviced on Saturday, then each of the following could be true EXCEPT:",
      "options": [
        "A) The limousine is serviced on Monday.",
        "B) The roadster is serviced on Tuesday.",
        "C) The hatchback is serviced on Wednesday.",
        "D) The roadster is serviced on Wednesday.",
        "E) The sedan is serviced on Wednesday."
      ]
    },
    "answer": "E",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((Vehicles 0)) (((hatchback) (limousine) (pickup) (roadster) (sedan) (van))))",
        "(declare-datatypes ((Days 0)) (((Monday) (Tuesday) (Wednesday) (Thursday) (Friday) (Saturday))))",
        "(declare-fun serviced (Vehicles Days) Bool)",
        "(define-fun to-int ((b Bool)) Int (ite b 1 0))",
        "(define-fun day-index ((d Days)) Int (ite (= d Monday) 1 (ite (= d Tuesday) 2 (ite (= d Wednesday) 3 (ite (= d Thursday) 4 (ite (= d Friday) 5 6)))))"
      ],
      "constraints": [
        "(forall ((d Days)) (< (+ (to-int (serviced hatchback d)) (to-int (serviced limousine d)) (to-int (serviced pickup d)) (to-int (serviced roadster d)) (to-int (serviced sedan d)) (to-int (serviced van d))) (day-index d)))",
        "(and (> (day-index roadster) (day-index van)) (< (day-index roadster) (day-index hatchback)))",
        "(or (and (= (day-index pickup) (+ (day-index van) 1)) (= (day-index sedan) (+ (day-index van) 1))) (and (= (day-index pickup) (+ (day-index sedan) 1)) (= (day-index sedan) (+ (day-index limousine) 1)) (not (= (day-index pickup) (+ (day-index sedan) 1))))",
        "(or (< (day-index sedan) (day-index pickup)) (< (day-index sedan) (day-index limousine)) (not (and (< (day-index sedan) (day-index pickup)) (< (day-index sedan) (day-index limousine))))"
      ],
      "options": [
        "(forall ((d Days)) (= (serviced roadster Wednesday) true))"
      ],
      "type": "unsat",
      "perplexity": [
        1.1374462842941284,
        1.1034976243972778
      ],
      "answer": "E",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "No Output"
    }
  },
  {
    "id": 61,
    "nl_problem": {
      "context": "A company's six vehicles—a hatchback, a limousine, a pickup, a roadster, a sedan, and a van—are serviced during a certain week—Monday through Saturday—one vehicle per day. The following conditions must apply: At least one of the vehicles is serviced later in the week than the hatchback. The roadster is serviced later in the week than the van and earlier in the week than the hatchback. Either the pickup and the van are serviced on consecutive days, or the pickup and the sedan are serviced on consecutive days, but not both. The sedan is serviced earlier in the week than the pickup or earlier in the week than the limousine, but not both.",
      "question": "If the sedan is serviced earlier in the week than the pickup, then which one of the following could be true?",
      "options": [
        "A) The limousine is serviced on Wednesday.",
        "B) The sedan is serviced on Wednesday.",
        "C) The van is serviced on Wednesday.",
        "D) The hatchback is serviced on Friday.",
        "E) The limousine is serviced on Saturday."
      ]
    },
    "answer": "A",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((Vehicles 0)) (((hatchback) (limousine) (pickup) (roadster) (sedan) (van))))",
        "(declare-datatypes ((Days 0)) (((Monday) (Tuesday) (Wednesday) (Thursday) (Friday) (Saturday))))",
        "(declare-fun serviced (Vehicles Days) Bool)",
        "(declare-fun later (Vehicles Vehicles) Bool)",
        "(define-fun to-int ((b Bool)) Int (ite b 1 0))",
        "(define-fun week-num ((d Day) (v Vehicle)) Int (ite (= d Monday) 1 (ite (= d Tuesday) 2 (ite (= d Wednesday) 3 (ite (= d Thursday) 4 (ite (= d Friday) 5 6))))))"
      ],
      "constraints": [
        "(forall ((v Vehicle)) (exists ((d Day)) (and (<= 1 (week-num d v)) (< (week-num d v) 6) (serviced v d))))",
        "(define-fun roadster-earlier-than-van () Bool (= 3 (week-num Wednesday roadster)))",
        "(define-fun roadster-earlier-than-hatchback () Bool (= 3 (week-num Wednesday roadster)))",
        "(define-fun van-earlier-than-roadster () Bool (= 2 (week-num Wednesday van)))",
        "(define-fun hatchback-earlier-than-roadster () Bool (= 4 (week-num Wednesday hatchback)))",
        "(forall ((v Vehicle) (d Day)) (=> (serviced v d) (<= 1 (week-num d v)) (<= (week-num d v) 6)))",
        "(define-fun hatchback-earlier-than-van () Bool (<= (week-num Wednesday hatchback) (week-num Wednesday van)))",
        "(define-fun consecutive-pickup-van () Bool (or (= 4 (week-num Friday van)) (= 4 (week-num Thursday van))))",
        "(define-fun consecutive-pickup-sedan () Bool (or (= 4 (week-num Friday sedan)) (= 4 (week-num Thursday sedan))))",
        "(forall ((d1 Day) (d2 Day)) (=> (and (or (= (week-num d1 pickup) (week-num d1 van)) (= (week-num d1 pickup) (week-num d1 sedan))) (or (= (week-num d2 pickup) (week-num d2 van)) (= (week-num d2 pickup) (week-num d2 sedan)))) (not (= (week-num d1 pickup) (week-num d2 pickup)))))",
        "(define-fun sedan-earlier-than-pickup-or-limousine () Bool (and (<= (week-num Wednesday sedan) (week-num Wednesday pickup)) (<= (week-num Wednesday sedan) (week-num Wednesday limousine))))",
        "(forall ((d Day)) (not (= (week-num d sedan) (week-num d pickup))))",
        "(for-all ((d Day)) (not (= (week-num d sedan) (week-num d limousine))))"
      ],
      "options": [
        "(forall ((d Day)) (or (= (week-num d sedan) 4) (= (week-num d limousine) 5) (= (week-num d van) 3) (= (week-num d hatchback) 5) (= (week-num d limousine) 6)))",
        "(forall ((d Day)) (not (= (week-num d sedan) 3)))",
        "(forall ((d Day)) (not (= (week-num d sedan) 5)))"
      ],
      "type": "sat",
      "perplexity": [
        1.2636430263519287,
        1.0489850044250488
      ],
      "answer": "A",
      "predicted_answer": [
        "sat",
        "sat",
        "sat"
      ],
      "status": "success",
      "error": ""
    }
  },
  {
    "id": 62,
    "nl_problem": {
      "context": "A company's six vehicles—a hatchback, a limousine, a pickup, a roadster, a sedan, and a van—are serviced during a certain week—Monday through Saturday—one vehicle per day. The following conditions must apply: At least one of the vehicles is serviced later in the week than the hatchback. The roadster is serviced later in the week than the van and earlier in the week than the hatchback. Either the pickup and the van are serviced on consecutive days, or the pickup and the sedan are serviced on consecutive days, but not both. The sedan is serviced earlier in the week than the pickup or earlier in the week than the limousine, but not both.",
      "question": "If the limousine is serviced on Saturday, then which one of the following must be true?",
      "options": [
        "A) The pickup is serviced earlier in the week than the roadster.",
        "B) The pickup is serviced earlier in the week than the sedan.",
        "C) The sedan is serviced earlier in the week than the roadster.",
        "D) The hatchback and the limousine are serviced on consecutive days.",
        "E) The roadster and the hatchback are serviced on consecutive days."
      ]
    },
    "answer": "B"
  },
  {
    "id": 63,
    "nl_problem": {
      "context": "A company's six vehicles—a hatchback, a limousine, a pickup, a roadster, a sedan, and a van—are serviced during a certain week—Monday through Saturday—one vehicle per day. The following conditions must apply: At least one of the vehicles is serviced later in the week than the hatchback. The roadster is serviced later in the week than the van and earlier in the week than the hatchback. Either the pickup and the van are serviced on consecutive days, or the pickup and the sedan are serviced on consecutive days, but not both. The sedan is serviced earlier in the week than the pickup or earlier in the week than the limousine, but not both.",
      "question": "Which one of the following could be the list of the vehicles serviced on Tuesday, Wednesday, and Friday, listed in that order?",
      "options": [
        "A) the pickup, the hatchback, the limousine",
        "B) the pickup, the roadster, the hatchback",
        "C) the sedan, the limousine, the hatchback",
        "D) the van, the limousine, the hatchback",
        "E) the van, the roadster, the limousine"
      ]
    },
    "answer": "B",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((Vehicles 0)) (((hatchback) (limousine) (pickup) (roadster) (sedan) (van))))",
        "(declare-datatypes ((Days 0)) (((monday) (tuesday) (wednesday) (thursday) (friday) (saturday))))",
        "(declare-fun serviced (Vehicles Days) Bool)",
        "(define-fun to-int ((b Bool)) Int (ite b 1 0))",
        "(declare-fun day-order (Vehicles Vehicles) Bool)",
        "(define-fun day-order ((v1 Vehicles) (v2 Vehicles)) Bool (ite (> (ite (distinct v1 hatchback) 1 0) (ite (distinct v2 hatchback) 1 0)) (ite (> (ite (distinct v1 van) 1 0) (ite (distinct v2 van) 1 0) (> (ite (distinct v1 hatchback) 1 0) (ite (distinct v2 hatchback) 1 0))) (> (ite (distinct v1 van) 1 0) (ite (distinct v2 van) 1 0))) (> (ite (distinct v1 van) 1 0) (ite (distinct v2 van) 1 0))))"
      ],
      "constraints": [
        "(forall ((v Vehicles)) (exists ((d Days)) (> (ite (distinct v hatchback) 1 0) (ite (distinct v tuesday) 1 0) (> (ite (distinct v wednesday) 1 0) (ite (distinct v thursday) 1 0) (> (ite (distinct v friday) 1 0) (ite (distinct v saturday) 1 0)))))",
        "(forall ((d Days)) (and (> (ite (distinct roadster v) 1 0) (ite (distinct van v) 1 0)) (< (ite (distinct hatchback v) 1 0) (ite (distinct van v) 1 0)))",
        "(forall ((d1 Days) (d2 Days)) (or (and (= d1 monday) (and (distinct (ite (serviced pickup d1) 1 0) (ite (serviced van d1) 1 0)) (ite (serviced pickup d2) 1 0) (ite (serviced van d2) 1 0)) (= (+ (ite (distinct d1 tuesday) 1 0) (ite (distinct d1 wednesday) 1 0)) 1)) (and (distinct (ite (serviced pickup d1) 1 0) (ite (serviced sedan d1) 1 0)) (ite (serviced pickup d2) 1 0) (ite (serviced sedan d2) 1 0)) (= (+ (ite (distinct d1 tuesday) 1 0) (ite (distinct d1 wednesday) 1 0)) 1)))",
        "(forall ((d1 Days) (d2 Days)) (and (or (< (ite (distinct sedan d1) 1 0) (ite (distinct pickup d1) 1 0)) (< (ite (distinct sedan d1) 1 0) (ite (distinct limousine d1) 1 0))) (not (and (< (ite (distinct sedan d1) 1 0) (ite (distinct pickup d1) 1 0)) (< (ite (distinct sedan d1) 1 0) (ite (distinct limousine d1) 1 0)))))"
      ],
      "options": [
        "(= (ite (distinct (ite (serviced pickup tuesday) 1 0) (ite (serviced hatchback tuesday) 1 0)) 1 0) (ite (distinct (ite (serviced limousine tuesday) 1 0) (ite (serviced hatchback tuesday) 1 0)) 1 0) (ite (distinct (ite (serviced pickup wednesday) 1 0) (ite (serviced hatchback wednesday) 1 0)) 1 0))",
        "(= (ite (distinct (ite (serviced pickup tuesday) 1 0) (ite (serviced hatchback tuesday) 1 0)) 1 0) (ite (distinct (ite (serviced roadster tuesday) 1 0) (ite (serviced hatchback tuesday) 1 0)) 1 0) (ite (distinct (ite (serviced hatchback wednesday) 1 0) (ite (serviced hatchback wednesday) 1 0)) 1 0))",
        "(= (ite (distinct (ite (serviced sedan tuesday) 1 0) (ite (serviced limousine tuesday) 1 0)) 1 0) (ite (distinct (ite (serviced hatchback tuesday) 1 0) (ite (serviced hatchback tuesday) 1 0)) 1 0) (ite (distinct (ite (serviced hatchback wednesday) 1 0) (ite (serviced hatchback wednesday) 1 0)) 1 0))",
        "(= (ite (distinct (ite (serviced van tuesday) 1 0) (ite (serviced hatchback tuesday) 1 0)) 1 0) (ite (distinct (ite (serviced limousine tuesday) 1 0) (ite (serviced hatchback tuesday) 1 0)) 1 0) (ite (distinct (ite (serviced hatchback wednesday) 1 0) (ite (serviced hatchback wednesday) 1 0)) 1 0))",
        "(= (ite (distinct (ite (serviced van tuesday) 1 0) (ite (serviced hatchback tuesday) 1 0)) 1 0) (ite (distinct (ite (serviced roadster tuesday) 1 0) (ite (serviced hatchback tuesday) 1 0)) 1 0) (ite (distinct (ite (serviced limousine wednesday) 1 0) (ite (serviced hatchback wednesday) 1 0)) 1 0))"
      ],
      "type": "unsat",
      "perplexity": [
        1.1476224660873413,
        1.0307457447052002
      ],
      "answer": "B",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "No Output"
    }
  },
  {
    "id": 64,
    "nl_problem": {
      "context": "A street entertainer has six boxes stacked one on top of the other and numbered consecutively 1 through 6, from the lowest box up to the highest. Each box contains a single ball, and each ball is one of three colors—green, red, or white. Onlookers are to guess the color of each ball in each box, given that the following conditions hold: There are more red balls than white balls. There is a box containing a green ball that is lower in the stack than any box that contains a red ball. There is a white ball in a box that is immediately below a box that contains a green ball.",
      "question": "If there are exactly two white balls, then which one of the following boxes could contain a green ball?",
      "options": [
        "A) box 1",
        "B) box 3",
        "C) box 4",
        "D) box 5",
        "E) box 6"
      ]
    },
    "answer": "B",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((Colors 0)) (((green) (red) (white))))",
        "(declare-datatypes ((Boxes 0)) (((box1) (box2) (box3) (box4) (box5) (box6))))",
        "(declare-fun has_ball (Boxes Colors) Bool)"
      ],
      "constraints": [
        "(declare-fun has_red ((Boxes Colors)) Bool (exists ((b Colors)) (= (has_ball b red) true)))",
        "(declare-fun has_white ((Boxes Colors)) Bool (exists ((b Colors)) (= (has_ball b white) true)))",
        "(>= (to-int (has_red box1)) (to-int (has_white box1)))",
        "(declare-fun has_green_lower_than_red () Bool)",
        "(forall ((b1 Boxes) (b2 Boxes)) (=> (= b1 box1) (not (= b2 box1)) (<= b1 b2) (=> (has_ball b2 green) (has_ball b1 red))))",
        "(declare-fun has_green ((Boxes Colors)) Bool (exists ((b Colors)) (= (has_ball b green) true)))",
        "(declare-fun has_red_lower ((Boxes Colors)) Bool (exists ((b1 Boxes) (b2 Boxes) (b Colors)) (and (= b1 box1) (not (= b2 box1)) (<= b1 b2) (=> (has_ball b2 green) (has_ball b1 red)) (= (has_ball b green) true))))",
        "(assert (has_green_lower_than_red))",
        "(forall ((b Boxes) (b2 Boxes)) (=> (= b box1) (not (= b2 box1)) (= b2 b) (=> (has_ball b green) (has_ball (if (= b2 box6) box6 box5) white))))",
        "(assert (= (+ (to-int (has_white box1)) (to-int (has_white box2)) (to-int (has_white box3)) (to-int (has_white box4)) (to-int (has_white box5)) (to-int (has_white box6))) 2))"
      ],
      "options": [
        "(= (could_contain_green box1) true)",
        "(= (could_contain_green box3) true)",
        "(= (could_contain_green box4) true)",
        "(= (could_contain_green box5) true)",
        "(= (could_contain_green box6) true)"
      ],
      "type": "unsat",
      "perplexity": [
        1.2762608528137207,
        1.087735652923584
      ],
      "answer": "B",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "No Output"
    }
  },
  {
    "id": 65,
    "nl_problem": {
      "context": "A street entertainer has six boxes stacked one on top of the other and numbered consecutively 1 through 6, from the lowest box up to the highest. Each box contains a single ball, and each ball is one of three colors—green, red, or white. Onlookers are to guess the color of each ball in each box, given that the following conditions hold: There are more red balls than white balls. There is a box containing a green ball that is lower in the stack than any box that contains a red ball. There is a white ball in a box that is immediately below a box that contains a green ball.",
      "question": "If there are green balls in boxes 5 and 6, then which one of the following could be true?",
      "options": [
        "A) There are red balls in boxes 1 and 4.",
        "B) There are red balls in boxes 2 and 4.",
        "C) There is a white ball in box 1.",
        "D) There is a white ball in box 2.",
        "E) There is a white ball in box 3."
      ]
    },
    "answer": "C",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((Box 0)) (((box1) (box2) (box3) (box4) (box5) (box6))))",
        "(declare-datatypes ((Color 0)) (((green) (red) (white))))",
        "(declare-fun has_color (Box Color) Bool)",
        "(declare-fun total_red (Int) Int)",
        "(declare-fun total_white (Int) Int)"
      ],
      "constraints": [
        "(>= (total_red 6) (total_white 6))",
        "(exists ((b Box)) (and (has_color b green) (forall ((r Box)) (=> (has_color r red) (> b r)))))",
        "(exists ((b Box)) (and (has_color b white) (exists ((g Box)) (and (has_color g green) (= (ite (= b box1) 1 1) (ite (= g box1) 1 (+ 1 (ite (= g box2) 1 (+ 1 (ite (= g box3) 1 (+ 1 (ite (= g box4) 1 (+ 1 (ite (= g box5) 1 (+ 1 (ite (= g box6) 1 6)))))))))))))))))",
        "(and (has_color box5 green) (has_color box6 green))",
        "(forall ((o (or (= (has_color box1 red) (has_color box4 red)) (= (has_color box2 red) (has_color box4 red)) (has_color box1 white) (has_color box2 white) (has_color box3 white)))) (= o (or (= (has_color box1 red) (has_color box4 red)) (= (has_color box2 red) (has_color box4 red)) (has_color box1 white) (has_color box2 white) (has_color box3 white))))"
      ],
      "options": [
        "(or (= (has_color box1 red) (has_color box4 red)) (= (has_color box2 red) (has_color box4 red)) (has_color box1 white) (has_color box2 white) (has_color box3 white))"
      ],
      "type": "unsat",
      "perplexity": [
        1.2828677892684937,
        1.0940401554107666
      ],
      "answer": "C",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "No Output"
    }
  },
  {
    "id": 66,
    "nl_problem": {
      "context": "A street entertainer has six boxes stacked one on top of the other and numbered consecutively 1 through 6, from the lowest box up to the highest. Each box contains a single ball, and each ball is one of three colors—green, red, or white. Onlookers are to guess the color of each ball in each box, given that the following conditions hold: There are more red balls than white balls. There is a box containing a green ball that is lower in the stack than any box that contains a red ball. There is a white ball in a box that is immediately below a box that contains a green ball.",
      "question": "The ball in which one of the following boxes must be the same color as at least one of the other balls?",
      "options": [
        "A) box 2",
        "B) box 3",
        "C) box 4",
        "D) box 5",
        "E) box 6"
      ]
    },
    "answer": "E",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((Boxes 0)) (((box1) (box2) (box3) (box4) (box5) (box6))))",
        "(declare-datatypes ((Colors 0)) (((green) (red) (white))))",
        "(declare-fun has-green (Boxes) Bool)",
        "(declare-fun has-red (Boxes) Bool)",
        "(declare-fun has-white (Boxes) Bool)"
      ],
      "constraints": [
        ">= (+ (to-int (has-red box1)) (to-int (has-red box2)) (to-int (has-red box3)) (to-int (has-red box4)) (to-int (has-red box5)) (to-int (has-red box6))) (+ (to-int (has-white box1)) (to-int (has-white box2)) (to-int (has-white box3)) (to-int (has-white box4)) (to-int (has-white box5)) (to-int (has-white box6)))",
        "(forall ((i Int) (b Boxes)) (= (ite (> i 0) (has-green (ite (< i 3) (ite (= i 2) box2 box1) (ite (= i 3) box3 (ite (= i 4) box4 box1)))) (ite (> i 0) (has-red (ite (< i 3) (ite (= i 2) box2 box1) (ite (= i 3) box3 (ite (= i 4) box4 box1)))) (ite (> i 0) (has-white (ite (< i 3) (ite (= i 2) box2 box1) (ite (= i 3) box3 (ite (= i 4) box4 box1)))) false)) (= (ite (> i 0) (ite (< i 3) (ite (= i 2) box2 box1) (ite (= i 3) box3 (ite (= i 4) box4 box1))) false true)))",
        "(forall ((i Int) (b Boxes)) (= (ite (= i 0) false (ite (= (ite (> i 0) (has-green (ite (< i 3) (ite (= i 2) box2 box1) (ite (= i 3) box3 (ite (= i 4) box4 box1)))) false) true) (ite (> i 0) (has-white (ite (< i 3) (ite (= i 2) box2 box1) (ite (= i 3) box3 (ite (= i 4) box4 box1)))) false)) (= (ite (> i 0) (ite (< i 3) (ite (= i 2) box2 box1) (ite (= i 3) box3 (ite (= i 4) box4 box1))) false true)))"
      ],
      "options": [
        "(forall ((m Boxes)) (or (= (has-green m) (or (has-green (ite (> 0 (- 2 1)) box2 box1)) (has-green (ite (> 0 (- 2 1)) box3 (ite (> 0 (- 2 1)) box4 box1))))) (or (= (has-red m) (or (has-red (ite (> 0 (- 2 1)) box2 box1)) (has-red (ite (> 0 (- 2 1)) box3 (ite (> 0 (- 2 1)) box4 box1))))) (or (= (has-white m) (or (has-white (ite (> 0 (- 2 1)) box2 box1)) (has-white (ite (> 0 (- 2 1)) box3 (ite (> 0 (- 2 1)) box4 box1)))))))))",
        "(forall ((m Boxes)) (or (= (has-green m) (or (has-green (ite (> 0 (- 3 1)) box2 box1)) (has-green (ite (> 0 (- 3 1)) box3 (ite (> 0 (- 3 1)) box4 box1))))) (or (= (has-red m) (or (has-red (ite (> 0 (- 3 1)) box2 box1)) (has-red (ite (> 0 (- 3 1)) box3 (ite (> 0 (- 3 1)) box4 box1))))) (or (= (has-white m) (or (has-white (ite (> 0 (- 3 1)) box2 box1)) (has-white (ite (> 0 (- 3 1)) box3 (ite (> 0 (- 3 1)) box4 box1)))))))))",
        "(forall ((m Boxes)) (or (= (has-green m) (or (has-green (ite (> 0 (- 4 1)) box2 box1)) (has-green (ite (> 0 (- 4 1)) box3 (ite (> 0 (- 4 1)) box4 box1))))) (or (= (has-red m) (or (has-red (ite (> 0 (- 4 1)) box2 box1)) (has-red (ite (> 0 (- 4 1)) box3 (ite (> 0 (- 4 1)) box4 box1))))) (or (= (has-white m) (or (has-white (ite (> 0 (- 4 1)) box2 box1)) (has-white (ite (> 0 (- 4 1)) box3 (ite (> 0 (- 4 1)) box4 box1)))))))))",
        "(forall ((m Boxes)) (or (= (has-green m) (or (has-green (ite (> 0 (- 5 1)) box2 box1)) (has-green (ite (> 0 (- 5 1)) box3 (ite (> 0 (- 5 1)) box4 box1))))) (or (= (has-red m) (or (has-red (ite (> 0 (- 5 1)) box2 box1)) (has-red (ite (> 0 (- 5 1)) box3 (ite (> 0 (- 5 1)) box4 box1))))) (or (= (has-white m) (or (has-white (ite (> 0 (- 5 1)) box2 box1)) (has-white (ite (> 0 (- 5 1)) box3 (ite (> 0 (- 5 1)) box4 box1)))))))))",
        "(forall ((m Boxes)) (or (= (has-green m) (or (has-green (ite (> 0 (- 6 1)) box2 box1)) (has-green (ite (> 0 (- 6 1)) box3 (ite (> 0 (- 6 1)) box4 box1))))) (or (= (has-red m) (or (has-red (ite (> 0 (- 6 1)) box2 box1)) (has-red (ite (> 0 (- 6 1)) box3 (ite (> 0 (- 6 1)) box4 box1))))) (or (= (has-white m) (or (has-white (ite (> 0 (- 6 1)) box2 box1)) (has-white (ite (> 0 (- 6 1)) box3 (ite (> 0 (- 6 1)) box4 box1))))))))"
      ],
      "type": "sat",
      "perplexity": [
        1.143773078918457,
        1.024099588394165
      ],
      "answer": "E",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "No Output"
    }
  },
  {
    "id": 67,
    "nl_problem": {
      "context": "A street entertainer has six boxes stacked one on top of the other and numbered consecutively 1 through 6, from the lowest box up to the highest. Each box contains a single ball, and each ball is one of three colors—green, red, or white. Onlookers are to guess the color of each ball in each box, given that the following conditions hold: There are more red balls than white balls. There is a box containing a green ball that is lower in the stack than any box that contains a red ball. There is a white ball in a box that is immediately below a box that contains a green ball.",
      "question": "Which one of the following must be true?",
      "options": [
        "A) There is a green ball in a box that is lower than box 4.",
        "B) There is a green ball in a box that is higher than box 4.",
        "C) There is a red ball in a box that is lower than box 4.",
        "D) There is a red ball in a box that is higher than box 4.",
        "E) There is a white ball in a box that is lower than box 4."
      ]
    },
    "answer": "A",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((Boxes 0)) (((box1) (box2) (box3) (box4) (box5) (box6))))",
        "(declare-datatypes ((Colors 0)) (((green) (red) (white))))",
        "(declare-fun contains (Boxes Colors) Bool)"
      ],
      "constraints": [
        ">= (to-int (contains box6 red)) (to-int (contains box6 white))",
        "(forall ((b Boxes) (c Colors)) (=> (contains b green) (not (exists ((d Boxes)) (< d b & (contains d red)))))",
        "(exists ((b Boxes)) (and (contains b white) (< b (contains box3 green))))"
      ],
      "options": [
        "(forall ((b Boxes)) (=> (< b box4) (= (contains b green) true)))",
        "(forall ((b Boxes)) (=> (> b box4) (= (contains b green) true)))",
        "(forall ((b Boxes)) (=> (< b box4) (= (contains b red) true)))",
        "(forall ((b Boxes)) (=> (> b box4) (= (contains b red) true)))",
        "(forall ((b Boxes)) (=> (< b box4) (= (contains b white) true)))"
      ],
      "type": "sat",
      "perplexity": [
        1.1693353652954102,
        1.128200888633728
      ],
      "answer": "A",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "No Output"
    }
  },
  {
    "id": 68,
    "nl_problem": {
      "context": "A street entertainer has six boxes stacked one on top of the other and numbered consecutively 1 through 6, from the lowest box up to the highest. Each box contains a single ball, and each ball is one of three colors—green, red, or white. Onlookers are to guess the color of each ball in each box, given that the following conditions hold: There are more red balls than white balls. There is a box containing a green ball that is lower in the stack than any box that contains a red ball. There is a white ball in a box that is immediately below a box that contains a green ball.",
      "question": "If there are red balls in boxes 2 and 3, then which one of the following could be true?",
      "options": [
        "A) There is a red ball in box 1.",
        "B) There is a white ball in box 1.",
        "C) There is a green ball in box 4.",
        "D) There is a red ball in box 5.",
        "E) There is a white ball in box 6."
      ]
    },
    "answer": "C",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((Box 0)) (((1) (2) (3) (4) (5) (6))))",
        "(declare-datatypes ((Color 0)) (((green) (red) (white))))",
        "(declare-fun has (Box Color) Bool)",
        "(declare-fun total_red (Color) Int)",
        "(declare-fun total_white (Color) Int)"
      ],
      "constraints": [
        ">(+ (to-int (has 1 red)) (to-int (has 2 red)) (to-int (has 3 red)) (to-int (has 4 red)) (to-int (has 5 red)) (to-int (has 6 red))) (+ (to-int (has 1 white)) (to-int (has 2 white)) (to-int (has 3 white)) (to-int (has 4 white)) (to-int (has 5 white)) (to-int (has 6 white)))",
        "(and (has 1 green) (forall ((b Box)) (=> (has b red) (> b 1))))",
        "(or (and (has 2 white) (has 1 green)) (and (has 3 white) (has 2 green)) (and (has 4 white) (has 3 green)) (and (has 5 white) (has 4 green)) (and (has 6 white) (has 5 green)))",
        "(and (has 2 red) (has 3 red))"
      ],
      "options": [
        "(= (has 1 red) true)",
        "(= (has 1 white) true)",
        "(= (has 4 green) true)",
        "(= (has 5 red) true)",
        "(= (has 6 white) true)"
      ],
      "type": "sat",
      "perplexity": [
        1.1764699220657349,
        1.1081721782684326
      ],
      "answer": "C",
      "predicted_answer": [
        "sat",
        "sat",
        "sat",
        "sat",
        "sat"
      ],
      "status": "success",
      "error": ""
    }
  },
  {
    "id": 69,
    "nl_problem": {
      "context": "A street entertainer has six boxes stacked one on top of the other and numbered consecutively 1 through 6, from the lowest box up to the highest. Each box contains a single ball, and each ball is one of three colors—green, red, or white. Onlookers are to guess the color of each ball in each box, given that the following conditions hold: There are more red balls than white balls. There is a box containing a green ball that is lower in the stack than any box that contains a red ball. There is a white ball in a box that is immediately below a box that contains a green ball.",
      "question": "If boxes 2, 3, and 4 all contain balls that are the same color as each other, then which one of the following must be true?",
      "options": [
        "A) Exactly two of the boxes contain a green ball.",
        "B) Exactly three of the boxes contain a green ball.",
        "C) Exactly three of the boxes contain a red ball.",
        "D) Exactly one of the boxes contains a white ball.",
        "E) Exactly two of the boxes contain a white ball."
      ]
    },
    "answer": "D",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((Box 0)) (((box1) (box2) (box3) (box4) (box5) (box6))))",
        "(declare-datatypes ((Color 0)) (((green) (red) (white))))",
        "(declare-fun ball (Box) Color)"
      ],
      "constraints": [
        "(>= (+ (ite (= (ball box1) red) 1 0) (ite (= (ball box2) red) 1 0) (ite (= (ball box3) red) 1 0) (ite (= (ball box4) red) 1 0) (ite (= (ball box5) red) 1 0) (ite (= (ball box6) red) 1 0)) (+ (ite (= (ball box1) white) 1 0) (ite (= (ball box2) white) 1 0) (ite (= (ball box3) white) 1 0) (ite (= (ball box4) white) 1 0) (ite (= (ball box5) white) 1 0) (ite (= (ball box6) white) 1 0))) 0)",
        "(let ((lower-green (exists ((b Box)) (and (< b box1) (= (ball b) green))))) (exists ((b Box)) (and (< b lower-green) (= (ball b) red)))))",
        "(let ((upper-green (exists ((b Box)) (and (< box4 b) (= (ball b) green))))) (exists ((b Box)) (and (< b upper-green) (= (ball b) white))))"
      ],
      "options": [
        "(let ((same-color (and (= (ball box2) (ball box3)) (= (ball box2) (ball box4))))) (= 2 (ite (exists ((b Box)) (and (< box1 b) (= (ball b) green))) 1 0)))",
        "(let ((same-color (and (= (ball box2) (ball box3)) (= (ball box2) (ball box4))))) (= 3 (ite (exists ((b Box)) (and (< box1 b) (= (ball b) green))) 1 0)))",
        "(let ((same-color (and (= (ball box2) (ball box3)) (= (ball box2) (ball box4))))) (= 3 (ite (exists ((b Box)) (and (< box1 b) (= (ball b) red))) 1 0)))",
        "(let ((same-color (and (= (ball box2) (ball box3)) (= (ball box2) (ball box4))))) (= 1 (ite (exists ((b Box)) (and (< box1 b) (= (ball b) white))) 1 0)))",
        "(let ((same-color (and (= (ball box2) (ball box3)) (= (ball box2) (ball box4))))) (= 2 (ite (exists ((b Box)) (and (< box1 b) (= (ball b) white))) 1 0)))"
      ],
      "type": "sat",
      "perplexity": [
        1.0983027219772339,
        1.0602189302444458
      ],
      "answer": "D",
      "predicted_answer": [
        "sat",
        "sat",
        "sat",
        "sat",
        "sat"
      ],
      "status": "success",
      "error": ""
    }
  },
  {
    "id": 70,
    "nl_problem": {
      "context": "A professor must determine the order in which five of her students—Fernando, Ginny, Hakim, Juanita, and Kevin—will perform in an upcoming piano recital. Each student performs one piece, and no two performances overlap. The following constraints apply: Ginny must perform earlier than Fernando. Kevin must perform earlier than Hakim and Juanita. Hakim must perform either immediately before or immediately after Fernando.",
      "question": "Which one of the following could be the order, from first to last, in which the students perform?",
      "options": [
        "A) Ginny, Fernando, Hakim, Kevin, Juanita",
        "B) Ginny, Juanita, Kevin, Hakim, Fernando",
        "C) Ginny, Kevin, Hakim, Juanita, Fernando",
        "D) Kevin, Ginny, Juanita, Fernando, Hakim",
        "E) Kevin, Juanita, Fernando, Hakim, Ginny"
      ]
    },
    "answer": "D",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((Students 0)) (((Fernando) (Ginny) (Hakim) (Juanita) (Kevin))))",
        "(declare-fun performs (Students) Int)",
        "(declare-fun pos (Students) Int)",
        "(declare-fun all_pos (Int) Bool)",
        "(define-fun all_pos_func ((x Int)) Bool (forall ((y Students)) (not (= x (pos y)))))",
        "(declare-fun diff (Int Int) Int)"
      ],
      "constraints": [
        "(forall ((s Students)) (not (forall ((x Int)) (not (all_pos x)) (not (= (pos s) x)))))",
        "(forall ((f Int)) (forall ((t Int)) (=> (and (< f t) (= (pos Ginny) f)) (> t (pos Fernando))))))",
        "(forall ((f Int)) (forall ((t Int)) (=> (and (< f t) (= (pos Kevin) f)) (> t (pos Hakim))) (=> (and (< f t) (= (pos Kevin) f)) (> t (pos Juanita)))))",
        "(forall ((f Int)) (forall ((t Int)) (=> (and (distinct f t) (= (pos Hakim) f)) (ite (= (pos Fernando) (+ f 1)) true (= (diff t f) 1))) (=> (and (distinct f t) (= (pos Hakim) f)) (ite (= (pos Fernando) (+ f 1)) true (= (diff f t) 1)))))",
        "(forall ((f Int)) (forall ((t Int)) (=> (and (distinct f t) (= (pos Hakim) f)) (ite (= (pos Fernando) (+ f 1)) true (= (diff t f) 1))) (=> (and (distinct f t) (= (pos Hakim) f)) (ite (= (pos Fernando) (+ f 1)) true (= (diff f t) 1)))))",
        "(forall ((f Int)) (forall ((t Int)) (=> (and (distinct f t) (= (pos Hakim) f)) (ite (= (pos Fernando) (+ f 1)) true (= (diff t f) 1))) (=> (and (distinct f t) (= (pos Hakim) f)) (ite (= (pos Fernando) (+ f 1)) true (= (diff f t) 1)))))",
        "(forall ((f Int)) (forall ((t Int)) (=> (and (distinct f t) (= (pos Hakim) f)) (ite (= (pos Fernando) (+ f 1)) true (= (diff t f) 1))) (=> (and (distinct f t) (= (pos Hakim) f)) (ite (= (pos Fernando) (+ f 1)) true (= (diff f t) 1)))))",
        "(forall ((f Int)) (forall ((t Int)) (=> (and (distinct f t) (= (pos Hakim) f)) (ite (= (pos Fernando) (+ f 1)) true (= (diff t f) 1))) (=> (and (distinct f t) (= (pos Hakim) f)) (ite (= (pos Fernando) (+ f 1)) true (= (diff f t) 1)))))"
      ],
      "options": [
        "(forall ((x Int) (y Int) (z Int) (w Int) (v Int)) (and (= (pos Ginny) x) (= (pos Fernando) (+ x 1)) (= (pos Hakim) (+ x 2)) (= (pos Kevin) (+ x 3)) (= (pos Juanita) (+ x 4))))",
        "(forall ((x Int) (y Int) (z Int) (w Int) (v Int)) (and (= (pos Ginny) x) (= (pos Juanita) (+ x 1)) (= (pos Kevin) (+ x 2)) (= (pos Hakim) (+ x 3)) (= (pos Fernando) (+ x 4))))",
        "(forall ((x Int) (y Int) (z Int) (w Int) (v Int)) (and (= (pos Ginny) x) (= (pos Kevin) (+ x 1)) (= (pos Hakim) (+ x 2)) (= (pos Juanita) (+ x 3)) (= (pos Fernando) (+ x 4))))",
        "(forall ((x Int) (y Int) (z Int) (w Int) (v Int)) (and (= (pos Kevin) x) (= (pos Ginny) (+ x 1)) (= (pos Juanita) (+ x 2)) (= (pos Fernando) (+ x 3)) (= (pos Hakim) (+ x 4))))",
        "(forall ((x Int) (y Int) (z Int) (w Int) (v Int)) (and (= (pos Kevin) x) (= (pos Juanita) (+ x 1)) (= (pos Fernando) (+ x 2)) (= (pos Hakim) (+ x 3)) (= (pos Ginny) (+ x 4))))"
      ],
      "type": "unsat",
      "perplexity": [
        1.1548629999160767,
        1.04888916015625
      ],
      "answer": "D",
      "predicted_answer": [
        "unsat",
        "unsat",
        "unsat",
        "unsat",
        "unsat"
      ],
      "status": "success",
      "error": ""
    }
  },
  {
    "id": 71,
    "nl_problem": {
      "context": "A professor must determine the order in which five of her students—Fernando, Ginny, Hakim, Juanita, and Kevin—will perform in an upcoming piano recital. Each student performs one piece, and no two performances overlap. The following constraints apply: Ginny must perform earlier than Fernando. Kevin must perform earlier than Hakim and Juanita. Hakim must perform either immediately before or immediately after Fernando.",
      "question": "If Juanita performs earlier than Ginny, then which one of the following could be true?",
      "options": [
        "A) Fernando performs fourth.",
        "B) Ginny performs second.",
        "C) Hakim performs third.",
        "D) Juanita performs third.",
        "E) Kevin performs second."
      ]
    },
    "answer": "A",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((Students 0)) (((Fernando) (Ginny) (Hakim) (Juanita) (Kevin))))",
        "(declare-fun performance_order (Students) Int)",
        "(declare-fun piece (Students) Int)"
      ],
      "constraints": [
        "(forall ((s Students)) (= (< (performance_order s) (+ (performance_order s) 1)) true))",
        "(forall ((s Students)) (= (ite (< (performance_order Ginny) (performance_order Fernando)) true false) true))",
        "(forall ((s Students)) (= (ite (< (performance_order Kevin) (performance_order Hakim)) true false) true))",
        "(forall ((s Students)) (= (ite (< (performance_order Kevin) (performance_order Juanita)) true false) true))",
        "(forall ((s Students) (t Students)) (= (ite (ite (< (performance_order Hakim) (performance_order Fernando)) (ite (< (performance_order Hakim) (+ (performance_order Fernando) 1)) true false) false) true false))"
      ],
      "options": [
        "(and (ite (< (performance_order Juanita) (performance_order Ginny)) (ite (ite (= (performance_order Fernando) 4) true false) true false) true false) (= (performance_order Fernando) 4))",
        "(and (ite (< (performance_order Juanita) (performance_order Ginny)) (ite (ite (= (performance_order Fernando) 4) true false) true false) true false) (= (performance_order Ginny) 2))",
        "(and (ite (< (performance_order Juanita) (performance_order Ginny)) (ite (ite (= (performance_order Fernando) 4) true false) true false) true false) (= (performance_order Hakim) 3))",
        "(and (ite (< (performance_order Juanita) (performance_order Ginny)) (ite (ite (= (performance_order Fernando) 4) true false) true false) true false) (= (performance_order Juanita) 3))",
        "(and (ite (< (performance_order Juanita) (performance_order Ginny)) (ite (ite (= (performance_order Fernando) 4) true false) true false) true false) (= (performance_order Kevin) 2))"
      ],
      "type": "sat",
      "perplexity": [
        1.2851804494857788,
        1.0807055234909058
      ],
      "answer": "A",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "No Output"
    }
  },
  {
    "id": 72,
    "nl_problem": {
      "context": "A professor must determine the order in which five of her students—Fernando, Ginny, Hakim, Juanita, and Kevin—will perform in an upcoming piano recital. Each student performs one piece, and no two performances overlap. The following constraints apply: Ginny must perform earlier than Fernando. Kevin must perform earlier than Hakim and Juanita. Hakim must perform either immediately before or immediately after Fernando.",
      "question": "Which one of the following CANNOT be true?",
      "options": [
        "A) Fernando performs immediately before Juanita.",
        "B) Ginny performs immediately before Hakim.",
        "C) Hakim performs immediately before Ginny.",
        "D) Juanita performs immediately before Ginny.",
        "E) Kevin performs immediately before Hakim."
      ]
    },
    "answer": "C",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((Students 0)) (((Fernando) (Ginny) (Hakim) (Juanita) (Kevin))))",
        "(declare-fun performs (Students Students) Bool)"
      ],
      "constraints": [
        "(forall ((s Students)) (not (= (performing s s))))",
        "(forall ((s Students) (t Students)) (=> (= (performing s t) (performing t s)) (= s t)))",
        "(forall ((s Students) (t Students) (u Students)) (=> (and (performing s t) (performing t u)) (or (= s u) (= (performing s u) (performing u s)) (= (performing u s) (performing s u)))))",
        "(forall ((s Students) (t Students)) (=> (performing s t) (not (performing t s))))",
        "(forall ((s Students) (t Students)) (=> (and (performing s t) (performing t s)) (= s t)))",
        "(forall ((t Students)) (=> (= t Fernando) (= (performing Ginny t) (performing t Fernando))))",
        "(forall ((t Students)) (=> (= t Kevin) (or (= (performing t Hakim) (performing Hakim t)) (= (performing t Juanita) (performing Juanita t)))))",
        "(forall ((t Students)) (=> (= t Fernando) (or (= (performing Hakim t) (performing t Hakim)) (= (performing t Hakim) (performing Hakim t)))))"
      ],
      "options": [
        "(forall ((t Students)) (=> (= t Juanita) (= (performing t Fernando) (performing Fernando t))))",
        "(forall ((t Students)) (=> (= t Hakim) (= (performing Ginny t) (performing t Ginny))))",
        "(forall ((t Students)) (=> (= t Hakim) (= (performing t Ginny) (performing Ginny t))))",
        "(forall ((t Students)) (=> (= t Ginny) (= (performing t Juanita) (performing Juanita t))))",
        "(forall ((t Students)) (=> (= t Kevin) (= (performing t Hakim) (performing Hakim t))))"
      ],
      "type": "unsat",
      "perplexity": [
        1.221605658531189,
        1.0717228651046753
      ],
      "answer": "C",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "No Output"
    }
  },
  {
    "id": 73,
    "nl_problem": {
      "context": "A professor must determine the order in which five of her students—Fernando, Ginny, Hakim, Juanita, and Kevin—will perform in an upcoming piano recital. Each student performs one piece, and no two performances overlap. The following constraints apply: Ginny must perform earlier than Fernando. Kevin must perform earlier than Hakim and Juanita. Hakim must perform either immediately before or immediately after Fernando.",
      "question": "The order in which the students perform is fully determined if which one of the following is true?",
      "options": [
        "A) Fernando performs immediately before Hakim.",
        "B) Ginny performs immediately before Fernando.",
        "C) Hakim performs immediately before Juanita.",
        "D) Juanita performs immediately before Hakim.",
        "E) Kevin performs immediately before Fernando."
      ]
    },
    "answer": "E"
  },
  {
    "id": 74,
    "nl_problem": {
      "context": "A professor must determine the order in which five of her students—Fernando, Ginny, Hakim, Juanita, and Kevin—will perform in an upcoming piano recital. Each student performs one piece, and no two performances overlap. The following constraints apply: Ginny must perform earlier than Fernando. Kevin must perform earlier than Hakim and Juanita. Hakim must perform either immediately before or immediately after Fernando.",
      "question": "How many of the students are there any one of whom could perform fourth?",
      "options": [
        "A) one",
        "B) two",
        "C) three",
        "D) four",
        "E) five"
      ]
    },
    "answer": "B",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((Students 0)) (((Fernando) (Ginny) (Hakim) (Juanita) (Kevin))))",
        "(declare-datatypes ((Pieces 0)) (((piece1) (piece2) (piece3) (piece4) (piece5))))",
        "(declare-fun performs (Students Pieces) Bool)",
        "(declare-fun order (Students) Int)",
        "(declare-fun prev (Students Students) Bool)"
      ],
      "constraints": [
        "(= 5 (card (Students)))",
        "(forall ((s Students)) (=> (not (prev s s)) (= (order s) (+ (order s 1) 1))))",
        "(forall ((s Students) (p Pieces)) (=> (performs s p) (> (order s) 0)))",
        "(forall ((s1 Students) (s2 Students) (p Pieces)) (= (and (performs s1 p) (performs s2 p)) (or (< (order s1) (order s2)) (= (order s1) (order s2)))))",
        "(= (order Ginny) (< (order Ginny) (order Fernando)))",
        "(= (order Kevin) (< (order Kevin) (order Hakim)))",
        "(= (order Hakim) (ite (= (order Fernando) (+ (order Hakim) 1)) true (ite (= (order Hakim) (+ (order Fernando) 1)) true false)))"
      ],
      "options": [
        "(forbid)",
        "(forbid)",
        "(forbid)",
        "(forbid)",
        "(forbid)",
        "(forbid)",
        "(forbid)",
        "(forbid)",
        "(forbid)",
        "(forbid)"
      ],
      "type": "unsat",
      "perplexity": [
        1.3190233707427979,
        1.1023057699203491
      ],
      "answer": "B",
      "predicted_answer": [
        "unsat",
        "unsat",
        "unsat",
        "unsat",
        "unsat",
        "unsat",
        "unsat",
        "unsat",
        "unsat",
        "unsat"
      ],
      "status": "success",
      "error": ""
    }
  },
  {
    "id": 75,
    "nl_problem": {
      "context": "As part of an open house at a crafts studio, three teachers—Jiang, Kudrow, and Lanning—will give six consecutive presentations on six different subjects. Jiang will present on needlework and origami; Kudrow on pottery, stenciling, and textile making; and Lanning on woodworking. The order of their presentations will meet the following conditions: Kudrow cannot give two presentations in a row. The presentation on stenciling must be given earlier than the one on origami. The presentation on textile making must be given earlier than the one on woodworking.",
      "question": "Which one of the following could be the order of the presentations, from first to sixth?",
      "options": [
        "A) stenciling, origami, needlework, textile making, pottery, woodworking",
        "B) stenciling, origami, pottery, woodworking, needlework, textile making",
        "C) stenciling, origami, textile making, woodworking, needlework, pottery",
        "D) textile making, origami, stenciling, woodworking, needlework, pottery",
        "E) textile making, stenciling, woodworking, needlework, pottery, origami"
      ]
    },
    "answer": "C"
  },
  {
    "id": 76,
    "nl_problem": {
      "context": "As part of an open house at a crafts studio, three teachers—Jiang, Kudrow, and Lanning—will give six consecutive presentations on six different subjects. Jiang will present on needlework and origami; Kudrow on pottery, stenciling, and textile making; and Lanning on woodworking. The order of their presentations will meet the following conditions: Kudrow cannot give two presentations in a row. The presentation on stenciling must be given earlier than the one on origami. The presentation on textile making must be given earlier than the one on woodworking.",
      "question": "If textile making is presented fifth, which one of the following could be true?",
      "options": [
        "A) Needlework is presented sixth.",
        "B) Pottery is presented fourth.",
        "C) Stenciling is presented second.",
        "D) Stenciling is presented third.",
        "E) Woodworking is presented second."
      ]
    },
    "answer": "D",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((Teachers 0)) (((Jiang) (Kudrow) (Lanning))))",
        "(declare-datatypes ((Subjects 0)) (((needlework) (origami) (pottery) (stenciling) (textile_making) (woodworking))))",
        "(declare-fun presents (Teachers Int) Subjects)"
      ],
      "constraints": [
        "(forall ((t Teachers)) (= (+ (ite (and (distinct t Jiang) (distinct t Kudrow)) 1 0) (ite (and (distinct t Jiang) (distinct t Lanning)) 1 0) 0) 1))",
        "(forall ((t Teachers) (i Int)) (distinct (presents t i) (presents t (+ i 1))))",
        "(forall ((i Int)) (< i 5))",
        "(forall ((i Int) (s Subjects)) (= (presents Kudrow i) s) (ite (< (+ 2 i) 5) true false))",
        "(forall ((i Int) (s Subjects)) (= (presents Kudrow i) s) (ite (< (+ 2 i) 5) true false) (= (presents Kudrow i) textile_making) (> (+ 2 i) 3))"
      ],
      "options": [
        "(= (presents Jiang 5) needlework)",
        "(= (presents Kudrow 3) pottery)",
        "(= (presents Kudrow 1) stenciling)",
        "(= (presents Kudrow 2) stenciling)",
        "(= (presents Lanning 1) woodworking)"
      ],
      "type": "unsat",
      "perplexity": [
        1.1705090999603271,
        1.1065518856048584
      ],
      "answer": "D",
      "predicted_answer": [
        "unsat",
        "unsat",
        "unsat",
        "unsat",
        "unsat"
      ],
      "status": "success",
      "error": ""
    }
  },
  {
    "id": 77,
    "nl_problem": {
      "context": "As part of an open house at a crafts studio, three teachers—Jiang, Kudrow, and Lanning—will give six consecutive presentations on six different subjects. Jiang will present on needlework and origami; Kudrow on pottery, stenciling, and textile making; and Lanning on woodworking. The order of their presentations will meet the following conditions: Kudrow cannot give two presentations in a row. The presentation on stenciling must be given earlier than the one on origami. The presentation on textile making must be given earlier than the one on woodworking.",
      "question": "If needlework is presented first, which one of the following could be true?",
      "options": [
        "A) Origami is presented sixth.",
        "B) Pottery is presented second.",
        "C) Stenciling is presented third.",
        "D) Textile making is presented fifth.",
        "E) Woodworking is presented third."
      ]
    },
    "answer": "E",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((Teachers 0)) (((Jiang) (Kudrow) (Lanning))))",
        "(declare-datatypes ((Subjects 0)) (((needlework) (origami) (pottery) (stenciling) (textile_making) (woodworking))))",
        "(declare-fun presents (Teachers Subjects) Bool)",
        "(declare-fun Jiang_presentations (Subjects) (Teachers Subjects))",
        "(declare-fun Kudrow_presentations (Subjects) (Teachers Subjects))",
        "(declare-fun Lanning_presentations (Subjects) (Teachers Subjects))",
        "(declare-fun presentations (Subjects) (Teachers Subjects))",
        "(declare-fun Kudrow_not_two_in_row ((Teachers Subjects) (Teachers Subjects)) Bool)",
        "(declare-fun stenciling_before_origami ((Teachers Subjects) (Teachers Subjects)) Bool)",
        "(declare-fun textile_making_before_woodworking ((Teachers Subjects) (Teachers Subjects)) Bool)",
        "(declare-fun A ((Teachers Subjects)) Bool)",
        "(declare-fun B ((Teachers Subjects)) Bool)",
        "(declare-fun C ((Teachers Subjects)) Bool)",
        "(declare-fun D ((Teachers Subjects)) Bool)",
        "(declare-fun E ((Teachers Subjects)) Bool)"
      ],
      "constraints": [
        "(forall ((t Teachers) (s Subjects) (t2 Teachers) (s2 Subjects)) (=> (and (distinct t1 t2) (= t Kudrow) (= t2 Kudrow) (= s1 s) (= s2 (+ s1 1))) (not (and (presents t1 s1) (presents t2 s2)))))",
        "(forall ((t Teachers) (s Subjects) (t2 Teachers) (s2 Subjects)) (=> (and (distinct t1 t2) (= t1 Kudrow) (= t2 Kudrow) (= s1 pottery) (= s2 origami)) (not (and (presents t1 s1) (presents t2 s2))))))",
        "(forall ((t Teachers) (s Subjects) (t2 Teachers) (s2 Subjects)) (=> (and (distinct t1 t2) (= t1 Kudrow) (= t2 Kudrow) (= s1 textile_making) (= s2 woodworking)) (not (and (presents t1 s1) (presents t2 s2))))))",
        "(forall ((t Teachers) (s Subjects)) (=> (and (= s needlework) (= (+ s 5) origami) (presents Jiang s) (presents t origami)) (not (A t s))))",
        "(forall ((t Teachers) (s Subjects)) (=> (and (= s needlework) (= (+ s 1) pottery) (presents Jiang s) (presents t pottery)) (not (B t s))))",
        "(forall ((t Teachers) (s Subjects)) (=> (and (= s needlework) (= (+ s 2) stenciling) (presents Jiang s) (presents t stenciling)) (not (C t s))))",
        "(forall ((t Teachers) (s Subjects)) (=> (and (= s needlework) (= (+ s 4) textile_making) (presents Jiang s) (presents t textile_making)) (not (D t s))))",
        "(forall ((t Teachers) (s Subjects)) (=> (and (= s needlework) (= (+ s 2) woodworking) (presents Jiang s) (presents t woodworking)) (not (E t s))))",
        "(forall ((t Teachers)) (A t needlework))"
      ],
      "options": [],
      "type": "unsat",
      "perplexity": [
        1.1320539712905884,
        1.065615177154541
      ],
      "answer": "E",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "No Output"
    }
  },
  {
    "id": 78,
    "nl_problem": {
      "context": "As part of an open house at a crafts studio, three teachers—Jiang, Kudrow, and Lanning—will give six consecutive presentations on six different subjects. Jiang will present on needlework and origami; Kudrow on pottery, stenciling, and textile making; and Lanning on woodworking. The order of their presentations will meet the following conditions: Kudrow cannot give two presentations in a row. The presentation on stenciling must be given earlier than the one on origami. The presentation on textile making must be given earlier than the one on woodworking.",
      "question": "Jiang CANNOT give both",
      "options": [
        "A) the first and third presentations",
        "B) the first and fourth presentations",
        "C) the first and fifth presentations",
        "D) the second and third presentations",
        "E) the second and fourth presentations"
      ]
    },
    "answer": "B",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((Teachers 0)) (((Jiang) (Kudrow) (Lanning))))",
        "(declare-datatypes ((Subjects 0)) (((needlework) (origami) (pottery) (stenciling) (textile_making) (woodworking))))",
        "(declare-fun presentation (Teachers Subjects) Bool)",
        "(declare-fun presentation_order (Teachers Int) Int)"
      ],
      "constraints": [
        "(= (has_presentation Jiang needlework 0) true)",
        "(= (has_presentation Jiang origami 2) true)",
        "(= (has_presentation Kudrow pottery 1) true)",
        "(= (has_presentation Kudrow stenciling 3) true)",
        "(= (has_presentation Kudrow textile_making 4) true)",
        "(= (has_presentation Lanning woodworking 5) true)",
        "(forall ((i Int)) (=> (distinct (mod i 2) 0) (not (= (presentation_order Kudrow i) (presentation_order Kudrow (+ i 1)))))",
        "(forall ((i Int)) (=> (and (presentation Kudrow stenciling i) (presentation Jiang origami (+ i 2))) (< i (+ i 2))))",
        "(forall ((i Int)) (=> (and (presentation Kudrow textile_making i) (presentation Lanning woodworking (+ i 2))) (< i (+ i 2))))"
      ],
      "options": [
        "(= (presentation_order Jiang 0) 0)",
        "(= (presentation_order Jiang 0) 1)",
        "(= (presentation_order Jiang 0) 2)",
        "(= (presentation_order Jiang 0) 1)",
        "(= (presentation_order Jiang 0) 3)"
      ],
      "type": "unsat",
      "perplexity": [
        1.3004326820373535,
        1.1028375625610352
      ],
      "answer": "B",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "No Output"
    }
  },
  {
    "id": 79,
    "nl_problem": {
      "context": "As part of an open house at a crafts studio, three teachers—Jiang, Kudrow, and Lanning—will give six consecutive presentations on six different subjects. Jiang will present on needlework and origami; Kudrow on pottery, stenciling, and textile making; and Lanning on woodworking. The order of their presentations will meet the following conditions: Kudrow cannot give two presentations in a row. The presentation on stenciling must be given earlier than the one on origami. The presentation on textile making must be given earlier than the one on woodworking.",
      "question": "If needlework is presented sixth, which one of the following must be true?",
      "options": [
        "A) Origami is presented fourth.",
        "B) Pottery is presented fifth.",
        "C) Stenciling is presented third.",
        "D) Textile making is presented first.",
        "E) Woodworking is presented fourth."
      ]
    },
    "answer": "B",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((Presenters 0)) (((Jiang) (Kudrow) (Lanning)))",
        "(declare-datatypes ((Subjects 0)) (((needlework) (origami) (pottery) (stenciling) (textile_making) (woodworking)))",
        "(declare-fun gives (Presenters Subjects) Bool)",
        "(declare-fun order (Presenters Subjects) Int)"
      ],
      "constraints": [
        "(define-fun to-int ((b Bool)) Int (ite b 1 0))",
        "(forall ((s Subjects)) (not (= (and (not Jiang_origami) (gives Jiang s)) true))",
        "(forall ((s Subjects)) (not (= (and (not Jiang_needlework) (gives Jiang s)) true))",
        "(forall ((s Subjects)) (not (= (and (not Kudrow_pottery) (gives Kudrow s)) true))",
        "(forall ((s Subjects)) (not (= (and (not Kudrow_stenciling) (gives Kudrow s)) true))",
        "(forall ((s Subjects)) (not (= (and (not Kudrow_textile_making) (gives Kudrow s)) true))",
        "(forall ((s Subjects)) (not (= (and (not Lanning_woodworking) (gives Lanning s)) true))",
        "(forall ((p Presenters) (s1 Subjects) (s2 Subjects)) (= (ite (= p Jiang) (= (gives Kudrow s1) (= (gives Jiang s2) true)) false) true)",
        "(forall ((o order)) (= (< (ite Kudrow_stenciling 1 0) (ite Jiang_origami 1 0)) (ite (= 2 o) 1 0))",
        "(forall ((o order)) (= (< (ite Kudrow_textile_making 1 0) (ite Lanning_woodworking 1 0)) (ite (= 3 o) 1 0))"
      ],
      "options": [
        "(declare-fun needlework_sixth Bool) (= needlework_sixth true)"
      ],
      "type": "unsat",
      "perplexity": [
        1.014641284942627,
        1.0856462717056274
      ],
      "answer": "B",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "No Output"
    }
  },
  {
    "id": 80,
    "nl_problem": {
      "context": "As part of an open house at a crafts studio, three teachers—Jiang, Kudrow, and Lanning—will give six consecutive presentations on six different subjects. Jiang will present on needlework and origami; Kudrow on pottery, stenciling, and textile making; and Lanning on woodworking. The order of their presentations will meet the following conditions: Kudrow cannot give two presentations in a row. The presentation on stenciling must be given earlier than the one on origami. The presentation on textile making must be given earlier than the one on woodworking.",
      "question": "Which one of the following CANNOT be the subject of the second presentation?",
      "options": [
        "A) needlework",
        "B) origami",
        "C) pottery",
        "D) textile making",
        "E) woodworking"
      ]
    },
    "answer": "C",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((Teachers 0)) (((Jiang) (Kudrow) (Lanning))))",
        "(declare-datatypes ((Subjects 0)) (((needlework) (origami) (pottery) (stenciling) (textile_making) (woodworking))))",
        "(declare-fun gives (Teachers Subjects Int) Bool)"
      ],
      "constraints": [
        "(= Jiang_needlework true)",
        "(= Jiang_origami true)",
        "(= Kudrow_pottery true)",
        "(= Kudrow_stenciling true)",
        "(= Kudrow_textile_making true)",
        "(= Lanning_woodworking true)",
        "(define-fun Jiang_presents () Bool (and Jiang_needlework Jiang_origami))",
        "(define-fun Kudrow_presents () Bool (and Kudrow_pottery Kudrow_stenciling Kudrow_textile_making))",
        "(define-fun Lanning_presents () Bool Lanning_woodworking)",
        "(define-fun no_consecutive_presentation_by_Kudrow (p s) Bool (or (not (and (= p 0) (or Kudrow_pottery Kudrow_stenciling Kudrow_textile_making))) (not (and (= p 1) Kudrow_pottery)) (not (and (= p 2) Kudrow_stenciling)) (not (and (= p 3) Kudrow_textile_making))))",
        "(define-fun stenciling_before_origami (p) Bool (or (not Kudrow_stenciling) (not Jiang_origami) (< p 3)))",
        "(define-fun textile_making_before_woodworking (p) Bool (or (not Kudrow_textile_making) (not Lanning_woodworking) (< p 3)))"
      ],
      "options": [
        "(= not_second_presentation_needlework true)",
        "(= not_second_presentation_origami true)",
        "(= not_second_presentation_pottery true)",
        "(= not_second_presentation_textile_making true)",
        "(= not_second_presentation_woodworking true)"
      ],
      "type": "unsat",
      "perplexity": [
        1.120590329170227,
        1.0906614065170288
      ],
      "answer": "C",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "No Output"
    }
  },
  {
    "id": 81,
    "nl_problem": {
      "context": "The organizer of a luncheon will select exactly five foods to be served from among exactly eight foods: two desserts—F and G; three main courses—N, O, and P; three side dishes—T, V, and W. Only F, N, and T are hot foods. The following requirements will be satisfied: At least one dessert, at least one main course, and at least one side dish must be selected. At least one hot food must be selected. If either P or W is selected, both must be selected. If G is selected, O must be selected. If N is selected, V cannot be selected.",
      "question": "Which one of the following is a list of foods that could be the foods selected?",
      "options": [
        "A) F, N, O, T, V",
        "B) F, O, P, T, W",
        "C) G, N, P, T, W",
        "D) G, O, P, T, V",
        "E) G, O, P, V, W"
      ]
    },
    "answer": "B",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((Foods 0)) (((F) (G) (N) (O) (P) (T) (V) (W))))",
        "(declare-fun selected (Foods) Bool)",
        "(define-fun to-int ((b Bool)) Int (ite b 1 0))",
        "(declare-fun hot (Foods) Bool)",
        "(declare-fun dessert-count (Foods) Int)",
        "(declare-fun main-course-count (Foods) Int)",
        "(declare-fun side-dish-count (Foods) Int)",
        "(declare-fun num_foods (Foods) Int)",
        "(define-fun num-f (f Foods) (= num_foods f))",
        "(define-fun num-f-0 () (= num_foods 0))",
        "(define-fun num-f-1 () (= num_foods 1))",
        "(define-fun num-f-2 () (= num_foods 2))",
        "(define-fun num-f-3 () (= num_foods 3))",
        "(define-fun num-f-4 () (= num_foods 4))",
        "(define-fun num-f-5 () (= num_foods 5))",
        "(define-fun num-f-6 () (= num_foods 6))",
        "(define-fun num-f-7 () (= num_foods 7))",
        "(declare-fun hot-f (Foods) Bool)",
        "(define-fun hot-f-0 () (= hot-f F))",
        "(define-fun hot-f-1 () (= hot-f N))",
        "(define-fun hot-f-2 () (= hot-f T))"
      ],
      "constraints": [
        ">= (+ (to-int (selected F)) (to-int (selected G))) 1",
        ">= (+ (to-int (selected N)) (to-int (selected O)) (to-int (selected P))) 1",
        ">= (+ (to-int (selected T)) (to-int (selected V)) (to-int (selected W))) 1",
        ">= (+ (hot-count F) (hot-count N) (hot-count T)) 1",
        "=> (selected P) (selected W)",
        "=> (selected W) (selected P)",
        "=> (selected G) (selected O)",
        "not (=> (selected N) (selected V))"
      ],
      "options": [
        "=(+ (to-int (selected F)) (to-int (selected N)) (to-int (selected O)) (to-int (selected T)) (to-int (selected V))) 5",
        "=(+ (to-int (selected F)) (to-int (selected O)) (to-int (selected P)) (to-int (selected T)) (to-int (selected W))) 5",
        "=(+ (to-int (selected G)) (to-int (selected N)) (to-int (selected P)) (to-int (selected T)) (to-int (selected W))) 5",
        "=(+ (to-int (selected G)) (to-int (selected O)) (to-int (selected P)) (to-int (selected T)) (to-int (selected V))) 5",
        "=(+ (to-int (selected G)) (to-int (selected O)) (to-int (selected P)) (to-int (selected V)) (to-int (selected W))) 5"
      ],
      "type": "sat",
      "perplexity": [
        1.1161508560180664,
        1.0630818605422974
      ],
      "answer": "B",
      "predicted_answer": [
        "sat",
        "sat",
        "sat",
        "sat",
        "sat"
      ],
      "status": "success",
      "error": ""
    }
  },
  {
    "id": 82,
    "nl_problem": {
      "context": "The organizer of a luncheon will select exactly five foods to be served from among exactly eight foods: two desserts—F and G; three main courses—N, O, and P; three side dishes—T, V, and W. Only F, N, and T are hot foods. The following requirements will be satisfied: At least one dessert, at least one main course, and at least one side dish must be selected. At least one hot food must be selected. If either P or W is selected, both must be selected. If G is selected, O must be selected. If N is selected, V cannot be selected.",
      "question": "Which one of the following is a pair of foods of which the organizer of the luncheon must select at least one?",
      "options": [
        "A) F, T",
        "B) G, O",
        "C) N, T",
        "D) O, P",
        "E) V, W"
      ]
    },
    "answer": "D",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((Foods 0)) (((F) (G) (N) (O) (P) (T) (V) (W))))",
        "(declare-datatypes ((Selection 0)) (((Foods Sel F G N O P T V W))))",
        "(declare-fun hot (Foods) Bool)",
        "(declare-fun select (Selection Foods) Bool)",
        "(declare-fun main (Foods) Bool)",
        "(declare-fun side (Foods) Bool)"
      ],
      "constraints": [
        "(declare-fun Sel0 (Foods) Foods)",
        "(declare-fun Sel1 (Foods) Foods)",
        "(declare-fun Sel2 (Foods) Foods)",
        "(declare-fun Sel3 (Foods) Foods)",
        "(declare-fun Sel4 (Foods) Foods)",
        "(declare-fun Sel5 (Foods) Foods)",
        "(declare-fun Sel6 (Foods) Foods)",
        "(declare-fun Sel7 (Foods) Foods)",
        "(forall ((s Selection)) (or (select s F) (select s G) (select s N) (select s O) (select s P) (select s T) (select s V) (select s W)))",
        "(forall ((s Selection)) (or (select s F) (select s N) (select s T)))",
        "(forall ((s Selection)) (=> (or (select s P) (select s W)) (and (select s P) (select s W))))",
        "(forall ((s Selection)) (=> (select s G) (select s O)))",
        "(forall ((s Selection)) (=> (select s N) (not (select s V))))",
        "(forall ((s Selection)) (= (+ (ite (select s F) 1 0) (ite (select s G) 1 0) (ite (select s N) 1 0) (ite (select s O) 1 0) (ite (select s P) 1 0) (ite (select s T) 1 0) (ite (select s V) 1 0) (ite (select s W) 1 0)) 5))",
        "(forall ((m Meals)) (and (= (select Sel0 F) (select Sel0 T)) (= (select Sel1 G) (select Sel1 O)) (= (select Sel2 N) (select Sel2 T)) (= (select Sel3 O) (select Sel3 P)) (= (select Sel4 V) (select Sel4 W))))"
      ],
      "options": [
        "(forall ((m Meals)) (and (= (select Sel0 F) (select Sel0 T)) (= (select Sel1 G) (select Sel1 O))))",
        "(forall ((m Meals)) (and (= (select Sel0 F) (select Sel0 T)) (= (select Sel2 N) (select Sel2 T))))",
        "(forall ((m Meals)) (and (= (select Sel1 G) (select Sel1 O)) (= (select Sel3 O) (select Sel3 P))))",
        "(forall ((m Meals)) (and (= (select Sel1 G) (select Sel1 O)) (= (select Sel4 V) (select Sel4 W))))",
        "(forall ((m Meals)) (and (= (select Sel2 N) (select Sel2 T)) (= (select Sel3 O) (select Sel3 P))))",
        "(forall ((m Meals)) (and (= (select Sel2 N) (select Sel2 T)) (= (select Sel4 V) (select Sel4 W))))",
        "(forall ((m Meals)) (and (= (select Sel3 O) (select Sel3 P)) (= (select Sel4 V) (select Sel4 W))))"
      ],
      "type": "unsat",
      "perplexity": [
        1.3094340562820435,
        1.0637776851654053
      ],
      "answer": "D",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "No Output"
    }
  },
  {
    "id": 83,
    "nl_problem": {
      "context": "The organizer of a luncheon will select exactly five foods to be served from among exactly eight foods: two desserts—F and G; three main courses—N, O, and P; three side dishes—T, V, and W. Only F, N, and T are hot foods. The following requirements will be satisfied: At least one dessert, at least one main course, and at least one side dish must be selected. At least one hot food must be selected. If either P or W is selected, both must be selected. If G is selected, O must be selected. If N is selected, V cannot be selected.",
      "question": "If O is the only main course selected, then which one of the following CANNOT be selected?",
      "options": [
        "A) F",
        "B) G",
        "C) T",
        "D) V",
        "E) W"
      ]
    },
    "answer": "E",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((Foods 0)) (((F) (G) (N) (O) (P) (T) (V) (W))))",
        "(declare-fun selected (Foods) Bool)"
      ],
      "constraints": [
        "(= (+ (to-int (selected F)) (to-int (selected G)) (to-int (selected N)) (to-int (selected O)) (to-int (selected P)) (to-int (selected T)) (to-int (selected V)) (to-int (selected W))) 5)",
        "(>= (+ (to-int (selected F)) (to-int (selected G))) 1)",
        "(>= (+ (to-int (selected N)) (to-int (selected O)) (to-int (selected P))) 1)",
        "(>= (+ (to-int (selected T)) (to-int (selected V)) (to-int (selected W))) 1)",
        "(>= (+ (to-int (selected F)) (to-int (selected N)) (to-int (selected T))) 1)",
        "(and (= (selected P) true) (= (selected W) true))",
        "(and (= (selected G) true) (= (selected O) false))",
        "(and (= (selected N) true) (= (selected V) false))",
        "(=> (= (selected O) true) (= (selected P) true))",
        "(=> (= (selected O) true) (= (selected V) false))",
        "(=> (= (selected O) true) (= (selected W) false))"
      ],
      "options": [
        "(=> (= (selected O) true) (not (selected F)))",
        "(=> (= (selected O) true) (not (selected G)))",
        "(=> (= (selected O) true) (not (selected T)))",
        "(=> (= (selected O) true) (not (selected V)))",
        "(=> (= (selected O) true) (not (selected W)))"
      ],
      "type": "sat",
      "perplexity": [
        1.1141821146011353,
        1.0901036262512207
      ],
      "answer": "E",
      "predicted_answer": [
        "sat",
        "sat",
        "sat",
        "sat",
        "sat"
      ],
      "status": "success",
      "error": ""
    }
  },
  {
    "id": 84,
    "nl_problem": {
      "context": "The organizer of a luncheon will select exactly five foods to be served from among exactly eight foods: two desserts—F and G; three main courses—N, O, and P; three side dishes—T, V, and W. Only F, N, and T are hot foods. The following requirements will be satisfied: At least one dessert, at least one main course, and at least one side dish must be selected. At least one hot food must be selected. If either P or W is selected, both must be selected. If G is selected, O must be selected. If N is selected, V cannot be selected.",
      "question": "If F is not selected, which one of the following could be true?",
      "options": [
        "A) P is the only main course selected.",
        "B) T is the only side dish selected.",
        "C) Exactly two hot foods are selected.",
        "D) Exactly three main courses are selected.",
        "E) Exactly three side dishes are selected."
      ]
    },
    "answer": "D",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((Foods 0)) (((F) (G) (N) (O) (P) (T) (V) (W))))",
        "(declare-fun selected (Foods) Bool)",
        "(declare-fun hot (Foods) Bool)",
        "(declare-fun at_least_one_dessert (Foods) Bool)",
        "(declare-fun at_least_one_main_course (Foods) Bool)",
        "(declare-fun at_least_one_side_dish (Foods) Bool)",
        "(declare-fun at_least_one_hot_food (Foods) Bool)",
        "(declare-fun num_selected_foods (Foods) Int)",
        "(declare-fun num_desserts (Foods) Int)",
        "(declare-fun num_main_courses (Foods) Int)",
        "(declare-fun num_side_dishes (Foods) Int)",
        "(declare-fun num_hot_foods (Foods) Int)",
        "(declare-fun total_num_selected (Foods) Int)",
        "(declare-fun num_hot_foods_selected (Foods) Int)",
        "(declare-fun num_selected_P_and_W (Foods) Int)",
        "(declare-fun num_selected_G_and_O (Foods) Int)",
        "(declare-fun num_selected_N_and_not_V (Foods) Int)",
        "(declare-fun option_A (Foods) Bool)",
        "(declare-fun option_B (Foods) Bool)",
        "(declare-fun option_C (Foods) Bool)",
        "(declare-fun option_D (Foods) Bool)",
        "(declare-fun option_E (Foods) Bool)"
      ],
      "constraints": [
        "(>= (total_num_selected f) 0)",
        "(>= (total_num_selected f) 0)",
        "(>= (total_num_selected f) 0)",
        "(>= (num_hot_foods_selected f) 1)",
        ">= (+ (ite (and (selected P) (selected W)) 1 0) 1)",
        ">= (+ (ite (and (selected G) (selected O)) 1 0) 1)",
        ">= (+ (ite (and (selected N) (not (selected V))) 1 0) 1)",
        "(not (or (selected N) (selected O)))",
        "(not (or (selected V) (selected W)))",
        "(ite (= (num_hot_foods_selected f) 2) 1 0)",
        "(not (or (selected N) (selected O) (selected P)))",
        "(ite (= (total_num_selected f) 3) 1 0)",
        "not (= (total_num_selected f) 1)",
        "not (= (total_num_selected f) 1)",
        "not (= (num_hot_foods_selected f) 2)",
        "not (= (total_num_selected f) 3)",
        "not (= (total_num_selected f) 3)",
        "(=> (not (selected F)) option_A)",
        "(=> (not (selected F)) option_B)",
        "(=> (not (selected F)) option_C)",
        "(=> (not (selected F)) option_D)",
        "(=> (not (selected F)) option_E)",
        "not option_A"
      ],
      "options": [
        "option_A"
      ],
      "type": "sat",
      "perplexity": [
        1.2051864862442017,
        1.0918726921081543
      ],
      "answer": "D",
      "predicted_answer": [
        "sat"
      ],
      "status": "success",
      "error": ""
    }
  },
  {
    "id": 85,
    "nl_problem": {
      "context": "The organizer of a luncheon will select exactly five foods to be served from among exactly eight foods: two desserts—F and G; three main courses—N, O, and P; three side dishes—T, V, and W. Only F, N, and T are hot foods. The following requirements will be satisfied: At least one dessert, at least one main course, and at least one side dish must be selected. At least one hot food must be selected. If either P or W is selected, both must be selected. If G is selected, O must be selected. If N is selected, V cannot be selected.",
      "question": "If T and V are the only side dishes selected, then which one of the following is a pair of foods each of which must be selected?",
      "options": [
        "A) F and G",
        "B) F and N",
        "C) F and P",
        "D) N and O",
        "E) O and P"
      ]
    },
    "answer": "A",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((Foods 0)) (((F) (G) (N) (O) (P) (T) (V) (W))))",
        "(declare-fun selected (Foods) Bool)"
      ],
      "constraints": [
        "(exists ((d Foods)) (and (distinct F G) (distinct d F G) (selected d)))",
        "(exists ((m Foods)) (and (distinct N O P) (distinct m N O P) (selected m)))",
        "(exists ((s Foods)) (and (distinct T V W) (distinct s T V W) (selected s)))",
        "(exists ((h Foods)) (and (or (selected F) (selected N) (selected T)) (selected h)))",
        "(:= (or (selected P) (selected W)) (and (selected P) (selected W)))",
        "(:= (selected G) (selected O))",
        "(:= (selected N) (not (selected V)))",
        "(:= (not (selected T)) true)",
        "(:= (not (selected V)) true)",
        "(:forall ((d Foods)) (= (selected d) (or (distinct F d) (distinct G d))))",
        "(:forall ((m Foods)) (= (selected m) (or (distinct N m) (distinct O m) (distinct P m))))",
        "(:forall ((o Foods)) (= (selected o) (or (distinct O o) (distinct P o))))",
        "(:forall ((f Foods)) (= (selected f) (and (selected F) (selected G))))",
        "(:forall ((n Foods)) (= (selected n) (and (selected N) (selected O))))",
        "(:forall ((p Foods)) (= (selected p) (and (selected P) (selected O))))",
        "(:= (forall ((o Foods)) (= (selected o) (and (selected O) (selected P)))) (forall ((n Foods)) (= (selected n) (and (selected N) (selected O)))))"
      ],
      "options": [],
      "type": "sat",
      "perplexity": [
        1.3140941858291626,
        1.1378403902053833
      ],
      "answer": "A",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "No Output"
    }
  },
  {
    "id": 86,
    "nl_problem": {
      "context": "A television programming director is scheduling a three-hour block of programs beginning at 1 P.M. The programs that are to fill this time block include an hour-long program called Generations and four half-hour programs: Roamin', Sundown, Terry, and Waterloo. The programs will be shown one after the other, each program shown exactly once. The schedule must meet the following constraints: Generations starts on the hour rather than the half hour. Terry starts on the half hour rather than the hour. Roamin' is shown earlier than Sundown. If Waterloo is shown earlier than Terry, it is shown immediately before Terry.",
      "question": "Which one of the following could be the order in which the programs are shown, from earliest to latest?",
      "options": [
        "A) Generations, Roamin', Waterloo, Terry, Sundown",
        "B) Roamin', Sundown, Waterloo, Terry, Generations",
        "C) Roamin', Terry, Waterloo, Generations, Sundown",
        "D) Waterloo, Roamin', Sundown, Terry, Generations",
        "E) Waterloo, Terry, Sundown, Roamin', Generations"
      ]
    },
    "answer": "B",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((Programs 0)) (((Generations) (Roamin) (Sundown) (Terry) (Waterloo))))",
        "(declare-fun starts (Programs) Int)",
        "(declare-fun order (Programs) Int)",
        "(declare-fun shown (Programs Program) Bool)"
      ],
      "constraints": [
        "(= (+ (starts Generations) 1) 1)",
        "(= (+ (starts Terry) 1) 0)",
        "(> (starts Roamin) (starts Sundown))",
        "(=> (and (< (starts Waterloo) (starts Terry)) (= (order Waterloo) (+ (starts Terry) 1))) true)",
        "(>= (order Generations) 0)",
        "(>= (order Terry) 1)",
        "(> (starts Sundown) (starts Terry))",
        "(>= (order Waterloo) (starts Roamin))",
        "(>= (order Sundown) (starts Sundown))",
        "(>= (order Roamin) (starts Roamin))",
        "(= (+ (starts Waterloo) 1) 1)",
        "(>= (+ (starts Terry) 1) 1)",
        "(= (+ (starts Roamin) 1) 0)",
        "(= (+ (starts Sundown) 1) 0)",
        "(>= (order Generations) (order Terry))",
        "(>= (order Roamin) (order Sundown))"
      ],
      "options": [
        "(= (option Gen_Roam_Water_Terr_Sund) Gen_Roam_Water_Terr_Sund)",
        "(= (option Roam_Sund_Water_Terr_Gen) Roam_Sund_Water_Terr_Gen)",
        "(= (option Roam_Terr_Water_Gen_Sund) Roam_Terr_Water_Gen_Sund)",
        "(= (option Water_Terr_Roam_Sund_Gen) Water_Terr_Roam_Sund_Gen)",
        "(= (option Water_Terr_Sund_Roam_Gen) Water_Terr_Sund_Roam_Gen)"
      ],
      "type": "sat",
      "perplexity": [
        1.17877995967865,
        1.0863043069839478
      ],
      "answer": "B",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "No Output"
    }
  },
  {
    "id": 87,
    "nl_problem": {
      "context": "A television programming director is scheduling a three-hour block of programs beginning at 1 P.M. The programs that are to fill this time block include an hour-long program called Generations and four half-hour programs: Roamin', Sundown, Terry, and Waterloo. The programs will be shown one after the other, each program shown exactly once. The schedule must meet the following constraints: Generations starts on the hour rather than the half hour. Terry starts on the half hour rather than the hour. Roamin' is shown earlier than Sundown. If Waterloo is shown earlier than Terry, it is shown immediately before Terry.",
      "question": "If Waterloo is the first program, then how many orders are there in which the remaining programs could be shown?",
      "options": [
        "A) one",
        "B) two",
        "C) three",
        "D) four",
        "E) five"
      ]
    },
    "answer": "B",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((Programs 0)) (((Generations) (Roamin) (Sundown) (Terry) (Waterloo))))",
        "(declare-datatypes ((TimeSlots 0)) (((hour1) (hour2) (hour3))))",
        "(declare-fun starts (Programs TimeSlots) Bool)"
      ],
      "constraints": [
        "(forall ((t TimeSlots)) (= (or (starts Generations t) (and (not (starts Generations t)) (starts Terry t))) (not (and (not (starts Generations t)) (starts Terry t)))))",
        "(forall ((t TimeSlots)) (= (or (starts Terry t) (and (not (starts Terry t)) (starts Generations t))) (not (and (not (starts Terry t)) (starts Generations t)))))",
        "(forall ((p Programs) (t TimeSlots)) (= (=> (and (starts p t) (not (starts p t))) false)))",
        "(forall ((t1 TimeSlots) (t2 TimeSlots)) (= (=> (and (starts Roamin t1) (starts Sundown t2)) (> t1 t2))))",
        "(forall ((t1 TimeSlots) (t2 TimeSlots)) (=> (= t1 hour1) (= t2 hour1) (and (= (starts Waterloo t1) (starts Terry t2)) (= (not (starts Waterloo t1)) (not (starts Terry t2))))))",
        "(forall ((t TimeSlots)) (not (= (starts Terry t) (starts Generations t))))",
        "(forall ((t TimeSlots)) (not (= (starts Roamin t) (starts Sundown t))))",
        "(forall ((t TimeSlots)) (not (= (starts Terry t) (starts Waterloo t))))",
        "(forall ((t TimeSlots)) (not (= (starts Waterloo t) (starts Roamin t))))",
        "(forall ((t TimeSlots)) (not (= (starts Sundown t) (starts Generations t))))",
        "(forall ((t TimeSlots)) (not (= (starts Sundown t) (starts Terry t))))",
        "(forall ((t TimeSlots)) (not (= (starts Generations t) (starts Roamin t))))",
        "(forall ((t TimeSlots)) (not (= (starts Generations t) (starts Sundown t))))",
        "(forall ((t TimeSlots)) (not (= (starts Roamin t) (starts Terry t))))",
        "(forall ((t TimeSlots)) (not (= (starts Roamin t) (starts Waterloo t))))",
        "(forall ((t TimeSlots)) (not (= (starts Sundown t) (starts Terry t))))",
        "(forall ((t TimeSlots)) (not (= (starts Sundown t) (starts Waterloo t))))",
        "(forall ((t TimeSlots)) (not (= (starts Terry t) (starts Sundown t))))",
        "(forall ((t TimeSlots)) (not (= (starts Terry t) (starts Roamin t))))",
        "(forall ((t TimeSlots)) (not (= (starts Waterloo t) (starts Generations t))))",
        "(forall ((t TimeSlots)) (not (= (starts Waterloo t) (starts Terry t))))",
        "(forall ((t TimeSlots)) (not (= (starts Waterloo t) (starts Sundown t))))",
        "(forall ((t TimeSlots)) (not (= (starts Waterloo t) (starts Roamin t))))",
        "(forall ((t TimeSlots)) (not (= (starts Waterloo t) (starts Waterloo t))))",
        "(forall ((t TimeSlots)) (not (= (starts Sundown t) (starts Sundown t))))",
        "(forall ((t TimeSlots)) (not (= (starts Terry t) (starts Terry t))))",
        "(forall ((t TimeSlots)) (not (= (starts Roamin t) (starts Roamin t))))",
        "(forall ((t TimeSlots)) (not (= (starts Generations t) (starts Generations t))))"
      ],
      "options": [
        "(forall ((o1 TimeSlots) (o2 TimeSlots) (o3 TimeSlots) (o4 TimeSlots)) (=> (= (and (starts Waterloo o1) (starts Roamin o2) (starts Sundown o3) (starts Terry o4)) true) (or (and (= o1 hour1) (= o2 hour2) (= o3 hour3) (= o4 hour1)) (and (= o1 hour1) (= o2 hour2) (= o3 hour1) (= o4 hour3)) (and (= o1 hour1) (= o2 hour3) (= o3 hour2) (= o4 hour1)) (and (= o1 hour1) (= o2 hour3) (= o3 hour1) (= o4 hour2)) (and (= o1 hour1) (= o2 hour1) (= o3 hour2) (= o4 hour3)) (and (= o1 hour1) (= o2 hour1) (= o3 hour3) (= o4 hour2)) (and (= o1 hour2) (= o2 hour1) (= o3 hour3) (= o4 hour1)) (and (= o1 hour2) (= o2 hour1) (= o3 hour1) (= o4 hour3)) (and (= o1 hour2) (= o2 hour3) (= o3 hour1) (= o4 hour1)) (and (= o1 hour2) (= o2 hour3) (= o3 hour1) (= o4 hour2)) (and (= o1 hour2) (= o2 hour1) (= o3 hour2) (= o4 hour3)) (and (= o1 hour2) (= o2 hour1) (= o3 hour3) (= o4 hour2)) (and (= o1 hour3) (= o2 hour1) (= o3 hour2) (= o4 hour1)) (and (= o1 hour3) (= o2 hour1) (= o3 hour1) (= o4 hour2)) (and (= o1 hour3) (= o2 hour2) (= o3 hour1) (= o4 hour1)) (and (= o1 hour3) (= o2 hour2) (= o3 hour1) (= o4 hour2)) (and (= o1 hour3) (= o2 hour1) (= o3 hour2) (= o4 hour2)) (and (= o1 hour3) (= o2 hour1) (= o3 hour2) (= o4 hour1)) (and (= o1 hour3) (= o2 hour2) (= o3 hour2) (= o4 hour1)) (and (= o1 hour3) (= o2 hour2) (= o3 hour1) (= o4 hour1))))"
      ],
      "type": "sat",
      "perplexity": [
        1.111413836479187,
        1.027623176574707
      ],
      "answer": "B",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "No Output"
    }
  },
  {
    "id": 88,
    "nl_problem": {
      "context": "A television programming director is scheduling a three-hour block of programs beginning at 1 P.M. The programs that are to fill this time block include an hour-long program called Generations and four half-hour programs: Roamin', Sundown, Terry, and Waterloo. The programs will be shown one after the other, each program shown exactly once. The schedule must meet the following constraints: Generations starts on the hour rather than the half hour. Terry starts on the half hour rather than the hour. Roamin' is shown earlier than Sundown. If Waterloo is shown earlier than Terry, it is shown immediately before Terry.",
      "question": "If Roamin' is the second program, then each of the following could be true EXCEPT:",
      "options": [
        "A) Sundown is the third program.",
        "B) Sundown is the fourth program.",
        "C) Terry is the fifth program.",
        "D) Waterloo is the third program.",
        "E) Waterloo is the fifth program."
      ]
    },
    "answer": "D",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((People 0)) (((TV_Director)))",
        "(declare-datatypes ((Programs 0)) (((Generations) (Roamin) (Sundown) (Terry) (Waterloo)))",
        "(declare-fun hour (Programs) Int)",
        "(declare-fun half_hour (Programs) Int)",
        "(declare-fun starts (People Programs Int) Bool)",
        "(declare-fun starts_generations (TV_Director Int) Bool)",
        "(declare-fun starts_generations_half_hour (TV_Director Int) Bool)",
        "(declare-fun starts_terry (TV_Director Int) Bool)",
        "(declare-fun starts_terry_half_hour (TV_Director Int) Bool)",
        "(declare-fun roamin_before_sundown (Int Int) Bool)",
        "(declare-fun waterloo_before_terry (Int Int) Bool)",
        "(declare-fun program_order (Programs Int) Program)",
        "(declare-fun first_program_time (Program) Int)",
        "(declare-fun second_program_time (Program) Int)",
        "(declare-fun third_program_time (Program) Int)",
        "(declare-fun fourth_program_time (Program) Int)",
        "(declare-fun fifth_program_time (Program) Int)",
        "(declare-fun roamin_second (Int Int) Bool)",
        "(declare-fun sundown_third (Int Int) Bool)",
        "(declare-fun sundown_fourth (Int Int) Bool)",
        "(declare-fun terry_fifth (Int Int) Bool)",
        "(declare-fun waterloo_third (Int Int) Bool)",
        "(declare-fun waterloo_fifth (Int Int) Bool)",
        "(declare-fun option (Program Program Program Program Program) Bool)"
      ],
      "constraints": [
        "(not (and (starts TV_Director Generations (hour Generations)) (starts TV_Director Generations (half_hour Generations))))",
        "(not (and (starts TV_Director Terry (hour Terry)) (starts TV_Director Terry (half_hour Terry))))",
        "forall ((i1 Int) (i2 Int)) (= (roamin_before_sundown i1 i2) (or (= i1 1) (= i2 2)))",
        "forall ((i1 Int) (i2 Int)) (=> (and (= i1 1) (= i2 2)) (= (waterloo_before_terry i1 i2) true))",
        "forall ((p Program) (i Int)) (or (= (program_order p 1) Roamin) (= (program_order p 1) Generations) (= (program_order p 1) Terry) (= (program_order p 1) Sundown) (= (program_order p 1) Waterloo))",
        "forall ((p Program)) (or (= (first_program_time p) 1) (= (first_program_time p) 2) (= (first_program_time p) 3))",
        "forall ((p Program)) (or (= (second_program_time p) 1.5) (= (second_program_time p) 2.5) (= (second_program_time p) 3.5))",
        "forall ((p Program)) (or (= (third_program_time p) 2) (= (third_program_time p) 2.5) (= (third_program_time p) 3))",
        "forall ((p Program)) (or (= (fourth_program_time p) 2.5) (= (fourth_program_time p) 3) (= (fourth_program_time p) 3.5))",
        "forall ((p Program)) (or (= (fifth_program_time p) 3) (= (fifth_program_time p) 3.5))",
        "forall ((i1 Int) (i2 Int)) (= (roamin_second i1 i2) (and (program_order Roamin 1) (= (second_program_time Roamin) 1.5) (= i1 1.5)))",
        "forall ((i1 Int) (i2 Int)) (= (sundown_third i1 i2) (and (program_order Sundown 3) (= (third_program_time Sundown) 2.5) (= i2 2.5)))",
        "forall ((i1 Int) (i2 Int)) (= (sundown_fourth i1 i2) (and (program_order Sundown 4) (= (fourth_program_time Sundown) 3) (= i1 3)))",
        "forall ((i1 Int) (i2 Int)) (= (terry_fifth i1 i2) (and (program_order Terry 5) (= (fifth_program_time Terry) 3.5) (= i2 3.5)))",
        "forall ((i1 Int) (i2 Int)) (= (waterloo_third i1 i2) (and (program_order Waterloo 3) (= (third_program_time Waterloo) 2.5) (= i1 2.5)))",
        "forall ((i1 Int) (i2 Int)) (= (waterloo_fifth i1 i2) (and (program_order Waterloo 5) (= (fifth_program_time Waterloo) 3.5) (= i1 3.5)))",
        "forall ((p1 Program) (p2 Program) (p3 Program) (p4 Program) (p5 Program)) (or (= (option p1 p2 p3 p4 p5) (sundown_third 1.5 2.5)) (= (option p1 p2 p3 p4 p5) (sundown_fourth 1.5 3)) (= (option p1 p2 p3 p4 p5) (terry_fifth 1.5 3.5)) (= (option p1 p2 p3 p4 p5) (waterloo_third 1.5 2.5)) (= (option p1 p2 p3 p4 p5) (waterloo_fifth 1.5 3.5)))"
      ],
      "options": [
        "(sundown_third 1.5 2.5)",
        "(sundown_fourth 1.5 3)",
        "(terry_fifth 1.5 3.5)",
        "(waterloo_third 1.5 2.5)",
        "(waterloo_fifth 1.5 3.5)"
      ],
      "type": "sat",
      "perplexity": [
        1.1516474485397339,
        1.030173897743225
      ],
      "answer": "D",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "No Output"
    }
  },
  {
    "id": 89,
    "nl_problem": {
      "context": "A television programming director is scheduling a three-hour block of programs beginning at 1 P.M. The programs that are to fill this time block include an hour-long program called Generations and four half-hour programs: Roamin', Sundown, Terry, and Waterloo. The programs will be shown one after the other, each program shown exactly once. The schedule must meet the following constraints: Generations starts on the hour rather than the half hour. Terry starts on the half hour rather than the hour. Roamin' is shown earlier than Sundown. If Waterloo is shown earlier than Terry, it is shown immediately before Terry.",
      "question": "If Sundown is the third program, then which one of the following must be true?",
      "options": [
        "A) Generations is the first program.",
        "B) Roamin' is the first program.",
        "C) Roamin' is the second program.",
        "D) Terry is the fifth program.",
        "E) Waterloo is the fourth program."
      ]
    },
    "answer": "E",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((Programs 0)) (((Generations) (Roamin') (Sundown) (Terry) (Waterloo))))",
        "(declare-datatypes ((Time 0)) (((hour) (half_hour))))",
        "(declare-fun starts (Programs Time) Bool)"
      ],
      "constraints": [
        "(= (+ (to-int (starts Generations hour)) (to-int (starts Roamin' half_hour)) (to-int (starts Sundown half_hour)) (to-int (starts Terry half_hour)) (to-int (starts Waterloo half_hour))) 1)",
        "(forall ((p Programs) (t Time)) (=> (starts p t) (= (to-int (starts p t)) 1)))",
        "(forall ((p1 Programs) (p2 Programs)) (=> (and (starts p1 half_hour) (starts p2 hour)) (distinct p1 p2)))",
        "(forall ((p1 Programs) (p2 Programs)) (=> (and (starts p1 hour) (starts p2 half_hour)) (distinct p1 p2)))",
        "(forall ((p1 Programs) (p2 Programs)) (=> (and (starts p1 half_hour) (starts p2 half_hour)) (<= (to-int (starts p1 half_hour)) (to-int (starts p2 half_hour)))))",
        "(forall ((p1 Programs) (p2 Programs)) (=> (and (starts p1 half_hour) (starts p2 half_hour)) (=> (< (to-int (starts p1 half_hour)) (to-int (starts p2 half_hour))) (ite (< (to-int (starts Waterloo half_hour)) (to-int (starts Terry half_hour))) (= (starts p1 half_hour) (ite (< (to-int (starts Waterloo half_hour)) (to-int (starts Terry half_hour))) (starts Waterloo half_hour) (starts Terry half_hour))) (distinct p1 p2))))))",
        "(forall ((p Programs)) (=> (= (starts Sundown half_hour) t3) (or (= (starts Generations hour) t1) (= (starts Roamin' half_hour) t1) (= (starts Roamin' half_hour) t2) (= (starts Terry half_hour) t5) (= (starts Waterloo half_hour) t4))))",
        "(= t1 0)",
        "(= t2 1)",
        "(= t3 2)",
        "(= t4 3)",
        "(= t5 4)"
      ],
      "options": [
        "(= t3 2)",
        "(= t3 3)",
        "(= t3 4)"
      ],
      "type": "unsat",
      "perplexity": [
        1.1843926906585693,
        1.092002272605896
      ],
      "answer": "E",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "No Output"
    }
  },
  {
    "id": 90,
    "nl_problem": {
      "context": "A television programming director is scheduling a three-hour block of programs beginning at 1 P.M. The programs that are to fill this time block include an hour-long program called Generations and four half-hour programs: Roamin', Sundown, Terry, and Waterloo. The programs will be shown one after the other, each program shown exactly once. The schedule must meet the following constraints: Generations starts on the hour rather than the half hour. Terry starts on the half hour rather than the hour. Roamin' is shown earlier than Sundown. If Waterloo is shown earlier than Terry, it is shown immediately before Terry.",
      "question": "If Generations is the third program, then which one of the following could be true?",
      "options": [
        "A) Roamin' is the second program.",
        "B) Roamin' is the fifth program.",
        "C) Sundown is the fourth program.",
        "D) Terry is the fourth program.",
        "E) Waterloo is the second program."
      ]
    },
    "answer": "C",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((Time 0)) (((hour0) (half0) (hour1) (half1) (hour2) (half2) (hour3) (half3))))",
        "(declare-datatypes ((Programs 0)) (((Generations) (Roamin) (Sundown) (Terry) (Waterloo))))",
        "(declare-fun at (Time Time) Bool)",
        "(declare-fun next (Time Time) Bool)",
        "(declare-fun schedule (Time Programs) Bool)",
        "(define-fun start-hour (t Time) Time (ite (= t hour0) hour0 (ite (= t hour1) hour1 (ite (= t hour2) hour2 hour3))))",
        "(define-fun start-half (t Time) Time (ite (= t half0) half0 (ite (= t half1) half1 (ite (= t half2) half2 half3))))",
        "(define-fun end-hour (t Time) Time (ite (= t hour0) hour1 (ite (= t hour1) hour2 (ite (= t hour2) hour3 hour3))))",
        "(define-fun end-half (t Time) Time (ite (= t half0) half1 (ite (= t half1) half2 (ite (= t half2) half3 half3))))",
        "(define-fun third-program (t Time) Bool (and (at t Generations) (= (start-half t) half2)))",
        "(define-fun second-program (t Time) Bool (and (not (at t Generations)) (not (at t Terry)) (at t Roamin)))",
        "(define-fun fourth-program (t Time) Bool (and (not (at t Generations)) (not (at t Terry)) (at t Sundown)))",
        "(define-fun fifth-program (t Time) Bool (and (not (at t Generations)) (not (at t Terry)) (at t Waterloo)))",
        "(define-fun option-a (t Time) Bool (and (third-program t) (second-program t)))",
        "(define-fun option-b (t Time) Bool (and (third-program t) (not (second-program t) ) (at t Roamin)))",
        "(define-fun option-c (t Time) Bool (and (third-program t) (at t Sundown)))",
        "(define-fun option-d (t Time) Bool (and (third-program t) (at t Terry)))",
        "(define-fun option-e (t Time) Bool (and (third-program t) (at t Waterloo)))"
      ],
      "constraints": [
        "(forall ((t Time) (p Programs)) (= (at t p) (schedule t p)))",
        "(forall ((t1 Time) (t2 Time) (p Programs)) (=> (next t1 t2) (not (= (at t1 p) (at t2 p)))))",
        "(forall ((p Programs)) (=> (not (at half0 p)) (not (at half1 p))))",
        "(forall ((p Programs)) (=> (not (at half2 p)) (not (at half3 p))))",
        "(forall ((p Programs)) (=> (= (at hour0 p) (at hour1 p)) (not (at half0 p))))",
        "(forall ((p Programs)) (=> (= (at hour1 p) (at hour2 p)) (not (at half1 p))))",
        "(forall ((p Programs)) (=> (= (at hour2 p) (at hour3 p)) (not (at half2 p))))",
        "(forall ((p Programs)) (=> (= (at hour0 p) (at hour3 p)) (not (at half3 p))))",
        "(forall ((p Programs)) (=> (= (at hour0 p) (at half1 p)) (not (at hour1 p))))",
        "(forall ((p Programs)) (=> (= (at hour1 p) (at half2 p)) (not (at hour2 p))))",
        "(forall ((p Programs)) (=> (= (at hour2 p) (at half3 p)) (not (at hour3 p))))",
        "(forall ((p Programs)) (=> (= (at half0 p) (at hour1 p)) (not (at hour0 p))))",
        "(forall ((p Programs)) (=> (= (at half1 p) (at hour2 p)) (not (at hour1 p))))",
        "(forall ((p Programs)) (=> (= (at half2 p) (at hour3 p)) (not (at hour2 p))))",
        "(forall ((p Programs)) (=> (= (at half0 p) (at half2 p)) (not (at hour0 p))))",
        "(forall ((p Programs)) (=> (= (at half1 p) (at half3 p)) (not (at hour1 p))))",
        "(forall ((p Programs)) (=> (= (at half2 p) (at half3 p)) (not (at hour2 p))))",
        "(forall ((t Time)) (not (next t t)))",
        "(forall ((t Time) (p Programs)) (=> (next t hour0) (= t half0)))",
        "(forall ((t Time) (p Programs)) (=> (next t half0) (= t hour0)))",
        "(forall ((t Time) (p Programs)) (=> (next t hour1) (= t half1)))",
        "(forall ((t Time) (p Programs)) (=> (next t half1) (= t hour1)))",
        "(forall ((t Time) (p Programs)) (=> (next t hour2) (= t half2)))",
        "(forall ((t Time) (p Programs)) (=> (next t half2) (= t hour2)))",
        "(forall ((t Time) (p Programs)) (=> (next t hour3) (= t half3)))",
        "(forall ((t Time) (p Programs)) (=> (next t half3) (= t hour3)))",
        "(forall ((t Time) (p Programs)) (=> (next t half0) (= t hour1)))",
        "(forall ((t Time) (p Programs)) (=> (next t half1) (= t hour2)))",
        "(forall ((t Time) (p Programs)) (=> (next t half2) (= t hour3)))",
        "(forall ((t Time) (p Programs)) (=> (next t half3) (= t hour0)))",
        "(forall ((p Programs)) (=> (at half0 Generations) (at half1 Generations)))",
        "(forall ((p Programs)) (=> (at half1 Generations) (not (at half0 Generations))))",
        "(forall ((p Programs)) (=> (at half0 Terry) (at half1 Terry)))",
        "(forall ((p Programs)) (=> (at half1 Terry) (not (at half0 Terry))))",
        "(forall ((p Programs)) (=> (and (at hour0 Roamin) (at half1 Roamin)) (and (at hour0 Sundown) (at half1 Sundown))))",
        "(forall ((p Programs)) (=> (and (at hour1 Roamin) (at half2 Roamin)) (and (at hour1 Sundown) (at half2 Sundown))))",
        "(forall ((p Programs)) (=> (and (at hour2 Roamin) (at half3 Roamin)) (and (at hour2 Sundown) (at half3 Sundown))))",
        "(forall ((p Programs)) (=> (and (at hour0 Waterloo) (at half1 Terry)) (at half0 Terry)))",
        "(forall ((p Programs)) (=> (and (at hour1 Waterloo) (at half2 Terry)) (at half1 Terry)))",
        "(forall ((p Programs)) (=> (and (at hour2 Waterloo) (at half3 Terry)) (at half2 Terry)))"
      ],
      "options": [
        "(assert (third-program hour2))",
        "(assert (option-a hour2))",
        "(assert (third-program hour2))",
        "(assert (option-b hour2))",
        "(assert (third-program hour2))",
        "(assert (option-c hour2))",
        "(assert (third-program hour2))",
        "(assert (option-d hour2))",
        "(assert (third-program hour2))",
        "(assert (option-e hour2))"
      ],
      "type": "unsat",
      "perplexity": [
        1.2137129306793213,
        1.0257850885391235
      ],
      "answer": "C",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "No Output"
    }
  },
  {
    "id": 91,
    "nl_problem": {
      "context": "A television programming director is scheduling a three-hour block of programs beginning at 1 P.M. The programs that are to fill this time block include an hour-long program called Generations and four half-hour programs: Roamin', Sundown, Terry, and Waterloo. The programs will be shown one after the other, each program shown exactly once. The schedule must meet the following constraints: Generations starts on the hour rather than the half hour. Terry starts on the half hour rather than the hour. Roamin' is shown earlier than Sundown. If Waterloo is shown earlier than Terry, it is shown immediately before Terry.",
      "question": "Which one of the following CANNOT be true?",
      "options": [
        "A) Sundown is shown immediately before Generations.",
        "B) Waterloo is shown immediately before Roamin'.",
        "C) Generations is shown immediately before Sundown.",
        "D) Roamin' is shown immediately before Terry.",
        "E) Terry is shown immediately before Waterloo."
      ]
    },
    "answer": "B",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((Programming_Director 0)) (((Television_Programming_Director))))",
        "(declare-datatypes ((Programs 0)) (((Generations) (Roamin_) (Sundown) (Terry) (Waterloo))))",
        "(declare-datatypes ((Time_Block 0)) (((One_PM) (Two_PM) (Three_PM)))",
        "(declare-fun scheduled (Time_Block Programs) Bool)"
      ],
      "constraints": [
        "(define-fun Generations_start_on_hour () Bool (and (scheduled One_PM Generations) (not (scheduled Two_PM Generations))))",
        "(define-fun Terry_start_on_half_hour () Bool (and (scheduled Two_PM Terry) (not (scheduled One_PM Terry))))",
        "(define-fun Roamin_before_Sundown () Bool (and (scheduled One_PM Roamin_) (scheduled Three_PM Sundown) (or (scheduled Two_PM Sundown) (not (scheduled Two_PM Sundown)))))",
        "(define-fun Waterloo_before_Terry () Bool (and (scheduled One_PM Waterloo) (scheduled Two_PM Terry) (not (scheduled One_PM Terry))))"
      ],
      "options": [
        "(define-fun Sundown_before_Generations () Bool (and (scheduled Three_PM Sundown) (scheduled Two_PM Generations)))",
        "(define-fun Waterloo_before_Roamin () Bool (and (scheduled One_PM Waterloo) (scheduled Two_PM Roamin_)))",
        "(define-fun Generations_before_Sundown () Bool (and (scheduled Two_PM Generations) (scheduled Three_PM Sundown)))",
        "(define-fun Roamin_before_Terry () Bool (and (scheduled Two_PM Roamin_) (scheduled Three_PM Terry)))",
        "(define-fun Terry_before_Waterloo () Bool (and (scheduled Two_PM Terry) (scheduled One_PM Waterloo)))"
      ],
      "type": "unsat",
      "perplexity": [
        1.3023808002471924,
        1.0998798608779907
      ],
      "answer": "B",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "No Output"
    }
  },
  {
    "id": 92,
    "nl_problem": {
      "context": "A television programming director is scheduling a three-hour block of programs beginning at 1 P.M. The programs that are to fill this time block include an hour-long program called Generations and four half-hour programs: Roamin', Sundown, Terry, and Waterloo. The programs will be shown one after the other, each program shown exactly once. The schedule must meet the following constraints: Generations starts on the hour rather than the half hour. Terry starts on the half hour rather than the hour. Roamin' is shown earlier than Sundown. If Waterloo is shown earlier than Terry, it is shown immediately before Terry.",
      "question": "Which one of the following, if substituted for the constraint that Generations starts on the hour rather than the half hour, would have the same effect in determining the order in which the programs are shown?",
      "options": [
        "A) Generations is not shown immediately before Terry.",
        "B) Generations is either the first program or the fifth.",
        "C) Generations is neither the second program nor the fourth.",
        "D) If Generations is shown third, then Roamin' is shown first.",
        "E) If Generations is not shown first, then it is shown later than Terry."
      ]
    },
    "answer": "C",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((Programs 0)) (((Generations) (Roamin') (Sundown) (Terry) (Waterloo))))",
        "(declare-datatypes ((TimeSlots 0)) (((hour1) (half1) (hour2) (half2) (hour3) (hour5))))",
        "(declare-fun starts (Programs TimeSlots) Bool)",
        "(define-fun to-int ((b Bool)) Int (ite b 1 0))"
      ],
      "constraints": [
        "(forall ((p Programs) (t TimeSlots)) (=> (starts p t) (or (= t hour1) (= t half1) (= t hour2) (= t half2) (= t hour3) (= t hour5))))",
        "(=> (starts Generations hour1) true)",
        "(=> (starts Terry half1) true)",
        "(=> (starts Roamin' half1) (starts Sundown half2))",
        "(=> (and (starts Waterloo half1) (starts Terry hour1)) (starts Waterloo hour2))"
      ],
      "options": [
        "(forall ((t TimeSlots)) (=> (and (starts Generations t) (starts Terry t)) false))",
        "(forall ((t TimeSlots)) (=> (starts Generations t) (or (= t hour1) (= t hour5))))",
        "(forall ((t TimeSlots)) (=> (starts Generations t) (not (and (starts Generations hour2) (starts Generations half4)))))",
        "(=> (starts Generations half3) (starts Roamin' half1))",
        "(=> (starts Generations hour1) (or (starts Terry hour2) (not (starts Generations hour1))))"
      ],
      "type": "sat",
      "perplexity": [
        1.2406469583511353,
        1.1003648042678833
      ],
      "answer": "C",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "No Output"
    }
  },
  {
    "id": 93,
    "nl_problem": {
      "context": "Five students—Manolo, Nadia, Owen, Peng, and Rana—are each to deliver exactly one speech. Speeches are on exactly one of two topics—friendship and liberty. Each student has only one major: two major in geology, two in history, and one in journalism. The following conditions must apply: Exactly two of the students speak on friendship. A geology major and a history major speak on friendship. Manolo speaks on friendship. Rana speaks on liberty. Neither Peng nor Rana is a geology major. Nadia is a geology major.",
      "question": "Which one of the following could be a list of the majors of Manolo, Nadia, Owen, Peng, and Rana, respectively?",
      "options": [
        "A) geology, geology, journalism, journalism, history",
        "B) geology, geology, history, history, history",
        "C) history, geology, geology, journalism, history",
        "D) history, geology, journalism, geology, history",
        "E) history, history, geology, journalism, history"
      ]
    },
    "answer": "C",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((People 0)) (((Manolo) (Nadia) (Owen) (Peng) (Rana))))",
        "(declare-datatypes ((Topics 0)) (((friendship) (liberty))))",
        "(declare-datatypes ((Majors 0)) (((geology) (history) (journalism))))",
        "(declare-fun speaks_on (People Topics) Bool)",
        "(declare-fun major (People) Majors)",
        "(define-fun to-int ((b Bool)) Int (ite b 1 0))",
        "(define-fun is-geology-major ((p People)) Bool (= (major p) geology))",
        "(define-fun is-history-major ((p People)) Bool (= (major p) history))",
        "(define-fun is-journalism-major ((p People)) Bool (= (major p) journalism))"
      ],
      "constraints": [
        "(forall ((t Topics)) (not (= (speaks_on Manolo t) (speaks_on Nadia t))))",
        "(forall ((p People) (t Topics)) (<= (+ (ite (= (speaks_on p t) friendship) 1 0) (ite (= (speaks_on p t) liberty) 1 0)) 1))",
        "(forall ((p People)) (or (= (speaks_on p friendship) true) (= (speaks_on p liberty) true)))",
        "(and (= (speaks_on Manolo friendship) true) (= (+ (to-int (and (is-geology-major Nadia) (speaks_on Nadia friendship))) (to-int (and (is-geology-major Owen) (speaks_on Owen friendship))) (to-int (and (is-geology-major Peng) (speaks_on Peng friendship))) (to-int (and (is-geology-major Rana) (speaks_on Rana friendship)))) 1) (= (+ (to-int (and (is-geology-major Manolo) (speaks_on Manolo friendship))) (to-int (and (is-geology-major Nadia) (speaks_on Nadia friendship))) (to-int (and (is-geology-major Owen) (speaks_on Owen friendship))) (to-int (and (is-geology-major Peng) (speaks_on Peng friendship))) (to-int (and (is-geology-major Rana) (speaks_on Rana friendship)))) 2))",
        "(and (is-geology-major Nadia) (is-geology-major Owen) (= (speaks_on Nadia friendship) true) (= (speaks_on Owen friendship) true))",
        "(= (major Rana) journalism) (= (speaks_on Rana liberty) true)",
        "(forall ((p People)) (not (and (is-geology-major p) (= (speaks_on p liberty) true))))",
        "(forall ((p People)) (not (and (major p) (major p))))"
      ],
      "options": [
        "(not (= (major Manolo) history)) (= (major Nadia) geology) (= (major Owen) geology) (= (major Peng) journalism) (= (major Rana) journalism))",
        "(not (= (major Manolo) history)) (= (major Nadia) geology) (= (major Owen) geology) (= (major Peng) journalism) (= (major Rana) history))",
        "(= (major Manolo) history) (= (major Nadia) geology) (= (major Owen) geology) (= (major Peng) journalism) (= (major Rana) history))",
        "(= (major Manolo) history) (= (major Nadia) geology) (= (major Owen) journalism) (= (major Peng) geology) (= (major Rana) history))",
        "(= (major Manolo) history) (= (major Nadia) geology) (= (major Owen) geology) (= (major Peng) journalism) (= (major Rana) history))"
      ],
      "type": "sat",
      "perplexity": [
        1.1077028512954712,
        1.0414918661117554
      ],
      "answer": "C",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "No Output"
    }
  },
  {
    "id": 94,
    "nl_problem": {
      "context": "Five students—Manolo, Nadia, Owen, Peng, and Rana—are each to deliver exactly one speech. Speeches are on exactly one of two topics—friendship and liberty. Each student has only one major: two major in geology, two in history, and one in journalism. The following conditions must apply: Exactly two of the students speak on friendship. A geology major and a history major speak on friendship. Manolo speaks on friendship. Rana speaks on liberty. Neither Peng nor Rana is a geology major. Nadia is a geology major.",
      "question": "If Peng speaks on friendship, then which one of the following could be true?",
      "options": [
        "A) Manolo is a history major.",
        "B) Nadia speaks on friendship.",
        "C) Owen speaks on friendship.",
        "D) Owen is a journalism major.",
        "E) Peng is a journalism major."
      ]
    },
    "answer": "D"
  },
  {
    "id": 95,
    "nl_problem": {
      "context": "Five students—Manolo, Nadia, Owen, Peng, and Rana—are each to deliver exactly one speech. Speeches are on exactly one of two topics—friendship and liberty. Each student has only one major: two major in geology, two in history, and one in journalism. The following conditions must apply: Exactly two of the students speak on friendship. A geology major and a history major speak on friendship. Manolo speaks on friendship. Rana speaks on liberty. Neither Peng nor Rana is a geology major. Nadia is a geology major.",
      "question": "If Owen is a geology major who speaks on friendship, then which one of the following must be true?",
      "options": [
        "A) Manolo is a history major.",
        "B) Nadia speaks on friendship.",
        "C) Peng speaks on friendship.",
        "D) Peng is a history major.",
        "E) Rana is a journalism major."
      ]
    },
    "answer": "A",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((Students 0)) (((Manolo) (Nadia) (Owen) (Peng) (Rana))))",
        "(declare-datatypes ((Topics 0)) (((friendship) (liberty))))",
        "(declare-datatypes ((Majors 0)) (((geology) (history) (journalism))))",
        "(declare-fun speaks (Students Topics) Bool)",
        "(declare-fun is_geology_major (Students) Bool)",
        "(declare-fun is_history_major (Students) Bool)",
        "(declare-fun is_journalism_major (Students) Bool)",
        "(define-fun to-int ((b Bool)) Int (ite b 1 0))"
      ],
      "constraints": [
        "(forall ((t Topics)) (not (= (speaks Manolo t) (speaks Nadia t))))",
        "(forall ((t Topics)) (not (= (speaks Peng t) (speaks Rana t))))",
        "(forall ((p Students)) (or (= (is_geology_major p) true) (= (is_history_major p) true) (= (is_journalism_major p) true)))",
        "(forall ((m Majors)) (= (to-int (or (= (is_geology_major Manolo) true) (= (is_history_major Manolo) true))) 1))",
        "(forall ((m Majors)) (= (to-int (or (= (is_geology_major Nadia) true) (= (is_history_major Nadia) true))) 2))",
        "(forall ((m Majors)) (= (to-int (or (= (is_geology_major Peng) true) (= (is_history_major Peng) true))) 2))",
        "(forall ((m Majors)) (= (to-int (or (= (is_geology_major Rana) true) (= (is_history_major Rana) true))) 1))",
        "(forall ((m Majors)) (= (to-int (or (= (is_geology_major Owen) true) (= (is_history_major Owen) true))) 1))",
        "(forall ((t Topics)) (>= (+ (to-int (speaks Manolo t)) (to-int (speaks Nadia t)) (to-int (speaks Peng t)) (to-int (speaks Rana t))) 2))",
        "(forall ((t Topics)) (= (to-int (and (is_geology_major Manolo) (speaks Manolo t))) (to-int (and (is_history_major Nadia) (speaks Nadia t)))))",
        "(= (speaks Manolo friendship) true)",
        "(= (speaks Rana liberty) true)",
        "(forall ((t Topics)) (not (= (speaks Peng t) true)))",
        "(= (is_geology_major Nadia) true)",
        "(forall ((t Topics)) (=> (and (is_geology_major Owen) (speaks Owen friendship)) (or (= (speaks Manolo t) true) (= (speaks Nadia t) true) (= (speaks Peng t) true) (= (speaks Rana t) true))))"
      ],
      "options": [
        "(forall ((t Topics)) (= (or (= (speaks Manolo t) true) (= (speaks Nadia t) true) (= (speaks Peng t) true)) (= (and (is_geology_major Owen) (speaks Owen t)))))",
        "(forall ((t Topics)) (= (or (= (speaks Manolo t) true) (= (speaks Nadia t) true) (= (speaks Peng t) true)) (= (or (= (is_geology_major Owen) true) (= (is_history_major Owen) true)))))",
        "(forall ((t Topics)) (= (or (= (speaks Manolo t) true) (= (speaks Nadia t) true) (= (speaks Peng t) true)) (= (is_history_major Peng) true)))",
        "(forall ((t Topics)) (= (or (= (speaks Manolo t) true) (= (speaks Nadia t) true) (= (speaks Peng t) true)) (= (is_geology_major Peng) true)))",
        "(forall ((t Topics)) (= (or (= (speaks Manolo t) true) (= (speaks Nadia t) true) (= (speaks Peng t) true)) (= (is_journalism_major Rana) true)))"
      ],
      "type": "sat",
      "perplexity": [
        1.117304801940918,
        1.0393825769424438
      ],
      "answer": "A",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "No Output"
    }
  },
  {
    "id": 96,
    "nl_problem": {
      "context": "Five students—Manolo, Nadia, Owen, Peng, and Rana—are each to deliver exactly one speech. Speeches are on exactly one of two topics—friendship and liberty. Each student has only one major: two major in geology, two in history, and one in journalism. The following conditions must apply: Exactly two of the students speak on friendship. A geology major and a history major speak on friendship. Manolo speaks on friendship. Rana speaks on liberty. Neither Peng nor Rana is a geology major. Nadia is a geology major.",
      "question": "If Nadia speaks on friendship, then which one of the following must be false?",
      "options": [
        "A) Manolo is a geology major.",
        "B) Manolo is a history major.",
        "C) Owen is a geology major.",
        "D) Peng is a history major.",
        "E) Rana is a history major."
      ]
    },
    "answer": "A",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((Students 0)) (((Manolo) (Nadia) (Owen) (Peng) (Rana))))",
        "(declare-datatypes ((Topics 0)) (((friendship) (liberty))))",
        "(declare-datatypes ((Majors 0)) (((geology) (history) (journalism))))",
        "(declare-fun speaks (Students Topics) Bool)",
        "(declare-fun major (Students Majors) Bool)"
      ],
      "constraints": [
        "(forall ((s Students) (t Topics)) (< (+ (ite (speaks s friendship) 1 0) (ite (speaks s liberty) 1 0)) 2))",
        "((ite (speaks Manolo friendship) 1 0) + (ite (speaks Nadia friendship) 1 0) + (ite (speaks Owen friendship) 1 0) + (ite (speaks Peng friendship) 1 0) + (ite (speaks Rana friendship) 1 0) = 2)",
        "((or (and (major Manolo geology) (major Nadia history)) (and (major Nadia geology) (major Manolo history)) (and (major Nadia geology) (major Owen history)) (and (major Nadia geology) (major Peng history)) (and (major Nadia geology) (major Rana history))) => (and (speaks Manolo friendship) (speaks Nadia friendship)))",
        "(speaks Manolo friendship)",
        "(speaks Rana liberty)",
        "(not (major Peng geology))",
        "(not (major Rana geology))",
        "(major Nadia geology)"
      ],
      "options": [
        "((not (major Manolo geology)) => (speaks Nadia friendship))",
        "((not (major Manolo history)) => (speaks Nadia friendship))",
        "((not (major Owen geology)) => (speaks Nadia friendship))",
        "((not (major Peng history)) => (speaks Nadia friendship))",
        "((not (major Rana history)) => (speaks Nadia friendship))"
      ],
      "type": "sat",
      "perplexity": [
        1.1253153085708618,
        1.1108005046844482
      ],
      "answer": "A",
      "predicted_answer": [
        "sat",
        "sat",
        "sat",
        "sat",
        "sat"
      ],
      "status": "success",
      "error": ""
    }
  },
  {
    "id": 97,
    "nl_problem": {
      "context": "Five students—Manolo, Nadia, Owen, Peng, and Rana—are each to deliver exactly one speech. Speeches are on exactly one of two topics—friendship and liberty. Each student has only one major: two major in geology, two in history, and one in journalism. The following conditions must apply: Exactly two of the students speak on friendship. A geology major and a history major speak on friendship. Manolo speaks on friendship. Rana speaks on liberty. Neither Peng nor Rana is a geology major. Nadia is a geology major.",
      "question": "Rana must be a journalism major if which one of the following is true?",
      "options": [
        "A) Manolo is a geology major and Peng is a history major.",
        "B) Owen is a geology major and Manolo is a history major.",
        "C) Owen is a geology major and Peng is a history major.",
        "D) Both Manolo and Nadia speak on friendship.",
        "E) Both Manolo and Peng speak on friendship."
      ]
    },
    "answer": "C",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((Students 0)) (((Manolo) (Nadia) (Owen) (Peng) (Rana))))",
        "(declare-datatypes ((Topics 0)) (((friendship) (liberty))))",
        "(declare-datatypes ((Majors 0)) (((geology) (history) (journalism))))",
        "(declare-fun speaks (Students Topics) Bool)",
        "(declare-fun major (Students Majors) Bool)",
        "(define-fun to-int ((b Bool)) Int (ite b 1 0))"
      ],
      "constraints": [
        "(forall ((s Students)) (= (to-int (speaks s friendship)) (to-int (speaks s liberty)) 1))",
        "(and (and (speaks Manolo friendship) (= (to-int (and (major Manolo geology) (major _ history))) 1)) (= (to-int (and (major Manolo geology) (major Nadia history))) 1))",
        "(= (to-int (or (and (major Manolo geology) (major _ history)) (and (major Manolo geology) (major Nadia history)) (and (major Manolo geology) (major Nadia history)) (and (major Manolo geology) (major Nadia history)))) 1)",
        "(and (speaks Manolo friendship) (speaks Rana liberty))",
        "(forall ((s Students)) (=> (major s geology) (not (major s liberty))))",
        "(forall ((s Students)) (=> (major s geology) (not (major s Rana))))",
        "(= (major Nadia geology) 1)"
      ],
      "options": [
        "(and (major Owen geology) (major Manolo history))",
        "(= (major Rana journalism) 1)"
      ],
      "type": "sat",
      "perplexity": [
        1.2107324600219727,
        1.1253409385681152
      ],
      "answer": "C",
      "predicted_answer": [
        "sat",
        "sat"
      ],
      "status": "success",
      "error": ""
    }
  },
  {
    "id": 98,
    "nl_problem": {
      "context": "Each of exactly seven professors—Powell, Shihab, Taylor, Vaughan, Wood, Young, and Zabel—gives exactly one guest lecture in the literary theory course. The lectures are ordered from first through seventh, and their order must conform to the following: Powell lectures before Wood. Taylor lectures before Shihab. Vaughan lectures before Zabel. Shihab is no later than third. Young is not seventh. Powell lectures first if, but only if, Young lectures before Vaughan.",
      "question": "Which one of the following could be the order in which the professors lecture, from first to last?",
      "options": [
        "A) Powell, Young, Taylor, Shihab, Vaughan, Zabel, Wood",
        "B) Taylor, Powell, Shihab, Wood, Vaughan, Young, Zabel",
        "C) Taylor, Vaughan, Shihab, Wood, Powell, Young, Zabel",
        "D) Vaughan, Taylor, Shihab, Powell, Wood, Zabel, Young",
        "E) Young, Taylor, Shihab, Powell, Vaughan, Zabel, Wood"
      ]
    },
    "answer": "B",
    "logic_problem": {
      "perplexity": [
        1.1632986068725586,
        275772.71875
      ],
      "answer": "B",
      "predicted_answer": "N/A",
      "status": "parsing error",
      "error": ""
    }
  },
  {
    "id": 99,
    "nl_problem": {
      "context": "Each of exactly seven professors—Powell, Shihab, Taylor, Vaughan, Wood, Young, and Zabel—gives exactly one guest lecture in the literary theory course. The lectures are ordered from first through seventh, and their order must conform to the following: Powell lectures before Wood. Taylor lectures before Shihab. Vaughan lectures before Zabel. Shihab is no later than third. Young is not seventh. Powell lectures first if, but only if, Young lectures before Vaughan.",
      "question": "Which one of the following could lecture first?",
      "options": [
        "A) Shihab",
        "B) Vaughan",
        "C) Wood",
        "D) Young",
        "E) Zabel"
      ]
    },
    "answer": "B",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((Professors 0)) (((Powell) (Shihab) (Taylor) (Vaughan) (Wood) (Young) (Zabel))))",
        "(declare-fun lectures_before (Professors Professors) Bool)",
        "(define-fun first ((p Professors)) Int (ite (distinct p Powell) 1 0))",
        "(define-fun lecture_order (i Int) (Professors) (ite (> i 7) (error \"Invalid lecture order\") (ite (< i 7) (ite (distinct i 1) Powell (ite (distinct i 2) Taylor (ite (distinct i 3) Vaughan (ite (distinct i 4) Wood (ite (distinct i 5) Young Zabel)))) (error \"Invalid lecture order\"))))",
        "(define-fun position (p Professors) Int (ite (distinct p Powell) 1 (ite (distinct p Taylor) 2 (ite (distinct p Vaughan) 3 (ite (distinct p Wood) 4 (ite (distinct p Young) 5 6)))))",
        "(define-fun pos_before (i Int j Int) Bool (ite (>= i j) (ite (> i j) true false) (ite (>= i 7) true false)))"
      ],
      "constraints": [
        "(forall ((p1 Professors) (p2 Professors)) (= (lectures_before p1 p2) (or (= (position p1 1) 1) (= (position p2 1) 1) (and (lectures_before p1 p2) (distinct (position p1 1) (position p2 1)) (not (distinct (position p1 1) 7))))) )",
        "(forall ((i Int)) (=> (< i 3) (not (distinct (position Shihab i) 7))))",
        "(forall ((i Int)) (=> (distinct i 7) (not (= (position Young i) 7))))",
        "(forall ((p Professors) (i Int)) (=> (and (= (position p i) 1) (= (position Young 1) 1) (= (position Vaughan 1) 1)) (= (position Young 1) 1)))"
      ],
      "options": [
        "(forall ((p Professors)) (= (first p) (ite (= p Powell) 1 (ite (= p Taylor) 2 (ite (= p Vaughan) 3 (ite (= p Wood) 4 (ite (= p Young) 5 Zabel)))))))"
      ],
      "type": "unsat",
      "perplexity": [
        1.373666524887085,
        1.0717120170593262
      ],
      "answer": "B",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "No Output"
    }
  },
  {
    "id": 100,
    "nl_problem": {
      "context": "Each of exactly seven professors—Powell, Shihab, Taylor, Vaughan, Wood, Young, and Zabel—gives exactly one guest lecture in the literary theory course. The lectures are ordered from first through seventh, and their order must conform to the following: Powell lectures before Wood. Taylor lectures before Shihab. Vaughan lectures before Zabel. Shihab is no later than third. Young is not seventh. Powell lectures first if, but only if, Young lectures before Vaughan.",
      "question": "Which one of the following CANNOT given the second guest lecture?",
      "options": [
        "A) Powell",
        "B) Shihab",
        "C) Taylor",
        "D) Vaughan",
        "E) Wood"
      ]
    },
    "answer": "E",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((Professors 0)) (((Powell) (Shihab) (Taylor) (Vaughan) (Wood) (Young) (Zabel))))",
        "(declare-datatypes ((Lectures 0)) (((first) (second) (third) (fourth) (fifth) (sixth) (seventh))))",
        "(declare-fun lectures (Professors Lectures) Bool)",
        "(define-fun to-int ((b Bool)) Int (ite b 1 0))",
        "(declare-fun rank ((Professors)) Int)",
        "(define-fun rank-expr ((p Professors)) Int (ite (and (lectures p first) (not (lectures p second))) 0 (ite (and (lectures p second) (not (lectures p third))) 1 (ite (and (lectures p third) (not (lectures p fourth))) 2 (ite (and (lectures p fourth) (not (lectures p fifth))) 3 (ite (and (lectures p fifth) (not (lectures p sixth))) 4 (ite (and (lectures p sixth) (not (lectures p seventh))) 5 6)))))))",
        "(declare-fun is-late ((Professors)) Bool)",
        "(define-fun is-late-expr ((p Professors)) Bool (and (lectures p first) (>= (rank p) (rank (Young)))))",
        "(declare-fun is-shihab-late ((Professors)) Bool)",
        "(define-fun is-shihab-late-expr ((p Professors)) Bool (and (lectures p third) (>= (rank p) 2)))",
        "(declare-fun is-young-not-seventh ((Professors)) Bool)",
        "(define-fun is-young-not-seventh-expr ((p Professors)) Bool (not (and (lectures p seventh) (= (rank p) 5))))",
        "(declare-fun is-powell-first ((Professors)) Bool)",
        "(define-fun is-powell-first-expr ((p Professors)) Bool (and (lectures p first) (and (lectures p second) (and (not (lectures p third)) (and (lectures p fourth) (and (lectures p fifth) (and (not (lectures p sixth)) (not (lectures p seventh)))))))))",
        "(declare-fun is-young-before-vaughan ((Professors)) Bool)",
        "(define-fun is-young-before-vaughan-expr ((p Professors)) Bool (and (lectures p second) (lectures p fourth)))",
        "(declare-fun can-powell-give-second-lecture ((Professors)) Bool)",
        "(define-fun can-powell-give-second-lecture-expr ((p Professors)) Bool (ite (and (is-young-before-vaughan p) (is-powell-first-expr p)) true (ite (is-shihab-late-expr p) (ite (is-young-not-seventh-expr p) true false) false)))",
        "(declare-fun can-shihab-give-second-lecture ((Professors)) Bool)",
        "(define-fun can-shihab-give-second-lecture-expr ((p Professors)) Bool (ite (is-shihab-late-expr p) (ite (is-young-not-seventh-expr p) true false) false))",
        "(declare-fun can-taylor-give-second-lecture ((Professors)) Bool)",
        "(define-fun can-taylor-give-second-lecture-expr ((p Professors)) Bool true)",
        "(declare-fun can-vaughan-give-second-lecture ((Professors)) Bool)",
        "(define-fun can-vaughan-give-second-lecture-expr ((p Professors)) Bool (ite (is-young-not-seventh-expr p) true false))",
        "(declare-fun can-wood-give-second-lecture ((Professors)) Bool)",
        "(define-fun can-wood-give-second-lecture-expr ((p Professors)) Bool true)",
        "(declare-fun can-powell-give-second-lecture-expr-alt ((Professors)) Bool)",
        "(define-fun can-powell-give-second-lecture-expr-alt ((p Professors)) Bool (ite (lectures p second) (ite (is-young-before-vaughan p) true false) false))",
        "(declare-fun can-shihab-give-second-lecture-expr-alt ((Professors)) Bool)",
        "(define-fun can-shihab-give-second-lecture-expr-alt ((p Professors)) Bool (ite (lectures p second) false true))",
        "(declare-fun can-taylor-give-second-lecture-expr-alt ((Professors)) Bool)",
        "(define-fun can-taylor-give-second-lecture-expr-alt ((p Professors)) Bool (ite (lectures p second) true false))",
        "(declare-fun can-vaughan-give-second-lecture-expr-alt ((Professors)) Bool)",
        "(define-fun can-vaughan-give-second-lecture-expr-alt ((p Professors)) Bool (ite (lectures p second) (ite (is-young-not-seventh-expr p) true false) false))",
        "(declare-fun can-wood-give-second-lecture-expr-alt ((Professors)) Bool)",
        "(define-fun can-wood-give-second-lecture-expr-alt ((p Professors)) Bool (ite (lectures p second) true false))"
      ],
      "constraints": [
        "(forall ((p Professors)) (= (cannot-give-second-lecture p) (not (can-powell-give-second-lecture-expr p))))",
        "(forall ((p Professors)) (= (cannot-give-second-lecture p) (not (and (not (can-powell-give-second-lecture-expr p)) (can-shihab-give-second-lecture-expr-alt p))))",
        "(forall ((p Professors)) (= (cannot-give-second-lecture p) (not (and (not (can-powell-give-second-lecture-expr p)) (can-taylor-give-second-lecture-expr-alt p))))",
        "(forall ((p Professors)) (= (cannot-give-second-lecture p) (not (and (not (can-powell-give-second-lecture-expr p)) (can-vaughan-give-second-lecture-expr-alt p))))",
        "(forall ((p Professors)) (= (cannot-give-second-lecture p) (not (and (not (can-powell-give-second-lecture-expr p)) (can-wood-give-second-lecture-expr-alt p))))"
      ],
      "options": [
        "(not (can-powell-give-second-lecture-expr Powell))",
        "(not (and (not (can-powell-give-second-lecture-expr Powell)) (can-shihab-give-second-lecture-expr-alt Powell)))",
        "(not (and (not (can-powell-give-second-lecture-expr Powell)) (can-taylor-give-second-lecture-expr-alt Powell)))",
        "(not (and (not (can-powell-give-second-lecture-expr Powell)) (can-vaughan-give-second-lecture-expr-alt Powell)))",
        "(not (and (not (can-powell-give-second-lecture-expr Powell)) (can-wood-give-second-lecture-expr-alt Powell)))"
      ],
      "type": "unsat",
      "perplexity": [
        1.170201063156128,
        1.0325058698654175
      ],
      "answer": "E",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "No Output"
    }
  },
  {
    "id": 101,
    "nl_problem": {
      "context": "Each of exactly seven professors—Powell, Shihab, Taylor, Vaughan, Wood, Young, and Zabel—gives exactly one guest lecture in the literary theory course. The lectures are ordered from first through seventh, and their order must conform to the following: Powell lectures before Wood. Taylor lectures before Shihab. Vaughan lectures before Zabel. Shihab is no later than third. Young is not seventh. Powell lectures first if, but only if, Young lectures before Vaughan.",
      "question": "If Shihab lectures second and Zabel lectures fourth, then which one of the following could be true?",
      "options": [
        "A) Powell lectures sixth",
        "B) Taylor lectures third",
        "C) Vaughan lectures fifth",
        "D) Wood lectures fifth",
        "E) Young lectures third"
      ]
    },
    "answer": "A"
  },
  {
    "id": 102,
    "nl_problem": {
      "context": "Each of exactly seven professors—Powell, Shihab, Taylor, Vaughan, Wood, Young, and Zabel—gives exactly one guest lecture in the literary theory course. The lectures are ordered from first through seventh, and their order must conform to the following: Powell lectures before Wood. Taylor lectures before Shihab. Vaughan lectures before Zabel. Shihab is no later than third. Young is not seventh. Powell lectures first if, but only if, Young lectures before Vaughan.",
      "question": "Which one of the following CANNOT be the guest lecture that Vaughan gives?",
      "options": [
        "A) second",
        "B) third",
        "C) fourth",
        "D) sixth",
        "E) seventh"
      ]
    },
    "answer": "E",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((Professors 0)) (((Powell) (Shihab) (Taylor) (Vaughan) (Wood) (Young) (Zabel))))",
        "(declare-fun guest_lecture (Professors) Int)"
      ],
      "constraints": [
        "(forall ((p Professors)) (not (= (guest_lecture p) (- (guest_lecture p)) )))",
        " (= (guest_lecture Powell) 0)",
        " (< (guest_lecture Wood) (guest_lecture Powell))",
        " (< (guest_lecture Taylor) (guest_lecture Shihab))",
        " (< (guest_lecture Vaughan) (guest_lecture Zabel))",
        " (or (< (guest_lecture Shihab) 3) (or (< (guest_lecture Shihab) 0) (<= (guest_lecture Shihab) 3)))",
        " (not (= (guest_lecture Young) 6))",
        " (let ((y (guest_lecture Young))) (and (ite (= y 0) (= (guest_lecture Vaughan) 1) false) (= (guest_lecture Vaughan) 1) (= y 0)))"
      ],
      "options": [
        " (= (guest_lecture Vaughan) 0)",
        " (= (guest_lecture Vaughan) 1)",
        " (= (guest_lecture Vaughan) 2)",
        " (= (guest_lecture Vaughan) 5)",
        " (= (guest_lecture Vaughan) 6)"
      ],
      "type": "unsat",
      "perplexity": [
        1.2103195190429688,
        1.1338543891906738
      ],
      "answer": "E",
      "predicted_answer": [
        "unsat",
        "unsat",
        "unsat",
        "unsat",
        "unsat"
      ],
      "status": "success",
      "error": ""
    }
  },
  {
    "id": 103,
    "nl_problem": {
      "context": "Each of exactly seven professors—Powell, Shihab, Taylor, Vaughan, Wood, Young, and Zabel—gives exactly one guest lecture in the literary theory course. The lectures are ordered from first through seventh, and their order must conform to the following: Powell lectures before Wood. Taylor lectures before Shihab. Vaughan lectures before Zabel. Shihab is no later than third. Young is not seventh. Powell lectures first if, but only if, Young lectures before Vaughan.",
      "question": "If Young lectures fourth and Taylor lectures first, then which one of the following must be true?",
      "options": [
        "A) Powell lectures no earlier than sixth",
        "B) Shihab lectures second.",
        "C) Vaughan lectures no later than third.",
        "D) Wood lectures seventh.",
        "E) Zabel lectures no earlier than sixth."
      ]
    },
    "answer": "E",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((Professors 0)) (((Powell) (Shihab) (Taylor) (Vaughan) (Wood) (Young) (Zabel))))",
        "(declare-datatypes ((LectureOrder 0)) (((first) (second) (third) (fourth) (fifth) (sixth) (seventh))))",
        "(declare-fun gives (Professors LectureOrder) Bool)",
        "(define-fun Powell-before-Wood ((t LectureOrder)) Bool (= t first (or (not (gives Young Vaughan)) (not (gives Young t)))))",
        "(define-fun Taylor-before-Shihab ((t LectureOrder)) Bool (= t first (not (= t third))))",
        "(define-fun Vaughan-before-Zabel ((t LectureOrder)) Bool (= t first))",
        "(define-fun Shihab-no-later-than-third ((t LectureOrder)) Bool (or (= t second) (= t third)))",
        "(define-fun Young-not-seventh ((t LectureOrder)) Bool (not (= t seventh)))",
        "(define-fun Powell-first-if-Young-before-Vaughan ((t LectureOrder)) Bool (and (Powell-before-Wood t) (gives Young Vaughan)))",
        "(define-fun Powell-first ((t LectureOrder)) Bool (and (Powell-before-Wood t) (not (gives Young Vaughan))))",
        "(define-fun Powell-no-earlier-than-sixth ((t LectureOrder)) Bool (not (Powell-first t)))",
        "(define-fun Shihab-lectures-second ((t LectureOrder)) Bool (= t second))",
        "(define-fun Vaughan-no-later-than-third ((t LectureOrder)) Bool (not (not (Vaughan-before-Zabel t))))",
        "(define-fun Wood-seventh ((t LectureOrder)) Bool (= t seventh))",
        "(define-fun Zabel-no-earlier-than-sixth ((t LectureOrder)) Bool (not (not (Vaughan-before-Zabel t))))",
        "(declare-fun Powell ((LectureOrder)) Bool)",
        "(declare-fun Shihab ((LectureOrder)) Bool)",
        "(declare-fun Taylor ((LectureOrder)) Bool)",
        "(declare-fun Vaughan ((LectureOrder)) Bool)",
        "(declare-fun Wood ((LectureOrder)) Bool)",
        "(declare-fun Young ((LectureOrder)) Bool)",
        "(declare-fun Zabel ((LectureOrder)) Bool)",
        "(define-fun Powell-first-if-young-before-vaughan-and-taylor-first ((t LectureOrder)) Bool (and (Powell-first t) (gives Young Vaughan) (gives Taylor first)))",
        "(define-fun Taylor-lectures-first ((t LectureOrder)) Bool (= t first))",
        "(define-fun Young-lectures-fourth ((t LectureOrder)) Bool (= t fourth))",
        "(define-fun Powell-no-earlier-than-sixth-if-taylor-first-and-young-fourth ((t LectureOrder)) Bool (and (Powell-first-if-young-before-vaughan-and-taylor-first t) (Young-lectures-fourth t)))"
      ],
      "constraints": [
        "(forall ((t LectureOrder)) (Powell-before-Wood t))",
        "(forall ((t LectureOrder)) (Taylor-before-Shihab t))",
        "(forall ((t LectureOrder)) (Vaughan-before-Zabel t))",
        "(forall ((t LectureOrder)) (Shihab-no-later-than-third t))",
        "(forall ((t LectureOrder)) (Young-not-seventh t))",
        "(forall ((t LectureOrder)) (Taylor-lectures-first t))",
        "(forall ((t LectureOrder)) (Young-lectures-fourth t))",
        "(not (Powell-no-earlier-than-sixth-if-taylor-first-and-young-fourth sixth))"
      ],
      "options": [
        "(forall ((t LectureOrder)) (Powell-no-earlier-than-sixth t))",
        "(forall ((t LectureOrder)) (Shihab-lectures-second t))",
        "(forall ((t LectureOrder)) (Vaughan-no-later-than-third t))",
        "(forall ((t LectureOrder)) (Wood-seventh t))",
        "(forall ((t LectureOrder)) (Zabel-no-earlier-than-sixth t))"
      ],
      "type": "unsat",
      "perplexity": [
        1.190329909324646,
        1.0456535816192627
      ],
      "answer": "E",
      "predicted_answer": [
        "unsat",
        "unsat",
        "unsat",
        "unsat",
        "unsat"
      ],
      "status": "success",
      "error": ""
    }
  },
  {
    "id": 104,
    "nl_problem": {
      "context": "Each of exactly seven professors—Powell, Shihab, Taylor, Vaughan, Wood, Young, and Zabel—gives exactly one guest lecture in the literary theory course. The lectures are ordered from first through seventh, and their order must conform to the following: Powell lectures before Wood. Taylor lectures before Shihab. Vaughan lectures before Zabel. Shihab is no later than third. Young is not seventh. Powell lectures first if, but only if, Young lectures before Vaughan.",
      "question": "If Zabel lectures fourth, then which one of the following could be true?",
      "options": [
        "A) Powell lectures second.",
        "B) Powell lectures seventh.",
        "C) Wood lectures third.",
        "D) Young lectures second.",
        "E) Young lectures sixth."
      ]
    },
    "answer": "E",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((Professors 0)) (((Powell) (Shihab) (Taylor) (Vaughan) (Wood) (Young) (Zabel))))",
        "(declare-datatypes ((LectureOrder 0)) (((first) (second) (third) (fourth) (fifth) (sixth) (seventh))))",
        "(declare-fun lectures (Professors LectureOrder) Bool)"
      ],
      "constraints": [
        "(forall ((p Professors) (o LectureOrder)) (=> (lectures p o) (distinct p Powell)))",
        "(forall ((p Professors) (o LectureOrder)) (=> (lectures p o) (distinct p Wood)))",
        "(forall ((p Professors) (o LectureOrder)) (=> (lectures p o) (distinct p Taylor)))",
        "(forall ((p Professors) (o LectureOrder)) (=> (lectures p o) (distinct p Shihab)))",
        "(forall ((p Professors) (o LectureOrder)) (=> (lectures p o) (distinct p Vaughan)))",
        "(forall ((p Professors) (o LectureOrder)) (=> (lectures p o) (distinct p Young)))",
        "(forall ((p Professors) (o LectureOrder)) (=> (lectures p o) (distinct p Zabel)))",
        "(forall ((o LectureOrder)) (=> (lectures Powell first) (or (and (lectures Young o) (<= o fourth)) (not (lectures Young o)))))",
        "(forall ((p Professors) (o LectureOrder)) (=> (lectures Taylor o) (<= o (if (= o third) third (ite (= p Shihab) third (if (= p Shihab) third o)))))",
        "(forall ((p Professors) (o LectureOrder)) (=> (lectures Vaughan o) (<= o (if (= o fifth) fifth (ite (= p Zabel) fifth o)))))",
        "(forall ((o LectureOrder)) (=> (<= o third) (<= (if (= o third) third (ite (= o third) third (ite (= p Shihab) third (if (= p Shihab) third o)))) third)))",
        "(forall ((o LectureOrder)) (=> (not (<= o sixth)) (not (= o seventh))))"
      ],
      "options": [
        "(forall ((o LectureOrder)) (=> (and (= o fourth) (lectures Zabel fourth)) (or (and (= o second) (lectures Powell second)) (and (= o seventh) (not (lectures Powell seventh))) (and (= o third) (lectures Wood third)) (and (= o second) (lectures Young second)) (and (= o sixth) (lectures Young sixth)))))"
      ],
      "type": "unsat",
      "perplexity": [
        1.3052327632904053,
        1.0690888166427612
      ],
      "answer": "E",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "No Output"
    }
  },
  {
    "id": 105,
    "nl_problem": {
      "context": "A toy retailer is opening a small satellite store with exactly three aisles, numbered from 1 (lowest) to 3 (highest). Six sections—Fantasy, Hobbies, Music, Puzzles, Reading, and Science—will each be confined to exactly one aisle, with each aisle containing at least one of the sections. The following conditions hold: Reading must be located in the same aisle as either Fantasy or Music. Fantasy must be located in a lower-numbered aisle than both Music and Puzzles. Science must be located in a lower-numbered aisle than Puzzles. Science cannot be located in a lower-numbered aisle than Hobbies.",
      "question": "If aisle 1 contains Hobbies only, which one of the following could be true?",
      "options": [
        "A) Fantasy is located in aisle 3.",
        "B) Music is located in aisle 2.",
        "C) Puzzles is located in aisle 2.",
        "D) Reading is located in aisle 3.",
        "E) Science is located in aisle 3."
      ]
    },
    "answer": "D",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((Aisles 0)) (((aisle1) (aisle2) (aisle3))))",
        "(declare-datatypes ((Sections 0)) (((Fantasy) (Hobbies) (Music) (Puzzles) (Reading) (Science))))",
        "(declare-fun contains (Aisles Sections) Bool)",
        "(define-fun to-int ((b Bool)) Int (ite b 1 0))"
      ],
      "constraints": [
        "(forall ((a Aisles)) (> (+ (to-int (contains a Fantasy)) (to-int (contains a Music)) (to-int (contains a Puzzles)) (to-int (contains a Reading)) (to-int (contains a Science))) 0))",
        "(forall ((a Aisles)) (< (+ (to-int (contains a Fantasy)) (to-int (contains a Music)) (to-int (contains a Puzzles)) (to-int (contains a Reading)) (to-int (contains a Science))) 5))",
        "(forall ((a Aisles)) (> (+ (to-int (contains a Fantasy)) (to-int (contains a Music)) (to-int (contains a Puzzles)) (to-int (contains a Reading)) (to-int (contains a Science))) (ite (distinct a aisle1) 2 3)))",
        "(forall ((a Aisles)) (> (+ (to-int (contains a Science)) (to-int (contains a Puzzles))) (ite (distinct a aisle1) 1 2)))",
        "(forall ((a Aisles)) (> (+ (to-int (contains a Fantasy)) (to-int (contains a Music))) (ite (distinct a aisle1) 1 2)))",
        "(forall ((a Aisles)) (> (+ (to-int (contains a Fantasy)) (to-int (contains a Music)) (to-int (contains a Puzzles))) (ite (distinct a aisle1) 2 3)))",
        "(forall ((a Aisles)) (or (ite (= a aisle1) Fantasy (= a aisle2) Fantasy (= a aisle3) Fantasy) (= a aisle1) Fantasy (= a aisle2) Music (= a aisle3) Fantasy))",
        "(forall ((a Aisles)) (or (ite (= a aisle1) Fantasy (= a aisle2) Fantasy (= a aisle3) Fantasy) (> (to-int (contains a Fantasy)) (to-int (contains a Music))) (ite (= a aisle1) Fantasy (= a aisle2) Fantasy (= a aisle3) Fantasy) (> (to-int (contains a Fantasy)) (to-int (contains a Puzzles)))))",
        "(forall ((a Aisles)) (> (to-int (contains a Science)) (to-int (contains a Puzzles))))",
        "(forall ((a Aisles)) (not (and (> (to-int (contains a Science)) (to-int (contains a Hobbies))) (> (to-int (contains a Hobbies)) (to-int (contains a Puzzles)))))"
      ],
      "options": [
        "(forall ((a Aisles)) (= (contains a Fantasy) (= a aisle3)))",
        "(forall ((a Aisles)) (= (contains a Music) (= a aisle2)))",
        "(forall ((a Aisles)) (= (contains a Puzzles) (= a aisle2)))",
        "(forall ((a Aisles)) (= (contains a Reading) (= a aisle3)))",
        "(forall ((a Aisles)) (= (contains a Science) (= a aisle3)))"
      ],
      "type": "unsat",
      "perplexity": [
        1.0971840620040894,
        1.0601166486740112
      ],
      "answer": "D",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "No Output"
    }
  },
  {
    "id": 106,
    "nl_problem": {
      "context": "A toy retailer is opening a small satellite store with exactly three aisles, numbered from 1 (lowest) to 3 (highest). Six sections—Fantasy, Hobbies, Music, Puzzles, Reading, and Science—will each be confined to exactly one aisle, with each aisle containing at least one of the sections. The following conditions hold: Reading must be located in the same aisle as either Fantasy or Music. Fantasy must be located in a lower-numbered aisle than both Music and Puzzles. Science must be located in a lower-numbered aisle than Puzzles. Science cannot be located in a lower-numbered aisle than Hobbies.",
      "question": "If aisle 3 contains Puzzles only, which one of the following must be true?",
      "options": [
        "A) Fantasy is located in aisle 1.",
        "B) Hobbies is located in aisle 1.",
        "C) Music is located in aisle 1.",
        "D) Reading is located in aisle 1.",
        "E) Science is located in aisle 2."
      ]
    },
    "answer": "A",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((Aisles 0)) (((aisle1) (aisle2) (aisle3))))",
        "(declare-datatypes ((Sections 0)) (((Fantasy) (Hobbies) (Music) (Puzzles) (Reading) (Science))))",
        "(declare-fun located (Aisles Sections) Bool)"
      ],
      "constraints": [
        "(define-fun to-int ((b Bool)) Int (ite b 1 0))",
        "(define-fun count (a Aisles) Int (+ (to-int (located a Fantasy)) (to-int (located a Hobbies)) (to-int (located a Music)) (to-int (located a Puzzles)) (to-int (located a Reading)) (to-int (located a Science))))",
        "(declare-fun R Aisles)",
        "(define-fun R_constraint () Bool (or (= (located R Fantasy) (located R Music))))",
        "(assert (forall ((a Aisles)) (=> (located a Reading) (R_constraint))))",
        "(define-fun Fantasy_lower_than_Music_Puzzles () Bool (or (not (located aisle1 Fantasy)) (and (not (located aisle1 Music)) (not (located aisle1 Puzzles)))))",
        "(assert (forall ((a Aisles)) (=> (located a Fantasy) (Fantasy_lower_than_Music_Puzzles))))",
        "(define-fun Science_lower_than_Puzzles () Bool (or (not (located aisle1 Science)) (or (not (located aisle1 Puzzles)) (not (located aisle2 Puzzles)))))",
        "(assert (forall ((a Aisles)) (=> (located a Science) (Science_lower_than_Puzzles))))",
        "(define-fun Science_not_lower_than_Hobbies () Bool (or (not (located aisle1 Science)) (or (not (located aisle1 Hobbies)) (not (located aisle2 Hobbies)))))",
        "(assert (forall ((a Aisles)) (=> (located a Science) (Science_not_lower_than_Hobbies))))",
        "(assert (forall ((a Aisles)) (> (count a) 0)))",
        "(assert (forall ((a Aisles)) (= (count a) 1)))",
        "(assert (= (located aisle3 Puzzles)))",
        "(assert (not (located aisle3 Fantasy)))",
        "(assert (not (located aisle3 Hobbies)))",
        "(assert (not (located aisle3 Music)))",
        "(assert (not (located aisle3 Reading)))",
        "(assert (not (located aisle3 Science)))",
        "(define-fun option_A () Bool (located aisle1 Fantasy))",
        "(assert (=> (located aisle1 Fantasy) option_A))",
        "(define-fun option_B () Bool (located aisle1 Hobbies))",
        "(assert (=> (located aisle1 Hobbies) option_B))",
        "(define-fun option_C () Bool (located aisle1 Music))",
        "(assert (=> (located aisle1 Music) option_C))",
        "(define-fun option_D () Bool (located aisle1 Reading))",
        "(assert (=> (located aisle1 Reading) option_D))",
        "(define-fun option_E () Bool (located aisle2 Science))",
        "(assert (=> (located aisle2 Science) option_E))"
      ],
      "options": [
        "option_A",
        "option_B",
        "option_C",
        "option_D",
        "option_E"
      ],
      "type": "unsat",
      "perplexity": [
        1.1971681118011475,
        1.0758472681045532
      ],
      "answer": "A",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "No Output"
    }
  },
  {
    "id": 107,
    "nl_problem": {
      "context": "A toy retailer is opening a small satellite store with exactly three aisles, numbered from 1 (lowest) to 3 (highest). Six sections—Fantasy, Hobbies, Music, Puzzles, Reading, and Science—will each be confined to exactly one aisle, with each aisle containing at least one of the sections. The following conditions hold: Reading must be located in the same aisle as either Fantasy or Music. Fantasy must be located in a lower-numbered aisle than both Music and Puzzles. Science must be located in a lower-numbered aisle than Puzzles. Science cannot be located in a lower-numbered aisle than Hobbies.",
      "question": "If each aisle contains exactly two of the six sections, then Science must be located in the same aisle as",
      "options": [
        "A) Fantasy",
        "B) Hobbies",
        "C) Music",
        "D) Puzzles",
        "E) Reading"
      ]
    },
    "answer": "B",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((Aisles 0)) (((aisle1) (aisle2) (aisle3))))",
        "(declare-datatypes ((Sections 0)) (((Fantasy) (Hobbies) (Music) (Puzzles) (Reading) (Science)))",
        "(declare-fun located (Sections Aisles) Bool)",
        "(declare-fun aisle-sections (Aisles) (Set Sections))"
      ],
      "constraints": [
        "(forall ((s Sections)) (has-at-least-one-section aisle1))",
        "(forall ((s Sections)) (has-at-least-one-section aisle2))",
        "(forall ((s Sections)) (has-at-least-one-section aisle3))",
        "(Reading-in-same-aisle-as-Fantasy-or-Music)",
        "(Fantasy-in-lower-aisle-than-Music-and-Puzzles)",
        "(Science-in-lower-aisle-than-Puzzles)",
        "(Science-not-in-lower-aisle-than-Hobbies)",
        "(forall ((aisle Aisles)) (= (count-sections aisle) 2))"
      ],
      "options": [
        "option-A-f",
        "option-B-f",
        "option-C-f",
        "option-D-f",
        "option-E-f"
      ],
      "type": "unsat",
      "perplexity": [
        1.1791235208511353,
        1.1542508602142334
      ],
      "answer": "B",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "No Output"
    }
  },
  {
    "id": 108,
    "nl_problem": {
      "context": "A toy retailer is opening a small satellite store with exactly three aisles, numbered from 1 (lowest) to 3 (highest). Six sections—Fantasy, Hobbies, Music, Puzzles, Reading, and Science—will each be confined to exactly one aisle, with each aisle containing at least one of the sections. The following conditions hold: Reading must be located in the same aisle as either Fantasy or Music. Fantasy must be located in a lower-numbered aisle than both Music and Puzzles. Science must be located in a lower-numbered aisle than Puzzles. Science cannot be located in a lower-numbered aisle than Hobbies.",
      "question": "Which one of the following CANNOT be the list of the sections located in aisle 2?",
      "options": [
        "A) Hobbies, Music",
        "B) Music, Reading",
        "C) Music, Science",
        "D) Hobbies, Music, Science",
        "E) Music, Reading, Science"
      ]
    },
    "answer": "A",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((Aisles 0)) (((1) (2) (3))))",
        "(declare-datatypes ((Sections 0)) (((Fantasy) (Hobbies) (Music) (Puzzles) (Reading) (Science))))",
        "(declare-fun located (Aisles Sections) Bool)",
        "(declare-fun R (Aisles Sections) Bool)",
        "(declare-fun F (Aisles Sections) Bool)",
        "(declare-fun M (Aisles Sections) Bool)",
        "(declare-fun P (Aisles Sections) Bool)",
        "(declare-fun H (Aisles Sections) Bool)",
        "(declare-fun S (Aisles Sections) Bool)",
        "(declare-fun A1 (Sections) Bool)",
        "(declare-fun A2 (Sections) Bool)",
        "(declare-fun A3 (Sections) Bool)"
      ],
      "constraints": [
        "(forall ((t Aisles)) (>= (to-int (and (located t Fantasy) (located t Music))) 1))",
        "(forall ((t Aisles)) (>= (to-int (and (located t Hobbies) (located t Science))) 1))",
        "(forall ((t Aisles)) (= (to-int (and (located t Reading) (located t Fantasy))) (to-int (and (located t Reading) (located t Music)))))",
        "(forall ((t Aisles)) (= (to-int (located t Fantasy)) (+ (to-int (and (not (= t 2)) (located t Music))) (to-int (and (not (= t 2)) (located t Puzzles))))))",
        "(forall ((t Aisles)) (=> (not (= t 2)) (located t Science)))",
        "(forall ((t Aisles)) (=> (not (= t 1)) (located t Science)))",
        "(or (not (= (located 1 Reading) (located 1 Fantasy))) (not (= (located 1 Fantasy) (located 1 Music))) (not (= (located 1 Music) (located 1 Puzzles))))",
        "(or (not (= (located 1 Music) (located 1 Puzzles))) (not (= (located 1 Puzzles) (located 1 Science))))",
        "(or (not (= (located 1 Puzzles) (located 1 Science))) (not (= (located 1 Hobbies) (located 1 Science))))",
        "(or (not (= (located 1 Science) (located 1 Hobbies))) (not (= (located 1 Hobbies) (located 1 Science))))",
        "(or (not (= (located 2 Reading) (located 2 Fantasy))) (not (= (located 2 Fantasy) (located 2 Music))) (not (= (located 2 Music) (located 2 Puzzles))))",
        "(or (not (= (located 2 Music) (located 2 Puzzles))) (not (= (located 2 Puzzles) (located 2 Science))))",
        "(or (not (= (located 2 Puzzles) (located 2 Science))) (not (= (located 2 Hobbies) (located 2 Science))))",
        "(or (not (= (located 2 Hobbies) (located 2 Science))) (not (= (located 2 Music) (located 2 Science))))",
        "(or (not (= (located 2 Music) (located 2 Science))) (not (= (located 2 Science) (located 2 Music))))"
      ],
      "options": [
        "(or (not (and (located 2 Hobbies) (located 2 Music))) (not (and (located 2 Music) (located 2 Science))))",
        "(or (not (and (located 2 Music) (located 2 Reading))) (not (and (located 2 Music) (located 2 Science))))",
        "(or (not (and (located 2 Hobbies) (located 2 Music) (located 2 Science))) (not (and (located 2 Music) (located 2 Reading) (located 2 Science))))",
        "(or (not (and (located 2 Music) (located 2 Reading) (located 2 Science))) (not (and (located 2 Music) (located 2 Science))))"
      ],
      "type": "unsat",
      "perplexity": [
        1.189884066581726,
        1.051251769065857
      ],
      "answer": "A",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "No Output"
    }
  },
  {
    "id": 109,
    "nl_problem": {
      "context": "A toy retailer is opening a small satellite store with exactly three aisles, numbered from 1 (lowest) to 3 (highest). Six sections—Fantasy, Hobbies, Music, Puzzles, Reading, and Science—will each be confined to exactly one aisle, with each aisle containing at least one of the sections. The following conditions hold: Reading must be located in the same aisle as either Fantasy or Music. Fantasy must be located in a lower-numbered aisle than both Music and Puzzles. Science must be located in a lower-numbered aisle than Puzzles. Science cannot be located in a lower-numbered aisle than Hobbies.",
      "question": "If aisle 2 contains Science only, then each of the following must be true EXCEPT:",
      "options": [
        "A) Fantasy is located in aisle 1.",
        "B) Hobbies is located in aisle 1.",
        "C) Music is located in aisle 3.",
        "D) Puzzles is located in aisle 3.",
        "E) Reading is located in aisle 1."
      ]
    },
    "answer": "E",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((Aisles 0)) (((aisle1) (aisle2) (aisle3))))",
        "(declare-datatypes ((Sections 0)) (((Fantasy) (Hobbies) (Music) (Puzzles) (Reading) (Science))))",
        "(declare-fun in (Sections Aisles) Bool)",
        "(declare-fun to-int ((b Bool)) Int (ite b 1 0))",
        "(declare-fun in-count (Sections Aisles) Int)",
        "(define-fun count ((s Sections) (a Aisles)) Int (ite (in s a) (+ (to-int (in s a)) (count s (ite (< a aisle1) (ite (< a aisle2) aisle2 aisle1) aisle3)) (count s (ite (< a aisle2) aisle2 aisle1)))) 0))",
        "(declare-fun count-equal (Sections) Bool)",
        "(define-fun count-equal ((s1 Sections) (s2 Sections)) Bool (ite (and (= (count s1 aisle1) (count s2 aisle1)) (= (count s1 aisle2) (count s2 aisle2)) (= (count s1 aisle3) (count s2 aisle3))) true false))",
        "(declare-fun count-less (Sections) Bool)",
        "(define-fun count-less ((s1 Sections) (s2 Sections)) Bool (ite (or (< (count s1 aisle1) (count s2 aisle1)) (< (count s1 aisle2) (count s2 aisle2)) (< (count s1 aisle3) (count s2 aisle3))) true false))",
        "(declare-fun count-not-less (Sections) Bool)",
        "(define-fun count-not-less ((s1 Sections) (s2 Sections)) Bool (not (count-less s1 s2)))",
        "(declare-fun count-science-less-puzzles (Sections) Bool)",
        "(define-fun count-science-less-puzzles ((s Sections)) Bool (ite (and (not (in Science aisle1)) (not (in Science aisle2)) (count-less Science Puzzles)) true false))",
        "(declare-fun count-science-not-less-hobbies (Sections) Bool)",
        "(define-fun count-science-not-less-hobbies ((s Sections)) Bool (ite (and (not (in Science aisle1)) (not (in Science aisle2)) (not (count-less Science Hobbies))) true false))",
        "(declare-fun reading-fantasy-or-music (Sections) Bool)",
        "(define-fun reading-fantasy-or-music ((s Sections)) Bool (or (count-equal Reading Fantasy) (count-equal Reading Music)))",
        "(declare-fun fantasy-music-puzzles-less (Sections) Bool)",
        "(define-fun fantasy-music-puzzles-less ((s Sections)) Bool (and (count-less Fantasy Music) (count-less Fantasy Puzzles)))",
        "(declare-fun science-puzzles-less (Sections) Bool)",
        "(define-fun science-puzzles-less ((s Sections)) Bool (count-less Science Puzzles))",
        "(declare-fun science-not-less-hobbies (Sections) Bool)",
        "(define-fun science-not-less-hobbies ((s Sections)) Bool (count-not-less Science Hobbies))",
        "(declare-fun count-science-not-less-hobbies-helper (Sections Aisles) Bool)",
        "(define-fun count-science-not-less-hobbies-helper ((s Sections) (a Aisles)) Bool (ite (and (not (in Science a)) (not (count-less Science Hobbies))) true false))",
        "(declare-fun count-science-in-aisle-2 (Sections) Bool)",
        "(define-fun count-science-in-aisle-2 ((s Sections)) Bool (= (count Science aisle2) 1))",
        "(declare-fun option-A (Sections) Bool)",
        "(define-fun option-A ((s Sections)) Bool (and (not (in Fantasy aisle2)) (not (in Fantasy aisle3))))",
        "(declare-fun option-B (Sections) Bool)",
        "(define-fun option-B ((s Sections)) Bool (and (not (in Hobbies aisle2)) (not (in Hobbies aisle3))))",
        "(declare-fun option-C (Sections) Bool)",
        "(define-fun option-C ((s Sections)) Bool (and (not (in Music aisle1)) (not (in Music aisle2))))",
        "(declare-fun option-D (Sections) Bool)",
        "(define-fun option-D ((s Sections)) Bool (and (not (in Puzzles aisle1)) (not (in Puzzles aisle2))))",
        "(declare-fun option-E (Sections) Bool)",
        "(define-fun option-E ((s Sections)) Bool (and (not (in Reading aisle2)) (not (in Reading aisle3))))",
        "(declare-fun answer (Sections) Bool)",
        "(define-fun answer ((s Sections)) Bool (not (implies (and (count-science-in-aisle-2 s) (option-A s)) (reading-fantasy-or-music s))))",
        "(check-sat)",
        "(declare-fun correct-option (Sections) Bool)",
        "(define-fun correct-option ((s Sections)) Bool (ite (and (count-science-in-aisle-2 s) (option-A s)) (not (reading-fantasy-or-music s)) (and (count-science-in-aisle-2 s) (option-B s) (not (in Hobbies aisle1))) (and (count-science-in-aisle-2 s) (option-C s) (not (in Music aisle3))) (and (count-science-in-aisle-2 s) (option-D s) (not (in Puzzles aisle3))) (and (count-science-in-aisle-2 s) (option-E s) (not (in Reading aisle1))))))",
        "(assert (not (correct-option Science)))",
        "(check-sat)"
      ],
      "constraints": [
        "(forall ((s Sections)) (not (implies (and (count-science-in-aisle-2 s) (option-A s)) (reading-fantasy-or-music s))))",
        "(forall ((s Sections)) (ite (and (count-science-in-aisle-2 s) (option-A s)) (not (reading-fantasy-or-music s)) (and (count-science-in-aisle-2 s) (option-B s) (not (in Hobbies aisle1))) (and (count-science-in-aisle-2 s) (option-C s) (not (in Music aisle3))) (and (count-science-in-aisle-2 s) (option-D s) (not (in Puzzles aisle3))) (and (count-science-in-aisle-2 s) (option-E s) (not (in Reading aisle1)))))",
        "(forall ((s Sections)) (not (= (count Science aisle2) 1)))"
      ],
      "options": [
        "(not (in Fantasy aisle2))",
        "(not (in Fantasy aisle3))",
        "(not (in Hobbies aisle2))",
        "(not (in Hobbies aisle3))",
        "(not (in Music aisle1))",
        "(not (in Music aisle2))",
        "(not (in Puzzles aisle1))",
        "(not (in Puzzles aisle2))",
        "(not (in Reading aisle2))",
        "(not (in Reading aisle3))"
      ],
      "type": "unsat",
      "perplexity": [
        1.1552462577819824,
        1.0318191051483154
      ],
      "answer": "E",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "No Output"
    }
  },
  {
    "id": 110,
    "nl_problem": {
      "context": "Millville has created three new development zones: Z1, Z2, and Z3. Within these zones, subzones can be designated for housing, industrial, or retail use, with no subzone designated for more than one use. By city regulation, a total of no more than three subzones can be designated for each of the three uses. The following restrictions are in place: Retail subzones are not allowed in Z1. No more than two subzones for housing are allowed in any particular zone. No more than one retail subzone is allowed in any zone in which a subzone is designated for housing. Industrial subzones are not allowed in any zone in which a subzone is designated for housing or three subzones are designated for retail use.",
      "question": "Which one of the following is an allowable way of designating subzones within the three zones?",
      "options": [
        "A) Z1: no designated subzones Z2: one housing subzone, two retail subzones Z3: one industrial subzone, one retail subzone",
        "B) Z1: one housing subzone, one industrial subzone Z2: two housing subzones, one retail subzone Z3: one industrial subzone, one retail subzone",
        "C) Z1: one housing subzone, one retail subzone Z2: two housing subzones, one retail subzone Z3: one industrial subzone, one retail subzone",
        "D) Z1: one industrial subzone Z2: three housing subzones Z3: three retail subzones",
        "E) Z1: one industrial subzone Z2: two housing subzones, one retail subzone Z3: one industrial subzone, two retail subzones"
      ]
    },
    "answer": "E",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((DevelopmentZones 0)) (((Z1) (Z2) (Z3))))",
        "(declare-datatypes ((SubzoneUses 0)) (((housing) (industrial) (retail))))",
        "(declare-fun designated (DevelopmentZones SubzoneUses) Bool)",
        "(define-fun to-int ((b Bool)) Int (ite b 1 0))",
        "(define-fun subzone-designated ((z DevelopmentZones) (u SubzoneUses)) Bool (ite (and (designated z u) (not (= (to-int (designated z housing)) (to-int (designated z industrial))) (not (= (to-int (designated z housing)) (to-int (designated z retail))) (not (= (to-int (designated z industrial)) (to-int (designated z retail))))) (designated z u))) (designated z u))",
        "(declare-fun designated (DevelopmentZones SubzoneUses) Bool)",
        "(define-fun to-int ((b Bool)) Int (ite b 1 0))",
        "(define-fun subzone-designated ((z DevelopmentZones) (u SubzoneUses)) Bool (ite (and (designated z u) (not (= (to-int (designated z housing)) (to-int (designated z industrial))) (not (= (to-int (designated z housing)) (to-int (designated z retail))) (not (= (to-int (designated z industrial)) (to-int (designated z retail))))) (designated z u))) (designated z u))"
      ],
      "constraints": [
        "(forall ((z DevelopmentZones) (u SubzoneUses) (v SubzoneUses)) (=> (= u v) (not (and (designated z u) (designated z v)))))",
        "(forall ((u SubzoneUses)) (not (designated Z1 u)))",
        "(forall ((z DevelopmentZones)) (< (+ (to-int (designated z housing)) (to-int (designated z industrial)) (to-int (designated z retail))) 3))",
        "(forall ((z DevelopmentZones)) (=> (designated z housing) (<= (+ (to-int (designated z housing)) (to-int (designated z industrial)) (to-int (designated z retail))) 2)))",
        "(forall ((z DevelopmentZones)) (=> (or (designated z housing) (and (= (to-int (designated z housing)) (to-int (designated z industrial))) (= (to-int (designated z housing)) (to-int (designated z retail))) (not (= (to-int (designated z industrial)) (to-int (designated z retail))))) (not (designated z industrial))))",
        "(forall ((z DevelopmentZones)) (=> (or (designated z housing) (and (= (to-int (designated z housing)) (to-int (designated z industrial))) (= (to-int (designated z housing)) (to-int (designated z retail))) (not (= (to-int (designated z industrial)) (to-int (designated z retail))))) (not (designated z industrial))) (not (designated z industrial)))"
      ],
      "options": [
        "(and (not (designated Z1 housing)) (not (designated Z1 industrial)) (not (designated Z1 retail)) (designated Z2 housing) (designated Z2 retail) (not (designated Z2 industrial)) (designated Z3 industrial) (designated Z3 retail))",
        "(and (designated Z1 housing) (not (designated Z1 industrial)) (not (designated Z1 retail)) (designated Z2 housing) (designated Z2 retail) (not (designated Z2 industrial)) (designated Z3 industrial) (designated Z3 retail))",
        "(and (designated Z1 housing) (not (designated Z1 industrial)) (designated Z1 retail) (designated Z2 housing) (designated Z2 retail) (not (designated Z2 industrial)) (designated Z3 industrial) (designated Z3 retail))",
        "(and (not (designated Z1 housing)) (designated Z1 industrial) (not (designated Z1 retail)) (designated Z2 housing) (designated Z2 housing) (designated Z2 housing) (not (designated Z2 industrial)) (designated Z2 retail) (designated Z3 retail) (designated Z3 retail) (designated Z3 retail))",
        "(and (not (designated Z1 housing)) (designated Z1 industrial) (not (designated Z1 retail)) (designated Z2 housing) (designated Z2 retail) (not (designated Z2 industrial)) (designated Z3 industrial) (designated Z3 retail) (designated Z3 retail))"
      ],
      "type": "sat",
      "perplexity": [
        1.1909189224243164,
        1.0543609857559204
      ],
      "answer": "E",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "No Output"
    }
  },
  {
    "id": 111,
    "nl_problem": {
      "context": "Millville has created three new development zones: Z1, Z2, and Z3. Within these zones, subzones can be designated for housing, industrial, or retail use, with no subzone designated for more than one use. By city regulation, a total of no more than three subzones can be designated for each of the three uses. The following restrictions are in place: Retail subzones are not allowed in Z1. No more than two subzones for housing are allowed in any particular zone. No more than one retail subzone is allowed in any zone in which a subzone is designated for housing. Industrial subzones are not allowed in any zone in which a subzone is designated for housing or three subzones are designated for retail use.",
      "question": "Which one of the following CANNOT be true within a single zone?",
      "options": [
        "A) Two subzones are designated, one housing and one retail.",
        "B) Two subzones are designated, one industrial and one retail.",
        "C) Three subzones are designated, all of them retail.",
        "D) Four subzones are designated, none of them industrial.",
        "E) Four subzones are designated, two retail and two industrial."
      ]
    },
    "answer": "D",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((Subzone_uses 0)) (((housing) (industrial) (retail))))",
        "(declare-datatypes ((Subzones 0)) (((zone1_subzones) (zone2_subzones) (zone3_subzones))))",
        "(declare-fun has_use (Subzone_uses) Bool)",
        "(declare-fun num_housing (Subzones) Int)",
        "(declare-fun to-int ((b Bool)) Int (ite b 1 0))"
      ],
      "constraints": [
        "(= (num_housing zone1_subzones) 1)",
        "(= (num_housing zone2_subzones) 1)",
        "(= (num_housing zone3_subzones) 1)",
        "(not (has-use retail))",
        "(>= (+ (num_housing zone1_subzones) (num_housing zone2_subzones) (num_housing zone3_subzones)) 2)",
        "(not (or (and (has-use zone1_subzones housing) (has-use zone1_subzones retail)) (and (has-use zone2_subzones housing) (has-use zone2_subzones retail)) (and (has-use zone3_subzones housing) (has-use zone3_subzones retail))))",
        "(not (or (and (has-use zone1_subzones housing) (has-use zone1_subzones industrial)) (and (has-use zone2_subzones housing) (has-use zone2_subzones industrial)) (and (has-use zone3_subzones housing) (has-use zone3_subzones industrial)) (and (>= (num_retail zone1_subzones) 3) (has-use zone1_subzones industrial)) (and (>= (num_retail zone2_subzones) 3) (has-use zone2_subzones industrial)) (and (>= (num_retail zone3_subzones) 3) (has-use zone3_subzones industrial))))",
        "(not (forall ((t (Set Subzone_uses))) (>= (+ (to-int (has-use t housing)) (to-int (has-use t retail))) 2)))",
        "(forall ((t (Set Subzone_uses))) (>= (+ (to-int (has-use t housing)) (to-int (has-use t retail)) (to-int (has-use t industrial))) 0))"
      ],
      "options": [
        "(not (forall ((t (Set Subzone_uses))) (>= (+ (to-int (has-use t housing)) (to-int (has-use t industrial)) (to-int (has-use t retail))) 2)))",
        "(forall ((t (Set Subzone_uses))) (>= (+ (to-int (has-use t housing)) (to-int (has-use t retail))) 2))",
        "(not (forall ((t (Set Subzone_uses))) (>= (+ (to-int (has-use t housing)) (to-int (has-use t industrial)) (to-int (has-use t retail))) 2)))",
        "(forall ((t (Set Subzone_uses))) (>= (+ (to-int (has-use t housing)) (to-int (has-use t industrial)) (to-int (has-use t retail))) 2))",
        "(forall ((t (Set Subzone_uses))) (>= (+ (to-int (has-use t housing)) (to-int (has-use t industrial)) (to-int (has-use t retail))) 2))"
      ],
      "type": "unsat",
      "perplexity": [
        1.1438493728637695,
        1.0888142585754395
      ],
      "answer": "D",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "No Output"
    }
  },
  {
    "id": 112,
    "nl_problem": {
      "context": "Millville has created three new development zones: Z1, Z2, and Z3. Within these zones, subzones can be designated for housing, industrial, or retail use, with no subzone designated for more than one use. By city regulation, a total of no more than three subzones can be designated for each of the three uses. The following restrictions are in place: Retail subzones are not allowed in Z1. No more than two subzones for housing are allowed in any particular zone. No more than one retail subzone is allowed in any zone in which a subzone is designated for housing. Industrial subzones are not allowed in any zone in which a subzone is designated for housing or three subzones are designated for retail use.",
      "question": "What is the maximum number of designated subzones allowed in Z3?",
      "options": [
        "A) 2",
        "B) 3",
        "C) 4",
        "D) 5",
        "E) 6"
      ]
    },
    "answer": "D",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((Zones 0)) (((Z1) (Z2) (Z3))))",
        "(declare-datatypes ((Uses 0)) (((housing) (industrial) (retail))))",
        "(declare-datatypes ((Subzones 0)) (((zone1-housing) (zone1-industrial) (zone1-retail) (zone2-housing) (zone2-industrial) (zone2-retail) (zone3-housing) (zone3-industrial) (zone3-retail))))",
        "(declare-fun designated (Zones Uses) Bool)",
        "(declare-fun total (Uses) Int)"
      ],
      "constraints": [
        "(forall ((u Uses)) (not (designated Z1 u)))",
        "(forall ((u Uses)) (<= (+ (ite (designated Z1 u) 1 0) (ite (designated Z2 u) 1 0) (ite (designated Z3 u) 1 0)) 3))",
        "(forall ((z Zones)) (<= (+ (ite (designated z housing) 1 0) (ite (designated z industrial) 1 0) (ite (designated z retail) 1 0)) 2))",
        "(forall ((z Zones)) (=> (designated z housing) (<= (+ (ite (designated z retail) 1 0)) 1)))",
        "(forall ((z Zones)) (=> (or (designated z housing) (>= (+ (ite (designated Z1 retail) 1 0) (ite (designated Z2 retail) 1 0) (ite (designated Z3 retail) 1 0)) 3)) (not (designated z industrial))))",
        " (= (total housing) (+ (ite (and (designated Z1 housing) (not (designated Z1 industrial))) 1 0) (ite (and (designated Z2 housing) (not (designated Z2 industrial))) 1 0) (ite (and (designated Z3 housing) (not (designated Z3 industrial))) 1 0)))",
        " (= (total industrial) (+ (ite (and (designated Z1 industrial) (not (designated Z1 housing)) (not (designated Z1 retail))) 1 0) (ite (and (designated Z2 industrial) (not (designated Z2 housing)) (not (designated Z2 retail))) 1 0) (ite (and (designated Z3 industrial) (not (designated Z3 housing)) (not (designated Z3 retail))) 1 0)))",
        " (= (total retail) (+ (ite (and (designated Z1 retail) (not (designated Z1 housing)) (not (designated Z1 industrial))) 1 0) (ite (and (designated Z2 retail) (not (designated Z2 housing)) (not (designated Z2 industrial))) 1 0) (ite (and (designated Z3 retail) (not (designated Z3 housing)) (not (designated Z3 industrial))) 1 0)))"
      ],
      "options": [
        "(not (< (+ (ite (designated Z1 retail) 1 0) (ite (designated Z2 retail) 1 0) (ite (designated Z3 retail) 1 0)) 2))",
        "(not (< (+ (ite (designated Z1 retail) 1 0) (ite (designated Z2 retail) 1 0) (ite (designated Z3 retail) 1 0)) 3))",
        "(not (< (+ (ite (designated Z1 retail) 1 0) (ite (designated Z2 retail) 1 0) (ite (designated Z3 retail) 1 0)) 4))",
        "(not (< (+ (ite (designated Z1 retail) 1 0) (ite (designated Z2 retail) 1 0) (ite (designated Z3 retail) 1 0)) 5))",
        "(not (< (+ (ite (designated Z1 retail) 1 0) (ite (designated Z2 retail) 1 0) (ite (designated Z3 retail) 1 0)) 6))"
      ],
      "type": "unsat",
      "perplexity": [
        1.1854578256607056,
        1.0494441986083984
      ],
      "answer": "D",
      "predicted_answer": [
        "unsat",
        "unsat",
        "unsat",
        "unsat"
      ],
      "status": "success",
      "error": ""
    }
  },
  {
    "id": 113,
    "nl_problem": {
      "context": "Millville has created three new development zones: Z1, Z2, and Z3. Within these zones, subzones can be designated for housing, industrial, or retail use, with no subzone designated for more than one use. By city regulation, a total of no more than three subzones can be designated for each of the three uses. The following restrictions are in place: Retail subzones are not allowed in Z1. No more than two subzones for housing are allowed in any particular zone. No more than one retail subzone is allowed in any zone in which a subzone is designated for housing. Industrial subzones are not allowed in any zone in which a subzone is designated for housing or three subzones are designated for retail use.",
      "question": "If three subzones are designated for each use, then which one of the following is allowed?",
      "options": [
        "A) Exactly one subzone in Z3 is designated for industrial use and exactly one subzone in Z3 is designated for retail use.",
        "B) Exactly two subzones in Z2 are designated for housing.",
        "C) Three subzones in Z1 are designated for industrial use.",
        "D) Three subzones in Z2 are designated for industrial use and exactly one subzone in Z2 is designated for retail use.",
        "E) Three subzones in Z3 are designated for retail use."
      ]
    },
    "answer": "B",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((DevelopmentZones 0)) (((Z1) (Z2) (Z3))))",
        "(declare-datatypes ((SubzoneUses 0)) (((housing) (industrial) (retail))))",
        "(declare-fun subzone_designation (DevelopmentZones SubzoneUses) Int)",
        "(declare-fun total_subzone_designations (SubzoneUses) Int)",
        "(define-fun to-int ((b Bool)) Int (ite b 1 0))"
      ],
      "constraints": [
        " (= (+ (subzone_designation Z1 housing) (subzone_designation Z1 industrial) (subzone_designation Z1 retail)) 0)",
        ">= (total_subzone_designations housing) 0",
        ">= (total_subzone_designations industrial) 0",
        ">= (total_subzone_designations retail) 0",
        ">= (total_subzone_designations housing) 3",
        ">= (total_subzone_designations industrial) 3",
        ">= (total_subzone_designations retail) 3",
        "<= (+ (subzone_designation Z1 housing) (subzone_designation Z1 industrial) (subzone_designation Z1 retail)) 0",
        "<= (+ (subzone_designation Z2 housing) (subzone_designation Z2 industrial) (subzone_designation Z2 retail)) 3",
        "<= (+ (subzone_designation Z3 housing) (subzone_designation Z3 industrial) (subzone_designation Z3 retail)) 3",
        "<= (+ (subzone_designation Z2 housing) (subzone_designation Z2 industrial)) 2",
        "<= (+ (subzone_designation Z1 housing) (subzone_designation Z1 industrial)) 2",
        "<= (subzone_designation Z3 industrial) (ite (= (subzone_designation Z3 housing) 0) 3 (ite (= (subzone_designation Z3 retail) 3) 2 3))"
      ],
      "options": [
        "<= (subzone_designation Z3 industrial) 1",
        "<= (subzone_designation Z3 retail) 1",
        "<= (subzone_designation Z2 housing) 2",
        "<= (subzone_designation Z1 industrial) 3",
        "<= (subzone_designation Z2 industrial) 3",
        "<= (subzone_designation Z3 retail) 3"
      ],
      "type": "unsat",
      "perplexity": [
        1.158932089805603,
        1.086901068687439
      ],
      "answer": "B",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "No Output"
    }
  },
  {
    "id": 114,
    "nl_problem": {
      "context": "Millville has created three new development zones: Z1, Z2, and Z3. Within these zones, subzones can be designated for housing, industrial, or retail use, with no subzone designated for more than one use. By city regulation, a total of no more than three subzones can be designated for each of the three uses. The following restrictions are in place: Retail subzones are not allowed in Z1. No more than two subzones for housing are allowed in any particular zone. No more than one retail subzone is allowed in any zone in which a subzone is designated for housing. Industrial subzones are not allowed in any zone in which a subzone is designated for housing or three subzones are designated for retail use.",
      "question": "If one subzone in each of the zones is designated for industrial use, then which one of the following is allowed?",
      "options": [
        "A) More subzones are designated for retail use in Z2 than in Z3.",
        "B) A subzone in one of the zones is designated for housing.",
        "C) Exactly two subzones are designated in Z1.",
        "D) Exactly three subzones each are designated in Z2 and Z3.",
        "E) Exactly four subzones are designated in Z3."
      ]
    },
    "answer": "A",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((People 0)) (((Vladimir) (Wendy))))",
        "(declare-datatypes ((Meals 0)) (((breakfast) (lunch) (dinner) (snack))))",
        "(declare-datatypes ((Foods 0)) (((fish) (hot_cakes) (macaroni) (omelet) (poached_eggs))))",
        "(declare-fun eats (People Meals) Foods)"
      ],
      "constraints": [
        "(forall ((m Meals)) (not (= (eats Vladimir m) (eats Wendy m))))",
        "(forall ((p People) (f Foods)) (<= (+ (ite (= (eats p breakfast) f) 1 0) (ite (= (eats p lunch) f) 1 0) (ite (= (eats p dinner) f) 1 0) (ite (= (eats p snack) f) 1 0)) 1))",
        "(forall ((p People)) (or (= (eats p breakfast) hot_cakes) (= (eats p breakfast) poached_eggs) (= (eats p breakfast) omelet)))",
        "(forall ((p People)) (or (= (eats p lunch) fish) (= (eats p lunch) hot_cakes) (= (eats p lunch) macaroni) (= (eats p lunch) omelet)))",
        "(forall ((p People)) (or (= (eats p dinner) fish) (= (eats p dinner) hot_cakes) (= (eats p dinner) macaroni) (= (eats p dinner) omelet)))",
        "(forall ((p People)) (or (= (eats p snack) fish) (= (eats p snack) omelet)))",
        "(= (eats Wendy lunch) omelet)"
      ],
      "options": [
        "(not (exists ((m Meals)) (= (eats Vladimir m) fish)))",
        "(not (exists ((m Meals)) (= (eats Vladimir m) hot_cakes)))",
        "(not (exists ((m Meals)) (= (eats Vladimir m) macaroni)))",
        "(not (exists ((m Meals)) (= (eats Vladimir m) omelet)))",
        "(not (exists ((m Meals)) (= (eats Vladimir m) poached_eggs)))"
      ],
      "type": "unsat",
      "perplexity": [
        1.0109387636184692,
        1.0915477275848389
      ],
      "answer": "A",
      "predicted_answer": [
        "unsat"
      ],
      "status": "success",
      "error": ""
    }
  },
  {
    "id": 115,
    "nl_problem": {
      "context": "Millville has created three new development zones: Z1, Z2, and Z3. Within these zones, subzones can be designated for housing, industrial, or retail use, with no subzone designated for more than one use. By city regulation, a total of no more than three subzones can be designated for each of the three uses. The following restrictions are in place: Retail subzones are not allowed in Z1. No more than two subzones for housing are allowed in any particular zone. No more than one retail subzone is allowed in any zone in which a subzone is designated for housing. Industrial subzones are not allowed in any zone in which a subzone is designated for housing or three subzones are designated for retail use.",
      "question": "If three subzones in all are designated for retail use and a subzone in Z2 is designated for housing, then which one of the following is allowed?",
      "options": [
        "A) Two subzones in Z1 are designated for housing.",
        "B) More subzones are designated for industrial use in Z2 than in Z3.",
        "C) More subzones are designated for retail use in Z2 than in Z3.",
        "D) The same number of subzones are designated for retail use in Z2 and Z3.",
        "E) A subzone in Z3 is designated for housing."
      ]
    },
    "answer": "A",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((Development_zones 0)) (((Z1) (Z2) (Z3))))",
        "(declare-datatypes ((Subzone_uses 0)) (((housing) (industrial) (retail))))",
        "(declare-fun designated (Development_zones Subzone_uses) Bool)",
        "(declare-fun count (Development_zones Subzone_uses) Int)"
      ],
      "constraints": [
        "(forall ((z Development_zones) (u Subzone_uses)) (= (count z u) (ite (designated z u) 1 0)))",
        "(forall ((u Subzone_uses)) (= (>= (count Z1 u) 0) 1) (= (>= (count Z2 u) 0) 1) (= (>= (count Z3 u) 0) 1)))",
        "(forall ((z Development_zones)) (not (and (designated z retail) (designated z housing))))",
        "(forall ((z Development_zones)) (<= (count z housing) 2))",
        "(forall ((z Development_zones)) (<= (ite (and (designated z retail) (designated z housing)) 1 0) 1))",
        "(forall ((z Development_zones)) (<= (ite (and (designated z housing) (designated z retail) (>= (count z retail) 3)) 1 0) 1))"
      ],
      "options": [
        "(= (count Z1 retail) 3) (designated Z2 housing) (forall ((z Development_zones) (u Subzone_uses)) (<= (count z u) 3))",
        "(forall ((z Development_zones)) (= (count z industrial) (ite (and (designated z housing) (designated z retail)) 1 0) (ite (designated z retail) (ite (>= (count z retail) 3) 1 0) 0) 0))",
        "(= (count Z1 housing) 2)",
        "(> (count Z2 industrial) (count Z3 industrial))",
        "(> (count Z2 retail) (count Z3 retail))",
        "(= (count Z2 retail) (count Z3 retail))",
        "(= (count Z3 housing) 1)"
      ],
      "type": "sat",
      "perplexity": [
        1.1856379508972168,
        1.0894584655761719
      ],
      "answer": "A",
      "predicted_answer": [
        "sat",
        "sat",
        "sat",
        "sat",
        "sat"
      ],
      "status": "success",
      "error": ""
    }
  },
  {
    "id": 116,
    "nl_problem": {
      "context": "A researcher is studying seven manuscripts—F, G, H, L, M, P, and S—to determine their relative ages. It is known that no two manuscripts were written at the same time. The researcher has also determined the following: H was written earlier than S but later than F. P was the next manuscript written after G. At least four of the manuscripts were written earlier than L. At least four of the manuscripts were written later than M. H was not written fifth.",
      "question": "Which one of the following could be the order in which the manuscripts were written, from first to last?",
      "options": [
        "A) F, M, G, H, P, L, S",
        "B) G, P, M, F, H, S, L",
        "C) H, F, M, G, P, L, S",
        "D) L, F, M, G, P, H, S",
        "E) M, F, H, S, L, G, P"
      ]
    },
    "answer": "E",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((Manuscripts 0)) (((F) (G) (H) (L) (M) (P) (S))))",
        "(declare-fun written (Manuscripts Manuscripts) Bool)",
        "(declare-fun earliest (Manuscripts) Manuscripts)",
        "(declare-fun latest (Manuscripts) Manuscripts)"
      ],
      "constraints": [
        "(forall ((m1 Manuscripts) (m2 Manuscripts)) (=> (and (written m1 m2) (written m2 m1)) false))",
        "(forall () (and (written H S) (written H F)))",
        "(forall () (written P G))",
        "(forall () (>= (count (lambda ((x Manuscripts)) (written x L)) (Manuscripts F G H P S M)) 4))",
        "(forall () (>= (count (lambda ((x Manuscripts)) (written x M)) (Manuscripts F G H P S L)) 4))",
        "(forall () (not (= (earliest L) H)))"
      ],
      "options": [
        "(and (= (earliest F) F) (= (latest S) S) (= (earliest G) M) (= (earliest L) L) (= (earliest P) P) (= (earliest H) G) (= (latest M) G)))",
        "(and (= (earliest G) G) (= (latest S) S) (= (earliest M) G) (= (earliest L) L) (= (earliest P) M) (= (earliest H) H) (= (latest F) M)))",
        "(and (= (earliest H) H) (= (latest S) S) (= (earliest F) F) (= (earliest L) L) (= (earliest P) G) (= (earliest M) F) (= (latest G) F)))",
        "(and (= (earliest L) L) (= (latest S) S) (= (earliest F) L) (= (earliest G) M) (= (earliest P) H) (= (earliest M) F) (= (latest H) L)))",
        "(and (= (earliest M) M) (= (latest S) S) (= (earliest F) M) (= (earliest G) H) (= (earliest P) S) (= (earliest L) F) (= (latest H) S)))"
      ],
      "type": "unsat",
      "perplexity": [
        1.2696647644042969,
        1.0815247297286987
      ],
      "answer": "E",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "No Output"
    }
  },
  {
    "id": 117,
    "nl_problem": {
      "context": "A researcher is studying seven manuscripts—F, G, H, L, M, P, and S—to determine their relative ages. It is known that no two manuscripts were written at the same time. The researcher has also determined the following: H was written earlier than S but later than F. P was the next manuscript written after G. At least four of the manuscripts were written earlier than L. At least four of the manuscripts were written later than M. H was not written fifth.",
      "question": "Which one of the following manuscripts CANNOT have been written third?",
      "options": [
        "A) S",
        "B) P",
        "C) M",
        "D) H",
        "E) G"
      ]
    },
    "answer": "A",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((Manuscripts 0)) (((F) (G) (H) (L) (M) (P) (S))))",
        "(declare-fun was-written-before (Manuscripts Manuscripts) Bool)",
        "(declare-fun position (Manuscripts Int) Bool)",
        "(declare-fun written-earlier-than (Manuscripts Manuscripts) Bool)",
        "(declare-fun to-int ((b Bool)) Int (ite b 1 0))",
        "(declare-fun next-written (Manuscripts Manuscripts) Bool)"
      ],
      "constraints": [
        "(= (position H 3) false)",
        "(= (position S 7) true)",
        "(= (position F 1) true)",
        "(= (next-written G P))",
        "(= (next-written H S))",
        "(= (to-int (or (= (position F 1) true) (= (position G 2) true) (= (position H 3) true) (= (position P 4) true))) 1) 1)",
        "(= (to-int (or (= (position M 5) true) (= (position H 3) true) (= (position G 2) true) (= (position F 1) true))) 1) 1)",
        "(= (to-int (or (= (position P 4) true) (= (position G 2) true) (= (position H 3) true) (= (position F 1) true))) 1) 1)",
        "(= (to-int (or (= (position S 7) true) (= (position H 3) true) (= (position G 2) true) (= (position F 1) true))) 1) 1)",
        "(= (to-int (or (= (position H 3) true) (= (position P 4) true) (= (position S 7) true) (= (position L 6) true))) 1) 1)",
        "(= (to-int (or (= (position L 6) true) (= (position P 4) true) (= (position S 7) true) (= (position H 3) true))) 1) 1)",
        "(= (to-int (or (= (position P 4) true) (= (position S 7) true) (= (position L 6) true) (= (position H 3) true))) 1) 1)",
        "(= (to-int (or (= (position S 7) true) (= (position H 3) true) (= (position P 4) true) (= (position L 6) true))) 1) 1)",
        "(=> (and (written-earlier-than H S) (written-earlier-than F H)) (and (not (written-earlier-than S F)) (not (written-earlier-than H F))))",
        "(= (position H 5) false)"
      ],
      "options": [
        "(not (CANNOT-have-been-written-third S true))",
        "(not (CANNOT-have-been-written-third P true))",
        "(not (CANNOT-have-been-written-third M true))",
        "(not (CANNOT-have-been-written-third H true))",
        "(CANNOT-have-been-written-third G true)"
      ],
      "type": "unsat",
      "perplexity": [
        1.240261197090149,
        1.056200623512268
      ],
      "answer": "A",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "No Output"
    }
  },
  {
    "id": 118,
    "nl_problem": {
      "context": "A researcher is studying seven manuscripts—F, G, H, L, M, P, and S—to determine their relative ages. It is known that no two manuscripts were written at the same time. The researcher has also determined the following: H was written earlier than S but later than F. P was the next manuscript written after G. At least four of the manuscripts were written earlier than L. At least four of the manuscripts were written later than M. H was not written fifth.",
      "question": "If H was the next manuscript written after M, which one of the following could be true?",
      "options": [
        "A) F was written second.",
        "B) G was written third.",
        "C) H was written fourth.",
        "D) P was written third.",
        "E) S was written fourth."
      ]
    },
    "answer": "E",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((Manuscripts 0)) (((F) (G) (H) (L) (M) (P) (S))))",
        "(declare-datatypes ((Position 0)) (((first) (second) (third) (fourth) (fifth) (sixth) (seventh))))",
        "(declare-fun was-written-earlier (Manuscripts Manuscripts) Bool)",
        "(define-fun to-int ((p Position) (n Int)) Int (ite (distinct p first) n (ite (distinct p second) (+ n 1) (ite (distinct p third) (+ n 2) (ite (distinct p fourth) (+ n 3) (ite (distinct p fifth) (+ n 4) (ite (distinct p sixth) (+ n 5) (ite (distinct p seventh) (+ n 6) 7)))))))",
        "(define-fun get-position ((i Int)) Position (ite (<= i 1) first (ite (<= i 2) second (ite (<= i 3) third (ite (<= i 4) fourth (ite (<= i 5) fifth (ite (<= i 6) sixth seventh)))))))",
        "(define-fun get-sequence ((n Int)) (List Position) (ite (= n 0) nil (cons (get-position n) (get-sequence (- n 1)))))",
        "(define-fun is-valid-sequence ((s (List Position))) Bool (forall ((i Int) (j Int)) (=> (distinct i j) (not (= (nth i s) (nth j s)))))",
        "constraints"
      ],
      "constraints": [
        "(forall ((m Manuscripts) (n Manuscripts)) (not (= m n)))",
        "=(was-written-earlier H S) true",
        "(forall ((m Manuscripts)) =(was-written-earlier F m) true)",
        "(forall ((m Manuscripts) (n Manuscripts)) (=> (was-written-earlier m n) =(was-written-earlier n m) false))",
        "(forall ((m Manuscripts)) <(to-int (get-position (length (get-sequence 0))) (length (get-sequence 0))) 4)",
        "(forall ((m Manuscripts)) >(to-int (get-position (length (get-sequence 0))) (length (get-sequence 0))) 3)",
        "(not (and (get-position 4) (distinct H (nth 4 (get-sequence 0)))))",
        "=(was-written-earlier P G) true",
        "(forall ((m Manuscripts)) (<= 1 (to-int (get-position (length (get-sequence 0))) (length (get-sequence 0)))))",
        "(forall ((m Manuscripts) (n Manuscripts)) =(was-written-earlier m n) =(nth (to-int m (length (get-sequence 0))) (get-sequence 0)) (nth (to-int n (length (get-sequence 0))) (get-sequence 0)))",
        "options"
      ],
      "options": [
        "(= (nth 2 (get-sequence 0)) F)",
        "(= (nth 3 (get-sequence 0)) G)",
        "(= (nth 4 (get-sequence 0)) H)",
        "(= (nth 3 (get-sequence 0)) P)",
        "(= (nth 4 (get-sequence 0)) S)"
      ],
      "type": "unsat",
      "perplexity": [
        1.295867919921875,
        1.126577615737915
      ],
      "answer": "E",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "No Output"
    }
  },
  {
    "id": 119,
    "nl_problem": {
      "context": "A researcher is studying seven manuscripts—F, G, H, L, M, P, and S—to determine their relative ages. It is known that no two manuscripts were written at the same time. The researcher has also determined the following: H was written earlier than S but later than F. P was the next manuscript written after G. At least four of the manuscripts were written earlier than L. At least four of the manuscripts were written later than M. H was not written fifth.",
      "question": "Which one of the following manuscripts CANNOT have been written fourth?",
      "options": [
        "A) F",
        "B) G",
        "C) H",
        "D) P",
        "E) S"
      ]
    },
    "answer": "D",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((Manuscripts 0)) (((F) (G) (H) (L) (M) (P) (S))))",
        "(declare-fun written-before (Manuscripts Manuscripts) Bool)"
      ],
      "constraints": [
        "(forall ((m Manuscripts)) (forall ((n Manuscripts)) (=> (distinct m n) (= (written-before m n) (or (< (ite (written-before m n) 1 0) (ite (written-before n m) 1 0) 0) (or (< (ite (written-before m n) 1 0) (ite (written-before n m) 1 0) 0) 0)))))",
        "(define-fun H-before-S () Bool (written-before H S))",
        "(define-fun H-after-F () Bool (written-before H F))",
        "(assert (and (=> (written-before H F) (written-before H S)) (not (=> (written-before F H) (written-before H S)))))",
        "(define-fun P-after-G () Bool (written-before P G))",
        "(assert (=> (written-before G P) (not (written-before P G))))",
        "(define-fun L-after-four () Bool (and (written-before H L) (written-before M L) (written-before F L) (written-before G L)))",
        "(assert (or L-after-four (written-before P L) (written-before S L)))",
        "(define-fun M-before-four () Bool (and (written-before L M) (written-before H M) (written-before F M) (written-before G M)))",
        "(assert (or M-before-four (written-before P M) (written-before S M)))",
        "(define-fun not-H-fifth () Bool (not (or (= (ite (written-before F H) 1 0) 1) (= (ite (written-before G H) 1 0) 1) (= (ite (written-before P H) 1 0) 1) (= (ite (written-before S H) 1 0) 1))))",
        "(assert not-H-fifth)"
      ],
      "options": [
        "(define-fun cannot-four (m Manuscripts) (or (ite (written-before m F) 1 0) (ite (written-before m G) 1 0) (ite (written-before m P) 1 0) (ite (written-before m S) 1 0)))",
        "(assert (or (not (exists ((m Manuscripts)) (and (written-before m F) (cannot-four m)))) (not (exists ((m Manuscripts)) (and (written-before m G) (cannot-four m)))))",
        "(assert (not (exists ((m Manuscripts)) (and (written-before m P) (cannot-four m)))))",
        "(assert (not (exists ((m Manuscripts)) (and (written-before m S) (cannot-four m))))"
      ],
      "type": "unsat",
      "perplexity": [
        1.2532907724380493,
        1.0597683191299438
      ],
      "answer": "D",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "No Output"
    }
  },
  {
    "id": 120,
    "nl_problem": {
      "context": "A researcher is studying seven manuscripts—F, G, H, L, M, P, and S—to determine their relative ages. It is known that no two manuscripts were written at the same time. The researcher has also determined the following: H was written earlier than S but later than F. P was the next manuscript written after G. At least four of the manuscripts were written earlier than L. At least four of the manuscripts were written later than M. H was not written fifth.",
      "question": "If P was written earlier than H, then any of the following could be true EXCEPT:",
      "options": [
        "A) F was written first.",
        "B) G was written third.",
        "C) H was written sixth.",
        "D) L was written seventh.",
        "E) M was written second."
      ]
    },
    "answer": "D",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((Manuscripts 0)) (((F) (G) (H) (L) (M) (P) (S))))",
        "(declare-fun written-before (Manuscripts Manuscripts) Bool)",
        "(declare-fun is-written-at (Manuscripts Int) Bool)"
      ],
      "constraints": [
        "(forall ((m1 Manuscripts) (m2 Manuscripts)) (=> (and (not (= m1 m2)) (written-before m1 m2)) (not (written-before m2 m1))))",
        "(forall ((m Manuscripts)) (and (written-before H S) (written-before F H)))",
        "(forall ((m Manuscripts)) (=> (written-before G P) (= (+ (ite (written-before G m) 1 0) (ite (written-before m G) 1 0)) 1)))",
        "(forall ((m Manuscripts)) (>= (+ (ite (written-before m L) 1 0) (ite (written-before H L) 1 0) (ite (written-before F L) 1 0) (ite (written-before G L) 1 0)) 4))",
        "(forall ((m Manuscripts)) (>= (+ (ite (written-before L m) 1 0) (ite (written-before H m) 1 0) (ite (written-before F m) 1 0) (ite (written-before G m) 1 0)) 4))",
        "(forall ((m Manuscripts)) (not (and (written-before H m) (written-before m F) (written-before G H))))",
        "(not (and (written-before P H) (written-before F P)))",
        "(or (not (written-before P H)) (not (written-before G P)))",
        "(not (and (written-before P H) (written-before P H)))",
        "(or (not (written-before P H)) (not (written-before L P)))",
        "(or (not (written-before P H)) (not (written-before M P)))"
      ],
      "options": [],
      "type": "unsat",
      "perplexity": [
        1.2272052764892578,
        1.092870831489563
      ],
      "answer": "D",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "No Output"
    }
  },
  {
    "id": 121,
    "nl_problem": {
      "context": "Exactly six petri dishes—labeled dish 1 through dish 6—are to be stored in an otherwise empty refrigerator. There are three available shelves—the bottom shelf, the middle shelf, and the top shelf. The placement of the dishes must be consistent with the following conditions: No more than three dishes are stored on any shelf. Dish 2 is stored at least one shelf above dish 6. Dish 6 is stored either one shelf above or one shelf below dish 5. Dish 1 is not stored on the same shelf as dish 4.",
      "question": "Which one of the following is an acceptable placement of dishes on the bottom, middle, and top shelves?",
      "options": [
        "A) bottom: dish 1 middle: dish 6 top: dishes 2, 3, 4, 5",
        "B) bottom: dishes 1, 3 middle: dish 6 top: dishes 2, 4, 5",
        "C) bottom: dish 2 middle: dishes 4, 6 top: dishes 1, 3, 5",
        "D) bottom: dishes 3, 5 middle: dish 6 top: dishes 1, 2, 4",
        "E) bottom: dishes 4, 6 middle: dishes 1, 3 top: dishes 2, 5"
      ]
    },
    "answer": "B",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((Dishes 0)) (((dish_1) (dish_2) (dish_3) (dish_4) (dish_5) (dish_6))))",
        "(declare-datatypes ((Shelves 0)) (((bottom_shelf) (middle_shelf) (top_shelf))))",
        "(declare-fun stored (Dishes Shelves) Bool)"
      ],
      "constraints": [
        "(forall ((d Dishes)) (= (< (ite (stored d bottom_shelf) 1 (ite (stored d middle_shelf) 2 (ite (stored d top_shelf) 3 0))) 4) true))",
        "(forall ((d Dishes)) (=> (stored d top_shelf) (or (stored dish_2 top_shelf) (stored dish_2 middle_shelf))))",
        "(forall ((d Dishes)) (=> (stored d bottom_shelf) (or (stored dish_6 middle_shelf) (stored dish_6 top_shelf))))",
        "(forall ((d Dishes)) (=> (stored d middle_shelf) (or (stored dish_5 top_shelf) (stored dish_5 bottom_shelf))))",
        "(forall ((d Dishes)) (not (= (ite (stored d bottom_shelf) 1 0) (ite (stored dish_4 bottom_shelf) 1 0))))",
        "(forall ((d Dishes)) (not (= (ite (stored d middle_shelf) 2 0) (ite (stored dish_4 middle_shelf) 2 0))))",
        "(forall ((d Dishes)) (not (= (ite (stored d top_shelf) 3 0) (ite (stored dish_4 top_shelf) 3 0))))"
      ],
      "options": [
        "(and (stored dish_1 bottom_shelf) (stored dish_6 middle_shelf) (and (and (stored dish_2 top_shelf) (stored dish_3 top_shelf)) (stored dish_4 top_shelf) (stored dish_5 top_shelf)))",
        "(and (and (stored dish_1 bottom_shelf) (stored dish_3 bottom_shelf)) (stored dish_6 middle_shelf) (and (stored dish_2 top_shelf) (stored dish_4 top_shelf) (stored dish_5 top_shelf)))",
        "(and (stored dish_2 bottom_shelf) (and (stored dish_4 middle_shelf) (stored dish_6 middle_shelf)) (and (stored dish_1 top_shelf) (stored dish_3 top_shelf) (stored dish_5 top_shelf)))",
        "(and (and (stored dish_3 bottom_shelf) (stored dish_5 bottom_shelf)) (stored dish_6 middle_shelf) (and (stored dish_1 top_shelf) (stored dish_2 top_shelf) (stored dish_4 top_shelf)))",
        "(and (and (stored dish_4 bottom_shelf) (stored dish_6 bottom_shelf)) (and (stored dish_1 middle_shelf) (stored dish_3 middle_shelf)) (and (stored dish_2 top_shelf) (stored dish_5 top_shelf)))"
      ],
      "type": "unsat",
      "perplexity": [
        1.1394398212432861,
        1.0627213716506958
      ],
      "answer": "B",
      "predicted_answer": [
        "unsat",
        "unsat",
        "unsat",
        "unsat",
        "unsat"
      ],
      "status": "success",
      "error": ""
    }
  },
  {
    "id": 122,
    "nl_problem": {
      "context": "Exactly six petri dishes—labeled dish 1 through dish 6—are to be stored in an otherwise empty refrigerator. There are three available shelves—the bottom shelf, the middle shelf, and the top shelf. The placement of the dishes must be consistent with the following conditions: No more than three dishes are stored on any shelf. Dish 2 is stored at least one shelf above dish 6. Dish 6 is stored either one shelf above or one shelf below dish 5. Dish 1 is not stored on the same shelf as dish 4.",
      "question": "If dish 6 is the only dish stored on the bottom shelf, which one of the following could be the list of dishes that are stored together on the middle shelf?",
      "options": [
        "A) dish 1, dish 3",
        "B) dish 2, dish 4",
        "C) dish 2, dish 3",
        "D) dish 3, dish 5",
        "E) dish 4, dish 5"
      ]
    },
    "answer": "E",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((Shelves 0)) (((bottom) (middle) (top))))",
        "(declare-datatypes ((PetriDishes 0)) (((dish1) (dish2) (dish3) (dish4) (dish5) (dish6))))",
        "(declare-fun stored (PetriDishes Shelves) Bool)"
      ],
      "constraints": [
        "(forall ((s Shelves)) (<= (ite (ite (stored dish1 bottom) 1 0) (ite (stored dish2 bottom) 1 0) (ite (stored dish3 bottom) 1 0) (ite (stored dish4 bottom) 1 0) (ite (stored dish5 bottom) 1 0) (ite (stored dish6 bottom) 1 0) 0 0) (ite (ite (stored dish1 middle) 1 0) (ite (stored dish2 middle) 1 0) (ite (stored dish3 middle) 1 0) (ite (stored dish4 middle) 1 0) (ite (stored dish5 middle) 1 0) (ite (stored dish6 middle) 1 0) 0 0) (ite (ite (stored dish1 top) 1 0) (ite (stored dish2 top) 1 0) (ite (stored dish3 top) 1 0) (ite (stored dish4 top) 1 0) (ite (stored dish5 top) 1 0) (ite (stored dish6 top) 1 0) 0 0) 3))",
        "(forall ((s Shelves)) (=> (and (stored dish2 s) (stored dish6 bottom)) (or (and (= s middle) (not (and (stored dish6 middle) (stored dish2 middle)))) (and (= s top) (not (and (stored dish6 top) (stored dish2 top)))))))",
        "(forall ((s Shelves)) (=> (and (stored dish6 s) (stored dish5 bottom)) (or (and (= s middle) (not (and (stored dish5 middle) (stored dish6 middle)))) (and (= s top) (not (and (stored dish5 top) (stored dish6 top)))))))",
        "(forall ((s Shelves)) (=> (and (stored dish1 s) (stored dish4 s)) (= s bottom)))"
      ],
      "options": [
        "(forall ((s Shelves)) (=> (= s middle) (or (and (stored dish1 s) (stored dish3 s)) (and (not (stored dish1 s)) (not (stored dish3 s))))))",
        "(forall ((s Shelves)) (=> (= s middle) (or (and (stored dish2 s) (stored dish4 s)) (and (not (stored dish2 s)) (not (stored dish4 s))))))",
        "(forall ((s Shelves)) (=> (= s middle) (or (and (stored dish2 s) (stored dish3 s)) (and (not (stored dish2 s)) (not (stored dish3 s))))))",
        "(forall ((s Shelves)) (=> (= s middle) (or (and (stored dish3 s) (stored dish5 s)) (and (not (stored dish3 s)) (not (stored dish5 s))))))",
        "(forall ((s Shelves)) (=> (= s middle) (or (and (stored dish4 s) (stored dish5 s)) (and (not (stored dish4 s)) (not (stored dish5 s))))))"
      ],
      "type": "unsat",
      "perplexity": [
        1.1172007322311401,
        1.0728546380996704
      ],
      "answer": "E",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "No Output"
    }
  },
  {
    "id": 123,
    "nl_problem": {
      "context": "Exactly six petri dishes—labeled dish 1 through dish 6—are to be stored in an otherwise empty refrigerator. There are three available shelves—the bottom shelf, the middle shelf, and the top shelf. The placement of the dishes must be consistent with the following conditions: No more than three dishes are stored on any shelf. Dish 2 is stored at least one shelf above dish 6. Dish 6 is stored either one shelf above or one shelf below dish 5. Dish 1 is not stored on the same shelf as dish 4.",
      "question": "If dish 1, dish 2, and dish 3 are stored on the same shelf as each other, which one of the following could be true?",
      "options": [
        "A) Exactly one of the dishes is stored on the top shelf.",
        "B) Exactly two of the dishes are stored on the top shelf.",
        "C) Exactly two of the dishes are stored on the middle shelf.",
        "D) Exactly three of the dishes are stored on the middle shelf.",
        "E) Exactly three of the dishes are stored on the bottom shelf."
      ]
    },
    "answer": "C",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((Shelves 0)) (((bottom_shelf) (middle_shelf) (top_shelf))))",
        "(declare-datatypes ((PetriDishes 0)) (((dish_1) (dish_2) (dish_3) (dish_4) (dish_5) (dish_6))))",
        "(declare-fun stored (PetriDishes Shelves) Bool)",
        "(define-fun to-int ((b Bool)) Int (ite b 1 0))"
      ],
      "constraints": [
        "(forall ((shelf Shelves)) (<= (num_dishes shelf) 3))",
        "(not (and (stored dish_2 bottom_shelf) (stored dish_6 bottom_shelf)))",
        "(not (and (stored dish_2 bottom_shelf) (stored dish_6 middle_shelf)))",
        "(not (and (stored dish_2 top_shelf) (stored dish_6 top_shelf)))",
        "(or (and (stored dish_6 bottom_shelf) (stored dish_5 middle_shelf)) (and (stored dish_6 bottom_shelf) (stored dish_5 top_shelf)) (and (stored dish_6 middle_shelf) (stored dish_5 top_shelf)))",
        "(not (and (stored dish_1 shelf) (stored dish_4 shelf)))"
      ],
      "options": [
        "(and (stored dish_1 top_shelf) (not (stored dish_2 top_shelf)) (not (stored dish_3 top_shelf)) (exactly_three middle_shelf) (exactly_three bottom_shelf))",
        "(and (not (stored dish_1 top_shelf)) (stored dish_2 top_shelf) (not (stored dish_3 top_shelf)) (exactly_three middle_shelf) (exactly_three bottom_shelf))",
        "(and (not (stored dish_1 top_shelf)) (not (stored dish_2 top_shelf)) (stored dish_3 top_shelf) (exactly_three middle_shelf) (exactly_three bottom_shelf))",
        "(and (stored dish_1 top_shelf) (stored dish_2 top_shelf) (stored dish_3 top_shelf) (exactly_three middle_shelf) (exactly_three bottom_shelf))",
        "(and (not (stored dish_1 top_shelf)) (stored dish_2 top_shelf) (stored dish_3 top_shelf) (exactly_three middle_shelf) (exactly_three bottom_shelf))",
        "(and (not (stored dish_1 top_shelf)) (not (stored dish_2 top_shelf)) (stored dish_3 top_shelf) (exactly_three middle_shelf) (exactly_three bottom_shelf))",
        "(and (stored dish_1 top_shelf) (not (stored dish_2 top_shelf)) (stored dish_3 top_shelf) (exactly_three middle_shelf) (exactly_three bottom_shelf))"
      ],
      "type": "unsat",
      "perplexity": [
        1.1297768354415894,
        1.064424991607666
      ],
      "answer": "C",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "No Output"
    }
  },
  {
    "id": 124,
    "nl_problem": {
      "context": "Exactly six petri dishes—labeled dish 1 through dish 6—are to be stored in an otherwise empty refrigerator. There are three available shelves—the bottom shelf, the middle shelf, and the top shelf. The placement of the dishes must be consistent with the following conditions: No more than three dishes are stored on any shelf. Dish 2 is stored at least one shelf above dish 6. Dish 6 is stored either one shelf above or one shelf below dish 5. Dish 1 is not stored on the same shelf as dish 4.",
      "question": "If exactly one of the shelves has no dish stored on it, which one of the following must be true?",
      "options": [
        "A) Exactly three of the dishes are stored on the bottom shelf.",
        "B) Exactly three of the dishes are stored on the middle shelf.",
        "C) Dish 1 is stored on the same shelf as dish 5.",
        "D) Dish 2 is stored on the same shelf as dish 3.",
        "E) Dish 4 is stored on the same shelf as dish 5."
      ]
    },
    "answer": "B",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((Shelves 0)) (((bottom_shelf) (middle_shelf) (top_shelf))))",
        "(declare-datatypes ((Dishes 0)) (((dish_1) (dish_2) (dish_3) (dish_4) (dish_5) (dish_6))))",
        "(declare-fun stored (Dishes Shelves) Bool)",
        "(define-fun to-int ((b Bool)) Int (ite b 1 0))",
        "(declare-fun on-bottom (Dishes) Bool)",
        "(declare-fun on-middle (Dishes) Bool)",
        "(declare-fun on-top (Dishes) Bool)",
        "(define-fun on-shelf ((d Dishes) (s Shelves)) Bool (or (on-bottom d) (on-middle d) (on-top d)))",
        "(declare-fun has-dishes (Shelves) Bool)",
        "(declare-fun on-bottom (Dishes) Bool)",
        "(declare-fun on-middle (Dishes) Bool)",
        "(declare-fun on-top (Dishes) Bool)"
      ],
      "constraints": [
        "(forall ((d Dishes) (s Shelves)) (=> (stored d s) (has-dishes s)))",
        "(forall ((s Shelves)) (=> (not (has-dishes s)) (not (stored _ s))))",
        "(forall ((s Shelves)) (=> (has-dishes s) (not (and (on-bottom _) (on-middle _) (on-top _)))))",
        "(forall ((s Shelves)) (= (has-dishes s) (or (on-bottom _) (on-middle _) (on-top _))))",
        "(forall ((d Dishes)) (< (to-int (on-bottom d)) 4))",
        "(forall ((d Dishes)) (< (to-int (on-middle d)) 4))",
        "(forall ((d Dishes)) (< (to-int (on-top d)) 4))",
        "(not (and (on-bottom dish_2) (on-bottom dish_6)))",
        "(forall ((d Dishes)) (= (or (on-bottom d) (on-middle d) (on-top d)) true))",
        "(or (not (on-bottom dish_6)) (> (to-int (on-middle dish_2)) 0))",
        "(forall ((d Dishes)) (= (or (and (on-bottom d) (not (on-bottom dish_5))) (and (on-top d) (not (on-bottom dish_5))) (and (on-middle d) (not (on-bottom dish_5)))) true))",
        "(forall ((d Dishes)) (= (or (and (on-bottom d) (not (on-bottom dish_4))) (and (on-middle d) (not (on-bottom dish_4))) (and (on-top d) (not (on-bottom dish_4)))) true))"
      ],
      "options": [
        "(= (to-int (on-bottom _)) 3)",
        "(= (to-int (on-middle _)) 3)",
        "(forall ((s Shelves)) (= (stored dish_1 s) (stored dish_5 s)))",
        "(forall ((s Shelves)) (= (stored dish_2 s) (stored dish_3 s)))",
        "(forall ((s Shelves)) (= (stored dish_4 s) (stored dish_5 s)))"
      ],
      "type": "unsat",
      "perplexity": [
        1.2829692363739014,
        1.0660605430603027
      ],
      "answer": "B",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "No Output"
    }
  },
  {
    "id": 125,
    "nl_problem": {
      "context": "Exactly six petri dishes—labeled dish 1 through dish 6—are to be stored in an otherwise empty refrigerator. There are three available shelves—the bottom shelf, the middle shelf, and the top shelf. The placement of the dishes must be consistent with the following conditions: No more than three dishes are stored on any shelf. Dish 2 is stored at least one shelf above dish 6. Dish 6 is stored either one shelf above or one shelf below dish 5. Dish 1 is not stored on the same shelf as dish 4.",
      "question": "If dish 5 is the only dish stored on the bottom shelf and if exactly two of the dishes are stored on the middle shelf, then which one of the following is a pair of dishes that must be among the dishes stored on the top shelf?",
      "options": [
        "A) dish 1 and dish 2",
        "B) dish 1 and dish 6",
        "C) dish 2 and dish 3",
        "D) dish 2 and dish 4",
        "E) dish 3 and dish 4"
      ]
    },
    "answer": "C"
  },
  {
    "id": 126,
    "nl_problem": {
      "context": "Exactly six petri dishes—labeled dish 1 through dish 6—are to be stored in an otherwise empty refrigerator. There are three available shelves—the bottom shelf, the middle shelf, and the top shelf. The placement of the dishes must be consistent with the following conditions: No more than three dishes are stored on any shelf. Dish 2 is stored at least one shelf above dish 6. Dish 6 is stored either one shelf above or one shelf below dish 5. Dish 1 is not stored on the same shelf as dish 4.",
      "question": "If exactly one of the dishes is stored on the middle shelf, which one of the following could be the list of dishes stored on the top shelf?",
      "options": [
        "A) dish 1, dish 2",
        "B) dish 1, dish 5",
        "C) dish 2, dish 3",
        "D) dish 3, dish 4",
        "E) dish 3, dish 5"
      ]
    },
    "answer": "A",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((PetriDishes 0)) (((dish_1) (dish_2) (dish_3) (dish_4) (dish_5) (dish_6))))",
        "(declare-datatypes ((Shelves 0)) (((bottom_shelf) (middle_shelf) (top_shelf))))",
        "(declare-fun stored (PetriDishes Shelves) Bool)",
        "(define-fun to-int ((b Bool)) Int (ite b 1 0))"
      ],
      "constraints": [
        "(forall ((s Shelves)) (<= (+ (to-int (stored dish_1 s)) (to-int (stored dish_2 s)) (to-int (stored dish_3 s)) (to-int (stored dish_4 s)) (to-int (stored dish_5 s)) (to-int (stored dish_6 s))) 3))",
        "(or (and (not (stored dish_2 bottom_shelf)) (stored dish_2 middle_shelf)) (and (not (stored dish_2 bottom_shelf)) (not (stored dish_2 middle_shelf)) (stored dish_2 top_shelf)))",
        "(or (and (not (stored dish_6 bottom_shelf)) (stored dish_6 middle_shelf)) (and (stored dish_6 bottom_shelf) (stored dish_5 middle_shelf)) (and (stored dish_6 bottom_shelf) (not (stored dish_5 middle_shelf)) (not (stored dish_5 top_shelf))))",
        "(or (and (stored dish_1 bottom_shelf) (stored dish_4 bottom_shelf)) (and (stored dish_1 middle_shelf) (stored dish_4 middle_shelf)) (and (stored dish_1 top_shelf) (stored dish_4 top_shelf)))",
        "(or (and (not (stored dish_1 middle_shelf)) (stored dish_1 bottom_shelf) (not (stored dish_2 middle_shelf)) (not (stored dish_3 middle_shelf)) (not (stored dish_4 middle_shelf)) (not (stored dish_5 middle_shelf)) (not (stored dish_6 middle_shelf)) (stored dish_2 top_shelf)) (and (not (stored dish_1 middle_shelf)) (not (stored dish_1 bottom_shelf)) (not (stored dish_2 middle_shelf)) (stored dish_3 middle_shelf) (not (stored dish_4 middle_shelf)) (not (stored dish_5 middle_shelf)) (not (stored dish_6 middle_shelf)) (stored dish_3 top_shelf)) (and (not (stored dish_1 middle_shelf)) (not (stored dish_1 bottom_shelf)) (not (stored dish_2 middle_shelf)) (not (stored dish_3 middle_shelf)) (stored dish_4 middle_shelf) (not (stored dish_5 middle_shelf)) (not (stored dish_6 middle_shelf)) (stored dish_4 top_shelf)) (and (not (stored dish_1 middle_shelf)) (not (stored dish_1 bottom_shelf)) (not (stored dish_2 middle_shelf)) (not (stored dish_3 middle_shelf)) (not (stored dish_4 middle_shelf)) (stored dish_5 middle_shelf) (not (stored dish_6 middle_shelf)) (stored dish_5 top_shelf)) (and (not (stored dish_1 middle_shelf)) (not (stored dish_1 bottom_shelf)) (not (stored dish_2 middle_shelf)) (not (stored dish_3 middle_shelf)) (not (stored dish_4 middle_shelf)) (not (stored dish_5 middle_shelf)) (stored dish_6 middle_shelf) (stored dish_2 top_shelf)) (and (not (stored dish_1 middle_shelf)) (not (stored dish_1 bottom_shelf)) (not (stored dish_2 middle_shelf)) (not (stored dish_3 middle_shelf)) (not (stored dish_4 middle_shelf)) (stored dish_5 middle_shelf) (stored dish_6 middle_shelf) (stored dish_3 top_shelf)))",
        "(or (and (stored dish_1 top_shelf) (stored dish_2 top_shelf)) (and (stored dish_1 top_shelf) (stored dish_5 top_shelf)) (and (stored dish_2 top_shelf) (stored dish_3 top_shelf)) (and (stored dish_3 top_shelf) (stored dish_4 top_shelf)) (and (stored dish_3 top_shelf) (stored dish_5 top_shelf)))"
      ],
      "options": [
        "(not (and (stored dish_1 top_shelf) (stored dish_2 top_shelf)))",
        "(not (and (stored dish_1 top_shelf) (stored dish_5 top_shelf)))",
        "(not (and (stored dish_2 top_shelf) (stored dish_3 top_shelf)))",
        "(not (and (stored dish_3 top_shelf) (stored dish_4 top_shelf)))",
        "(not (and (stored dish_3 top_shelf) (stored dish_5 top_shelf)))"
      ],
      "type": "unsat",
      "perplexity": [
        1.0951342582702637,
        1.0435045957565308
      ],
      "answer": "A",
      "predicted_answer": "N/A",
      "status": "execution error",
      "error": "No Output"
    }
  },
  {
    "id": 127,
    "nl_problem": {
      "context": "A company operates vending machines in four schools: Ferndale, Gladstone, Hafford, and Isley. The company delivers juices in one of its two trucks and snacks in the other truck. Each week, exactly one delivery of juices and exactly one delivery of snacks is made to each school, subject to the following conditions: Snacks must be delivered to Ferndale at some time before they are delivered to Hafford. Gladstone cannot be the fourth school to which juices are delivered. Gladstone must be the third school to which snacks are delivered. The first school to which juices are delivered must be the fourth one to which snacks are delivered.",
      "question": "Which one of the following could be the schedule of deliveries to the schools, from the first to the fourth?",
      "options": [
        "A) Juices: Hafford, Ferndale, Gladstone, Isley Snacks: Ferndale, Isley, Gladstone, Hafford",
        "B) Juices: Hafford, Isley, Ferndale, Gladstone Snacks: Isley, Ferndale, Gladstone, Hafford",
        "C) Juices: Isley, Ferndale, Gladstone, Hafford Snacks: Hafford, Ferndale, Gladstone, Isley",
        "D) Juices: Isley, Gladstone, Ferndale, Hafford Snacks: Ferndale, Gladstone, Hafford, Isley",
        "E) Juices: Isley, Hafford, Gladstone, Ferndale Snacks: Ferndale, Isley, Gladstone, Hafford"
      ]
    },
    "answer": "A",
    "logic_problem": {
      "declarations": [
        "(declare-datatypes ((Schools 0)) (((Ferndale) (Gladstone) (Hafford) (Isley))))",
        "(declare-datatypes ((Trucks 0)) (((juices_truck) (snacks_truck))))",
        "(declare-fun delivery (Trucks Schools) Bool)",
        "(declare-fun delivery_order (Trucks Schools) Int)"
      ],
      "constraints": [
        "(forall ((s Schools) (t Trucks)) (not (= (delivery t s) (and (delivery t s) (delivery t s)))))",
        "(forall ((s Schools)) (=> (delivery snacks_truck Ferndale) (not (delivery snacks_truck Hafford))))",
        "(forall ((s Schools)) (=> (delivery snacks_truck Ferndale) (< (delivery_order snacks_truck Hafford) (delivery_order snacks_truck Ferndale))))",
        "(forall ((s Schools)) (=> (not (delivery juices_truck Gladstone)) (not (and (= (delivery_order juices_truck Isley) 3) (delivery juices_truck Gladstone)))))",
        "(forall ((s Schools)) (=> (not (delivery juices_truck Gladstone)) (not (and (delivery juices_truck Isley) (= (delivery_order juices_truck Isley) 3) (delivery juices_truck Gladstone)))))",
        "(forall ((s Schools)) (=> (delivery juices_truck Isley) (not (= (delivery_order juices_truck Isley) 3))))",
        "(forall ((s Schools)) (=> (not (delivery juices_truck Isley)) (not (and (delivery juices_truck Isley) (= (delivery_order juices_truck Isley) 3)))))",
        "(forall ((s Schools)) (=> (not (delivery juices_truck Isley)) (not (= (delivery_order juices_truck Isley) 3))))",
        "(forall ((s Schools)) (=> (not (and (delivery juices_truck Isley) (= (delivery_order juices_truck Isley) 3))) (not (and (delivery juices_truck Isley) (= (delivery_order juices_truck Isley) 3)))))",
        "(forall ((s Schools)) (=> (not (delivery juices_truck Isley)) (not (and (delivery juices_truck Isley) (= (delivery_order juices_truck Isley) 3)))))",
        "(forall ((s Schools)) (=> (delivery juices_truck Isley) (not (and (delivery juices_truck Isley) (= (delivery_order juices_truck Isley) 3)))))",
        "(forall ((s Schools)) (=> (not (and (delivery juices_truck Isley) (= (delivery_order juices_truck Isley) 3))) (not (delivery juices_truck Isley))))",
        "(forall ((s Schools)) (=> (not (delivery juices_truck Isley)) (delivery juices_truck Isley)))",
        "(forall ((s Schools)) (=> (delivery juices_truck Isley) (delivery juices_truck Isley)))"
      ],
      "options": [
        "(not (exists ((m Meals)) (= (eats Vladimir m) fish)))",
        "(not (exists ((m Meals)) (= (eats Vladimir m) hot_cakes)))",
        "(not (exists ((m Meals)) (= (eats Vladimir m) macaroni)))",
        "(not (exists ((m Meals)) (= (eats Vladimir m) omelet)))",
        "(not (exists ((m Meals)) (= (eats Vladimir m) poached_eggs)))"
      ],
      "type": "unsat",
      "perplexity": [
        1.0400586128234863,
        1.0748567581176758
      ],
      "answer": "A",
      "predicted_answer": [
        "unsat",
        "unsat",
        "unsat",
        "unsat",
        "unsat"
      ],
      "status": "success",
      "error": ""
    }
  }
]