#### Wrap SMTLIB2 program and solution type in JSON ####
root ::= "{" ws program ws type ws "}"

ws ::= [ \t\n\r]+

program ::= "\"program\":" ws "\"" smtlib2program "\""
type ::= "\"type\":" ws "\"" ("sat" | "unsat") "\""

#### Generate SMTLIB2 Program ####
smtlib2program ::= logicdecl declarations assertions checks

# Logic declaration
logicdecl ::= "(set-logic ALL)\n\n"

# Declarations section
declarations ::= datatypesdecls? functionsdecl? helpersdecl?

datatypesdecls ::= datatypesdecl ""
datatypesdecl ::= "(declare-datatypes ((" identifier " 0)) ((" constructorlist ")))"
constructorlist ::= constructor (" " constructor)*
constructor ::= "(" identifier ")"

functionsdecl ::= functiondecl ("\n" functiondecl)*
functiondecl ::= "(declare-fun " identifier " (" paramtypes ") " returntype ")"
paramtypes ::= identifier (" " identifier)*
returntype ::= identifier | "Bool" | "Int"

helpersdecl ::= "(define-fun " identifier " (" paramlist ") " returntype body ")"
paramlist ::= "(" param (" " param)* ")"
param ::= "(" [a-z] " " identifier ")"
body ::= expr

# Assertions section
assertions ::= "(assert " constraint ")"+ 

constraint ::= basicconstraint | forallconstraint | existsconstraint
basicconstraint ::= "(" comparison | booleanop | functioncall ")"
forallconstraint ::= "(forall (" boundvars ") " constraint ")"
existsconstraint ::= "(exists (" boundvars ") " constraint ")"

comparison ::= op expr expr
op ::= "= " | "> " | "< " | ">= " | "<= " | "distinct "
booleanop ::= "and " constraint+ | "or " constraint+ | "not " constraint
functioncall ::= identifier expr*

# Check-sat section with push/pop
checks ::= checkblock+
checkblock ::= "(push)\n" assertion "\n(check-sat)\n(pop)"
assertion ::= "(assert " constraint ")"

# Basic elements
identifier ::= [A-Za-z][A-Za-z0-9]*
expr ::= "(" number | identifier | functioncall | arithmeticexpr ")"
arithmeticexpr ::= arithop expr expr
arithop ::= "+ " | "- " | "* " | "/ "
number ::= [0-9]+

boundvars ::= "(" param ")"+