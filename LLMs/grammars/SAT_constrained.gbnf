#### Root structure defining the JSON output format ####
root ::= "{" ws declarations ws constraints ws options ws "}"

ws ::= [ \t\n\r]*

declarations ::= "\"declarations\":" ws "[" ws decllist ws "]," ws 
decllist ::= "\"" declaration "\"" (ws "," ws "\"" declaration "\"")*

constraints ::= "\"constraints\":" ws "[" ws constraintlist ws "],"
constraintlist ::= "\"" constraint "\"" (ws "," ws "\"" constraint "\"")*

options ::= "\"options\":" ws "[" ws optionlist ws "]"
optionlist ::= "\"" option "\"" (ws "," ws "\"" option "\"")*

# Declarations section
declaration ::= enumsortdecl | intsortdecl | functiondecl

enumsortdecl ::= identifier " = EnumSort([" enummembers "])"
enummembers ::= identifier (", " identifier)*

intsortdecl ::= identifier " = IntSort([" intmembers "])"
intmembers ::= number (", " number)*

functiondecl ::= identifier " = Function(" functionargs ")"
functionargs ::= "[" typelist "] -> [" type "]" | "[" typelist "]"
typelist ::= type (", " type)*
type ::= identifier | "int" | "bool"

# Constraints section
constraint ::= constraintexprBase constraintexprTail*
constraintexprBase ::= forallexpr | existsexpr | countexpr | distinctexpr | basicexpr
constraintexprTail ::= comparisonop constraintexprBase

countinsideexpr ::= basicexpr
distinctinsideexpr ::= basicexpr | countexpr
quantinsideexpr ::= countexpr | distinctexpr | basicexpr

forallexpr ::= "ForAll([" varbindings "], " quantinsideexpr ")"
existsexpr ::= "Exists([" varbindings "], " quantinsideexpr ")"
countexpr ::= "Count([" varbindings "], " countinsideexpr ")"
distinctexpr ::= "Distinct([" varbinding "], " distinctinsideexpr ")"

varbindings ::= varbinding (", " varbinding)*
varbinding ::= identifier ":" identifier

basicexpr ::= functioncall | atom

functioncall ::= identifier "(" arglist ")"
arglist ::= exprBase (", " exprBase)*
comparisonop ::= " == " | " != " | " <= " | " >= " | " < " | " > "

logicalexpr ::= logicalAnd | logicalOr | logicalNot
logicalAnd ::= "And(" exprlist ")"
logicalOr ::= "Or(" exprlist ")"
logicalNot ::= "Not(" exprBase ")"
exprlist ::= exprBase (", " exprBase)*

exprBase ::= atom exprTail*
exprTail ::= comparisonop exprBase
atom ::= identifier | number | functioncall | logicalexpr

# Options section
option ::= validitycheck
validitycheck ::= ("is_valid" | "is_unsat" | "is_sat" | "is_exception" | "is_accurate_list") "(" constraintexprBase ")"

# Basic elements
identifier ::= [a-z][a-z0-9]*
number ::= [0-9]+
text ::= [^\n]+
comment ::= [^\n]+