#### Root structure defining the JSON output format ####
root ::= "{" ws declarations ws constraints ws options ws "}"

ws ::= [ \t\n\r]*

declarations ::= "\"declarations\":" ws "[" ws decllist ws "]," ws 
decllist ::= "\"" declaration "\"" (ws "," ws "\"" declaration "\"")*

constraints ::= "\"constraints\":" ws "[" ws constraintlist ws "],"
constraintlist ::= "\"" constraint "\"" (ws "," ws "\"" constraint "\"")*

options ::= "\"options\":" ws "[" ws optionlist ws "]"
optionlist ::= "\"" option "\"" (ws "," ws "\"" option "\"")*

# Declarations section
declaration ::= enumsortdecl | intsortdecl | functiondecl

enumsortdecl ::= identifier " = EnumSort([" enummembers "])"
enummembers ::= identifier (", " identifier)*

intsortdecl ::= identifier " = IntSort([" intmembers "])"
intmembers ::= number (", " number)*

functiondecl ::= identifier " = Function(" functionargs ")"
functionargs ::= "[" identifierlist "] -> [" (identifier | "int" | "bool") "]"
identifierlist ::= identifier (", " identifier)*

# Constraints section
constraint ::= constraintBase constraintTail*
constraintBase ::= forallexpr | existsexpr | countexpr | distinctexpr | constraintexpr
constraintTail ::= comparisonop constraintBase

countinsideexpr ::= constraintexpr
distinctinsideexpr ::= constraintexpr | countexpr
quantinsideexpr ::= countexpr | distinctexpr | constraintexpr

forallexpr ::= "ForAll([" varbindings "], " quantinsideexpr ")"
existsexpr ::= "Exists([" varbindings "], " quantinsideexpr ")"
countexpr ::= "Count([" varbindings "], " countinsideexpr ")"
distinctexpr ::= "Distinct([" varbinding "], " distinctinsideexpr ")"

varbindings ::= varbinding (", " varbinding)*
varbinding ::= identifier ":" identifier

constraintexpr ::= functioncall | atom

functioncall ::= identifier "(" arglist ")"
arglist ::= atom (", " atom)*
comparisonop ::= " == " | " != " | " <= " | " >= " | " < " | " > "

logicalexpr ::= logicalAnd | logicalOr | logicalNot | logicalImplies
logicalAnd ::= "And(" exprlist ")"
logicalOr ::= "Or(" exprlist ")"
logicalNot ::= "Not(" expr ")"
logicalImplies ::= "Implies(" expr ", " expr ")"
exprlist ::= expr (", " expr)*

expr ::= comparisonexpr | atom
comparisonexpr ::= atom comparisonop atom
atom ::= identifier | number | functioncall | logicalexpr

# Options section
option ::= validitycheck
validitycheck ::= ("is_valid" | "is_unsat" | "is_sat" | "is_exception" | "is_accurate_list") "(" constraintBase ")"

# Basic elements
identifier ::= [a-z][a-z0-9]*
number ::= [0-9]+
text ::= [^\n]+
comment ::= [^\n]+