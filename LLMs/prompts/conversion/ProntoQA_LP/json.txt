Wrap the provided predicates, facts, rules and query in a valid JSON, with the following schema:
"""
\{
"predicates": [list of required Predicates],
"facts": [list of known Facts],
"rules": [list of generated Rules],
"query": [generated Query]
\}
"""

Here's an example of how to perform the conversion:

Predicates:

:- dynamic dumpus/1
:- dynamic impuses/1
:- dynamic jompus/1
:- dynamic numpus/1
:- dynamic rompus/1
:- dynamic tumpuses/1
:- dynamic vumpuses/1
:- dynamic wumpus/1
:- dynamic wumpuses/1
:- dynamic yumpus/1
:- dynamic shy/1

Facts:

tumpuses(alex).

Rules:

jompus(X) :- fruity(X).
jompus(X) :- wumpus(X).
wumpus(X) :- \\+transparent(X).
wumpuses(X) :- tumpuses(X).
tumpuses(X) :- mean(X).
tumpuses(X) :- vumpuses(X).
vumpuses(X) :- cold(X).
vumpuses(X) :- yumpus(X).
yumpus(X) :- orange(X).
yumpus(X) :- numpus(X).
numpus(X) :- dull(X).
numpus(X) :- dumpus(X).
dumpus(X) :- \\+shy(X).
impuses(X) :- shy(X).
dumpus(X) :- rompus(X).
rompus(X) :- liquid(X).
rompus(X) :- zumpus(X).

Query:
\\+shy(alex).

Output

{"predicates": [":- dynamic dumpus/1", ":- dynamic impuses/1", ":- dynamic jompus/1", ":- dynamic numpus/1", ":- dynamic rompus/1", ":- dynamic tumpuses/1", ":- dynamic vumpuses/1", ":- dynamic wumpus/1", ":- dynamic wumpuses/1", ":- dynamic yumpus/1", ":- dynamic shy/1"], "facts": ["tumpuses(alex)"], "rules": [ "jompus(X) :- fruity(X)", "jompus(X) :- wumpus(X)", "wumpus(X) :- \\+transparent(X)", "wumpuses(X) :- tumpuses(X)", "tumpuses(X) :- mean(X)", "tumpuses(X) :- vumpuses(X)", "vumpuses(X) :- cold(X)", "vumpuses(X) :- yumpus(X)", "yumpus(X) :- orange(X)", "yumpus(X) :- numpus(X)", "numpus(X) :- dull(X)", "numpus(X) :- dumpus(X)", "dumpus(X) :- \\+shy(X)", "impuses(X) :- shy(X)", "dumpus(X) :- rompus(X)", "rompus(X) :- liquid(X)", "rompus(X) :- zumpus(X)"], "query": "\\+shy(alex)."}

###

Now let's convert this problem:

[[unconstrained]]