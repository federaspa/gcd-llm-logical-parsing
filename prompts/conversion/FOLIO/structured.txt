Wrap the provided predicates, constants, FOL rules and FOL conclusion in a valid JSON, with the following schema:
"""
\{
"fol_preds": [list of required FOL Predicates],
"fol_consts": [list of required FOL Constants],
"fol_rules": [list of generated FOL Rules],
"fol_conc": [generated FOL Conclusion]
\}
"""

Here's an example of how to perform the conversion:

Predicates:
- Dependent(x): x is a person dependent on caffeine.
- Drinks(x): x regularly drinks coffee.
- Jokes(x): x jokes about being addicted to caffeine.
- Unaware(x): x is unaware that caffeine is a drug.
- Student(x): x is a student.

Constants:
- rina: Rina

FOL Rules:
- ∀x (Drinks(x) → Dependent(x)): All people who regularly drink coffee are dependent on caffeine. 
- ∀x (Drinks(x) ⊕ Jokes(x)): People either regularly drink coffee or joke about being addicted to caffeine. 
- ∀x (Jokes(x) → ¬Unaware(x)): No one who jokes about being addicted to caffeine is unaware that caffeine is a drug. 
- (Student(rina) ∧ Unaware(rina)) ⊕ ¬(Student(rina) ∨ Unaware(rina)): Rina is either a student and unaware that caffeine is a drug, or neither a student nor unaware that caffeine is a drug. 
- ¬(Dependent(rina) ∧ Student(rina)) → (Dependent(rina) ∧ Student(rina)) ⊕ ¬(Dependent(rina) ∨ Student(rina)): If Rina is not a person dependent on caffeine and a student, then Rina is either a person dependent on caffeine and a student, or neither a person dependent on caffeine nor a student.

FOL Conclusion:
- Jokes(rina) ⊕ Unaware(rina): Rina is either a person who jokes about being addicted to caffeine or is unaware that caffeine is a drug.

Output

{"fol_preds": ["Dependent(x)", "Drinks(x)", "Jokes(x)", "Unaware(x)", "Student(x)"],
"fol_consts": ["rina"],
"fol_rules": ["∀x (Drinks(x) → Dependent(x))", "∀x (Drinks(x) ⊕ Jokes(x))", "∀x (Jokes(x) → ¬Unaware(x))", "(Student(rina) ∧ Unaware(rina)) ⊕ ¬(Student(rina) ∨ Unaware(rina))", "¬(Dependent(rina) ∧ Student(rina)) → (Dependent(rina) ∧ Student(rina)) ⊕ ¬(Dependent(rina) ∨ Student(rina))"],
"fol_conc": "Jokes(rina) ⊕ Unaware(rina)"}

###

Here's another example:

Predicates:
- Project(x): x is a project
- Do(x, y): x is doing y
- WrittenIn(x, y): x is written in language y
- Use(x, y): x uses y
- Play(x, y): x plays y
- Song(x): x is a song
- Be(x, y): x is y

Constants:
- sam: Sam
- mac: Mac computer
- python: Python programming language
- rust: Rust programming language
- perfect: The song "Perfect"

FOL Rules:
- ∃x (Project(x) ∧ Do(sam, x)): Sam is doing a project.
- ∀x (Project(x) → (WrittenIn(x, python) ⊕ WrittenIn(x, rust))): A project is written either in Rust or in Python.
- ∀x (Project(x) ∧ WrittenIn(x, python) ∧ Do(sam, x) → ¬Use(sam, mac)): If Sam does a project written in Python, he will not use a Mac.
- Use(sam, mac): Sam is using a Mac.
- Use(sam, mac) → ∃x (Song(x) ∧ Play(sam, x)): If Sam uses a Mac, he will play a song.
- ∀x ((Song(x) ∧ ¬Be(x, perfect)) → ¬Play(sam, x)): If a song is not "Perfect", Sam will never play it.

FOL Conclusion:
- ∃x (Project(x) ∧ Do(sam, x) ∧ WrittenIn(x, rust)): The project Sam is doing is written in Rust.

Output:

{"fol_preds": ["Project(x)", "Do(x, y)", "WrittenIn(x, y)", "Use(x, y)", "Play(x, y)", "Song(x)", "Be(x, y)"],
  "fol_consts": ["sam", "mac", "python", "rust", "perfect"],
  "fol_rules": ["∃x (Project(x) ∧ Do(sam, x))", "∀x (Project(x) → (WrittenIn(x, python) ⊕ WrittenIn(x, rust)))", "∀x (Project(x) ∧ WrittenIn(x, python) ∧ Do(sam, x) → ¬Use(sam, mac))", "Use(sam, mac)", "Use(sam, mac) → ∃x (Song(x) ∧ Play(sam, x))", "∀x ((Song(x) ∧ ¬Be(x, perfect)) → ¬Play(sam, x))"],
  "fol_conc": "∃x (Project(x) ∧ Do(sam, x) ∧ WrittenIn(x, rust))"}
###

Now let's convert this problem:

[[unstructured]]