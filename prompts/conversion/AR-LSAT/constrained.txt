The task is to convert a natrual language reasoning problem into a SAT problem in SMTLIB2 format. Add comments to the code to explain what each part does. After writing the code, state whether to answer the question we are looking for a "sat" or an "unsat" result.
Do not attempt to solve the problem, limit yourself to converting.

You reply strictly in JSON format, with the following schema:
"""
\{"declarations": [list of declarations],
"constraints": [list of constraints],
"options": [list of options to check], 
"type": [solution we are looking for, either "sat" or "unsat"], 
\}
"""

Example 1:

NL problem:
"""
On Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.
"""

NL question:
"""
Vladimir must eat which one of the following foods?
Choices:
(A) fish
(B) hot cakes
(C) macaroni
(D) omelet
(E) poached eggs
"""

------

{"declarations": [
    "(declare-datatypes ((People 0)) (((Vladimir) (Wendy))))",
    "(declare-datatypes ((Meals 0)) (((breakfast) (lunch) (dinner) (snack))))",
    "(declare-datatypes ((Foods 0)) (((fish) (hot_cakes) (macaroni) (omelet) (poached_eggs))))",
    "(declare-fun eats (People Meals) Foods)"
  ],
  "constraints": [
    "(forall ((m Meals)) (not (= (eats Vladimir m) (eats Wendy m))))",
    "(forall ((p People) (f Foods)) (<= (+ (ite (= (eats p breakfast) f) 1 0) (ite (= (eats p lunch) f) 1 0) (ite (= (eats p dinner) f) 1 0) (ite (= (eats p snack) f) 1 0)) 1))",
    "(forall ((p People)) (or (= (eats p breakfast) hot_cakes) (= (eats p breakfast) poached_eggs) (= (eats p breakfast) omelet)))",
    "(forall ((p People)) (or (= (eats p lunch) fish) (= (eats p lunch) hot_cakes) (= (eats p lunch) macaroni) (= (eats p lunch) omelet)))",
    "(forall ((p People)) (or (= (eats p dinner) fish) (= (eats p dinner) hot_cakes) (= (eats p dinner) macaroni) (= (eats p dinner) omelet)))",
    "(forall ((p People)) (or (= (eats p snack) fish) (= (eats p snack) omelet)))",
    "(= (eats Wendy lunch) omelet)"
  ],
  "options": [
    "(not (exists ((m Meals)) (= (eats Vladimir m) fish)))",
    "(not (exists ((m Meals)) (= (eats Vladimir m) hot_cakes)))",
    "(not (exists ((m Meals)) (= (eats Vladimir m) macaroni)))",
    "(not (exists ((m Meals)) (= (eats Vladimir m) omelet)))",
    "(not (exists ((m Meals)) (= (eats Vladimir m) poached_eggs)))"
  ],
  "type": "unsat"}

###

Example 2:

NL problem:
"""
In a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.
"""

NL question:
"""
Which one of the following pairs of technicians could repair all and only the same types of machines as each other?
Choices:
(A) Stacy and Urma
(B) Urma and Yolanda
(C) Urma and Xena
(D) Wim and Xena
(E) Xena and Yolanda
"""

------

{"declarations": [
    "(declare-datatypes ((Technicians 0)) (((Stacy) (Urma) (Wim) (Xena) (Yolanda) (Zane))))",
    "(declare-datatypes ((Machines 0)) (((radios) (televisions) (VCRs))))",
    "(declare-fun repairs (Technicians Machines) Bool)",
    "(define-fun to-int ((b Bool)) Int (ite b 1 0))"
  ],
  "constraints": [
    "(forall ((t Technicians)) (>= (+ (to-int (repairs t radios)) (to-int (repairs t televisions)) (to-int (repairs t VCRs))) 1))",
    "(and (repairs Xena radios) (= (+ (to-int (and (distinct Stacy Xena) (repairs Stacy radios))) (to-int (and (distinct Urma Xena) (repairs Urma radios))) (to-int (and (distinct Wim Xena) (repairs Wim radios))) (to-int (and (distinct Yolanda Xena) (repairs Yolanda radios))) (to-int (and (distinct Zane Xena) (repairs Zane radios)))) 3))",
    "(and (repairs Yolanda televisions) (repairs Yolanda VCRs))",
    "(forall ((m Machines)) (=> (repairs Yolanda m) (not (repairs Stacy m))))",
    "(> (+ (to-int (repairs Zane radios)) (to-int (repairs Zane televisions)) (to-int (repairs Zane VCRs))) (+ (to-int (repairs Yolanda radios)) (to-int (repairs Yolanda televisions)) (to-int (repairs Yolanda VCRs))))",
    "(forall ((m Machines)) (=> (repairs Stacy m) (not (repairs Wim m))))",
    "(= (+ (to-int (repairs Urma radios)) (to-int (repairs Urma televisions)) (to-int (repairs Urma VCRs))) 2)"
  ],
  "options": [
    "(forall ((m Machines)) (= (repairs Stacy m) (repairs Urma m)))",
    "(forall ((m Machines)) (= (repairs Urma m) (repairs Yolanda m)))",
    "(forall ((m Machines)) (= (repairs Urma m) (repairs Xena m)))",
    "(forall ((m Machines)) (= (repairs Wim m) (repairs Xena m)))",
    "(forall ((m Machines)) (= (repairs Xena m) (repairs Yolanda m)))"
  ],
  "type": "sat"}

###

Now let's convert this problem to SMTLIB2:

NL problem:
"""
[[nl_problem]]
"""

NL question:
"""
[[nl_question]]
Choices:
[[choices]]
"""