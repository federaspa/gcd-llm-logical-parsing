The task is to convert a natrual language reasoning problem into first-order logic. 
First, identify the predicates and constants required to build the first order logic formulas. 
Then, use them to build the rules and the conclusion. 
Do not attempt to prove or disprove the conclusion, limit yourself to converting.
You reply strictly in JSON format, with the following schema:
"""
\{
"fol_preds": [list of required FOL Predicates],
"fol_consts": [list of required FOL Constants],
"fol_rules": [list of generated FOL Rules],
"fol_conc": [generated FOL Conclusion]
\}
"""

Here's an example of how to perform the conversion:

NL premises:
"""
Each jompus is fruity. Every jompus is a wumpus. Every wumpus is not transparent. Wumpuses are tumpuses. Tumpuses are mean. Tumpuses are vumpuses. Every vumpus is cold. Each vumpus is a yumpus. Yumpuses are orange. Yumpuses are numpuses. Numpuses are dull. Each numpus is a dumpus. Every dumpus is not shy. Impuses are shy. Dumpuses are rompuses. Each rompus is liquid. Rompuses are zumpuses. Alex is a tumpus.
"""

NL conclusion:
"""
Alex is not shy.
"""

------


{
  "predicates": [
    "Jompus($x, bool)",
    "Fruity($x, bool)",
    "Wumpus($x, bool)",
    "Transparent($x, bool)",
    "Tumpuses($x, bool)",
    "Mean($x, bool)",
    "Vumpuses($x, bool)",
    "Cold($x, bool)",
    "Yumpus($x, bool)",
    "Orange($x, bool)",
    "Numpus($x, bool)",
    "Dull($x, bool)",
    "Dumpus($x, bool)",
    "Shy($x, bool)",
    "Impuses($x, bool)",
    "Rompus($x, bool)",
    "Liquid($x, bool)",
    "Zumpus($x, bool)"
  ],
  "facts": [
    "Tumpuses(Alex, True)"
  ],
  "rules": [
    "Jompus($x, True) >>> Fruity($x, True)",
    "Jompus($x, True) >>> Wumpus($x, True)",
    "Wumpus($x, True) >>> Transparent($x, False)",
    "Wumpuses($x, True) >>> Tumpuses($x, True)",
    "Tumpuses($x, True) >>> Mean($x, True)",
    "Tumpuses($x, True) >>> Vumpuses($x, True)",
    "Vumpuses($x, True) >>> Cold($x, True)",
    "Vumpuses($x, True) >>> Yumpus($x, True)",
    "Yumpus($x, True) >>> Orange($x, True)",
    "Yumpus($x, True) >>> Numpus($x, True)",
    "Numpus($x, True) >>> Dull($x, True)",
    "Numpus($x, True) >>> Dumpus($x, True)",
    "Dumpus($x, True) >>> Shy($x, False)",
    "Impuses($x, True) >>> Shy($x, True)",
    "Dumpus($x, True) >>> Rompus($x, True)",
    "Rompus($x, True) >>> Liquid($x, True)",
    "Rompus($x, True) >>> Zumpus($x, True)"
  ],
  "query": "Shy(Alex, False)"
}

###

Here's another example:

NL premises:
"""
Anne is green. Charlie is big. Charlie is quiet. Charlie is rough. Charlie is smart. Charlie is white. Fiona is big. Fiona is furry. Fiona is smart. Harry is big. Harry is furry. Harry is quiet. Green things are quiet. Rough, quiet things are smart. If something is green and quiet then it is rough. Big, rough things are furry. If something is white then it is big. Quiet things are rough. If Charlie is big then Charlie is quiet. All green, furry things are white. Quiet, smart things are big.
"""

NL conclusion:
"""
Anne is big.
"""

------

{
  "fol_preds": [
    "Green(x)",
    "Big(x)",
    "Quiet(x)", 
    "Rough(x)",
    "Smart(x)",
    "White(x)",
    "Furry(x)"
  ],
  "fol_consts": [
    "anne",
    "charlie",
    "fiona",
    "harry"
  ],
  "fol_rules": [
    "Green(anne)",
    "Big(charlie)",
    "Quiet(charlie)",
    "Rough(charlie)",
    "Smart(charlie)",
    "White(charlie)",
    "Big(fiona)",
    "Furry(fiona)",
    "Smart(fiona)",
    "Big(harry)",
    "Furry(harry)",
    "Quiet(harry)",
    "∀x(Green(x) → Quiet(x))",
    "∀x(Rough(x) ∧ Quiet(x) → Smart(x))",
    "∀x(Green(x) ∧ Quiet(x) → Rough(x))",
    "∀x(Big(x) ∧ Rough(x) → Furry(x))",
    "∀x(White(x) → Big(x))",
    "∀x(Quiet(x) → Rough(x))",
    "Big(charlie) → Quiet(charlie)",
    "∀x(Green(x) ∧ Furry(x) → White(x))",
    "∀x(Quiet(x) ∧ Smart(x) → Big(x))"
  ],
  "fol_conc": "Big(anne)"
}

###

Now let's convert this problem to first-order logic:

NL premises:
"""
[[nl_problem]]
"""

NL conclusion:
"""
[[nl_conclusion]]
"""