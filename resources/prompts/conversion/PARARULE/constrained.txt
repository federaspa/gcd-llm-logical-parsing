The task is to convert a natrual language reasoning problem into first-order logic. 
First, identify the predicates and constants required to build the first order logic formulas. 
Then, use them to build the rules and the conclusion. 
Do not attempt to prove or disprove the conclusion, limit yourself to converting.

You reply strictly in JSON format, with the following schema:
"""
\{
"fol_preds": [list of required FOL Predicates],
"fol_consts": [list of required FOL Constants],
"fol_rules": [list of generated FOL Rules],
"fol_conc": [generated FOL Conclusion]
\}
"""

Here's an example of how to perform the conversion:

NL premises:
"""
Harry is strong
Harry is huge
Harry is big
Dave is little
Dave is short
Erin is quiet
Erin is kind
Erin is clever
Bob is dull
Bob is imperfect
Bob is poor
Strong people are quiet
If someone is little and short then they are tiny
If someone is dull and imperfect then they are sad
If someone is quiet and kind then they are wealthy
If someone is tiny then they are small
If someone is small then they are thin
If someone is thin then they are poor
All poor people are imperfect
If someone is quiet then they are kind
If someone is kind then they are clever
If someone is clever then they are high
All high people are heavy
If someone is wealthy then they are smart
If someone is smart then they are nice
If someone is nice then they are huge
All huge people are big
If someone is sad then they are rough
If someone is rough then they are bad
All bad people are short
All short people are little
"""

NL conclusion:
"""
Harry is heavy
"""

------

{"fol_preds": ["Strong(x)", "Huge(x)", "Big(x)", "Little(x)", "Short(x)", "Quiet(x)", "Kind(x)", "Clever(x)", "Dull(x)", "Imperfect(x)", "Poor(x)", "Tiny(x)", "Small(x)", "Thin(x)", "Sad(x)", "Wealthy(x)", "High(x)", "Heavy(x)", "Smart(x)", "Nice(x)", "Rough(x)", "Bad(x)"], "fol_consts": ["harry", "dave", "erin", "bob"], "fol_rules": ["Strong(harry)", "Huge(harry)", "Big(harry)", "Little(dave)", "Short(dave)", "Quiet(erin)", "Kind(erin)", "Clever(erin)", "Dull(bob)", "Imperfect(bob)", "Poor(bob)", "∀x(Strong(x) → Quiet(x))", "∀x((Little(x) ∧ Short(x)) → Tiny(x))", "∀x((Dull(x) ∧ Imperfect(x)) → Sad(x))", "∀x((Quiet(x) ∧ Kind(x)) → Wealthy(x))", "∀x(Tiny(x) → Small(x))", "∀x(Small(x) → Thin(x))", "∀x(Thin(x) → Poor(x))", "∀x(Poor(x) → Imperfect(x))", "∀x(Quiet(x) → Kind(x))", "∀x(Kind(x) → Clever(x))", "∀x(Clever(x) → High(x))", "∀x(High(x) → Heavy(x))", "∀x(Wealthy(x) → Smart(x))", "∀x(Smart(x) → Nice(x))", "∀x(Nice(x) → Huge(x))", "∀x(Huge(x) → Big(x))", "∀x(Sad(x) → Rough(x))", "∀x(Rough(x) → Bad(x))", "∀x(Bad(x) → Short(x))", "∀x(Short(x) → Little(x))" ], "fol_conc": "Heavy(harry)"}

###

Here's another example:

NL premises:
"""
The wolf is dull.
The wolf is sleepy.
The wolf is slow.
The wolf sees the mouse.
The bald eagle chases the rabbit.
The bald eagle is heavy.
The bald eagle is big.
The mouse is smart.
The mouse is kind.
The mouse is round.
The rabbit is lovely.
The rabbit is small.
The rabbit is cute.
Smart animals are lovely.
If something is sleepy then it attacks the mouse.
If something attacks the mouse then it is rough.
If something is dull and sleepy then it is slow.
If something is lovely and small then it is furry.
If something is heavy and big then it is awful.
All slow animals are lazy.
All lovely animals are small.
All awful animals are strong.
All furry animals are beautiful.

"""

NL conclusion:
"""
The mouse is small
"""

------

{"fol_preds": ["Dull(x)", "Sleepy(x)", "Slow(x)", "Heavy(x)", "Big(x)", "Smart(x)", "Kind(x)", "Round(x)", "Lovely(x)", "Small(x)", "Cute(x)", "Rough(x)", "Furry(x)", "Awful(x)", "Lazy(x)", "Strong(x)", "Beautiful(x)", "Sees(x,y)", "Chases(x,y)", "Attacks(x,y)"], "fol_consts": ["wolf", "mouse", "baldeagle", "rabbit"], "fol_rules": ["Dull(wolf)", "Sleepy(wolf)", "Slow(wolf)", "Sees(wolf, mouse)", "Chases(baldeagle, rabbit)", "Heavy(baldeagle)", "Big(baldeagle)", "Smart(mouse)", "Kind(mouse)", "Round(mouse)", "Lovely(rabbit)", "Small(rabbit)", "Cute(rabbit)", "∀x(Smart(x) → Lovely(x))", "∀x(Sleepy(x) → Attacks(x, mouse))", "∀x(Attacks(x, mouse) → Rough(x))", "∀x((Dull(x) ∧ Sleepy(x)) → Slow(x))", "∀x((Lovely(x) ∧ Small(x)) → Furry(x))", "∀x((Heavy(x) ∧ Big(x)) → Awful(x))", "∀x(Slow(x) → Lazy(x))", "∀x(Lovely(x) → Small(x))", "∀x(Awful(x) → Strong(x))", "∀x(Furry(x) → Beautiful(x))"], "fol_conc": ["Small(mouse)"]}

###

Now let's convert this problem to first-order logic:

NL premises:
"""
[[nl_problem]]
"""

NL conclusion:
"""
[[nl_conclusion]]
"""