[
    {
        "id": 2,
        "raw_prog": {
            "First-Order-Logic Rules": "∀x (Perform(x) → (Attend(x) ∧ Engaged(x))) ::: If people perform in school talent shows often, then they attend and are very engaged with school events.\n∀x ((Perform(x) ∨ (Inactive(x) ∧ Disinterested(x))) ::: People either perform in school talent shows often or are inactive and disinterested members of their community.\n∀x (Chaperone(x) → ¬Student(x)) ::: If people chaperone high school dances, then they are not students who attend the school.\n∀x ((Inactive(x) ∧ Disinterested(x)) → Chaperone(x)) ::: All people who are inactive and disinterested members of their community chaperone high school dances.\n∀x ((Young(x) ∨ Teenager(x)) ∧ Wish(x) → Student(x)) ::: All young children and teenagers who wish to further their academic careers and educational opportunities are students who attend the school.\n¬((Attend(Bonnie) ∧ Engaged(Bonnie)) ⊕ Student(Bonnie)) ::: Bonnie either both attends and is very engaged with school events and is a student who attends the school, or she neither attends and is very engaged with school events nor is a student who attends the school.\n",
            "First-Order-Logic Question": "((Chaperone(Bonnie) ∨ ¬Chaperone(Bonnie) ∧ Perform(Bonnie)) → ((Young(Bonnie) ∨ Teenager(Bonnie)) ∧ Wish(Bonnie) ∧ Inactive(Bonnie) ∧ Disinterested(Bonnie))) ::: If Bonnie either chaperones high school dances or, if she does not, she performs in school talent shows often, then Bonnie is both a young child or teenager who wishes to further her academic career and educational opportunities and an inactive and disinterested member of the community."
        },
        "gram_prog": {
            "First-Order-Logic Rules": "∀x (Perform(x) → (Attend(x) ∧ Engaged(x))) ::: If people perform in school talent shows often, then they attend and are very engaged with school events.\n∀x((Perform(x)∨Inactive(x))) ::: People either perform in school talent shows often or are inactive and disinterested members of their community.\n∀x (Chaperone(x) → ¬Student(x)) ::: If people chaperone high school dances, then they are not students who attend the school.\n∀x ((Inactive(x) ∧ Disinterested(x)) → Chaperone(x)) ::: All people who are inactive and disinterested members of their community chaperone high school dances.\n∀x ((Young(x) ∨ Teenager(x)) ∧ Wish(x) → Student(x)) ::: All young children and teenagers who wish to further their academic careers and educational opportunities are students who attend the school.\n¬((Attend(Bonnie) ∧ Engaged(Bonnie)) ⊕ Student(Bonnie)) ::: Bonnie either both attends and is very engaged with school events and is a student who attends the school, or she neither attends and is very engaged with school events nor is a student who attends the school.\n",
            "First-Order-Logic Question": "((Chaperone(Bonnie) ∨ ¬Chaperone(Bonnie) ∧ Perform(Bonnie)) → ((Young(Bonnie) ∨ Teenager(Bonnie)) ∧ Wish(Bonnie) ∧ Inactive(Bonnie) ∧ Disinterested(Bonnie))) ::: If Bonnie either chaperones high school dances or, if she does not, she performs in school talent shows often, then Bonnie is both a young child or teenager who wishes to further her academic career and educational opportunities and an inactive and disinterested member of the community."
        },
        "diff": [
            {
                "raw": "∀x ((Perform(x) ∨ (Inactive(x) ∧ Disinterested(x))) ::: People either perform in school talent shows often or are inactive and disinterested members of their community.",
                "gram": "∀x((Perform(x)∨Inactive(x))) ::: People either perform in school talent shows often or are inactive and disinterested members of their community."
            }
        ],
        "answer": "B",
        "grammar_answer": "C",
        "manual_prog": {
            "First-Order-Logic Rules": "∀x (Perform(x) → (Attend(x) ∧ Engaged(x))) ::: If people perform in school talent shows often, then they attend and are very engaged with school events.\n∀x ((Perform(x) ∨ (Inactive(x) ∧ Disinterested(x)))) ::: People either perform in school talent shows often or are inactive and disinterested members of their community.\n∀x (Chaperone(x) → ¬Student(x)) ::: If people chaperone high school dances, then they are not students who attend the school.\n∀x ((Inactive(x) ∧ Disinterested(x)) → Chaperone(x)) ::: All people who are inactive and disinterested members of their community chaperone high school dances.\n∀x ((Young(x) ∨ Teenager(x)) ∧ Wish(x) → Student(x)) ::: All young children and teenagers who wish to further their academic careers and educational opportunities are students who attend the school.\n¬((Attend(Bonnie) ∧ Engaged(Bonnie)) ⊕ Student(Bonnie)) ::: Bonnie either both attends and is very engaged with school events and is a student who attends the school, or she neither attends and is very engaged with school events nor is a student who attends the school.\n",
            "First-Order-Logic Question": "((Chaperone(Bonnie) ∨ ¬Chaperone(Bonnie) ∧ Perform(Bonnie)) → ((Young(Bonnie) ∨ Teenager(Bonnie)) ∧ Wish(Bonnie) ∧ Inactive(Bonnie) ∧ Disinterested(Bonnie))) ::: If Bonnie either chaperones high school dances or, if she does not, she performs in school talent shows often, then Bonnie is both a young child or teenager who wishes to further her academic career and educational opportunities and an inactive and disinterested member of the community."
        },
        "fixed": true
    },
    {
        "id": 52,
        "raw_prog": {
            "First-Order-Logic Rules": "∀x (Romance(x) → IndoEuropean(x)) ::: All Romance languages are Indo-European languages.\nLanguageFamily(romance) ::: The Romance languages are a language family.\n∀x ∀y (LanguageFamily(x) ∧ LanguageFamily(y) → Related(x, y)) ::: All languages within a language family are related to each other.\nRomance(french) ∧ Romance(spanish) ::: French and Spanish are both Romance languages.\nRelated(german, spanish) ::: German is related to Spanish.\nBasque ::: Basque is not related to any other language.",
            "First-Order-Logic Question": "Romance(basque) ::: Basque is a Romance language."
        },
        "gram_prog": {
            "First-Order-Logic Rules": "∀x (RomanceLanguage(x) → IndoEuropeanLanguage(x)) ::: All Romance languages are Indo-European languages.\nLanguageFamily(romance) ::: The Romance languages are a language family.\n∀x ∀y (LanguageFamily(x) ∧ LanguageFamily(y) → RelatedLanguages(x, y)) ::: All languages within a language family are related to each other.\nRomanceLanguage(french) ∧ RomanceLanguage(spanish) ::: French and Spanish are both Romance languages.\nRelatedLanguages(german, spanish) ::: German is related to Spanish.\nBasqueLanguage(x) → ¬RelatedLanguages(x,y) ::: Basque language is not related to any other language.",
            "First-Order-Logic Question": "RomanceLanguage(basque) ::: Basque language is a Romance language."
        },
        "diff": [
            {
                "raw": "∀x (Romance(x) → IndoEuropean(x)) ::: All Romance languages are Indo-European languages.",
                "gram": "∀x (RomanceLanguage(x) → IndoEuropeanLanguage(x)) ::: All Romance languages are Indo-European languages."
            },
            {
                "raw": "Romance(french) ∧ Romance(spanish) ::: French and Spanish are both Romance languages.",
                "gram": "RomanceLanguage(french) ∧ RomanceLanguage(spanish) ::: French and Spanish are both Romance languages."
            },
            {
                "raw": "Related(german, spanish) ::: German is related to Spanish.",
                "gram": "RelatedLanguages(german, spanish) ::: German is related to Spanish."
            },
            {
                "raw": "Basque ::: Basque is not related to any other language.",
                "gram": "BasqueLanguage(x) → ¬RelatedLanguages(x,y) ::: Basque language is not related to any other language."
            }
        ],
        "answer": "B",
        "grammar_answer": "C",
        "manual_prog": {
            "First-Order-Logic Rules": "∀x (Romance(x) → IndoEuropean(x)) ::: All Romance languages are Indo-European languages.\nLanguageFamily(romance) ::: The Romance languages are a language family.\n∀x ∀y (LanguageFamily(x) ∧ LanguageFamily(y) → Related(x, y)) ::: All languages within a language family are related to each other.\nRomance(french) ∧ Romance(spanish) ::: French and Spanish are both Romance languages.\nRelated(german, spanish) ::: German is related to Spanish.\n∀x (¬Related(x, basque)) ::: ∀x (¬Related(x, basque)) is not related to any other language.",
            "First-Order-Logic Question": "Romance(basque) ::: ∀x (¬Related(x, basque)) is a Romance language."
        },
        "fixed": true
    },
    {
        "id": 58,
        "raw_prog": {
            "First-Order-Logic Rules": "City(billings) ∧ City(butte) ∧ City(helena) ∧ City(missoula) ∧ City(whiteSulphurSprings) ∧ City(pierre) ∧ State(montana) ∧ State(southDakota) ∧ State(x) ∧ In(billings, montana) ∧ In(butte, montana) ∧ In(helena, montana) ∧ In(missoula, montana) ∧ In(whiteSulphurSprings, montana) ∧ In(butte, x) ∧ ¬In(pierre, southDakota) ∧ ∀x (In(x, butte) → ¬In(x, pierre)) ::: Billings is a city in Montana. Montana includes the cities of Butte, Helena, and Missoula. White Sulphur Springs and Butte are cities in the same state. The city of Pierre is not in Montana. Any city in Butte is not in Pierre.",
            "First-Order-Logic Question": "SameState(butte, pierre) ::: Butte and Pierre are in the same state."
        },
        "gram_prog": {
            "First-Order-Logic Rules": "City(x)→¬In(x,y)→¬In(y,z)→¬In(x,z) ::: Billings is a city in Montana. Montana includes the cities of Butte, Helena, and Missoula. White Sulphur Springs and Butte are cities in the same state. The city of Pierre is not in Montana. Any city in Butte is not in Pierre.",
            "First-Order-Logic Question": "SameState(butte, pierre) ::: Butte and Pierre are in the same state."
        },
        "diff": [
            {
                "raw": "City(billings) ∧ City(butte) ∧ City(helena) ∧ City(missoula) ∧ City(whiteSulphurSprings) ∧ City(pierre) ∧ State(montana) ∧ State(southDakota) ∧ State(x) ∧ In(billings, montana) ∧ In(butte, montana) ∧ In(helena, montana) ∧ In(missoula, montana) ∧ In(whiteSulphurSprings, montana) ∧ In(butte, x) ∧ ¬In(pierre, southDakota) ∧ ∀x (In(x, butte) → ¬In(x, pierre)) ::: Billings is a city in Montana. Montana includes the cities of Butte, Helena, and Missoula. White Sulphur Springs and Butte are cities in the same state. The city of Pierre is not in Montana. Any city in Butte is not in Pierre.",
                "gram": "City(x)→¬In(x,y)→¬In(y,z)→¬In(x,z) ::: Billings is a city in Montana. Montana includes the cities of Butte, Helena, and Missoula. White Sulphur Springs and Butte are cities in the same state. The city of Pierre is not in Montana. Any city in Butte is not in Pierre."
            }
        ],
        "answer": "B",
        "grammar_answer": "C",
        "manual_prog": {
            "First-Order-Logic Rules": "City(billings) ∧ City(butte) ∧ City(helena) ∧ City(missoula) ∧ City(whiteSulphurSprings) ∧ City(pierre) ∧ State(montana) ∧ State(southDakota) ∧ State(x) ∧ In(billings, montana) ∧ In(butte, montana) ∧ In(helena, montana) ∧ In(missoula, montana) ∧ In(whiteSulphurSprings, montana) ∧ In(butte, x) ∧ ¬In(pierre, southDakota) ∧ ∀x (In(x, butte) → ¬In(x, pierre)) ::: Billings is a city in Montana. Montana includes the cities of Butte, Helena, and Missoula. White Sulphur Springs and Butte are cities in the same state. The city of Pierre is not in Montana. Any city in Butte is not in Pierre.",
            "First-Order-Logic Question": "SameState(butte, pierre) ::: Butte and Pierre are in the same state."
        },
        "fixed": false
    },
    {
        "id": 93,
        "raw_prog": {
            "First-Order-Logic Rules": "∃x (Pet(x) ∧ AllowedIn(x, y)) ::: Pets are allowed in some managed buildings.\n∀x (RequireDeposit(x) → ∃y (RentApartment(z, y) ∧ SecurityDeposit(x) ∧ (Equal(SecurityDeposit(x), RentAmount(y)) ∨ MoreThan(SecurityDeposit(x), RentAmount(y))))) ::: A deposit is required to rent an apartment in a managed building. The security deposit can be either equal to one month's rent or more.\nCat(fluffy) ∧ Pet(fluffy) ∧ Owner(tom, fluffy) ::: Fluffy is Tom's cat.\nCat(x) → Pet(x) ::: Cats are pets.\nManagedBuilding(olivegarden) ::: The Olive Garden is a managed building.\nRentAmount(2000, olivegarden) ::: The monthly rent at the Olive Garden is $2000.\nRentApartment(tom, olivegarden) ↔ (AllowedIn(tom, olivegarden) ∧ SecurityDeposit(olivegarden) ∧ (Equal(SecurityDeposit(olivegarden), 1500) ∨ ¬MoreThan(SecurityDeposit(olivegarden), 1500))) ::: Tom will rent an apartment in a managed building if and only if he is allowed to move in with Fluffy, and the security deposit is no more than $1500.\nMoreThan(2000, 1500) ::: 2000$ is more than $1500.",
            "First-Order-Logic Question": "RentApartment(tom, olivegarden) ::: Tom will rent an apartment in The Olive Garden."
        },
        "gram_prog": {
            "First-Order-Logic Rules": "∃x (Pet(x) ∧ AllowedIn(x, y)) ::: Pets are allowed in some managed buildings.\nRequireDeposit(x)→¬(AllowedIn(x,y)∧ManagedBuilding(x)) ::: A deposit is required to rent an apartment in a managed building. The security deposit can be either equal to one month's rent or more.\nCat(fluffy) ∧ Pet(fluffy) ∧ Owner(tom, fluffy) ::: Fluffy is Tom's cat.\nCat(x) → Pet(x) ::: Cats are pets.\nManagedBuilding(olivegarden) ::: The Olive Garden is a managed building.\nRentAmount(2000, olivegarden) ::: The monthly rent at the Olive Garden is $2000.\nRentApartment(x,y)↔(AllowedIn(x,y)∧SecurityDeposit(y)) ::: Tom will rent an apartment in a managed building if and only if he is allowed to move in with Fluffy, and the security deposit is no more than $1500.\nMoreThan(2000, 1500) ::: 2000$ is more than $1500.",
            "First-Order-Logic Question": "RentApartment(tom, olivegarden) ::: Tom will rent an apartment in The Olive Garden."
        },
        "diff": [
            {
                "raw": "∀x (RequireDeposit(x) → ∃y (RentApartment(z, y) ∧ SecurityDeposit(x) ∧ (Equal(SecurityDeposit(x), RentAmount(y)) ∨ MoreThan(SecurityDeposit(x), RentAmount(y))))) ::: A deposit is required to rent an apartment in a managed building. The security deposit can be either equal to one month's rent or more.",
                "gram": "RequireDeposit(x)→¬(AllowedIn(x,y)∧ManagedBuilding(x)) ::: A deposit is required to rent an apartment in a managed building. The security deposit can be either equal to one month's rent or more."
            },
            {
                "raw": "RentApartment(tom, olivegarden) ↔ (AllowedIn(tom, olivegarden) ∧ SecurityDeposit(olivegarden) ∧ (Equal(SecurityDeposit(olivegarden), 1500) ∨ ¬MoreThan(SecurityDeposit(olivegarden), 1500))) ::: Tom will rent an apartment in a managed building if and only if he is allowed to move in with Fluffy, and the security deposit is no more than $1500.",
                "gram": "RentApartment(x,y)↔(AllowedIn(x,y)∧SecurityDeposit(y)) ::: Tom will rent an apartment in a managed building if and only if he is allowed to move in with Fluffy, and the security deposit is no more than $1500."
            }
        ],
        "answer": "B",
        "grammar_answer": "C",
        "manual_prog": {
            "First-Order-Logic Rules": "∃x (Pet(x) ∧ AllowedIn(x, y)) ::: Pets are allowed in some managed buildings.\n∀x ∃y ∃z (RequireDeposit(x) → (RentApartment(z, y) ∧ SecurityDeposit(x) ∧ (Equal(x,y) ∨ MoreThan(x,y)))) ::: A deposit is required to rent an apartment in a managed building. The security deposit can be either equal to one month's rent or more.\nCat(fluffy) ∧ Pet(fluffy) ∧ Owner(tom, fluffy) ::: Fluffy is Tom's cat.\nCat(x) → Pet(x) ::: Cats are pets.\nManagedBuilding(olivegarden) ::: The Olive Garden is a managed building.\nRentAmount(2000, olivegarden) ::: The monthly rent at the Olive Garden is $2000.\nRentApartment(tom, olivegarden) ↔ (AllowedIn(tom, olivegarden) ∧ SecurityDeposit(olivegarden) ∧ (Equal(olivegarden, 1500) ∨ ¬MoreThan(olivegarden, 1500))) ::: Tom will rent an apartment in a managed building if and only if he is allowed to move in with Fluffy, and the security deposit is no more than $1500.\nMoreThan(2000, 1500) ::: 2000$ is more than $1500.",
            "First-Order-Logic Question": "RentApartment(tom, olivegarden) ::: Tom will rent an apartment in The Olive Garden."
        },
        "fixed": true
    },
    {
        "id": 104,
        "raw_prog": {
            "First-Order-Logic Rules": "∀x (Twins(x) ∨ Triplets(x) → SpendTimeWith(x, x)) ::: If people are twins or triplets, then they spend a lot of time hanging out with and playing with their siblings.\n∀x (Siblings(x, y) → Twins(x) ∨ Triplets(x)) ::: If people have siblings who are the same age, then they are twins or triplets.\n∀x (Complain(x) → Siblings(x, y)) ::: If people complain often about annoying siblings, then they have siblings who are the same age.\n∀x (¬LiveAtHome(x) → ¬DevelopBonds(x, y)) ::: If people do not live at home regularly, then they do not develop strong bonds with their family members.\n∀x (SpendTimeWith(x, y) → ¬LiveAtHome(x)) ::: If people spend a lot of time hanging out with and playing with their siblings, then they often did not live at home regularly.\n(Twins(luke) ∧ DevelopBonds(luke, luke)) ⊕ (¬Twins(luke) ∧ ¬DevelopBonds(luke, luke)) ::: Luke is either both a twin or triplet and develops strong bonds with his family members, or he neither is a twin or triplet nor develops strong bonds with his family members.\n",
            "First-Order-Logic Question": "¬(Twins(luke) ∨ Triplets(luke) ∨ Complain(luke)) ::: Luke is neither a twin nor triplet nor complains often about annoying siblings."
        },
        "gram_prog": {
            "First-Order-Logic Rules": "∀x (Twins(x) ∨ Triplets(x) → SpendTimeWith(x, x)) ::: If people are twins or triplets, then they spend a lot of time hanging out with and playing with their siblings.\n∀x (Siblings(x, y) → Twins(x) ∨ Triplets(x)) ::: If people have siblings who are the same age, then they are twins or triplets.\n∀x (Complain(x) → Siblings(x, y)) ::: If people complain often about annoying siblings, then they have siblings who are the same age.\n∀x (¬LiveAtHome(x) → ¬DevelopBonds(x, y)) ::: If people do not live at home regularly, then they do not develop strong bonds with their family members.\n∀x (SpendTimeWith(x, y) → ¬LiveAtHome(x)) ::: If people spend a lot of time hanging out with and playing with their siblings, then they often did not live at home regularly.\n(Twins(luke) ∧ DevelopBonds(luke, luke)) ⊕ (¬Twins(luke) ∧ ¬DevelopBonds(luke, luke)) ::: Luke is either both a twin or triplet and develops strong bonds with his family members, or he neither is a twin or triplet nor develops strong bonds with his family members.\n",
            "First-Order-Logic Question": "¬(Twins(luke) ∨ Triplets(luke) ∨ Complain(luke)) ::: Luke is neither a twin nor triplet nor complains often about annoying siblings."
        },
        "diff": [],
        "answer": "A",
        "grammar_answer": "C",
        "manual_prog": {
            "First-Order-Logic Rules": "∀x (Twins(x) ∨ Triplets(x) → SpendTimeWith(x, x)) ::: If people are twins or triplets, then they spend a lot of time hanging out with and playing with their siblings.\n∀x (Siblings(x, y) → Twins(x) ∨ Triplets(x)) ::: If people have siblings who are the same age, then they are twins or triplets.\n∀x (Complain(x) → Siblings(x, y)) ::: If people complain often about annoying siblings, then they have siblings who are the same age.\n∀x (¬LiveAtHome(x) → ¬DevelopBonds(x, y)) ::: If people do not live at home regularly, then they do not develop strong bonds with their family members.\n∀x (SpendTimeWith(x, y) → ¬LiveAtHome(x)) ::: If people spend a lot of time hanging out with and playing with their siblings, then they often did not live at home regularly.\n(Twins(luke) ∧ DevelopBonds(luke, luke)) ⊕ (¬Twins(luke) ∧ ¬DevelopBonds(luke, luke)) ::: Luke is either both a twin or triplet and develops strong bonds with his family members, or he neither is a twin or triplet nor develops strong bonds with his family members.\n",
            "First-Order-Logic Question": "¬(Twins(luke) ∨ Triplets(luke) ∨ Complain(luke)) ::: Luke is neither a twin nor triplet nor complains often about annoying siblings."
        },
        "fixed": true
    },
    {
        "id": 124,
        "raw_prog": {
            "First-Order-Logic Rules": "∀x (Transport(x) → ¬Empty(x)) ::: If something can transport multiple passengers, then they are not empty. \n∀x (Airline(x) → Transport(x)) ::: All airlines can transport multiple passengers. \n∀x (Plane(x) → Empty(x)) ::: All planes are empty. \n∀x (Boeing707(x) → Plane(x)) ::: All Boeing 707s are planes. \nAirline(Greyhound) → ¬∃x (Greyhound(x) ∧ Plane(x)) ::: If Greyhound is not an airline, then there are no Greyhound planes.\n",
            "First-Order-Logic Question": "¬(Greyhound(x) ∧ Boeing707(x)) ::: A Greyhound is not a Boeing 707."
        },
        "gram_prog": {
            "First-Order-Logic Rules": "∀x (Transport(x) → ¬Empty(x)) ::: If something can transport multiple passengers, then they are not empty. \n∀x (Airline(x) → Transport(x)) ::: All airlines can transport multiple passengers. \n∀x (Plane(x) → Empty(x)) ::: All planes are empty. \n∀x (Boeing707(x) → Plane(x)) ::: All Boeing 707s are planes. \nAirline(x)→¬(Greyhound(x)∧Plane(x)) ::: If Greyhound is not an airline, then there are no Greyhound planes.\n",
            "First-Order-Logic Question": "¬(Greyhound(x) ∧ Boeing707(x)) ::: A Greyhound is not a Boeing 707."
        },
        "diff": [
            {
                "raw": "Airline(Greyhound) → ¬∃x (Greyhound(x) ∧ Plane(x)) ::: If Greyhound is not an airline, then there are no Greyhound planes.",
                "gram": "Airline(x)→¬(Greyhound(x)∧Plane(x)) ::: If Greyhound is not an airline, then there are no Greyhound planes."
            }
        ],
        "answer": "A",
        "grammar_answer": "C",
        "manual_prog": {
            "First-Order-Logic Rules": "∀x (Transport(x) → ¬Empty(x)) ::: If something can transport multiple passengers, then they are not empty. \n∀x (Airline(x) → Transport(x)) ::: All airlines can transport multiple passengers. \n∀x (Plane(x) → Empty(x)) ::: All planes are empty. \n∀x (Boeing707(x) → Plane(x)) ::: All Boeing 707s are planes. \n∀x ((Greyhound(x) ∧ ¬Airline(x)) → ¬Plane(x)) ::: If Greyhound is not an airline, then there are no Greyhound planes.\n",
            "First-Order-Logic Question": "¬(Greyhound(x) ∧ Boeing707(x)) ::: A Greyhound is not a Boeing 707."
        },
        "fixed": true
    },
    {
        "id": 128,
        "raw_prog": {
            "First-Order-Logic Rules": "∀x (HaveWedding(x) → HaveChild(x)) ::: All people who have a wedding are people who have at least one child.\n∀x (TravelToParis(x) → HaveWedding(x)) ::: All people who travel to Paris for their honeymoon are people who have a wedding.\n∀x (OccurIn(x, July) ∧ HaveWedding(x) → TravelToParis(x)) ::: All weddings that occur in July belong to people who travel to Paris for their honeymoon.\n∃x (OccurIn(x, July) ∧ WellAttended(x)) ::: Some weddings in July are well-attended.\nHaveChild(John) → (¬TravelToParis(John) ∧ ¬HaveWedding(John)) ::: If John has at least one child, then John does not travel to Paris for his honeymoon and does not have a wedding.\nHaveWedding(John) ∧ WellAttended(John) → (OccurIn(John, July) ∨ (¬OccurIn(John, July) → TravelToParis(John))) ::: If John has a wedding that is well-attended, then John has a wedding in July or, if not, then John travels to Paris for their honeymoon.",
            "First-Order-Logic Question": "WellAttended(John) ::: John has a wedding that is well-attended."
        },
        "gram_prog": {
            "First-Order-Logic Rules": "∀x (HaveWedding(x) → HaveChild(x)) ::: All people who have a wedding are people who have at least one child.\n∀x (TravelToParis(x) → HaveWedding(x)) ::: All people who travel to Paris for their honeymoon are people who have a wedding.\n∀x (OccurIn(x, July) ∧ HaveWedding(x) → TravelToParis(x)) ::: All weddings that occur in July belong to people who travel to Paris for their honeymoon.\n∃x (OccurIn(x, July) ∧ WellAttended(x)) ::: Some weddings in July are well-attended.\nHaveChild(John) → (¬TravelToParis(John) ∧ ¬HaveWedding(John)) ::: If John has at least one child, then John does not travel to Paris for his honeymoon and does not have a wedding.\nHaveWedding(John) ∧ WellAttended(John) → (OccurIn(John, July) ∨ (¬OccurIn(John, July) → TravelToParis(John))) ::: If John has a wedding that is well-attended, then John has a wedding in July or, if not, then John travels to Paris for their honeymoon.",
            "First-Order-Logic Question": "WellAttended(John) ::: John has a wedding that is well-attended."
        },
        "diff": [],
        "answer": "B",
        "grammar_answer": "C",
        "manual_prog": {
            "First-Order-Logic Rules": "∀x (HaveWedding(x) → HaveChild(x)) ::: All people who have a wedding are people who have at least one child.\n∀x (TravelToParis(x) → HaveWedding(x)) ::: All people who travel to Paris for their honeymoon are people who have a wedding.\n∀x (OccurIn(x, July) ∧ HaveWedding(x) → TravelToParis(x)) ::: All weddings that occur in July belong to people who travel to Paris for their honeymoon.\n∃x (OccurIn(x, July) ∧ WellAttended(x)) ::: Some weddings in July are well-attended.\nHaveChild(John) → (¬TravelToParis(John) ∧ ¬HaveWedding(John)) ::: If John has at least one child, then John does not travel to Paris for his honeymoon and does not have a wedding.\nHaveWedding(John) ∧ WellAttended(John) → (OccurIn(John, July) ∨ (¬OccurIn(John, July) → TravelToParis(John))) ::: If John has a wedding that is well-attended, then John has a wedding in July or, if not, then John travels to Paris for their honeymoon.",
            "First-Order-Logic Question": "WellAttended(John) ::: John has a wedding that is well-attended."
        },
        "fixed": true
    },
    {
        "id": 138,
        "raw_prog": {
            "First-Order-Logic Rules": "∀x (Algorithm(x) → (SupervisedLearning(x) ∨ UnsupervisedLearning(x) ∨ ReinforcementLearning(x))) ::: Machine Learning algorithms can be categorized as supervised learning, unsupervised learning, and reinforcement learning.\n∀x (UnsupervisedLearning(x) → ¬RequireLabelledData(x)) ::: Unsupervised learning doesn't require labelled data.\nStateOfTheArtModel(model) ∧ Algorithm(algo) ∧ TrainedWith(model, algo) ::: The state-of-the-art text summarization model is trained with machine learning algorithms.\nReinforcementLearning(rl) → ¬TrainedWith(StateOfTheArtModel(model), rl) ::: Reinforcement learning is not used to train the state-of-the-art text summarization model.\n∀x (Algorithm(x) ∧ TrainedWith(StateOfTheArtModel(model), x) → RequireLabelledData(x)) ::: The Machine Learning algorithm for training text summarization model requires labelled data.\n",
            "First-Order-Logic Question": "SupervisedLearning(supervised) ∧ TrainedWith(StateOfTheArtModel(model), supervised) ::: Supervised learning is used to train the state-of-the-art text summarization model."
        },
        "gram_prog": {
            "First-Order-Logic Rules": "∀x (Algorithm(x) → (SupervisedLearning(x) ∨ UnsupervisedLearning(x) ∨ ReinforcementLearning(x))) ::: Machine Learning algorithms can be categorized as supervised learning, unsupervised learning, and reinforcement learning.\n∀x (UnsupervisedLearning(x) → ¬RequireLabelledData(x)) ::: Unsupervised learning doesn't require labelled data.\nStateOfTheArtModel(model) ∧ Algorithm(algo) ∧ TrainedWith(model, algo) ::: The state-of-the-art text summarization model is trained with machine learning algorithms.\nReinforcementLearning(x)→¬TrainedWith(x,y) ::: Reinforcement learning is not used to train the state-of-the-art text summarization model.\nAlgorithm(x)∧TrainedWith(x,y)→RequireLabelledData(x) ::: The Machine Learning algorithm for training text summarization model requires labelled data.\n",
            "First-Order-Logic Question": "SupervisedLearning(x)→TrainedWith(x,y) ::: Supervised learning is used to train the state-of-the-art text summarization model."
        },
        "diff": [
            {
                "raw": "ReinforcementLearning(rl) → ¬TrainedWith(StateOfTheArtModel(model), rl) ::: Reinforcement learning is not used to train the state-of-the-art text summarization model.",
                "gram": "ReinforcementLearning(x)→¬TrainedWith(x,y) ::: Reinforcement learning is not used to train the state-of-the-art text summarization model."
            },
            {
                "raw": "∀x (Algorithm(x) ∧ TrainedWith(StateOfTheArtModel(model), x) → RequireLabelledData(x)) ::: The Machine Learning algorithm for training text summarization model requires labelled data.",
                "gram": "Algorithm(x)∧TrainedWith(x,y)→RequireLabelledData(x) ::: The Machine Learning algorithm for training text summarization model requires labelled data."
            }
        ],
        "answer": "A",
        "grammar_answer": "C",
        "manual_prog": {
            "First-Order-Logic Rules": "∀x (Algorithm(x) → (SupervisedLearning(x) ∨ UnsupervisedLearning(x) ∨ ReinforcementLearning(x))) ::: Machine Learning algorithms can be categorized as supervised learning, unsupervised learning, and reinforcement learning.\n∀x (UnsupervisedLearning(x) → ¬RequireLabelledData(x)) ::: Unsupervised learning doesn't require labelled data.\nStateOfTheArtModel(model) ∧ Algorithm(algo) ∧ TrainedWith(model, algo) ::: The state-of-the-art text summarization model is trained with machine learning algorithms.\nReinforcementLearning(rl) → (StateOfTheArtModel(model) ∧ ¬TrainedWith(model, rl)) ::: Reinforcement learning is not used to train the state-of-the-art text summarization model.\n∀x (Algorithm(x) ∧ StateOfTheArtModel(model) ∧ TrainedWith(model, x) → RequireLabelledData(x)) ::: The Machine Learning algorithm for training text summarization model requires labelled data.\n",
            "First-Order-Logic Question": "SupervisedLearning(supervised) ∧ StateOfTheArtModel(model) ∧ TrainedWith(model, supervised) ::: Supervised learning is used to train the state-of-the-art text summarization model."
        },
        "fixed": true
    },
    {
        "id": 155,
        "raw_prog": {
            "First-Order-Logic Rules": "∀x,y (Owns(x, y) → (WorkRegularly(x) ∧ WorkOften(x))) ::: If people own a large desktop monitor at their home, then they work regularly and often at home.\n∀x (FullyStocked(x) → Owns(x, largeDesktopMonitor) ∧ Impressive(x)) ::: All people who have a fully stocked and impressive home office are people who own a large desktop monitor at their home.\n∀x (WorkRegularly(x) ∧ WorkOften(x) → Tidy(x)) ::: All people who work regularly and often at home spend their free time tidying and organizing the spaces in their homes.\n∀x (WorkRegularly(x) ∧ WorkOften(x) → VisitStore(x)) ::: All people who work regularly and often at home visit the office supply store regularly.\n∀x (Tidy(x) → (¬Late(x) ∧ ¬WakeLate(x))) ::: If people spend their free time tidying and organizing the spaces in their home, then they do not go to bed late and wake up every day after noon.\n(Tidy(remy) ∧ Late(remy) ∧ WakeLate(remy)) ⊕ (¬Late(remy) ∧ ¬WakeLate(remy) ∧ ¬Tidy(remy)) ::: Remy either both goes to bed late and wakes up every day after noon and spends their free time tidying and organizing the spaces in their home, or they do not go to bed late and wake up every day after noon nor spend their free time tidying and organizing the spaces in their home.\n",
            "First-Order-Logic Question": "((Late(remy) ∧ WakeLate(remy)) ∨ VisitStore(remy)) → (¬Tidy(remy) ∧ ¬FullyStocked(remy)) ::: If Remy either goes to bed late and wakes up every day after noon or visits the office supply store regularly, then Remy neither spends their free time tidying and organizing the spaces in their home nor has a fully stocked and impressive home office."
        },
        "gram_prog": {
            "First-Order-Logic Rules": "∀x(Owns(x,y)→(WorkRegularly(x))) ::: If people own a large desktop monitor at their home, then they work regularly and often at home.\n∀x (FullyStocked(x) → Owns(x, largeDesktopMonitor) ∧ Impressive(x)) ::: All people who have a fully stocked and impressive home office are people who own a large desktop monitor at their home.\n∀x (WorkRegularly(x) ∧ WorkOften(x) → Tidy(x)) ::: All people who work regularly and often at home spend their free time tidying and organizing the spaces in their homes.\n∀x (WorkRegularly(x) ∧ WorkOften(x) → VisitStore(x)) ::: All people who work regularly and often at home visit the office supply store regularly.\n∀x (Tidy(x) → (¬Late(x) ∧ ¬WakeLate(x))) ::: If people spend their free time tidying and organizing the spaces in their home, then they do not go to bed late and wake up every day after noon.\n(Tidy(remy) ∧ Late(remy) ∧ WakeLate(remy)) ⊕ (¬Late(remy) ∧ ¬WakeLate(remy) ∧ ¬Tidy(remy)) ::: Remy either both goes to bed late and wakes up every day after noon and spends their free time tidying and organizing the spaces in their home, or they do not go to bed late and wake up every day after noon nor spend their free time tidying and organizing the spaces in their home.\n",
            "First-Order-Logic Question": "((Late(remy) ∧ WakeLate(remy)) ∨ VisitStore(remy)) → (¬Tidy(remy) ∧ ¬FullyStocked(remy)) ::: If Remy either goes to bed late and wakes up every day after noon or visits the office supply store regularly, then Remy neither spends their free time tidying and organizing the spaces in their home nor has a fully stocked and impressive home office."
        },
        "diff": [
            {
                "raw": "∀x,y (Owns(x, y) → (WorkRegularly(x) ∧ WorkOften(x))) ::: If people own a large desktop monitor at their home, then they work regularly and often at home.",
                "gram": "∀x(Owns(x,y)→(WorkRegularly(x))) ::: If people own a large desktop monitor at their home, then they work regularly and often at home."
            }
        ],
        "answer": "A",
        "grammar_answer": "C",
        "manual_prog": {
            "First-Order-Logic Rules": "∀x ∀y (Owns(x, y) → (WorkRegularly(x) ∧ WorkOften(x))) ::: If people own a large desktop monitor at their home, then they work regularly and often at home.\n∀x (FullyStocked(x) → Owns(x, largeDesktopMonitor) ∧ Impressive(x)) ::: All people who have a fully stocked and impressive home office are people who own a large desktop monitor at their home.\n∀x (WorkRegularly(x) ∧ WorkOften(x) → Tidy(x)) ::: All people who work regularly and often at home spend their free time tidying and organizing the spaces in their homes.\n∀x (WorkRegularly(x) ∧ WorkOften(x) → VisitStore(x)) ::: All people who work regularly and often at home visit the office supply store regularly.\n∀x (Tidy(x) → (¬Late(x) ∧ ¬WakeLate(x))) ::: If people spend their free time tidying and organizing the spaces in their home, then they do not go to bed late and wake up every day after noon.\n(Tidy(remy) ∧ Late(remy) ∧ WakeLate(remy)) ⊕ (¬Late(remy) ∧ ¬WakeLate(remy) ∧ ¬Tidy(remy)) ::: Remy either both goes to bed late and wakes up every day after noon and spends their free time tidying and organizing the spaces in their home, or they do not go to bed late and wake up every day after noon nor spend their free time tidying and organizing the spaces in their home.\n",
            "First-Order-Logic Question": "((Late(remy) ∧ WakeLate(remy)) ∨ VisitStore(remy)) → (¬Tidy(remy) ∧ ¬FullyStocked(remy)) ::: If Remy either goes to bed late and wakes up every day after noon or visits the office supply store regularly, then Remy neither spends their free time tidying and organizing the spaces in their home nor has a fully stocked and impressive home office."
        },
        "fixed": true
    },
    {
        "id": 166,
        "raw_prog": {
            "First-Order-Logic Rules": "∃x ∃y (Monday(y) ∧ Time(y) ∧ Roses(x) ∧ GivenOut(x, y)) ::: On some Mondays at 8 pm, roses are given out on TV.\n∀x (Roses(x) → On(x, Bachelor)) ::: Every rose given out on TV is on the Bachelor.\n∀x (On(x, Bachelor) → Portray(x, RealPeople)) ::: Everything on the Bachelor portrays the lives of real people.\n∀x (Portray(x, RealPeople) → RealityTVShow(x)) ::: All shows portraying the lives of real people are reality TV shows.\n¬RealityTVShow(BreakingBad) ::: Breaking Bad is not a reality TV show.\n",
            "First-Order-Logic Question": "∀x (Roses(x) ∧ GivenOut(x, Monday(8pm))) → On(BreakingBad, Monday(8pm)) ::: If roses are given out during Breaking Bad, then it is on Monday at 8 pm."
        },
        "gram_prog": {
            "First-Order-Logic Rules": "∃x ∃y (Monday(y) ∧ Time(y) ∧ Roses(x) ∧ GivenOut(x, y)) ::: On some Mondays at 8 pm, roses are given out on TV.\n∀x (Roses(x) → On(x, Bachelor)) ::: Every rose given out on TV is on the Bachelor.\n∀x (On(x, Bachelor) → Portray(x, RealPeople)) ::: Everything on the Bachelor portrays the lives of real people.\n∀x (Portray(x, RealPeople) → RealityTVShow(x)) ::: All shows portraying the lives of real people are reality TV shows.\n¬RealityTVShow(BreakingBad) ::: Breaking Bad is not a reality TV show.\n",
            "First-Order-Logic Question": "∀x(Roses(x)∧GivenOut(x,y)→On(x,y)) ::: If roses are given out during Breaking Bad, then it is on Monday at 8 pm."
        },
        "diff": [],
        "answer": "A",
        "grammar_answer": "C",
        "manual_prog": {
            "First-Order-Logic Rules": "∃x ∃y (Monday(y) ∧ Time(y) ∧ Roses(x) ∧ GivenOut(x, y)) ::: On some Mondays at 8 pm, roses are given out on TV.\n∀x (Roses(x) → On(x, Bachelor)) ::: Every rose given out on TV is on the Bachelor.\n∀x (On(x, Bachelor) → Portray(x, RealPeople)) ::: Everything on the Bachelor portrays the lives of real people.\n∀x (Portray(x, RealPeople) → RealityTVShow(x)) ::: All shows portraying the lives of real people are reality TV shows.\n¬RealityTVShow(BreakingBad) ::: Breaking Bad is not a reality TV show.\n",
            "First-Order-Logic Question": "∀x (Roses(x) ∧ Monday(y) ∧ GivenOut(x, y)) → On(BreakingBad, y) ::: If roses are given out during Breaking Bad, then it is on Monday at 8 pm."
        },
        "fixed": true
    },
    {
        "id": 181,
        "raw_prog": {
            "First-Order-Logic Rules": "Flies(susan, LGA) ::: Susan flies to LGA airport.\n∀x (Airport(x) ∧ Flies(john, x) ∧ ¬(DepartsFrom(john, x) ∧ ArrivesAt(john, x))) ::: The departure and arrival can not be the same airport.\n",
            "First-Order-Logic Question": "Flies(john, LGA) ::: John flies to LGA airport."
        },
        "gram_prog": {
            "First-Order-Logic Rules": "Flies(susan, LGA) ::: Susan flies to LGA airport.\n∀x (Airport(x) ∧ Flies(john, x) ∧ ¬(DepartsFrom(john, x) ∧ ArrivesAt(john, x))) ::: The departure and arrival can not be the same airport.\n",
            "First-Order-Logic Question": "Flies(john, LGA) ::: John flies to LGA airport."
        },
        "diff": [],
        "answer": "B",
        "grammar_answer": "A",
        "manual_prog": {
            "First-Order-Logic Rules": "Flies(susan, LGA) ::: Susan flies to LGA airport.\n∀x (Airport(x) ∧ Flies(john, x) ∧ ¬(DepartsFrom(john, x) ∧ ArrivesAt(john, x))) ::: The departure and arrival can not be the same airport.\n",
            "First-Order-Logic Question": "Flies(john, LGA) ::: John flies to LGA airport."
        },
        "fixed": true
    },
    {
        "id": 1,
        "raw_prog": {
            "First-Order-Logic Rules": "∀x (Perform(x) → (Attend(x) ∧ Engaged(x))) ::: If people perform in school talent shows often, then they attend and are very engaged with school events.\n∀x ((Perform(x) ∨ (Inactive(x) ∧ Disinterested(x))) ::: People either perform in school talent shows often or are inactive and disinterested members of their community.\n∀x (Chaperone(x) → ¬Student(x)) ::: If people chaperone high school dances, then they are not students who attend the school.\n∀x ((Inactive(x) ∧ Disinterested(x)) → Chaperone(x)) ::: All people who are inactive and disinterested members of their community chaperone high school dances.\n∀x ((Young(x) ∨ Teenager(x)) ∧ Wish(x) → Student(x)) ::: All young children and teenagers who wish to further their academic careers and educational opportunities are students who attend the school.\n¬((Attend(Bonnie) ∧ Engaged(Bonnie)) ⊕ Student(Bonnie)) ::: Bonnie either both attends and is very engaged with school events and is a student who attends the school, or she neither attends and is very engaged with school events nor is a student who attends the school.",
            "First-Order-Logic Question": "((Young(Bonnie) ∨ Teenager(Bonnie)) ∧ Wish(Bonnie) ∧ Chaperone(Bonnie)) ∨ ¬((Young(Bonnie) ∨ Teenager(Bonnie)) ∧ ¬Wish(Bonnie)) → (Student(Bonnie) ∨ (Inactive(Bonnie) ∧ Disinterested(Bonnie)))"
        },
        "gram_prog": {
            "First-Order-Logic Rules": "∀x (Perform(x) → (Attend(x) ∧ Engaged(x))) ::: If people perform in school talent shows often, then they attend and are very engaged with school events.\n∀x((Perform(x)∨Inactive(x))) ::: People either perform in school talent shows often or are inactive and disinterested members of their community.\n∀x (Chaperone(x) → ¬Student(x)) ::: If people chaperone high school dances, then they are not students who attend the school.\n∀x ((Inactive(x) ∧ Disinterested(x)) → Chaperone(x)) ::: All people who are inactive and disinterested members of their community chaperone high school dances.\n∀x ((Young(x) ∨ Teenager(x)) ∧ Wish(x) → Student(x)) ::: All young children and teenagers who wish to further their academic careers and educational opportunities are students who attend the school.\n¬((Attend(Bonnie) ∧ Engaged(Bonnie)) ⊕ Student(Bonnie)) ::: Bonnie either both attends and is very engaged with school events and is a student who attends the school, or she neither attends and is very engaged with school events nor is a student who attends the school.",
            "First-Order-Logic Question": "((Young(Bonnie) ∨ Teenager(Bonnie)) ∧ Wish(Bonnie) ∧ Chaperone(Bonnie)) ∨ ¬((Young(Bonnie) ∨ Teenager(Bonnie)) ∧ ¬Wish(Bonnie)) → (Student(Bonnie) ∨ (Inactive(Bonnie) ∧ Disinterested(Bonnie)))"
        },
        "diff": [
            {
                "raw": "∀x ((Perform(x) ∨ (Inactive(x) ∧ Disinterested(x))) ::: People either perform in school talent shows often or are inactive and disinterested members of their community.",
                "gram": "∀x((Perform(x)∨Inactive(x))) ::: People either perform in school talent shows often or are inactive and disinterested members of their community."
            }
        ],
        "answer": "A",
        "grammar_answer": "C",
        "manual_prog": {
            "First-Order-Logic Rules": "∀x (Perform(x) → (Attend(x) ∧ Engaged(x))) ::: If people perform in school talent shows often, then they attend and are very engaged with school events.\n∀x ((Perform(x) ∨ (Inactive(x) ∧ Disinterested(x)))) ::: People either perform in school talent shows often or are inactive and disinterested members of their community.\n∀x (Chaperone(x) → ¬Student(x)) ::: If people chaperone high school dances, then they are not students who attend the school.\n∀x ((Inactive(x) ∧ Disinterested(x)) → Chaperone(x)) ::: All people who are inactive and disinterested members of their community chaperone high school dances.\n∀x ((Young(x) ∨ Teenager(x)) ∧ Wish(x) → Student(x)) ::: All young children and teenagers who wish to further their academic careers and educational opportunities are students who attend the school.\n¬((Attend(Bonnie) ∧ Engaged(Bonnie)) ⊕ Student(Bonnie)) ::: Bonnie either both attends and is very engaged with school events and is a student who attends the school, or she neither attends and is very engaged with school events nor is a student who attends the school.",
            "First-Order-Logic Question": "((Young(Bonnie) ∨ Teenager(Bonnie)) ∧ Wish(Bonnie) ∧ Chaperone(Bonnie)) ∨ ¬((Young(Bonnie) ∨ Teenager(Bonnie)) ∧ ¬Wish(Bonnie)) → (Student(Bonnie) ∨ (Inactive(Bonnie) ∧ Disinterested(Bonnie)))"
        },
        "fixed": true
    },
    {
        "id": 13,
        "raw_prog": {
            "First-Order-Logic Rules": "Create(japaneseGameCompany, legendOfZelda) ::: A Japanese game company created the game the Legend of Zelda.\n∀x (Game(x) ∧ Sell(x, moreThanOneMillion) → Select(x, Top10(x))) ::: If a game sells more than one million copies, then it will be selected into the Top 10 list.\nSelect(legendOfZelda, Top10) ::: The Legend of Zelda sold more than one million copies and is selected into the Top 10 list.\n",
            "First-Order-Logic Question": "Create(japaneseVideoGameCompany, FIFA22) ::: FIFA 22 is made by a Japanese video game company."
        },
        "gram_prog": {
            "First-Order-Logic Rules": "Create(japaneseGameCompany, legendOfZelda) ::: A Japanese game company created the game the Legend of Zelda.\n∀x(Game(x)→Select(x,y))∧¬(Create(x,y)→Sell(x,y)) ::: If a game sells more than one million copies, then it will be selected into the Top 10 list.\nSelect(legendOfZelda, Top10) ::: The Legend of Zelda sold more than one million copies and is selected into the Top 10 list.\n",
            "First-Order-Logic Question": "Create(japaneseVideoGameCompany, FIFA22) ::: FIFA 22 is made by a Japanese video game company."
        },
        "diff": [
            {
                "raw": "∀x (Game(x) ∧ Sell(x, moreThanOneMillion) → Select(x, Top10(x))) ::: If a game sells more than one million copies, then it will be selected into the Top 10 list.",
                "gram": "∀x(Game(x)→Select(x,y))∧¬(Create(x,y)→Sell(x,y)) ::: If a game sells more than one million copies, then it will be selected into the Top 10 list."
            }
        ],
        "answer": "C",
        "grammar_answer": "A",
        "manual_prog": {
            "First-Order-Logic Rules": "Create(japaneseGameCompany, legendOfZelda) ::: A Japanese game company created the game the Legend of Zelda.\n∀x (Game(x) ∧ Sell(x, moreThanOneMillion) → Select(x, Top10)) ::: If a game sells more than one million copies, then it will be selected into the Top 10 list.\nSelect(legendOfZelda, Top10) ::: The Legend of Zelda sold more than one million copies and is selected into the Top 10 list.\n",
            "First-Order-Logic Question": "Create(japaneseVideoGameCompany, FIFA22) ::: FIFA 22 is made by a Japanese video game company."
        },
        "fixed": true
    },
    {
        "id": 46,
        "raw_prog": {
            "First-Order-Logic Rules": "∀x (Season(x) → (Spring(x) ∨ Summer(x) ∨ Fall(x) ∨ Winter(x))) ::: There are four seasons in a year: Spring, Summer, Fall, and Winter. \n∀x (Student(x) ∧ WantLongVacation(x) → Love(x, Summer)) ::: All students who want to have a long vacation love summer the most. \nFavoriteSeason(emma, Summer) ::: Emma's favorite season is summer. \n∀x (Student(mia) ∧ NotSame(FavoriteSeason(mia, emma), emma)) ::: Mia's favorite season is not the same as Emma's. \nWantLongVacation(james) ::: James wants to have a long vacation.",
            "First-Order-Logic Question": "FavoriteSeason(james, Summer) ::: James's favorite season is summer."
        },
        "gram_prog": {
            "First-Order-Logic Rules": "∀x (Season(x) → (Spring(x) ∨ SeasonSummer(x) ∨ Fall(x) ∨ Winter(x))) ::: There are four seasons in a year: Spring, Summer, Fall, and Winter. \n∀x (Student(x) ∧ WantLongVacation(x) → Love(x, SeasonSummer)) ::: All students who want to have a long vacation love summer the most. \nFavoriteSeason(emma, SeasonSummer) ::: Emma's favorite season is summer. \nStudent(x) ∧ NotSame(x,y) → FavoriteSeason(x,y) ::: Mia's favorite season is not the same as Emma's. \nWantLongVacation(james) ::: James wants to have a long vacation.",
            "First-Order-Logic Question": "FavoriteSeason(james, SeasonSummer) ::: James's favorite season is summer."
        },
        "diff": [
            {
                "raw": "∀x (Student(mia) ∧ NotSame(FavoriteSeason(mia, emma), emma)) ::: Mia's favorite season is not the same as Emma's. ",
                "gram": "Student(x) ∧ NotSame(x,y) → FavoriteSeason(x,y) ::: Mia's favorite season is not the same as Emma's. "
            }
        ],
        "answer": "A",
        "grammar_answer": "C",
        "manual_prog": {
            "First-Order-Logic Rules": "∀x (Season(x) → (Spring(x) ∨ Summer(x) ∨ Fall(x) ∨ Winter(x))) ::: There are four seasons in a year: Spring, Summer, Fall, and Winter. \n∀x (Student(x) ∧ WantLongVacation(x) → Love(x, Summer)) ::: All students who want to have a long vacation love summer the most. \nFavoriteSeason(emma, Summer) ::: Emma's favorite season is summer. \n∀x (FavoriteSeason(mia, x) → ¬FavoriteSeason(mia, x)) ::: Mia's favorite season is not the same as Emma's. \nWantLongVacation(james) ::: James wants to have a long vacation.",
            "First-Order-Logic Question": "FavoriteSeason(james, Summer) ::: James's favorite season is summer."
        },
        "fixed": true
    },
    {
        "id": 68,
        "raw_prog": {
            "First-Order-Logic Rules": "PrivateUniversity(yaleuniversity) ∧ IvyLeagueUniversity(yaleuniversity) ∧ ResearchUniversity(yaleuniversity) ::: Yale University is a private Ivy League research university.\nMove(yaleuniversity, newhaven, 1716) ::: Yale University moved to New Haven in 1716.\nEndowment(yaleuniversity, 42.3billion) ::: Yale university's endowment was valued at $42.3 billion.\nOrganize(yaleuniversity, List([residentialcolleges, yalegraduate, professionalschools])) ∧ List(residentialcolleges, [benjaminfranklin, berkeley, branford, davenport, ezrastiles, gracehopper, jonathanedwards, morse, paulimurray, pierson, saybrook, silliman, timothydwight, trumbull]) ::: Yale University has been organized into 27 constituent colleges and schools: the residential colleges, the Yale Graduate School of Arts and Sciences, and twelve professional schools.\n",
            "First-Order-Logic Question": "ResidentialCollege(pierson) ∧ College(pierson) ∧ YaleUniversity ::: Pierson College is a residential college at Yale."
        },
        "gram_prog": {
            "First-Order-Logic Rules": "PrivateUniversity(yaleuniversity) ∧ IvyLeagueUniversity(yaleuniversity) ∧ ResearchUniversity(yaleuniversity) ::: Yale University is a private Ivy League research university.\nMove(yaleuniversity, newhaven, 1716) ::: Yale University moved to New Haven in 1716.\nEndowment(yaleuniversity, billion42_3) ::: Yale university's endowment was valued at $42.3 billion.\nOrganize(y,y)→List(y,y) ::: Yale University has been organized into 27 constituent colleges and schools: the residential colleges, the Yale Graduate School of Arts and Sciences, and twelve professional schools.",
            "First-Order-Logic Question": "ResidentialCollege(x)→College(x)→YaleUniversity(x) ::: Pierson College is a residential college at Yale."
        },
        "diff": [],
        "answer": "A",
        "grammar_answer": "C",
        "manual_prog": {
            "First-Order-Logic Rules": "PrivateUniversity(yaleuniversity) ∧ IvyLeagueUniversity(yaleuniversity) ∧ ResearchUniversity(yaleuniversity) ::: Yale University is a private Ivy League research university.\nMove(yaleuniversity, newhaven, 1716) ::: Yale University moved to New Haven in 1716.\nEndowment(yaleuniversity, 42.3billion) ::: Yale university's endowment was valued at $42.3 billion.\nOrganize(yaleuniversity, List([residentialcolleges, yalegraduate, professionalschools])) ∧ List(residentialcolleges, [benjaminfranklin, berkeley, branford, davenport, ezrastiles, gracehopper, jonathanedwards, morse, paulimurray, pierson, saybrook, silliman, timothydwight, trumbull]) ::: Yale University has been organized into 27 constituent colleges and schools: the residential colleges, the Yale Graduate School of Arts and Sciences, and twelve professional schools.\n",
            "First-Order-Logic Question": "ResidentialCollege(pierson) ∧ College(pierson) ∧ YaleUniversity ::: Pierson College is a residential college at Yale."
        },
        "fixed": false
    },
    {
        "id": 103,
        "raw_prog": {
            "First-Order-Logic Rules": "∀x (Twins(x) ∨ Triplets(x) → SpendTimeWith(x, Siblings(x))) ::: If people are twins or triplets, then they spend a lot of time hanging out with and playing with their siblings.\n∀x (Siblings(x, y) → Twins(x) ∨ Triplets(x)) ::: If people have siblings who are the same age, then they are twins or triplets.\n∀x (Complain(x) → Siblings(x, y)) ::: If people complain often about annoying siblings, then they have siblings who are the same age.\n∀x (¬LiveAtHomeRegularly(x) → ¬DevelopBonds(x, y)) ::: If people do not live at home regularly, then they do not develop strong bonds with their family members.\n∀x (SpendTimeWith(x, Siblings(x)) → ¬LiveAtHomeRegularly(x)) ::: If people spend a lot of time hanging out with and playing with their siblings, then they often did not live at home regularly.\n(Twins(luke) ∧ DevelopBonds(luke, FamilyMembers)) ∨ (¬Twins(luke) ∧ ¬DevelopBonds(luke, FamilyMembers)) ::: Luke is either both a twin or triplet and develops strong bonds with his family members, or he neither is a twin or triplet nor develops strong bonds with his family members.\n",
            "First-Order-Logic Question": "Complain(luke) ::: Luke complains often about annoying siblings."
        },
        "gram_prog": {
            "First-Order-Logic Rules": "∀x(Twins(x)∨Triplets(x))→SpendTimeWith(x,y)∧Siblings(x,y)∧Complain(x)∧LiveAtHomeRegularly(x) ::: If people are twins or triplets, then they spend a lot of time hanging out with and playing with their siblings.\n∀x (Siblings(x, y) → Twins(x) ∨ Triplets(x)) ::: If people have siblings who are the same age, then they are twins or triplets.\n∀x (Complain(x) → Siblings(x, y)) ::: If people complain often about annoying siblings, then they have siblings who are the same age.\n∀x (¬LiveAtHomeRegularly(x) → ¬DevelopBonds(x, y)) ::: If people do not live at home regularly, then they do not develop strong bonds with their family members.\n∀x(SpendTimeWith(x,y)→¬LiveAtHomeRegularly(x)) ::: If people spend a lot of time hanging out with and playing with their siblings, then they often did not live at home regularly.\n(Twins(luke) ∧ DevelopBonds(luke, FamilyMembers)) ∨ (¬Twins(luke) ∧ ¬DevelopBonds(luke, FamilyMembers)) ::: Luke is either both a twin or triplet and develops strong bonds with his family members, or he neither is a twin or triplet nor develops strong bonds with his family members.\n",
            "First-Order-Logic Question": "Complain(luke) ::: Luke complains often about annoying siblings."
        },
        "diff": [
            {
                "raw": "∀x (Twins(x) ∨ Triplets(x) → SpendTimeWith(x, Siblings(x))) ::: If people are twins or triplets, then they spend a lot of time hanging out with and playing with their siblings.",
                "gram": "∀x(Twins(x)∨Triplets(x))→SpendTimeWith(x,y)∧Siblings(x,y)∧Complain(x)∧LiveAtHomeRegularly(x) ::: If people are twins or triplets, then they spend a lot of time hanging out with and playing with their siblings."
            }
        ],
        "answer": "B",
        "grammar_answer": "A",
        "manual_prog": {
            "First-Order-Logic Rules": "∀x ∀y (Twins(x) ∨ Triplets(x) → SpendTimeWith(x,y) ∧ Siblings(x,y)) ::: If people are twins or triplets, then they spend a lot of time hanging out with and playing with their siblings.\n∀x (Siblings(x, y) → Twins(x) ∨ Triplets(x)) ::: If people have siblings who are the same age, then they are twins or triplets.\n∀x (Complain(x) → Siblings(x, y)) ::: If people complain often about annoying siblings, then they have siblings who are the same age.\n∀x (¬LiveAtHomeRegularly(x) → ¬DevelopBonds(x, y)) ::: If people do not live at home regularly, then they do not develop strong bonds with their family members.\n∀x (Siblings(y) ∧ SpendTimeWith(x, y) → ¬LiveAtHomeRegularly(x)) ::: If people spend a lot of time hanging out with and playing with their siblings, then they often did not live at home regularly.\n(Twins(luke) ∧ DevelopBonds(luke, FamilyMembers)) ∨ (¬Twins(luke) ∧ ¬DevelopBonds(luke, FamilyMembers)) ::: Luke is either both a twin or triplet and develops strong bonds with his family members, or he neither is a twin or triplet nor develops strong bonds with his family members.\n",
            "First-Order-Logic Question": "Complain(luke) ::: Luke complains often about annoying siblings."
        },
        "fixed": true
    },
    {
        "id": 105,
        "raw_prog": {
            "First-Order-Logic Rules": "Cost(gre_test, 205) ::: It costs US $205 to take the GRE test.\n∀x ∀y (Prove(x, EconomicHardship(y)) → ProvideAid(ETS, y)) ::: ETS provides financial aid to those GRE applicants who prove economic hardship.\n∀x (EconomicHardship(x) ↔ (Difficulty(x, money) ∨ Difficulty(x, resources))) ::: Economic hardship refers to difficulty caused by having too little money or too few resources.\nSingleParent(tom) ::: Tom lives in a single-parent family.\nOutOfWork(tom_dad, more_than_1_year) ::: His dad has been out of work for more than a year.\n",
            "First-Order-Logic Question": "ApplyFor(tom, ETS, gre_test) ::: Tom can apply for financial aid from ETS to take the GRE test."
        },
        "gram_prog": {
            "First-Order-Logic Rules": "Cost(gre_test, 205) ::: It costs US $205 to take the GRE test.\nProvideAid(x,y)→Prove(x,y)∧EconomicHardship(y) ::: ETS provides financial aid to those GRE applicants who prove economic hardship.\n∀x (EconomicHardship(x) ↔ (Difficulty(x, money) ∨ Difficulty(x, resources))) ::: Economic hardship refers to difficulty caused by having too little money or too few resources.\nSingleParent(tom) ::: Tom lives in a single-parent family.\nOutOfWork(tom_dad, more_than_1_year) ::: His dad has been out of work for more than a year.\n",
            "First-Order-Logic Question": "ApplyFor(tom, ETS, gre_test) ::: Tom can apply for financial aid from ETS to take the GRE test."
        },
        "diff": [
            {
                "raw": "∀x ∀y (Prove(x, EconomicHardship(y)) → ProvideAid(ETS, y)) ::: ETS provides financial aid to those GRE applicants who prove economic hardship.",
                "gram": "ProvideAid(x,y)→Prove(x,y)∧EconomicHardship(y) ::: ETS provides financial aid to those GRE applicants who prove economic hardship."
            }
        ],
        "answer": "A",
        "grammar_answer": "C",
        "manual_prog": {
            "First-Order-Logic Rules": "Cost(gre_test, 205) ::: It costs US $205 to take the GRE test.\n∀x ∀y (EconomicHardship(y) ∧ Prove(x, y) → ProvideAid(ETS, y)) ::: ETS provides financial aid to those GRE applicants who prove economic hardship.\n∀x (EconomicHardship(x) ↔ (Difficulty(x, money) ∨ Difficulty(x, resources))) ::: Economic hardship refers to difficulty caused by having too little money or too few resources.\nSingleParent(tom) ::: Tom lives in a single-parent family.\nOutOfWork(tom_dad, more_than_1_year) ::: His dad has been out of work for more than a year.\n",
            "First-Order-Logic Question": "ApplyFor(tom, ETS, gre_test) ::: Tom can apply for financial aid from ETS to take the GRE test."
        },
        "fixed": true
    },
    {
        "id": 115,
        "raw_prog": {
            "First-Order-Logic Rules": "∀x ∀y (Man(x) ∧ Man(y) ∧ Taller(x, y) → Block(x, y)) ::: If a man is taller than another man, the taller one can block the other's shooting.\nMan(michael) ∧ ∀x (Man(x) ∧ x ≠ michael → Taller(michael, x)) ::: Michael is a man who is taller than everyone else in his class.\n∀x ∀y ∀z (Taller(x, y) ∧ Taller(y, z) → Taller(x, z)) ::: If person x is taller than person y, and person y is taller than person z, than x is taller than z\nMan(peter) ∧ Taller(peter, michael) ::: Peter is a man who is taller than Michael.\n∀x (Shooter(x) ∧ ¬Jump(x) → Block(michael, x)) ::: Michael can block any shooting from a person as long as the person does not jump when shooting.\n¬Block(michael, windy) ::: Michael cannot block Windy's shooting.\n∀x (Shooter(x) ∧ Jump(x) → GreatShooter(x)) ::: Every shooter who can jump when shooting is a great shooter.",
            "First-Order-Logic Question": "∃x (Man(x) ∧ Classmate(x, michael) ∧ Taller(x, peter)) ::: Peter is shorter than a man in Michael's class."
        },
        "gram_prog": {
            "First-Order-Logic Rules": "∀x ∀y (Man(x) ∧ Man(y) ∧ Taller(x, y) → Block(x, y)) ::: If a man is taller than another man, the taller one can block the other's shooting.\nMan(x)∧¬(Man(x)→Taller(x,y)) ::: Michael is a man who is taller than everyone else in his class.\n∀x ∀y ∀z (Taller(x, y) ∧ Taller(y, z) → Taller(x, z)) ::: If person x is taller than person y, and person y is taller than person z, than x is taller than z\nMan(peter) ∧ Taller(peter, michael) ::: Peter is a man who is taller than Michael.\n∀x (Shooter(x) ∧ ¬Jump(x) → Block(michael, x)) ::: Michael can block any shooting from a person as long as the person does not jump when shooting.\n¬Block(michael, windy) ::: Michael cannot block Windy's shooting.\n∀x (Shooter(x) ∧ Jump(x) → GreatShooter(x)) ::: Every shooter who can jump when shooting is a great shooter.",
            "First-Order-Logic Question": "∃x (Man(x) ∧ Classmate(x, michael) ∧ Taller(x, peter)) ::: Peter is shorter than a man in Michael's class."
        },
        "diff": [
            {
                "raw": "Man(michael) ∧ ∀x (Man(x) ∧ x ≠ michael → Taller(michael, x)) ::: Michael is a man who is taller than everyone else in his class.",
                "gram": "Man(x)∧¬(Man(x)→Taller(x,y)) ::: Michael is a man who is taller than everyone else in his class."
            }
        ],
        "answer": "B",
        "grammar_answer": "A",
        "manual_prog": {
            "First-Order-Logic Rules": "∀x ∀y (Man(x) ∧ Man(y) ∧ Taller(x, y) → Block(x, y)) ::: If a man is taller than another man, the taller one can block the other's shooting.\nMan(michael) ∧ ∀x (Man(x) ∧ Not(x,michael) → Taller(michael, x)) ::: Michael is a man who is taller than everyone else in his class.\n∀x ∀y ∀z (Taller(x, y) ∧ Taller(y, z) → Taller(x, z)) ::: If person x is taller than person y, and person y is taller than person z, than x is taller than z\nMan(peter) ∧ Taller(peter, michael) ::: Peter is a man who is taller than Michael.\n∀x (Shooter(x) ∧ ¬Jump(x) → Block(michael, x)) ::: Michael can block any shooting from a person as long as the person does not jump when shooting.\n¬Block(michael, windy) ::: Michael cannot block Windy's shooting.\n∀x (Shooter(x) ∧ Jump(x) → GreatShooter(x)) ::: Every shooter who can jump when shooting is a great shooter.",
            "First-Order-Logic Question": "∃x (Man(x) ∧ Classmate(x, michael) ∧ Taller(x, peter)) ::: Peter is shorter than a man in Michael's class."
        },
        "fixed": true
    },
    {
        "id": 117,
        "raw_prog": {
            "First-Order-Logic Rules": "∀x ∀y (Man(x) ∧ Man(y) ∧ Taller(x, y) → Block(x, y)) ::: If a man is taller than another man, the taller one can block the other's shooting.\nMan(michael) ∧ ∀x (Classmate(x, michael) ∧ x ≠ michael → Taller(michael, x)) ::: Michael is a man who is taller than everyone else in his class.\n∀x ∀y ∀z (Taller(x, y) ∧ Taller(y, z) → Taller(x, z)) ::: If person x is taller than person y, and person y is taller than person z, than x is taller than z\nMan(peter) ∧ Taller(peter, michael) ::: Peter is a man who is taller than Michael.\n∀x (Shoot(x) ∧ ¬Jump(x) → Block(michael, x)) ::: Michael can block any shooting from a person as long as the person does not jump when shooting.\n¬Block(michael, windy) ::: Michael cannot block Windy's shooting.\n∀x (Jump(x) → GreatShooter(x)) ::: Every shooter who can jump when shooting is a great shooter.",
            "First-Order-Logic Question": "Block(peter, windy) ::: Peter can block Windy's shooting."
        },
        "gram_prog": {
            "First-Order-Logic Rules": "∀x ∀y (Man(x) ∧ Man(y) ∧ Taller(x, y) → Block(x, y)) ::: If a man is taller than another man, the taller one can block the other's shooting.\nMan(x)→Taller(x,y)∧¬(Classmate(x,y))∧¬(Block(x,y))∧¬(Shoot(x)) ::: Michael is a man who is taller than everyone else in his class.\n∀x ∀y ∀z (Taller(x, y) ∧ Taller(y, z) → Taller(x, z)) ::: If person x is taller than person y, and person y is taller than person z, than x is taller than z\nMan(peter) ∧ Taller(peter, michael) ::: Peter is a man who is taller than Michael.\n∀x (Shoot(x) ∧ ¬Jump(x) → Block(michael, x)) ::: Michael can block any shooting from a person as long as the person does not jump when shooting.\n¬Block(michael, windy) ::: Michael cannot block Windy's shooting.\n∀x (Jump(x) → GreatShooter(x)) ::: Every shooter who can jump when shooting is a great shooter.",
            "First-Order-Logic Question": "Block(peter, windy) ::: Peter can block Windy's shooting."
        },
        "diff": [
            {
                "raw": "Man(michael) ∧ ∀x (Classmate(x, michael) ∧ x ≠ michael → Taller(michael, x)) ::: Michael is a man who is taller than everyone else in his class.",
                "gram": "Man(x)→Taller(x,y)∧¬(Classmate(x,y))∧¬(Block(x,y))∧¬(Shoot(x)) ::: Michael is a man who is taller than everyone else in his class."
            }
        ],
        "answer": "C",
        "grammar_answer": "A",
        "manual_prog": {
            "First-Order-Logic Rules": "∀x ∀y (Man(x) ∧ Man(y) ∧ Taller(x, y) → Block(x, y)) ::: If a man is taller than another man, the taller one can block the other's shooting.\nMan(michael) ∧ ∀x (Classmate(x, michael) ∧ Not(x,michael) → Taller(michael, x)) ::: Michael is a man who is taller than everyone else in his class.\n∀x ∀y ∀z (Taller(x, y) ∧ Taller(y, z) → Taller(x, z)) ::: If person x is taller than person y, and person y is taller than person z, than x is taller than z\nMan(peter) ∧ Taller(peter, michael) ::: Peter is a man who is taller than Michael.\n∀x (Shoot(x) ∧ ¬Jump(x) → Block(michael, x)) ::: Michael can block any shooting from a person as long as the person does not jump when shooting.\n¬Block(michael, windy) ::: Michael cannot block Windy's shooting.\n∀x (Jump(x) → GreatShooter(x)) ::: Every shooter who can jump when shooting is a great shooter.",
            "First-Order-Logic Question": "Block(peter, windy) ::: Peter can block Windy's shooting."
        },
        "fixed": true
    },
    {
        "id": 129,
        "raw_prog": {
            "First-Order-Logic Rules": "∀x (HaveWedding(x) → HaveChild(x)) ::: All people who have a wedding are people who have at least one child.\n∀x (TravelToParisForHoneymoon(x) → HaveWedding(x)) ::: All people who travel to Paris for their honeymoon are people who have a wedding.\n∀x (Weddings(x) ∧ July(x) → BelongTo(x, TravelToParisForHoneymoon(x))) ::: All weddings that occur in July belong to people who travel to Paris for their honeymoon.\n∃x (Weddings(x) ∧ July(x) ∧ WellAttended(x)) ::: Some weddings in July are well-attended.\nHaveChild(John) → (¬TravelToParisForHoneymoon(John) ∧ ¬HaveWedding(John)) ::: If John has at least one child, then John does not travel to Paris for his honeymoon and does not have a wedding.\nHaveWedding(John) ∧ WellAttended(John) → (July(John) ∨ (¬July(John) ∧ TravelToParisForHoneymoon(John))) ::: If John has a wedding that is well-attended, then John has a wedding in July or, if not, then John travels to Paris for their honeymoon.",
            "First-Order-Logic Question": "¬WellAttended(John) ::: John does not have a wedding that is well-attended."
        },
        "gram_prog": {
            "First-Order-Logic Rules": "∀x (HaveWedding(x) → HaveChild(x)) ::: All people who have a wedding are people who have at least one child.\n∀x (TravelToParisForHoneymoon(x) → HaveWedding(x)) ::: All people who travel to Paris for their honeymoon are people who have a wedding.\n∀x(WellAttended(x)→BelongTo(x,x)) ::: All weddings that occur in July belong to people who travel to Paris for their honeymoon.\n∃x (Weddings(x) ∧ July(x) ∧ WellAttended(x)) ::: Some weddings in July are well-attended.\nHaveChild(John) → (¬TravelToParisForHoneymoon(John) ∧ ¬HaveWedding(John)) ::: If John has at least one child, then John does not travel to Paris for his honeymoon and does not have a wedding.\nHaveWedding(John) ∧ WellAttended(John) → (July(John) ∨ (¬July(John) ∧ TravelToParisForHoneymoon(John))) ::: If John has a wedding that is well-attended, then John has a wedding in July or, if not, then John travels to Paris for their honeymoon.",
            "First-Order-Logic Question": "¬WellAttended(John) ::: John does not have a wedding that is well-attended."
        },
        "diff": [
            {
                "raw": "∀x (Weddings(x) ∧ July(x) → BelongTo(x, TravelToParisForHoneymoon(x))) ::: All weddings that occur in July belong to people who travel to Paris for their honeymoon.",
                "gram": "∀x(WellAttended(x)→BelongTo(x,x)) ::: All weddings that occur in July belong to people who travel to Paris for their honeymoon."
            }
        ],
        "answer": "A",
        "grammar_answer": "C",
        "manual_prog": {
            "First-Order-Logic Rules": "∀x (HaveWedding(x) → HaveChild(x)) ::: All people who have a wedding are people who have at least one child.\n∀x (TravelToParisForHoneymoon(x) → HaveWedding(x)) ::: All people who travel to Paris for their honeymoon are people who have a wedding.\n∀x (Weddings(x) ∧ July(x) → TravelToParisForHoneymoon(x) ∧ BelongTo(x, y)) ::: All weddings that occur in July belong to people who travel to Paris for their honeymoon.\n∃x (Weddings(x) ∧ July(x) ∧ WellAttended(x)) ::: Some weddings in July are well-attended.\nHaveChild(John) → (¬TravelToParisForHoneymoon(John) ∧ ¬HaveWedding(John)) ::: If John has at least one child, then John does not travel to Paris for his honeymoon and does not have a wedding.\nHaveWedding(John) ∧ WellAttended(John) → (July(John) ∨ (¬July(John) ∧ TravelToParisForHoneymoon(John))) ::: If John has a wedding that is well-attended, then John has a wedding in July or, if not, then John travels to Paris for their honeymoon.",
            "First-Order-Logic Question": "¬WellAttended(John) ::: John does not have a wedding that is well-attended."
        },
        "fixed": true
    },
    {
        "id": 131,
        "raw_prog": {
            "First-Order-Logic Rules": "∀x HaveWedding(x) → HaveChild(x) ::: All people who have a wedding are people who have at least one child.\n∀x (TravelToParisForHoneymoon(x) → HaveWedding(x)) ::: All people who travel to Paris for their honeymoon are people who have a wedding.\n∀x (Weddings(x) ∧ July(x) → BelongTo(x, TravelToParisForHoneymoon(x))) ::: All weddings that occur in July belong to people who travel to Paris for their honeymoon.\n∃x (Weddings(x) ∧ July(x) ∧ WellAttended(x)) ::: Some weddings in July are well-attended.\nHaveChild(John) → ¬(TravelToParisForHoneymoon(John) ∧ HaveWedding(John)) ::: If John has at least one child, then John does not travel to Paris for his honeymoon and does not have a wedding.\nHaveWedding(John) ∧ WellAttended(John) → (July(John) ∨ (¬July(John) ∧ TravelToParisForHoneymoon(John))) ::: If John has a wedding that is well-attended, then John has a wedding in July or, if not, then John travels to Paris for their honeymoon.",
            "First-Order-Logic Question": "¬(WellAttended(John) ∨ TravelToParisForHoneymoon(John)) ::: John has neither a wedding that is well-attended nor does he travel to Paris for his honeymoon."
        },
        "gram_prog": {
            "First-Order-Logic Rules": "∀x HaveWedding(x) → HaveChild(x) ::: All people who have a wedding are people who have at least one child.\n∀x (TravelToParisForHoneymoon(x) → HaveWedding(x)) ::: All people who travel to Paris for their honeymoon are people who have a wedding.\n∀x(WellAttended(x)→BelongTo(x,x)) ::: All weddings that occur in July belong to people who travel to Paris for their honeymoon.\n∃x (Weddings(x) ∧ July(x) ∧ WellAttended(x)) ::: Some weddings in July are well-attended.\nHaveChild(John) → ¬(TravelToParisForHoneymoon(John) ∧ HaveWedding(John)) ::: If John has at least one child, then John does not travel to Paris for his honeymoon and does not have a wedding.\nHaveWedding(John) ∧ WellAttended(John) → (July(John) ∨ (¬July(John) ∧ TravelToParisForHoneymoon(John))) ::: If John has a wedding that is well-attended, then John has a wedding in July or, if not, then John travels to Paris for their honeymoon.",
            "First-Order-Logic Question": "¬(WellAttended(John) ∨ TravelToParisForHoneymoon(John)) ::: John has neither a wedding that is well-attended nor does he travel to Paris for his honeymoon."
        },
        "diff": [
            {
                "raw": "∀x (Weddings(x) ∧ July(x) → BelongTo(x, TravelToParisForHoneymoon(x))) ::: All weddings that occur in July belong to people who travel to Paris for their honeymoon.",
                "gram": "∀x(WellAttended(x)→BelongTo(x,x)) ::: All weddings that occur in July belong to people who travel to Paris for their honeymoon."
            }
        ],
        "answer": "A",
        "grammar_answer": "C",
        "manual_prog": {
            "First-Order-Logic Rules": "∀x HaveWedding(x) → HaveChild(x) ::: All people who have a wedding are people who have at least one child.\n∀x (TravelToParisForHoneymoon(x) → HaveWedding(x)) ::: All people who travel to Paris for their honeymoon are people who have a wedding.\n∀x (Weddings(x) ∧ July(x) → TravelToParisForHoneymoon(x) ∧ BelongTo(x, y)) ::: All weddings that occur in July belong to people who travel to Paris for their honeymoon.\n∃x (Weddings(x) ∧ July(x) ∧ WellAttended(x)) ::: Some weddings in July are well-attended.\nHaveChild(John) → ¬(TravelToParisForHoneymoon(John) ∧ HaveWedding(John)) ::: If John has at least one child, then John does not travel to Paris for his honeymoon and does not have a wedding.\nHaveWedding(John) ∧ WellAttended(John) → (July(John) ∨ (¬July(John) ∧ TravelToParisForHoneymoon(John))) ::: If John has a wedding that is well-attended, then John has a wedding in July or, if not, then John travels to Paris for their honeymoon.",
            "First-Order-Logic Question": "¬(WellAttended(John) ∨ TravelToParisForHoneymoon(John)) ::: John has neither a wedding that is well-attended nor does he travel to Paris for his honeymoon."
        },
        "fixed": true
    },
    {
        "id": 154,
        "raw_prog": {
            "First-Order-Logic Rules": "∀x,y (Owns(x, y) → (WorkRegularlyAtHome(x) ∧ TidyOrganize(x))) ::: If people own a large desktop monitor at their home, then they work regularly and often at home.\n∀x,y (FullyStockedImpressiveHomeOffice(x) → LargeDesktopMonitor(x, y)) ::: All people who have a fully stocked and impressive home office are people who own a large desktop monitor at their home.\n∀x (WorkRegularlyAtHome(x) → TidyOrganize(x)) ::: All people who work regularly and often at home spend their free time tidying and organizing the spaces in their homes.\n∀x (WorkRegularlyAtHome(x) → VisitOfficeStore(x)) ::: All people who work regularly and often at home visit the office supply store regularly.\n∀x (TidyOrganize(x) → (¬GoToBedLate(x) ∧ ¬WakeUpAfterNoon(x))) ::: If people spend their free time tidying and organizing the spaces in their home, then they do not go to bed late and wake up every day after noon.\n(TidyOrganize(remy) ∧ (GoToBedLate(remy) ∧ WakeUpAfterNoon(remy))) ⊕ (¬GoToBedLate(remy) ∧ ¬WakeUpAfterNoon(remy) ∧ ¬TidyOrganize(remy)) ::: Remy either both goes to bed late and wakes up every day after noon and spends their free time tidying and organizing the spaces in their home, or they do not go to bed late and wake up every day after noon nor spend their free time tidying and organizing the spaces in their home.\n",
            "First-Order-Logic Question": "FullyStockedImpressiveHomeOffice(remy) ∧ VisitOfficeStore(remy) ::: Remy has a fully stocked and impressive home office and also visits the office supply store regularly."
        },
        "gram_prog": {
            "First-Order-Logic Rules": "∀x(Owns(x,y)→(WorkRegularlyAtHome(x))) ::: If people own a large desktop monitor at their home, then they work regularly and often at home.\n∀x(Owns(x,y)→LargeDesktopMonitor(x,y)) ::: All people who have a fully stocked and impressive home office are people who own a large desktop monitor at their home.\n∀x (WorkRegularlyAtHome(x) → TidyOrganize(x)) ::: All people who work regularly and often at home spend their free time tidying and organizing the spaces in their homes.\n∀x (WorkRegularlyAtHome(x) → VisitOfficeStore(x)) ::: All people who work regularly and often at home visit the office supply store regularly.\n∀x (TidyOrganize(x) → (¬GoToBedLate(x) ∧ ¬WakeUpAfterNoon(x))) ::: If people spend their free time tidying and organizing the spaces in their home, then they do not go to bed late and wake up every day after noon.\n(TidyOrganize(remy) ∧ (GoToBedLate(remy) ∧ WakeUpAfterNoon(remy))) ⊕ (¬GoToBedLate(remy) ∧ ¬WakeUpAfterNoon(remy) ∧ ¬TidyOrganize(remy)) ::: Remy either both goes to bed late and wakes up every day after noon and spends their free time tidying and organizing the spaces in their home, or they do not go to bed late and wake up every day after noon nor spend their free time tidying and organizing the spaces in their home.\n",
            "First-Order-Logic Question": "FullyStockedImpressiveHomeOffice(remy) ∧ VisitOfficeStore(remy) ::: Remy has a fully stocked and impressive home office and also visits the office supply store regularly."
        },
        "diff": [
            {
                "raw": "∀x,y (Owns(x, y) → (WorkRegularlyAtHome(x) ∧ TidyOrganize(x))) ::: If people own a large desktop monitor at their home, then they work regularly and often at home.",
                "gram": "∀x(Owns(x,y)→(WorkRegularlyAtHome(x))) ::: If people own a large desktop monitor at their home, then they work regularly and often at home."
            },
            {
                "raw": "∀x,y (FullyStockedImpressiveHomeOffice(x) → LargeDesktopMonitor(x, y)) ::: All people who have a fully stocked and impressive home office are people who own a large desktop monitor at their home.",
                "gram": "∀x(Owns(x,y)→LargeDesktopMonitor(x,y)) ::: All people who have a fully stocked and impressive home office are people who own a large desktop monitor at their home."
            }
        ],
        "answer": "B",
        "grammar_answer": "C",
        "manual_prog": {
            "First-Order-Logic Rules": "∀x ∀y (Owns(x, y) → (WorkRegularlyAtHome(x) ∧ TidyOrganize(x))) ::: If people own a large desktop monitor at their home, then they work regularly and often at home.\n∀x ∀y (FullyStockedImpressiveHomeOffice(x) → LargeDesktopMonitor(x, y)) ::: All people who have a fully stocked and impressive home office are people who own a large desktop monitor at their home.\n∀x (WorkRegularlyAtHome(x) → TidyOrganize(x)) ::: All people who work regularly and often at home spend their free time tidying and organizing the spaces in their homes.\n∀x (WorkRegularlyAtHome(x) → VisitOfficeStore(x)) ::: All people who work regularly and often at home visit the office supply store regularly.\n∀x (TidyOrganize(x) → (¬GoToBedLate(x) ∧ ¬WakeUpAfterNoon(x))) ::: If people spend their free time tidying and organizing the spaces in their home, then they do not go to bed late and wake up every day after noon.\n(TidyOrganize(remy) ∧ (GoToBedLate(remy) ∧ WakeUpAfterNoon(remy))) ⊕ (¬GoToBedLate(remy) ∧ ¬WakeUpAfterNoon(remy) ∧ ¬TidyOrganize(remy)) ::: Remy either both goes to bed late and wakes up every day after noon and spends their free time tidying and organizing the spaces in their home, or they do not go to bed late and wake up every day after noon nor spend their free time tidying and organizing the spaces in their home.\n",
            "First-Order-Logic Question": "FullyStockedImpressiveHomeOffice(remy) ∧ VisitOfficeStore(remy) ::: Remy has a fully stocked and impressive home office and also visits the office supply store regularly."
        },
        "fixed": true
    },
    {
        "id": 180,
        "raw_prog": {
            "First-Order-Logic Rules": "Flies(susan, lga) ::: Susan flies to LGA airport.\nDeparture(x, y) ∧ Arrival(x, y) ⊕ ¬(x = y) ::: The departure and arrival can not be the same airport.\nFrom(john, lga) ::: John flies from LGA airport.",
            "First-Order-Logic Question": "From(susan, lga) ::: Susan flies from LGA airport."
        },
        "gram_prog": {
            "First-Order-Logic Rules": "Flies(susan, lga) ::: Susan flies to LGA airport.\nDeparture(x,y)∧¬(From(x,y))∨Arrival(x,y)⊕¬(From(x,y)) ::: The departure and arrival can not be the same airport.\nFrom(john, lga) ::: John flies from LGA airport.",
            "First-Order-Logic Question": "From(susan, lga) ::: Susan flies from LGA airport."
        },
        "diff": [
            {
                "raw": "Departure(x, y) ∧ Arrival(x, y) ⊕ ¬(x = y) ::: The departure and arrival can not be the same airport.",
                "gram": "Departure(x,y)∧¬(From(x,y))∨Arrival(x,y)⊕¬(From(x,y)) ::: The departure and arrival can not be the same airport."
            }
        ],
        "answer": "B",
        "grammar_answer": "C",
        "manual_prog": {
            "First-Order-Logic Rules": "Flies(susan, lga) ::: Susan flies to LGA airport.\nDeparture(x, y) ∧ Arrival(x, y) ⊕ ¬Equal(x,y) ::: The departure and arrival can not be the same airport.\nFrom(john, lga) ::: John flies from LGA airport.",
            "First-Order-Logic Question": "From(susan, lga) ::: Susan flies from LGA airport."
        },
        "fixed": true
    },
    {
        "id": 199,
        "raw_prog": {
            "First-Order-Logic Rules": "Person(ailtonSilva) ∧ Born(ailtonSilva, 1995) ∧ KnownAs(ailtonSilva, ailton) ∧ FootballPlayer(ailton) ∧ Loan(ailton, braga) ∧ Brazilian(ailtonSilva) ∧ PlaysFor(ailtonSilva, nautico) ∧ Club(nautico) ∧ Club(braga) ∧ Club(fluminense) ::: Ailton Silva, born in 1995, is commonly known as Ailton. Ailton is a football player who was loaned out to Braga. Ailton Silva is a Brazillian footballer who plays for Nautico. Nautico is a football club along with Braga. Fluminense is a football club.",
            "First-Order-Logic Question": "¬∃x (PlaysFor(x, nautico) ∧ Brazilian(x)) ::: No one playing for Nautico is Brazilian."
        },
        "gram_prog": {
            "First-Order-Logic Rules": "Person(x)→KnownAs(x,x)→FootballPlayer(x)→Loan(x,y)→Club(y)→PlaysFor(x,y)→Brazilian(x) ::: Ailton Silva, born in 1995, is commonly known as Ailton. Ailton is a football player who was loaned out to Braga. Ailton Silva is a Brazillian footballer who plays for Nautico. Nautico is a football club along with Braga. Fluminense is a football club.",
            "First-Order-Logic Question": "¬∃x (PlaysFor(x, nautico) ∧ Brazilian(x)) ::: No one playing for Nautico is Brazilian."
        },
        "diff": [
            {
                "raw": "Person(ailtonSilva) ∧ Born(ailtonSilva, 1995) ∧ KnownAs(ailtonSilva, ailton) ∧ FootballPlayer(ailton) ∧ Loan(ailton, braga) ∧ Brazilian(ailtonSilva) ∧ PlaysFor(ailtonSilva, nautico) ∧ Club(nautico) ∧ Club(braga) ∧ Club(fluminense) ::: Ailton Silva, born in 1995, is commonly known as Ailton. Ailton is a football player who was loaned out to Braga. Ailton Silva is a Brazillian footballer who plays for Nautico. Nautico is a football club along with Braga. Fluminense is a football club.",
                "gram": "Person(x)→KnownAs(x,x)→FootballPlayer(x)→Loan(x,y)→Club(y)→PlaysFor(x,y)→Brazilian(x) ::: Ailton Silva, born in 1995, is commonly known as Ailton. Ailton is a football player who was loaned out to Braga. Ailton Silva is a Brazillian footballer who plays for Nautico. Nautico is a football club along with Braga. Fluminense is a football club."
            }
        ],
        "answer": "B",
        "grammar_answer": "C",
        "manual_prog": {
            "First-Order-Logic Rules": "Person(ailtonSilva) ∧ Born(ailtonSilva, 1995) ∧ KnownAs(ailtonSilva, ailton) ∧ FootballPlayer(ailton) ∧ Loan(ailton, braga) ∧ Brazilian(ailtonSilva) ∧ PlaysFor(ailtonSilva, nautico) ∧ Club(nautico) ∧ Club(braga) ∧ Club(fluminense) ::: Ailton Silva, born in 1995, is commonly known as Ailton. Ailton is a football player who was loaned out to Braga. Ailton Silva is a Brazillian footballer who plays for Nautico. Nautico is a football club along with Braga. Fluminense is a football club.",
            "First-Order-Logic Question": "¬∃x (PlaysFor(x, nautico) ∧ Brazilian(x)) ::: No one playing for Nautico is Brazilian."
        },
        "fixed": false
    },
    {
        "id": 201,
        "raw_prog": {
            "First-Order-Logic Rules": "Person(ailtonSilva) ∧ Born(ailtonSilva, 1995) ∧ KnownAs(ailtonSilva, ailton) ::: Ailton Silva, born in 1995, is commonly known as Ailton.\nFootballPlayer(ailton) ∧ Loan(ailton, braga) ::: Ailton is a football player who was loaned out to Braga.\nBrazilian(ailtonSilva) ∧ FootballPlayer(ailtonSilva) ∧ PlaysFor(ailtonSilva, nautico) ::: Ailton Silva is a Brazillian footballer who plays for Nautico.\nClub(nautico) ∧ Club(braga) ∧ Team(nautico, braga) ::: Nautico is a football club along with Braga.\nClub(fluminense) ::: Fluminense is a football club.\n",
            "First-Order-Logic Question": "¬(∃x Loan(ailton, Club(x))) ::: Ailton was not loaned out to a football club."
        },
        "gram_prog": {
            "First-Order-Logic Rules": "Person(ailtonSilva) ∧ Born(ailtonSilva, 1995) ∧ KnownAs(ailtonSilva, ailton) ::: Ailton Silva, born in 1995, is commonly known as Ailton.\nFootballPlayer(ailton) ∧ Loan(ailton, braga) ::: Ailton is a football player who was loaned out to Braga.\nBrazilian(ailtonSilva) ∧ FootballPlayer(ailtonSilva) ∧ PlaysFor(ailtonSilva, nautico) ::: Ailton Silva is a Brazillian footballer who plays for Nautico.\nClub(nautico) ∧ Club(braga) ∧ Team(nautico, braga) ::: Nautico is a football club along with Braga.\nClub(fluminense) ::: Fluminense is a football club.\n",
            "First-Order-Logic Question": "¬(Loan(x,y)) ::: Ailton was not loaned out to a football club."
        },
        "diff": [],
        "answer": "B",
        "grammar_answer": "C",
        "manual_prog": {
            "First-Order-Logic Rules": "Person(ailtonSilva) ∧ Born(ailtonSilva, 1995) ∧ KnownAs(ailtonSilva, ailton) ::: Ailton Silva, born in 1995, is commonly known as Ailton.\nFootballPlayer(ailton) ∧ Loan(ailton, braga) ::: Ailton is a football player who was loaned out to Braga.\nBrazilian(ailtonSilva) ∧ FootballPlayer(ailtonSilva) ∧ PlaysFor(ailtonSilva, nautico) ::: Ailton Silva is a Brazillian footballer who plays for Nautico.\nClub(nautico) ∧ Club(braga) ∧ Team(nautico, braga) ::: Nautico is a football club along with Braga.\nClub(fluminense) ::: Fluminense is a football club.\n",
            "First-Order-Logic Question": "¬∃x(Club(y) ∧ Loan(ailton, y)) ::: Ailton was not loaned out to a football club."
        },
        "fixed": false
    },
    {
        "id": 11,
        "raw_prog": {
            "First-Order-Logic Rules": "WildTurkey(tom) ::: Tom is a wild turkey.\n∀x (WildTurkey(x) → (x = EasternWildTurkey ∨ x = OsceolaWildTurkey ∨ x = GouldsWildTurkey ∨ x = MerriamsWildTurkey ∨ x = RioGrandeWildTurkey ∨ x = OcellatedWildTurkey)) ::: There are six types of wild turkeys: Eastern wild turkey, Osceola wild turkey, Gould’s wild turkey, Merriam’s wild turkey, Rio Grande wild turkey, and Ocellated wild turkey.\n¬EasternWildTurkey(tom) ∧ ¬OsceolaWildTurkey(tom) ∧ ¬GouldsWildTurkey(tom) ∧ ¬MerriamsWildTurkey(tom) ∧ ¬RioGrandeWildTurkey(tom) ::: Tom is not an Eastern wild turkey, Osceola wild turkey, Gould's wild turkey, Merriam's wild turkey, or Rio Grande wild turkey.\n",
            "First-Order-Logic Question": "WildTurkey(joey) ::: Joey is a wild turkey."
        },
        "gram_prog": {
            "First-Order-Logic Rules": "WildTurkey(tom) ::: Tom is a wild turkey.\n∀x(WildTurkey(x)→(EasternWildTurkey(x))) ::: There are six types of wild turkeys: Eastern wild turkey, Osceola wild turkey, Gould’s wild turkey, Merriam’s wild turkey, Rio Grande wild turkey, and Ocellated wild turkey.\n¬EasternWildTurkey(tom) ∧ ¬OsceolaWildTurkey(tom) ∧ ¬GouldsWildTurkey(tom) ∧ ¬MerriamsWildTurkey(tom) ∧ ¬RioGrandeWildTurkey(tom) ::: Tom is not an Eastern wild turkey, Osceola wild turkey, Gould's wild turkey, Merriam's wild turkey, or Rio Grande wild turkey.\n",
            "First-Order-Logic Question": "WildTurkey(joey) ::: Joey is a wild turkey."
        },
        "diff": [
            {
                "raw": "∀x (WildTurkey(x) → (x = EasternWildTurkey ∨ x = OsceolaWildTurkey ∨ x = GouldsWildTurkey ∨ x = MerriamsWildTurkey ∨ x = RioGrandeWildTurkey ∨ x = OcellatedWildTurkey)) ::: There are six types of wild turkeys: Eastern wild turkey, Osceola wild turkey, Gould’s wild turkey, Merriam’s wild turkey, Rio Grande wild turkey, and Ocellated wild turkey.",
                "gram": "∀x(WildTurkey(x)→(EasternWildTurkey(x))) ::: There are six types of wild turkeys: Eastern wild turkey, Osceola wild turkey, Gould’s wild turkey, Merriam’s wild turkey, Rio Grande wild turkey, and Ocellated wild turkey."
            }
        ],
        "answer": "C",
        "grammar_answer": "A",
        "manual_prog": {
            "First-Order-Logic Rules": "WildTurkey(tom) ::: Tom is a wild turkey.\n∀x (WildTurkey(x) → (EasternWildTurkey(x) ∨ OsceolaWildTurkey(x) ∨ GouldsWildTurkey(x) ∨ MerriamsWildTurkey(x) ∨ RioGrandeWildTurkey(x) ∨ OcellatedWildTurkey(x))) ::: There are six types of wild turkeys: Eastern wild turkey, Osceola wild turkey, Gould’s wild turkey, Merriam’s wild turkey, Rio Grande wild turkey, and Ocellated wild turkey.\n¬EasternWildTurkey(tom) ∧ ¬OsceolaWildTurkey(tom) ∧ ¬GouldsWildTurkey(tom) ∧ ¬MerriamsWildTurkey(tom) ∧ ¬RioGrandeWildTurkey(tom) ::: Tom is not an Eastern wild turkey, Osceola wild turkey, Gould's wild turkey, Merriam's wild turkey, or Rio Grande wild turkey.\n",
            "First-Order-Logic Question": "WildTurkey(joey) ::: Joey is a wild turkey."
        },
        "fixed": true
    },
    {
        "id": 41,
        "raw_prog": {
            "First-Order-Logic Rules": "∀x (DesignStyle(x, ZahaHadid) → Timeless(x)) ::: All of Zaha Hadid's design styles are timeless.\n∀x (MassProductDesign(x) → ¬Timeless(x)) ::: No mass product design is timeless.\nDesignStyle(ZahaHadid, y) ∨ DesignStyle(KellyWearstler, y) ::: Either Zaha Hadid's design style or Kelly Wearstler's design style.\n∀x (DesignStyle(x, KellyWearstler) → Evocative(x)) ::: All of Kelly Wearstler's design styles are evocative.\n∀x (DesignStyle(x, KellyWearstler) → Dreamy(x)) ::: All of Kelly Wearstler's design styles are dreamy.\n∀x (Timeless(DesignBy(x, Max)) → (MassProductDesign(DesignBy(x, Max)) ∧ Evocative(DesignBy(x, Max)))) ::: If a design by Max is timeless, then a design by Max is a mass product design and evocative.\n",
            "First-Order-Logic Question": "Evocative(DesignBy(Max, Max)) ∨ Dreamy(DesignBy(Max, Max)) ::: A design by Max is either evocative or dreamy."
        },
        "gram_prog": {
            "First-Order-Logic Rules": "∀x (DesignStyle(x, ZahaHadid) → Timeless(x)) ::: All of Zaha Hadid's design styles are timeless.\n∀x (MassProductDesign(x) → ¬Timeless(x)) ::: No mass product design is timeless.\nDesignStyle(ZahaHadid, y) ∨ DesignStyle(KellyWearstler, y) ::: Either Zaha Hadid's design style or Kelly Wearstler's design style.\n∀x (DesignStyle(x, KellyWearstler) → Evocative(x)) ::: All of Kelly Wearstler's design styles are evocative.\n∀x (DesignStyle(x, KellyWearstler) → Dreamy(x)) ::: All of Kelly Wearstler's design styles are dreamy.\n∀x(Timeless(x)→(MassProductDesign(x))) ::: If a design by Max is timeless, then a design by Max is a mass product design and evocative.\n",
            "First-Order-Logic Question": "Evocative(x)∨Dreamy(x) ::: A design by Max is either evocative or dreamy."
        },
        "diff": [
            {
                "raw": "∀x (Timeless(DesignBy(x, Max)) → (MassProductDesign(DesignBy(x, Max)) ∧ Evocative(DesignBy(x, Max)))) ::: If a design by Max is timeless, then a design by Max is a mass product design and evocative.",
                "gram": "∀x(Timeless(x)→(MassProductDesign(x))) ::: If a design by Max is timeless, then a design by Max is a mass product design and evocative."
            }
        ],
        "answer": "B",
        "grammar_answer": "A",
        "manual_prog": {
            "First-Order-Logic Rules": "∀x (DesignStyle(x, ZahaHadid) → Timeless(x)) ::: All of Zaha Hadid's design styles are timeless.\n∀x (MassProductDesign(x) → ¬Timeless(x)) ::: No mass product design is timeless.\nDesignStyle(ZahaHadid, y) ∨ DesignStyle(KellyWearstler, y) ::: Either Zaha Hadid's design style or Kelly Wearstler's design style.\n∀x (DesignStyle(x, KellyWearstler) → Evocative(x)) ::: All of Kelly Wearstler's design styles are evocative.\n∀x (DesignStyle(x, KellyWearstler) → Dreamy(x)) ::: All of Kelly Wearstler's design styles are dreamy.\n∀x (DesignBy(x, Max) ∧ Timeless(x)) → (DesignBy(x, Max) ∧ MassProductDesign(x) ∧ Evocative(x)) ::: If a design by Max is timeless, then a design by Max is a mass product design and evocative.\n",
            "First-Order-Logic Question": "DesignBy(x, Max) ∧ Evocative(x) ∨ DesignBy(x, Max) ∧ Dreamy(x) ::: A design by Max is either evocative or dreamy."
        },
        "fixed": true
    },
    {
        "id": 85,
        "raw_prog": {
            "First-Order-Logic Rules": "∀x (Listed(x) → ¬NotNegative(x)) ::: If the restaurant is listed in Yelp’s recommendations, then the restaurant does not receive many negative reviews.\n∀x (Rating(x, y) ∧ y > 9 → Listed(x)) ::: All restaurants with a rating greater than 9 are listed in Yelp’s recommendations.\n∃x (Restaurant(x) ∧ ¬Provide(x, takeout) → NotNegative(x)) ::: Some restaurants that do not provide take-out service receive many negative reviews.\n∀x (Popular(x) → Rating(x, y) ∧ y > 9) ::: All restaurants that are popular among local residents have ratings greater than 9.\nRating(subway, y) ∨ Popular(subway) ::: Subway has a rating greater than 9 or is popular among local residents.\n",
            "First-Order-Logic Question": "TakeOut(subway) ∧ ¬NotNegative(subway) ::: Subway provides take-out service and does not receive many negative reviews."
        },
        "gram_prog": {
            "First-Order-Logic Rules": "∀x (Listed(x) → ¬NotNegative(x)) ::: If the restaurant is listed in Yelp’s recommendations, then the restaurant does not receive many negative reviews.\n∀x(Rating(x,y)∧(NotNegative(x))) ::: All restaurants with a rating greater than 9 are listed in Yelp’s recommendations.\n∃x (Restaurant(x) ∧ ¬Provide(x, takeout) → NotNegative(x)) ::: Some restaurants that do not provide take-out service receive many negative reviews.\n∀x(Popular(x)→Rating(x,y)∧(Rating(x,y))) ::: All restaurants that are popular among local residents have ratings greater than 9.\nRating(subway, y) ∨ Popular(subway) ::: Subway has a rating greater than 9 or is popular among local residents.\n",
            "First-Order-Logic Question": "TakeOut(subway) ∧ ¬NotNegative(subway) ::: Subway provides take-out service and does not receive many negative reviews."
        },
        "diff": [
            {
                "raw": "∀x (Rating(x, y) ∧ y > 9 → Listed(x)) ::: All restaurants with a rating greater than 9 are listed in Yelp’s recommendations.",
                "gram": "∀x(Rating(x,y)∧(NotNegative(x))) ::: All restaurants with a rating greater than 9 are listed in Yelp’s recommendations."
            },
            {
                "raw": "∀x (Popular(x) → Rating(x, y) ∧ y > 9) ::: All restaurants that are popular among local residents have ratings greater than 9.",
                "gram": "∀x(Popular(x)→Rating(x,y)∧(Rating(x,y))) ::: All restaurants that are popular among local residents have ratings greater than 9."
            }
        ],
        "answer": "A",
        "grammar_answer": "B",
        "manual_prog": {
            "First-Order-Logic Rules": "∀x (Listed(x) → ¬NotNegative(x)) ::: If the restaurant is listed in Yelp’s recommendations, then the restaurant does not receive many negative reviews.\n∀x (Rating(x, y) ∧ MoreThan(y,9) → Listed(x)) ::: All restaurants with a rating greater than 9 are listed in Yelp’s recommendations.\n∃x (Restaurant(x) ∧ ¬Provide(x, takeout) → NotNegative(x)) ::: Some restaurants that do not provide take-out service receive many negative reviews.\n∀x (Popular(x) → Rating(x, y) ∧ MoreThan(y,9)) ::: All restaurants that are popular among local residents have ratings greater than 9.\nRating(subway, y) ∨ Popular(subway) ::: Subway has a rating greater than 9 or is popular among local residents.\n",
            "First-Order-Logic Question": "TakeOut(subway) ∧ ¬NotNegative(subway) ::: Subway provides take-out service and does not receive many negative reviews."
        },
        "fixed": true
    },
    {
        "id": 95,
        "raw_prog": {
            "First-Order-Logic Rules": "∃x (Pet(x) ∧ AllowedIn(x, y)) ::: Pets are allowed in some managed buildings.\n∀x (RequireDeposit(x) → (Equal(x, RentAmount(y, z)) ∨ MoreThan(x, RentAmount(y, z)))) ::: A deposit is required to rent an apartment in a managed building.\nCat(fluffy) ∧ Pet(fluffy) ∧ Owner(tom, fluffy) ::: Fluffy is Tom's cat.\nCat(x) → Pet(x) ::: Cats are pets.\nManaged(olivegarden) ∧ Building(olivegarden) ::: The Olive Garden is a managed building.\nRentAmount(olivegarden, 2000) ::: The monthly rent at the Olive Garden is $2000.\nRentApartment(tom, olivegarden) ↔ (MoveInWith(tom, fluffy) ∧ ¬MoreThan(deposit, 1500)) ::: Tom will rent an apartment in a managed building if and only if he is allowed to move in with Fluffy, and the security deposit is no more than $1500.\nMoreThan(2000, 1500) ::: 2000$ is more than $1500.\n",
            "First-Order-Logic Question": "Equal(deposit, 2000) ∨ MoreThan(deposit, 2000) ::: The security deposit at the Olive Garden is either $2000 or more."
        },
        "gram_prog": {
            "First-Order-Logic Rules": "∃x (Pet(x) ∧ AllowedIn(x, y)) ::: Pets are allowed in some managed buildings.\n∀x(RequireDeposit(x)→(Equal(x,y))) ::: A deposit is required to rent an apartment in a managed building.\nCat(fluffy) ∧ Pet(fluffy) ∧ Owner(tom, fluffy) ::: Fluffy is Tom's cat.\nCat(x) → Pet(x) ::: Cats are pets.\nManaged(olivegarden) ∧ Building(olivegarden) ::: The Olive Garden is a managed building.\nRentAmount(olivegarden, 2000) ::: The monthly rent at the Olive Garden is $2000.\nRentApartment(tom, olivegarden) ↔ (MoveInWith(tom, fluffy) ∧ ¬MoreThan(deposit, 1500)) ::: Tom will rent an apartment in a managed building if and only if he is allowed to move in with Fluffy, and the security deposit is no more than $1500.\nMoreThan(2000, 1500) ::: 2000$ is more than $1500.\n",
            "First-Order-Logic Question": "Equal(deposit, 2000) ∨ MoreThan(deposit, 2000) ::: The security deposit at the Olive Garden is either $2000 or more."
        },
        "diff": [
            {
                "raw": "∀x (RequireDeposit(x) → (Equal(x, RentAmount(y, z)) ∨ MoreThan(x, RentAmount(y, z)))) ::: A deposit is required to rent an apartment in a managed building.",
                "gram": "∀x(RequireDeposit(x)→(Equal(x,y))) ::: A deposit is required to rent an apartment in a managed building."
            }
        ],
        "answer": "A",
        "grammar_answer": "C",
        "manual_prog": {
            "First-Order-Logic Rules": "∃x (Pet(x) ∧ AllowedIn(x, y)) ::: Pets are allowed in some managed buildings.\n∀x (RequireDeposit(x) → (RentAmount(y, z) ∧ Equal(x, y) ∨ RentAmount(y, z) ∧ MoreThan(x, y))) ::: A deposit is required to rent an apartment in a managed building.\nCat(fluffy) ∧ Pet(fluffy) ∧ Owner(tom, fluffy) ::: Fluffy is Tom's cat.\nCat(x) → Pet(x) ::: Cats are pets.\nManaged(olivegarden) ∧ Building(olivegarden) ::: The Olive Garden is a managed building.\nRentAmount(olivegarden, 2000) ::: The monthly rent at the Olive Garden is $2000.\nRentApartment(tom, olivegarden) ↔ (MoveInWith(tom, fluffy) ∧ ¬MoreThan(deposit, 1500)) ::: Tom will rent an apartment in a managed building if and only if he is allowed to move in with Fluffy, and the security deposit is no more than $1500.\nMoreThan(2000, 1500) ::: 2000$ is more than $1500.\n",
            "First-Order-Logic Question": "Equal(deposit, 2000) ∨ MoreThan(deposit, 2000) ::: The security deposit at the Olive Garden is either $2000 or more."
        },
        "fixed": true
    },
    {
        "id": 106,
        "raw_prog": {
            "First-Order-Logic Rules": "Cost(gre, 205) ::: It costs US $205 to take the GRE test.\n∀x ∀y (TakeTest(x, gre) ∧ EconomicHardship(y) ∧ Difficulty(y, money) → ProvideAid(ets, x)) ::: ETS provides financial aid to those GRE applicants who prove economic hardship.\n∀x (EconomicHardship(x) ↔ (Difficulty(x, money) ∨ Difficulty(x, resources))) ::: Economic hardship refers to difficulty caused by having too little money or too few resources.\nSingleParentFamily(tom) ::: Tom lives in a single-parent family.\nOutOfWork(tom's dad, more than a year) ::: His dad has been out of work for more than a year.\n",
            "First-Order-Logic Question": "∃x (Cost(gre, x) ∧ x < 300) ::: It cost below US $300 to take the GRE test."
        },
        "gram_prog": {
            "First-Order-Logic Rules": "Cost(gre, 205) ::: It costs US $205 to take the GRE test.\n∀x ∀y (TakeTest(x, gre) ∧ EconomicHardship(y) ∧ Difficulty(y, money) → ProvideAid(ets, x)) ::: ETS provides financial aid to those GRE applicants who prove economic hardship.\n∀x (EconomicHardship(x) ↔ (Difficulty(x, money) ∨ Difficulty(x, resources))) ::: Economic hardship refers to difficulty caused by having too little money or too few resources.\nSingleParentFamily(tom) ::: Tom lives in a single-parent family.\nHave(x,y)→ProvideAid(x,y) ::: His dad has been out of work for more than a year.\n",
            "First-Order-Logic Question": "∃x(Cost(x,y)∧(Cost(x,y))) ::: It cost below US $300 to take the GRE test."
        },
        "diff": [
            {
                "raw": "OutOfWork(tom's dad, more than a year) ::: His dad has been out of work for more than a year.",
                "gram": "Have(x,y)→ProvideAid(x,y) ::: His dad has been out of work for more than a year."
            }
        ],
        "answer": "A",
        "grammar_answer": "C",
        "manual_prog": {
            "First-Order-Logic Rules": "Cost(gre, 205) ::: It costs US $205 to take the GRE test.\n∀x ∀y (TakeTest(x, gre) ∧ EconomicHardship(y) ∧ Difficulty(y, money) → ProvideAid(ets, x)) ::: ETS provides financial aid to those GRE applicants who prove economic hardship.\n∀x (EconomicHardship(x) ↔ (Difficulty(x, money) ∨ Difficulty(x, resources))) ::: Economic hardship refers to difficulty caused by having too little money or too few resources.\nSingleParentFamily(tom) ::: Tom lives in a single-parent family.\nOutOfWork(tomdad) ::: His dad has been out of work for more than a year.\n",
            "First-Order-Logic Question": "∃x (Cost(gre, x) ∧ Cost(x, 300)) ::: It cost below US $300 to take the GRE test."
        },
        "fixed": true
    },
    {
        "id": 107,
        "raw_prog": {
            "First-Order-Logic Rules": "Costs(gre, 205) ::: It costs US $205 to take the GRE test.\n∀x ∀y (Prove(x, EconomicHardship(y)) → ProvidesAid(ETS, y)) ::: ETS provides financial aid to those GRE applicants who prove economic hardship.\n∀x (EconomicHardship(x) ↔ (TooLittleMoney(x) ∨ TooFewResources(x))) ::: Economic hardship refers to difficulty caused by having too little money or too few resources.\nSingleParent(tom) ::: Tom lives in a single-parent family.\nOutOfWork(dad, moreThanAYear) ::: His dad has been out of work for more than a year.\n",
            "First-Order-Logic Question": "¬∃x ∀y (Costs(gre, y) ∧ ProvidesAid(ETS, x)) ::: There is no financial aid available for the GRE test."
        },
        "gram_prog": {
            "First-Order-Logic Rules": "Costs(gre, 205) ::: It costs US $205 to take the GRE test.\nProvidesAid(x,y)→Prove(x,y)∧EconomicHardship(y) ::: ETS provides financial aid to those GRE applicants who prove economic hardship.\n∀x (EconomicHardship(x) ↔ (TooLittleMoney(x) ∨ TooFewResources(x))) ::: Economic hardship refers to difficulty caused by having too little money or too few resources.\nSingleParent(tom) ::: Tom lives in a single-parent family.\nOutOfWork(dad, moreThanAYear) ::: His dad has been out of work for more than a year.\n",
            "First-Order-Logic Question": "¬∃x ∀y (Costs(gre, y) ∧ ProvidesAid(ETS, x)) ::: There is no financial aid available for the GRE test."
        },
        "diff": [
            {
                "raw": "∀x ∀y (Prove(x, EconomicHardship(y)) → ProvidesAid(ETS, y)) ::: ETS provides financial aid to those GRE applicants who prove economic hardship.",
                "gram": "ProvidesAid(x,y)→Prove(x,y)∧EconomicHardship(y) ::: ETS provides financial aid to those GRE applicants who prove economic hardship."
            }
        ],
        "answer": "B",
        "grammar_answer": "C",
        "manual_prog": {
            "First-Order-Logic Rules": "Costs(gre, 205) ::: It costs US $205 to take the GRE test.\n∀x ∀y (EconomicHardship(y) ∧ Prove(x, y) → ProvidesAid(ETS, y)) ::: ETS provides financial aid to those GRE applicants who prove economic hardship.\n∀x (EconomicHardship(x) ↔ (TooLittleMoney(x) ∨ TooFewResources(x))) ::: Economic hardship refers to difficulty caused by having too little money or too few resources.\nSingleParent(tom) ::: Tom lives in a single-parent family.\nOutOfWork(dad, moreThanAYear) ::: His dad has been out of work for more than a year.\n",
            "First-Order-Logic Question": "¬∃x ∀y (Costs(gre, y) ∧ ProvidesAid(ETS, x)) ::: There is no financial aid available for the GRE test."
        },
        "fixed": true
    },
    {
        "id": 114,
        "raw_prog": {
            "First-Order-Logic Rules": "MountainRange(picurismountains) ∨ MountainRange(picurismountains) ::: The Picuris Mountains are a mountain range in New Mexico or Texas.\nVisited(juandeonate, picurismountains) ::: Juan de Onate visited the Picuris Mountains.\nLocatedIn(hardingpegmatitemine, picurismountains) ∧ Donated(hardingpegmatitemine) ::: The Harding Pegmatite Mine, located in the Picuris Mountains, was donated.\n∀x (MountainRange(x) ∧ In(x, texas) → ¬∃y (Mine(y) ∧ Has(y, donated) ∧ LocatedIn(y, x))) ::: There are no mountain ranges in Texas that have mines which have been donated.\n",
            "First-Order-Logic Question": "NotLocatedIn(hardingpegmatitemine, newmexico) ::: The Harding Pegmatite Mine is not located in a mountain range in New Mexico."
        },
        "gram_prog": {
            "First-Order-Logic Rules": "MountainRange(picurismountains) ∨ MountainRange(picurismountains) ::: The Picuris Mountains are a mountain range in New Mexico or Texas.\nVisited(juandeonate, picurismountains) ::: Juan de Onate visited the Picuris Mountains.\nLocatedIn(hardingpegmatitemine, picurismountains) ∧ Donated(hardingpegmatitemine) ::: The Harding Pegmatite Mine, located in the Picuris Mountains, was donated.\n¬∃y(Mine(y)∧Has(y,x)∧LocatedIn(y,x)) ::: There are no mountain ranges in Texas that have mines which have been donated.\n",
            "First-Order-Logic Question": "NotLocatedIn(hardingpegmatitemine, newmexico) ::: The Harding Pegmatite Mine is not located in a mountain range in New Mexico."
        },
        "diff": [
            {
                "raw": "∀x (MountainRange(x) ∧ In(x, texas) → ¬∃y (Mine(y) ∧ Has(y, donated) ∧ LocatedIn(y, x))) ::: There are no mountain ranges in Texas that have mines which have been donated.",
                "gram": "¬∃y(Mine(y)∧Has(y,x)∧LocatedIn(y,x)) ::: There are no mountain ranges in Texas that have mines which have been donated."
            }
        ],
        "answer": "B",
        "grammar_answer": "C",
        "manual_prog": {
            "First-Order-Logic Rules": "MountainRange(picurismountains) ∨ MountainRange(picurismountains) ::: The Picuris Mountains are a mountain range in New Mexico or Texas.\nVisited(juandeonate, picurismountains) ::: Juan de Onate visited the Picuris Mountains.\nLocatedIn(hardingpegmatitemine, picurismountains) ∧ Donated(hardingpegmatitemine) ::: The Harding Pegmatite Mine, located in the Picuris Mountains, was donated.\n∀x ∃y (MountainRange(x) ∧ In(x, texas) → ¬(Mine(y) ∧ Has(y, donated) ∧ LocatedIn(y, x))) ::: There are no mountain ranges in Texas that have mines which have been donated.\n",
            "First-Order-Logic Question": "NotLocatedIn(hardingpegmatitemine, newmexico) ::: The Harding Pegmatite Mine is not located in a mountain range in New Mexico."
        },
        "fixed": true
    }
]