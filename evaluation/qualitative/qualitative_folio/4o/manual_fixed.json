{
    "outputs_1": [
        {
            "id": 41,
            "raw_prog": {
                "First-Order-Logic Rules": [
                    "∀x (ZahaHadid(x) → Timeless(x)) ::: All of Zaha Hadid's design styles are timeless.",
                    "∀x (MassProduct(x) → ¬Timeless(x)) ::: No mass product design is timeless.",
                    "∀x (ZahaHadid(x) ∨ KellyWearstler(x)) ::: Either Zaha Hadid's design style or Kelly Wearstler's design style.",
                    "∀x (KellyWearstler(x) → Evocative(x)) ::: All of Kelly Wearstler's design styles are evocative.",
                    "∀x (KellyWearstler(x) → Dreamy(x)) ::: All of Kelly Wearstler's design styles are dreamy.",
                    "∀x (Timeless(Max(x)) → (MassProduct(Max(x)) ∧ Evocative(Max(x)))) ::: If a design by Max is timeless, then a design by Max is a mass product design and evocative."
                ],
                "First-Order-Logic Question": [
                    "Evocative(Max(x)) ∨ Dreamy(Max(x)) ::: A design by Max is either evocative or dreamy."
                ]
            },
            "gram_prog": {
                "First-Order-Logic Rules": [
                    "∀x (ZahaHadid(x) → Timeless(x)) ::: All of Zaha Hadid's design styles are timeless.",
                    "∀x (MassProduct(x) → ¬Timeless(x)) ::: No mass product design is timeless.",
                    "∀x (ZahaHadid(x) ∨ KellyWearstler(x)) ::: Either Zaha Hadid's design style or Kelly Wearstler's design style.",
                    "∀x (KellyWearstler(x) → Evocative(x)) ::: All of Kelly Wearstler's design styles are evocative.",
                    "∀x (KellyWearstler(x) → Dreamy(x)) ::: All of Kelly Wearstler's design styles are dreamy.",
                    "∀x(Timeless(x)→(MassProduct(x))) ::: If a design by Max is timeless, then a design by Max is a mass product design and evocative."
                ],
                "First-Order-Logic Question": [
                    "Evocative(x)∨Dreamy(x) ::: A design by Max is either evocative or dreamy."
                ]
            },
            "diff": [
                {
                    "raw": "∀x (Timeless(Max(x)) → (MassProduct(Max(x)) ∧ Evocative(Max(x)))) ::: If a design by Max is timeless, then a design by Max is a mass product design and evocative.",
                    "gram": "∀x(Timeless(x)→(MassProduct(x))) ::: If a design by Max is timeless, then a design by Max is a mass product design and evocative."
                },
                {
                    "raw": "Evocative(Max(x)) ∨ Dreamy(Max(x)) ::: A design by Max is either evocative or dreamy.",
                    "gram": "Evocative(x)∨Dreamy(x) ::: A design by Max is either evocative or dreamy."
                }
            ],
            "answer": "B",
            "grammar_answer": "A",
            "backup_answer": "C",
            "manual_prog": {
                "First-Order-Logic Rules": "∀x (ZahaHadid(x) → Timeless(x)) ::: All of Zaha Hadid's design styles are timeless.\n∀x (MassProduct(x) → ¬Timeless(x)) ::: No mass product design is timeless.\n∀x (ZahaHadid(x) ∨ KellyWearstler(x)) ::: Either Zaha Hadid's design style or Kelly Wearstler's design style.\n∀x (KellyWearstler(x) → Evocative(x)) ::: All of Kelly Wearstler's design styles are evocative.\n∀x (KellyWearstler(x) → Dreamy(x)) ::: All of Kelly Wearstler's design styles are dreamy.\n∀x (Max(x) ∧ Timeless(x) → (Max(x) ∧ MassProduct(x) ∧ Evocative(x))) ::: If a design by Max is timeless, then a design by Max is a mass product design and evocative.",
                "First-Order-Logic Question": "(Max(x) ∧ Evocative(x)) ∨ (Dreamy(x) ∧ Max(x)) ::: A design by Max is either evocative or dreamy."
            },
            "fixed": true
        },
        {
            "id": 70,
            "raw_prog": {
                "First-Order-Logic Rules": [
                    "British(badults) ∧ Sitcom(badults) ∧ ∀x (MemberOf(x, pappys) → Star(x, badults)) ::: Badults is a British Sitcom series, starring members of Pappy's.",
                    "Pilot(badults, 2013) ∧ Network(badults, bbcthree) ::: Badults piloted in July 2013 on BBC Three.",
                    "WorkingTitle(badults, thesecretdudesociety) ::: The Working title 'The Secret Dude Society' was used for Badults.",
                    "ScriptEditor(andrewcollins, badults) ::: Andrew Collins was the script editor for Badults."
                ],
                "First-Order-Logic Question": [
                    "∀x (MemberOf(x, pappys) → ¬∃y (Star(x, y) ∧ (Network(y, bbctwo) ∨ Network(y, bbcthree)))) ::: No members of Pappy's have starred for a show piloting on BBC Two or BBC Three."
                ]
            },
            "gram_prog": {
                "First-Order-Logic Rules": [
                    "British(badults) ∧ Sitcom(badults) ∧ ∀x (MemberOf(x, pappys) → Star(x, badults)) ::: Badults is a British Sitcom series, starring members of Pappy's.",
                    "Pilot(badults, 2013) ∧ Network(badults, bbcthree) ::: Badults piloted in July 2013 on BBC Three.",
                    "WorkingTitle(badults, thesecretdudesociety) ::: The Working title 'The Secret Dude Society' was used for Badults.",
                    "ScriptEditor(andrewcollins, badults) ::: Andrew Collins was the script editor for Badults."
                ],
                "First-Order-Logic Question": [
                    "∀x(MemberOf(x,y)→¬(Star(x,y))) ::: No members of Pappy's have starred for a show piloting on BBC Two or BBC Three."
                ]
            },
            "diff": [
                {
                    "raw": "∀x (MemberOf(x, pappys) → ¬∃y (Star(x, y) ∧ (Network(y, bbctwo) ∨ Network(y, bbcthree)))) ::: No members of Pappy's have starred for a show piloting on BBC Two or BBC Three.",
                    "gram": "∀x(MemberOf(x,y)→¬(Star(x,y))) ::: No members of Pappy's have starred for a show piloting on BBC Two or BBC Three."
                }
            ],
            "answer": "B",
            "grammar_answer": "C",
            "backup_answer": "B",
            "manual_prog": {
                "First-Order-Logic Rules": "British(badults) ∧ Sitcom(badults) ∧ ∀x (MemberOf(x, pappys) → Star(x, badults)) ::: Badults is a British Sitcom series, starring members of Pappy's.\nPilot(badults, 2013) ∧ Network(badults, bbcthree) ::: Badults piloted in July 2013 on BBC Three.\nWorkingTitle(badults, thesecretdudesociety) ::: The Working title 'The Secret Dude Society' was used for Badults.\nScriptEditor(andrewcollins, badults) ::: Andrew Collins was the script editor for Badults.",
                "First-Order-Logic Question": "∀x ∃y (MemberOf(x, pappys) → ¬(Star(x, y) ∧ (Network(y, bbctwo) ∨ Network(y, bbcthree)))) ::: No members of Pappy's have starred for a show piloting on BBC Two or BBC Three."
            },
            "fixed": true
        },
        {
            "id": 93,
            "raw_prog": {
                "First-Order-Logic Rules": [
                    "∃x (Pet(x) ∧ ManagedBuilding(y) ∧ AllowedIn(x, y)) ::: Pets are allowed in some managed buildings.",
                    "∀x (ManagedBuilding(x) → DepositRequired(x)) ::: A deposit is required to rent an apartment in a managed building.",
                    "∀x ∀y (SecurityDeposit(x, y) → EqualOrMore(y, MonthlyRent(x, 1))) ::: The security deposit can be either equal to one month's rent or more.",
                    "Cat(fluffy) ∧ Owner(tom, fluffy) ::: Fluffy is Tom's cat.",
                    "∀x (Cat(x) → Pet(x)) ::: Cats are pets.",
                    "ManagedBuilding(olivegarden) ::: The Olive Garden is a managed building.",
                    "MonthlyRent(olivegarden, 2000) ::: The monthly rent at the Olive Garden is $2000.",
                    "∀x ∀y (Owner(x, y) ∧ Pet(y) ∧ ManagedBuilding(z) ∧ AllowedIn(y, z) ∧ SecurityDeposit(z, d) ∧ d ≤ 1500 ↔ Rent(x, z)) ::: Tom will rent an apartment in a managed building if and only if he is allowed to move in with Fluffy, and the security deposit is no more than $1500.",
                    "EqualOrMore(2000, 1500) ::: 2000$ is more than $1500."
                ],
                "First-Order-Logic Question": [
                    "Rent(tom, olivegarden) ::: Tom will rent an apartment in The Olive Garden."
                ]
            },
            "gram_prog": {
                "First-Order-Logic Rules": [
                    "∃x (Pet(x) ∧ ManagedBuilding(y) ∧ AllowedIn(x, y)) ::: Pets are allowed in some managed buildings.",
                    "∀x (ManagedBuilding(x) → DepositRequired(x)) ::: A deposit is required to rent an apartment in a managed building.",
                    "DepositRequired(x)→SecurityDeposit(x,y)→EqualOrMore(y,x) ::: The security deposit can be either equal to one month's rent or more.",
                    "Cat(fluffy) ∧ Owner(tom, fluffy) ::: Fluffy is Tom's cat.",
                    "∀x (Cat(x) → Pet(x)) ::: Cats are pets.",
                    "ManagedBuilding(olivegarden) ::: The Olive Garden is a managed building.",
                    "MonthlyRent(olivegarden, 2000) ::: The monthly rent at the Olive Garden is $2000.",
                    "∀x∀y(Owner(x,y)∧Pet(y)∧ManagedBuilding(z)∧AllowedIn(y,z)) ::: Tom will rent an apartment in a managed building if and only if he is allowed to move in with Fluffy, and the security deposit is no more than $1500.",
                    "EqualOrMore(2000, 1500) ::: 2000$ is more than $1500."
                ],
                "First-Order-Logic Question": [
                    "Rent(tom, olivegarden) ::: Tom will rent an apartment in The Olive Garden."
                ]
            },
            "diff": [
                {
                    "raw": "∀x ∀y (SecurityDeposit(x, y) → EqualOrMore(y, MonthlyRent(x, 1))) ::: The security deposit can be either equal to one month's rent or more.",
                    "gram": "DepositRequired(x)→SecurityDeposit(x,y)→EqualOrMore(y,x) ::: The security deposit can be either equal to one month's rent or more."
                },
                {
                    "raw": "∀x ∀y (Owner(x, y) ∧ Pet(y) ∧ ManagedBuilding(z) ∧ AllowedIn(y, z) ∧ SecurityDeposit(z, d) ∧ d ≤ 1500 ↔ Rent(x, z)) ::: Tom will rent an apartment in a managed building if and only if he is allowed to move in with Fluffy, and the security deposit is no more than $1500.",
                    "gram": "∀x∀y(Owner(x,y)∧Pet(y)∧ManagedBuilding(z)∧AllowedIn(y,z)) ::: Tom will rent an apartment in a managed building if and only if he is allowed to move in with Fluffy, and the security deposit is no more than $1500."
                }
            ],
            "answer": "B",
            "grammar_answer": "C",
            "backup_answer": "B",
            "manual_prog": {
                "First-Order-Logic Rules": "∃x (Pet(x) ∧ ManagedBuilding(y) ∧ AllowedIn(x, y)) ::: Pets are allowed in some managed buildings.\n∀x (ManagedBuilding(x) → DepositRequired(x)) ::: A deposit is required to rent an apartment in a managed building.\n∀x ∀y (SecurityDeposit(x, y) → MonthlyRent(x, 1) ∧ EqualOrMore(y, x)) ::: The security deposit can be either equal to one month's rent or more.\nCat(fluffy) ∧ Owner(tom, fluffy) ::: Fluffy is Tom's cat.\n∀x (Cat(x) → Pet(x)) ::: Cats are pets.\nManagedBuilding(olivegarden) ::: The Olive Garden is a managed building.\nMonthlyRent(olivegarden, 2000) ::: The monthly rent at the Olive Garden is $2000.\n∀x ∀y (Owner(x, y) ∧ Pet(y) ∧ ManagedBuilding(z) ∧ AllowedIn(y, z) ∧ SecurityDeposit(z, d) ∧ EqualOrLess(d , 1500) ↔ Rent(x, z)) ::: Tom will rent an apartment in a managed building if and only if he is allowed to move in with Fluffy, and the security deposit is no more than $1500.\nEqualOrMore(2000, 1500) ::: 2000$ is more than $1500.",
                "First-Order-Logic Question": "Rent(tom, olivegarden) ::: Tom will rent an apartment in The Olive Garden."
            },
            "fixed": true
        },
        {
            "id": 95,
            "raw_prog": {
                "First-Order-Logic Rules": [
                    "∃x (ManagedBuilding(x) ∧ Pet(y) ∧ AllowedIn(y, x)) ::: Pets are allowed in some managed buildings.",
                    "∀x (ManagedBuilding(x) → DepositRequired(x)) ::: A deposit is required to rent an apartment in a managed building.",
                    "∀x ∀y (SecurityDeposit(x, y) → (EqualOrMore(y, MonthlyRent(x, 1)) ∨ EqualOrMore(y, MonthlyRent(x, 2)))) ::: The security deposit can be either equal to one month's rent or more.",
                    "Cat(fluffy) ∧ Owner(tom, fluffy) ::: Fluffy is Tom's cat.",
                    "∀x (Cat(x) → Pet(x)) ::: Cats are pets.",
                    "ManagedBuilding(olivegarden) ::: The Olive Garden is a managed building.",
                    "MonthlyRent(olivegarden, 2000) ::: The monthly rent at the Olive Garden is $2000.",
                    "∀x ∀y (Owner(tom, fluffy) ∧ ManagedBuilding(x) ∧ (AllowedIn(fluffy, x) ∧ SecurityDeposit(x, y) ∧ EqualOrMore(1500, y)) ↔ Rent(tom, x)) ::: Tom will rent an apartment in a managed building if and only if he is allowed to move in with Fluffy, and the security deposit is no more than $1500.",
                    "EqualOrMore(2000, 1500) ::: 2000$ is more than $1500."
                ],
                "First-Order-Logic Question": [
                    "SecurityDeposit(olivegarden, 2000) ∨ ∃y (SecurityDeposit(olivegarden, y) ∧ EqualOrMore(y, 2000)) ::: The security deposit at the Olive Garden is either $2000 or more."
                ]
            },
            "gram_prog": {
                "First-Order-Logic Rules": [
                    "∃x (ManagedBuilding(x) ∧ Pet(y) ∧ AllowedIn(y, x)) ::: Pets are allowed in some managed buildings.",
                    "∀x (ManagedBuilding(x) → DepositRequired(x)) ::: A deposit is required to rent an apartment in a managed building.",
                    "∀x∀y(SecurityDeposit(x,y)→(EqualOrMore(y,x))) ::: The security deposit can be either equal to one month's rent or more.",
                    "Cat(fluffy) ∧ Owner(tom, fluffy) ::: Fluffy is Tom's cat.",
                    "∀x (Cat(x) → Pet(x)) ::: Cats are pets.",
                    "ManagedBuilding(olivegarden) ::: The Olive Garden is a managed building.",
                    "MonthlyRent(olivegarden, 2000) ::: The monthly rent at the Olive Garden is $2000.",
                    "∀x ∀y (Owner(tom, fluffy) ∧ ManagedBuilding(x) ∧ (AllowedIn(fluffy, x) ∧ SecurityDeposit(x, y) ∧ EqualOrMore(1500, y)) ↔ Rent(tom, x)) ::: Tom will rent an apartment in a managed building if and only if he is allowed to move in with Fluffy, and the security deposit is no more than $1500.",
                    "EqualOrMore(2000, 1500) ::: 2000$ is more than $1500."
                ],
                "First-Order-Logic Question": [
                    "SecurityDeposit(olivegarden, 2000) ∨ ∃y (SecurityDeposit(olivegarden, y) ∧ EqualOrMore(y, 2000)) ::: The security deposit at the Olive Garden is either $2000 or more."
                ]
            },
            "diff": [
                {
                    "raw": "∀x ∀y (SecurityDeposit(x, y) → (EqualOrMore(y, MonthlyRent(x, 1)) ∨ EqualOrMore(y, MonthlyRent(x, 2)))) ::: The security deposit can be either equal to one month's rent or more.",
                    "gram": "∀x∀y(SecurityDeposit(x,y)→(EqualOrMore(y,x))) ::: The security deposit can be either equal to one month's rent or more."
                }
            ],
            "answer": "A",
            "grammar_answer": "C",
            "backup_answer": "A",
            "manual_prog": {
                "First-Order-Logic Rules": "∃x (ManagedBuilding(x) ∧ Pet(y) ∧ AllowedIn(y, x)) ::: Pets are allowed in some managed buildings.\n∀x (ManagedBuilding(x) → DepositRequired(x)) ::: A deposit is required to rent an apartment in a managed building.\n∀x ∀y (SecurityDeposit(x, y) → ((MonthlyRent(x, 1) ∧ EqualOrMore(y, x)) ∨ (MonthlyRent(x, 2) ∧ EqualOrMore(y, x)))) ::: The security deposit can be either equal to one month's rent or more.\nCat(fluffy) ∧ Owner(tom, fluffy) ::: Fluffy is Tom's cat.\n∀x (Cat(x) → Pet(x)) ::: Cats are pets.\nManagedBuilding(olivegarden) ::: The Olive Garden is a managed building.\nMonthlyRent(olivegarden, 2000) ::: The monthly rent at the Olive Garden is $2000.\n∀x ∀y (Owner(tom, fluffy) ∧ ManagedBuilding(x) ∧ (AllowedIn(fluffy, x) ∧ SecurityDeposit(x, y) ∧ EqualOrMore(1500, y)) ↔ Rent(tom, x)) ::: Tom will rent an apartment in a managed building if and only if he is allowed to move in with Fluffy, and the security deposit is no more than $1500.\nEqualOrMore(2000, 1500) ::: 2000$ is more than $1500.",
                "First-Order-Logic Question": "SecurityDeposit(olivegarden, 2000) ∨ ∃y (SecurityDeposit(olivegarden, y) ∧ EqualOrMore(y, 2000)) ::: The security deposit at the Olive Garden is either $2000 or more."
            },
            "fixed": true
        },
        {
            "id": 113,
            "raw_prog": {
                "First-Order-Logic Rules": [
                    "MountainRange(picurismountains) ∧ (In(picurismountains, newmexico) ⊕ In(picurismountains, texas)) ::: The Picuris Mountains are a mountain range in New Mexico or Texas.",
                    "Visit(juandeonate, picurismountains) ::: Juan de Onate visited the Picuris Mountains.",
                    "Mine(hardingpegmatitemine) ∧ LocatedIn(hardingpegmatitemine, picurismountains) ∧ Donate(hardingpegmatitemine) ::: The Harding Pegmatite Mine, located in the Picuris Mountains, was donated.",
                    "∀x (MountainRange(x) ∧ In(x, texas) → ¬∃y (Mine(y) ∧ LocatedIn(y, x) ∧ Donate(y))) ::: There are no mountain ranges in Texas that have mines which have been donated."
                ],
                "First-Order-Logic Question": "∃x (MountainRange(x) ∧ In(x, texas) ∧ Visit(juandeonate, x)) ::: Juan de Onate visited a mountain range in Texas."
            },
            "gram_prog": {
                "First-Order-Logic Rules": [
                    "MountainRange(picurismountains) ∧ (In(picurismountains, newmexico) ⊕ In(picurismountains, texas)) ::: The Picuris Mountains are a mountain range in New Mexico or Texas.",
                    "Visit(juandeonate, picurismountains) ::: Juan de Onate visited the Picuris Mountains.",
                    "Mine(hardingpegmatitemine) ∧ LocatedIn(hardingpegmatitemine, picurismountains) ∧ Donate(hardingpegmatitemine) ::: The Harding Pegmatite Mine, located in the Picuris Mountains, was donated.",
                    "∀x(MountainRange(x)→¬(In(x,y))) ::: There are no mountain ranges in Texas that have mines which have been donated."
                ],
                "First-Order-Logic Question": "∃x (MountainRange(x) ∧ In(x, texas) ∧ Visit(juandeonate, x)) ::: Juan de Onate visited a mountain range in Texas."
            },
            "diff": [
                {
                    "raw": "∀x (MountainRange(x) ∧ In(x, texas) → ¬∃y (Mine(y) ∧ LocatedIn(y, x) ∧ Donate(y))) ::: There are no mountain ranges in Texas that have mines which have been donated.",
                    "gram": "∀x(MountainRange(x)→¬(In(x,y))) ::: There are no mountain ranges in Texas that have mines which have been donated."
                }
            ],
            "answer": "C",
            "grammar_answer": "A",
            "backup_answer": "B",
            "manual_prog": {
                "First-Order-Logic Rules": "MountainRange(picurismountains) ∧ (In(picurismountains, newmexico) ⊕ In(picurismountains, texas)) ::: The Picuris Mountains are a mountain range in New Mexico or Texas.\nVisit(juandeonate, picurismountains) ::: Juan de Onate visited the Picuris Mountains.\nMine(hardingpegmatitemine) ∧ LocatedIn(hardingpegmatitemine, picurismountains) ∧ Donate(hardingpegmatitemine) ::: The Harding Pegmatite Mine, located in the Picuris Mountains, was donated.\n∀x ∃y (MountainRange(x) ∧ In(x, texas) → ¬(Mine(y) ∧ LocatedIn(y, x) ∧ Donate(y))) ::: There are no mountain ranges in Texas that have mines which have been donated.",
                "First-Order-Logic Question": "∃x (MountainRange(x) ∧ In(x, texas) ∧ Visit(juandeonate, x)) ::: Juan de Onate visited a mountain range in Texas."
            },
            "fixed": true
        },
        {
            "id": 122,
            "raw_prog": {
                "First-Order-Logic Rules": "∀x (TransportMultiplePassengers(x) → ¬Empty(x)) ::: If something can transport multiple passengers, then they are not empty.\n∀x (Airline(x) → TransportMultiplePassengers(x)) ::: All airlines can transport multiple passengers.\n∀x (Plane(x) → Empty(x)) ::: All planes are empty.\n∀x (Boeing707(x) → Plane(x)) ::: All Boeing 707s are planes.\n¬Airline(greyhound) → ¬∃y (Plane(y) ∧ Greyhound(y)) ::: If Greyhound is not an airline, then there are no Greyhound planes.\n",
                "First-Order-Logic Question": "Airline(greyhound) ::: Greyhound is an airline."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∀x (TransportMultiplePassengers(x) → ¬Empty(x)) ::: If something can transport multiple passengers, then they are not empty.\n∀x (Airline(x) → TransportMultiplePassengers(x)) ::: All airlines can transport multiple passengers.\n∀x (Plane(x) → Empty(x)) ::: All planes are empty.\n∀x (Boeing707(x) → Plane(x)) ::: All Boeing 707s are planes.\n¬Airline(greyhound) → (¬Plane(y) ∧ IsGreyhound(y)) ::: If Greyhound is not an airline, then there are no Greyhound planes.\n",
                "First-Order-Logic Question": "Airline(greyhound) ::: Greyhound is an airline."
            },
            "diff": [],
            "answer": "C",
            "grammar_answer": "C",
            "backup_answer": "B",
            "manual_prog": {
                "First-Order-Logic Rules": "∀x (TransportMultiplePassengers(x) → ¬Empty(x)) ::: If something can transport multiple passengers, then they are not empty.\n∀x (Airline(x) → TransportMultiplePassengers(x)) ::: All airlines can transport multiple passengers.\n∀x (Plane(x) → Empty(x)) ::: All planes are empty.\n∀x (Boeing707(x) → Plane(x)) ::: All Boeing 707s are planes.\n¬Airline(greyhound) → ¬∃y (Plane(y) ∧ Greyhound(y)) ::: If Greyhound is not an airline, then there are no Greyhound planes.\n",
                "First-Order-Logic Question": "Airline(greyhound) ::: Greyhound is an airline."
            },
            "fixed": true
        },
        {
            "id": 123,
            "raw_prog": {
                "First-Order-Logic Rules": "∀x (TransportMultiplePassengers(x) → ¬Empty(x)) ::: If something can transport multiple passengers, then they are not empty.\n∀x (Airline(x) → TransportMultiplePassengers(x)) ::: All airlines can transport multiple passengers.\n∀x (Plane(x) → Empty(x)) ::: All planes are empty.\n∀x (Boeing707(x) → Plane(x)) ::: All Boeing 707s are planes.\n¬Airline(greyhound) → ¬∃y (Greyhound(y) ∧ Plane(y)) ::: If Greyhound is not an airline, then there are no Greyhound planes.\n",
                "First-Order-Logic Question": "Boeing707(greyhound) ::: A Greyhound is a Boeing 707."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∀x (TransportMultiplePassengers(x) → ¬Empty(x)) ::: If something can transport multiple passengers, then they are not empty.\n∀x (Airline(x) → TransportMultiplePassengers(x)) ::: All airlines can transport multiple passengers.\n∀x (Plane(x) → Empty(x)) ::: All planes are empty.\n∀x (Boeing707(x) → Plane(x)) ::: All Boeing 707s are planes.\n¬Airline(x)→¬Plane(x) ::: If Greyhound is not an airline, then there are no Greyhound planes.\n",
                "First-Order-Logic Question": "Boeing707(greyhound) ::: A Greyhound is a Boeing 707."
            },
            "diff": [
                {
                    "raw": "¬Airline(greyhound) → ¬∃y (Greyhound(y) ∧ Plane(y)) ::: If Greyhound is not an airline, then there are no Greyhound planes.",
                    "gram": "¬Airline(x)→¬Plane(x) ::: If Greyhound is not an airline, then there are no Greyhound planes."
                }
            ],
            "answer": "B",
            "grammar_answer": "B",
            "backup_answer": "B",
            "manual_prog": {
                "First-Order-Logic Rules": "∀x (TransportMultiplePassengers(x) → ¬Empty(x)) ::: If something can transport multiple passengers, then they are not empty.\n∀x (Airline(x) → TransportMultiplePassengers(x)) ::: All airlines can transport multiple passengers.\n∀x (Plane(x) → Empty(x)) ::: All planes are empty.\n∀x (Boeing707(x) → Plane(x)) ::: All Boeing 707s are planes.\n∃y (¬Airline(greyhound) → ¬(Greyhound(y) ∧ Plane(y))) ::: If Greyhound is not an airline, then there are no Greyhound planes.\n",
                "First-Order-Logic Question": "Boeing707(greyhound) ::: A Greyhound is a Boeing 707."
            },
            "fixed": true
        },
        {
            "id": 124,
            "raw_prog": {
                "First-Order-Logic Rules": "∀x (TransportMultiplePassengers(x) → ¬Empty(x)) ::: If something can transport multiple passengers, then they are not empty.\n∀x (Airline(x) → TransportMultiplePassengers(x)) ::: All airlines can transport multiple passengers.\n∀x (Plane(x) → Empty(x)) ::: All planes are empty.\n∀x (Boeing707(x) → Plane(x)) ::: All Boeing 707s are planes.\n¬Airline(greyhound) → ¬∃y (Greyhound(y) ∧ Plane(y)) ::: If Greyhound is not an airline, then there are no Greyhound planes.\n",
                "First-Order-Logic Question": "¬Greyhound(boeing707) ::: A Greyhound is not a Boeing 707."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∀x (TransportMultiplePassengers(x) → ¬Empty(x)) ::: If something can transport multiple passengers, then they are not empty.\n∀x (Airline(x) → TransportMultiplePassengers(x)) ::: All airlines can transport multiple passengers.\n∀x (Plane(x) → Empty(x)) ::: All planes are empty.\nPlane(boeing707) ::: Boeing 707 is a plane.\n¬Airline(greyhound) → ¬Plane(greyhound) ::: If Greyhound is not an airline, then there are no Greyhound planes.",
                "First-Order-Logic Question": "¬IsGreyhound(boeing707) ::: A Greyhound is not a Boeing 707."
            },
            "diff": [],
            "answer": "A",
            "grammar_answer": "C",
            "backup_answer": "A",
            "manual_prog": {
                "First-Order-Logic Rules": "∀x (TransportMultiplePassengers(x) → ¬Empty(x)) ::: If something can transport multiple passengers, then they are not empty.\n∀x (Airline(x) → TransportMultiplePassengers(x)) ::: All airlines can transport multiple passengers.\n∀x (Plane(x) → Empty(x)) ::: All planes are empty.\n∀x (Boeing707(x) → Plane(x)) ::: All Boeing 707s are planes.\n¬Airline(greyhound) → ¬∃y (Greyhound(y) ∧ Plane(y)) ::: If Greyhound is not an airline, then there are no Greyhound planes.\n",
                "First-Order-Logic Question": "¬Greyhound(boeing707) ::: A Greyhound is not a Boeing 707."
            },
            "fixed": true
        },
        {
            "id": 143,
            "raw_prog": {
                "First-Order-Logic Rules": "∀x (BreedingBack(x) → ArtificiallySelected(x)) ::: Breeding back is a form of artificial selection by the deliberate selective breeding of domestic animals.\nBredBack(heck_cattle, aurochs) ∧ Resemble(heck_cattle, aurochs) ::: Heck cattle were bred-back in the 1920s to resemble the aurochs.\nAnimal(heck_cattle) ::: Heck cattle are animals.\nAnimal(aurochs) ::: Aurochs are animals.\n∃x ∃y (Animal(x) ∧ Animal(y) ∧ BredBack(x, y) ∧ Resemble(x, y) ∧ Extinct(y)) ::: Some animals to be bred-back resemble animals that are extinct.\n",
                "First-Order-Logic Question": "∃x (Animal(x) ∧ ArtificiallySelected(x) ∧ x = heck_cattle) ::: Some Heck cattle are artificially selected."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∀x (BreedingBack(x) → ArtificiallySelected(x)) ::: Breeding back is a form of artificial selection by the deliberate selective breeding of domestic animals.\nBredBack(heck_cattle, aurochs) ∧ Resemble(heck_cattle, aurochs) ::: Heck cattle were bred-back in the 1920s to resemble the aurochs.\nAnimal(heck_cattle) ::: Heck cattle are animals.\nAnimal(aurochs) ::: Aurochs are animals.\n∃x ∃y (Animal(x) ∧ Animal(y) ∧ BredBack(x, y) ∧ Resemble(x, y) ∧ Extinct(y)) ::: Some animals to be bred-back resemble animals that are extinct.\n",
                "First-Order-Logic Question": "∃x(Animal(x)∧ArtificiallySelected(x)∧Resemble(x,x)) ::: Some Heck cattle are artificially selected."
            },
            "diff": [
                {
                    "raw": "∃x (Animal(x) ∧ ArtificiallySelected(x) ∧ x = heck_cattle) ::: Some Heck cattle are artificially selected.",
                    "gram": "∃x(Animal(x)∧ArtificiallySelected(x)∧Resemble(x,x)) ::: Some Heck cattle are artificially selected."
                }
            ],
            "answer": "A",
            "grammar_answer": "C",
            "backup_answer": "A",
            "manual_prog": {
                "First-Order-Logic Rules": "∀x (BreedingBack(x) → ArtificiallySelected(x)) ::: Breeding back is a form of artificial selection by the deliberate selective breeding of domestic animals.\nBredBack(heck_cattle, aurochs) ∧ Resemble(heck_cattle, aurochs) ::: Heck cattle were bred-back in the 1920s to resemble the aurochs.\nAnimal(heck_cattle) ::: Heck cattle are animals.\nAnimal(aurochs) ::: Aurochs are animals.\n∃x ∃y (Animal(x) ∧ Animal(y) ∧ BredBack(x, y) ∧ Resemble(x, y) ∧ Extinct(y)) ::: Some animals to be bred-back resemble animals that are extinct.\n",
                "First-Order-Logic Question": "∃x (Animal(x) ∧ ArtificiallySelected(x) ∧ HeckCattle(x)) ::: Some Heck cattle are artificially selected."
            },
            "fixed": true
        }
    ],
    "outputs_2": [
        {
            "id": 10,
            "raw_prog": {
                "First-Order-Logic Rules": "∀x (WildTurkey(x) → (EasternWildTurkey(x) ∨ OsceolaWildTurkey(x) ∨ GouldsWildTurkey(x) ∨ MerriamsWildTurkey(x) ∨ RioGrandeWildTurkey(x) ∨ OcellatedWildTurkey(x))) ::: There are six types of wild turkeys: Eastern wild turkey, Osceola wild turkey, Gould’s wild turkey, Merriam’s wild turkey, Rio Grande wild turkey, and Ocellated wild turkey.\nNot(tom, EasternWildTurkey(tom)) ::: Tom is not an Eastern wild turkey.\nNot(tom, OsceolaWildTurkey(tom)) ::: Tom is not an Osceola wild turkey.\nNot(tom, GouldsWildTurkey(tom)) ∧ Not(tom, MerriamsWildTurkey(tom)) ∧ Not(tom, RioGrandeWildTurkey(tom)) ::: Tom is also not a Gould's wild turkey, or a Merriam's wild turkey, or a Rio Grande wild turkey.\nWildTurkey(tom) ::: Tom is a wild turkey.\n",
                "First-Order-Logic Question": "EasternWildTurkey(tom) ::: Tom is an Eastern wild turkey."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∀x (WildTurkey(x) → (EasternWildTurkey(x) ∨ OsceolaWildTurkey(x) ∨ GouldsWildTurkey(x) ∨ MerriamsWildTurkey(x) ∨ RioGrandeWildTurkey(x) ∨ OcellatedWildTurkey(x))) ::: There are six types of wild turkeys: Eastern wild turkey, Osceola wild turkey, Gould’s wild turkey, Merriam’s wild turkey, Rio Grande wild turkey, and Ocellated wild turkey.\nNot(x,y)→(EasternWildTurkey(x)→¬OsceolaWildTurkey(x)) ::: Tom is not an Eastern wild turkey.\nNot(x,y)→OsceolaWildTurkey(x) ::: Tom is not an Osceola wild turkey.\nNot(x,y)→(WildTurkey(x)∧¬EasternWildTurkey(x)) ::: Tom is also not a Gould's wild turkey, or a Merriam's wild turkey, or a Rio Grande wild turkey.\nWildTurkey(tom) ::: Tom is a wild turkey.\n",
                "First-Order-Logic Question": "EasternWildTurkey(tom) ::: Tom is an Eastern wild turkey."
            },
            "diff": [
                {
                    "raw": "Not(tom, EasternWildTurkey(tom)) ::: Tom is not an Eastern wild turkey.",
                    "gram": "Not(x,y)→(EasternWildTurkey(x)→¬OsceolaWildTurkey(x)) ::: Tom is not an Eastern wild turkey."
                },
                {
                    "raw": "Not(tom, OsceolaWildTurkey(tom)) ::: Tom is not an Osceola wild turkey.",
                    "gram": "Not(x,y)→OsceolaWildTurkey(x) ::: Tom is not an Osceola wild turkey."
                },
                {
                    "raw": "Not(tom, GouldsWildTurkey(tom)) ∧ Not(tom, MerriamsWildTurkey(tom)) ∧ Not(tom, RioGrandeWildTurkey(tom)) ::: Tom is also not a Gould's wild turkey, or a Merriam's wild turkey, or a Rio Grande wild turkey.",
                    "gram": "Not(x,y)→(WildTurkey(x)∧¬EasternWildTurkey(x)) ::: Tom is also not a Gould's wild turkey, or a Merriam's wild turkey, or a Rio Grande wild turkey."
                }
            ],
            "answer": "B",
            "grammar_answer": "C",
            "backup_answer": "B",
            "manual_prog": {
                "First-Order-Logic Rules": "∀x (WildTurkey(x) → (EasternWildTurkey(x) ∨ OsceolaWildTurkey(x) ∨ GouldsWildTurkey(x) ∨ MerriamsWildTurkey(x) ∨ RioGrandeWildTurkey(x) ∨ OcellatedWildTurkey(x))) ::: There are six types of wild turkeys: Eastern wild turkey, Osceola wild turkey, Gould’s wild turkey, Merriam’s wild turkey, Rio Grande wild turkey, and Ocellated wild turkey.\n¬EasternWildTurkey(tom) ::: Tom is not an Eastern wild turkey.\n¬OsceolaWildTurkey(tom) ::: Tom is not an Osceola wild turkey.\n¬GouldsWildTurkey(tom) ∧ ¬MerriamsWildTurkey(tom) ∧ ¬RioGrandeWildTurkey(tom) ::: Tom is also not a Gould's wild turkey, or a Merriam's wild turkey, or a Rio Grande wild turkey.\nWildTurkey(tom) ::: Tom is a wild turkey.\n",
                "First-Order-Logic Question": "EasternWildTurkey(tom) ::: Tom is an Eastern wild turkey."
            },
            "fixed": true
        },
        {
            "id": 41,
            "raw_prog": {
                "First-Order-Logic Rules": [
                    "∀x (ZahaHadid(x) → Timeless(x)) ::: All of Zaha Hadid's design styles are timeless.",
                    "∀x (MassProduct(x) → ¬Timeless(x)) ::: No mass product design is timeless.",
                    "∀x (ZahaHadid(x) ∨ KellyWearstler(x)) ::: Either Zaha Hadid's design style or Kelly Wearstler's design style.",
                    "∀x (KellyWearstler(x) → Evocative(x)) ::: All of Kelly Wearstler's design styles are evocative.",
                    "∀x (KellyWearstler(x) → Dreamy(x)) ::: All of Kelly Wearstler's design styles are dreamy.",
                    "∀x (Timeless(Max(x)) → (MassProduct(Max(x)) ∧ Evocative(Max(x)))) ::: If a design by Max is timeless, then a design by Max is a mass product design and evocative."
                ],
                "First-Order-Logic Question": [
                    "Evocative(Max(x)) ∨ Dreamy(Max(x)) ::: A design by Max is either evocative or dreamy."
                ]
            },
            "gram_prog": {
                "First-Order-Logic Rules": [
                    "∀x (ZahaHadid(x) → Timeless(x)) ::: All of Zaha Hadid's design styles are timeless.",
                    "∀x (MassProduct(x) → ¬Timeless(x)) ::: No mass product design is timeless.",
                    "∀x (ZahaHadid(x) ∨ KellyWearstler(x)) ::: Either Zaha Hadid's design style or Kelly Wearstler's design style.",
                    "∀x (KellyWearstler(x) → Evocative(x)) ::: All of Kelly Wearstler's design styles are evocative.",
                    "∀x (KellyWearstler(x) → Dreamy(x)) ::: All of Kelly Wearstler's design styles are dreamy.",
                    "∀x(Timeless(x)→(MassProduct(x))) ::: If a design by Max is timeless, then a design by Max is a mass product design and evocative."
                ],
                "First-Order-Logic Question": [
                    "Evocative(x)∨Dreamy(x) ::: A design by Max is either evocative or dreamy."
                ]
            },
            "diff": [
                {
                    "raw": "∀x (Timeless(Max(x)) → (MassProduct(Max(x)) ∧ Evocative(Max(x)))) ::: If a design by Max is timeless, then a design by Max is a mass product design and evocative.",
                    "gram": "∀x(Timeless(x)→(MassProduct(x))) ::: If a design by Max is timeless, then a design by Max is a mass product design and evocative."
                },
                {
                    "raw": "Evocative(Max(x)) ∨ Dreamy(Max(x)) ::: A design by Max is either evocative or dreamy.",
                    "gram": "Evocative(x)∨Dreamy(x) ::: A design by Max is either evocative or dreamy."
                }
            ],
            "answer": "B",
            "grammar_answer": "A",
            "backup_answer": "C",
            "manual_prog": {
                "First-Order-Logic Rules": "∀x (ZahaHadid(x) → Timeless(x)) ::: All of Zaha Hadid's design styles are timeless.\n∀x (MassProduct(x) → ¬Timeless(x)) ::: No mass product design is timeless.\n∀x (ZahaHadid(x) ∨ KellyWearstler(x)) ::: Either Zaha Hadid's design style or Kelly Wearstler's design style.\n∀x (KellyWearstler(x) → Evocative(x)) ::: All of Kelly Wearstler's design styles are evocative.\n∀x (KellyWearstler(x) → Dreamy(x)) ::: All of Kelly Wearstler's design styles are dreamy.\n∀x (Max(x) ∧ Timeless(x) → (Max(x) ∧ MassProduct(x) ∧ Evocative(x))) ::: If a design by Max is timeless, then a design by Max is a mass product design and evocative.",
                "First-Order-Logic Question": "(Max(x) ∧ Evocative(x)) ∨ (Dreamy(x) ∧ Max(x)) ::: A design by Max is either evocative or dreamy."
            },
            "fixed": true
        },
        {
            "id": 47,
            "raw_prog": {
                "First-Order-Logic Rules": [
                    "Season(spring) ∧ Season(summer) ∧ Season(fall) ∧ Season(winter) ::: There are four seasons in a year: Spring, Summer, Fall, and Winter.",
                    "∀x (Student(x) ∧ WantsLongVacation(x) → LovesMost(x, summer)) ::: All students who want to have a long vacation love summer the most.",
                    "FavoriteSeason(emma, summer) ::: Emma's favorite season is summer.",
                    "∀x (FavoriteSeason(mia, x) → x ≠ summer) ::: Mia's favorite season is not the same as Emma's.",
                    "WantsLongVacation(james) ::: James wants to have a long vacation."
                ],
                "First-Order-Logic Question": "FavoriteSeason(james, fall) ::: James's favorite season is fall."
            },
            "gram_prog": {
                "First-Order-Logic Rules": [
                    "Season(spring) ∧ Season(summer) ∧ Season(fall) ∧ Season(winter) ::: There are four seasons in a year: Spring, Summer, Fall, and Winter.",
                    "∀x (Student(x) ∧ WantsLongVacation(x) → LovesMost(x, summer)) ::: All students who want to have a long vacation love summer the most.",
                    "FavoriteSeason(emma, summer) ::: Emma's favorite season is summer.",
                    "∀x(FavoriteSeason(x,y)→¬(IsSummer(y))) ::: Mia's favorite season is not the same as Emma's.",
                    "WantsLongVacation(james) ::: James wants to have a long vacation."
                ],
                "First-Order-Logic Question": "FavoriteSeason(james, fall) ::: James's favorite season is fall."
            },
            "diff": [
                {
                    "raw": "∀x (FavoriteSeason(mia, x) → x ≠ summer) ::: Mia's favorite season is not the same as Emma's.",
                    "gram": "∀x(FavoriteSeason(x,y)→¬(IsSummer(y))) ::: Mia's favorite season is not the same as Emma's."
                }
            ],
            "answer": "C",
            "grammar_answer": "C",
            "backup_answer": "B",
            "manual_prog": {
                "First-Order-Logic Rules": "Season(spring) ∧ Season(summer) ∧ Season(fall) ∧ Season(winter) ::: There are four seasons in a year: Spring, Summer, Fall, and Winter.\n∀x (Student(x) ∧ WantsLongVacation(x) → LovesMost(x, summer)) ::: All students who want to have a long vacation love summer the most.\nFavoriteSeason(emma, summer) ::: Emma's favorite season is summer.\n∀x (FavoriteSeason(mia, x) → ¬Summer(x)) ::: Mia's favorite season is not the same as Emma's.\nWantsLongVacation(james) ::: James wants to have a long vacation.",
                "First-Order-Logic Question": "FavoriteSeason(james, fall) ::: James's favorite season is fall."
            },
            "fixed": true
        },
        {
            "id": 53,
            "raw_prog": {
                "First-Order-Logic Rules": "∀x (RomanceLanguage(x) → IndoEuropeanLanguage(x)) ::: All Romance languages are Indo-European languages.\nLanguageFamily(romanceLanguages) ::: The Romance languages are a language family.\n∀x ∀y (LanguageFamily(f) ∧ RomanceLanguage(x) ∧ RomanceLanguage(y) → Related(x, y)) ::: All languages within a language family are related to each other.\nRomanceLanguage(french) ∧ RomanceLanguage(spanish) ::: French and Spanish are both Romance languages.\nRelated(german, spanish) ::: German is related to Spanish.\n∀x (Basque(x) → ¬∃y (Related(x, y))) ::: Basque is not related to any other language.\n",
                "First-Order-Logic Question": "RomanceLanguage(german) ::: German is a Romance language."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∀x (RomanceLanguage(x) → IndoEuropeanLanguage(x)) ::: All Romance languages are Indo-European languages.\nLanguageFamily(romanceLanguages) ::: The Romance languages are a language family.\n∀x ∀y (LanguageFamily(f) ∧ RomanceLanguage(x) ∧ RomanceLanguage(y) → Related(x, y)) ::: All languages within a language family are related to each other.\nRomanceLanguage(french) ∧ RomanceLanguage(spanish) ::: French and Spanish are both Romance languages.\nRelated(german, spanish) ::: German is related to Spanish.\n∀x(Basque(x)→¬(Related(x,y))) ::: Basque is not related to any other language.\n",
                "First-Order-Logic Question": "RomanceLanguage(german) ::: German is a Romance language."
            },
            "diff": [],
            "answer": "C",
            "grammar_answer": "C",
            "backup_answer": "C",
            "manual_prog": {
                "First-Order-Logic Rules": "∀x (RomanceLanguage(x) → IndoEuropeanLanguage(x)) ::: All Romance languages are Indo-European languages.\nLanguageFamily(romanceLanguages) ::: The Romance languages are a language family.\n∀x ∀y (LanguageFamily(f) ∧ RomanceLanguage(x) ∧ RomanceLanguage(y) → Related(x, y)) ::: All languages within a language family are related to each other.\nRomanceLanguage(french) ∧ RomanceLanguage(spanish) ::: French and Spanish are both Romance languages.\nRelated(german, spanish) ::: German is related to Spanish.\n∀x (Basque(x) → ¬∃y (Related(x, y))) ::: Basque is not related to any other language.\n",
                "First-Order-Logic Question": "RomanceLanguage(german) ::: German is a Romance language."
            },
            "fixed": true
        },
        {
            "id": 70,
            "raw_prog": {
                "First-Order-Logic Rules": [
                    "BritishSitcom(badults) ∧ ∀x (MemberOf(x, pappys) → Star(x, badults)) ::: Badults is a British Sitcom series, starring members of Pappy's.",
                    "Pilot(badults, 2013) ∧ Network(badults, bbcthree) ::: Badults piloted in July 2013 on BBC Three.",
                    "WorkingTitle(badults, thesecretdudesociety) ::: The Working title 'The Secret Dude Society' was used for Badults.",
                    "ScriptEditor(andrewcollins, badults) ::: Andrew Collins was the script editor for Badults."
                ],
                "First-Order-Logic Question": [
                    "∀x (MemberOf(x, pappys) → ¬∃y (Star(x, y) ∧ (Network(y, bbcthree) ∨ Network(y, bbctwo)))) ::: No members of Pappy's have starred for a show piloting on BBC Two or BBC Three."
                ]
            },
            "gram_prog": {
                "First-Order-Logic Rules": [
                    "BritishSitcom(badults) ∧ ∀x (MemberOf(x, pappys) → Star(x, badults)) ::: Badults is a British Sitcom series, starring members of Pappy's.",
                    "Pilot(badults, 2013) ∧ Network(badults, bbcthree) ::: Badults piloted in July 2013 on BBC Three.",
                    "WorkingTitle(badults, thesecretdudesociety) ::: The Working title 'The Secret Dude Society' was used for Badults.",
                    "ScriptEditor(andrewcollins, badults) ::: Andrew Collins was the script editor for Badults."
                ],
                "First-Order-Logic Question": [
                    "∀x(MemberOf(x,y)→¬(Star(x,y))) ::: No members of Pappy's have starred for a show piloting on BBC Two or BBC Three."
                ]
            },
            "diff": [
                {
                    "raw": "∀x (MemberOf(x, pappys) → ¬∃y (Star(x, y) ∧ (Network(y, bbcthree) ∨ Network(y, bbctwo)))) ::: No members of Pappy's have starred for a show piloting on BBC Two or BBC Three.",
                    "gram": "∀x(MemberOf(x,y)→¬(Star(x,y))) ::: No members of Pappy's have starred for a show piloting on BBC Two or BBC Three."
                }
            ],
            "answer": "B",
            "grammar_answer": "C",
            "backup_answer": "B",
            "manual_prog": {
                "First-Order-Logic Rules": "BritishSitcom(badults) ∧ ∀x (MemberOf(x, pappys) → Star(x, badults)) ::: Badults is a British Sitcom series, starring members of Pappy's.\nPilot(badults, 2013) ∧ Network(badults, bbcthree) ::: Badults piloted in July 2013 on BBC Three.\nWorkingTitle(badults, thesecretdudesociety) ::: The Working title 'The Secret Dude Society' was used for Badults.\nScriptEditor(andrewcollins, badults) ::: Andrew Collins was the script editor for Badults.",
                "First-Order-Logic Question": "∀x ∃y (MemberOf(x, pappys) → ¬(Star(x, y) ∧ (Network(y, bbctwo) ∨ Network(y, bbcthree)))) ::: No members of Pappy's have starred for a show piloting on BBC Two or BBC Three."
            },
            "fixed": true
        },
        {
            "id": 93,
            "raw_prog": {
                "First-Order-Logic Rules": [
                    "∃x (Pet(x) ∧ ManagedBuilding(y) ∧ AllowedIn(x, y)) ::: Pets are allowed in some managed buildings.",
                    "∀x (ManagedBuilding(x) → DepositRequired(x)) ::: A deposit is required to rent an apartment in a managed building.",
                    "∀x ∀y (SecurityDeposit(x, y) → (EqualOrMore(y, OneMonthRent(x)) ∨ More(y, OneMonthRent(x)))) ::: The security deposit can be either equal to one month's rent or more.",
                    "Cat(fluffy) ∧ Owner(tom, fluffy) ::: Fluffy is Tom's cat.",
                    "∀x (Cat(x) → Pet(x)) ::: Cats are pets.",
                    "ManagedBuilding(olivegarden) ::: The Olive Garden is a managed building.",
                    "MonthlyRent(olivegarden, 2000) ::: The monthly rent at the Olive Garden is $2000.",
                    "∀x ∀y ∀z (Owner(y, x) ∧ Pet(x) ∧ ManagedBuilding(z) ∧ AllowedIn(x, z) ∧ SecurityDeposit(z, d) ∧ d ≤ 1500 ↔ Rent(y, z)) ::: Tom will rent an apartment in a managed building if and only if he is allowed to move in with Fluffy, and the security deposit is no more than $1500.",
                    "2000 > 1500 ::: 2000$ is more than $1500."
                ],
                "First-Order-Logic Question": [
                    "Rent(tom, olivegarden) ::: Tom will rent an apartment in The Olive Garden."
                ]
            },
            "gram_prog": {
                "First-Order-Logic Rules": [
                    "∃x (Pet(x) ∧ ManagedBuilding(y) ∧ AllowedIn(x, y)) ::: Pets are allowed in some managed buildings.",
                    "∀x (ManagedBuilding(x) → DepositRequired(x)) ::: A deposit is required to rent an apartment in a managed building.",
                    "∀x∀y(SecurityDeposit(x,y)→(EqualOrMore(y,x))) ::: The security deposit can be either equal to one month's rent or more.",
                    "Cat(fluffy) ∧ Owner(tom, fluffy) ::: Fluffy is Tom's cat.",
                    "∀x (Cat(x) → Pet(x)) ::: Cats are pets.",
                    "ManagedBuilding(olivegarden) ::: The Olive Garden is a managed building.",
                    "MonthlyRent(olivegarden, 2000) ::: The monthly rent at the Olive Garden is $2000.",
                    "∀x∀y∀z(Owner(y,x)∧Pet(x)∧ManagedBuilding(z)∧AllowedIn(x,z)) ::: Tom will rent an apartment in a managed building if and only if he is allowed to move in with Fluffy, and the security deposit is no more than $1500.",
                    "DepositRequired(x)→SecurityDeposit(x,y) ::: 2000$ is more than $1500."
                ],
                "First-Order-Logic Question": [
                    "Rent(tom, olivegarden) ::: Tom will rent an apartment in The Olive Garden."
                ]
            },
            "diff": [
                {
                    "raw": "∀x ∀y (SecurityDeposit(x, y) → (EqualOrMore(y, OneMonthRent(x)) ∨ More(y, OneMonthRent(x)))) ::: The security deposit can be either equal to one month's rent or more.",
                    "gram": "∀x∀y(SecurityDeposit(x,y)→(EqualOrMore(y,x))) ::: The security deposit can be either equal to one month's rent or more."
                },
                {
                    "raw": "∀x ∀y ∀z (Owner(y, x) ∧ Pet(x) ∧ ManagedBuilding(z) ∧ AllowedIn(x, z) ∧ SecurityDeposit(z, d) ∧ d ≤ 1500 ↔ Rent(y, z)) ::: Tom will rent an apartment in a managed building if and only if he is allowed to move in with Fluffy, and the security deposit is no more than $1500.",
                    "gram": "∀x∀y∀z(Owner(y,x)∧Pet(x)∧ManagedBuilding(z)∧AllowedIn(x,z)) ::: Tom will rent an apartment in a managed building if and only if he is allowed to move in with Fluffy, and the security deposit is no more than $1500."
                },
                {
                    "raw": "2000 > 1500 ::: 2000$ is more than $1500.",
                    "gram": "DepositRequired(x)→SecurityDeposit(x,y) ::: 2000$ is more than $1500."
                }
            ],
            "answer": "B",
            "grammar_answer": "C",
            "backup_answer": "B",
            "manual_prog": {
                "First-Order-Logic Rules": "∃x (Pet(x) ∧ ManagedBuilding(y) ∧ AllowedIn(x, y)) ::: Pets are allowed in some managed buildings.\n∀x (ManagedBuilding(x) → DepositRequired(x)) ::: A deposit is required to rent an apartment in a managed building.\n∀x ∀y (SecurityDeposit(x, y) → (OneMonthRent(x) ∧ EqualOrMore(y,x) ∨ More(y,x))) ::: The security deposit can be either equal to one month's rent or more.\nCat(fluffy) ∧ Owner(tom, fluffy) ::: Fluffy is Tom's cat.\n∀x (Cat(x) → Pet(x)) ::: Cats are pets.\nManagedBuilding(olivegarden) ::: The Olive Garden is a managed building.\nMonthlyRent(olivegarden, 2000) ::: The monthly rent at the Olive Garden is $2000.\n∀x ∀y ∀z (Owner(y, x) ∧ Pet(x) ∧ ManagedBuilding(z) ∧ AllowedIn(x, z) ∧ SecurityDeposit(z, d) ∧ EqualOrLess(d, 1500) ↔ Rent(y, z)) ::: Tom will rent an apartment in a managed building if and only if he is allowed to move in with Fluffy, and the security deposit is no more than $1500.\nMore(2000,1500) ::: 2000$ is more than $1500.",
                "First-Order-Logic Question": "Rent(tom, olivegarden) ::: Tom will rent an apartment in The Olive Garden."
            },
            "fixed": true
        },
        {
            "id": 94,
            "raw_prog": {
                "First-Order-Logic Rules": [
                    "∃x (ManagedBuilding(x) ∧ Pet(y) ∧ MoveInAllowed(tom, x, y)) ::: Pets are allowed in some managed buildings.",
                    "∀x (ManagedBuilding(x) → DepositRequired(x)) ::: A deposit is required to rent an apartment in a managed building.",
                    "∀x ∀y (SecurityDeposit(x, y) → (y = Rent(x) ∨ y > Rent(x))) ::: The security deposit can be either equal to one month's rent or more.",
                    "Cat(fluffy) ∧ Owner(tom, fluffy) ::: Fluffy is Tom's cat.",
                    "∀x (Cat(x) → Pet(x)) ::: Cats are pets.",
                    "ManagedBuilding(olivegarden) ::: The Olive Garden is a managed building.",
                    "Rent(olivegarden, 2000) ::: The monthly rent at the Olive Garden is $2000.",
                    "∀x ∀y ∀z (RentApartment(x, y) ↔ (MoveInAllowed(x, y, z) ∧ SecurityDeposit(y, d) ∧ d ≤ 1500)) ::: Tom will rent an apartment in a managed building if and only if he is allowed to move in with Fluffy, and the security deposit is no more than $1500.",
                    "2000 > 1500 ::: 2000$ is more than $1500."
                ],
                "First-Order-Logic Question": [
                    "MoveInAllowed(tom, olivegarden, fluffy) ::: Tom is allowed to move in an apartment in The Olive Garden with Fluffy."
                ]
            },
            "gram_prog": {
                "First-Order-Logic Rules": [
                    "∃x (ManagedBuilding(x) ∧ Pet(y) ∧ MoveInAllowed(tom, x, y)) ::: Pets are allowed in some managed buildings.",
                    "∀x (ManagedBuilding(x) → DepositRequired(x)) ::: A deposit is required to rent an apartment in a managed building.",
                    "∀x∀y(SecurityDeposit(x,y)→(Rent(x,y))) ::: The security deposit can be either equal to one month's rent or more.",
                    "Cat(fluffy) ∧ Owner(tom, fluffy) ::: Fluffy is Tom's cat.",
                    "∀x (Cat(x) → Pet(x)) ::: Cats are pets.",
                    "ManagedBuilding(olivegarden) ::: The Olive Garden is a managed building.",
                    "Rent(olivegarden, 2000) ::: The monthly rent at the Olive Garden is $2000.",
                    "∀x∀y∀z(MoveInAllowed(x,y,z)→(SecurityDeposit(y,z))) ::: Tom will rent an apartment in a managed building if and only if he is allowed to move in with Fluffy, and the security deposit is no more than $1500.",
                    "DepositRequired(x)→SecurityDeposit(x,y) ::: 2000$ is more than $1500."
                ],
                "First-Order-Logic Question": [
                    "MoveInAllowed(tom, olivegarden, fluffy) ::: Tom is allowed to move in an apartment in The Olive Garden with Fluffy."
                ]
            },
            "diff": [
                {
                    "raw": "∀x ∀y (SecurityDeposit(x, y) → (y = Rent(x) ∨ y > Rent(x))) ::: The security deposit can be either equal to one month's rent or more.",
                    "gram": "∀x∀y(SecurityDeposit(x,y)→(Rent(x,y))) ::: The security deposit can be either equal to one month's rent or more."
                },
                {
                    "raw": "∀x ∀y ∀z (RentApartment(x, y) ↔ (MoveInAllowed(x, y, z) ∧ SecurityDeposit(y, d) ∧ d ≤ 1500)) ::: Tom will rent an apartment in a managed building if and only if he is allowed to move in with Fluffy, and the security deposit is no more than $1500.",
                    "gram": "∀x∀y∀z(MoveInAllowed(x,y,z)→(SecurityDeposit(y,z))) ::: Tom will rent an apartment in a managed building if and only if he is allowed to move in with Fluffy, and the security deposit is no more than $1500."
                },
                {
                    "raw": "2000 > 1500 ::: 2000$ is more than $1500.",
                    "gram": "DepositRequired(x)→SecurityDeposit(x,y) ::: 2000$ is more than $1500."
                }
            ],
            "answer": "C",
            "grammar_answer": "C",
            "backup_answer": "B",
            "manual_prog": {
                "First-Order-Logic Rules": "∃x (ManagedBuilding(x) ∧ Pet(y) ∧ MoveInAllowed(tom, x, y)) ::: Pets are allowed in some managed buildings.\n∀x (ManagedBuilding(x) → DepositRequired(x)) ::: A deposit is required to rent an apartment in a managed building.\n∀x ∀y (SecurityDeposit(x, y) → (Rent(x) ∨ EqualOrMore(y,x))) ::: The security deposit can be either equal to one month's rent or more.\nCat(fluffy) ∧ Owner(tom, fluffy) ::: Fluffy is Tom's cat.\n∀x (Cat(x) → Pet(x)) ::: Cats are pets.\nManagedBuilding(olivegarden) ::: The Olive Garden is a managed building.\nRent(olivegarden, 2000) ::: The monthly rent at the Olive Garden is $2000.\n∀x ∀y ∀z (RentApartment(x, y) ↔ (MoveInAllowed(x, y, z) ∧ SecurityDeposit(y, d) ∧ EqualOrLess(d, 1500))) ::: Tom will rent an apartment in a managed building if and only if he is allowed to move in with Fluffy, and the security deposit is no more than $1500.\nMore(2000,1500) ::: 2000$ is more than $1500.",
                "First-Order-Logic Question": "MoveInAllowed(tom, olivegarden, fluffy) ::: Tom is allowed to move in an apartment in The Olive Garden with Fluffy."
            },
            "fixed": true
        },
        {
            "id": 95,
            "raw_prog": {
                "First-Order-Logic Rules": [
                    "∃x (ManagedBuilding(x) ∧ Pet(y) ∧ AllowedWithPet(x, y)) ::: Pets are allowed in some managed buildings.",
                    "∀x (ManagedBuilding(x) → DepositRequired(x)) ::: A deposit is required to rent an apartment in a managed building.",
                    "∀x ∀y (SecurityDeposit(x, y) → (EqualOrMore(y, OneMonthRent(x)) ∨ MoreThan(y, OneMonthRent(x)))) ::: The security deposit can be either equal to one month's rent or more.",
                    "Cat(fluffy) ∧ Owner(tom, fluffy) ::: Fluffy is Tom's cat.",
                    "∀x (Cat(x) → Pet(x)) ::: Cats are pets.",
                    "ManagedBuilding(olivegarden) ::: The Olive Garden is a managed building.",
                    "MonthlyRent(olivegarden, 2000) ::: The monthly rent at the Olive Garden is $2000.",
                    "∀x ∀y (Owner(tom, fluffy) ∧ ManagedBuilding(x) ∧ (AllowedWithPet(x, fluffy) ∧ SecurityDeposit(x, y) ∧ EqualOrMore(y, 1500)) ↔ Rent(tom, x)) ::: Tom will rent an apartment in a managed building if and only if he is allowed to move in with Fluffy, and the security deposit is no more than $1500.",
                    "EqualOrMore(2000, 1500) ::: 2000$ is more than $1500."
                ],
                "First-Order-Logic Question": [
                    "SecurityDeposit(olivegarden, 2000) ∨ MoreThan(2000, OneMonthRent(olivegarden)) ::: The security deposit at the Olive Garden is either $2000 or more."
                ]
            },
            "gram_prog": {
                "First-Order-Logic Rules": [
                    "∃x (ManagedBuilding(x) ∧ Pet(y) ∧ AllowedWithPet(x, y)) ::: Pets are allowed in some managed buildings.",
                    "∀x (ManagedBuilding(x) → DepositRequired(x)) ::: A deposit is required to rent an apartment in a managed building.",
                    "∀x∀y(SecurityDeposit(x,y)→(EqualOrMore(y,x))) ::: The security deposit can be either equal to one month's rent or more.",
                    "Cat(fluffy) ∧ Owner(tom, fluffy) ::: Fluffy is Tom's cat.",
                    "∀x (Cat(x) → Pet(x)) ::: Cats are pets.",
                    "ManagedBuilding(olivegarden) ::: The Olive Garden is a managed building.",
                    "MonthlyRent(olivegarden, 2000) ::: The monthly rent at the Olive Garden is $2000.",
                    "∀x ∀y (Owner(tom, fluffy) ∧ ManagedBuilding(x) ∧ (AllowedWithPet(x, fluffy) ∧ SecurityDeposit(x, y) ∧ EqualOrMore(y, 1500)) ↔ Rent(tom, x)) ::: Tom will rent an apartment in a managed building if and only if he is allowed to move in with Fluffy, and the security deposit is no more than $1500.",
                    "EqualOrMore(2000, 1500) ::: 2000$ is more than $1500."
                ],
                "First-Order-Logic Question": [
                    "SecurityDeposit(x,y)∨(AllowedWithPet(x,y)→MonthlyRent(x,y)) ::: The security deposit at the Olive Garden is either $2000 or more."
                ]
            },
            "diff": [
                {
                    "raw": "∀x ∀y (SecurityDeposit(x, y) → (EqualOrMore(y, OneMonthRent(x)) ∨ MoreThan(y, OneMonthRent(x)))) ::: The security deposit can be either equal to one month's rent or more.",
                    "gram": "∀x∀y(SecurityDeposit(x,y)→(EqualOrMore(y,x))) ::: The security deposit can be either equal to one month's rent or more."
                },
                {
                    "raw": "SecurityDeposit(olivegarden, 2000) ∨ MoreThan(2000, OneMonthRent(olivegarden)) ::: The security deposit at the Olive Garden is either $2000 or more.",
                    "gram": "SecurityDeposit(x,y)∨(AllowedWithPet(x,y)→MonthlyRent(x,y)) ::: The security deposit at the Olive Garden is either $2000 or more."
                }
            ],
            "answer": "A",
            "grammar_answer": "C",
            "backup_answer": "A",
            "manual_prog": {
                "First-Order-Logic Rules": "∃x (ManagedBuilding(x) ∧ Pet(y) ∧ AllowedWithPet(x, y)) ::: Pets are allowed in some managed buildings.\n∀x (ManagedBuilding(x) → DepositRequired(x)) ::: A deposit is required to rent an apartment in a managed building.\n∀x ∀y (SecurityDeposit(x, y) → (OneMonthRent(x) ∧ (EqualOrMore(y,x) ∨ MoreThan(y, x)))) ::: The security deposit can be either equal to one month's rent or more.\nCat(fluffy) ∧ Owner(tom, fluffy) ::: Fluffy is Tom's cat.\n∀x (Cat(x) → Pet(x)) ::: Cats are pets.\nManagedBuilding(olivegarden) ::: The Olive Garden is a managed building.\nMonthlyRent(olivegarden, 2000) ::: The monthly rent at the Olive Garden is $2000.\n∀x ∀y (Owner(tom, fluffy) ∧ ManagedBuilding(x) ∧ (AllowedWithPet(x, fluffy) ∧ SecurityDeposit(x, y) ∧ EqualOrMore(y, 1500)) ↔ Rent(tom, x)) ::: Tom will rent an apartment in a managed building if and only if he is allowed to move in with Fluffy, and the security deposit is no more than $1500.\nEqualOrMore(2000, 1500) ::: 2000$ is more than $1500.",
                "First-Order-Logic Question": "SecurityDeposit(olivegarden, 2000) ∨ (OneMonthRent(olivegarden) ∧ MoreThan(2000, olivegarden)) ::: The security deposit at the Olive Garden is either $2000 or more."
            },
            "fixed": true
        },
        {
            "id": 114,
            "raw_prog": {
                "First-Order-Logic Rules": [
                    "MountainRange(picurismountains) ∧ (In(picurismountains, newmexico) ⊕ In(picurismountains, texas)) ::: The Picuris Mountains are a mountain range in New Mexico or Texas.",
                    "Visit(juandeonate, picurismountains) ::: Juan de Onate visited the Picuris Mountains.",
                    "Mine(hardingpegmatitemine) ∧ In(hardingpegmatitemine, picurismountains) ∧ Donate(hardingpegmatitemine) ::: The Harding Pegmatite Mine, located in the Picuris Mountains, was donated.",
                    "∀x (MountainRange(x) ∧ In(x, texas) → ¬∃y (Mine(y) ∧ In(y, x) ∧ Donate(y))) ::: There are no mountain ranges in Texas that have mines which have been donated."
                ],
                "First-Order-Logic Question": [
                    "¬In(hardingpegmatitemine, newmexico) ::: The Harding Pegmatite Mine is not located in a mountain range in New Mexico."
                ]
            },
            "gram_prog": {
                "First-Order-Logic Rules": [
                    "MountainRange(picurismountains) ∧ (In(picurismountains, newmexico) ⊕ In(picurismountains, texas)) ::: The Picuris Mountains are a mountain range in New Mexico or Texas.",
                    "Visit(juandeonate, picurismountains) ::: Juan de Onate visited the Picuris Mountains.",
                    "Mine(hardingpegmatitemine) ∧ In(hardingpegmatitemine, picurismountains) ∧ Donate(hardingpegmatitemine) ::: The Harding Pegmatite Mine, located in the Picuris Mountains, was donated.",
                    "∀x(MountainRange(x)→¬In(x,y))∧¬In(x,y)→Donate(x) ::: There are no mountain ranges in Texas that have mines which have been donated."
                ],
                "First-Order-Logic Question": [
                    "¬In(hardingpegmatitemine, newmexico) ::: The Harding Pegmatite Mine is not located in a mountain range in New Mexico."
                ]
            },
            "diff": [
                {
                    "raw": "∀x (MountainRange(x) ∧ In(x, texas) → ¬∃y (Mine(y) ∧ In(y, x) ∧ Donate(y))) ::: There are no mountain ranges in Texas that have mines which have been donated.",
                    "gram": "∀x(MountainRange(x)→¬In(x,y))∧¬In(x,y)→Donate(x) ::: There are no mountain ranges in Texas that have mines which have been donated."
                }
            ],
            "answer": "B",
            "grammar_answer": "C",
            "backup_answer": "B",
            "manual_prog": {
                "First-Order-Logic Rules": "MountainRange(picurismountains) ∧ (In(picurismountains, newmexico) ⊕ In(picurismountains, texas)) ::: The Picuris Mountains are a mountain range in New Mexico or Texas.\nVisit(juandeonate, picurismountains) ::: Juan de Onate visited the Picuris Mountains.\nMine(hardingpegmatitemine) ∧ In(hardingpegmatitemine, picurismountains) ∧ Donate(hardingpegmatitemine) ::: The Harding Pegmatite Mine, located in the Picuris Mountains, was donated.\n∀x ∃y (MountainRange(x) ∧ In(x, texas) → ¬(Mine(y) ∧ In(y, x) ∧ Donate(y))) ::: There are no mountain ranges in Texas that have mines which have been donated.",
                "First-Order-Logic Question": "¬In(hardingpegmatitemine, newmexico) ::: The Harding Pegmatite Mine is not located in a mountain range in New Mexico."
            },
            "fixed": true
        },
        {
            "id": 124,
            "raw_prog": {
                "First-Order-Logic Rules": "∀x (TransportMultiplePassengers(x) → ¬Empty(x)) ::: If something can transport multiple passengers, then they are not empty.\n∀x (Airline(x) → TransportMultiplePassengers(x)) ::: All airlines can transport multiple passengers.\n∀x (Plane(x) → Empty(x)) ::: All planes are empty.\n∀x (Boeing707(x) → Plane(x)) ::: All Boeing 707s are planes.\n¬Airline(greyhound) → ¬∃y (Greyhound(y) ∧ Plane(y)) ::: If Greyhound is not an airline, then there are no Greyhound planes.\n",
                "First-Order-Logic Question": "¬Greyhound(boeing707) ::: A Greyhound is not a Boeing 707."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∀x (TransportMultiplePassengers(x) → ¬Empty(x)) ::: If something can transport multiple passengers, then they are not empty.\n∀x (Airline(x) → TransportMultiplePassengers(x)) ::: All airlines can transport multiple passengers.\n∀x (Plane(x) → Empty(x)) ::: All planes are empty.\n∀x (IsBoeing707(x) → Plane(x)) ::: All Boeing 707s are planes.\n¬Airline(x)→¬Plane(x) ::: If Greyhound is not an airline, then there are no Greyhound planes.\n",
                "First-Order-Logic Question": "¬Greyhound(boeing707) ::: A Greyhound is not a Boeing 707."
            },
            "diff": [
                {
                    "raw": "¬Airline(greyhound) → ¬∃y (Greyhound(y) ∧ Plane(y)) ::: If Greyhound is not an airline, then there are no Greyhound planes.",
                    "gram": "¬Airline(x)→¬Plane(x) ::: If Greyhound is not an airline, then there are no Greyhound planes."
                }
            ],
            "answer": "A",
            "grammar_answer": "C",
            "backup_answer": "A",
            "manual_prog": {
                "First-Order-Logic Rules": "∀x (TransportMultiplePassengers(x) → ¬Empty(x)) ::: If something can transport multiple passengers, then they are not empty.\n∀x (Airline(x) → TransportMultiplePassengers(x)) ::: All airlines can transport multiple passengers.\n∀x (Plane(x) → Empty(x)) ::: All planes are empty.\n∀x (Boeing707(x) → Plane(x)) ::: All Boeing 707s are planes.\n∃y (¬Airline(greyhound) → ¬(Greyhound(y) ∧ Plane(y))) ::: If Greyhound is not an airline, then there are no Greyhound planes.\n",
                "First-Order-Logic Question": "¬Greyhound(boeing707) ::: A Greyhound is not a Boeing 707."
            },
            "fixed": true
        },
        {
            "id": 143,
            "raw_prog": {
                "First-Order-Logic Rules": "∀x (BreedingBack(x) → ArtificiallySelected(x)) ::: Breeding back is a form of artificial selection by the deliberate selective breeding of domestic animals.\nBredBack(heck_cattle, aurochs) ∧ Resemble(heck_cattle, aurochs) ::: Heck cattle were bred-back in the 1920s to resemble the aurochs.\nAnimal(heck_cattle) ::: Heck cattle are animals.\nAnimal(aurochs) ::: Aurochs are animals.\n∃x (Animal(x) ∧ ∃y (BredBack(x, y) ∧ Resemble(x, y) ∧ Extinct(y))) ::: Some animals to be bred-back resemble animals that are extinct.\n",
                "First-Order-Logic Question": "∃x (Animal(x) ∧ ArtificiallySelected(x) ∧ x = heck_cattle) ::: Some Heck cattle are artificially selected."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∀x (BreedingBack(x) → ArtificiallySelected(x)) ::: Breeding back is a form of artificial selection by the deliberate selective breeding of domestic animals.\nBredBack(heck_cattle, aurochs) ∧ Resemble(heck_cattle, aurochs) ::: Heck cattle were bred-back in the 1920s to resemble the aurochs.\nAnimal(heck_cattle) ::: Heck cattle are animals.\nAnimal(aurochs) ::: Aurochs are animals.\n∃x (Animal(x) ∧ ∃y (BredBack(x, y) ∧ Resemble(x, y) ∧ Extinct(y))) ::: Some animals to be bred-back resemble animals that are extinct.\n",
                "First-Order-Logic Question": "∃x(Animal(x)∧ArtificiallySelected(x)∧Resemble(x,x)) ::: Some Heck cattle are artificially selected."
            },
            "diff": [
                {
                    "raw": "∃x (Animal(x) ∧ ArtificiallySelected(x) ∧ x = heck_cattle) ::: Some Heck cattle are artificially selected.",
                    "gram": "∃x(Animal(x)∧ArtificiallySelected(x)∧Resemble(x,x)) ::: Some Heck cattle are artificially selected."
                }
            ],
            "answer": "A",
            "grammar_answer": "C",
            "backup_answer": "A",
            "manual_prog": {
                "First-Order-Logic Rules": "∀x (BreedingBack(x) → ArtificiallySelected(x)) ::: Breeding back is a form of artificial selection by the deliberate selective breeding of domestic animals.\nBredBack(heck_cattle, aurochs) ∧ Resemble(heck_cattle, aurochs) ::: Heck cattle were bred-back in the 1920s to resemble the aurochs.\nAnimal(heck_cattle) ::: Heck cattle are animals.\nAnimal(aurochs) ::: Aurochs are animals.\n∃x (Animal(x) ∧ ∃y (BredBack(x, y) ∧ Resemble(x, y) ∧ Extinct(y))) ::: Some animals to be bred-back resemble animals that are extinct.\n",
                "First-Order-Logic Question": "∃x (Animal(x) ∧ ArtificiallySelected(x) ∧ HeckCattle(x)) ::: Some Heck cattle are artificially selected."
            },
            "fixed": true
        }
    ],
    "outputs_3": [
        {
            "id": 38,
            "raw_prog": {
                "First-Order-Logic Rules": [
                    "MusicPiece(symphonyNo9) ::: Symphony No. 9 is a music piece.",
                    "∀x (Composer(x) → ∃y (Write(x, y) ∧ MusicPiece(y))) ::: Composers write music pieces.",
                    "Write(beethoven, symphonyNo9) ∧ Composer(beethoven) ::: Beethoven wrote Symphony No. 9.",
                    "Premiere(viennaMusicSociety, symphonyNo9) ::: Vienna Music Society premiered Symphony No. 9.",
                    "Orchestra(viennaMusicSociety) ::: Vienna Music Society is an orchestra.",
                    "Lead(beethoven, viennaMusicSociety) ::: Beethoven leads the Vienna Music Society.",
                    "∀x (Orchestra(x) → ∃y (Lead(y, x) ∧ Conductor(y))) ::: Orchestras are led by conductors."
                ],
                "First-Order-Logic Question": "Not(Conductor(beethoven)) ::: Beethoven is not a conductor."
            },
            "gram_prog": {
                "First-Order-Logic Rules": [
                    "MusicPiece(symphonyNo9) ::: Symphony No. 9 is a music piece.",
                    "∀x (Composer(x) → ∃y (Write(x, y) ∧ MusicPiece(y))) ::: Composers write music pieces.",
                    "Write(beethoven, symphonyNo9) ∧ Composer(beethoven) ::: Beethoven wrote Symphony No. 9.",
                    "Premiere(viennaMusicSociety, symphonyNo9) ::: Vienna Music Society premiered Symphony No. 9.",
                    "Orchestra(viennaMusicSociety) ::: Vienna Music Society is an orchestra.",
                    "Lead(beethoven, viennaMusicSociety) ::: Beethoven leads the Vienna Music Society.",
                    "∀x (Orchestra(x) → ∃y (Lead(y, x) ∧ Conductor(y))) ::: Orchestras are led by conductors."
                ],
                "First-Order-Logic Question": "Not(x)→Composer(x)∨Write(x,y)∨Premiere(x,y)∨Orchestra(x)∨Lead(x,y)∨Conductor(x) ::: Beethoven is not a conductor."
            },
            "diff": [
                {
                    "raw": "Not(Conductor(beethoven)) ::: Beethoven is not a conductor.",
                    "gram": "Not(x)→Composer(x)∨Write(x,y)∨Premiere(x,y)∨Orchestra(x)∨Lead(x,y)∨Conductor(x) ::: Beethoven is not a conductor."
                }
            ],
            "answer": "B",
            "grammar_answer": "C",
            "backup_answer": "B",
            "manual_prog": {
                "First-Order-Logic Rules": "MusicPiece(symphonyNo9) ::: Symphony No. 9 is a music piece.\n∀x (Composer(x) → ∃y (Write(x, y) ∧ MusicPiece(y))) ::: Composers write music pieces.\nWrite(beethoven, symphonyNo9) ∧ Composer(beethoven) ::: Beethoven wrote Symphony No. 9.\nPremiere(viennaMusicSociety, symphonyNo9) ::: Vienna Music Society premiered Symphony No. 9.\nOrchestra(viennaMusicSociety) ::: Vienna Music Society is an orchestra.\nLead(beethoven, viennaMusicSociety) ::: Beethoven leads the Vienna Music Society.\n∀x (Orchestra(x) → ∃y (Lead(y, x) ∧ Conductor(y))) ::: Orchestras are led by conductors.",
                "First-Order-Logic Question": "¬Conductor(beethoven) ::: Beethoven is not a conductor."
            },
            "fixed": true
        },
        {
            "id": 40,
            "raw_prog": {
                "First-Order-Logic Rules": "∀x (ZahaHadid(x) → Timeless(x)) ::: All of Zaha Hadid's design styles are timeless.\n∀x (MassProduct(x) → ¬Timeless(x)) ::: No mass product design is timeless.\n∀x (ZahaHadid(x) ∨ KellyWearstler(x)) ::: Either Zaha Hadid's design style or Kelly Wearstler's design style.\n∀x (KellyWearstler(x) → Evocative(x)) ::: All of Kelly Wearstler's design styles are evocative.\n∀x (KellyWearstler(x) → Dreamy(x)) ::: All of Kelly Wearstler's design styles are dreamy.\n∀x (Timeless(Max(x)) → (MassProduct(Max(x)) ∧ Evocative(Max(x)))) ::: If a design by Max is timeless, then a design by Max is a mass product design and evocative.\n",
                "First-Order-Logic Question": "(Evocative(Max(x)) ∧ Dreamy(Max(x))) ::: A design by Max is evocative and dreamy."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∀x (ZahaHadid(x) → Timeless(x)) ::: All of Zaha Hadid's design styles are timeless.\n∀x (MassProduct(x) → ¬Timeless(x)) ::: No mass product design is timeless.\n∀x (ZahaHadid(x) ∨ KellyWearstler(x)) ::: Either Zaha Hadid's design style or Kelly Wearstler's design style.\n∀x (KellyWearstler(x) → Evocative(x)) ::: All of Kelly Wearstler's design styles are evocative.\n∀x (KellyWearstler(x) → Dreamy(x)) ::: All of Kelly Wearstler's design styles are dreamy.\n∀x(Timeless(x)→(MassProduct(x))) ::: If a design by Max is timeless, then a design by Max is a mass product design and evocative.\n",
                "First-Order-Logic Question": "DesignBy(x,y)→(Evocative(x)∧Dreamy(x)) ::: A design by Max is evocative and dreamy."
            },
            "diff": [
                {
                    "raw": "∀x (Timeless(Max(x)) → (MassProduct(Max(x)) ∧ Evocative(Max(x)))) ::: If a design by Max is timeless, then a design by Max is a mass product design and evocative.",
                    "gram": "∀x(Timeless(x)→(MassProduct(x))) ::: If a design by Max is timeless, then a design by Max is a mass product design and evocative."
                },
                {
                    "raw": "(Evocative(Max(x)) ∧ Dreamy(Max(x))) ::: A design by Max is evocative and dreamy.",
                    "gram": "DesignBy(x,y)→(Evocative(x)∧Dreamy(x)) ::: A design by Max is evocative and dreamy."
                }
            ],
            "answer": "A",
            "grammar_answer": "A",
            "backup_answer": "C",
            "manual_prog": {
                "First-Order-Logic Rules": "∀x (ZahaHadid(x) → Timeless(x)) ::: All of Zaha Hadid's design styles are timeless.\n∀x (MassProduct(x) → ¬Timeless(x)) ::: No mass product design is timeless.\n∀x (ZahaHadid(x) ∨ KellyWearstler(x)) ::: Either Zaha Hadid's design style or Kelly Wearstler's design style.\n∀x (KellyWearstler(x) → Evocative(x)) ::: All of Kelly Wearstler's design styles are evocative.\n∀x (KellyWearstler(x) → Dreamy(x)) ::: All of Kelly Wearstler's design styles are dreamy.\n∀x (Max(x) ∧ Timeless(x) → (Max(x) ∧ MassProduct(x) ∧ Evocative(x))) ::: If a design by Max is timeless, then a design by Max is a mass product design and evocative.\n",
                "First-Order-Logic Question": "Max(x) ∧ Evocative(x) ∧ Dreamy(x) ::: A design by Max is evocative and dreamy."
            },
            "fixed": true
        },
        {
            "id": 47,
            "raw_prog": {
                "First-Order-Logic Rules": "∀x (Season(Spring(x)) ∧ Season(Summer(x)) ∧ Season(Fall(x)) ∧ Season(Winter(x))) ::: There are four seasons in a year: Spring, Summer, Fall, and Winter. \n∀x (WantsLongVacation(x) → ∃y (LovesMost(x, y) ∧ Summer(y))) ::: All students who want to have a long vacation love summer the most. \nFavoriteSeason(emma, y) ∧ Summer(y) ::: Emma's favorite season is summer. \n∀x (FavoriteSeason(mia, z) → ¬FavoriteSeason(mia, y)) ∧ FavoriteSeason(emma, y) ::: Mia's favorite season is not the same as Emma's. \nWantsLongVacation(james) ::: James wants to have a long vacation.\n",
                "First-Order-Logic Question": "FavoriteSeason(james, z) ∧ Fall(z) ::: James's favorite season is fall."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∀x(Season(x)→Spring(x)∨Summer(x)∨Fall(x)) ::: There are four seasons in a year: Spring, Summer, Fall, and Winter. \n∀x (WantsLongVacation(x) → ∃y (LovesMost(x, y) ∧ Summer(y))) ::: All students who want to have a long vacation love summer the most. \nFavoriteSeason(emma, y) ∧ Summer(y) ::: Emma's favorite season is summer. \n∀x (FavoriteSeason(mia, z) → ¬FavoriteSeason(mia, y)) ∧ FavoriteSeason(emma, y) ::: Mia's favorite season is not the same as Emma's. \nWantsLongVacation(james) ::: James wants to have a long vacation.\n",
                "First-Order-Logic Question": "FavoriteSeason(james, z) ∧ Fall(z) ::: James's favorite season is fall."
            },
            "diff": [
                {
                    "raw": "∀x (Season(Spring(x)) ∧ Season(Summer(x)) ∧ Season(Fall(x)) ∧ Season(Winter(x))) ::: There are four seasons in a year: Spring, Summer, Fall, and Winter. ",
                    "gram": "∀x(Season(x)→Spring(x)∨Summer(x)∨Fall(x)) ::: There are four seasons in a year: Spring, Summer, Fall, and Winter. "
                }
            ],
            "answer": "C",
            "grammar_answer": "C",
            "backup_answer": "B",
            "manual_prog": {
                "First-Order-Logic Rules": "∀x (Season(x) ∧ Spring(x) ∧ Summer(x) ∧ Fall(x) ∧ Winter(x)) ::: There are four seasons in a year: Spring, Summer, Fall, and Winter. \n∀x (WantsLongVacation(x) → ∃y (LovesMost(x, y) ∧ Summer(y))) ::: All students who want to have a long vacation love summer the most. \nFavoriteSeason(emma, y) ∧ Summer(y) ::: Emma's favorite season is summer. \n∀x (FavoriteSeason(mia, z) → ¬FavoriteSeason(mia, y)) ∧ FavoriteSeason(emma, y) ::: Mia's favorite season is not the same as Emma's. \nWantsLongVacation(james) ::: James wants to have a long vacation.\n",
                "First-Order-Logic Question": "FavoriteSeason(james, z) ∧ Fall(z) ::: James's favorite season is fall."
            },
            "fixed": true
        },
        {
            "id": 49,
            "raw_prog": {
                "First-Order-Logic Rules": "∀x (Digital(x) → ¬Analog(x)) ::: No digital media are analog.\n∀x (PrintedText(x) → Analog(x)) ::: Every printed text is analog.\n∀x (StreamingService(x) → Digital(x)) ::: All streaming services are digital.\n∀x (HardcoverBook(x) → PrintedText(x)) ::: If an object is a hardcover book then it is printed text.\n∀x (StreamingService(x) ∧ Object1984(x) → HardcoverBook(x)) ::: If 1984 is a streaming service, then 1984 is a hardcover book.\n",
                "First-Order-Logic Question": "PrintedText(Object1984(x)) ::: 1984 is printed text."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∀x (Digital(x) → ¬Analog(x)) ::: No digital media are analog.\n∀x (PrintedText(x) → Analog(x)) ::: Every printed text is analog.\n∀x (StreamingService(x) → Digital(x)) ::: All streaming services are digital.\n∀x (HardcoverBook(x) → PrintedText(x)) ::: If an object is a hardcover book then it is printed text.\n∀x (StreamingService(x) ∧ Object1984(x) → HardcoverBook(x)) ::: If 1984 is a streaming service, then 1984 is a hardcover book.\n",
                "First-Order-Logic Question": "PrintedText(x) ::: 1984 is printed text."
            },
            "diff": [
                {
                    "raw": "PrintedText(Object1984(x)) ::: 1984 is printed text.",
                    "gram": "PrintedText(x) ::: 1984 is printed text."
                }
            ],
            "answer": "C",
            "grammar_answer": "C",
            "backup_answer": "C",
            "manual_prog": {
                "First-Order-Logic Rules": "∀x (Digital(x) → ¬Analog(x)) ::: No digital media are analog.\n∀x (PrintedText(x) → Analog(x)) ::: Every printed text is analog.\n∀x (StreamingService(x) → Digital(x)) ::: All streaming services are digital.\n∀x (HardcoverBook(x) → PrintedText(x)) ::: If an object is a hardcover book then it is printed text.\n∀x (StreamingService(x) ∧ Object1984(x) → HardcoverBook(x)) ::: If 1984 is a streaming service, then 1984 is a hardcover book.\n",
                "First-Order-Logic Question": "Object1984(x) ∧ PrintedText(x) ::: 1984 is printed text."
            },
            "fixed": true
        },
        {
            "id": 70,
            "raw_prog": {
                "First-Order-Logic Rules": [
                    "British(badults) ∧ Sitcom(badults) ∧ ∀x (MemberOf(x, pappys) → Star(x, badults)) ::: Badults is a British Sitcom series, starring members of Pappy's.",
                    "Pilot(badults, 2013) ∧ OnChannel(badults, bbcthree) ::: Badults piloted in July 2013 on BBC Three.",
                    "WorkingTitle(thesecretdudesociety, badults) ::: The Working title 'The Secret Dude Society' was used for Badults.",
                    "ScriptEditor(andrewcollins, badults) ::: Andrew Collins was the script editor for Badults."
                ],
                "First-Order-Logic Question": [
                    "∀x (MemberOf(x, pappys) → ¬∃y (Star(x, y) ∧ (OnChannel(y, bbctwo) ∨ OnChannel(y, bbcthree)))) ::: No members of Pappy's have starred for a show piloting on BBC Two or BBC Three."
                ]
            },
            "gram_prog": {
                "First-Order-Logic Rules": [
                    "British(badults) ∧ Sitcom(badults) ∧ ∀x (MemberOf(x, pappys) → Star(x, badults)) ::: Badults is a British Sitcom series, starring members of Pappy's.",
                    "Pilot(badults, 2013) ∧ OnChannel(badults, bbcthree) ::: Badults piloted in July 2013 on BBC Three.",
                    "WorkingTitle(thesecretdudesociety, badults) ::: The Working title 'The Secret Dude Society' was used for Badults.",
                    "ScriptEditor(andrewcollins, badults) ::: Andrew Collins was the script editor for Badults."
                ],
                "First-Order-Logic Question": [
                    "∀x(MemberOf(x,y)→¬(Star(x,y))) ::: No members of Pappy's have starred for a show piloting on BBC Two or BBC Three."
                ]
            },
            "diff": [
                {
                    "raw": "∀x (MemberOf(x, pappys) → ¬∃y (Star(x, y) ∧ (OnChannel(y, bbctwo) ∨ OnChannel(y, bbcthree)))) ::: No members of Pappy's have starred for a show piloting on BBC Two or BBC Three.",
                    "gram": "∀x(MemberOf(x,y)→¬(Star(x,y))) ::: No members of Pappy's have starred for a show piloting on BBC Two or BBC Three."
                }
            ],
            "answer": "B",
            "grammar_answer": "C",
            "backup_answer": "B",
            "manual_prog": {
                "First-Order-Logic Rules": "British(badults) ∧ Sitcom(badults) ∧ ∀x (MemberOf(x, pappys) → Star(x, badults)) ::: Badults is a British Sitcom series, starring members of Pappy's.\nPilot(badults, 2013) ∧ OnChannel(badults, bbcthree) ::: Badults piloted in July 2013 on BBC Three.\nWorkingTitle(thesecretdudesociety, badults) ::: The Working title 'The Secret Dude Society' was used for Badults.\nScriptEditor(andrewcollins, badults) ::: Andrew Collins was the script editor for Badults.",
                "First-Order-Logic Question": "∀x ∃y (MemberOf(x, pappys) → ¬(Star(x, y) ∧ (OnChannel(y, bbctwo) ∨ OnChannel(y, bbcthree)))) ::: No members of Pappy's have starred for a show piloting on BBC Two or BBC Three."
            },
            "fixed": true
        },
        {
            "id": 93,
            "raw_prog": {
                "First-Order-Logic Rules": [
                    "∃x (Pet(x) ∧ ManagedBuilding(y) ∧ AllowedIn(x, y)) ::: Pets are allowed in some managed buildings.",
                    "∀x (ManagedBuilding(x) → DepositRequired(x)) ::: A deposit is required to rent an apartment in a managed building.",
                    "∀x ∀y (SecurityDeposit(x, y) → (EqualTo(y, OneMonthRent(x)) ∨ MoreThan(y, OneMonthRent(x)))) ::: The security deposit can be either equal to one month's rent or more.",
                    "Owns(tom, fluffy) ∧ Cat(fluffy) ::: Fluffy is Tom's cat.",
                    "∀x (Cat(x) → Pet(x)) ::: Cats are pets.",
                    "ManagedBuilding(olivegarden) ::: The Olive Garden is a managed building.",
                    "MonthlyRent(olivegarden, 2000) ::: The monthly rent at the Olive Garden is $2000.",
                    "∀x ∀y (Rent(tom, x) ↔ (AllowedIn(fluffy, x) ∧ SecurityDeposit(x, y) ∧ ¬MoreThan(y, 1500))) ::: Tom will rent an apartment in a managed building if and only if he is allowed to move in with Fluffy, and the security deposit is no more than $1500.",
                    "MoreThan(2000, 1500) ::: 2000$ is more than $1500."
                ],
                "First-Order-Logic Question": [
                    "Rent(tom, olivegarden) ::: Tom will rent an apartment in The Olive Garden."
                ]
            },
            "gram_prog": {
                "First-Order-Logic Rules": [
                    "∃x (Pet(x) ∧ ManagedBuilding(y) ∧ AllowedIn(x, y)) ::: Pets are allowed in some managed buildings.",
                    "∀x (ManagedBuilding(x) → DepositRequired(x)) ::: A deposit is required to rent an apartment in a managed building.",
                    "∀x∀y(SecurityDeposit(x,y)→(EqualTo(y,x))) ::: The security deposit can be either equal to one month's rent or more.",
                    "Owns(tom, fluffy) ∧ Cat(fluffy) ::: Fluffy is Tom's cat.",
                    "∀x (Cat(x) → Pet(x)) ::: Cats are pets.",
                    "ManagedBuilding(olivegarden) ::: The Olive Garden is a managed building.",
                    "MonthlyRent(olivegarden, 2000) ::: The monthly rent at the Olive Garden is $2000.",
                    "∀x ∀y (Rent(tom, x) ↔ (AllowedIn(fluffy, x) ∧ SecurityDeposit(x, y) ∧ ¬MoreThan(y, 1500))) ::: Tom will rent an apartment in a managed building if and only if he is allowed to move in with Fluffy, and the security deposit is no more than $1500.",
                    "MoreThan(2000, 1500) ::: 2000$ is more than $1500."
                ],
                "First-Order-Logic Question": [
                    "Rent(tom, olivegarden) ::: Tom will rent an apartment in The Olive Garden."
                ]
            },
            "diff": [
                {
                    "raw": "∀x ∀y (SecurityDeposit(x, y) → (EqualTo(y, OneMonthRent(x)) ∨ MoreThan(y, OneMonthRent(x)))) ::: The security deposit can be either equal to one month's rent or more.",
                    "gram": "∀x∀y(SecurityDeposit(x,y)→(EqualTo(y,x))) ::: The security deposit can be either equal to one month's rent or more."
                }
            ],
            "answer": "B",
            "grammar_answer": "B",
            "backup_answer": "B",
            "manual_prog": {
                "First-Order-Logic Rules": "∃x (Pet(x) ∧ ManagedBuilding(y) ∧ AllowedIn(x, y)) ::: Pets are allowed in some managed buildings.\n∀x (ManagedBuilding(x) → DepositRequired(x)) ::: A deposit is required to rent an apartment in a managed building.\n∀x ∀y (SecurityDeposit(x, y) → (OneMonthRent(x) ∧ (EqualOrMore(y,x) ∨ MoreThan(y, x)))) ::: The security deposit can be either equal to one month's rent or more.\nOwns(tom, fluffy) ∧ Cat(fluffy) ::: Fluffy is Tom's cat.\n∀x (Cat(x) → Pet(x)) ::: Cats are pets.\nManagedBuilding(olivegarden) ::: The Olive Garden is a managed building.\nMonthlyRent(olivegarden, 2000) ::: The monthly rent at the Olive Garden is $2000.\n∀x ∀y (Rent(tom, x) ↔ (AllowedIn(fluffy, x) ∧ SecurityDeposit(x, y) ∧ ¬MoreThan(y, 1500))) ::: Tom will rent an apartment in a managed building if and only if he is allowed to move in with Fluffy, and the security deposit is no more than $1500.\nMoreThan(2000, 1500) ::: 2000$ is more than $1500.",
                "First-Order-Logic Question": "Rent(tom, olivegarden) ::: Tom will rent an apartment in The Olive Garden."
            },
            "fixed": true
        },
        {
            "id": 95,
            "raw_prog": {
                "First-Order-Logic Rules": [
                    "∃x (Pet(x) ∧ ManagedBuilding(y) ∧ AllowedIn(x, y)) ::: Pets are allowed in some managed buildings.",
                    "∀x (ManagedBuilding(x) → DepositRequired(x)) ::: A deposit is required to rent an apartment in a managed building.",
                    "∀x ∀y (SecurityDeposit(x, y) → EqualOrMore(y, MonthlyRent(x, 1))) ::: The security deposit can be either equal to one month's rent or more.",
                    "Cat(fluffy) ∧ Owner(tom, fluffy) ::: Fluffy is Tom's cat.",
                    "∀x (Cat(x) → Pet(x)) ::: Cats are pets.",
                    "ManagedBuilding(olivegarden) ::: The Olive Garden is a managed building.",
                    "MonthlyRent(olivegarden, 2000) ::: The monthly rent at the Olive Garden is $2000.",
                    "∀x ∀y (Owner(x, y) ∧ Pet(y) ∧ ManagedBuilding(z) ∧ AllowedIn(y, z) ∧ SecurityDeposit(z, d) ∧ d ≤ 1500 ↔ Rent(x, z)) ::: Tom will rent an apartment in a managed building if and only if he is allowed to move in with Fluffy, and the security deposit is no more than $1500.",
                    "EqualOrMore(2000, 1500) ::: 2000$ is more than $1500."
                ],
                "First-Order-Logic Question": [
                    "SecurityDeposit(olivegarden, 2000) ∨ ∃x (SecurityDeposit(olivegarden, x) ∧ EqualOrMore(x, 2000)) ::: The security deposit at the Olive Garden is either $2000 or more."
                ]
            },
            "gram_prog": {
                "First-Order-Logic Rules": [
                    "∃x (Pet(x) ∧ ManagedBuilding(y) ∧ AllowedIn(x, y)) ::: Pets are allowed in some managed buildings.",
                    "∀x (ManagedBuilding(x) → DepositRequired(x)) ::: A deposit is required to rent an apartment in a managed building.",
                    "∀x∀y(SecurityDeposit(x,y)→EqualOrMore(y,x)) ::: The security deposit can be either equal to one month's rent or more.",
                    "Cat(fluffy) ∧ Owner(tom, fluffy) ::: Fluffy is Tom's cat.",
                    "∀x (Cat(x) → Pet(x)) ::: Cats are pets.",
                    "ManagedBuilding(olivegarden) ::: The Olive Garden is a managed building.",
                    "MonthlyRent(olivegarden, 2000) ::: The monthly rent at the Olive Garden is $2000.",
                    "∀x∀y(Owner(x,y)∧Pet(y)∧ManagedBuilding(z)∧AllowedIn(y,z)) ::: Tom will rent an apartment in a managed building if and only if he is allowed to move in with Fluffy, and the security deposit is no more than $1500.",
                    "EqualOrMore(2000, 1500) ::: 2000$ is more than $1500."
                ],
                "First-Order-Logic Question": [
                    "SecurityDeposit(olivegarden, 2000) ∨ ∃x (SecurityDeposit(olivegarden, x) ∧ EqualOrMore(x, 2000)) ::: The security deposit at the Olive Garden is either $2000 or more."
                ]
            },
            "diff": [
                {
                    "raw": "∀x ∀y (SecurityDeposit(x, y) → EqualOrMore(y, MonthlyRent(x, 1))) ::: The security deposit can be either equal to one month's rent or more.",
                    "gram": "∀x∀y(SecurityDeposit(x,y)→EqualOrMore(y,x)) ::: The security deposit can be either equal to one month's rent or more."
                },
                {
                    "raw": "∀x ∀y (Owner(x, y) ∧ Pet(y) ∧ ManagedBuilding(z) ∧ AllowedIn(y, z) ∧ SecurityDeposit(z, d) ∧ d ≤ 1500 ↔ Rent(x, z)) ::: Tom will rent an apartment in a managed building if and only if he is allowed to move in with Fluffy, and the security deposit is no more than $1500.",
                    "gram": "∀x∀y(Owner(x,y)∧Pet(y)∧ManagedBuilding(z)∧AllowedIn(y,z)) ::: Tom will rent an apartment in a managed building if and only if he is allowed to move in with Fluffy, and the security deposit is no more than $1500."
                }
            ],
            "answer": "A",
            "grammar_answer": "C",
            "backup_answer": "A",
            "manual_prog": {
                "First-Order-Logic Rules": "∃x (Pet(x) ∧ ManagedBuilding(y) ∧ AllowedIn(x, y)) ::: Pets are allowed in some managed buildings.\n∀x (ManagedBuilding(x) → DepositRequired(x)) ::: A deposit is required to rent an apartment in a managed building.\n∀x ∀y (SecurityDeposit(x, y) → MonthlyRent(x, 1) ∧ EqualOrMore(y, x)) ::: The security deposit can be either equal to one month's rent or more.\nCat(fluffy) ∧ Owner(tom, fluffy) ::: Fluffy is Tom's cat.\n∀x (Cat(x) → Pet(x)) ::: Cats are pets.\nManagedBuilding(olivegarden) ::: The Olive Garden is a managed building.\nMonthlyRent(olivegarden, 2000) ::: The monthly rent at the Olive Garden is $2000.\n∀x ∀y (Owner(x, y) ∧ Pet(y) ∧ ManagedBuilding(z) ∧ AllowedIn(y, z) ∧ SecurityDeposit(z, d) ∧ EqualOrLess(d , 1500) ↔ Rent(x, z)) ::: Tom will rent an apartment in a managed building if and only if he is allowed to move in with Fluffy, and the security deposit is no more than $1500.\nEqualOrMore(2000, 1500) ::: 2000$ is more than $1500.",
                "First-Order-Logic Question": "SecurityDeposit(olivegarden, 2000) ∨ ∃x (SecurityDeposit(olivegarden, x) ∧ EqualOrMore(x, 2000)) ::: The security deposit at the Olive Garden is either $2000 or more."
            },
            "fixed": true
        },
        {
            "id": 114,
            "raw_prog": {
                "First-Order-Logic Rules": [
                    "MountainRange(picurismountains) ∧ (LocatedIn(picurismountains, newmexico) ⊕ LocatedIn(picurismountains, texas)) ::: The Picuris Mountains are a mountain range in New Mexico or Texas.",
                    "Visited(juandeonate, picurismountains) ::: Juan de Onate visited the Picuris Mountains.",
                    "Mine(hardingpegmatitemine) ∧ LocatedIn(hardingpegmatitemine, picurismountains) ∧ Donated(hardingpegmatitemine) ::: The Harding Pegmatite Mine, located in the Picuris Mountains, was donated.",
                    "∀x (MountainRange(x) ∧ InTexas(x) → ¬∃y (Mine(y) ∧ LocatedIn(y, x) ∧ Donated(y))) ::: There are no mountain ranges in Texas that have mines which have been donated."
                ],
                "First-Order-Logic Question": [
                    "¬LocatedIn(hardingpegmatitemine, picurismountains) ∧ LocatedIn(picurismountains, newmexico) ::: The Harding Pegmatite Mine is not located in a mountain range in New Mexico."
                ]
            },
            "gram_prog": {
                "First-Order-Logic Rules": [
                    "MountainRange(picurismountains) ∧ (LocatedIn(picurismountains, newmexico) ⊕ LocatedIn(picurismountains, texas)) ::: The Picuris Mountains are a mountain range in New Mexico or Texas.",
                    "Visited(juandeonate, picurismountains) ::: Juan de Onate visited the Picuris Mountains.",
                    "Mine(hardingpegmatitemine) ∧ LocatedIn(hardingpegmatitemine, picurismountains) ∧ Donated(hardingpegmatitemine) ::: The Harding Pegmatite Mine, located in the Picuris Mountains, was donated.",
                    "∀x(MountainRange(x)→¬LocatedIn(x,y))∧¬Visited(x,y)∧Donated(x)∧¬Mine(x)∧¬InTexas(x) ::: There are no mountain ranges in Texas that have mines which have been donated."
                ],
                "First-Order-Logic Question": [
                    "¬LocatedIn(hardingpegmatitemine, picurismountains) ∧ LocatedIn(picurismountains, newmexico) ::: The Harding Pegmatite Mine is not located in a mountain range in New Mexico."
                ]
            },
            "diff": [
                {
                    "raw": "∀x (MountainRange(x) ∧ InTexas(x) → ¬∃y (Mine(y) ∧ LocatedIn(y, x) ∧ Donated(y))) ::: There are no mountain ranges in Texas that have mines which have been donated.",
                    "gram": "∀x(MountainRange(x)→¬LocatedIn(x,y))∧¬Visited(x,y)∧Donated(x)∧¬Mine(x)∧¬InTexas(x) ::: There are no mountain ranges in Texas that have mines which have been donated."
                }
            ],
            "answer": "B",
            "grammar_answer": "A",
            "backup_answer": "B",
            "manual_prog": {
                "First-Order-Logic Rules": "MountainRange(picurismountains) ∧ (LocatedIn(picurismountains, newmexico) ⊕ LocatedIn(picurismountains, texas)) ::: The Picuris Mountains are a mountain range in New Mexico or Texas.\nVisited(juandeonate, picurismountains) ::: Juan de Onate visited the Picuris Mountains.\nMine(hardingpegmatitemine) ∧ LocatedIn(hardingpegmatitemine, picurismountains) ∧ Donated(hardingpegmatitemine) ::: The Harding Pegmatite Mine, located in the Picuris Mountains, was donated.\n∀x ∃y (MountainRange(x) ∧ InTexas(x) → ¬(Mine(y) ∧ LocatedIn(y, x) ∧ Donated(y))) ::: There are no mountain ranges in Texas that have mines which have been donated.",
                "First-Order-Logic Question": "¬LocatedIn(hardingpegmatitemine, picurismountains) ∧ LocatedIn(picurismountains, newmexico) ::: The Harding Pegmatite Mine is not located in a mountain range in New Mexico."
            },
            "fixed": true
        },
        {
            "id": 122,
            "raw_prog": {
                "First-Order-Logic Rules": "∀x (TransportMultiplePassengers(x) → ¬Empty(x)) ::: If something can transport multiple passengers, then they are not empty.\n∀x (Airline(x) → TransportMultiplePassengers(x)) ::: All airlines can transport multiple passengers.\n∀x (Plane(x) → Empty(x)) ::: All planes are empty.\n∀x (Boeing707(x) → Plane(x)) ::: All Boeing 707s are planes.\n¬Airline(greyhound) → ¬∃y (Greyhound(y) ∧ Plane(y)) ::: If Greyhound is not an airline, then there are no Greyhound planes.\n",
                "First-Order-Logic Question": "Airline(greyhound) ::: Greyhound is an airline."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∀x (TransportMultiplePassengers(x) → ¬Empty(x)) ::: If something can transport multiple passengers, then they are not empty.\n∀x (Airline(x) → TransportMultiplePassengers(x)) ::: All airlines can transport multiple passengers.\n∀x (Plane(x) → Empty(x)) ::: All planes are empty.\n∀x (Boeing707(x) → Plane(x)) ::: All Boeing 707s are planes.\n¬Airline(x)→¬Plane(x) ::: If Greyhound is not an airline, then there are no Greyhound planes.\n",
                "First-Order-Logic Question": "Airline(greyhound) ::: Greyhound is an airline."
            },
            "diff": [
                {
                    "raw": "¬Airline(greyhound) → ¬∃y (Greyhound(y) ∧ Plane(y)) ::: If Greyhound is not an airline, then there are no Greyhound planes.",
                    "gram": "¬Airline(x)→¬Plane(x) ::: If Greyhound is not an airline, then there are no Greyhound planes."
                }
            ],
            "answer": "C",
            "grammar_answer": "C",
            "backup_answer": "B",
            "manual_prog": {
                "First-Order-Logic Rules": "∀x (TransportMultiplePassengers(x) → ¬Empty(x)) ::: If something can transport multiple passengers, then they are not empty.\n∀x (Airline(x) → TransportMultiplePassengers(x)) ::: All airlines can transport multiple passengers.\n∀x (Plane(x) → Empty(x)) ::: All planes are empty.\n∀x (Boeing707(x) → Plane(x)) ::: All Boeing 707s are planes.\n∃y (¬Airline(greyhound) → ¬(Greyhound(y) ∧ Plane(y))) ::: If Greyhound is not an airline, then there are no Greyhound planes.\n",
                "First-Order-Logic Question": "Airline(greyhound) ::: Greyhound is an airline."
            },
            "fixed": true
        },
        {
            "id": 123,
            "raw_prog": {
                "First-Order-Logic Rules": "∀x (TransportMultiplePassengers(x) → ¬Empty(x)) ::: If something can transport multiple passengers, then they are not empty.\n∀x (Airline(x) → TransportMultiplePassengers(x)) ::: All airlines can transport multiple passengers.\n∀x (Plane(x) → Empty(x)) ::: All planes are empty.\n∀x (Boeing707(x) → Plane(x)) ::: All Boeing 707s are planes.\n¬Airline(greyhound) → ¬∃y (Greyhound(y) ∧ Plane(y)) ::: If Greyhound is not an airline, then there are no Greyhound planes.\n",
                "First-Order-Logic Question": "Boeing707(greyhound) ::: A Greyhound is a Boeing 707."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∀x (TransportMultiplePassengers(x) → ¬Empty(x)) ::: If something can transport multiple passengers, then they are not empty.\n∀x (Airline(x) → TransportMultiplePassengers(x)) ::: All airlines can transport multiple passengers.\n∀x (Plane(x) → Empty(x)) ::: All planes are empty.\n∀x (Boeing707(x) → Plane(x)) ::: All Boeing 707s are planes.\n¬Airline(x)→¬Plane(x) ::: If Greyhound is not an airline, then there are no Greyhound planes.\n",
                "First-Order-Logic Question": "Boeing707(greyhound) ::: A Greyhound is a Boeing 707."
            },
            "diff": [
                {
                    "raw": "¬Airline(greyhound) → ¬∃y (Greyhound(y) ∧ Plane(y)) ::: If Greyhound is not an airline, then there are no Greyhound planes.",
                    "gram": "¬Airline(x)→¬Plane(x) ::: If Greyhound is not an airline, then there are no Greyhound planes."
                }
            ],
            "answer": "B",
            "grammar_answer": "B",
            "backup_answer": "B",
            "manual_prog": {
                "First-Order-Logic Rules": "∀x (TransportMultiplePassengers(x) → ¬Empty(x)) ::: If something can transport multiple passengers, then they are not empty.\n∀x (Airline(x) → TransportMultiplePassengers(x)) ::: All airlines can transport multiple passengers.\n∀x (Plane(x) → Empty(x)) ::: All planes are empty.\n∀x (Boeing707(x) → Plane(x)) ::: All Boeing 707s are planes.\n∃y (¬Airline(greyhound) → ¬(Greyhound(y) ∧ Plane(y))) ::: If Greyhound is not an airline, then there are no Greyhound planes.\n",
                "First-Order-Logic Question": "Boeing707(greyhound) ::: A Greyhound is a Boeing 707."
            },
            "fixed": true
        },
        {
            "id": 124,
            "raw_prog": {
                "First-Order-Logic Rules": "∀x (TransportMultiplePassengers(x) → ¬Empty(x)) ::: If something can transport multiple passengers, then they are not empty.\n∀x (Airline(x) → TransportMultiplePassengers(x)) ::: All airlines can transport multiple passengers.\n∀x (Plane(x) → Empty(x)) ::: All planes are empty.\n∀x (Boeing707(x) → Plane(x)) ::: All Boeing 707s are planes.\n¬Airline(greyhound) → ¬∃y (Greyhound(y) ∧ Plane(y)) ::: If Greyhound is not an airline, then there are no Greyhound planes.\n",
                "First-Order-Logic Question": "¬Greyhound(boeing707) ::: A Greyhound is not a Boeing 707."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∀x (TransportMultiplePassengers(x) → ¬Empty(x)) ::: If something can transport multiple passengers, then they are not empty.\n∀x (Airline(x) → TransportMultiplePassengers(x)) ::: All airlines can transport multiple passengers.\n∀x (Plane(x) → Empty(x)) ::: All planes are empty.\n∀x (IsBoeing707(x) → Plane(x)) ::: All Boeing 707s are planes.\n¬Airline(x)→¬Plane(x) ::: If Greyhound is not an airline, then there are no Greyhound planes.\n",
                "First-Order-Logic Question": "¬Greyhound(boeing707) ::: A Greyhound is not a Boeing 707."
            },
            "diff": [
                {
                    "raw": "¬Airline(greyhound) → ¬∃y (Greyhound(y) ∧ Plane(y)) ::: If Greyhound is not an airline, then there are no Greyhound planes.",
                    "gram": "¬Airline(x)→¬Plane(x) ::: If Greyhound is not an airline, then there are no Greyhound planes."
                }
            ],
            "answer": "A",
            "grammar_answer": "C",
            "backup_answer": "A",
            "manual_prog": {
                "First-Order-Logic Rules": "∀x (TransportMultiplePassengers(x) → ¬Empty(x)) ::: If something can transport multiple passengers, then they are not empty.\n∀x (Airline(x) → TransportMultiplePassengers(x)) ::: All airlines can transport multiple passengers.\n∀x (Plane(x) → Empty(x)) ::: All planes are empty.\n∀x (Boeing707(x) → Plane(x)) ::: All Boeing 707s are planes.\n∃y (¬Airline(greyhound) → ¬(Greyhound(y) ∧ Plane(y))) ::: If Greyhound is not an airline, then there are no Greyhound planes.\n",
                "First-Order-Logic Question": "¬Greyhound(boeing707) ::: A Greyhound is not a Boeing 707."
            },
            "fixed": true
        },
        {
            "id": 143,
            "raw_prog": {
                "First-Order-Logic Rules": "∀x (BreedingBack(x) → ArtificiallySelected(x)) ::: Breeding back is a form of artificial selection by the deliberate selective breeding of domestic animals.\nBredBack(heck_cattle, aurochs) ∧ Resemble(heck_cattle, aurochs) ::: Heck cattle were bred-back in the 1920s to resemble the aurochs.\nAnimal(heck_cattle) ::: Heck cattle are animals.\nAnimal(aurochs) ::: Aurochs are animals.\n∃x (Animal(x) ∧ ∃y (Animal(y) ∧ Extinct(y) ∧ Resemble(x, y))) ::: Some animals to be bred-back resemble animals that are extinct.\n",
                "First-Order-Logic Question": "∃x (Animal(x) ∧ ArtificiallySelected(x) ∧ x = heck_cattle) ::: Some Heck cattle are artificially selected."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∀x (BreedingBack(x) → ArtificiallySelected(x)) ::: Breeding back is a form of artificial selection by the deliberate selective breeding of domestic animals.\nBredBack(heck_cattle, aurochs) ∧ Resemble(heck_cattle, aurochs) ::: Heck cattle were bred-back in the 1920s to resemble the aurochs.\nAnimal(heck_cattle) ::: Heck cattle are animals.\nAnimal(aurochs) ::: Aurochs are animals.\n∃x (Animal(x) ∧ ∃y (Animal(y) ∧ Extinct(y) ∧ Resemble(x, y))) ::: Some animals to be bred-back resemble animals that are extinct.\n",
                "First-Order-Logic Question": "∃x(Animal(x)∧ArtificiallySelected(x)∧Resemble(x,x)) ::: Some Heck cattle are artificially selected."
            },
            "diff": [
                {
                    "raw": "∃x (Animal(x) ∧ ArtificiallySelected(x) ∧ x = heck_cattle) ::: Some Heck cattle are artificially selected.",
                    "gram": "∃x(Animal(x)∧ArtificiallySelected(x)∧Resemble(x,x)) ::: Some Heck cattle are artificially selected."
                }
            ],
            "answer": "A",
            "grammar_answer": "C",
            "backup_answer": "A",
            "manual_prog": {
                "First-Order-Logic Rules": "∀x (BreedingBack(x) → ArtificiallySelected(x)) ::: Breeding back is a form of artificial selection by the deliberate selective breeding of domestic animals.\nBredBack(heck_cattle, aurochs) ∧ Resemble(heck_cattle, aurochs) ::: Heck cattle were bred-back in the 1920s to resemble the aurochs.\nAnimal(heck_cattle) ::: Heck cattle are animals.\nAnimal(aurochs) ::: Aurochs are animals.\n∃x (Animal(x) ∧ ∃y (Animal(y) ∧ Extinct(y) ∧ Resemble(x, y))) ::: Some animals to be bred-back resemble animals that are extinct.\n",
                "First-Order-Logic Question": "∃x (Animal(x) ∧ ArtificiallySelected(x) ∧ HeckCattle(x)) ::: Some Heck cattle are artificially selected."
            },
            "fixed": true
        }
    ]
}