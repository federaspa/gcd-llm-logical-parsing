{
    "outputs_1": [
        {
            "id": 32,
            "raw_prog": {
                "First-Order-Logic Rules": "Giant(juliana) ::: Juliana is giant.\n¬Technical(burgess) ::: Burgess is not technical.\n¬Gleaming(blaine) ::: Blaine is not gleaming.\n¬Gleaming(tristan) ::: Tristan is not gleaming.\n¬Alert(luther) ::: Luther is not alert.\n¬Technical(lyndon) ::: Lyndon is not technical.\n¬Attractive(lyndon) ::: Lyndon is not attractive.\nGiant(blaine) ::: Blaine is giant.\n¬Giant(tristan) ::: Tristan is not giant.\n¬Giant(luther) ::: Luther is not giant.\nTechnical(blaine) ::: Blaine is technical.\n¬Technical(tristan) ::: Tristan is not technical.\n(∀x (¬Attractive(x))) → (∀x (Technical(x) ∧ Gleaming(x))) ::: If someone is not attractive, then he is both technical and gleaming.\n(∀x (Technical(x) ∧ ¬Loving(x))) → (∀x (Giant(x))) ::: If someone is both technical and not loving, then he is giant.\n(∀x (¬Attractive(x))) ↔ (∀x (Alert(x))) ::: Someone is not attractive if and only if he is alert.\n(∀x (Alert(x) ∨ ¬Loving(x))) → (∀x (¬Giant(x))) ::: If someone is alert or he is not loving, then he is not giant.\n(∀x (Alert(x))) ↔ (∀x (¬Attractive(x))) ::: Someone being alert is equivalent to being not attractive.\n(∃x (Alert(x) ∨ ¬Loving(x))) → ((Giant(blaine))) ::: If there is someone who is either alert or not loving, then Blaine is giant.\n(∀x (¬Gleaming(x))) ↔ (∀x (Alert(x))) ::: Someone being not gleaming is equivalent to being alert.\n(∀x (Alert(x) ∧ Technical(x))) → (∀x (Giant(x))) ::: Someone who is both alert and technical is always giant.\n(∀x (¬Technical(x) ∨ ¬Attractive(x))) → (∀x (Gleaming(x))) ::: If someone is he or not technical is not attractive, then he is gleaming.\n(∀x (Attractive(x) ∧ ¬Gleaming(x))) ↔ (∀x (Alert(x))) ::: If someone is attractive and not gleaming, then he is alert, and vice versa.\n(∃x (Alert(x) ∨ ¬Loving(x))) → ((¬Technical(luther))) ::: If there is at least one people who is alert or not loving, then Luther is not technical.\n(∃x (Alert(x))) → ((Technical(lyndon) ∧ ¬Loving(juliana))) ::: If there is at least one people who is alert, then Lyndon is technical and Juliana is not loving.\n",
                "First-Order-Logic Question": "¬Loving(jack) ::: Jack is not loving."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "Giant(juliana) ::: Juliana is giant.\n¬Technical(burgess) ::: Burgess is not technical.\n¬Gleaming(blaine) ::: Blaine is not gleaming.\n¬Gleaming(tristan) ::: Tristan is not gleaming.\n¬Alert(luther) ::: Luther is not alert.\n¬Technical(lyndon) ::: Lyndon is not technical.\n¬Attractive(lyndon) ::: Lyndon is not attractive.\nGiant(blaine) ::: Blaine is giant.\n¬Giant(tristan) ::: Tristan is not giant.\n¬Giant(luther) ::: Luther is not giant.\nTechnical(blaine) ::: Blaine is technical.\n¬Technical(tristan) ::: Tristan is not technical.\n(∀x (¬Attractive(x))) → (∀x (Technical(x) ∧ Gleaming(x))) ::: If someone is not attractive, then he is both technical and gleaming.\n(∀x (Technical(x) ∧ ¬Loving(x))) → (∀x (Giant(x))) ::: If someone is both technical and not loving, then he is giant.\n(∀x (¬Attractive(x))) ↔ (∀x (Alert(x))) ::: Someone is not attractive if and only if he is alert.\n(∀x (Alert(x) ∨ ¬Loving(x))) → (∀x (¬Giant(x))) ::: If someone is alert or he is not loving, then he is not giant.\n(∀x (Alert(x))) ↔ (∀x (¬Attractive(x))) ::: Someone being alert is equivalent to being not attractive.\n(∃x (Alert(x) ∨ ¬Loving(x))) → ((Giant(blaine))) ::: If there is someone who is either alert or not loving, then Blaine is giant.\n(∀x (¬Gleaming(x))) ↔ (∀x (Alert(x))) ::: Someone being not gleaming is equivalent to being alert.\n(∀x (Alert(x) ∧ Technical(x))) → (∀x (Giant(x))) ::: Someone who is both alert and technical is always giant.\n(∀x (¬Technical(x) ∨ ¬Attractive(x))) → (∀x (Gleaming(x))) ::: If someone is he or not technical is not attractive, then he is gleaming.\n(∀x (Attractive(x) ∧ ¬Gleaming(x))) ↔ (∀x (Alert(x))) ::: If someone is attractive and not gleaming, then he is alert, and vice versa.\n(∃x (Alert(x) ∨ ¬Loving(x))) → ((¬Technical(luther))) ::: If there is at least one people who is alert or not loving, then Luther is not technical.\n(∃x (Alert(x))) → ((Technical(lyndon) ∧ ¬Loving(juliana))) ::: If there is at least one people who is alert, then Lyndon is technical and Juliana is not loving.\n",
                "First-Order-Logic Question": "¬Loving(jack) ::: Jack is not loving."
            },
            "diff": [],
            "answer": "C",
            "grammar_answer": "C",
            "backup_answer": "C"
        },
        {
            "id": 120,
            "raw_prog": {
                "First-Order-Logic Rules": "¬Hungry(gregory) ::: Gregory is not hungry.\nMushy(ronald) ::: Ronald is mushy.\nTeak(keith) ::: Keith is teak.\nPoised(crosby) ::: Crosby is poised.\nFrank(shane) ::: Shane is frank.\nPoised(gregory) ::: Gregory is poised.\n¬Poised(shane) ::: Shane is not poised.\nMushy(keith) ::: Keith is mushy.\n¬Frank(noel) ::: Noel is not frank.\nFrank(george) ::: George is frank.\nWicked(george) ::: George is wicked.\nFrank(keith) ::: Keith is frank.\n(∀x (Mushy(x) ∨ ¬Poised(x))) → (∀x (Hungry(x) ∧ ¬Wicked(x))) ::: If someone is either mushy or not poised, then he is hungry and not wicked.\n(¬Poised(gregory)) → (Mushy(shane)) ::: If Gregory is not poised, then Shane is mushy.\n(∃x (Wicked(x))) → ((¬Poised(shane) ∧ ¬Frank(george))) ::: If there is at least one people who is wicked, then Shane is not poised and George is not frank.\n((Teak(noel))) ↔ ((¬Poised(noel))) ::: If Noel is teak, then Noel is not poised, and vice versa.\n(∀x (¬x)) → ((Teak(shane) ∧ ¬Poised(shane))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised.\n(∀x (Wicked(x) ∧ Mushy(x))) ↔ (∀x (Poised(x))) ::: Someone is wicked and mushy if and only if he is poised.\n(∃x (Poised(x) ∨ ¬Hungry(x))) → ((¬Mushy(george))) ::: If there is at least one people who is poised or not hungry, then George is not mushy.\n(∃x (Wicked(x) ∧ ¬Teak(x))) → ((Poised(crosby))) ::: If there is at least one people who is both wicked and not teak, then Crosby is poised.\n((Teak(keith))) ↔ ((¬Poised(gregory) ∧ ¬Wicked(noel))) ::: Keith is teak if and only if Gregory is not poised and Noel is not wicked.\n((Teak(noel))) ↔ ((Hungry(shane))) ::: Noel is teak if and only if Shane is hungry.\n((¬Teak(gregory) ∧ Wicked(crosby))) → ((¬Mushy(keith))) ::: If Gregory is not teak and Crosby is wicked, then Keith is not mushy.\n(∃x (Hungry(x) ∧ Wicked(x))) → ((Teak(noel))) ::: If there is at least one people who is both hungry and wicked, then Noel is teak.\n",
                "First-Order-Logic Question": "¬Mushy(noel) ::: Noel is not mushy."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "¬Hungry(gregory) ::: Gregory is not hungry.\nMushy(ronald) ::: Ronald is mushy.\nTeak(keith) ::: Keith is teak.\nPoised(crosby) ::: Crosby is poised.\nFrank(shane) ::: Shane is frank.\nPoised(gregory) ::: Gregory is poised.\n¬Poised(shane) ::: Shane is not poised.\nMushy(keith) ::: Keith is mushy.\n¬Frank(noel) ::: Noel is not frank.\nFrank(george) ::: George is frank.\nWicked(george) ::: George is wicked.\nFrank(keith) ::: Keith is frank.\n(∀x (Mushy(x) ∨ ¬Poised(x))) → (∀x (Hungry(x) ∧ ¬Wicked(x))) ::: If someone is either mushy or not poised, then he is hungry and not wicked.\n(¬Poised(gregory)) → (Mushy(shane)) ::: If Gregory is not poised, then Shane is mushy.\n(∃x (Wicked(x))) → ((¬Poised(shane) ∧ ¬Frank(george))) ::: If there is at least one people who is wicked, then Shane is not poised and George is not frank.\n((Teak(noel))) ↔ ((¬Poised(noel))) ::: If Noel is teak, then Noel is not poised, and vice versa.\n¬(Hungry(x))→((Teak(x))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised.\n(∀x (Wicked(x) ∧ Mushy(x))) ↔ (∀x (Poised(x))) ::: Someone is wicked and mushy if and only if he is poised.\n(∃x (Poised(x) ∨ ¬Hungry(x))) → ((¬Mushy(george))) ::: If there is at least one people who is poised or not hungry, then George is not mushy.\n(∃x (Wicked(x) ∧ ¬Teak(x))) → ((Poised(crosby))) ::: If there is at least one people who is both wicked and not teak, then Crosby is poised.\n((Teak(keith))) ↔ ((¬Poised(gregory) ∧ ¬Wicked(noel))) ::: Keith is teak if and only if Gregory is not poised and Noel is not wicked.\n((Teak(noel))) ↔ ((Hungry(shane))) ::: Noel is teak if and only if Shane is hungry.\n((¬Teak(gregory) ∧ Wicked(crosby))) → ((¬Mushy(keith))) ::: If Gregory is not teak and Crosby is wicked, then Keith is not mushy.\n(∃x (Hungry(x) ∧ Wicked(x))) → ((Teak(noel))) ::: If there is at least one people who is both hungry and wicked, then Noel is teak.\n",
                "First-Order-Logic Question": "¬Mushy(noel) ::: Noel is not mushy."
            },
            "diff": [
                {
                    "raw": "(∀x (¬x)) → ((Teak(shane) ∧ ¬Poised(shane))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised.",
                    "gram": "¬(Hungry(x))→((Teak(x))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised."
                }
            ],
            "answer": "B",
            "grammar_answer": "A",
            "backup_answer": "C"
        },
        {
            "id": 121,
            "raw_prog": {
                "First-Order-Logic Rules": "¬Hungry(gregory) ::: Gregory is not hungry.\nMushy(ronald) ::: Ronald is mushy.\nTeak(keith) ::: Keith is teak.\nPoised(crosby) ::: Crosby is poised.\nFrank(shane) ::: Shane is frank.\nPoised(gregory) ::: Gregory is poised.\n¬Poised(shane) ::: Shane is not poised.\nMushy(keith) ::: Keith is mushy.\n¬Frank(noel) ::: Noel is not frank.\nFrank(george) ::: George is frank.\nWicked(george) ::: George is wicked.\nFrank(keith) ::: Keith is frank.\n(∀x (Mushy(x) ∨ ¬Poised(x))) → (∀x (Hungry(x) ∧ ¬Wicked(x))) ::: If someone is either mushy or not poised, then he is hungry and not wicked.\n(¬Poised(gregory)) → (Mushy(shane)) ::: If Gregory is not poised, then Shane is mushy.\n(∃x (Wicked(x))) → ((¬Poised(shane) ∧ ¬Frank(george))) ::: If there is at least one people who is wicked, then Shane is not poised and George is not frank.\n((Teak(noel))) ↔ ((¬Poised(noel))) ::: If Noel is teak, then Noel is not poised, and vice versa.\n(¬∃x (¬x)) → ((Teak(shane) ∧ ¬Poised(shane))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised.\n(∀x (Wicked(x) ∧ Mushy(x))) ↔ (∀x (Poised(x))) ::: Someone is wicked and mushy if and only if he is poised.\n(∃x (Poised(x) ∨ ¬Hungry(x))) → ((¬Mushy(george))) ::: If there is at least one people who is poised or not hungry, then George is not mushy.\n(∃x (Wicked(x) ∧ ¬Teak(x))) → ((Poised(crosby))) ::: If there is at least one people who is both wicked and not teak, then Crosby is poised.\n((Teak(keith))) ↔ ((¬Poised(gregory) ∧ ¬Wicked(noel))) ::: Keith is teak if and only if Gregory is not poised and Noel is not wicked.\n((Teak(noel))) ↔ ((Hungry(shane))) ::: Noel is teak if and only if Shane is hungry.\n((¬Teak(gregory) ∧ Wicked(crosby))) → ((¬Mushy(keith))) ::: If Gregory is not teak and Crosby is wicked, then Keith is not mushy.\n(∃x (Hungry(x) ∧ Wicked(x))) → ((Teak(noel))) ::: If there is at least one people who is both hungry and wicked, then Noel is teak.\n",
                "First-Order-Logic Question": "¬Mushy(shane) ::: Shane is not mushy."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "¬Hungry(gregory) ::: Gregory is not hungry.\nMushy(ronald) ::: Ronald is mushy.\nTeak(keith) ::: Keith is teak.\nPoised(crosby) ::: Crosby is poised.\nFrank(shane) ::: Shane is frank.\nPoised(gregory) ::: Gregory is poised.\n¬Poised(shane) ::: Shane is not poised.\nMushy(keith) ::: Keith is mushy.\n¬Frank(noel) ::: Noel is not frank.\nFrank(george) ::: George is frank.\nWicked(george) ::: George is wicked.\nFrank(keith) ::: Keith is frank.\n(∀x (Mushy(x) ∨ ¬Poised(x))) → (∀x (Hungry(x) ∧ ¬Wicked(x))) ::: If someone is either mushy or not poised, then he is hungry and not wicked.\n(¬Poised(gregory)) → (Mushy(shane)) ::: If Gregory is not poised, then Shane is mushy.\n(∃x (Wicked(x))) → ((¬Poised(shane) ∧ ¬Frank(george))) ::: If there is at least one people who is wicked, then Shane is not poised and George is not frank.\n((Teak(noel))) ↔ ((¬Poised(noel))) ::: If Noel is teak, then Noel is not poised, and vice versa.\n¬∃x((¬(¬Frank(x)))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised.\n(∀x (Wicked(x) ∧ Mushy(x))) ↔ (∀x (Poised(x))) ::: Someone is wicked and mushy if and only if he is poised.\n(∃x (Poised(x) ∨ ¬Hungry(x))) → ((¬Mushy(george))) ::: If there is at least one people who is poised or not hungry, then George is not mushy.\n(∃x (Wicked(x) ∧ ¬Teak(x))) → ((Poised(crosby))) ::: If there is at least one people who is both wicked and not teak, then Crosby is poised.\n((Teak(keith))) ↔ ((¬Poised(gregory) ∧ ¬Wicked(noel))) ::: Keith is teak if and only if Gregory is not poised and Noel is not wicked.\n((Teak(noel))) ↔ ((Hungry(shane))) ::: Noel is teak if and only if Shane is hungry.\n((¬Teak(gregory) ∧ Wicked(crosby))) → ((¬Mushy(keith))) ::: If Gregory is not teak and Crosby is wicked, then Keith is not mushy.\n(∃x (Hungry(x) ∧ Wicked(x))) → ((Teak(noel))) ::: If there is at least one people who is both hungry and wicked, then Noel is teak.\n",
                "First-Order-Logic Question": "¬Mushy(shane) ::: Shane is not mushy."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬x)) → ((Teak(shane) ∧ ¬Poised(shane))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised.",
                    "gram": "¬∃x((¬(¬Frank(x)))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised."
                }
            ],
            "answer": "A",
            "grammar_answer": "A",
            "backup_answer": "A"
        },
        {
            "id": 122,
            "raw_prog": {
                "First-Order-Logic Rules": "¬Hungry(gregory) ::: Gregory is not hungry.\nMushy(ronald) ::: Ronald is mushy.\nTeak(keith) ::: Keith is teak.\nPoised(crosby) ::: Crosby is poised.\nFrank(shane) ::: Shane is frank.\nPoised(gregory) ::: Gregory is poised.\n¬Poised(shane) ::: Shane is not poised.\nMushy(keith) ::: Keith is mushy.\n¬Frank(noel) ::: Noel is not frank.\nFrank(george) ::: George is frank.\nWicked(george) ::: George is wicked.\nFrank(keith) ::: Keith is frank.\n(∀x (Mushy(x) ∨ ¬Poised(x))) → (∀x (Hungry(x) ∧ ¬Wicked(x))) ::: If someone is either mushy or not poised, then he is hungry and not wicked.\n(¬Poised(gregory)) → (Mushy(shane)) ::: If Gregory is not poised, then Shane is mushy.\n(∃x (Wicked(x))) → ((¬Poised(shane) ∧ ¬Frank(george))) ::: If there is at least one people who is wicked, then Shane is not poised and George is not frank.\n((Teak(noel))) ↔ ((¬Poised(noel))) ::: If Noel is teak, then Noel is not poised, and vice versa.\n(¬∃x (¬x)) → ((Teak(shane) ∧ ¬Poised(shane))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised.\n(∀x (Wicked(x) ∧ Mushy(x))) ↔ (∀x (Poised(x))) ::: Someone is wicked and mushy if and only if he is poised.\n(∃x (Poised(x) ∨ ¬Hungry(x))) → ((¬Mushy(george))) ::: If there is at least one people who is poised or not hungry, then George is not mushy.\n(∃x (Wicked(x) ∧ ¬Teak(x))) → ((Poised(crosby))) ::: If there is at least one people who is both wicked and not teak, then Crosby is poised.\n((Teak(keith))) ↔ ((¬Poised(gregory) ∧ ¬Wicked(noel))) ::: Keith is teak if and only if Gregory is not poised and Noel is not wicked.\n((Teak(noel))) ↔ ((Hungry(shane))) ::: Noel is teak if and only if Shane is hungry.\n((¬Teak(gregory) ∧ Wicked(crosby))) → ((¬Mushy(keith))) ::: If Gregory is not teak and Crosby is wicked, then Keith is not mushy.\n(∃x (Hungry(x) ∧ Wicked(x))) → ((Teak(noel))) ::: If there is at least one people who is both hungry and wicked, then Noel is teak.\n",
                "First-Order-Logic Question": "Hungry(crosby) ::: Crosby is hungry."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "¬Hungry(gregory) ::: Gregory is not hungry.\nMushy(ronald) ::: Ronald is mushy.\nTeak(keith) ::: Keith is teak.\nPoised(crosby) ::: Crosby is poised.\nFrank(shane) ::: Shane is frank.\nPoised(gregory) ::: Gregory is poised.\n¬Poised(shane) ::: Shane is not poised.\nMushy(keith) ::: Keith is mushy.\n¬Frank(noel) ::: Noel is not frank.\nFrank(george) ::: George is frank.\nWicked(george) ::: George is wicked.\nFrank(keith) ::: Keith is frank.\n(∀x (Mushy(x) ∨ ¬Poised(x))) → (∀x (Hungry(x) ∧ ¬Wicked(x))) ::: If someone is either mushy or not poised, then he is hungry and not wicked.\n(¬Poised(gregory)) → (Mushy(shane)) ::: If Gregory is not poised, then Shane is mushy.\n(∃x (Wicked(x))) → ((¬Poised(shane) ∧ ¬Frank(george))) ::: If there is at least one people who is wicked, then Shane is not poised and George is not frank.\n((Teak(noel))) ↔ ((¬Poised(noel))) ::: If Noel is teak, then Noel is not poised, and vice versa.\n¬∃x((¬(¬Frank(x)))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised.\n(∀x (Wicked(x) ∧ Mushy(x))) ↔ (∀x (Poised(x))) ::: Someone is wicked and mushy if and only if he is poised.\n(∃x (Poised(x) ∨ ¬Hungry(x))) → ((¬Mushy(george))) ::: If there is at least one people who is poised or not hungry, then George is not mushy.\n(∃x (Wicked(x) ∧ ¬Teak(x))) → ((Poised(crosby))) ::: If there is at least one people who is both wicked and not teak, then Crosby is poised.\n((Teak(keith))) ↔ ((¬Poised(gregory) ∧ ¬Wicked(noel))) ::: Keith is teak if and only if Gregory is not poised and Noel is not wicked.\n((Teak(noel))) ↔ ((Hungry(shane))) ::: Noel is teak if and only if Shane is hungry.\n((¬Teak(gregory) ∧ Wicked(crosby))) → ((¬Mushy(keith))) ::: If Gregory is not teak and Crosby is wicked, then Keith is not mushy.\n(∃x (Hungry(x) ∧ Wicked(x))) → ((Teak(noel))) ::: If there is at least one people who is both hungry and wicked, then Noel is teak.\n",
                "First-Order-Logic Question": "Hungry(crosby) ::: Crosby is hungry."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬x)) → ((Teak(shane) ∧ ¬Poised(shane))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised.",
                    "gram": "¬∃x((¬(¬Frank(x)))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised."
                }
            ],
            "answer": "A",
            "grammar_answer": "A",
            "backup_answer": "B"
        },
        {
            "id": 123,
            "raw_prog": {
                "First-Order-Logic Rules": "¬Hungry(gregory) ::: Gregory is not hungry.\nMushy(ronald) ::: Ronald is mushy.\nTeak(keith) ::: Keith is teak.\nPoised(crosby) ::: Crosby is poised.\nFrank(shane) ::: Shane is frank.\nPoised(gregory) ::: Gregory is poised.\n¬Poised(shane) ::: Shane is not poised.\nMushy(keith) ::: Keith is mushy.\n¬Frank(noel) ::: Noel is not frank.\nFrank(george) ::: George is frank.\nWicked(george) ::: George is wicked.\nFrank(keith) ::: Keith is frank.\n(∀x (Mushy(x) ∨ ¬Poised(x))) → (∀x (Hungry(x) ∧ ¬Wicked(x))) ::: If someone is either mushy or not poised, then he is hungry and not wicked.\n(¬Poised(gregory)) → (Mushy(shane)) ::: If Gregory is not poised, then Shane is mushy.\n(∃x (Wicked(x))) → ((¬Poised(shane) ∧ ¬Frank(george))) ::: If there is at least one people who is wicked, then Shane is not poised and George is not frank.\n((Teak(noel))) ↔ ((¬Poised(noel))) ::: If Noel is teak, then Noel is not poised, and vice versa.\n(¬∃x (¬x)) → ((Teak(shane) ∧ ¬Poised(shane))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised.\n(∀x (Wicked(x) ∧ Mushy(x))) ↔ (∀x (Poised(x))) ::: Someone is wicked and mushy if and only if he is poised.\n(∃x (Poised(x) ∨ ¬Hungry(x))) → ((¬Mushy(george))) ::: If there is at least one people who is poised or not hungry, then George is not mushy.\n(∃x (Wicked(x) ∧ ¬Teak(x))) → ((Poised(crosby))) ::: If there is at least one people who is both wicked and not teak, then Crosby is poised.\n((Teak(keith))) ↔ ((¬Poised(gregory) ∧ ¬Wicked(noel))) ::: Keith is teak if and only if Gregory is not poised and Noel is not wicked.\n((Teak(noel))) ↔ ((Hungry(shane))) ::: Noel is teak if and only if Shane is hungry.\n((¬Teak(gregory) ∧ Wicked(crosby))) → ((¬Mushy(keith))) ::: If Gregory is not teak and Crosby is wicked, then Keith is not mushy.\n(∃x (Hungry(x) ∧ Wicked(x))) → ((Teak(noel))) ::: If there is at least one people who is both hungry and wicked, then Noel is teak.\n",
                "First-Order-Logic Question": "¬Wicked(shane) ::: Shane is not wicked."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "¬Hungry(gregory) ::: Gregory is not hungry.\nMushy(ronald) ::: Ronald is mushy.\nTeak(keith) ::: Keith is teak.\nPoised(crosby) ::: Crosby is poised.\nFrank(shane) ::: Shane is frank.\nPoised(gregory) ::: Gregory is poised.\n¬Poised(shane) ::: Shane is not poised.\nMushy(keith) ::: Keith is mushy.\n¬Frank(noel) ::: Noel is not frank.\nFrank(george) ::: George is frank.\nWicked(george) ::: George is wicked.\nFrank(keith) ::: Keith is frank.\n(∀x (Mushy(x) ∨ ¬Poised(x))) → (∀x (Hungry(x) ∧ ¬Wicked(x))) ::: If someone is either mushy or not poised, then he is hungry and not wicked.\n(¬Poised(gregory)) → (Mushy(shane)) ::: If Gregory is not poised, then Shane is mushy.\n(∃x (Wicked(x))) → ((¬Poised(shane) ∧ ¬Frank(george))) ::: If there is at least one people who is wicked, then Shane is not poised and George is not frank.\n((Teak(noel))) ↔ ((¬Poised(noel))) ::: If Noel is teak, then Noel is not poised, and vice versa.\n¬∃x((¬(¬Frank(x)))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised.\n(∀x (Wicked(x) ∧ Mushy(x))) ↔ (∀x (Poised(x))) ::: Someone is wicked and mushy if and only if he is poised.\n(∃x (Poised(x) ∨ ¬Hungry(x))) → ((¬Mushy(george))) ::: If there is at least one people who is poised or not hungry, then George is not mushy.\n(∃x (Wicked(x) ∧ ¬Teak(x))) → ((Poised(crosby))) ::: If there is at least one people who is both wicked and not teak, then Crosby is poised.\n((Teak(keith))) ↔ ((¬Poised(gregory) ∧ ¬Wicked(noel))) ::: Keith is teak if and only if Gregory is not poised and Noel is not wicked.\n((Teak(noel))) ↔ ((Hungry(shane))) ::: Noel is teak if and only if Shane is hungry.\n((¬Teak(gregory) ∧ Wicked(crosby))) → ((¬Mushy(keith))) ::: If Gregory is not teak and Crosby is wicked, then Keith is not mushy.\n(∃x (Hungry(x) ∧ Wicked(x))) → ((Teak(noel))) ::: If there is at least one people who is both hungry and wicked, then Noel is teak.\n",
                "First-Order-Logic Question": "¬Wicked(shane) ::: Shane is not wicked."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬x)) → ((Teak(shane) ∧ ¬Poised(shane))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised.",
                    "gram": "¬∃x((¬(¬Frank(x)))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised."
                }
            ],
            "answer": "B",
            "grammar_answer": "A",
            "backup_answer": "A"
        },
        {
            "id": 124,
            "raw_prog": {
                "First-Order-Logic Rules": "¬Hungry(gregory) ::: Gregory is not hungry.\nMushy(ronald) ::: Ronald is mushy.\nTeak(keith) ::: Keith is teak.\nPoised(crosby) ::: Crosby is poised.\nFrank(shane) ::: Shane is frank.\nPoised(gregory) ::: Gregory is poised.\n¬Poised(shane) ::: Shane is not poised.\nMushy(keith) ::: Keith is mushy.\n¬Frank(noel) ::: Noel is not frank.\nFrank(george) ::: George is frank.\nWicked(george) ::: George is wicked.\nFrank(keith) ::: Keith is frank.\n(∀x (Mushy(x) ∨ ¬Poised(x))) → (∀x (Hungry(x) ∧ ¬Wicked(x))) ::: If someone is either mushy or not poised, then he is hungry and not wicked.\n(¬Poised(gregory)) → (Mushy(shane)) ::: If Gregory is not poised, then Shane is mushy.\n(∃x (Wicked(x))) → ((¬Poised(shane) ∧ ¬Frank(george))) ::: If there is at least one people who is wicked, then Shane is not poised and George is not frank.\n((Teak(noel))) ↔ ((¬Poised(noel))) ::: If Noel is teak, then Noel is not poised, and vice versa.\n(¬∃x (¬x)) → ((Teak(shane) ∧ ¬Poised(shane))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised.\n(∀x (Wicked(x) ∧ Mushy(x))) ↔ (∀x (Poised(x))) ::: Someone is wicked and mushy if and only if he is poised.\n(∃x (Poised(x) ∨ ¬Hungry(x))) → ((¬Mushy(george))) ::: If there is at least one people who is poised or not hungry, then George is not mushy.\n(∃x (Wicked(x) ∧ ¬Teak(x))) → ((Poised(crosby))) ::: If there is at least one people who is both wicked and not teak, then Crosby is poised.\n((Teak(keith))) ↔ ((¬Poised(gregory) ∧ ¬Wicked(noel))) ::: Keith is teak if and only if Gregory is not poised and Noel is not wicked.\n((Teak(noel))) ↔ ((Hungry(shane))) ::: Noel is teak if and only if Shane is hungry.\n((¬Teak(gregory) ∧ Wicked(crosby))) → ((¬Mushy(keith))) ::: If Gregory is not teak and Crosby is wicked, then Keith is not mushy.\n(∃x (Hungry(x) ∧ Wicked(x))) → ((Teak(noel))) ::: If there is at least one people who is both hungry and wicked, then Noel is teak.\n",
                "First-Order-Logic Question": "¬Hungry(shane) ::: Shane is not hungry."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "¬Hungry(gregory) ::: Gregory is not hungry.\nMushy(ronald) ::: Ronald is mushy.\nTeak(keith) ::: Keith is teak.\nPoised(crosby) ::: Crosby is poised.\nFrank(shane) ::: Shane is frank.\nPoised(gregory) ::: Gregory is poised.\n¬Poised(shane) ::: Shane is not poised.\nMushy(keith) ::: Keith is mushy.\n¬Frank(noel) ::: Noel is not frank.\nFrank(george) ::: George is frank.\nWicked(george) ::: George is wicked.\nFrank(keith) ::: Keith is frank.\n(∀x (Mushy(x) ∨ ¬Poised(x))) → (∀x (Hungry(x) ∧ ¬Wicked(x))) ::: If someone is either mushy or not poised, then he is hungry and not wicked.\n(¬Poised(gregory)) → (Mushy(shane)) ::: If Gregory is not poised, then Shane is mushy.\n(∃x (Wicked(x))) → ((¬Poised(shane) ∧ ¬Frank(george))) ::: If there is at least one people who is wicked, then Shane is not poised and George is not frank.\n((Teak(noel))) ↔ ((¬Poised(noel))) ::: If Noel is teak, then Noel is not poised, and vice versa.\n¬∃x((¬(¬Frank(x)))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised.\n(∀x (Wicked(x) ∧ Mushy(x))) ↔ (∀x (Poised(x))) ::: Someone is wicked and mushy if and only if he is poised.\n(∃x (Poised(x) ∨ ¬Hungry(x))) → ((¬Mushy(george))) ::: If there is at least one people who is poised or not hungry, then George is not mushy.\n(∃x (Wicked(x) ∧ ¬Teak(x))) → ((Poised(crosby))) ::: If there is at least one people who is both wicked and not teak, then Crosby is poised.\n((Teak(keith))) ↔ ((¬Poised(gregory) ∧ ¬Wicked(noel))) ::: Keith is teak if and only if Gregory is not poised and Noel is not wicked.\n((Teak(noel))) ↔ ((Hungry(shane))) ::: Noel is teak if and only if Shane is hungry.\n((¬Teak(gregory) ∧ Wicked(crosby))) → ((¬Mushy(keith))) ::: If Gregory is not teak and Crosby is wicked, then Keith is not mushy.\n(∃x (Hungry(x) ∧ Wicked(x))) → ((Teak(noel))) ::: If there is at least one people who is both hungry and wicked, then Noel is teak.\n",
                "First-Order-Logic Question": "¬Hungry(shane) ::: Shane is not hungry."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬x)) → ((Teak(shane) ∧ ¬Poised(shane))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised.",
                    "gram": "¬∃x((¬(¬Frank(x)))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised."
                }
            ],
            "answer": "C",
            "grammar_answer": "A",
            "backup_answer": "B"
        },
        {
            "id": 125,
            "raw_prog": {
                "First-Order-Logic Rules": "¬Hungry(gregory) ::: Gregory is not hungry.\nMushy(ronald) ::: Ronald is mushy.\nTeak(keith) ::: Keith is teak.\nPoised(crosby) ::: Crosby is poised.\nFrank(shane) ::: Shane is frank.\nPoised(gregory) ::: Gregory is poised.\n¬Poised(shane) ::: Shane is not poised.\nMushy(keith) ::: Keith is mushy.\n¬Frank(noel) ::: Noel is not frank.\nFrank(george) ::: George is frank.\nWicked(george) ::: George is wicked.\nFrank(keith) ::: Keith is frank.\n(∀x (Mushy(x) ∨ ¬Poised(x))) → (∀x (Hungry(x) ∧ ¬Wicked(x))) ::: If someone is either mushy or not poised, then he is hungry and not wicked.\n(¬Poised(gregory)) → (Mushy(shane)) ::: If Gregory is not poised, then Shane is mushy.\n(∃x (Wicked(x))) → ((¬Poised(shane) ∧ ¬Frank(george))) ::: If there is at least one people who is wicked, then Shane is not poised and George is not frank.\n((Teak(noel))) ↔ ((¬Poised(noel))) ::: If Noel is teak, then Noel is not poised, and vice versa.\n(¬∃x (¬x)) → ((Teak(shane) ∧ ¬Poised(shane))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised.\n(∀x (Wicked(x) ∧ Mushy(x))) ↔ (∀x (Poised(x))) ::: Someone is wicked and mushy if and only if he is poised.\n(∃x (Poised(x) ∨ ¬Hungry(x))) → ((¬Mushy(george))) ::: If there is at least one people who is poised or not hungry, then George is not mushy.\n(∃x (Wicked(x) ∧ ¬Teak(x))) → ((Poised(crosby))) ::: If there is at least one people who is both wicked and not teak, then Crosby is poised.\n((Teak(keith))) ↔ ((¬Poised(gregory) ∧ ¬Wicked(noel))) ::: Keith is teak if and only if Gregory is not poised and Noel is not wicked.\n((Teak(noel))) ↔ ((Hungry(shane))) ::: Noel is teak if and only if Shane is hungry.\n((¬Teak(gregory) ∧ Wicked(crosby))) → ((¬Mushy(keith))) ::: If Gregory is not teak and Crosby is wicked, then Keith is not mushy.\n(∃x (Hungry(x) ∧ Wicked(x))) → ((Teak(noel))) ::: If there is at least one people who is both hungry and wicked, then Noel is teak.\n",
                "First-Order-Logic Question": "Mushy(noel) ::: Noel is mushy."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "¬Hungry(gregory) ::: Gregory is not hungry.\nMushy(ronald) ::: Ronald is mushy.\nTeak(keith) ::: Keith is teak.\nPoised(crosby) ::: Crosby is poised.\nFrank(shane) ::: Shane is frank.\nPoised(gregory) ::: Gregory is poised.\n¬Poised(shane) ::: Shane is not poised.\nMushy(keith) ::: Keith is mushy.\n¬Frank(noel) ::: Noel is not frank.\nFrank(george) ::: George is frank.\nWicked(george) ::: George is wicked.\nFrank(keith) ::: Keith is frank.\n(∀x (Mushy(x) ∨ ¬Poised(x))) → (∀x (Hungry(x) ∧ ¬Wicked(x))) ::: If someone is either mushy or not poised, then he is hungry and not wicked.\n(¬Poised(gregory)) → (Mushy(shane)) ::: If Gregory is not poised, then Shane is mushy.\n(∃x (Wicked(x))) → ((¬Poised(shane) ∧ ¬Frank(george))) ::: If there is at least one people who is wicked, then Shane is not poised and George is not frank.\n((Teak(noel))) ↔ ((¬Poised(noel))) ::: If Noel is teak, then Noel is not poised, and vice versa.\n¬∃x((¬(¬Frank(x)))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised.\n(∀x (Wicked(x) ∧ Mushy(x))) ↔ (∀x (Poised(x))) ::: Someone is wicked and mushy if and only if he is poised.\n(∃x (Poised(x) ∨ ¬Hungry(x))) → ((¬Mushy(george))) ::: If there is at least one people who is poised or not hungry, then George is not mushy.\n(∃x (Wicked(x) ∧ ¬Teak(x))) → ((Poised(crosby))) ::: If there is at least one people who is both wicked and not teak, then Crosby is poised.\n((Teak(keith))) ↔ ((¬Poised(gregory) ∧ ¬Wicked(noel))) ::: Keith is teak if and only if Gregory is not poised and Noel is not wicked.\n((Teak(noel))) ↔ ((Hungry(shane))) ::: Noel is teak if and only if Shane is hungry.\n((¬Teak(gregory) ∧ Wicked(crosby))) → ((¬Mushy(keith))) ::: If Gregory is not teak and Crosby is wicked, then Keith is not mushy.\n(∃x (Hungry(x) ∧ Wicked(x))) → ((Teak(noel))) ::: If there is at least one people who is both hungry and wicked, then Noel is teak.\n",
                "First-Order-Logic Question": "Mushy(noel) ::: Noel is mushy."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬x)) → ((Teak(shane) ∧ ¬Poised(shane))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised.",
                    "gram": "¬∃x((¬(¬Frank(x)))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised."
                }
            ],
            "answer": "A",
            "grammar_answer": "A",
            "backup_answer": "B"
        },
        {
            "id": 126,
            "raw_prog": {
                "First-Order-Logic Rules": "¬Hungry(gregory) ::: Gregory is not hungry.\nMushy(ronald) ::: Ronald is mushy.\nTeak(keith) ::: Keith is teak.\nPoised(crosby) ::: Crosby is poised.\nFrank(shane) ::: Shane is frank.\nPoised(gregory) ::: Gregory is poised.\n¬Poised(shane) ::: Shane is not poised.\nMushy(keith) ::: Keith is mushy.\n¬Frank(noel) ::: Noel is not frank.\nFrank(george) ::: George is frank.\nWicked(george) ::: George is wicked.\nFrank(keith) ::: Keith is frank.\n(∀x (Mushy(x) ∨ ¬Poised(x))) → (∀x (Hungry(x) ∧ ¬Wicked(x))) ::: If someone is either mushy or not poised, then he is hungry and not wicked.\n(¬Poised(gregory)) → ((Mushy(shane))) ::: If Gregory is not poised, then Shane is mushy.\n(∃x (Wicked(x))) → ((¬Poised(shane) ∧ ¬Frank(george))) ::: If there is at least one people who is wicked, then Shane is not poised and George is not frank.\n((Teak(noel))) ↔ ((¬Poised(noel))) ::: If Noel is teak, then Noel is not poised, and vice versa.\n(∀x (¬x)) → ((Teak(shane) ∧ ¬Poised(shane))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised.\n(∀x (Wicked(x) ∧ Mushy(x))) ↔ (∀x (Poised(x))) ::: Someone is wicked and mushy if and only if he is poised.\n(∃x (Poised(x) ∨ ¬Hungry(x))) → ((¬Mushy(george))) ::: If there is at least one people who is poised or not hungry, then George is not mushy.\n(∃x (Wicked(x) ∧ ¬Teak(x))) → ((Poised(crosby))) ::: If there is at least one people who is both wicked and not teak, then Crosby is poised.\n((Teak(keith))) ↔ ((¬Poised(gregory) ∧ ¬Wicked(noel))) ::: Keith is teak if and only if Gregory is not poised and Noel is not wicked.\n((Teak(noel))) ↔ ((Hungry(shane))) ::: Noel is teak if and only if Shane is hungry.\n((¬Teak(gregory) ∧ Wicked(crosby))) → ((¬Mushy(keith))) ::: If Gregory is not teak and Crosby is wicked, then Keith is not mushy.\n(∃x (Hungry(x) ∧ Wicked(x))) → ((Teak(noel))) ::: If there is at least one people who is both hungry and wicked, then Noel is teak.\n",
                "First-Order-Logic Question": "¬Mushy(george) ::: George is not mushy."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "¬Hungry(gregory) ::: Gregory is not hungry.\nMushy(ronald) ::: Ronald is mushy.\nTeak(keith) ::: Keith is teak.\nPoised(crosby) ::: Crosby is poised.\nFrank(shane) ::: Shane is frank.\nPoised(gregory) ::: Gregory is poised.\n¬Poised(shane) ::: Shane is not poised.\nMushy(keith) ::: Keith is mushy.\n¬Frank(noel) ::: Noel is not frank.\nFrank(george) ::: George is frank.\nWicked(george) ::: George is wicked.\nFrank(keith) ::: Keith is frank.\n(∀x (Mushy(x) ∨ ¬Poised(x))) → (∀x (Hungry(x) ∧ ¬Wicked(x))) ::: If someone is either mushy or not poised, then he is hungry and not wicked.\n(¬Poised(gregory)) → ((Mushy(shane))) ::: If Gregory is not poised, then Shane is mushy.\n(∃x (Wicked(x))) → ((¬Poised(shane) ∧ ¬Frank(george))) ::: If there is at least one people who is wicked, then Shane is not poised and George is not frank.\n((Teak(noel))) ↔ ((¬Poised(noel))) ::: If Noel is teak, then Noel is not poised, and vice versa.\n¬(Hungry(x))→((Teak(x))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised.\n(∀x (Wicked(x) ∧ Mushy(x))) ↔ (∀x (Poised(x))) ::: Someone is wicked and mushy if and only if he is poised.\n(∃x (Poised(x) ∨ ¬Hungry(x))) → ((¬Mushy(george))) ::: If there is at least one people who is poised or not hungry, then George is not mushy.\n(∃x (Wicked(x) ∧ ¬Teak(x))) → ((Poised(crosby))) ::: If there is at least one people who is both wicked and not teak, then Crosby is poised.\n((Teak(keith))) ↔ ((¬Poised(gregory) ∧ ¬Wicked(noel))) ::: Keith is teak if and only if Gregory is not poised and Noel is not wicked.\n((Teak(noel))) ↔ ((Hungry(shane))) ::: Noel is teak if and only if Shane is hungry.\n((¬Teak(gregory) ∧ Wicked(crosby))) → ((¬Mushy(keith))) ::: If Gregory is not teak and Crosby is wicked, then Keith is not mushy.\n(∃x (Hungry(x) ∧ Wicked(x))) → ((Teak(noel))) ::: If there is at least one people who is both hungry and wicked, then Noel is teak.\n",
                "First-Order-Logic Question": "¬Mushy(george) ::: George is not mushy."
            },
            "diff": [
                {
                    "raw": "(∀x (¬x)) → ((Teak(shane) ∧ ¬Poised(shane))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised.",
                    "gram": "¬(Hungry(x))→((Teak(x))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised."
                }
            ],
            "answer": "C",
            "grammar_answer": "A",
            "backup_answer": "A"
        },
        {
            "id": 127,
            "raw_prog": {
                "First-Order-Logic Rules": "¬Hungry(gregory) ::: Gregory is not hungry.\nMushy(ronald) ::: Ronald is mushy.\nTeak(keith) ::: Keith is teak.\nPoised(crosby) ::: Crosby is poised.\nFrank(shane) ::: Shane is frank.\nPoised(gregory) ::: Gregory is poised.\n¬Poised(shane) ::: Shane is not poised.\nMushy(keith) ::: Keith is mushy.\n¬Frank(noel) ::: Noel is not frank.\nFrank(george) ::: George is frank.\nWicked(george) ::: George is wicked.\nFrank(keith) ::: Keith is frank.\n(∀x (Mushy(x) ∨ ¬Poised(x))) → (∀x (Hungry(x) ∧ ¬Wicked(x))) ::: If someone is either mushy or not poised, then he is hungry and not wicked.\n(¬Poised(gregory)) → (Mushy(shane)) ::: If Gregory is not poised, then Shane is mushy.\n(∃x (Wicked(x))) → ((¬Poised(shane) ∧ ¬Frank(george))) ::: If there is at least one people who is wicked, then Shane is not poised and George is not frank.\n((Teak(noel))) ↔ ((¬Poised(noel))) ::: If Noel is teak, then Noel is not poised, and vice versa.\n(¬∃x (¬x)) → ((Teak(shane) ∧ ¬Poised(shane))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised.\n(∀x (Wicked(x) ∧ Mushy(x))) ↔ (∀x (Poised(x))) ::: Someone is wicked and mushy if and only if he is poised.\n(∃x (Poised(x) ∨ ¬Hungry(x))) → ((¬Mushy(george))) ::: If there is at least one people who is poised or not hungry, then George is not mushy.\n(∃x (Wicked(x) ∧ ¬Teak(x))) → ((Poised(crosby))) ::: If there is at least one people who is both wicked and not teak, then Crosby is poised.\n((Teak(keith))) ↔ ((¬Poised(gregory) ∧ ¬Wicked(noel))) ::: Keith is teak if and only if Gregory is not poised and Noel is not wicked.\n((Teak(noel))) ↔ ((Hungry(shane))) ::: Noel is teak if and only if Shane is hungry.\n((¬Teak(gregory) ∧ Wicked(crosby))) → ((¬Mushy(keith))) ::: If Gregory is not teak and Crosby is wicked, then Keith is not mushy.\n(∃x (Hungry(x) ∧ Wicked(x))) → ((Teak(noel))) ::: If there is at least one people who is both hungry and wicked, then Noel is teak.\n",
                "First-Order-Logic Question": "¬Teak(ronald) ::: Ronald is not teak."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "¬Hungry(gregory) ::: Gregory is not hungry.\nMushy(ronald) ::: Ronald is mushy.\nTeak(keith) ::: Keith is teak.\nPoised(crosby) ::: Crosby is poised.\nFrank(shane) ::: Shane is frank.\nPoised(gregory) ::: Gregory is poised.\n¬Poised(shane) ::: Shane is not poised.\nMushy(keith) ::: Keith is mushy.\n¬Frank(noel) ::: Noel is not frank.\nFrank(george) ::: George is frank.\nWicked(george) ::: George is wicked.\nFrank(keith) ::: Keith is frank.\n(∀x (Mushy(x) ∨ ¬Poised(x))) → (∀x (Hungry(x) ∧ ¬Wicked(x))) ::: If someone is either mushy or not poised, then he is hungry and not wicked.\n(¬Poised(gregory)) → (Mushy(shane)) ::: If Gregory is not poised, then Shane is mushy.\n(∃x (Wicked(x))) → ((¬Poised(shane) ∧ ¬Frank(george))) ::: If there is at least one people who is wicked, then Shane is not poised and George is not frank.\n((Teak(noel))) ↔ ((¬Poised(noel))) ::: If Noel is teak, then Noel is not poised, and vice versa.\n¬∃x((¬(¬Frank(x)))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised.\n(∀x (Wicked(x) ∧ Mushy(x))) ↔ (∀x (Poised(x))) ::: Someone is wicked and mushy if and only if he is poised.\n(∃x (Poised(x) ∨ ¬Hungry(x))) → ((¬Mushy(george))) ::: If there is at least one people who is poised or not hungry, then George is not mushy.\n(∃x (Wicked(x) ∧ ¬Teak(x))) → ((Poised(crosby))) ::: If there is at least one people who is both wicked and not teak, then Crosby is poised.\n((Teak(keith))) ↔ ((¬Poised(gregory) ∧ ¬Wicked(noel))) ::: Keith is teak if and only if Gregory is not poised and Noel is not wicked.\n((Teak(noel))) ↔ ((Hungry(shane))) ::: Noel is teak if and only if Shane is hungry.\n((¬Teak(gregory) ∧ Wicked(crosby))) → ((¬Mushy(keith))) ::: If Gregory is not teak and Crosby is wicked, then Keith is not mushy.\n(∃x (Hungry(x) ∧ Wicked(x))) → ((Teak(noel))) ::: If there is at least one people who is both hungry and wicked, then Noel is teak.\n",
                "First-Order-Logic Question": "¬Teak(ronald) ::: Ronald is not teak."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬x)) → ((Teak(shane) ∧ ¬Poised(shane))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised.",
                    "gram": "¬∃x((¬(¬Frank(x)))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised."
                }
            ],
            "answer": "B",
            "grammar_answer": "A",
            "backup_answer": "C"
        },
        {
            "id": 128,
            "raw_prog": {
                "First-Order-Logic Rules": "¬Hungry(gregory) ::: Gregory is not hungry.\nMushy(ronald) ::: Ronald is mushy.\nTeak(keith) ::: Keith is teak.\nPoised(crosby) ::: Crosby is poised.\nFrank(shane) ::: Shane is frank.\nPoised(gregory) ::: Gregory is poised.\n¬Poised(shane) ::: Shane is not poised.\nMushy(keith) ::: Keith is mushy.\n¬Frank(noel) ::: Noel is not frank.\nFrank(george) ::: George is frank.\nWicked(george) ::: George is wicked.\nFrank(keith) ::: Keith is frank.\n(∀x (Mushy(x) ∨ ¬Poised(x))) → (∀x (Hungry(x) ∧ ¬Wicked(x))) ::: If someone is either mushy or not poised, then he is hungry and not wicked.\n(¬Poised(gregory)) → (Mushy(shane)) ::: If Gregory is not poised, then Shane is mushy.\n(∃x (Wicked(x))) → ((¬Poised(shane) ∧ ¬Frank(george))) ::: If there is at least one people who is wicked, then Shane is not poised and George is not frank.\n((Teak(noel))) ↔ ((¬Poised(noel))) ::: If Noel is teak, then Noel is not poised, and vice versa.\n(¬∃x (¬x)) → ((Teak(shane) ∧ ¬Poised(shane))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised.\n(∀x (Wicked(x) ∧ Mushy(x))) ↔ (∀x (Poised(x))) ::: Someone is wicked and mushy if and only if he is poised.\n(∃x (Poised(x) ∨ ¬Hungry(x))) → ((¬Mushy(george))) ::: If there is at least one people who is poised or not hungry, then George is not mushy.\n(∃x (Wicked(x) ∧ ¬Teak(x))) → ((Poised(crosby))) ::: If there is at least one people who is both wicked and not teak, then Crosby is poised.\n((Teak(keith))) ↔ ((¬Poised(gregory) ∧ ¬Wicked(noel))) ::: Keith is teak if and only if Gregory is not poised and Noel is not wicked.\n((Teak(noel))) ↔ ((Hungry(shane))) ::: Noel is teak if and only if Shane is hungry.\n((¬Teak(gregory) ∧ Wicked(crosby))) → ((¬Mushy(keith))) ::: If Gregory is not teak and Crosby is wicked, then Keith is not mushy.\n(∃x (Hungry(x) ∧ Wicked(x))) → ((Teak(noel))) ::: If there is at least one people who is both hungry and wicked, then Noel is teak.\n",
                "First-Order-Logic Question": "¬Hungry(crosby) ::: Crosby is not hungry."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "¬Hungry(gregory) ::: Gregory is not hungry.\nMushy(ronald) ::: Ronald is mushy.\nTeak(keith) ::: Keith is teak.\nPoised(crosby) ::: Crosby is poised.\nFrank(shane) ::: Shane is frank.\nPoised(gregory) ::: Gregory is poised.\n¬Poised(shane) ::: Shane is not poised.\nMushy(keith) ::: Keith is mushy.\n¬Frank(noel) ::: Noel is not frank.\nFrank(george) ::: George is frank.\nWicked(george) ::: George is wicked.\nFrank(keith) ::: Keith is frank.\n(∀x (Mushy(x) ∨ ¬Poised(x))) → (∀x (Hungry(x) ∧ ¬Wicked(x))) ::: If someone is either mushy or not poised, then he is hungry and not wicked.\n(¬Poised(gregory)) → (Mushy(shane)) ::: If Gregory is not poised, then Shane is mushy.\n(∃x (Wicked(x))) → ((¬Poised(shane) ∧ ¬Frank(george))) ::: If there is at least one people who is wicked, then Shane is not poised and George is not frank.\n((Teak(noel))) ↔ ((¬Poised(noel))) ::: If Noel is teak, then Noel is not poised, and vice versa.\n¬∃x((¬(¬Frank(x)))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised.\n(∀x (Wicked(x) ∧ Mushy(x))) ↔ (∀x (Poised(x))) ::: Someone is wicked and mushy if and only if he is poised.\n(∃x (Poised(x) ∨ ¬Hungry(x))) → ((¬Mushy(george))) ::: If there is at least one people who is poised or not hungry, then George is not mushy.\n(∃x (Wicked(x) ∧ ¬Teak(x))) → ((Poised(crosby))) ::: If there is at least one people who is both wicked and not teak, then Crosby is poised.\n((Teak(keith))) ↔ ((¬Poised(gregory) ∧ ¬Wicked(noel))) ::: Keith is teak if and only if Gregory is not poised and Noel is not wicked.\n((Teak(noel))) ↔ ((Hungry(shane))) ::: Noel is teak if and only if Shane is hungry.\n((¬Teak(gregory) ∧ Wicked(crosby))) → ((¬Mushy(keith))) ::: If Gregory is not teak and Crosby is wicked, then Keith is not mushy.\n(∃x (Hungry(x) ∧ Wicked(x))) → ((Teak(noel))) ::: If there is at least one people who is both hungry and wicked, then Noel is teak.\n",
                "First-Order-Logic Question": "¬Hungry(crosby) ::: Crosby is not hungry."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬x)) → ((Teak(shane) ∧ ¬Poised(shane))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised.",
                    "gram": "¬∃x((¬(¬Frank(x)))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised."
                }
            ],
            "answer": "B",
            "grammar_answer": "A",
            "backup_answer": "C"
        },
        {
            "id": 129,
            "raw_prog": {
                "First-Order-Logic Rules": "¬Hungry(gregory) ::: Gregory is not hungry.\nMushy(ronald) ::: Ronald is mushy.\nTeak(keith) ::: Keith is teak.\nPoised(crosby) ::: Crosby is poised.\nFrank(shane) ::: Shane is frank.\nPoised(gregory) ::: Gregory is poised.\n¬Poised(shane) ::: Shane is not poised.\nMushy(keith) ::: Keith is mushy.\n¬Frank(noel) ::: Noel is not frank.\nFrank(george) ::: George is frank.\nWicked(george) ::: George is wicked.\nFrank(keith) ::: Keith is frank.\n(∀x (Mushy(x) ∨ ¬Poised(x))) → (∀x (Hungry(x) ∧ ¬Wicked(x))) ::: If someone is either mushy or not poised, then he is hungry and not wicked.\n(¬Poised(gregory)) → (Mushy(shane)) ::: If Gregory is not poised, then Shane is mushy.\n(∃x (Wicked(x))) → ((¬Poised(shane) ∧ ¬Frank(george))) ::: If there is at least one people who is wicked, then Shane is not poised and George is not frank.\n((Teak(noel))) ↔ ((¬Poised(noel))) ::: If Noel is teak, then Noel is not poised, and vice versa.\n(¬∃x (¬x)) → ((Teak(shane) ∧ ¬Poised(shane))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised.\n(∀x (Wicked(x) ∧ Mushy(x))) ↔ (∀x (Poised(x))) ::: Someone is wicked and mushy if and only if he is poised.\n(∃x (Poised(x) ∨ ¬Hungry(x))) → ((¬Mushy(george))) ::: If there is at least one people who is poised or not hungry, then George is not mushy.\n(∃x (Wicked(x) ∧ ¬Teak(x))) → ((Poised(crosby))) ::: If there is at least one people who is both wicked and not teak, then Crosby is poised.\n((Teak(keith))) ↔ ((¬Poised(gregory) ∧ ¬Wicked(noel))) ::: Keith is teak if and only if Gregory is not poised and Noel is not wicked.\n((Teak(noel))) ↔ ((Hungry(shane))) ::: Noel is teak if and only if Shane is hungry.\n((¬Teak(gregory) ∧ Wicked(crosby))) → ((¬Mushy(keith))) ::: If Gregory is not teak and Crosby is wicked, then Keith is not mushy.\n(∃x (Hungry(x) ∧ Wicked(x))) → ((Teak(noel))) ::: If there is at least one people who is both hungry and wicked, then Noel is teak.\n",
                "First-Order-Logic Question": "¬Mushy(keith) ::: Keith is not mushy."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "¬Hungry(gregory) ::: Gregory is not hungry.\nMushy(ronald) ::: Ronald is mushy.\nTeak(keith) ::: Keith is teak.\nPoised(crosby) ::: Crosby is poised.\nFrank(shane) ::: Shane is frank.\nPoised(gregory) ::: Gregory is poised.\n¬Poised(shane) ::: Shane is not poised.\nMushy(keith) ::: Keith is mushy.\n¬Frank(noel) ::: Noel is not frank.\nFrank(george) ::: George is frank.\nWicked(george) ::: George is wicked.\nFrank(keith) ::: Keith is frank.\n(∀x (Mushy(x) ∨ ¬Poised(x))) → (∀x (Hungry(x) ∧ ¬Wicked(x))) ::: If someone is either mushy or not poised, then he is hungry and not wicked.\n(¬Poised(gregory)) → (Mushy(shane)) ::: If Gregory is not poised, then Shane is mushy.\n(∃x (Wicked(x))) → ((¬Poised(shane) ∧ ¬Frank(george))) ::: If there is at least one people who is wicked, then Shane is not poised and George is not frank.\n((Teak(noel))) ↔ ((¬Poised(noel))) ::: If Noel is teak, then Noel is not poised, and vice versa.\n¬∃x((¬(¬Frank(x)))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised.\n(∀x (Wicked(x) ∧ Mushy(x))) ↔ (∀x (Poised(x))) ::: Someone is wicked and mushy if and only if he is poised.\n(∃x (Poised(x) ∨ ¬Hungry(x))) → ((¬Mushy(george))) ::: If there is at least one people who is poised or not hungry, then George is not mushy.\n(∃x (Wicked(x) ∧ ¬Teak(x))) → ((Poised(crosby))) ::: If there is at least one people who is both wicked and not teak, then Crosby is poised.\n((Teak(keith))) ↔ ((¬Poised(gregory) ∧ ¬Wicked(noel))) ::: Keith is teak if and only if Gregory is not poised and Noel is not wicked.\n((Teak(noel))) ↔ ((Hungry(shane))) ::: Noel is teak if and only if Shane is hungry.\n((¬Teak(gregory) ∧ Wicked(crosby))) → ((¬Mushy(keith))) ::: If Gregory is not teak and Crosby is wicked, then Keith is not mushy.\n(∃x (Hungry(x) ∧ Wicked(x))) → ((Teak(noel))) ::: If there is at least one people who is both hungry and wicked, then Noel is teak.\n",
                "First-Order-Logic Question": "¬Mushy(keith) ::: Keith is not mushy."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬x)) → ((Teak(shane) ∧ ¬Poised(shane))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised.",
                    "gram": "¬∃x((¬(¬Frank(x)))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised."
                }
            ],
            "answer": "C",
            "grammar_answer": "A",
            "backup_answer": "B"
        },
        {
            "id": 130,
            "raw_prog": {
                "First-Order-Logic Rules": "¬Hungry(gregory) ::: Gregory is not hungry.\nMushy(ronald) ::: Ronald is mushy.\nTeak(keith) ::: Keith is teak.\nPoised(crosby) ::: Crosby is poised.\nFrank(shane) ::: Shane is frank.\nPoised(gregory) ::: Gregory is poised.\n¬Poised(shane) ::: Shane is not poised.\nMushy(keith) ::: Keith is mushy.\n¬Frank(noel) ::: Noel is not frank.\nFrank(george) ::: George is frank.\nWicked(george) ::: George is wicked.\nFrank(keith) ::: Keith is frank.\n(∀x (Mushy(x) ∨ ¬Poised(x))) → (∀x (Hungry(x) ∧ ¬Wicked(x))) ::: If someone is either mushy or not poised, then he is hungry and not wicked.\n(¬Poised(gregory)) → (Mushy(shane)) ::: If Gregory is not poised, then Shane is mushy.\n(∃x (Wicked(x))) → ((¬Poised(shane) ∧ ¬Frank(george))) ::: If there is at least one people who is wicked, then Shane is not poised and George is not frank.\n((Teak(noel))) ↔ ((¬Poised(noel))) ::: If Noel is teak, then Noel is not poised, and vice versa.\n(¬∃x (¬x)) → ((Teak(shane) ∧ ¬Poised(shane))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised.\n(∀x (Wicked(x) ∧ Mushy(x))) ↔ (∀x (Poised(x))) ::: Someone is wicked and mushy if and only if he is poised.\n(∃x (Poised(x) ∨ ¬Hungry(x))) → ((¬Mushy(george))) ::: If there is at least one people who is poised or not hungry, then George is not mushy.\n(∃x (Wicked(x) ∧ ¬Teak(x))) → ((Poised(crosby))) ::: If there is at least one people who is both wicked and not teak, then Crosby is poised.\n((Teak(keith))) ↔ ((¬Poised(gregory) ∧ ¬Wicked(noel))) ::: Keith is teak if and only if Gregory is not poised and Noel is not wicked.\n((Teak(noel))) ↔ ((Hungry(shane))) ::: Noel is teak if and only if Shane is hungry.\n((¬Teak(gregory) ∧ Wicked(crosby))) → ((¬Mushy(keith))) ::: If Gregory is not teak and Crosby is wicked, then Keith is not mushy.\n(∃x (Hungry(x) ∧ Wicked(x))) → ((Teak(noel))) ::: If there is at least one people who is both hungry and wicked, then Noel is teak.\n",
                "First-Order-Logic Question": "Poised(keith) ::: Keith is poised."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "¬Hungry(gregory) ::: Gregory is not hungry.\nMushy(ronald) ::: Ronald is mushy.\nTeak(keith) ::: Keith is teak.\nPoised(crosby) ::: Crosby is poised.\nFrank(shane) ::: Shane is frank.\nPoised(gregory) ::: Gregory is poised.\n¬Poised(shane) ::: Shane is not poised.\nMushy(keith) ::: Keith is mushy.\n¬Frank(noel) ::: Noel is not frank.\nFrank(george) ::: George is frank.\nWicked(george) ::: George is wicked.\nFrank(keith) ::: Keith is frank.\n(∀x (Mushy(x) ∨ ¬Poised(x))) → (∀x (Hungry(x) ∧ ¬Wicked(x))) ::: If someone is either mushy or not poised, then he is hungry and not wicked.\n(¬Poised(gregory)) → (Mushy(shane)) ::: If Gregory is not poised, then Shane is mushy.\n(∃x (Wicked(x))) → ((¬Poised(shane) ∧ ¬Frank(george))) ::: If there is at least one people who is wicked, then Shane is not poised and George is not frank.\n((Teak(noel))) ↔ ((¬Poised(noel))) ::: If Noel is teak, then Noel is not poised, and vice versa.\n¬∃x((¬(¬Frank(x)))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised.\n(∀x (Wicked(x) ∧ Mushy(x))) ↔ (∀x (Poised(x))) ::: Someone is wicked and mushy if and only if he is poised.\n(∃x (Poised(x) ∨ ¬Hungry(x))) → ((¬Mushy(george))) ::: If there is at least one people who is poised or not hungry, then George is not mushy.\n(∃x (Wicked(x) ∧ ¬Teak(x))) → ((Poised(crosby))) ::: If there is at least one people who is both wicked and not teak, then Crosby is poised.\n((Teak(keith))) ↔ ((¬Poised(gregory) ∧ ¬Wicked(noel))) ::: Keith is teak if and only if Gregory is not poised and Noel is not wicked.\n((Teak(noel))) ↔ ((Hungry(shane))) ::: Noel is teak if and only if Shane is hungry.\n((¬Teak(gregory) ∧ Wicked(crosby))) → ((¬Mushy(keith))) ::: If Gregory is not teak and Crosby is wicked, then Keith is not mushy.\n(∃x (Hungry(x) ∧ Wicked(x))) → ((Teak(noel))) ::: If there is at least one people who is both hungry and wicked, then Noel is teak.\n",
                "First-Order-Logic Question": "Poised(keith) ::: Keith is poised."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬x)) → ((Teak(shane) ∧ ¬Poised(shane))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised.",
                    "gram": "¬∃x((¬(¬Frank(x)))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised."
                }
            ],
            "answer": "C",
            "grammar_answer": "A",
            "backup_answer": "C"
        },
        {
            "id": 131,
            "raw_prog": {
                "First-Order-Logic Rules": "¬Hungry(gregory) ::: Gregory is not hungry.\nMushy(ronald) ::: Ronald is mushy.\nTeak(keith) ::: Keith is teak.\nPoised(crosby) ::: Crosby is poised.\nFrank(shane) ::: Shane is frank.\nPoised(gregory) ::: Gregory is poised.\n¬Poised(shane) ::: Shane is not poised.\nMushy(keith) ::: Keith is mushy.\n¬Frank(noel) ::: Noel is not frank.\nFrank(george) ::: George is frank.\nWicked(george) ::: George is wicked.\nFrank(keith) ::: Keith is frank.\n(∀x (Mushy(x) ∨ ¬Poised(x))) → (∀x (Hungry(x) ∧ ¬Wicked(x))) ::: If someone is either mushy or not poised, then he is hungry and not wicked.\n(¬Poised(gregory)) → (Mushy(shane)) ::: If Gregory is not poised, then Shane is mushy.\n(∃x (Wicked(x))) → ((¬Poised(shane) ∧ ¬Frank(george))) ::: If there is at least one people who is wicked, then Shane is not poised and George is not frank.\n((Teak(noel))) ↔ ((¬Poised(noel))) ::: If Noel is teak, then Noel is not poised, and vice versa.\n(¬∃x (¬x)) → ((Teak(shane) ∧ ¬Poised(shane))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised.\n(∀x (Wicked(x) ∧ Mushy(x))) ↔ (∀x (Poised(x))) ::: Someone is wicked and mushy if and only if he is poised.\n(∃x (Poised(x) ∨ ¬Hungry(x))) → ((¬Mushy(george))) ::: If there is at least one people who is poised or not hungry, then George is not mushy.\n(∃x (Wicked(x) ∧ ¬Teak(x))) → ((Poised(crosby))) ::: If there is at least one people who is both wicked and not teak, then Crosby is poised.\n((Teak(keith))) ↔ ((¬Poised(gregory) ∧ ¬Wicked(noel))) ::: Keith is teak if and only if Gregory is not poised and Noel is not wicked.\n((Teak(noel))) ↔ ((Hungry(shane))) ::: Noel is teak if and only if Shane is hungry.\n((¬Teak(gregory) ∧ Wicked(crosby))) → ((¬Mushy(keith))) ::: If Gregory is not teak and Crosby is wicked, then Keith is not mushy.\n(∃x (Hungry(x) ∧ Wicked(x))) → ((Teak(noel))) ::: If there is at least one people who is both hungry and wicked, then Noel is teak.\n",
                "First-Order-Logic Question": "Poised(george) ::: George is poised."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "¬Hungry(gregory) ::: Gregory is not hungry.\nMushy(ronald) ::: Ronald is mushy.\nTeak(keith) ::: Keith is teak.\nPoised(crosby) ::: Crosby is poised.\nFrank(shane) ::: Shane is frank.\nPoised(gregory) ::: Gregory is poised.\n¬Poised(shane) ::: Shane is not poised.\nMushy(keith) ::: Keith is mushy.\n¬Frank(noel) ::: Noel is not frank.\nFrank(george) ::: George is frank.\nWicked(george) ::: George is wicked.\nFrank(keith) ::: Keith is frank.\n(∀x (Mushy(x) ∨ ¬Poised(x))) → (∀x (Hungry(x) ∧ ¬Wicked(x))) ::: If someone is either mushy or not poised, then he is hungry and not wicked.\n(¬Poised(gregory)) → (Mushy(shane)) ::: If Gregory is not poised, then Shane is mushy.\n(∃x (Wicked(x))) → ((¬Poised(shane) ∧ ¬Frank(george))) ::: If there is at least one people who is wicked, then Shane is not poised and George is not frank.\n((Teak(noel))) ↔ ((¬Poised(noel))) ::: If Noel is teak, then Noel is not poised, and vice versa.\n¬∃x((¬(¬Frank(x)))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised.\n(∀x (Wicked(x) ∧ Mushy(x))) ↔ (∀x (Poised(x))) ::: Someone is wicked and mushy if and only if he is poised.\n(∃x (Poised(x) ∨ ¬Hungry(x))) → ((¬Mushy(george))) ::: If there is at least one people who is poised or not hungry, then George is not mushy.\n(∃x (Wicked(x) ∧ ¬Teak(x))) → ((Poised(crosby))) ::: If there is at least one people who is both wicked and not teak, then Crosby is poised.\n((Teak(keith))) ↔ ((¬Poised(gregory) ∧ ¬Wicked(noel))) ::: Keith is teak if and only if Gregory is not poised and Noel is not wicked.\n((Teak(noel))) ↔ ((Hungry(shane))) ::: Noel is teak if and only if Shane is hungry.\n((¬Teak(gregory) ∧ Wicked(crosby))) → ((¬Mushy(keith))) ::: If Gregory is not teak and Crosby is wicked, then Keith is not mushy.\n(∃x (Hungry(x) ∧ Wicked(x))) → ((Teak(noel))) ::: If there is at least one people who is both hungry and wicked, then Noel is teak.\n",
                "First-Order-Logic Question": "Poised(george) ::: George is poised."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬x)) → ((Teak(shane) ∧ ¬Poised(shane))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised.",
                    "gram": "¬∃x((¬(¬Frank(x)))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised."
                }
            ],
            "answer": "B",
            "grammar_answer": "A",
            "backup_answer": "C"
        },
        {
            "id": 132,
            "raw_prog": {
                "First-Order-Logic Rules": "¬Hungry(gregory) ::: Gregory is not hungry.\nMushy(ronald) ::: Ronald is mushy.\nTeak(keith) ::: Keith is teak.\nPoised(crosby) ::: Crosby is poised.\nFrank(shane) ::: Shane is frank.\nPoised(gregory) ::: Gregory is poised.\n¬Poised(shane) ::: Shane is not poised.\nMushy(keith) ::: Keith is mushy.\n¬Frank(noel) ::: Noel is not frank.\nFrank(george) ::: George is frank.\nWicked(george) ::: George is wicked.\nFrank(keith) ::: Keith is frank.\n(∀x (Mushy(x) ∨ ¬Poised(x))) → (∀x (Hungry(x) ∧ ¬Wicked(x))) ::: If someone is either mushy or not poised, then he is hungry and not wicked.\n(¬Poised(gregory)) → (Mushy(shane)) ::: If Gregory is not poised, then Shane is mushy.\n(∃x (Wicked(x))) → ((¬Poised(shane) ∧ ¬Frank(george))) ::: If there is at least one people who is wicked, then Shane is not poised and George is not frank.\n((Teak(noel))) ↔ ((¬Poised(noel))) ::: If Noel is teak, then Noel is not poised, and vice versa.\n(¬∃x (¬x)) → ((Teak(shane) ∧ ¬Poised(shane))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised.\n(∀x (Wicked(x) ∧ Mushy(x))) ↔ (∀x (Poised(x))) ::: Someone is wicked and mushy if and only if he is poised.\n(∃x (Poised(x) ∨ ¬Hungry(x))) → ((¬Mushy(george))) ::: If there is at least one people who is poised or not hungry, then George is not mushy.\n(∃x (Wicked(x) ∧ ¬Teak(x))) → ((Poised(crosby))) ::: If there is at least one people who is both wicked and not teak, then Crosby is poised.\n((Teak(keith))) ↔ ((¬Poised(gregory) ∧ ¬Wicked(noel))) ::: Keith is teak if and only if Gregory is not poised and Noel is not wicked.\n((Teak(noel))) ↔ ((Hungry(shane))) ::: Noel is teak if and only if Shane is hungry.\n((¬Teak(gregory) ∧ Wicked(crosby))) → ((¬Mushy(keith))) ::: If Gregory is not teak and Crosby is wicked, then Keith is not mushy.\n(∃x (Hungry(x) ∧ Wicked(x))) → ((Teak(noel))) ::: If there is at least one people who is both hungry and wicked, then Noel is teak.\n",
                "First-Order-Logic Question": "Poised(noel) ::: Noel is poised."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "¬Hungry(gregory) ::: Gregory is not hungry.\nMushy(ronald) ::: Ronald is mushy.\nTeak(keith) ::: Keith is teak.\nPoised(crosby) ::: Crosby is poised.\nFrank(shane) ::: Shane is frank.\nPoised(gregory) ::: Gregory is poised.\n¬Poised(shane) ::: Shane is not poised.\nMushy(keith) ::: Keith is mushy.\n¬Frank(noel) ::: Noel is not frank.\nFrank(george) ::: George is frank.\nWicked(george) ::: George is wicked.\nFrank(keith) ::: Keith is frank.\n(∀x (Mushy(x) ∨ ¬Poised(x))) → (∀x (Hungry(x) ∧ ¬Wicked(x))) ::: If someone is either mushy or not poised, then he is hungry and not wicked.\n(¬Poised(gregory)) → (Mushy(shane)) ::: If Gregory is not poised, then Shane is mushy.\n(∃x (Wicked(x))) → ((¬Poised(shane) ∧ ¬Frank(george))) ::: If there is at least one people who is wicked, then Shane is not poised and George is not frank.\n((Teak(noel))) ↔ ((¬Poised(noel))) ::: If Noel is teak, then Noel is not poised, and vice versa.\n¬∃x((¬(¬Frank(x)))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised.\n(∀x (Wicked(x) ∧ Mushy(x))) ↔ (∀x (Poised(x))) ::: Someone is wicked and mushy if and only if he is poised.\n(∃x (Poised(x) ∨ ¬Hungry(x))) → ((¬Mushy(george))) ::: If there is at least one people who is poised or not hungry, then George is not mushy.\n(∃x (Wicked(x) ∧ ¬Teak(x))) → ((Poised(crosby))) ::: If there is at least one people who is both wicked and not teak, then Crosby is poised.\n((Teak(keith))) ↔ ((¬Poised(gregory) ∧ ¬Wicked(noel))) ::: Keith is teak if and only if Gregory is not poised and Noel is not wicked.\n((Teak(noel))) ↔ ((Hungry(shane))) ::: Noel is teak if and only if Shane is hungry.\n((¬Teak(gregory) ∧ Wicked(crosby))) → ((¬Mushy(keith))) ::: If Gregory is not teak and Crosby is wicked, then Keith is not mushy.\n(∃x (Hungry(x) ∧ Wicked(x))) → ((Teak(noel))) ::: If there is at least one people who is both hungry and wicked, then Noel is teak.\n",
                "First-Order-Logic Question": "Poised(noel) ::: Noel is poised."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬x)) → ((Teak(shane) ∧ ¬Poised(shane))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised.",
                    "gram": "¬∃x((¬(¬Frank(x)))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised."
                }
            ],
            "answer": "A",
            "grammar_answer": "A",
            "backup_answer": "C"
        },
        {
            "id": 133,
            "raw_prog": {
                "First-Order-Logic Rules": "¬Hungry(gregory) ::: Gregory is not hungry.\nMushy(ronald) ::: Ronald is mushy.\nTeak(keith) ::: Keith is teak.\nPoised(crosby) ::: Crosby is poised.\nFrank(shane) ::: Shane is frank.\nPoised(gregory) ::: Gregory is poised.\n¬Poised(shane) ::: Shane is not poised.\nMushy(keith) ::: Keith is mushy.\n¬Frank(noel) ::: Noel is not frank.\nFrank(george) ::: George is frank.\nWicked(george) ::: George is wicked.\nFrank(keith) ::: Keith is frank.\n(∀x (Mushy(x) ∨ ¬Poised(x))) → (∀x (Hungry(x) ∧ ¬Wicked(x))) ::: If someone is either mushy or not poised, then he is hungry and not wicked.\n(¬Poised(gregory)) → (Mushy(shane)) ::: If Gregory is not poised, then Shane is mushy.\n(∃x (Wicked(x))) → ((¬Poised(shane) ∧ ¬Frank(george))) ::: If there is at least one people who is wicked, then Shane is not poised and George is not frank.\n((Teak(noel))) ↔ ((¬Poised(noel))) ::: If Noel is teak, then Noel is not poised, and vice versa.\n(¬∃x (¬x)) → ((Teak(shane) ∧ ¬Poised(shane))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised.\n(∀x (Wicked(x) ∧ Mushy(x))) ↔ (∀x (Poised(x))) ::: Someone is wicked and mushy if and only if he is poised.\n(∃x (Poised(x) ∨ ¬Hungry(x))) → ((¬Mushy(george))) ::: If there is at least one people who is poised or not hungry, then George is not mushy.\n(∃x (Wicked(x) ∧ ¬Teak(x))) → ((Poised(crosby))) ::: If there is at least one people who is both wicked and not teak, then Crosby is poised.\n((Teak(keith))) ↔ ((¬Poised(gregory) ∧ ¬Wicked(noel))) ::: Keith is teak if and only if Gregory is not poised and Noel is not wicked.\n((Teak(noel))) ↔ ((Hungry(shane))) ::: Noel is teak if and only if Shane is hungry.\n((¬Teak(gregory) ∧ Wicked(crosby))) → ((¬Mushy(keith))) ::: If Gregory is not teak and Crosby is wicked, then Keith is not mushy.\n(∃x (Hungry(x) ∧ Wicked(x))) → ((Teak(noel))) ::: If there is at least one people who is both hungry and wicked, then Noel is teak.\n",
                "First-Order-Logic Question": "Mushy(crosby) ::: Crosby is mushy."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "¬Hungry(gregory) ::: Gregory is not hungry.\nMushy(ronald) ::: Ronald is mushy.\nTeak(keith) ::: Keith is teak.\nPoised(crosby) ::: Crosby is poised.\nFrank(shane) ::: Shane is frank.\nPoised(gregory) ::: Gregory is poised.\n¬Poised(shane) ::: Shane is not poised.\nMushy(keith) ::: Keith is mushy.\n¬Frank(noel) ::: Noel is not frank.\nFrank(george) ::: George is frank.\nWicked(george) ::: George is wicked.\nFrank(keith) ::: Keith is frank.\n(∀x (Mushy(x) ∨ ¬Poised(x))) → (∀x (Hungry(x) ∧ ¬Wicked(x))) ::: If someone is either mushy or not poised, then he is hungry and not wicked.\n(¬Poised(gregory)) → (Mushy(shane)) ::: If Gregory is not poised, then Shane is mushy.\n(∃x (Wicked(x))) → ((¬Poised(shane) ∧ ¬Frank(george))) ::: If there is at least one people who is wicked, then Shane is not poised and George is not frank.\n((Teak(noel))) ↔ ((¬Poised(noel))) ::: If Noel is teak, then Noel is not poised, and vice versa.\n¬∃x((¬(¬Frank(x)))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised.\n(∀x (Wicked(x) ∧ Mushy(x))) ↔ (∀x (Poised(x))) ::: Someone is wicked and mushy if and only if he is poised.\n(∃x (Poised(x) ∨ ¬Hungry(x))) → ((¬Mushy(george))) ::: If there is at least one people who is poised or not hungry, then George is not mushy.\n(∃x (Wicked(x) ∧ ¬Teak(x))) → ((Poised(crosby))) ::: If there is at least one people who is both wicked and not teak, then Crosby is poised.\n((Teak(keith))) ↔ ((¬Poised(gregory) ∧ ¬Wicked(noel))) ::: Keith is teak if and only if Gregory is not poised and Noel is not wicked.\n((Teak(noel))) ↔ ((Hungry(shane))) ::: Noel is teak if and only if Shane is hungry.\n((¬Teak(gregory) ∧ Wicked(crosby))) → ((¬Mushy(keith))) ::: If Gregory is not teak and Crosby is wicked, then Keith is not mushy.\n(∃x (Hungry(x) ∧ Wicked(x))) → ((Teak(noel))) ::: If there is at least one people who is both hungry and wicked, then Noel is teak.\n",
                "First-Order-Logic Question": "Mushy(crosby) ::: Crosby is mushy."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬x)) → ((Teak(shane) ∧ ¬Poised(shane))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised.",
                    "gram": "¬∃x((¬(¬Frank(x)))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised."
                }
            ],
            "answer": "A",
            "grammar_answer": "A",
            "backup_answer": "B"
        },
        {
            "id": 134,
            "raw_prog": {
                "First-Order-Logic Rules": "¬Hungry(gregory) ::: Gregory is not hungry.\nMushy(ronald) ::: Ronald is mushy.\nTeak(keith) ::: Keith is teak.\nPoised(crosby) ::: Crosby is poised.\nFrank(shane) ::: Shane is frank.\nPoised(gregory) ::: Gregory is poised.\n¬Poised(shane) ::: Shane is not poised.\nMushy(keith) ::: Keith is mushy.\n¬Frank(noel) ::: Noel is not frank.\nFrank(george) ::: George is frank.\nWicked(george) ::: George is wicked.\nFrank(keith) ::: Keith is frank.\n(∀x (Mushy(x) ∨ ¬Poised(x))) → (∀x (Hungry(x) ∧ ¬Wicked(x))) ::: If someone is either mushy or not poised, then he is hungry and not wicked.\n(¬Poised(gregory)) → (Mushy(shane)) ::: If Gregory is not poised, then Shane is mushy.\n(∃x (Wicked(x))) → ((¬Poised(shane) ∧ ¬Frank(george))) ::: If there is at least one people who is wicked, then Shane is not poised and George is not frank.\n((Teak(noel))) ↔ ((¬Poised(noel))) ::: If Noel is teak, then Noel is not poised, and vice versa.\n(¬∃x (¬x)) → ((Teak(shane) ∧ ¬Poised(shane))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised.\n(∀x (Wicked(x) ∧ Mushy(x))) ↔ (∀x (Poised(x))) ::: Someone is wicked and mushy if and only if he is poised.\n(∃x (Poised(x) ∨ ¬Hungry(x))) → ((¬Mushy(george))) ::: If there is at least one people who is poised or not hungry, then George is not mushy.\n(∃x (Wicked(x) ∧ ¬Teak(x))) → ((Poised(crosby))) ::: If there is at least one people who is both wicked and not teak, then Crosby is poised.\n((Teak(keith))) ↔ ((¬Poised(gregory) ∧ ¬Wicked(noel))) ::: Keith is teak if and only if Gregory is not poised and Noel is not wicked.\n((Teak(noel))) ↔ ((Hungry(shane))) ::: Noel is teak if and only if Shane is hungry.\n((¬Teak(gregory) ∧ Wicked(crosby))) → ((¬Mushy(keith))) ::: If Gregory is not teak and Crosby is wicked, then Keith is not mushy.\n(∃x (Hungry(x) ∧ Wicked(x))) → ((Teak(noel))) ::: If there is at least one people who is both hungry and wicked, then Noel is teak.\n",
                "First-Order-Logic Question": "Frank(keith) ::: Keith is frank."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "¬Hungry(gregory) ::: Gregory is not hungry.\nMushy(ronald) ::: Ronald is mushy.\nTeak(keith) ::: Keith is teak.\nPoised(crosby) ::: Crosby is poised.\nFrank(shane) ::: Shane is frank.\nPoised(gregory) ::: Gregory is poised.\n¬Poised(shane) ::: Shane is not poised.\nMushy(keith) ::: Keith is mushy.\n¬Frank(noel) ::: Noel is not frank.\nFrank(george) ::: George is frank.\nWicked(george) ::: George is wicked.\nFrank(keith) ::: Keith is frank.\n(∀x (Mushy(x) ∨ ¬Poised(x))) → (∀x (Hungry(x) ∧ ¬Wicked(x))) ::: If someone is either mushy or not poised, then he is hungry and not wicked.\n(¬Poised(gregory)) → (Mushy(shane)) ::: If Gregory is not poised, then Shane is mushy.\n(∃x (Wicked(x))) → ((¬Poised(shane) ∧ ¬Frank(george))) ::: If there is at least one people who is wicked, then Shane is not poised and George is not frank.\n((Teak(noel))) ↔ ((¬Poised(noel))) ::: If Noel is teak, then Noel is not poised, and vice versa.\n¬∃x((¬(¬Frank(x)))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised.\n(∀x (Wicked(x) ∧ Mushy(x))) ↔ (∀x (Poised(x))) ::: Someone is wicked and mushy if and only if he is poised.\n(∃x (Poised(x) ∨ ¬Hungry(x))) → ((¬Mushy(george))) ::: If there is at least one people who is poised or not hungry, then George is not mushy.\n(∃x (Wicked(x) ∧ ¬Teak(x))) → ((Poised(crosby))) ::: If there is at least one people who is both wicked and not teak, then Crosby is poised.\n((Teak(keith))) ↔ ((¬Poised(gregory) ∧ ¬Wicked(noel))) ::: Keith is teak if and only if Gregory is not poised and Noel is not wicked.\n((Teak(noel))) ↔ ((Hungry(shane))) ::: Noel is teak if and only if Shane is hungry.\n((¬Teak(gregory) ∧ Wicked(crosby))) → ((¬Mushy(keith))) ::: If Gregory is not teak and Crosby is wicked, then Keith is not mushy.\n(∃x (Hungry(x) ∧ Wicked(x))) → ((Teak(noel))) ::: If there is at least one people who is both hungry and wicked, then Noel is teak.\n",
                "First-Order-Logic Question": "Frank(keith) ::: Keith is frank."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬x)) → ((Teak(shane) ∧ ¬Poised(shane))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised.",
                    "gram": "¬∃x((¬(¬Frank(x)))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised."
                }
            ],
            "answer": "A",
            "grammar_answer": "A",
            "backup_answer": "A"
        },
        {
            "id": 360,
            "raw_prog": {
                "First-Order-Logic Rules": "¬Able(jasper) ::: Jasper is not able.\n¬Frank(jack) ::: Jack is not frank.\nCivil(jasper) ::: Jasper is civil.\n¬Civil(george) ::: George is not civil.\nFrank(burgess) ::: Burgess is frank.\nJolly(roderick) ::: Roderick is jolly.\n¬Civil(myra) ::: Myra is not civil.\nPrecious(roderick) ::: Roderick is precious.\nJolly(jack) ::: Jack is jolly.\n¬Able(burgess) ::: Burgess is not able.\n¬Jolly(miles) ::: Miles is not jolly.\nJolly(jasper) ::: Jasper is jolly.\n((Jolly(burgess))) → ((¬Able(roderick))) ::: It can be concluded that Roderick is not able once knowing that Burgess is jolly.\n(∃x (Able(x) ∧ Jolly(x))) → ((¬Frank(jasper))) ::: If there is someone who is both able and jolly, then Jasper is not frank.\n(∃x (¬Frank(x) ∨ ¬Civil(x))) → ((Able(roderick))) ::: If there is at least one people who is not frank or not civil, then Roderick is able.\n(∃x (Able(x))) → ((¬Frank(george) ∧ ¬Technical(jack))) ::: If there is someone who is able, then George is not frank and Jack is not technical.\n(¬∃x (¬x)) → ((¬Frank(jack))) ::: If there is nobody who is not, then Jack is not frank.\n(∃x (¬Frank(x) ∨ ¬Precious(x))) → ((¬Able(roderick))) ::: If there is at least one people who is not frank or not precious, then Roderick is not able.\n(∀x (Frank(x))) → (∀x (¬Precious(x) ∧ ¬Civil(x))) ::: If someone is frank, then he is neither precious nor civil.\n((¬Jolly(burgess) ∨ ¬Civil(roderick))) → ((¬Technical(george))) ::: It can be concluded that George is not technical once knowing that Burgess is not jolly or Roderick is not civil.\n(∀x (Precious(x))) ↔ (∀x (¬Frank(x))) ::: If someone is precious, then he is not frank, and vice versa.\n(∀x (x ∨ ¬Precious(x))) → (∀x (¬Jolly(x))) ::: If someone is he or not precious is technical, then he is not jolly.\n(∀x (¬Civil(x) ∧ ¬Jolly(x))) ↔ (∀x (Able(x))) ::: If someone is not civil and not jolly, then he is able, and vice versa.\n((Able(roderick))) → ((Precious(burgess) ∧ ¬Civil(jack))) ::: Roderick being able implies that Burgess is precious and Jack is not civil.\n",
                "First-Order-Logic Question": "Civil(myra) ::: Myra is civil."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "¬Able(jasper) ::: Jasper is not able.\n¬Frank(jack) ::: Jack is not frank.\nCivil(jasper) ::: Jasper is civil.\n¬Civil(george) ::: George is not civil.\nFrank(burgess) ::: Burgess is frank.\nJolly(roderick) ::: Roderick is jolly.\n¬Civil(myra) ::: Myra is not civil.\nPrecious(roderick) ::: Roderick is precious.\nJolly(jack) ::: Jack is jolly.\n¬Able(burgess) ::: Burgess is not able.\n¬Jolly(miles) ::: Miles is not jolly.\nJolly(jasper) ::: Jasper is jolly.\n((Jolly(burgess))) → ((¬Able(roderick))) ::: It can be concluded that Roderick is not able once knowing that Burgess is jolly.\n(∃x (Able(x) ∧ Jolly(x))) → ((¬Frank(jasper))) ::: If there is someone who is both able and jolly, then Jasper is not frank.\n(∃x (¬Frank(x) ∨ ¬Civil(x))) → ((Able(roderick))) ::: If there is at least one people who is not frank or not civil, then Roderick is able.\n(∃x (Able(x))) → ((¬Frank(george) ∧ ¬Technical(jack))) ::: If there is someone who is able, then George is not frank and Jack is not technical.\n¬∃x((¬Frank(x))→(¬Frank(x))) ::: If there is nobody who is not, then Jack is not frank.\n(∃x (¬Frank(x) ∨ ¬Precious(x))) → ((¬Able(roderick))) ::: If there is at least one people who is not frank or not precious, then Roderick is not able.\n(∀x (Frank(x))) → (∀x (¬Precious(x) ∧ ¬Civil(x))) ::: If someone is frank, then he is neither precious nor civil.\n((¬Jolly(burgess) ∨ ¬Civil(roderick))) → ((¬Technical(george))) ::: It can be concluded that George is not technical once knowing that Burgess is not jolly or Roderick is not civil.\n(∀x (Precious(x))) ↔ (∀x (¬Frank(x))) ::: If someone is precious, then he is not frank, and vice versa.\n∀x((Able(x)∨¬Precious(x))) ::: If someone is he or not precious is technical, then he is not jolly.\n(∀x (¬Civil(x) ∧ ¬Jolly(x))) ↔ (∀x (Able(x))) ::: If someone is not civil and not jolly, then he is able, and vice versa.\n((Able(roderick))) → ((Precious(burgess) ∧ ¬Civil(jack))) ::: Roderick being able implies that Burgess is precious and Jack is not civil.\n",
                "First-Order-Logic Question": "Civil(myra) ::: Myra is civil."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬x)) → ((¬Frank(jack))) ::: If there is nobody who is not, then Jack is not frank.",
                    "gram": "¬∃x((¬Frank(x))→(¬Frank(x))) ::: If there is nobody who is not, then Jack is not frank."
                },
                {
                    "raw": "(∀x (x ∨ ¬Precious(x))) → (∀x (¬Jolly(x))) ::: If someone is he or not precious is technical, then he is not jolly.",
                    "gram": "∀x((Able(x)∨¬Precious(x))) ::: If someone is he or not precious is technical, then he is not jolly."
                }
            ],
            "answer": "A",
            "grammar_answer": "A",
            "backup_answer": "B"
        },
        {
            "id": 361,
            "raw_prog": {
                "First-Order-Logic Rules": "¬Able(jasper) ::: Jasper is not able.\n¬Frank(jack) ::: Jack is not frank.\nCivil(jasper) ::: Jasper is civil.\n¬Civil(george) ::: George is not civil.\nFrank(burgess) ::: Burgess is frank.\nJolly(roderick) ::: Roderick is jolly.\n¬Civil(myra) ::: Myra is not civil.\nPrecious(roderick) ::: Roderick is precious.\nJolly(jack) ::: Jack is jolly.\n¬Able(burgess) ::: Burgess is not able.\n¬Jolly(miles) ::: Miles is not jolly.\nJolly(jasper) ::: Jasper is jolly.\n((Jolly(burgess))) → ((¬Able(roderick))) ::: It can be concluded that Roderick is not able once knowing that Burgess is jolly.\n(∃x (Able(x) ∧ Jolly(x))) → ((¬Frank(jasper))) ::: If there is someone who is both able and jolly, then Jasper is not frank.\n(∃x (¬Frank(x) ∨ ¬Civil(x))) → ((Able(roderick))) ::: If there is at least one people who is not frank or not civil, then Roderick is able.\n(∃x (Able(x))) → ((¬Frank(george) ∧ ¬Technical(jack))) ::: If there is someone who is able, then George is not frank and Jack is not technical.\n(¬∃x (¬x)) → ((¬Frank(jack))) ::: If there is nobody who is not, then Jack is not frank.\n(∃x (¬Frank(x) ∨ ¬Precious(x))) → ((¬Able(roderick))) ::: If there is at least one people who is not frank or not precious, then Roderick is not able.\n(∀x (Frank(x))) → (∀x (¬Precious(x) ∧ ¬Civil(x))) ::: If someone is frank, then he is neither precious nor civil.\n((¬Jolly(burgess) ∨ ¬Civil(roderick))) → ((¬Technical(george))) ::: It can be concluded that George is not technical once knowing that Burgess is not jolly or Roderick is not civil.\n(∀x (Precious(x))) ↔ (∀x (¬Frank(x))) ::: If someone is precious, then he is not frank, and vice versa.\n(∀x (x ∨ ¬Precious(x))) → (∀x (¬Jolly(x))) ::: If someone is he or not precious is technical, then he is not jolly.\n(∀x (¬Civil(x) ∧ ¬Jolly(x))) ↔ (∀x (Able(x))) ::: If someone is not civil and not jolly, then he is able, and vice versa.\n((Able(roderick))) → ((Precious(burgess) ∧ ¬Civil(jack))) ::: Roderick being able implies that Burgess is precious and Jack is not civil.\n",
                "First-Order-Logic Question": "Civil(jasper) ::: Jasper is civil."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "¬Able(jasper) ::: Jasper is not able.\n¬Frank(jack) ::: Jack is not frank.\nCivil(jasper) ::: Jasper is civil.\n¬Civil(george) ::: George is not civil.\nFrank(burgess) ::: Burgess is frank.\nJolly(roderick) ::: Roderick is jolly.\n¬Civil(myra) ::: Myra is not civil.\nPrecious(roderick) ::: Roderick is precious.\nJolly(jack) ::: Jack is jolly.\n¬Able(burgess) ::: Burgess is not able.\n¬Jolly(miles) ::: Miles is not jolly.\nJolly(jasper) ::: Jasper is jolly.\n((Jolly(burgess))) → ((¬Able(roderick))) ::: It can be concluded that Roderick is not able once knowing that Burgess is jolly.\n(∃x (Able(x) ∧ Jolly(x))) → ((¬Frank(jasper))) ::: If there is someone who is both able and jolly, then Jasper is not frank.\n(∃x (¬Frank(x) ∨ ¬Civil(x))) → ((Able(roderick))) ::: If there is at least one people who is not frank or not civil, then Roderick is able.\n(∃x (Able(x))) → ((¬Frank(george) ∧ ¬Technical(jack))) ::: If there is someone who is able, then George is not frank and Jack is not technical.\n¬∃x((¬Frank(x))→(¬Frank(x))) ::: If there is nobody who is not, then Jack is not frank.\n(∃x (¬Frank(x) ∨ ¬Precious(x))) → ((¬Able(roderick))) ::: If there is at least one people who is not frank or not precious, then Roderick is not able.\n(∀x (Frank(x))) → (∀x (¬Precious(x) ∧ ¬Civil(x))) ::: If someone is frank, then he is neither precious nor civil.\n((¬Jolly(burgess) ∨ ¬Civil(roderick))) → ((¬Technical(george))) ::: It can be concluded that George is not technical once knowing that Burgess is not jolly or Roderick is not civil.\n(∀x (Precious(x))) ↔ (∀x (¬Frank(x))) ::: If someone is precious, then he is not frank, and vice versa.\n∀x((Able(x)∨¬Precious(x))) ::: If someone is he or not precious is technical, then he is not jolly.\n(∀x (¬Civil(x) ∧ ¬Jolly(x))) ↔ (∀x (Able(x))) ::: If someone is not civil and not jolly, then he is able, and vice versa.\n((Able(roderick))) → ((Precious(burgess) ∧ ¬Civil(jack))) ::: Roderick being able implies that Burgess is precious and Jack is not civil.\n",
                "First-Order-Logic Question": "Civil(jasper) ::: Jasper is civil."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬x)) → ((¬Frank(jack))) ::: If there is nobody who is not, then Jack is not frank.",
                    "gram": "¬∃x((¬Frank(x))→(¬Frank(x))) ::: If there is nobody who is not, then Jack is not frank."
                },
                {
                    "raw": "(∀x (x ∨ ¬Precious(x))) → (∀x (¬Jolly(x))) ::: If someone is he or not precious is technical, then he is not jolly.",
                    "gram": "∀x((Able(x)∨¬Precious(x))) ::: If someone is he or not precious is technical, then he is not jolly."
                }
            ],
            "answer": "C",
            "grammar_answer": "A",
            "backup_answer": "A"
        },
        {
            "id": 362,
            "raw_prog": {
                "First-Order-Logic Rules": "¬Able(jasper) ::: Jasper is not able.\n¬Frank(jack) ::: Jack is not frank.\nCivil(jasper) ::: Jasper is civil.\n¬Civil(george) ::: George is not civil.\nFrank(burgess) ::: Burgess is frank.\nJolly(roderick) ::: Roderick is jolly.\n¬Civil(myra) ::: Myra is not civil.\nPrecious(roderick) ::: Roderick is precious.\nJolly(jack) ::: Jack is jolly.\n¬Able(burgess) ::: Burgess is not able.\n¬Jolly(miles) ::: Miles is not jolly.\nJolly(jasper) ::: Jasper is jolly.\n((Jolly(burgess))) → ((¬Able(roderick))) ::: It can be concluded that Roderick is not able once knowing that Burgess is jolly.\n(∃x (Able(x) ∧ Jolly(x))) → ((¬Frank(jasper))) ::: If there is someone who is both able and jolly, then Jasper is not frank.\n(∃x (¬Frank(x) ∨ ¬Civil(x))) → ((Able(roderick))) ::: If there is at least one people who is not frank or not civil, then Roderick is able.\n(∃x (Able(x))) → ((¬Frank(george) ∧ ¬Technical(jack))) ::: If there is someone who is able, then George is not frank and Jack is not technical.\n(¬∃x (¬x)) → ((¬Frank(jack))) ::: If there is nobody who is not, then Jack is not frank.\n(∃x (¬Frank(x) ∨ ¬Precious(x))) → ((¬Able(roderick))) ::: If there is at least one people who is not frank or not precious, then Roderick is not able.\n(∀x (Frank(x))) → (∀x (¬Precious(x) ∧ ¬Civil(x))) ::: If someone is frank, then he is neither precious nor civil.\n((¬Jolly(burgess) ∨ ¬Civil(roderick))) → ((¬Technical(george))) ::: It can be concluded that George is not technical once knowing that Burgess is not jolly or Roderick is not civil.\n(∀x (Precious(x))) ↔ (∀x (¬Frank(x))) ::: If someone is precious, then he is not frank, and vice versa.\n(∀x (x ∨ ¬Precious(x))) → (∀x (¬Jolly(x))) ::: If someone is he or not precious is technical, then he is not jolly.\n(∀x (¬Civil(x) ∧ ¬Jolly(x))) ↔ (∀x (Able(x))) ::: If someone is not civil and not jolly, then he is able, and vice versa.\n((Able(roderick))) → ((Precious(burgess) ∧ ¬Civil(jack))) ::: Roderick being able implies that Burgess is precious and Jack is not civil.\n",
                "First-Order-Logic Question": "Precious(myra) ::: Myra is precious."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "¬Able(jasper) ::: Jasper is not able.\n¬Frank(jack) ::: Jack is not frank.\nCivil(jasper) ::: Jasper is civil.\n¬Civil(george) ::: George is not civil.\nFrank(burgess) ::: Burgess is frank.\nJolly(roderick) ::: Roderick is jolly.\n¬Civil(myra) ::: Myra is not civil.\nPrecious(roderick) ::: Roderick is precious.\nJolly(jack) ::: Jack is jolly.\n¬Able(burgess) ::: Burgess is not able.\n¬Jolly(miles) ::: Miles is not jolly.\nJolly(jasper) ::: Jasper is jolly.\n((Jolly(burgess))) → ((¬Able(roderick))) ::: It can be concluded that Roderick is not able once knowing that Burgess is jolly.\n(∃x (Able(x) ∧ Jolly(x))) → ((¬Frank(jasper))) ::: If there is someone who is both able and jolly, then Jasper is not frank.\n(∃x (¬Frank(x) ∨ ¬Civil(x))) → ((Able(roderick))) ::: If there is at least one people who is not frank or not civil, then Roderick is able.\n(∃x (Able(x))) → ((¬Frank(george) ∧ ¬Technical(jack))) ::: If there is someone who is able, then George is not frank and Jack is not technical.\n¬∃x((¬Frank(x))→(¬Frank(x))) ::: If there is nobody who is not, then Jack is not frank.\n(∃x (¬Frank(x) ∨ ¬Precious(x))) → ((¬Able(roderick))) ::: If there is at least one people who is not frank or not precious, then Roderick is not able.\n(∀x (Frank(x))) → (∀x (¬Precious(x) ∧ ¬Civil(x))) ::: If someone is frank, then he is neither precious nor civil.\n((¬Jolly(burgess) ∨ ¬Civil(roderick))) → ((¬Technical(george))) ::: It can be concluded that George is not technical once knowing that Burgess is not jolly or Roderick is not civil.\n(∀x (Precious(x))) ↔ (∀x (¬Frank(x))) ::: If someone is precious, then he is not frank, and vice versa.\n∀x((Able(x)∨¬Precious(x))) ::: If someone is he or not precious is technical, then he is not jolly.\n(∀x (¬Civil(x) ∧ ¬Jolly(x))) ↔ (∀x (Able(x))) ::: If someone is not civil and not jolly, then he is able, and vice versa.\n((Able(roderick))) → ((Precious(burgess) ∧ ¬Civil(jack))) ::: Roderick being able implies that Burgess is precious and Jack is not civil.\n",
                "First-Order-Logic Question": "Precious(myra) ::: Myra is precious."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬x)) → ((¬Frank(jack))) ::: If there is nobody who is not, then Jack is not frank.",
                    "gram": "¬∃x((¬Frank(x))→(¬Frank(x))) ::: If there is nobody who is not, then Jack is not frank."
                },
                {
                    "raw": "(∀x (x ∨ ¬Precious(x))) → (∀x (¬Jolly(x))) ::: If someone is he or not precious is technical, then he is not jolly.",
                    "gram": "∀x((Able(x)∨¬Precious(x))) ::: If someone is he or not precious is technical, then he is not jolly."
                }
            ],
            "answer": "C",
            "grammar_answer": "A",
            "backup_answer": "C"
        },
        {
            "id": 363,
            "raw_prog": {
                "First-Order-Logic Rules": "¬Able(jasper) ::: Jasper is not able.\n¬Frank(jack) ::: Jack is not frank.\nCivil(jasper) ::: Jasper is civil.\n¬Civil(george) ::: George is not civil.\nFrank(burgess) ::: Burgess is frank.\nJolly(roderick) ::: Roderick is jolly.\n¬Civil(myra) ::: Myra is not civil.\nPrecious(roderick) ::: Roderick is precious.\nJolly(jack) ::: Jack is jolly.\n¬Able(burgess) ::: Burgess is not able.\n¬Jolly(miles) ::: Miles is not jolly.\nJolly(jasper) ::: Jasper is jolly.\n((Jolly(burgess))) → ((¬Able(roderick))) ::: It can be concluded that Roderick is not able once knowing that Burgess is jolly.\n(∃x (Able(x) ∧ Jolly(x))) → ((¬Frank(jasper))) ::: If there is someone who is both able and jolly, then Jasper is not frank.\n(∃x (¬Frank(x) ∨ ¬Civil(x))) → ((Able(roderick))) ::: If there is at least one people who is not frank or not civil, then Roderick is able.\n(∃x (Able(x))) → ((¬Frank(george) ∧ ¬Technical(jack))) ::: If there is someone who is able, then George is not frank and Jack is not technical.\n(¬∃x (¬x)) → ((¬Frank(jack))) ::: If there is nobody who is not, then Jack is not frank.\n(∃x (¬Frank(x) ∨ ¬Precious(x))) → ((¬Able(roderick))) ::: If there is at least one people who is not frank or not precious, then Roderick is not able.\n(∀x (Frank(x))) → (∀x (¬Precious(x) ∧ ¬Civil(x))) ::: If someone is frank, then he is neither precious nor civil.\n((¬Jolly(burgess) ∨ ¬Civil(roderick))) → ((¬Technical(george))) ::: It can be concluded that George is not technical once knowing that Burgess is not jolly or Roderick is not civil.\n(∀x (Precious(x))) → (∀x (¬Frank(x))) ∧ (∀x (¬Frank(x))) → (∀x (¬Precious(x))) ::: If someone is precious, then he is not frank, and vice versa.\n(∀x (¬Civil(x) ∧ ¬Jolly(x))) ↔ (∀x (Able(x))) ::: If someone is not civil and not jolly, then he is able, and vice versa.\n((Able(roderick))) → ((Precious(burgess) ∧ ¬Civil(jack))) ::: Roderick being able implies that Burgess is precious and Jack is not civil.\n",
                "First-Order-Logic Question": "¬Technical(burgess) ::: Burgess is not technical."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "¬Able(jasper) ::: Jasper is not able.\n¬Frank(jack) ::: Jack is not frank.\nCivil(jasper) ::: Jasper is civil.\n¬Civil(george) ::: George is not civil.\nFrank(burgess) ::: Burgess is frank.\nJolly(roderick) ::: Roderick is jolly.\n¬Civil(myra) ::: Myra is not civil.\nPrecious(roderick) ::: Roderick is precious.\nJolly(jack) ::: Jack is jolly.\n¬Able(burgess) ::: Burgess is not able.\n¬Jolly(miles) ::: Miles is not jolly.\nJolly(jasper) ::: Jasper is jolly.\n((Jolly(burgess))) → ((¬Able(roderick))) ::: It can be concluded that Roderick is not able once knowing that Burgess is jolly.\n(∃x (Able(x) ∧ Jolly(x))) → ((¬Frank(jasper))) ::: If there is someone who is both able and jolly, then Jasper is not frank.\n(∃x (¬Frank(x) ∨ ¬Civil(x))) → ((Able(roderick))) ::: If there is at least one people who is not frank or not civil, then Roderick is able.\n(∃x (Able(x))) → ((¬Frank(george) ∧ ¬Technical(jack))) ::: If there is someone who is able, then George is not frank and Jack is not technical.\n¬∃x((¬Frank(x))→(¬Frank(x))) ::: If there is nobody who is not, then Jack is not frank.\n(∃x (¬Frank(x) ∨ ¬Precious(x))) → ((¬Able(roderick))) ::: If there is at least one people who is not frank or not precious, then Roderick is not able.\n(∀x (Frank(x))) → (∀x (¬Precious(x) ∧ ¬Civil(x))) ::: If someone is frank, then he is neither precious nor civil.\n((¬Jolly(burgess) ∨ ¬Civil(roderick))) → ((¬Technical(george))) ::: It can be concluded that George is not technical once knowing that Burgess is not jolly or Roderick is not civil.\n(∀x (Precious(x))) → (∀x (¬Frank(x))) ∧ (∀x (¬Frank(x))) → (∀x (¬Precious(x))) ::: If someone is precious, then he is not frank, and vice versa.\n(∀x (¬Civil(x) ∧ ¬Jolly(x))) ↔ (∀x (Able(x))) ::: If someone is not civil and not jolly, then he is able, and vice versa.\n((Able(roderick))) → ((Precious(burgess) ∧ ¬Civil(jack))) ::: Roderick being able implies that Burgess is precious and Jack is not civil.\n",
                "First-Order-Logic Question": "¬Technical(burgess) ::: Burgess is not technical."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬x)) → ((¬Frank(jack))) ::: If there is nobody who is not, then Jack is not frank.",
                    "gram": "¬∃x((¬Frank(x))→(¬Frank(x))) ::: If there is nobody who is not, then Jack is not frank."
                }
            ],
            "answer": "B",
            "grammar_answer": "A",
            "backup_answer": "B"
        },
        {
            "id": 364,
            "raw_prog": {
                "First-Order-Logic Rules": "¬Able(jasper) ::: Jasper is not able.\n¬Frank(jack) ::: Jack is not frank.\nCivil(jasper) ::: Jasper is civil.\n¬Civil(george) ::: George is not civil.\nFrank(burgess) ::: Burgess is frank.\nJolly(roderick) ::: Roderick is jolly.\n¬Civil(myra) ::: Myra is not civil.\nPrecious(roderick) ::: Roderick is precious.\nJolly(jack) ::: Jack is jolly.\n¬Able(burgess) ::: Burgess is not able.\n¬Jolly(miles) ::: Miles is not jolly.\nJolly(jasper) ::: Jasper is jolly.\n((Jolly(burgess))) → ((¬Able(roderick))) ::: It can be concluded that Roderick is not able once knowing that Burgess is jolly.\n(∃x (Able(x) ∧ Jolly(x))) → ((¬Frank(jasper))) ::: If there is someone who is both able and jolly, then Jasper is not frank.\n(∃x (¬Frank(x) ∨ ¬Civil(x))) → ((Able(roderick))) ::: If there is at least one people who is not frank or not civil, then Roderick is able.\n(∃x (Able(x))) → ((¬Frank(george) ∧ ¬Technical(jack))) ::: If there is someone who is able, then George is not frank and Jack is not technical.\n(¬∃x (¬Frank(x))) → ((¬Frank(jack))) ::: If there is nobody who is not, then Jack is not frank.\n(∃x (¬Frank(x) ∨ ¬Precious(x))) → ((¬Able(roderick))) ::: If there is at least one people who is not frank or not precious, then Roderick is not able.\n(∀x (Frank(x))) → (∀x (¬Precious(x) ∧ ¬Civil(x))) ::: If someone is frank, then he is neither precious nor civil.\n((¬Jolly(burgess) ∨ ¬Civil(roderick))) → ((¬Technical(george))) ::: It can be concluded that George is not technical once knowing that Burgess is not jolly or Roderick is not civil.\n(∀x (Precious(x))) ↔ (∀x (¬Frank(x))) ::: If someone is precious, then he is not frank, and vice versa.\n(∀x (¬Precious(x) ∨ Technical(x))) → (∀x (¬Jolly(x))) ::: If someone is he or not precious is technical, then he is not jolly.\n(∀x (¬Civil(x) ∧ ¬Jolly(x))) ↔ (∀x (Able(x))) ::: If someone is not civil and not jolly, then he is able, and vice versa.\n((Able(roderick))) → ((Precious(burgess) ∧ ¬Civil(jack))) ::: Roderick being able implies that Burgess is precious and Jack is not civil.\n",
                "First-Order-Logic Question": "¬Precious(roderick) ::: Roderick is not precious."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "¬Able(jasper) ::: Jasper is not able.\n¬Frank(jack) ::: Jack is not frank.\nCivil(jasper) ::: Jasper is civil.\n¬Civil(george) ::: George is not civil.\nFrank(burgess) ::: Burgess is frank.\nJolly(roderick) ::: Roderick is jolly.\n¬Civil(myra) ::: Myra is not civil.\nPrecious(roderick) ::: Roderick is precious.\nJolly(jack) ::: Jack is jolly.\n¬Able(burgess) ::: Burgess is not able.\n¬Jolly(miles) ::: Miles is not jolly.\nJolly(jasper) ::: Jasper is jolly.\n((Jolly(burgess))) → ((¬Able(roderick))) ::: It can be concluded that Roderick is not able once knowing that Burgess is jolly.\n(∃x (Able(x) ∧ Jolly(x))) → ((¬Frank(jasper))) ::: If there is someone who is both able and jolly, then Jasper is not frank.\n(∃x (¬Frank(x) ∨ ¬Civil(x))) → ((Able(roderick))) ::: If there is at least one people who is not frank or not civil, then Roderick is able.\n(∃x (Able(x))) → ((¬Frank(george) ∧ ¬Technical(jack))) ::: If there is someone who is able, then George is not frank and Jack is not technical.\n¬∃x(¬Frank(x))→((¬Frank(x))) ::: If there is nobody who is not, then Jack is not frank.\n(∃x (¬Frank(x) ∨ ¬Precious(x))) → ((¬Able(roderick))) ::: If there is at least one people who is not frank or not precious, then Roderick is not able.\n(∀x (Frank(x))) → (∀x (¬Precious(x) ∧ ¬Civil(x))) ::: If someone is frank, then he is neither precious nor civil.\n((¬Jolly(burgess) ∨ ¬Civil(roderick))) → ((¬Technical(george))) ::: It can be concluded that George is not technical once knowing that Burgess is not jolly or Roderick is not civil.\n(∀x (Precious(x))) ↔ (∀x (¬Frank(x))) ::: If someone is precious, then he is not frank, and vice versa.\n(∀x (¬Precious(x) ∨ Technical(x))) → (∀x (¬Jolly(x))) ::: If someone is he or not precious is technical, then he is not jolly.\n(∀x (¬Civil(x) ∧ ¬Jolly(x))) ↔ (∀x (Able(x))) ::: If someone is not civil and not jolly, then he is able, and vice versa.\n((Able(roderick))) → ((Precious(burgess) ∧ ¬Civil(jack))) ::: Roderick being able implies that Burgess is precious and Jack is not civil.\n",
                "First-Order-Logic Question": "¬Precious(roderick) ::: Roderick is not precious."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬Frank(x))) → ((¬Frank(jack))) ::: If there is nobody who is not, then Jack is not frank.",
                    "gram": "¬∃x(¬Frank(x))→((¬Frank(x))) ::: If there is nobody who is not, then Jack is not frank."
                }
            ],
            "answer": "B",
            "grammar_answer": "A",
            "backup_answer": "B"
        },
        {
            "id": 365,
            "raw_prog": {
                "First-Order-Logic Rules": "¬Able(jasper) ::: Jasper is not able.\n¬Frank(jack) ::: Jack is not frank.\nCivil(jasper) ::: Jasper is civil.\n¬Civil(george) ::: George is not civil.\nFrank(burgess) ::: Burgess is frank.\nJolly(roderick) ::: Roderick is jolly.\n¬Civil(myra) ::: Myra is not civil.\nPrecious(roderick) ::: Roderick is precious.\nJolly(jack) ::: Jack is jolly.\n¬Able(burgess) ::: Burgess is not able.\n¬Jolly(miles) ::: Miles is not jolly.\nJolly(jasper) ::: Jasper is jolly.\n((Jolly(burgess))) → ((¬Able(roderick))) ::: It can be concluded that Roderick is not able once knowing that Burgess is jolly.\n(∃x (Able(x) ∧ Jolly(x))) → ((¬Frank(jasper))) ::: If there is someone who is both able and jolly, then Jasper is not frank.\n(∃x (¬Frank(x) ∨ ¬Civil(x))) → ((Able(roderick))) ::: If there is at least one people who is not frank or not civil, then Roderick is able.\n(∃x (Able(x))) → ((¬Frank(george) ∧ ¬Technical(jack))) ::: If there is someone who is able, then George is not frank and Jack is not technical.\n(¬∃x (¬x)) → ((¬Frank(jack))) ::: If there is nobody who is not, then Jack is not frank.\n(∃x (¬Frank(x) ∨ ¬Precious(x))) → ((¬Able(roderick))) ::: If there is at least one people who is not frank or not precious, then Roderick is not able.\n(∀x (Frank(x))) → (∀x (¬Precious(x) ∧ ¬Civil(x))) ::: If someone is frank, then he is neither precious nor civil.\n((¬Jolly(burgess) ∨ ¬Civil(roderick))) → ((¬Technical(george))) ::: It can be concluded that George is not technical once knowing that Burgess is not jolly or Roderick is not civil.\n(∀x (Precious(x))) → (∀x (¬Frank(x))) ∧ (∀x (¬Frank(x))) → (∀x (¬Precious(x))) ::: If someone is precious, then he is not frank, and vice versa.\n(∀x (¬Civil(x) ∧ ¬Jolly(x))) ↔ (∀x (Able(x))) ::: If someone is not civil and not jolly, then he is able, and vice versa.\n((Able(roderick))) → ((Precious(burgess) ∧ ¬Civil(jack))) ::: Roderick being able implies that Burgess is precious and Jack is not civil.\n",
                "First-Order-Logic Question": "Civil(roderick) ::: Roderick is civil."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "¬Able(jasper) ::: Jasper is not able.\n¬Frank(jack) ::: Jack is not frank.\nCivil(jasper) ::: Jasper is civil.\n¬Civil(george) ::: George is not civil.\nFrank(burgess) ::: Burgess is frank.\nJolly(roderick) ::: Roderick is jolly.\n¬Civil(myra) ::: Myra is not civil.\nPrecious(roderick) ::: Roderick is precious.\nJolly(jack) ::: Jack is jolly.\n¬Able(burgess) ::: Burgess is not able.\n¬Jolly(miles) ::: Miles is not jolly.\nJolly(jasper) ::: Jasper is jolly.\n((Jolly(burgess))) → ((¬Able(roderick))) ::: It can be concluded that Roderick is not able once knowing that Burgess is jolly.\n(∃x (Able(x) ∧ Jolly(x))) → ((¬Frank(jasper))) ::: If there is someone who is both able and jolly, then Jasper is not frank.\n(∃x (¬Frank(x) ∨ ¬Civil(x))) → ((Able(roderick))) ::: If there is at least one people who is not frank or not civil, then Roderick is able.\n(∃x (Able(x))) → ((¬Frank(george) ∧ ¬Technical(jack))) ::: If there is someone who is able, then George is not frank and Jack is not technical.\n¬∃x((¬Frank(x))→(¬Frank(x))) ::: If there is nobody who is not, then Jack is not frank.\n(∃x (¬Frank(x) ∨ ¬Precious(x))) → ((¬Able(roderick))) ::: If there is at least one people who is not frank or not precious, then Roderick is not able.\n(∀x (Frank(x))) → (∀x (¬Precious(x) ∧ ¬Civil(x))) ::: If someone is frank, then he is neither precious nor civil.\n((¬Jolly(burgess) ∨ ¬Civil(roderick))) → ((¬Technical(george))) ::: It can be concluded that George is not technical once knowing that Burgess is not jolly or Roderick is not civil.\n(∀x (Precious(x))) → (∀x (¬Frank(x))) ∧ (∀x (¬Frank(x))) → (∀x (¬Precious(x))) ::: If someone is precious, then he is not frank, and vice versa.\n(∀x (¬Civil(x) ∧ ¬Jolly(x))) ↔ (∀x (Able(x))) ::: If someone is not civil and not jolly, then he is able, and vice versa.\n((Able(roderick))) → ((Precious(burgess) ∧ ¬Civil(jack))) ::: Roderick being able implies that Burgess is precious and Jack is not civil.\n",
                "First-Order-Logic Question": "Civil(roderick) ::: Roderick is civil."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬x)) → ((¬Frank(jack))) ::: If there is nobody who is not, then Jack is not frank.",
                    "gram": "¬∃x((¬Frank(x))→(¬Frank(x))) ::: If there is nobody who is not, then Jack is not frank."
                }
            ],
            "answer": "A",
            "grammar_answer": "A",
            "backup_answer": "C"
        },
        {
            "id": 366,
            "raw_prog": {
                "First-Order-Logic Rules": "¬Able(jasper) ::: Jasper is not able.\n¬Frank(jack) ::: Jack is not frank.\nCivil(jasper) ::: Jasper is civil.\n¬Civil(george) ::: George is not civil.\nFrank(burgess) ::: Burgess is frank.\nJolly(roderick) ::: Roderick is jolly.\n¬Civil(myra) ::: Myra is not civil.\nPrecious(roderick) ::: Roderick is precious.\nJolly(jack) ::: Jack is jolly.\n¬Able(burgess) ::: Burgess is not able.\n¬Jolly(miles) ::: Miles is not jolly.\nJolly(jasper) ::: Jasper is jolly.\n((Jolly(burgess))) → ((¬Able(roderick))) ::: It can be concluded that Roderick is not able once knowing that Burgess is jolly.\n(∃x (Able(x) ∧ Jolly(x))) → ((¬Frank(jasper))) ::: If there is someone who is both able and jolly, then Jasper is not frank.\n(∃x (¬Frank(x) ∨ ¬Civil(x))) → ((Able(roderick))) ::: If there is at least one people who is not frank or not civil, then Roderick is able.\n(∃x (Able(x))) → ((¬Frank(george) ∧ ¬Technical(jack))) ::: If there is someone who is able, then George is not frank and Jack is not technical.\n(¬∃x (¬x)) → ((¬Frank(jack))) ::: If there is nobody who is not, then Jack is not frank.\n(∃x (¬Frank(x) ∨ ¬Precious(x))) → ((¬Able(roderick))) ::: If there is at least one people who is not frank or not precious, then Roderick is not able.\n(∀x (Frank(x))) → (∀x (¬Precious(x) ∧ ¬Civil(x))) ::: If someone is frank, then he is neither precious nor civil.\n((¬Jolly(burgess) ∨ ¬Civil(roderick))) → ((¬Technical(george))) ::: It can be concluded that George is not technical once knowing that Burgess is not jolly or Roderick is not civil.\n(∀x (Precious(x))) ↔ (∀x (¬Frank(x))) ::: If someone is precious, then he is not frank, and vice versa.\n(∀x (x ∨ ¬Precious(x))) → (∀x (¬Jolly(x))) ::: If someone is he or not precious is technical, then he is not jolly.\n(∀x (¬Civil(x) ∧ ¬Jolly(x))) ↔ (∀x (Able(x))) ::: If someone is not civil and not jolly, then he is able, and vice versa.\n((Able(roderick))) → ((Precious(burgess) ∧ ¬Civil(jack))) ::: Roderick being able implies that Burgess is precious and Jack is not civil.\n",
                "First-Order-Logic Question": "¬Technical(george) ::: George is not technical."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "¬Able(jasper) ::: Jasper is not able.\n¬Frank(jack) ::: Jack is not frank.\nCivil(jasper) ::: Jasper is civil.\n¬Civil(george) ::: George is not civil.\nFrank(burgess) ::: Burgess is frank.\nJolly(roderick) ::: Roderick is jolly.\n¬Civil(myra) ::: Myra is not civil.\nPrecious(roderick) ::: Roderick is precious.\nJolly(jack) ::: Jack is jolly.\n¬Able(burgess) ::: Burgess is not able.\n¬Jolly(miles) ::: Miles is not jolly.\nJolly(jasper) ::: Jasper is jolly.\n((Jolly(burgess))) → ((¬Able(roderick))) ::: It can be concluded that Roderick is not able once knowing that Burgess is jolly.\n(∃x (Able(x) ∧ Jolly(x))) → ((¬Frank(jasper))) ::: If there is someone who is both able and jolly, then Jasper is not frank.\n(∃x (¬Frank(x) ∨ ¬Civil(x))) → ((Able(roderick))) ::: If there is at least one people who is not frank or not civil, then Roderick is able.\n(∃x (Able(x))) → ((¬Frank(george) ∧ ¬Technical(jack))) ::: If there is someone who is able, then George is not frank and Jack is not technical.\n¬∃x((¬Frank(x))→(¬Frank(x))) ::: If there is nobody who is not, then Jack is not frank.\n(∃x (¬Frank(x) ∨ ¬Precious(x))) → ((¬Able(roderick))) ::: If there is at least one people who is not frank or not precious, then Roderick is not able.\n(∀x (Frank(x))) → (∀x (¬Precious(x) ∧ ¬Civil(x))) ::: If someone is frank, then he is neither precious nor civil.\n((¬Jolly(burgess) ∨ ¬Civil(roderick))) → ((¬Technical(george))) ::: It can be concluded that George is not technical once knowing that Burgess is not jolly or Roderick is not civil.\n(∀x (Precious(x))) ↔ (∀x (¬Frank(x))) ::: If someone is precious, then he is not frank, and vice versa.\n∀x((Able(x)∨¬Precious(x))) ::: If someone is he or not precious is technical, then he is not jolly.\n(∀x (¬Civil(x) ∧ ¬Jolly(x))) ↔ (∀x (Able(x))) ::: If someone is not civil and not jolly, then he is able, and vice versa.\n((Able(roderick))) → ((Precious(burgess) ∧ ¬Civil(jack))) ::: Roderick being able implies that Burgess is precious and Jack is not civil.\n",
                "First-Order-Logic Question": "¬Technical(george) ::: George is not technical."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬x)) → ((¬Frank(jack))) ::: If there is nobody who is not, then Jack is not frank.",
                    "gram": "¬∃x((¬Frank(x))→(¬Frank(x))) ::: If there is nobody who is not, then Jack is not frank."
                },
                {
                    "raw": "(∀x (x ∨ ¬Precious(x))) → (∀x (¬Jolly(x))) ::: If someone is he or not precious is technical, then he is not jolly.",
                    "gram": "∀x((Able(x)∨¬Precious(x))) ::: If someone is he or not precious is technical, then he is not jolly."
                }
            ],
            "answer": "A",
            "grammar_answer": "A",
            "backup_answer": "A"
        },
        {
            "id": 367,
            "raw_prog": {
                "First-Order-Logic Rules": "¬Able(jasper) ::: Jasper is not able.\n¬Frank(jack) ::: Jack is not frank.\nCivil(jasper) ::: Jasper is civil.\n¬Civil(george) ::: George is not civil.\nFrank(burgess) ::: Burgess is frank.\nJolly(roderick) ::: Roderick is jolly.\n¬Civil(myra) ::: Myra is not civil.\nPrecious(roderick) ::: Roderick is precious.\nJolly(jack) ::: Jack is jolly.\n¬Able(burgess) ::: Burgess is not able.\n¬Jolly(miles) ::: Miles is not jolly.\nJolly(jasper) ::: Jasper is jolly.\n((Jolly(burgess))) → ((¬Able(roderick))) ::: It can be concluded that Roderick is not able once knowing that Burgess is jolly.\n(∃x (Able(x) ∧ Jolly(x))) → ((¬Frank(jasper))) ::: If there is someone who is both able and jolly, then Jasper is not frank.\n(∃x (¬Frank(x) ∨ ¬Civil(x))) → ((Able(roderick))) ::: If there is at least one people who is not frank or not civil, then Roderick is able.\n(∃x (Able(x))) → ((¬Frank(george) ∧ ¬Technical(jack))) ::: If there is someone who is able, then George is not frank and Jack is not technical.\n(¬∃x (¬x)) → ((¬Frank(jack))) ::: If there is nobody who is not, then Jack is not frank.\n(∃x (¬Frank(x) ∨ ¬Precious(x))) → ((¬Able(roderick))) ::: If there is at least one people who is not frank or not precious, then Roderick is not able.\n(∀x (Frank(x))) → (∀x (¬Precious(x) ∧ ¬Civil(x))) ::: If someone is frank, then he is neither precious nor civil.\n((¬Jolly(burgess) ∨ ¬Civil(roderick))) → ((¬Technical(george))) ::: It can be concluded that George is not technical once knowing that Burgess is not jolly or Roderick is not civil.\n(∀x (Precious(x))) → (∀x (¬Frank(x))) ∧ (∀x (¬Frank(x))) → (∀x (¬Precious(x))) ::: If someone is precious, then he is not frank, and vice versa.\n(∀x (¬Civil(x) ∧ ¬Jolly(x))) ↔ (∀x (Able(x))) ::: If someone is not civil and not jolly, then he is able, and vice versa.\n((Able(roderick))) → ((Precious(burgess) ∧ ¬Civil(jack))) ::: Roderick being able implies that Burgess is precious and Jack is not civil.\n",
                "First-Order-Logic Question": "¬Jolly(miles) ::: Miles is not jolly."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "¬Able(jasper) ::: Jasper is not able.\n¬Frank(jack) ::: Jack is not frank.\nCivil(jasper) ::: Jasper is civil.\n¬Civil(george) ::: George is not civil.\nFrank(burgess) ::: Burgess is frank.\nJolly(roderick) ::: Roderick is jolly.\n¬Civil(myra) ::: Myra is not civil.\nPrecious(roderick) ::: Roderick is precious.\nJolly(jack) ::: Jack is jolly.\n¬Able(burgess) ::: Burgess is not able.\n¬Jolly(miles) ::: Miles is not jolly.\nJolly(jasper) ::: Jasper is jolly.\n((Jolly(burgess))) → ((¬Able(roderick))) ::: It can be concluded that Roderick is not able once knowing that Burgess is jolly.\n(∃x (Able(x) ∧ Jolly(x))) → ((¬Frank(jasper))) ::: If there is someone who is both able and jolly, then Jasper is not frank.\n(∃x (¬Frank(x) ∨ ¬Civil(x))) → ((Able(roderick))) ::: If there is at least one people who is not frank or not civil, then Roderick is able.\n(∃x (Able(x))) → ((¬Frank(george) ∧ ¬Technical(jack))) ::: If there is someone who is able, then George is not frank and Jack is not technical.\n¬∃x((¬Frank(x))→(¬Frank(x))) ::: If there is nobody who is not, then Jack is not frank.\n(∃x (¬Frank(x) ∨ ¬Precious(x))) → ((¬Able(roderick))) ::: If there is at least one people who is not frank or not precious, then Roderick is not able.\n(∀x (Frank(x))) → (∀x (¬Precious(x) ∧ ¬Civil(x))) ::: If someone is frank, then he is neither precious nor civil.\n((¬Jolly(burgess) ∨ ¬Civil(roderick))) → ((¬Technical(george))) ::: It can be concluded that George is not technical once knowing that Burgess is not jolly or Roderick is not civil.\n(∀x (Precious(x))) → (∀x (¬Frank(x))) ∧ (∀x (¬Frank(x))) → (∀x (¬Precious(x))) ::: If someone is precious, then he is not frank, and vice versa.\n(∀x (¬Civil(x) ∧ ¬Jolly(x))) ↔ (∀x (Able(x))) ::: If someone is not civil and not jolly, then he is able, and vice versa.\n((Able(roderick))) → ((Precious(burgess) ∧ ¬Civil(jack))) ::: Roderick being able implies that Burgess is precious and Jack is not civil.\n",
                "First-Order-Logic Question": "¬Jolly(miles) ::: Miles is not jolly."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬x)) → ((¬Frank(jack))) ::: If there is nobody who is not, then Jack is not frank.",
                    "gram": "¬∃x((¬Frank(x))→(¬Frank(x))) ::: If there is nobody who is not, then Jack is not frank."
                }
            ],
            "answer": "C",
            "grammar_answer": "A",
            "backup_answer": "A"
        },
        {
            "id": 368,
            "raw_prog": {
                "First-Order-Logic Rules": "¬Able(jasper) ::: Jasper is not able.\n¬Frank(jack) ::: Jack is not frank.\nCivil(jasper) ::: Jasper is civil.\n¬Civil(george) ::: George is not civil.\nFrank(burgess) ::: Burgess is frank.\nJolly(roderick) ::: Roderick is jolly.\n¬Civil(myra) ::: Myra is not civil.\nPrecious(roderick) ::: Roderick is precious.\nJolly(jack) ::: Jack is jolly.\n¬Able(burgess) ::: Burgess is not able.\n¬Jolly(miles) ::: Miles is not jolly.\nJolly(jasper) ::: Jasper is jolly.\n((Jolly(burgess))) → ((¬Able(roderick))) ::: It can be concluded that Roderick is not able once knowing that Burgess is jolly.\n(∃x (Able(x) ∧ Jolly(x))) → ((¬Frank(jasper))) ::: If there is someone who is both able and jolly, then Jasper is not frank.\n(∃x (¬Frank(x) ∨ ¬Civil(x))) → ((Able(roderick))) ::: If there is at least one people who is not frank or not civil, then Roderick is able.\n(∃x (Able(x))) → ((¬Frank(george) ∧ ¬Technical(jack))) ::: If there is someone who is able, then George is not frank and Jack is not technical.\n(¬∃x (¬Frank(x))) → ((¬Frank(jack))) ::: If there is nobody who is not, then Jack is not frank.\n(∃x (¬Frank(x) ∨ ¬Precious(x))) → ((¬Able(roderick))) ::: If there is at least one people who is not frank or not precious, then Roderick is not able.\n(∀x (Frank(x))) → (∀x (¬Precious(x) ∧ ¬Civil(x))) ::: If someone is frank, then he is neither precious nor civil.\n((¬Jolly(burgess) ∨ ¬Civil(roderick))) → ((¬Technical(george))) ::: It can be concluded that George is not technical once knowing that Burgess is not jolly or Roderick is not civil.\n(∀x (Precious(x))) ↔ (∀x (¬Frank(x))) ::: If someone is precious, then he is not frank, and vice versa.\n(∀x (¬Precious(x) ∨ Technical(x))) → (∀x (¬Jolly(x))) ::: If someone is he or not precious is technical, then he is not jolly.\n(∀x (¬Civil(x) ∧ ¬Jolly(x))) ↔ (∀x (Able(x))) ::: If someone is not civil and not jolly, then he is able, and vice versa.\n((Able(roderick))) → ((Precious(burgess) ∧ ¬Civil(jack))) ::: Roderick being able implies that Burgess is precious and Jack is not civil.\n",
                "First-Order-Logic Question": "¬Jolly(george) ::: George is not jolly."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "¬Able(jasper) ::: Jasper is not able.\n¬Frank(jack) ::: Jack is not frank.\nCivil(jasper) ::: Jasper is civil.\n¬Civil(george) ::: George is not civil.\nFrank(burgess) ::: Burgess is frank.\nJolly(roderick) ::: Roderick is jolly.\n¬Civil(myra) ::: Myra is not civil.\nPrecious(roderick) ::: Roderick is precious.\nJolly(jack) ::: Jack is jolly.\n¬Able(burgess) ::: Burgess is not able.\n¬Jolly(miles) ::: Miles is not jolly.\nJolly(jasper) ::: Jasper is jolly.\n((Jolly(burgess))) → ((¬Able(roderick))) ::: It can be concluded that Roderick is not able once knowing that Burgess is jolly.\n(∃x (Able(x) ∧ Jolly(x))) → ((¬Frank(jasper))) ::: If there is someone who is both able and jolly, then Jasper is not frank.\n(∃x (¬Frank(x) ∨ ¬Civil(x))) → ((Able(roderick))) ::: If there is at least one people who is not frank or not civil, then Roderick is able.\n(∃x (Able(x))) → ((¬Frank(george) ∧ ¬Technical(jack))) ::: If there is someone who is able, then George is not frank and Jack is not technical.\n¬∃x(¬Frank(x))→((¬Frank(x))) ::: If there is nobody who is not, then Jack is not frank.\n(∃x (¬Frank(x) ∨ ¬Precious(x))) → ((¬Able(roderick))) ::: If there is at least one people who is not frank or not precious, then Roderick is not able.\n(∀x (Frank(x))) → (∀x (¬Precious(x) ∧ ¬Civil(x))) ::: If someone is frank, then he is neither precious nor civil.\n((¬Jolly(burgess) ∨ ¬Civil(roderick))) → ((¬Technical(george))) ::: It can be concluded that George is not technical once knowing that Burgess is not jolly or Roderick is not civil.\n(∀x (Precious(x))) ↔ (∀x (¬Frank(x))) ::: If someone is precious, then he is not frank, and vice versa.\n(∀x (¬Precious(x) ∨ Technical(x))) → (∀x (¬Jolly(x))) ::: If someone is he or not precious is technical, then he is not jolly.\n(∀x (¬Civil(x) ∧ ¬Jolly(x))) ↔ (∀x (Able(x))) ::: If someone is not civil and not jolly, then he is able, and vice versa.\n((Able(roderick))) → ((Precious(burgess) ∧ ¬Civil(jack))) ::: Roderick being able implies that Burgess is precious and Jack is not civil.\n",
                "First-Order-Logic Question": "¬Jolly(george) ::: George is not jolly."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬Frank(x))) → ((¬Frank(jack))) ::: If there is nobody who is not, then Jack is not frank.",
                    "gram": "¬∃x(¬Frank(x))→((¬Frank(x))) ::: If there is nobody who is not, then Jack is not frank."
                }
            ],
            "answer": "A",
            "grammar_answer": "A",
            "backup_answer": "C"
        },
        {
            "id": 369,
            "raw_prog": {
                "First-Order-Logic Rules": "¬Able(jasper) ::: Jasper is not able.\n¬Frank(jack) ::: Jack is not frank.\nCivil(jasper) ::: Jasper is civil.\n¬Civil(george) ::: George is not civil.\nFrank(burgess) ::: Burgess is frank.\nJolly(roderick) ::: Roderick is jolly.\n¬Civil(myra) ::: Myra is not civil.\nPrecious(roderick) ::: Roderick is precious.\nJolly(jack) ::: Jack is jolly.\n¬Able(burgess) ::: Burgess is not able.\n¬Jolly(miles) ::: Miles is not jolly.\nJolly(jasper) ::: Jasper is jolly.\n((Jolly(burgess))) → ((¬Able(roderick))) ::: It can be concluded that Roderick is not able once knowing that Burgess is jolly.\n(∃x (Able(x) ∧ Jolly(x))) → ((¬Frank(jasper))) ::: If there is someone who is both able and jolly, then Jasper is not frank.\n(∃x (¬Frank(x) ∨ ¬Civil(x))) → ((Able(roderick))) ::: If there is at least one people who is not frank or not civil, then Roderick is able.\n(∃x (Able(x))) → ((¬Frank(george) ∧ ¬Technical(jack))) ::: If there is someone who is able, then George is not frank and Jack is not technical.\n(¬∃x (¬Frank(x))) → ((¬Frank(jack))) ::: If there is nobody who is not, then Jack is not frank.\n(∃x (¬Frank(x) ∨ ¬Precious(x))) → ((¬Able(roderick))) ::: If there is at least one people who is not frank or not precious, then Roderick is not able.\n(∀x (Frank(x))) → (∀x (¬Precious(x) ∧ ¬Civil(x))) ::: If someone is frank, then he is neither precious nor civil.\n((¬Jolly(burgess) ∨ ¬Civil(roderick))) → ((¬Technical(george))) ::: It can be concluded that George is not technical once knowing that Burgess is not jolly or Roderick is not civil.\n(∀x (Precious(x))) ↔ (∀x (¬Frank(x))) ::: If someone is precious, then he is not frank, and vice versa.\n(∀x (¬Precious(x) ∨ Technical(x))) → (∀x (¬Jolly(x))) ::: If someone is he or not precious is technical, then he is not jolly.\n(∀x (¬Civil(x) ∧ ¬Jolly(x))) ↔ (∀x (Able(x))) ::: If someone is not civil and not jolly, then he is able, and vice versa.\n((Able(roderick))) → ((Precious(burgess) ∧ ¬Civil(jack))) ::: Roderick being able implies that Burgess is precious and Jack is not civil.\n",
                "First-Order-Logic Question": "¬Frank(jack) ::: Jack is not frank."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "¬Able(jasper) ::: Jasper is not able.\n¬Frank(jack) ::: Jack is not frank.\nCivil(jasper) ::: Jasper is civil.\n¬Civil(george) ::: George is not civil.\nFrank(burgess) ::: Burgess is frank.\nJolly(roderick) ::: Roderick is jolly.\n¬Civil(myra) ::: Myra is not civil.\nPrecious(roderick) ::: Roderick is precious.\nJolly(jack) ::: Jack is jolly.\n¬Able(burgess) ::: Burgess is not able.\n¬Jolly(miles) ::: Miles is not jolly.\nJolly(jasper) ::: Jasper is jolly.\n((Jolly(burgess))) → ((¬Able(roderick))) ::: It can be concluded that Roderick is not able once knowing that Burgess is jolly.\n(∃x (Able(x) ∧ Jolly(x))) → ((¬Frank(jasper))) ::: If there is someone who is both able and jolly, then Jasper is not frank.\n(∃x (¬Frank(x) ∨ ¬Civil(x))) → ((Able(roderick))) ::: If there is at least one people who is not frank or not civil, then Roderick is able.\n(∃x (Able(x))) → ((¬Frank(george) ∧ ¬Technical(jack))) ::: If there is someone who is able, then George is not frank and Jack is not technical.\n¬∃x(¬Frank(x))→((¬Frank(x))) ::: If there is nobody who is not, then Jack is not frank.\n(∃x (¬Frank(x) ∨ ¬Precious(x))) → ((¬Able(roderick))) ::: If there is at least one people who is not frank or not precious, then Roderick is not able.\n(∀x (Frank(x))) → (∀x (¬Precious(x) ∧ ¬Civil(x))) ::: If someone is frank, then he is neither precious nor civil.\n((¬Jolly(burgess) ∨ ¬Civil(roderick))) → ((¬Technical(george))) ::: It can be concluded that George is not technical once knowing that Burgess is not jolly or Roderick is not civil.\n(∀x (Precious(x))) ↔ (∀x (¬Frank(x))) ::: If someone is precious, then he is not frank, and vice versa.\n(∀x (¬Precious(x) ∨ Technical(x))) → (∀x (¬Jolly(x))) ::: If someone is he or not precious is technical, then he is not jolly.\n(∀x (¬Civil(x) ∧ ¬Jolly(x))) ↔ (∀x (Able(x))) ::: If someone is not civil and not jolly, then he is able, and vice versa.\n((Able(roderick))) → ((Precious(burgess) ∧ ¬Civil(jack))) ::: Roderick being able implies that Burgess is precious and Jack is not civil.\n",
                "First-Order-Logic Question": "¬Frank(jack) ::: Jack is not frank."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬Frank(x))) → ((¬Frank(jack))) ::: If there is nobody who is not, then Jack is not frank.",
                    "gram": "¬∃x(¬Frank(x))→((¬Frank(x))) ::: If there is nobody who is not, then Jack is not frank."
                }
            ],
            "answer": "A",
            "grammar_answer": "A",
            "backup_answer": "A"
        },
        {
            "id": 370,
            "raw_prog": {
                "First-Order-Logic Rules": "¬Able(jasper) ::: Jasper is not able.\n¬Frank(jack) ::: Jack is not frank.\nCivil(jasper) ::: Jasper is civil.\n¬Civil(george) ::: George is not civil.\nFrank(burgess) ::: Burgess is frank.\nJolly(roderick) ::: Roderick is jolly.\n¬Civil(myra) ::: Myra is not civil.\nPrecious(roderick) ::: Roderick is precious.\nJolly(jack) ::: Jack is jolly.\n¬Able(burgess) ::: Burgess is not able.\n¬Jolly(miles) ::: Miles is not jolly.\nJolly(jasper) ::: Jasper is jolly.\n((Jolly(burgess))) → ((¬Able(roderick))) ::: It can be concluded that Roderick is not able once knowing that Burgess is jolly.\n(∃x (Able(x) ∧ Jolly(x))) → ((¬Frank(jasper))) ::: If there is someone who is both able and jolly, then Jasper is not frank.\n(∃x (¬Frank(x) ∨ ¬Civil(x))) → ((Able(roderick))) ::: If there is at least one people who is not frank or not civil, then Roderick is able.\n(∃x (Able(x))) → ((¬Frank(george) ∧ ¬Technical(jack))) ::: If there is someone who is able, then George is not frank and Jack is not technical.\n(¬∃x (¬x)) → ((¬Frank(jack))) ::: If there is nobody who is not, then Jack is not frank.\n(∃x (¬Frank(x) ∨ ¬Precious(x))) → ((¬Able(roderick))) ::: If there is at least one people who is not frank or not precious, then Roderick is not able.\n(∀x (Frank(x))) → (∀x (¬Precious(x) ∧ ¬Civil(x))) ::: If someone is frank, then he is neither precious nor civil.\n((¬Jolly(burgess) ∨ ¬Civil(roderick))) → ((¬Technical(george))) ::: It can be concluded that George is not technical once knowing that Burgess is not jolly or Roderick is not civil.\n(∀x (Precious(x))) → (∀x (¬Frank(x))) ∧ (∀x (¬Frank(x))) → (∀x (¬Precious(x))) ::: If someone is precious, then he is not frank, and vice versa.\n(∀x (¬Civil(x) ∧ ¬Jolly(x))) ↔ (∀x (Able(x))) ::: If someone is not civil and not jolly, then he is able, and vice versa.\n((Able(roderick))) → ((Precious(burgess) ∧ ¬Civil(jack))) ::: Roderick being able implies that Burgess is precious and Jack is not civil.\n",
                "First-Order-Logic Question": "¬Frank(roderick) ::: Roderick is not frank."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "¬Able(jasper) ::: Jasper is not able.\n¬Frank(jack) ::: Jack is not frank.\nCivil(jasper) ::: Jasper is civil.\n¬Civil(george) ::: George is not civil.\nFrank(burgess) ::: Burgess is frank.\nJolly(roderick) ::: Roderick is jolly.\n¬Civil(myra) ::: Myra is not civil.\nPrecious(roderick) ::: Roderick is precious.\nJolly(jack) ::: Jack is jolly.\n¬Able(burgess) ::: Burgess is not able.\n¬Jolly(miles) ::: Miles is not jolly.\nJolly(jasper) ::: Jasper is jolly.\n((Jolly(burgess))) → ((¬Able(roderick))) ::: It can be concluded that Roderick is not able once knowing that Burgess is jolly.\n(∃x (Able(x) ∧ Jolly(x))) → ((¬Frank(jasper))) ::: If there is someone who is both able and jolly, then Jasper is not frank.\n(∃x (¬Frank(x) ∨ ¬Civil(x))) → ((Able(roderick))) ::: If there is at least one people who is not frank or not civil, then Roderick is able.\n(∃x (Able(x))) → ((¬Frank(george) ∧ ¬Technical(jack))) ::: If there is someone who is able, then George is not frank and Jack is not technical.\n¬∃x((¬Frank(x))→(¬Frank(x))) ::: If there is nobody who is not, then Jack is not frank.\n(∃x (¬Frank(x) ∨ ¬Precious(x))) → ((¬Able(roderick))) ::: If there is at least one people who is not frank or not precious, then Roderick is not able.\n(∀x (Frank(x))) → (∀x (¬Precious(x) ∧ ¬Civil(x))) ::: If someone is frank, then he is neither precious nor civil.\n((¬Jolly(burgess) ∨ ¬Civil(roderick))) → ((¬Technical(george))) ::: It can be concluded that George is not technical once knowing that Burgess is not jolly or Roderick is not civil.\n(∀x (Precious(x))) → (∀x (¬Frank(x))) ∧ (∀x (¬Frank(x))) → (∀x (¬Precious(x))) ::: If someone is precious, then he is not frank, and vice versa.\n(∀x (¬Civil(x) ∧ ¬Jolly(x))) ↔ (∀x (Able(x))) ::: If someone is not civil and not jolly, then he is able, and vice versa.\n((Able(roderick))) → ((Precious(burgess) ∧ ¬Civil(jack))) ::: Roderick being able implies that Burgess is precious and Jack is not civil.\n",
                "First-Order-Logic Question": "¬Frank(roderick) ::: Roderick is not frank."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬x)) → ((¬Frank(jack))) ::: If there is nobody who is not, then Jack is not frank.",
                    "gram": "¬∃x((¬Frank(x))→(¬Frank(x))) ::: If there is nobody who is not, then Jack is not frank."
                }
            ],
            "answer": "C",
            "grammar_answer": "A",
            "backup_answer": "A"
        },
        {
            "id": 371,
            "raw_prog": {
                "First-Order-Logic Rules": "¬Able(jasper) ::: Jasper is not able.\n¬Frank(jack) ::: Jack is not frank.\nCivil(jasper) ::: Jasper is civil.\n¬Civil(george) ::: George is not civil.\nFrank(burgess) ::: Burgess is frank.\nJolly(roderick) ::: Roderick is jolly.\n¬Civil(myra) ::: Myra is not civil.\nPrecious(roderick) ::: Roderick is precious.\nJolly(jack) ::: Jack is jolly.\n¬Able(burgess) ::: Burgess is not able.\n¬Jolly(miles) ::: Miles is not jolly.\nJolly(jasper) ::: Jasper is jolly.\n((Jolly(burgess))) → ((¬Able(roderick))) ::: It can be concluded that Roderick is not able once knowing that Burgess is jolly.\n(∃x (Able(x) ∧ Jolly(x))) → ((¬Frank(jasper))) ::: If there is someone who is both able and jolly, then Jasper is not frank.\n(∃x (¬Frank(x) ∨ ¬Civil(x))) → ((Able(roderick))) ::: If there is at least one people who is not frank or not civil, then Roderick is able.\n(∃x (Able(x))) → ((¬Frank(george) ∧ ¬Technical(jack))) ::: If there is someone who is able, then George is not frank and Jack is not technical.\n(¬∃x (¬Frank(x))) → ((¬Frank(jack))) ::: If there is nobody who is not, then Jack is not frank.\n(∃x (¬Frank(x) ∨ ¬Precious(x))) → ((¬Able(roderick))) ::: If there is at least one people who is not frank or not precious, then Roderick is not able.\n(∀x (Frank(x))) → (∀x (¬Precious(x) ∧ ¬Civil(x))) ::: If someone is frank, then he is neither precious nor civil.\n((¬Jolly(burgess) ∨ ¬Civil(roderick))) → ((¬Technical(george))) ::: It can be concluded that George is not technical once knowing that Burgess is not jolly or Roderick is not civil.\n(∀x (Precious(x))) ↔ (∀x (¬Frank(x))) ::: If someone is precious, then he is not frank, and vice versa.\n(∀x (¬Precious(x) ∨ Technical(x))) → (∀x (¬Jolly(x))) ::: If someone is he or not precious is technical, then he is not jolly.\n(∀x (¬Civil(x) ∧ ¬Jolly(x))) ↔ (∀x (Able(x))) ::: If someone is not civil and not jolly, then he is able, and vice versa.\n((Able(roderick))) → ((Precious(burgess) ∧ ¬Civil(jack))) ::: Roderick being able implies that Burgess is precious and Jack is not civil.\n",
                "First-Order-Logic Question": "¬Able(myra) ::: Myra is not able."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "¬Able(jasper) ::: Jasper is not able.\n¬Frank(jack) ::: Jack is not frank.\nCivil(jasper) ::: Jasper is civil.\n¬Civil(george) ::: George is not civil.\nFrank(burgess) ::: Burgess is frank.\nJolly(roderick) ::: Roderick is jolly.\n¬Civil(myra) ::: Myra is not civil.\nPrecious(roderick) ::: Roderick is precious.\nJolly(jack) ::: Jack is jolly.\n¬Able(burgess) ::: Burgess is not able.\n¬Jolly(miles) ::: Miles is not jolly.\nJolly(jasper) ::: Jasper is jolly.\n((Jolly(burgess))) → ((¬Able(roderick))) ::: It can be concluded that Roderick is not able once knowing that Burgess is jolly.\n(∃x (Able(x) ∧ Jolly(x))) → ((¬Frank(jasper))) ::: If there is someone who is both able and jolly, then Jasper is not frank.\n(∃x (¬Frank(x) ∨ ¬Civil(x))) → ((Able(roderick))) ::: If there is at least one people who is not frank or not civil, then Roderick is able.\n(∃x (Able(x))) → ((¬Frank(george) ∧ ¬Technical(jack))) ::: If there is someone who is able, then George is not frank and Jack is not technical.\n¬∃x(¬Frank(x))→((¬Frank(x))) ::: If there is nobody who is not, then Jack is not frank.\n(∃x (¬Frank(x) ∨ ¬Precious(x))) → ((¬Able(roderick))) ::: If there is at least one people who is not frank or not precious, then Roderick is not able.\n(∀x (Frank(x))) → (∀x (¬Precious(x) ∧ ¬Civil(x))) ::: If someone is frank, then he is neither precious nor civil.\n((¬Jolly(burgess) ∨ ¬Civil(roderick))) → ((¬Technical(george))) ::: It can be concluded that George is not technical once knowing that Burgess is not jolly or Roderick is not civil.\n(∀x (Precious(x))) ↔ (∀x (¬Frank(x))) ::: If someone is precious, then he is not frank, and vice versa.\n(∀x (¬Precious(x) ∨ Technical(x))) → (∀x (¬Jolly(x))) ::: If someone is he or not precious is technical, then he is not jolly.\n(∀x (¬Civil(x) ∧ ¬Jolly(x))) ↔ (∀x (Able(x))) ::: If someone is not civil and not jolly, then he is able, and vice versa.\n((Able(roderick))) → ((Precious(burgess) ∧ ¬Civil(jack))) ::: Roderick being able implies that Burgess is precious and Jack is not civil.\n",
                "First-Order-Logic Question": "¬Able(myra) ::: Myra is not able."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬Frank(x))) → ((¬Frank(jack))) ::: If there is nobody who is not, then Jack is not frank.",
                    "gram": "¬∃x(¬Frank(x))→((¬Frank(x))) ::: If there is nobody who is not, then Jack is not frank."
                }
            ],
            "answer": "B",
            "grammar_answer": "A",
            "backup_answer": "B"
        },
        {
            "id": 372,
            "raw_prog": {
                "First-Order-Logic Rules": "¬Able(jasper) ::: Jasper is not able.\n¬Frank(jack) ::: Jack is not frank.\nCivil(jasper) ::: Jasper is civil.\n¬Civil(george) ::: George is not civil.\nFrank(burgess) ::: Burgess is frank.\nJolly(roderick) ::: Roderick is jolly.\n¬Civil(myra) ::: Myra is not civil.\nPrecious(roderick) ::: Roderick is precious.\nJolly(jack) ::: Jack is jolly.\n¬Able(burgess) ::: Burgess is not able.\n¬Jolly(miles) ::: Miles is not jolly.\nJolly(jasper) ::: Jasper is jolly.\n((Jolly(burgess))) → ((¬Able(roderick))) ::: It can be concluded that Roderick is not able once knowing that Burgess is jolly.\n(∃x (Able(x) ∧ Jolly(x))) → ((¬Frank(jasper))) ::: If there is someone who is both able and jolly, then Jasper is not frank.\n(∃x (¬Frank(x) ∨ ¬Civil(x))) → ((Able(roderick))) ::: If there is at least one people who is not frank or not civil, then Roderick is able.\n(∃x (Able(x))) → ((¬Frank(george) ∧ ¬Technical(jack))) ::: If there is someone who is able, then George is not frank and Jack is not technical.\n(¬∃x (¬Frank(x))) → ((¬Frank(jack))) ::: If there is nobody who is not, then Jack is not frank.\n(∃x (¬Frank(x) ∨ ¬Precious(x))) → ((¬Able(roderick))) ::: If there is at least one people who is not frank or not precious, then Roderick is not able.\n(∀x (Frank(x))) → (∀x (¬Precious(x) ∧ ¬Civil(x))) ::: If someone is frank, then he is neither precious nor civil.\n((¬Jolly(burgess) ∨ ¬Civil(roderick))) → ((¬Technical(george))) ::: It can be concluded that George is not technical once knowing that Burgess is not jolly or Roderick is not civil.\n(∀x (Precious(x))) ↔ (∀x (¬Frank(x))) ::: If someone is precious, then he is not frank, and vice versa.\n(∀x (¬Precious(x) ∨ Technical(x))) → (∀x (¬Jolly(x))) ::: If someone is he or not precious is technical, then he is not jolly.\n(∀x (¬Civil(x) ∧ ¬Jolly(x))) ↔ (∀x (Able(x))) ::: If someone is not civil and not jolly, then he is able, and vice versa.\n((Able(roderick))) → ((Precious(burgess) ∧ ¬Civil(jack))) ::: Roderick being able implies that Burgess is precious and Jack is not civil.\n",
                "First-Order-Logic Question": "¬Jolly(jack) ::: Jack is not jolly."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "¬Able(jasper) ::: Jasper is not able.\n¬Frank(jack) ::: Jack is not frank.\nCivil(jasper) ::: Jasper is civil.\n¬Civil(george) ::: George is not civil.\nFrank(burgess) ::: Burgess is frank.\nJolly(roderick) ::: Roderick is jolly.\n¬Civil(myra) ::: Myra is not civil.\nPrecious(roderick) ::: Roderick is precious.\nJolly(jack) ::: Jack is jolly.\n¬Able(burgess) ::: Burgess is not able.\n¬Jolly(miles) ::: Miles is not jolly.\nJolly(jasper) ::: Jasper is jolly.\n((Jolly(burgess))) → ((¬Able(roderick))) ::: It can be concluded that Roderick is not able once knowing that Burgess is jolly.\n(∃x (Able(x) ∧ Jolly(x))) → ((¬Frank(jasper))) ::: If there is someone who is both able and jolly, then Jasper is not frank.\n(∃x (¬Frank(x) ∨ ¬Civil(x))) → ((Able(roderick))) ::: If there is at least one people who is not frank or not civil, then Roderick is able.\n(∃x (Able(x))) → ((¬Frank(george) ∧ ¬Technical(jack))) ::: If there is someone who is able, then George is not frank and Jack is not technical.\n¬∃x(¬Frank(x))→((¬Frank(x))) ::: If there is nobody who is not, then Jack is not frank.\n(∃x (¬Frank(x) ∨ ¬Precious(x))) → ((¬Able(roderick))) ::: If there is at least one people who is not frank or not precious, then Roderick is not able.\n(∀x (Frank(x))) → (∀x (¬Precious(x) ∧ ¬Civil(x))) ::: If someone is frank, then he is neither precious nor civil.\n((¬Jolly(burgess) ∨ ¬Civil(roderick))) → ((¬Technical(george))) ::: It can be concluded that George is not technical once knowing that Burgess is not jolly or Roderick is not civil.\n(∀x (Precious(x))) ↔ (∀x (¬Frank(x))) ::: If someone is precious, then he is not frank, and vice versa.\n(∀x (¬Precious(x) ∨ Technical(x))) → (∀x (¬Jolly(x))) ::: If someone is he or not precious is technical, then he is not jolly.\n(∀x (¬Civil(x) ∧ ¬Jolly(x))) ↔ (∀x (Able(x))) ::: If someone is not civil and not jolly, then he is able, and vice versa.\n((Able(roderick))) → ((Precious(burgess) ∧ ¬Civil(jack))) ::: Roderick being able implies that Burgess is precious and Jack is not civil.\n",
                "First-Order-Logic Question": "¬Jolly(jack) ::: Jack is not jolly."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬Frank(x))) → ((¬Frank(jack))) ::: If there is nobody who is not, then Jack is not frank.",
                    "gram": "¬∃x(¬Frank(x))→((¬Frank(x))) ::: If there is nobody who is not, then Jack is not frank."
                }
            ],
            "answer": "C",
            "grammar_answer": "A",
            "backup_answer": "B"
        },
        {
            "id": 373,
            "raw_prog": {
                "First-Order-Logic Rules": "¬Able(jasper) ::: Jasper is not able.\n¬Frank(jack) ::: Jack is not frank.\nCivil(jasper) ::: Jasper is civil.\n¬Civil(george) ::: George is not civil.\nFrank(burgess) ::: Burgess is frank.\nJolly(roderick) ::: Roderick is jolly.\n¬Civil(myra) ::: Myra is not civil.\nPrecious(roderick) ::: Roderick is precious.\nJolly(jack) ::: Jack is jolly.\n¬Able(burgess) ::: Burgess is not able.\n¬Jolly(miles) ::: Miles is not jolly.\nJolly(jasper) ::: Jasper is jolly.\n((Jolly(burgess))) → ((¬Able(roderick))) ::: It can be concluded that Roderick is not able once knowing that Burgess is jolly.\n(∃x (Able(x) ∧ Jolly(x))) → ((¬Frank(jasper))) ::: If there is someone who is both able and jolly, then Jasper is not frank.\n(∃x (¬Frank(x) ∨ ¬Civil(x))) → ((Able(roderick))) ::: If there is at least one people who is not frank or not civil, then Roderick is able.\n(∃x (Able(x))) → ((¬Frank(george) ∧ ¬Technical(jack))) ::: If there is someone who is able, then George is not frank and Jack is not technical.\n(¬∃x (¬x)) → ((¬Frank(jack))) ::: If there is nobody who is not, then Jack is not frank.\n(∃x (¬Frank(x) ∨ ¬Precious(x))) → ((¬Able(roderick))) ::: If there is at least one people who is not frank or not precious, then Roderick is not able.\n(∀x (Frank(x))) → (∀x (¬Precious(x) ∧ ¬Civil(x))) ::: If someone is frank, then he is neither precious nor civil.\n((¬Jolly(burgess) ∨ ¬Civil(roderick))) → ((¬Technical(george))) ::: It can be concluded that George is not technical once knowing that Burgess is not jolly or Roderick is not civil.\n(∀x (Precious(x))) ↔ (∀x (¬Frank(x))) ::: If someone is precious, then he is not frank, and vice versa.\n(∀x (x ∨ ¬Precious(x))) → (∀x (¬Jolly(x))) ::: If someone is he or not precious is technical, then he is not jolly.\n(∀x (¬Civil(x) ∧ ¬Jolly(x))) ↔ (∀x (Able(x))) ::: If someone is not civil and not jolly, then he is able, and vice versa.\n((Able(roderick))) → ((Precious(burgess) ∧ ¬Civil(jack))) ::: Roderick being able implies that Burgess is precious and Jack is not civil.\n",
                "First-Order-Logic Question": "Jolly(george) ::: George is jolly."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "¬Able(jasper) ::: Jasper is not able.\n¬Frank(jack) ::: Jack is not frank.\nCivil(jasper) ::: Jasper is civil.\n¬Civil(george) ::: George is not civil.\nFrank(burgess) ::: Burgess is frank.\nJolly(roderick) ::: Roderick is jolly.\n¬Civil(myra) ::: Myra is not civil.\nPrecious(roderick) ::: Roderick is precious.\nJolly(jack) ::: Jack is jolly.\n¬Able(burgess) ::: Burgess is not able.\n¬Jolly(miles) ::: Miles is not jolly.\nJolly(jasper) ::: Jasper is jolly.\n((Jolly(burgess))) → ((¬Able(roderick))) ::: It can be concluded that Roderick is not able once knowing that Burgess is jolly.\n(∃x (Able(x) ∧ Jolly(x))) → ((¬Frank(jasper))) ::: If there is someone who is both able and jolly, then Jasper is not frank.\n(∃x (¬Frank(x) ∨ ¬Civil(x))) → ((Able(roderick))) ::: If there is at least one people who is not frank or not civil, then Roderick is able.\n(∃x (Able(x))) → ((¬Frank(george) ∧ ¬Technical(jack))) ::: If there is someone who is able, then George is not frank and Jack is not technical.\n¬∃x((¬Frank(x))→(¬Frank(x))) ::: If there is nobody who is not, then Jack is not frank.\n(∃x (¬Frank(x) ∨ ¬Precious(x))) → ((¬Able(roderick))) ::: If there is at least one people who is not frank or not precious, then Roderick is not able.\n(∀x (Frank(x))) → (∀x (¬Precious(x) ∧ ¬Civil(x))) ::: If someone is frank, then he is neither precious nor civil.\n((¬Jolly(burgess) ∨ ¬Civil(roderick))) → ((¬Technical(george))) ::: It can be concluded that George is not technical once knowing that Burgess is not jolly or Roderick is not civil.\n(∀x (Precious(x))) ↔ (∀x (¬Frank(x))) ::: If someone is precious, then he is not frank, and vice versa.\n∀x((Able(x)∨¬Precious(x))) ::: If someone is he or not precious is technical, then he is not jolly.\n(∀x (¬Civil(x) ∧ ¬Jolly(x))) ↔ (∀x (Able(x))) ::: If someone is not civil and not jolly, then he is able, and vice versa.\n((Able(roderick))) → ((Precious(burgess) ∧ ¬Civil(jack))) ::: Roderick being able implies that Burgess is precious and Jack is not civil.\n",
                "First-Order-Logic Question": "Jolly(george) ::: George is jolly."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬x)) → ((¬Frank(jack))) ::: If there is nobody who is not, then Jack is not frank.",
                    "gram": "¬∃x((¬Frank(x))→(¬Frank(x))) ::: If there is nobody who is not, then Jack is not frank."
                },
                {
                    "raw": "(∀x (x ∨ ¬Precious(x))) → (∀x (¬Jolly(x))) ::: If someone is he or not precious is technical, then he is not jolly.",
                    "gram": "∀x((Able(x)∨¬Precious(x))) ::: If someone is he or not precious is technical, then he is not jolly."
                }
            ],
            "answer": "B",
            "grammar_answer": "A",
            "backup_answer": "C"
        },
        {
            "id": 374,
            "raw_prog": {
                "First-Order-Logic Rules": "¬Able(jasper) ::: Jasper is not able.\n¬Frank(jack) ::: Jack is not frank.\nCivil(jasper) ::: Jasper is civil.\n¬Civil(george) ::: George is not civil.\nFrank(burgess) ::: Burgess is frank.\nJolly(roderick) ::: Roderick is jolly.\n¬Civil(myra) ::: Myra is not civil.\nPrecious(roderick) ::: Roderick is precious.\nJolly(jack) ::: Jack is jolly.\n¬Able(burgess) ::: Burgess is not able.\n¬Jolly(miles) ::: Miles is not jolly.\nJolly(jasper) ::: Jasper is jolly.\n((Jolly(burgess))) → ((¬Able(roderick))) ::: It can be concluded that Roderick is not able once knowing that Burgess is jolly.\n(∃x (Able(x) ∧ Jolly(x))) → ((¬Frank(jasper))) ::: If there is someone who is both able and jolly, then Jasper is not frank.\n(∃x (¬Frank(x) ∨ ¬Civil(x))) → ((Able(roderick))) ::: If there is at least one people who is not frank or not civil, then Roderick is able.\n(∃x (Able(x))) → ((¬Frank(george) ∧ ¬Technical(jack))) ::: If there is someone who is able, then George is not frank and Jack is not technical.\n(¬∃x (¬x)) → ((¬Frank(jack))) ::: If there is nobody who is not, then Jack is not frank.\n(∃x (¬Frank(x) ∨ ¬Precious(x))) → ((¬Able(roderick))) ::: If there is at least one people who is not frank or not precious, then Roderick is not able.\n(∀x (Frank(x))) → (∀x (¬Precious(x) ∧ ¬Civil(x))) ::: If someone is frank, then he is neither precious nor civil.\n((¬Jolly(burgess) ∨ ¬Civil(roderick))) → ((¬Technical(george))) ::: It can be concluded that George is not technical once knowing that Burgess is not jolly or Roderick is not civil.\n(∀x (Precious(x))) → (∀x (¬Frank(x))) ∧ (∀x (¬Frank(x))) → (∀x (¬Precious(x))) ::: If someone is precious, then he is not frank, and vice versa.\n(∀x (¬Civil(x) ∧ ¬Jolly(x))) ↔ (∀x (Able(x))) ::: If someone is not civil and not jolly, then he is able, and vice versa.\n((Able(roderick))) → ((Precious(burgess) ∧ ¬Civil(jack))) ::: Roderick being able implies that Burgess is precious and Jack is not civil.\n",
                "First-Order-Logic Question": "¬Civil(jasper) ::: Jasper is not civil."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "¬Able(jasper) ::: Jasper is not able.\n¬Frank(jack) ::: Jack is not frank.\nCivil(jasper) ::: Jasper is civil.\n¬Civil(george) ::: George is not civil.\nFrank(burgess) ::: Burgess is frank.\nJolly(roderick) ::: Roderick is jolly.\n¬Civil(myra) ::: Myra is not civil.\nPrecious(roderick) ::: Roderick is precious.\nJolly(jack) ::: Jack is jolly.\n¬Able(burgess) ::: Burgess is not able.\n¬Jolly(miles) ::: Miles is not jolly.\nJolly(jasper) ::: Jasper is jolly.\n((Jolly(burgess))) → ((¬Able(roderick))) ::: It can be concluded that Roderick is not able once knowing that Burgess is jolly.\n(∃x (Able(x) ∧ Jolly(x))) → ((¬Frank(jasper))) ::: If there is someone who is both able and jolly, then Jasper is not frank.\n(∃x (¬Frank(x) ∨ ¬Civil(x))) → ((Able(roderick))) ::: If there is at least one people who is not frank or not civil, then Roderick is able.\n(∃x (Able(x))) → ((¬Frank(george) ∧ ¬Technical(jack))) ::: If there is someone who is able, then George is not frank and Jack is not technical.\n¬∃x((¬Frank(x))→(¬Frank(x))) ::: If there is nobody who is not, then Jack is not frank.\n(∃x (¬Frank(x) ∨ ¬Precious(x))) → ((¬Able(roderick))) ::: If there is at least one people who is not frank or not precious, then Roderick is not able.\n(∀x (Frank(x))) → (∀x (¬Precious(x) ∧ ¬Civil(x))) ::: If someone is frank, then he is neither precious nor civil.\n((¬Jolly(burgess) ∨ ¬Civil(roderick))) → ((¬Technical(george))) ::: It can be concluded that George is not technical once knowing that Burgess is not jolly or Roderick is not civil.\n(∀x (Precious(x))) → (∀x (¬Frank(x))) ∧ (∀x (¬Frank(x))) → (∀x (¬Precious(x))) ::: If someone is precious, then he is not frank, and vice versa.\n(∀x (¬Civil(x) ∧ ¬Jolly(x))) ↔ (∀x (Able(x))) ::: If someone is not civil and not jolly, then he is able, and vice versa.\n((Able(roderick))) → ((Precious(burgess) ∧ ¬Civil(jack))) ::: Roderick being able implies that Burgess is precious and Jack is not civil.\n",
                "First-Order-Logic Question": "¬Civil(jasper) ::: Jasper is not civil."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬x)) → ((¬Frank(jack))) ::: If there is nobody who is not, then Jack is not frank.",
                    "gram": "¬∃x((¬Frank(x))→(¬Frank(x))) ::: If there is nobody who is not, then Jack is not frank."
                }
            ],
            "answer": "C",
            "grammar_answer": "A",
            "backup_answer": "B"
        },
        {
            "id": 424,
            "raw_prog": {
                "First-Order-Logic Rules": "Poor(jack) ::: Jack is poor.\n¬Fearless(lesley) ::: Lesley is not fearless.\nWonderful(lamont) ::: Lamont is wonderful.\n¬Poor(lamont) ::: Lamont is not poor.\n¬Combative(lesley) ::: Lesley is not combative.\n¬Bewildered(iver) ::: Iver is not bewildered.\n¬Fearless(blaine) ::: Blaine is not fearless.\nStubborn(lancelot) ::: Lancelot is stubborn.\nStubborn(lamont) ::: Lamont is stubborn.\n¬Bewildered(lancelot) ::: Lancelot is not bewildered.\nWonderful(lancelot) ::: Lancelot is wonderful.\nPoor(lancelot) ::: Lancelot is poor.\n(∀x (Wonderful(x) ∨ Combative(x))) → (∀x (¬Poor(x))) ::: If someone is he or not wonderful is combative, then he is not poor.\n(∀x (Poor(x) ∧ Stubborn(x))) → (∀x (Fearless(x))) ::: If someone who is poor is also stubborn, then he is fearless.\n(∃x (Combative(x) ∧ ¬Poor(x))) → ((Bewildered(jack))) ::: If there is someone who is both combative and not poor, then Jack is bewildered.\n(∀x (¬Fearless(x) ∧ ¬Combative(x))) ↔ (∀x (Bewildered(x))) ::: If someone is not fearless and not combative, then he is bewildered, and vice versa.\n(¬Stubborn(lancelot)) ↔ (¬Poor(jack)) ::: Lancelot is not stubborn if and only if Jack is not poor.\n(Fearless(olive)) → ((Bewildered(lamont) ∧ Combative(lancelot))) ::: Olive being fearless implies that Lamont is bewildered and Lancelot is combative.\n(∀x (¬Bewildered(x))) → (∀x (Poor(x) ∧ ¬Stubborn(x))) ::: If someone is not bewildered, then he is both poor and not stubborn.\n(∀x (Stubborn(x))) → (∀x (¬Bewildered(x))) ::: If someone is stubborn, then he is not bewildered.\n((Poor(jack) ∧ ¬Fearless(lamont))) → ((Stubborn(blaine))) ::: It can be concluded that Blaine is stubborn once knowing that Jack is poor and Lamont is not fearless.\n(∃x (¬Fearless(x))) → ((¬Bewildered(iver))) ::: If there is someone who is not fearless, then Iver is not bewildered.\n(∃x (¬Fearless(x) ∨ ¬Stubborn(x))) → ((¬Wonderful(jack))) ::: If there is someone who is either not fearless or not stubborn, then Jack is not wonderful.\n(Bewildered(olive)) ↔ (Stubborn(blaine)) ::: Olive being bewildered is equivalent to Blaine being stubborn.\n",
                "First-Order-Logic Question": "Poor(lancelot) ::: Lancelot is poor."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "Poor(jack) ::: Jack is poor.\n¬Fearless(lesley) ::: Lesley is not fearless.\nWonderful(lamont) ::: Lamont is wonderful.\n¬Poor(lamont) ::: Lamont is not poor.\n¬Combative(lesley) ::: Lesley is not combative.\n¬Bewildered(iver) ::: Iver is not bewildered.\n¬Fearless(blaine) ::: Blaine is not fearless.\nStubborn(lancelot) ::: Lancelot is stubborn.\nStubborn(lamont) ::: Lamont is stubborn.\n¬Bewildered(lancelot) ::: Lancelot is not bewildered.\nWonderful(lancelot) ::: Lancelot is wonderful.\nPoor(lancelot) ::: Lancelot is poor.\n(∀x (Wonderful(x) ∨ Combative(x))) → (∀x (¬Poor(x))) ::: If someone is he or not wonderful is combative, then he is not poor.\n(∀x (Poor(x) ∧ Stubborn(x))) → (∀x (Fearless(x))) ::: If someone who is poor is also stubborn, then he is fearless.\n(∃x (Combative(x) ∧ ¬Poor(x))) → ((Bewildered(jack))) ::: If there is someone who is both combative and not poor, then Jack is bewildered.\n(∀x (¬Fearless(x) ∧ ¬Combative(x))) ↔ (∀x (Bewildered(x))) ::: If someone is not fearless and not combative, then he is bewildered, and vice versa.\n(¬Stubborn(lancelot)) ↔ (¬Poor(jack)) ::: Lancelot is not stubborn if and only if Jack is not poor.\n(Fearless(olive)) → ((Bewildered(lamont) ∧ Combative(lancelot))) ::: Olive being fearless implies that Lamont is bewildered and Lancelot is combative.\n(∀x (¬Bewildered(x))) → (∀x (Poor(x) ∧ ¬Stubborn(x))) ::: If someone is not bewildered, then he is both poor and not stubborn.\n(∀x (Stubborn(x))) → (∀x (¬Bewildered(x))) ::: If someone is stubborn, then he is not bewildered.\n((Poor(jack) ∧ ¬Fearless(lamont))) → ((Stubborn(blaine))) ::: It can be concluded that Blaine is stubborn once knowing that Jack is poor and Lamont is not fearless.\n(∃x (¬Fearless(x))) → ((¬Bewildered(iver))) ::: If there is someone who is not fearless, then Iver is not bewildered.\n(∃x (¬Fearless(x) ∨ ¬Stubborn(x))) → ((¬Wonderful(jack))) ::: If there is someone who is either not fearless or not stubborn, then Jack is not wonderful.\n(Bewildered(olive)) ↔ (Stubborn(blaine)) ::: Olive being bewildered is equivalent to Blaine being stubborn.\n",
                "First-Order-Logic Question": "Poor(lancelot) ::: Lancelot is poor."
            },
            "diff": [],
            "answer": "C",
            "grammar_answer": "C",
            "backup_answer": "A"
        },
        {
            "id": 428,
            "raw_prog": {
                "First-Order-Logic Rules": "Poor(jack) ::: Jack is poor.\n¬Fearless(lesley) ::: Lesley is not fearless.\nWonderful(lamont) ::: Lamont is wonderful.\n¬Poor(lamont) ::: Lamont is not poor.\n¬Combative(lesley) ::: Lesley is not combative.\n¬Bewildered(iver) ::: Iver is not bewildered.\n¬Fearless(blaine) ::: Blaine is not fearless.\nStubborn(lancelot) ::: Lancelot is stubborn.\nStubborn(lamont) ::: Lamont is stubborn.\n¬Bewildered(lancelot) ::: Lancelot is not bewildered.\nWonderful(lancelot) ::: Lancelot is wonderful.\nPoor(lancelot) ::: Lancelot is poor.\n(∀x (Wonderful(x) ∨ Combative(x))) → (∀x (¬Poor(x))) ::: If someone is he or not wonderful is combative, then he is not poor.\n(∀x (Poor(x) ∧ Stubborn(x))) → (∀x (Fearless(x))) ::: If someone who is poor is also stubborn, then he is fearless.\n(∃x (Combative(x) ∧ ¬Poor(x))) → ((Bewildered(jack))) ::: If there is someone who is both combative and not poor, then Jack is bewildered.\n(∀x (¬Fearless(x) ∧ ¬Combative(x))) ↔ (∀x (Bewildered(x))) ::: If someone is not fearless and not combative, then he is bewildered, and vice versa.\n(¬Stubborn(lancelot)) ↔ (¬Poor(jack)) ::: Lancelot is not stubborn if and only if Jack is not poor.\n((Fearless(olive))) → ((Bewildered(lamont) ∧ Combative(lancelot))) ::: Olive being fearless implies that Lamont is bewildered and Lancelot is combative.\n(∀x (¬Bewildered(x))) → (∀x (Poor(x) ∧ ¬Stubborn(x))) ::: If someone is not bewildered, then he is both poor and not stubborn.\n(∀x (Stubborn(x))) → (∀x (¬Bewildered(x))) ::: If someone is stubborn, then he is not bewildered.\n((Poor(jack) ∧ ¬Fearless(lamont))) → ((Stubborn(blaine))) ::: It can be concluded that Blaine is stubborn once knowing that Jack is poor and Lamont is not fearless.\n(∃x (¬Fearless(x))) → ((¬Bewildered(iver))) ::: If there is someone who is not fearless, then Iver is not bewildered.\n(∃x (¬Fearless(x) ∨ ¬Stubborn(x))) → ((¬Wonderful(jack))) ::: If there is someone who is either not fearless or not stubborn, then Jack is not wonderful.\n(Bewildered(olive)) ↔ (Stubborn(blaine)) ::: Olive being bewildered is equivalent to Blaine being stubborn.\n",
                "First-Order-Logic Question": "Wonderful(lamont) ::: Lamont is wonderful."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "Poor(jack) ::: Jack is poor.\n¬Fearless(lesley) ::: Lesley is not fearless.\nWonderful(lamont) ::: Lamont is wonderful.\n¬Poor(lamont) ::: Lamont is not poor.\n¬Combative(lesley) ::: Lesley is not combative.\n¬Bewildered(iver) ::: Iver is not bewildered.\n¬Fearless(blaine) ::: Blaine is not fearless.\nStubborn(lancelot) ::: Lancelot is stubborn.\nStubborn(lamont) ::: Lamont is stubborn.\n¬Bewildered(lancelot) ::: Lancelot is not bewildered.\nWonderful(lancelot) ::: Lancelot is wonderful.\nPoor(lancelot) ::: Lancelot is poor.\n(∀x (Wonderful(x) ∨ Combative(x))) → (∀x (¬Poor(x))) ::: If someone is he or not wonderful is combative, then he is not poor.\n(∀x (Poor(x) ∧ Stubborn(x))) → (∀x (Fearless(x))) ::: If someone who is poor is also stubborn, then he is fearless.\n(∃x (Combative(x) ∧ ¬Poor(x))) → ((Bewildered(jack))) ::: If there is someone who is both combative and not poor, then Jack is bewildered.\n(∀x (¬Fearless(x) ∧ ¬Combative(x))) ↔ (∀x (Bewildered(x))) ::: If someone is not fearless and not combative, then he is bewildered, and vice versa.\n(¬Stubborn(lancelot)) ↔ (¬Poor(jack)) ::: Lancelot is not stubborn if and only if Jack is not poor.\n((Fearless(olive))) → ((Bewildered(lamont) ∧ Combative(lancelot))) ::: Olive being fearless implies that Lamont is bewildered and Lancelot is combative.\n(∀x (¬Bewildered(x))) → (∀x (Poor(x) ∧ ¬Stubborn(x))) ::: If someone is not bewildered, then he is both poor and not stubborn.\n(∀x (Stubborn(x))) → (∀x (¬Bewildered(x))) ::: If someone is stubborn, then he is not bewildered.\n((Poor(jack) ∧ ¬Fearless(lamont))) → ((Stubborn(blaine))) ::: It can be concluded that Blaine is stubborn once knowing that Jack is poor and Lamont is not fearless.\n(∃x (¬Fearless(x))) → ((¬Bewildered(iver))) ::: If there is someone who is not fearless, then Iver is not bewildered.\n(∃x (¬Fearless(x) ∨ ¬Stubborn(x))) → ((¬Wonderful(jack))) ::: If there is someone who is either not fearless or not stubborn, then Jack is not wonderful.\n(Bewildered(olive)) ↔ (Stubborn(blaine)) ::: Olive being bewildered is equivalent to Blaine being stubborn.\n",
                "First-Order-Logic Question": "Wonderful(lamont) ::: Lamont is wonderful."
            },
            "diff": [],
            "answer": "A",
            "grammar_answer": "A",
            "backup_answer": "A"
        },
        {
            "id": 429,
            "raw_prog": {
                "First-Order-Logic Rules": "Poor(jack) ::: Jack is poor.\n¬Fearless(lesley) ::: Lesley is not fearless.\nWonderful(lamont) ::: Lamont is wonderful.\n¬Poor(lamont) ::: Lamont is not poor.\n¬Combative(lesley) ::: Lesley is not combative.\n¬Bewildered(iver) ::: Iver is not bewildered.\n¬Fearless(blaine) ::: Blaine is not fearless.\nStubborn(lancelot) ::: Lancelot is stubborn.\nStubborn(lamont) ::: Lamont is stubborn.\n¬Bewildered(lancelot) ::: Lancelot is not bewildered.\nWonderful(lancelot) ::: Lancelot is wonderful.\nPoor(lancelot) ::: Lancelot is poor.\n(∀x (Wonderful(x) ∨ Combative(x))) → (∀x (¬Poor(x))) ::: If someone is he or not wonderful is combative, then he is not poor.\n(∀x (Poor(x) ∧ Stubborn(x))) → (∀x (Fearless(x))) ::: If someone who is poor is also stubborn, then he is fearless.\n(∃x (Combative(x) ∧ ¬Poor(x))) → ((Bewildered(jack))) ::: If there is someone who is both combative and not poor, then Jack is bewildered.\n(∀x (¬Fearless(x) ∧ ¬Combative(x))) ↔ (∀x (Bewildered(x))) ::: If someone is not fearless and not combative, then he is bewildered, and vice versa.\n(¬Stubborn(lancelot)) ↔ (¬Poor(jack)) ::: Lancelot is not stubborn if and only if Jack is not poor.\n((Fearless(olive))) → ((Bewildered(lamont) ∧ Combative(lancelot))) ::: Olive being fearless implies that Lamont is bewildered and Lancelot is combative.\n(∀x (¬Bewildered(x))) → (∀x (Poor(x) ∧ ¬Stubborn(x))) ::: If someone is not bewildered, then he is both poor and not stubborn.\n(∀x (Stubborn(x))) → (∀x (¬Bewildered(x))) ::: If someone is stubborn, then he is not bewildered.\n((Poor(jack) ∧ ¬Fearless(lamont))) → ((Stubborn(blaine))) ::: It can be concluded that Blaine is stubborn once knowing that Jack is poor and Lamont is not fearless.\n(∃x (¬Fearless(x))) → ((¬Bewildered(iver))) ::: If there is someone who is not fearless, then Iver is not bewildered.\n(∃x (¬Fearless(x) ∨ ¬Stubborn(x))) → ((¬Wonderful(jack))) ::: If there is someone who is either not fearless or not stubborn, then Jack is not wonderful.\n(Bewildered(olive)) ↔ (Stubborn(blaine)) ::: Olive being bewildered is equivalent to Blaine being stubborn.\n",
                "First-Order-Logic Question": "¬Wonderful(jack) ::: Jack is not wonderful."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "Poor(jack) ::: Jack is poor.\n¬Fearless(lesley) ::: Lesley is not fearless.\nWonderful(lamont) ::: Lamont is wonderful.\n¬Poor(lamont) ::: Lamont is not poor.\n¬Combative(lesley) ::: Lesley is not combative.\n¬Bewildered(iver) ::: Iver is not bewildered.\n¬Fearless(blaine) ::: Blaine is not fearless.\nStubborn(lancelot) ::: Lancelot is stubborn.\nStubborn(lamont) ::: Lamont is stubborn.\n¬Bewildered(lancelot) ::: Lancelot is not bewildered.\nWonderful(lancelot) ::: Lancelot is wonderful.\nPoor(lancelot) ::: Lancelot is poor.\n(∀x (Wonderful(x) ∨ Combative(x))) → (∀x (¬Poor(x))) ::: If someone is he or not wonderful is combative, then he is not poor.\n(∀x (Poor(x) ∧ Stubborn(x))) → (∀x (Fearless(x))) ::: If someone who is poor is also stubborn, then he is fearless.\n(∃x (Combative(x) ∧ ¬Poor(x))) → ((Bewildered(jack))) ::: If there is someone who is both combative and not poor, then Jack is bewildered.\n(∀x (¬Fearless(x) ∧ ¬Combative(x))) ↔ (∀x (Bewildered(x))) ::: If someone is not fearless and not combative, then he is bewildered, and vice versa.\n(¬Stubborn(lancelot)) ↔ (¬Poor(jack)) ::: Lancelot is not stubborn if and only if Jack is not poor.\n((Fearless(olive))) → ((Bewildered(lamont) ∧ Combative(lancelot))) ::: Olive being fearless implies that Lamont is bewildered and Lancelot is combative.\n(∀x (¬Bewildered(x))) → (∀x (Poor(x) ∧ ¬Stubborn(x))) ::: If someone is not bewildered, then he is both poor and not stubborn.\n(∀x (Stubborn(x))) → (∀x (¬Bewildered(x))) ::: If someone is stubborn, then he is not bewildered.\n((Poor(jack) ∧ ¬Fearless(lamont))) → ((Stubborn(blaine))) ::: It can be concluded that Blaine is stubborn once knowing that Jack is poor and Lamont is not fearless.\n(∃x (¬Fearless(x))) → ((¬Bewildered(iver))) ::: If there is someone who is not fearless, then Iver is not bewildered.\n(∃x (¬Fearless(x) ∨ ¬Stubborn(x))) → ((¬Wonderful(jack))) ::: If there is someone who is either not fearless or not stubborn, then Jack is not wonderful.\n(Bewildered(olive)) ↔ (Stubborn(blaine)) ::: Olive being bewildered is equivalent to Blaine being stubborn.\n",
                "First-Order-Logic Question": "¬Wonderful(jack) ::: Jack is not wonderful."
            },
            "diff": [],
            "answer": "C",
            "grammar_answer": "C",
            "backup_answer": "A"
        },
        {
            "id": 431,
            "raw_prog": {
                "First-Order-Logic Rules": "Poor(jack) ::: Jack is poor.\n¬Fearless(lesley) ::: Lesley is not fearless.\nWonderful(lamont) ::: Lamont is wonderful.\n¬Poor(lamont) ::: Lamont is not poor.\n¬Combative(lesley) ::: Lesley is not combative.\n¬Bewildered(iver) ::: Iver is not bewildered.\n¬Fearless(blaine) ::: Blaine is not fearless.\nStubborn(lancelot) ::: Lancelot is stubborn.\nStubborn(lamont) ::: Lamont is stubborn.\n¬Bewildered(lancelot) ::: Lancelot is not bewildered.\nWonderful(lancelot) ::: Lancelot is wonderful.\nPoor(lancelot) ::: Lancelot is poor.\n(∀x (x ∨ ¬Wonderful(x) ∧ Combative(x))) → (∀x (¬Poor(x))) ::: If someone is he or not wonderful is combative, then he is not poor.\n(∀x (Poor(x) ∧ Stubborn(x))) → (∀x (Fearless(x))) ::: If someone who is poor is also stubborn, then he is fearless.\n(∃x (Combative(x) ∧ ¬Poor(x))) → ((Bewildered(jack))) ::: If there is someone who is both combative and not poor, then Jack is bewildered.\n(∀x (¬Fearless(x) ∧ ¬Combative(x))) ↔ (∀x (Bewildered(x))) ::: If someone is not fearless and not combative, then he is bewildered, and vice versa.\n(¬Stubborn(lancelot)) ↔ (¬Poor(jack)) ::: Lancelot is not stubborn if and only if Jack is not poor.\n((Fearless(olive))) → ((Bewildered(lamont) ∧ Combative(lancelot))) ::: Olive being fearless implies that Lamont is bewildered and Lancelot is combative.\n(∀x (¬Bewildered(x))) → (∀x (Poor(x) ∧ ¬Stubborn(x))) ::: If someone is not bewildered, then he is both poor and not stubborn.\n(∀x (Stubborn(x))) → (∀x (¬Bewildered(x))) ::: If someone is stubborn, then he is not bewildered.\n((Poor(jack) ∧ ¬Fearless(lamont))) → ((Stubborn(blaine))) ::: It can be concluded that Blaine is stubborn once knowing that Jack is poor and Lamont is not fearless.\n(∃x (¬Fearless(x))) → ((¬Bewildered(iver))) ::: If there is someone who is not fearless, then Iver is not bewildered.\n(∃x (¬Fearless(x) ∨ ¬Stubborn(x))) → ((¬Wonderful(jack))) ::: If there is someone who is either not fearless or not stubborn, then Jack is not wonderful.\n(Bewildered(olive)) ↔ (Stubborn(blaine)) ::: Olive being bewildered is equivalent to Blaine being stubborn.\n",
                "First-Order-Logic Question": "Combative(lesley) ::: Lesley is combative."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "Poor(jack) ::: Jack is poor.\n¬Fearless(lesley) ::: Lesley is not fearless.\nWonderful(lamont) ::: Lamont is wonderful.\n¬Poor(lamont) ::: Lamont is not poor.\n¬Combative(lesley) ::: Lesley is not combative.\n¬Bewildered(iver) ::: Iver is not bewildered.\n¬Fearless(blaine) ::: Blaine is not fearless.\nStubborn(lancelot) ::: Lancelot is stubborn.\nStubborn(lamont) ::: Lamont is stubborn.\n¬Bewildered(lancelot) ::: Lancelot is not bewildered.\nWonderful(lancelot) ::: Lancelot is wonderful.\nPoor(lancelot) ::: Lancelot is poor.\n∀x((Wonderful(x)∨¬Poor(x))) ::: If someone is he or not wonderful is combative, then he is not poor.\n(∀x (Poor(x) ∧ Stubborn(x))) → (∀x (Fearless(x))) ::: If someone who is poor is also stubborn, then he is fearless.\n(∃x (Combative(x) ∧ ¬Poor(x))) → ((Bewildered(jack))) ::: If there is someone who is both combative and not poor, then Jack is bewildered.\n(∀x (¬Fearless(x) ∧ ¬Combative(x))) ↔ (∀x (Bewildered(x))) ::: If someone is not fearless and not combative, then he is bewildered, and vice versa.\n(¬Stubborn(lancelot)) ↔ (¬Poor(jack)) ::: Lancelot is not stubborn if and only if Jack is not poor.\n((Fearless(olive))) → ((Bewildered(lamont) ∧ Combative(lancelot))) ::: Olive being fearless implies that Lamont is bewildered and Lancelot is combative.\n(∀x (¬Bewildered(x))) → (∀x (Poor(x) ∧ ¬Stubborn(x))) ::: If someone is not bewildered, then he is both poor and not stubborn.\n(∀x (Stubborn(x))) → (∀x (¬Bewildered(x))) ::: If someone is stubborn, then he is not bewildered.\n((Poor(jack) ∧ ¬Fearless(lamont))) → ((Stubborn(blaine))) ::: It can be concluded that Blaine is stubborn once knowing that Jack is poor and Lamont is not fearless.\n(∃x (¬Fearless(x))) → ((¬Bewildered(iver))) ::: If there is someone who is not fearless, then Iver is not bewildered.\n(∃x (¬Fearless(x) ∨ ¬Stubborn(x))) → ((¬Wonderful(jack))) ::: If there is someone who is either not fearless or not stubborn, then Jack is not wonderful.\n(Bewildered(olive)) ↔ (Stubborn(blaine)) ::: Olive being bewildered is equivalent to Blaine being stubborn.\n",
                "First-Order-Logic Question": "Combative(lesley) ::: Lesley is combative."
            },
            "diff": [
                {
                    "raw": "(∀x (x ∨ ¬Wonderful(x) ∧ Combative(x))) → (∀x (¬Poor(x))) ::: If someone is he or not wonderful is combative, then he is not poor.",
                    "gram": "∀x((Wonderful(x)∨¬Poor(x))) ::: If someone is he or not wonderful is combative, then he is not poor."
                }
            ],
            "answer": "A",
            "grammar_answer": "A",
            "backup_answer": "B"
        },
        {
            "id": 555,
            "raw_prog": {
                "First-Order-Logic Rules": "Aggressive(montague) ::: Montague is aggressive.\nImpossible(ansel) ::: Ansel is impossible.\n¬Wicked(cyril) ::: Cyril is not wicked.\n¬Wicked(ansel) ::: Ansel is not wicked.\nDrab(katelynn) ::: Katelynn is drab.\n¬Drab(montague) ::: Montague is not drab.\n¬Mushy(ansel) ::: Ansel is not mushy.\n¬Wicked(joseph) ::: Joseph is not wicked.\nBroadMinded(joseph) ::: Joseph is broad-minded.\nDrab(olive) ::: Olive is drab.\n¬Drab(ansel) ::: Ansel is not drab.\n¬Wicked(montague) ::: Montague is not wicked.\n((Mushy(montague) ∧ ¬Wicked(katelynn))) → (¬Aggressive(ansel)) ::: Montague being mushy and Katelynn being not wicked imply that Ansel is not aggressive.\n(BroadMinded(joseph)) ↔ (¬Impossible(joseph)) ::: Joseph is broad-minded if and only if Joseph is not impossible.\n(∃x (¬Mushy(x))) → ((¬Aggressive(whitney) ∧ Impossible(cyril))) ::: If there is at least one people who is not mushy, then Whitney is not aggressive and Cyril is impossible.\n(∃x (BroadMinded(x) ∨ Impossible(x))) → ((Aggressive(olive))) ::: If there is someone who is either broad-minded or impossible, then Olive is aggressive.\n(¬∃x (¬x)) → ((¬BroadMinded(cyril) ∧ Aggressive(ansel))) ::: If there is nobody who is not, then Cyril is not broad-minded and Ansel is aggressive.\n((Wicked(olive) ∧ Drab(katelynn))) ↔ ((Aggressive(joseph) ∧ ¬BroadMinded(montague))) ::: Olive is wicked and Katelynn is drab if and only if Joseph is aggressive and Montague is not broad-minded.\n(∃x (Mushy(x))) → ((BroadMinded(katelynn) ∧ ¬Aggressive(joseph))) ::: If there is at least one people who is mushy, then Katelynn is broad-minded and Joseph is not aggressive.\n((Wicked(olive) ∨ BroadMinded(cyril))) → ((Aggressive(katelynn))) ::: Olive being wicked or Cyril being broad-minded implies that Katelynn is aggressive.\n(∃x (Wicked(x) ∧ ¬Mushy(x))) → ((¬Drab(montague))) ::: If there is someone who is both wicked and not mushy, then Montague is not drab.\n(¬Impossible(whitney)) → ((¬Mushy(cyril) ∧ BroadMinded(joseph))) ::: Whitney being not impossible implies that Cyril is not mushy and Joseph is broad-minded.\n(∀x (¬Aggressive(x))) ↔ (∀x (¬Impossible(x))) ::: Someone is not aggressive if and only if he is not impossible.\n(∀x (Aggressive(x) ∧ ¬Drab(x))) ↔ (∀x (¬Impossible(x))) ::: Someone is aggressive and not drab if and only if he is not impossible.\n",
                "First-Order-Logic Question": "¬Mushy(joseph) ::: Joseph is not mushy."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "Aggressive(montague) ::: Montague is aggressive.\nImpossible(ansel) ::: Ansel is impossible.\n¬Wicked(cyril) ::: Cyril is not wicked.\n¬Wicked(ansel) ::: Ansel is not wicked.\nDrab(katelynn) ::: Katelynn is drab.\n¬Drab(montague) ::: Montague is not drab.\n¬Mushy(ansel) ::: Ansel is not mushy.\n¬Wicked(joseph) ::: Joseph is not wicked.\nBroadMinded(joseph) ::: Joseph is broad-minded.\nDrab(olive) ::: Olive is drab.\n¬Drab(ansel) ::: Ansel is not drab.\n¬Wicked(montague) ::: Montague is not wicked.\n((Mushy(montague) ∧ ¬Wicked(katelynn))) → (¬Aggressive(ansel)) ::: Montague being mushy and Katelynn being not wicked imply that Ansel is not aggressive.\n(BroadMinded(joseph)) ↔ (¬Impossible(joseph)) ::: Joseph is broad-minded if and only if Joseph is not impossible.\n(∃x (¬Mushy(x))) → ((¬Aggressive(whitney) ∧ Impossible(cyril))) ::: If there is at least one people who is not mushy, then Whitney is not aggressive and Cyril is impossible.\n(∃x (BroadMinded(x) ∨ Impossible(x))) → ((Aggressive(olive))) ::: If there is someone who is either broad-minded or impossible, then Olive is aggressive.\n¬∃x(¬(¬(BroadMinded(x)))) ::: If there is nobody who is not, then Cyril is not broad-minded and Ansel is aggressive.\n((Wicked(olive) ∧ Drab(katelynn))) ↔ ((Aggressive(joseph) ∧ ¬BroadMinded(montague))) ::: Olive is wicked and Katelynn is drab if and only if Joseph is aggressive and Montague is not broad-minded.\n(∃x (Mushy(x))) → ((BroadMinded(katelynn) ∧ ¬Aggressive(joseph))) ::: If there is at least one people who is mushy, then Katelynn is broad-minded and Joseph is not aggressive.\n((Wicked(olive) ∨ BroadMinded(cyril))) → ((Aggressive(katelynn))) ::: Olive being wicked or Cyril being broad-minded implies that Katelynn is aggressive.\n(∃x (Wicked(x) ∧ ¬Mushy(x))) → ((¬Drab(montague))) ::: If there is someone who is both wicked and not mushy, then Montague is not drab.\n(¬Impossible(whitney)) → ((¬Mushy(cyril) ∧ BroadMinded(joseph))) ::: Whitney being not impossible implies that Cyril is not mushy and Joseph is broad-minded.\n(∀x (¬Aggressive(x))) ↔ (∀x (¬Impossible(x))) ::: Someone is not aggressive if and only if he is not impossible.\n(∀x (Aggressive(x) ∧ ¬Drab(x))) ↔ (∀x (¬Impossible(x))) ::: Someone is aggressive and not drab if and only if he is not impossible.\n",
                "First-Order-Logic Question": "¬Mushy(joseph) ::: Joseph is not mushy."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬x)) → ((¬BroadMinded(cyril) ∧ Aggressive(ansel))) ::: If there is nobody who is not, then Cyril is not broad-minded and Ansel is aggressive.",
                    "gram": "¬∃x(¬(¬(BroadMinded(x)))) ::: If there is nobody who is not, then Cyril is not broad-minded and Ansel is aggressive."
                }
            ],
            "answer": "C",
            "grammar_answer": "C",
            "backup_answer": "C"
        },
        {
            "id": 556,
            "raw_prog": {
                "First-Order-Logic Rules": "Aggressive(montague) ::: Montague is aggressive.\nImpossible(ansel) ::: Ansel is impossible.\n¬Wicked(cyril) ::: Cyril is not wicked.\n¬Wicked(ansel) ::: Ansel is not wicked.\nDrab(katelynn) ::: Katelynn is drab.\n¬Drab(montague) ::: Montague is not drab.\n¬Mushy(ansel) ::: Ansel is not mushy.\n¬Wicked(joseph) ::: Joseph is not wicked.\nBroadMinded(joseph) ::: Joseph is broad-minded.\nDrab(olive) ::: Olive is drab.\n¬Drab(ansel) ::: Ansel is not drab.\n¬Wicked(montague) ::: Montague is not wicked.\n((Mushy(montague) ∧ ¬Wicked(katelynn))) → (¬Aggressive(ansel)) ::: Montague being mushy and Katelynn being not wicked imply that Ansel is not aggressive.\n(BroadMinded(joseph)) ↔ (¬Impossible(joseph)) ::: Joseph is broad-minded if and only if Joseph is not impossible.\n(∃x (¬Mushy(x))) → ((¬Aggressive(whitney) ∧ Impossible(cyril))) ::: If there is at least one people who is not mushy, then Whitney is not aggressive and Cyril is impossible.\n(∃x (BroadMinded(x) ∨ Impossible(x))) → (Aggressive(olive)) ::: If there is someone who is either broad-minded or impossible, then Olive is aggressive.\n(¬∃x (¬x)) → ((¬BroadMinded(cyril) ∧ Aggressive(ansel))) ::: If there is nobody who is not, then Cyril is not broad-minded and Ansel is aggressive.\n((Wicked(olive) ∧ Drab(katelynn))) ↔ ((Aggressive(joseph) ∧ ¬BroadMinded(montague))) ::: Olive is wicked and Katelynn is drab if and only if Joseph is aggressive and Montague is not broad-minded.\n(∃x (Mushy(x))) → ((BroadMinded(katelynn) ∧ ¬Aggressive(joseph))) ::: If there is at least one people who is mushy, then Katelynn is broad-minded and Joseph is not aggressive.\n((Wicked(olive) ∨ BroadMinded(cyril))) → (Aggressive(katelynn)) ::: Olive being wicked or Cyril being broad-minded implies that Katelynn is aggressive.\n(∃x (Wicked(x) ∧ ¬Mushy(x))) → (¬Drab(montague)) ::: If there is someone who is both wicked and not mushy, then Montague is not drab.\n(¬Impossible(whitney)) → ((¬Mushy(cyril) ∧ BroadMinded(joseph))) ::: Whitney being not impossible implies that Cyril is not mushy and Joseph is broad-minded.\n(∀x (¬Aggressive(x))) ↔ (∀x (¬Impossible(x))) ::: Someone is not aggressive if and only if he is not impossible.\n(∀x (Aggressive(x) ∧ ¬Drab(x))) ↔ (∀x (¬Impossible(x))) ::: Someone is aggressive and not drab if and only if he is not impossible.\n",
                "First-Order-Logic Question": "Impossible(olive) ::: Olive is impossible."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "Aggressive(montague) ::: Montague is aggressive.\nImpossible(ansel) ::: Ansel is impossible.\n¬Wicked(cyril) ::: Cyril is not wicked.\n¬Wicked(ansel) ::: Ansel is not wicked.\nDrab(katelynn) ::: Katelynn is drab.\n¬Drab(montague) ::: Montague is not drab.\n¬Mushy(ansel) ::: Ansel is not mushy.\n¬Wicked(joseph) ::: Joseph is not wicked.\nBroadMinded(joseph) ::: Joseph is broad-minded.\nDrab(olive) ::: Olive is drab.\n¬Drab(ansel) ::: Ansel is not drab.\n¬Wicked(montague) ::: Montague is not wicked.\n((Mushy(montague) ∧ ¬Wicked(katelynn))) → (¬Aggressive(ansel)) ::: Montague being mushy and Katelynn being not wicked imply that Ansel is not aggressive.\n(BroadMinded(joseph)) ↔ (¬Impossible(joseph)) ::: Joseph is broad-minded if and only if Joseph is not impossible.\n(∃x (¬Mushy(x))) → ((¬Aggressive(whitney) ∧ Impossible(cyril))) ::: If there is at least one people who is not mushy, then Whitney is not aggressive and Cyril is impossible.\n(∃x (BroadMinded(x) ∨ Impossible(x))) → (Aggressive(olive)) ::: If there is someone who is either broad-minded or impossible, then Olive is aggressive.\n¬∃x((¬BroadMinded(x)∧Aggressive(x))) ::: If there is nobody who is not, then Cyril is not broad-minded and Ansel is aggressive.\n((Wicked(olive) ∧ Drab(katelynn))) ↔ ((Aggressive(joseph) ∧ ¬BroadMinded(montague))) ::: Olive is wicked and Katelynn is drab if and only if Joseph is aggressive and Montague is not broad-minded.\n(∃x (Mushy(x))) → ((BroadMinded(katelynn) ∧ ¬Aggressive(joseph))) ::: If there is at least one people who is mushy, then Katelynn is broad-minded and Joseph is not aggressive.\n((Wicked(olive) ∨ BroadMinded(cyril))) → (Aggressive(katelynn)) ::: Olive being wicked or Cyril being broad-minded implies that Katelynn is aggressive.\n(∃x (Wicked(x) ∧ ¬Mushy(x))) → (¬Drab(montague)) ::: If there is someone who is both wicked and not mushy, then Montague is not drab.\n(¬Impossible(whitney)) → ((¬Mushy(cyril) ∧ BroadMinded(joseph))) ::: Whitney being not impossible implies that Cyril is not mushy and Joseph is broad-minded.\n(∀x (¬Aggressive(x))) ↔ (∀x (¬Impossible(x))) ::: Someone is not aggressive if and only if he is not impossible.\n(∀x (Aggressive(x) ∧ ¬Drab(x))) ↔ (∀x (¬Impossible(x))) ::: Someone is aggressive and not drab if and only if he is not impossible.\n",
                "First-Order-Logic Question": "Impossible(olive) ::: Olive is impossible."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬x)) → ((¬BroadMinded(cyril) ∧ Aggressive(ansel))) ::: If there is nobody who is not, then Cyril is not broad-minded and Ansel is aggressive.",
                    "gram": "¬∃x((¬BroadMinded(x)∧Aggressive(x))) ::: If there is nobody who is not, then Cyril is not broad-minded and Ansel is aggressive."
                }
            ],
            "answer": "C",
            "grammar_answer": "C",
            "backup_answer": "C"
        },
        {
            "id": 557,
            "raw_prog": {
                "First-Order-Logic Rules": "Aggressive(montague) ::: Montague is aggressive.\nImpossible(ansel) ::: Ansel is impossible.\n¬Wicked(cyril) ::: Cyril is not wicked.\n¬Wicked(ansel) ::: Ansel is not wicked.\nDrab(katelynn) ::: Katelynn is drab.\n¬Drab(montague) ::: Montague is not drab.\n¬Mushy(ansel) ::: Ansel is not mushy.\n¬Wicked(joseph) ::: Joseph is not wicked.\nDrab(olive) ::: Olive is drab.\nBroadMinded(joseph) ::: Joseph is broad-minded.\n¬Drab(ansel) ::: Ansel is not drab.\n¬Wicked(montague) ::: Montague is not wicked.\n((Mushy(montague) ∧ ¬Wicked(katelynn))) → (¬Aggressive(ansel)) ::: Montague being mushy and Katelynn being not wicked imply that Ansel is not aggressive.\n(BroadMinded(joseph)) ↔ (¬Impossible(joseph)) ::: Joseph is broad-minded if and only if Joseph is not impossible.\n(∃x (¬Mushy(x))) → ((¬Aggressive(whitney) ∧ Impossible(cyril))) ::: If there is at least one people who is not mushy, then Whitney is not aggressive and Cyril is impossible.\n(∃x (BroadMinded(x) ∨ Impossible(x))) → ((Aggressive(olive))) ::: If there is someone who is either broad-minded or impossible, then Olive is aggressive.\n(¬∃x (¬x)) → ((¬BroadMinded(cyril) ∧ Aggressive(ansel))) ::: If there is nobody who is not, then Cyril is not broad-minded and Ansel is aggressive.\n((Wicked(olive) ∧ Drab(katelynn))) ↔ ((Aggressive(joseph) ∧ ¬BroadMinded(montague))) ::: Olive is wicked and Katelynn is drab if and only if Joseph is aggressive and Montague is not broad-minded.\n(∃x (Mushy(x))) → ((BroadMinded(katelynn) ∧ ¬Aggressive(joseph))) ::: If there is at least one people who is mushy, then Katelynn is broad-minded and Joseph is not aggressive.\n((Wicked(olive) ∨ BroadMinded(cyril))) → ((Aggressive(katelynn))) ::: Olive being wicked or Cyril being broad-minded implies that Katelynn is aggressive.\n(∃x (Wicked(x) ∧ ¬Mushy(x))) → ((¬Drab(montague))) ::: If there is someone who is both wicked and not mushy, then Montague is not drab.\n(¬Impossible(whitney)) → ((¬Mushy(cyril) ∧ BroadMinded(joseph))) ::: Whitney being not impossible implies that Cyril is not mushy and Joseph is broad-minded.\n(∀x (¬Aggressive(x))) ↔ (∀x (¬Impossible(x))) ::: Someone is not aggressive if and only if he is not impossible.\n(∀x (Aggressive(x) ∧ ¬Drab(x))) ↔ (∀x (¬Impossible(x))) ::: Someone is aggressive and not drab if and only if he is not impossible.\n",
                "First-Order-Logic Question": "BroadMinded(whitney) ::: Whitney is broad-minded."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "Aggressive(montague) ::: Montague is aggressive.\nImpossible(ansel) ::: Ansel is impossible.\n¬Wicked(cyril) ::: Cyril is not wicked.\n¬Wicked(ansel) ::: Ansel is not wicked.\nDrab(katelynn) ::: Katelynn is drab.\n¬Drab(montague) ::: Montague is not drab.\n¬Mushy(ansel) ::: Ansel is not mushy.\n¬Wicked(joseph) ::: Joseph is not wicked.\nDrab(olive) ::: Olive is drab.\nBroadMinded(joseph) ::: Joseph is broad-minded.\n¬Drab(ansel) ::: Ansel is not drab.\n¬Wicked(montague) ::: Montague is not wicked.\n((Mushy(montague) ∧ ¬Wicked(katelynn))) → (¬Aggressive(ansel)) ::: Montague being mushy and Katelynn being not wicked imply that Ansel is not aggressive.\n(BroadMinded(joseph)) ↔ (¬Impossible(joseph)) ::: Joseph is broad-minded if and only if Joseph is not impossible.\n(∃x (¬Mushy(x))) → ((¬Aggressive(whitney) ∧ Impossible(cyril))) ::: If there is at least one people who is not mushy, then Whitney is not aggressive and Cyril is impossible.\n(∃x (BroadMinded(x) ∨ Impossible(x))) → ((Aggressive(olive))) ::: If there is someone who is either broad-minded or impossible, then Olive is aggressive.\n¬∃x((¬BroadMinded(x)∧Aggressive(x))) ::: If there is nobody who is not, then Cyril is not broad-minded and Ansel is aggressive.\n((Wicked(olive) ∧ Drab(katelynn))) ↔ ((Aggressive(joseph) ∧ ¬BroadMinded(montague))) ::: Olive is wicked and Katelynn is drab if and only if Joseph is aggressive and Montague is not broad-minded.\n(∃x (Mushy(x))) → ((BroadMinded(katelynn) ∧ ¬Aggressive(joseph))) ::: If there is at least one people who is mushy, then Katelynn is broad-minded and Joseph is not aggressive.\n((Wicked(olive) ∨ BroadMinded(cyril))) → ((Aggressive(katelynn))) ::: Olive being wicked or Cyril being broad-minded implies that Katelynn is aggressive.\n(∃x (Wicked(x) ∧ ¬Mushy(x))) → ((¬Drab(montague))) ::: If there is someone who is both wicked and not mushy, then Montague is not drab.\n(¬Impossible(whitney)) → ((¬Mushy(cyril) ∧ BroadMinded(joseph))) ::: Whitney being not impossible implies that Cyril is not mushy and Joseph is broad-minded.\n(∀x (¬Aggressive(x))) ↔ (∀x (¬Impossible(x))) ::: Someone is not aggressive if and only if he is not impossible.\n(∀x (Aggressive(x) ∧ ¬Drab(x))) ↔ (∀x (¬Impossible(x))) ::: Someone is aggressive and not drab if and only if he is not impossible.\n",
                "First-Order-Logic Question": "BroadMinded(whitney) ::: Whitney is broad-minded."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬x)) → ((¬BroadMinded(cyril) ∧ Aggressive(ansel))) ::: If there is nobody who is not, then Cyril is not broad-minded and Ansel is aggressive.",
                    "gram": "¬∃x((¬BroadMinded(x)∧Aggressive(x))) ::: If there is nobody who is not, then Cyril is not broad-minded and Ansel is aggressive."
                }
            ],
            "answer": "B",
            "grammar_answer": "B",
            "backup_answer": "C"
        },
        {
            "id": 558,
            "raw_prog": {
                "First-Order-Logic Rules": "Aggressive(montague) ::: Montague is aggressive.\nImpossible(ansel) ::: Ansel is impossible.\n¬Wicked(cyril) ::: Cyril is not wicked.\n¬Wicked(ansel) ::: Ansel is not wicked.\nDrab(katelynn) ::: Katelynn is drab.\n¬Drab(montague) ::: Montague is not drab.\n¬Mushy(ansel) ::: Ansel is not mushy.\n¬Wicked(joseph) ::: Joseph is not wicked.\nDrab(olive) ::: Olive is drab.\nBroadMinded(joseph) ::: Joseph is broad-minded.\n¬Drab(ansel) ::: Ansel is not drab.\n¬Wicked(montague) ::: Montague is not wicked.\n((Mushy(montague) ∧ ¬Wicked(katelynn))) → (¬Aggressive(ansel)) ::: Montague being mushy and Katelynn being not wicked imply that Ansel is not aggressive.\n(BroadMinded(joseph)) ↔ (¬Impossible(joseph)) ::: Joseph is broad-minded if and only if Joseph is not impossible.\n(∃x (¬Mushy(x))) → ((¬Aggressive(whitney) ∧ Impossible(cyril))) ::: If there is at least one people who is not mushy, then Whitney is not aggressive and Cyril is impossible.\n(∃x (BroadMinded(x) ∨ Impossible(x))) → (Aggressive(olive)) ::: If there is someone who is either broad-minded or impossible, then Olive is aggressive.\n(∀x (¬x)) → ((¬BroadMinded(cyril) ∧ Aggressive(ansel))) ::: If there is nobody who is not, then Cyril is not broad-minded and Ansel is aggressive.\n((Wicked(olive) ∧ Drab(katelynn))) ↔ ((Aggressive(joseph) ∧ ¬BroadMinded(montague))) ::: Olive is wicked and Katelynn is drab if and only if Joseph is aggressive and Montague is not broad-minded.\n(∃x (Mushy(x))) → ((BroadMinded(katelynn) ∧ ¬Aggressive(joseph))) ::: If there is at least one people who is mushy, then Katelynn is broad-minded and Joseph is not aggressive.\n((Wicked(olive) ∨ BroadMinded(cyril))) → (Aggressive(katelynn)) ::: Olive being wicked or Cyril being broad-minded implies that Katelynn is aggressive.\n(∃x (Wicked(x) ∧ ¬Mushy(x))) → (¬Drab(montague)) ::: If there is someone who is both wicked and not mushy, then Montague is not drab.\n(¬Impossible(whitney)) → ((¬Mushy(cyril) ∧ BroadMinded(joseph))) ::: Whitney being not impossible implies that Cyril is not mushy and Joseph is broad-minded.\n(∀x (¬Aggressive(x))) ↔ (∀x (¬Impossible(x))) ::: Someone is not aggressive if and only if he is not impossible.\n(∀x (Aggressive(x) ∧ ¬Drab(x))) ↔ (∀x (¬Impossible(x))) ::: Someone is aggressive and not drab if and only if he is not impossible.\n",
                "First-Order-Logic Question": "Mushy(ansel) ::: Ansel is mushy."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "Aggressive(montague) ::: Montague is aggressive.\nImpossible(ansel) ::: Ansel is impossible.\n¬Wicked(cyril) ::: Cyril is not wicked.\n¬Wicked(ansel) ::: Ansel is not wicked.\nDrab(katelynn) ::: Katelynn is drab.\n¬Drab(montague) ::: Montague is not drab.\n¬Mushy(ansel) ::: Ansel is not mushy.\n¬Wicked(joseph) ::: Joseph is not wicked.\nDrab(olive) ::: Olive is drab.\nBroadMinded(joseph) ::: Joseph is broad-minded.\n¬Drab(ansel) ::: Ansel is not drab.\n¬Wicked(montague) ::: Montague is not wicked.\n((Mushy(montague) ∧ ¬Wicked(katelynn))) → (¬Aggressive(ansel)) ::: Montague being mushy and Katelynn being not wicked imply that Ansel is not aggressive.\n(BroadMinded(joseph)) ↔ (¬Impossible(joseph)) ::: Joseph is broad-minded if and only if Joseph is not impossible.\n(∃x (¬Mushy(x))) → ((¬Aggressive(whitney) ∧ Impossible(cyril))) ::: If there is at least one people who is not mushy, then Whitney is not aggressive and Cyril is impossible.\n(∃x (BroadMinded(x) ∨ Impossible(x))) → (Aggressive(olive)) ::: If there is someone who is either broad-minded or impossible, then Olive is aggressive.\n¬(¬BroadMinded(x))→((¬Aggressive(x))) ::: If there is nobody who is not, then Cyril is not broad-minded and Ansel is aggressive.\n((Wicked(olive) ∧ Drab(katelynn))) ↔ ((Aggressive(joseph) ∧ ¬BroadMinded(montague))) ::: Olive is wicked and Katelynn is drab if and only if Joseph is aggressive and Montague is not broad-minded.\n(∃x (Mushy(x))) → ((BroadMinded(katelynn) ∧ ¬Aggressive(joseph))) ::: If there is at least one people who is mushy, then Katelynn is broad-minded and Joseph is not aggressive.\n((Wicked(olive) ∨ BroadMinded(cyril))) → (Aggressive(katelynn)) ::: Olive being wicked or Cyril being broad-minded implies that Katelynn is aggressive.\n(∃x (Wicked(x) ∧ ¬Mushy(x))) → (¬Drab(montague)) ::: If there is someone who is both wicked and not mushy, then Montague is not drab.\n(¬Impossible(whitney)) → ((¬Mushy(cyril) ∧ BroadMinded(joseph))) ::: Whitney being not impossible implies that Cyril is not mushy and Joseph is broad-minded.\n(∀x (¬Aggressive(x))) ↔ (∀x (¬Impossible(x))) ::: Someone is not aggressive if and only if he is not impossible.\n(∀x (Aggressive(x) ∧ ¬Drab(x))) ↔ (∀x (¬Impossible(x))) ::: Someone is aggressive and not drab if and only if he is not impossible.\n",
                "First-Order-Logic Question": "Mushy(ansel) ::: Ansel is mushy."
            },
            "diff": [
                {
                    "raw": "(∀x (¬x)) → ((¬BroadMinded(cyril) ∧ Aggressive(ansel))) ::: If there is nobody who is not, then Cyril is not broad-minded and Ansel is aggressive.",
                    "gram": "¬(¬BroadMinded(x))→((¬Aggressive(x))) ::: If there is nobody who is not, then Cyril is not broad-minded and Ansel is aggressive."
                }
            ],
            "answer": "A",
            "grammar_answer": "A",
            "backup_answer": "B"
        },
        {
            "id": 559,
            "raw_prog": {
                "First-Order-Logic Rules": "Aggressive(montague) ::: Montague is aggressive.\nImpossible(ansel) ::: Ansel is impossible.\n¬Wicked(cyril) ::: Cyril is not wicked.\n¬Wicked(ansel) ::: Ansel is not wicked.\nDrab(katelynn) ::: Katelynn is drab.\n¬Drab(montague) ::: Montague is not drab.\n¬Mushy(ansel) ::: Ansel is not mushy.\n¬Wicked(joseph) ::: Joseph is not wicked.\nDrab(olive) ::: Olive is drab.\nBroadMinded(joseph) ::: Joseph is broad-minded.\n¬Drab(ansel) ::: Ansel is not drab.\n¬Wicked(montague) ::: Montague is not wicked.\n((Mushy(montague) ∧ ¬Wicked(katelynn))) → (¬Aggressive(ansel)) ::: Montague being mushy and Katelynn being not wicked imply that Ansel is not aggressive.\n(BroadMinded(joseph)) ↔ (¬Impossible(joseph)) ::: Joseph is broad-minded if and only if Joseph is not impossible.\n(∃x (¬Mushy(x))) → ((¬Aggressive(whitney) ∧ Impossible(cyril))) ::: If there is at least one people who is not mushy, then Whitney is not aggressive and Cyril is impossible.\n(∃x (BroadMinded(x) ∨ Impossible(x))) → ((Aggressive(olive))) ::: If there is someone who is either broad-minded or impossible, then Olive is aggressive.\n(¬∃x (¬x)) → ((¬BroadMinded(cyril) ∧ Aggressive(ansel))) ::: If there is nobody who is not, then Cyril is not broad-minded and Ansel is aggressive.\n((Wicked(olive) ∧ Drab(katelynn))) ↔ ((Aggressive(joseph) ∧ ¬BroadMinded(montague))) ::: Olive is wicked and Katelynn is drab if and only if Joseph is aggressive and Montague is not broad-minded.\n(∃x (Mushy(x))) → ((BroadMinded(katelynn) ∧ ¬Aggressive(joseph))) ::: If there is at least one people who is mushy, then Katelynn is broad-minded and Joseph is not aggressive.\n((Wicked(olive) ∨ BroadMinded(cyril))) → ((Aggressive(katelynn))) ::: Olive being wicked or Cyril being broad-minded implies that Katelynn is aggressive.\n(∃x (Wicked(x) ∧ ¬Mushy(x))) → ((¬Drab(montague))) ::: If there is someone who is both wicked and not mushy, then Montague is not drab.\n(¬Impossible(whitney)) → ((¬Mushy(cyril) ∧ BroadMinded(joseph))) ::: Whitney being not impossible implies that Cyril is not mushy and Joseph is broad-minded.\n(∀x (¬Aggressive(x))) ↔ (∀x (¬Impossible(x))) ::: Someone is not aggressive if and only if he is not impossible.\n(∀x (Aggressive(x) ∧ ¬Drab(x))) ↔ (∀x (¬Impossible(x))) ::: Someone is aggressive and not drab if and only if he is not impossible.\n",
                "First-Order-Logic Question": "¬Drab(ansel) ::: Ansel is not drab."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "Aggressive(montague) ::: Montague is aggressive.\nImpossible(ansel) ::: Ansel is impossible.\n¬Wicked(cyril) ::: Cyril is not wicked.\n¬Wicked(ansel) ::: Ansel is not wicked.\nDrab(katelynn) ::: Katelynn is drab.\n¬Drab(montague) ::: Montague is not drab.\n¬Mushy(ansel) ::: Ansel is not mushy.\n¬Wicked(joseph) ::: Joseph is not wicked.\nDrab(olive) ::: Olive is drab.\nBroadMinded(joseph) ::: Joseph is broad-minded.\n¬Drab(ansel) ::: Ansel is not drab.\n¬Wicked(montague) ::: Montague is not wicked.\n((Mushy(montague) ∧ ¬Wicked(katelynn))) → (¬Aggressive(ansel)) ::: Montague being mushy and Katelynn being not wicked imply that Ansel is not aggressive.\n(BroadMinded(joseph)) ↔ (¬Impossible(joseph)) ::: Joseph is broad-minded if and only if Joseph is not impossible.\n(∃x (¬Mushy(x))) → ((¬Aggressive(whitney) ∧ Impossible(cyril))) ::: If there is at least one people who is not mushy, then Whitney is not aggressive and Cyril is impossible.\n(∃x (BroadMinded(x) ∨ Impossible(x))) → ((Aggressive(olive))) ::: If there is someone who is either broad-minded or impossible, then Olive is aggressive.\n¬∃x((¬BroadMinded(x)∧Aggressive(x))) ::: If there is nobody who is not, then Cyril is not broad-minded and Ansel is aggressive.\n((Wicked(olive) ∧ Drab(katelynn))) ↔ ((Aggressive(joseph) ∧ ¬BroadMinded(montague))) ::: Olive is wicked and Katelynn is drab if and only if Joseph is aggressive and Montague is not broad-minded.\n(∃x (Mushy(x))) → ((BroadMinded(katelynn) ∧ ¬Aggressive(joseph))) ::: If there is at least one people who is mushy, then Katelynn is broad-minded and Joseph is not aggressive.\n((Wicked(olive) ∨ BroadMinded(cyril))) → ((Aggressive(katelynn))) ::: Olive being wicked or Cyril being broad-minded implies that Katelynn is aggressive.\n(∃x (Wicked(x) ∧ ¬Mushy(x))) → ((¬Drab(montague))) ::: If there is someone who is both wicked and not mushy, then Montague is not drab.\n(¬Impossible(whitney)) → ((¬Mushy(cyril) ∧ BroadMinded(joseph))) ::: Whitney being not impossible implies that Cyril is not mushy and Joseph is broad-minded.\n(∀x (¬Aggressive(x))) ↔ (∀x (¬Impossible(x))) ::: Someone is not aggressive if and only if he is not impossible.\n(∀x (Aggressive(x) ∧ ¬Drab(x))) ↔ (∀x (¬Impossible(x))) ::: Someone is aggressive and not drab if and only if he is not impossible.\n",
                "First-Order-Logic Question": "¬Drab(ansel) ::: Ansel is not drab."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬x)) → ((¬BroadMinded(cyril) ∧ Aggressive(ansel))) ::: If there is nobody who is not, then Cyril is not broad-minded and Ansel is aggressive.",
                    "gram": "¬∃x((¬BroadMinded(x)∧Aggressive(x))) ::: If there is nobody who is not, then Cyril is not broad-minded and Ansel is aggressive."
                }
            ],
            "answer": "C",
            "grammar_answer": "C",
            "backup_answer": "A"
        },
        {
            "id": 560,
            "raw_prog": {
                "First-Order-Logic Rules": "Aggressive(montague) ::: Montague is aggressive.\nImpossible(ansel) ::: Ansel is impossible.\n¬Wicked(cyril) ::: Cyril is not wicked.\n¬Wicked(ansel) ::: Ansel is not wicked.\nDrab(katelynn) ::: Katelynn is drab.\n¬Drab(montague) ::: Montague is not drab.\n¬Mushy(ansel) ::: Ansel is not mushy.\n¬Wicked(joseph) ::: Joseph is not wicked.\nDrab(olive) ::: Olive is drab.\nBroadMinded(joseph) ::: Joseph is broad-minded.\n¬Drab(ansel) ::: Ansel is not drab.\n¬Wicked(montague) ::: Montague is not wicked.\n((Mushy(montague) ∧ ¬Wicked(katelynn))) → (¬Aggressive(ansel)) ::: Montague being mushy and Katelynn being not wicked imply that Ansel is not aggressive.\n(BroadMinded(joseph)) ↔ (¬Impossible(joseph)) ::: Joseph is broad-minded if and only if Joseph is not impossible.\n(∃x (¬Mushy(x))) → ((¬Aggressive(whitney) ∧ Impossible(cyril))) ::: If there is at least one people who is not mushy, then Whitney is not aggressive and Cyril is impossible.\n(∃x (BroadMinded(x) ∨ Impossible(x))) → ((Aggressive(olive))) ::: If there is someone who is either broad-minded or impossible, then Olive is aggressive.\n(∀x (¬x)) → ((¬BroadMinded(cyril) ∧ Aggressive(ansel))) ::: If there is nobody who is not, then Cyril is not broad-minded and Ansel is aggressive.\n((Wicked(olive) ∧ Drab(katelynn))) ↔ ((Aggressive(joseph) ∧ ¬BroadMinded(montague))) ::: Olive is wicked and Katelynn is drab if and only if Joseph is aggressive and Montague is not broad-minded.\n(∃x (Mushy(x))) → ((BroadMinded(katelynn) ∧ ¬Aggressive(joseph))) ::: If there is at least one people who is mushy, then Katelynn is broad-minded and Joseph is not aggressive.\n((Wicked(olive) ∨ BroadMinded(cyril))) → ((Aggressive(katelynn))) ::: Olive being wicked or Cyril being broad-minded implies that Katelynn is aggressive.\n(∃x (Wicked(x) ∧ ¬Mushy(x))) → ((¬Drab(montague))) ::: If there is someone who is both wicked and not mushy, then Montague is not drab.\n((¬Impossible(whitney))) → ((¬Mushy(cyril) ∧ BroadMinded(joseph))) ::: Whitney being not impossible implies that Cyril is not mushy and Joseph is broad-minded.\n(∀x (¬Aggressive(x))) ↔ (∀x (¬Impossible(x))) ::: Someone is not aggressive if and only if he is not impossible.\n(∀x (Aggressive(x) ∧ ¬Drab(x))) ↔ (∀x (¬Impossible(x))) ::: Someone is aggressive and not drab if and only if he is not impossible.\n",
                "First-Order-Logic Question": "Impossible(katelynn) ::: Katelynn is impossible."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "Aggressive(montague) ::: Montague is aggressive.\nImpossible(ansel) ::: Ansel is impossible.\n¬Wicked(cyril) ::: Cyril is not wicked.\n¬Wicked(ansel) ::: Ansel is not wicked.\nDrab(katelynn) ::: Katelynn is drab.\n¬Drab(montague) ::: Montague is not drab.\n¬Mushy(ansel) ::: Ansel is not mushy.\n¬Wicked(joseph) ::: Joseph is not wicked.\nDrab(olive) ::: Olive is drab.\nBroadMinded(joseph) ::: Joseph is broad-minded.\n¬Drab(ansel) ::: Ansel is not drab.\n¬Wicked(montague) ::: Montague is not wicked.\n((Mushy(montague) ∧ ¬Wicked(katelynn))) → (¬Aggressive(ansel)) ::: Montague being mushy and Katelynn being not wicked imply that Ansel is not aggressive.\n(BroadMinded(joseph)) ↔ (¬Impossible(joseph)) ::: Joseph is broad-minded if and only if Joseph is not impossible.\n(∃x (¬Mushy(x))) → ((¬Aggressive(whitney) ∧ Impossible(cyril))) ::: If there is at least one people who is not mushy, then Whitney is not aggressive and Cyril is impossible.\n(∃x (BroadMinded(x) ∨ Impossible(x))) → ((Aggressive(olive))) ::: If there is someone who is either broad-minded or impossible, then Olive is aggressive.\n¬(¬BroadMinded(x))→((¬Aggressive(x))) ::: If there is nobody who is not, then Cyril is not broad-minded and Ansel is aggressive.\n((Wicked(olive) ∧ Drab(katelynn))) ↔ ((Aggressive(joseph) ∧ ¬BroadMinded(montague))) ::: Olive is wicked and Katelynn is drab if and only if Joseph is aggressive and Montague is not broad-minded.\n(∃x (Mushy(x))) → ((BroadMinded(katelynn) ∧ ¬Aggressive(joseph))) ::: If there is at least one people who is mushy, then Katelynn is broad-minded and Joseph is not aggressive.\n((Wicked(olive) ∨ BroadMinded(cyril))) → ((Aggressive(katelynn))) ::: Olive being wicked or Cyril being broad-minded implies that Katelynn is aggressive.\n(∃x (Wicked(x) ∧ ¬Mushy(x))) → ((¬Drab(montague))) ::: If there is someone who is both wicked and not mushy, then Montague is not drab.\n((¬Impossible(whitney))) → ((¬Mushy(cyril) ∧ BroadMinded(joseph))) ::: Whitney being not impossible implies that Cyril is not mushy and Joseph is broad-minded.\n(∀x (¬Aggressive(x))) ↔ (∀x (¬Impossible(x))) ::: Someone is not aggressive if and only if he is not impossible.\n(∀x (Aggressive(x) ∧ ¬Drab(x))) ↔ (∀x (¬Impossible(x))) ::: Someone is aggressive and not drab if and only if he is not impossible.\n",
                "First-Order-Logic Question": "Impossible(katelynn) ::: Katelynn is impossible."
            },
            "diff": [
                {
                    "raw": "(∀x (¬x)) → ((¬BroadMinded(cyril) ∧ Aggressive(ansel))) ::: If there is nobody who is not, then Cyril is not broad-minded and Ansel is aggressive.",
                    "gram": "¬(¬BroadMinded(x))→((¬Aggressive(x))) ::: If there is nobody who is not, then Cyril is not broad-minded and Ansel is aggressive."
                }
            ],
            "answer": "A",
            "grammar_answer": "A",
            "backup_answer": "A"
        },
        {
            "id": 562,
            "raw_prog": {
                "First-Order-Logic Rules": "Aggressive(montague) ::: Montague is aggressive.\nImpossible(ansel) ::: Ansel is impossible.\n¬Wicked(cyril) ::: Cyril is not wicked.\n¬Wicked(ansel) ::: Ansel is not wicked.\nDrab(katelynn) ::: Katelynn is drab.\n¬Drab(montague) ::: Montague is not drab.\n¬Mushy(ansel) ::: Ansel is not mushy.\n¬Wicked(joseph) ::: Joseph is not wicked.\nBroadMinded(joseph) ::: Joseph is broad-minded.\nDrab(olive) ::: Olive is drab.\n¬Drab(ansel) ::: Ansel is not drab.\n¬Wicked(montague) ::: Montague is not wicked.\n((Mushy(montague) ∧ ¬Wicked(katelynn))) → ((¬Aggressive(ansel))) ::: Montague being mushy and Katelynn being not wicked imply that Ansel is not aggressive.\n((BroadMinded(joseph))) ↔ ((¬Impossible(joseph))) ::: Joseph is broad-minded if and only if Joseph is not impossible.\n(∃x (¬Mushy(x))) → ((¬Aggressive(whitney) ∧ Impossible(cyril))) ::: If there is at least one people who is not mushy, then Whitney is not aggressive and Cyril is impossible.\n(∃x (BroadMinded(x) ∨ Impossible(x))) → ((Aggressive(olive))) ::: If there is someone who is either broad-minded or impossible, then Olive is aggressive.\n(∀x (¬x)) → ((¬BroadMinded(cyril) ∧ Aggressive(ansel))) ::: If there is nobody who is not, then Cyril is not broad-minded and Ansel is aggressive.\n((Wicked(olive) ∧ Drab(katelynn))) ↔ ((Aggressive(joseph) ∧ ¬BroadMinded(montague))) ::: Olive is wicked and Katelynn is drab if and only if Joseph is aggressive and Montague is not broad-minded.\n(∃x (Mushy(x))) → ((BroadMinded(katelynn) ∧ ¬Aggressive(joseph))) ::: If there is at least one people who is mushy, then Katelynn is broad-minded and Joseph is not aggressive.\n((Wicked(olive) ∨ BroadMinded(cyril))) → ((Aggressive(katelynn))) ::: Olive being wicked or Cyril being broad-minded implies that Katelynn is aggressive.\n(∃x (Wicked(x) ∧ ¬Mushy(x))) → ((¬Drab(montague))) ::: If there is someone who is both wicked and not mushy, then Montague is not drab.\n((¬Impossible(whitney))) → ((¬Mushy(cyril) ∧ BroadMinded(joseph))) ::: Whitney being not impossible implies that Cyril is not mushy and Joseph is broad-minded.\n(∀x (¬Aggressive(x))) ↔ (∀x (¬Impossible(x))) ::: Someone is not aggressive if and only if he is not impossible.\n(∀x (Aggressive(x) ∧ ¬Drab(x))) ↔ (∀x (¬Impossible(x))) ::: Someone is aggressive and not drab if and only if he is not impossible.\n",
                "First-Order-Logic Question": "Impossible(cyril) ::: Cyril is impossible."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "Aggressive(montague) ::: Montague is aggressive.\nImpossible(ansel) ::: Ansel is impossible.\n¬Wicked(cyril) ::: Cyril is not wicked.\n¬Wicked(ansel) ::: Ansel is not wicked.\nDrab(katelynn) ::: Katelynn is drab.\n¬Drab(montague) ::: Montague is not drab.\n¬Mushy(ansel) ::: Ansel is not mushy.\n¬Wicked(joseph) ::: Joseph is not wicked.\nBroadMinded(joseph) ::: Joseph is broad-minded.\nDrab(olive) ::: Olive is drab.\n¬Drab(ansel) ::: Ansel is not drab.\n¬Wicked(montague) ::: Montague is not wicked.\n((Mushy(montague) ∧ ¬Wicked(katelynn))) → ((¬Aggressive(ansel))) ::: Montague being mushy and Katelynn being not wicked imply that Ansel is not aggressive.\n((BroadMinded(joseph))) ↔ ((¬Impossible(joseph))) ::: Joseph is broad-minded if and only if Joseph is not impossible.\n(∃x (¬Mushy(x))) → ((¬Aggressive(whitney) ∧ Impossible(cyril))) ::: If there is at least one people who is not mushy, then Whitney is not aggressive and Cyril is impossible.\n(∃x (BroadMinded(x) ∨ Impossible(x))) → ((Aggressive(olive))) ::: If there is someone who is either broad-minded or impossible, then Olive is aggressive.\n¬(¬BroadMinded(x))→((¬Aggressive(x))) ::: If there is nobody who is not, then Cyril is not broad-minded and Ansel is aggressive.\n((Wicked(olive) ∧ Drab(katelynn))) ↔ ((Aggressive(joseph) ∧ ¬BroadMinded(montague))) ::: Olive is wicked and Katelynn is drab if and only if Joseph is aggressive and Montague is not broad-minded.\n(∃x (Mushy(x))) → ((BroadMinded(katelynn) ∧ ¬Aggressive(joseph))) ::: If there is at least one people who is mushy, then Katelynn is broad-minded and Joseph is not aggressive.\n((Wicked(olive) ∨ BroadMinded(cyril))) → ((Aggressive(katelynn))) ::: Olive being wicked or Cyril being broad-minded implies that Katelynn is aggressive.\n(∃x (Wicked(x) ∧ ¬Mushy(x))) → ((¬Drab(montague))) ::: If there is someone who is both wicked and not mushy, then Montague is not drab.\n((¬Impossible(whitney))) → ((¬Mushy(cyril) ∧ BroadMinded(joseph))) ::: Whitney being not impossible implies that Cyril is not mushy and Joseph is broad-minded.\n(∀x (¬Aggressive(x))) ↔ (∀x (¬Impossible(x))) ::: Someone is not aggressive if and only if he is not impossible.\n(∀x (Aggressive(x) ∧ ¬Drab(x))) ↔ (∀x (¬Impossible(x))) ::: Someone is aggressive and not drab if and only if he is not impossible.\n",
                "First-Order-Logic Question": "Impossible(cyril) ::: Cyril is impossible."
            },
            "diff": [
                {
                    "raw": "(∀x (¬x)) → ((¬BroadMinded(cyril) ∧ Aggressive(ansel))) ::: If there is nobody who is not, then Cyril is not broad-minded and Ansel is aggressive.",
                    "gram": "¬(¬BroadMinded(x))→((¬Aggressive(x))) ::: If there is nobody who is not, then Cyril is not broad-minded and Ansel is aggressive."
                }
            ],
            "answer": "B",
            "grammar_answer": "B",
            "backup_answer": "A"
        },
        {
            "id": 563,
            "raw_prog": {
                "First-Order-Logic Rules": "Aggressive(montague) ::: Montague is aggressive.\nImpossible(ansel) ::: Ansel is impossible.\n¬Wicked(cyril) ::: Cyril is not wicked.\n¬Wicked(ansel) ::: Ansel is not wicked.\nDrab(katelynn) ::: Katelynn is drab.\n¬Drab(montague) ::: Montague is not drab.\n¬Mushy(ansel) ::: Ansel is not mushy.\n¬Wicked(joseph) ::: Joseph is not wicked.\nBroadMinded(joseph) ::: Joseph is broad-minded.\nDrab(olive) ::: Olive is drab.\n¬Drab(ansel) ::: Ansel is not drab.\n¬Wicked(montague) ::: Montague is not wicked.\n((Mushy(montague) ∧ ¬Wicked(katelynn))) → (¬Aggressive(ansel)) ::: Montague being mushy and Katelynn being not wicked imply that Ansel is not aggressive.\n(BroadMinded(joseph)) ↔ (¬Impossible(joseph)) ::: Joseph is broad-minded if and only if Joseph is not impossible.\n(∃x (¬Mushy(x))) → ((¬Aggressive(whitney) ∧ Impossible(cyril))) ::: If there is at least one people who is not mushy, then Whitney is not aggressive and Cyril is impossible.\n(∃x (BroadMinded(x) ∨ Impossible(x))) → (Aggressive(olive)) ::: If there is someone who is either broad-minded or impossible, then Olive is aggressive.\n(¬∃x (¬x)) → ((¬BroadMinded(cyril) ∧ Aggressive(ansel))) ::: If there is nobody who is not, then Cyril is not broad-minded and Ansel is aggressive.\n((Wicked(olive) ∧ Drab(katelynn))) ↔ ((Aggressive(joseph) ∧ ¬BroadMinded(montague))) ::: Olive is wicked and Katelynn is drab if and only if Joseph is aggressive and Montague is not broad-minded.\n(∃x (Mushy(x))) → ((BroadMinded(katelynn) ∧ ¬Aggressive(joseph))) ::: If there is at least one people who is mushy, then Katelynn is broad-minded and Joseph is not aggressive.\n((Wicked(olive) ∨ BroadMinded(cyril))) → (Aggressive(katelynn)) ::: Olive being wicked or Cyril being broad-minded implies that Katelynn is aggressive.\n(∃x (Wicked(x) ∧ ¬Mushy(x))) → (¬Drab(montague)) ::: If there is someone who is both wicked and not mushy, then Montague is not drab.\n((¬Impossible(whitney))) → ((¬Mushy(cyril) ∧ BroadMinded(joseph))) ::: Whitney being not impossible implies that Cyril is not mushy and Joseph is broad-minded.\n(∀x (¬Aggressive(x))) ↔ (∀x (¬Impossible(x))) ::: Someone is not aggressive if and only if he is not impossible.\n(∀x (Aggressive(x) ∧ ¬Drab(x))) ↔ (∀x (¬Impossible(x))) ::: Someone is aggressive and not drab if and only if he is not impossible.\n",
                "First-Order-Logic Question": "Wicked(ansel) ::: Ansel is wicked."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "Aggressive(montague) ::: Montague is aggressive.\nImpossible(ansel) ::: Ansel is impossible.\n¬Wicked(cyril) ::: Cyril is not wicked.\n¬Wicked(ansel) ::: Ansel is not wicked.\nDrab(katelynn) ::: Katelynn is drab.\n¬Drab(montague) ::: Montague is not drab.\n¬Mushy(ansel) ::: Ansel is not mushy.\n¬Wicked(joseph) ::: Joseph is not wicked.\nBroadMinded(joseph) ::: Joseph is broad-minded.\nDrab(olive) ::: Olive is drab.\n¬Drab(ansel) ::: Ansel is not drab.\n¬Wicked(montague) ::: Montague is not wicked.\n((Mushy(montague) ∧ ¬Wicked(katelynn))) → (¬Aggressive(ansel)) ::: Montague being mushy and Katelynn being not wicked imply that Ansel is not aggressive.\n(BroadMinded(joseph)) ↔ (¬Impossible(joseph)) ::: Joseph is broad-minded if and only if Joseph is not impossible.\n(∃x (¬Mushy(x))) → ((¬Aggressive(whitney) ∧ Impossible(cyril))) ::: If there is at least one people who is not mushy, then Whitney is not aggressive and Cyril is impossible.\n(∃x (BroadMinded(x) ∨ Impossible(x))) → (Aggressive(olive)) ::: If there is someone who is either broad-minded or impossible, then Olive is aggressive.\n¬∃x((¬BroadMinded(x)∧Aggressive(x))) ::: If there is nobody who is not, then Cyril is not broad-minded and Ansel is aggressive.\n((Wicked(olive) ∧ Drab(katelynn))) ↔ ((Aggressive(joseph) ∧ ¬BroadMinded(montague))) ::: Olive is wicked and Katelynn is drab if and only if Joseph is aggressive and Montague is not broad-minded.\n(∃x (Mushy(x))) → ((BroadMinded(katelynn) ∧ ¬Aggressive(joseph))) ::: If there is at least one people who is mushy, then Katelynn is broad-minded and Joseph is not aggressive.\n((Wicked(olive) ∨ BroadMinded(cyril))) → (Aggressive(katelynn)) ::: Olive being wicked or Cyril being broad-minded implies that Katelynn is aggressive.\n(∃x (Wicked(x) ∧ ¬Mushy(x))) → (¬Drab(montague)) ::: If there is someone who is both wicked and not mushy, then Montague is not drab.\n((¬Impossible(whitney))) → ((¬Mushy(cyril) ∧ BroadMinded(joseph))) ::: Whitney being not impossible implies that Cyril is not mushy and Joseph is broad-minded.\n(∀x (¬Aggressive(x))) ↔ (∀x (¬Impossible(x))) ::: Someone is not aggressive if and only if he is not impossible.\n(∀x (Aggressive(x) ∧ ¬Drab(x))) ↔ (∀x (¬Impossible(x))) ::: Someone is aggressive and not drab if and only if he is not impossible.\n",
                "First-Order-Logic Question": "Wicked(ansel) ::: Ansel is wicked."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬x)) → ((¬BroadMinded(cyril) ∧ Aggressive(ansel))) ::: If there is nobody who is not, then Cyril is not broad-minded and Ansel is aggressive.",
                    "gram": "¬∃x((¬BroadMinded(x)∧Aggressive(x))) ::: If there is nobody who is not, then Cyril is not broad-minded and Ansel is aggressive."
                }
            ],
            "answer": "A",
            "grammar_answer": "A",
            "backup_answer": "B"
        },
        {
            "id": 564,
            "raw_prog": {
                "First-Order-Logic Rules": "Aggressive(montague) ::: Montague is aggressive.\nImpossible(ansel) ::: Ansel is impossible.\n¬Wicked(cyril) ::: Cyril is not wicked.\n¬Wicked(ansel) ::: Ansel is not wicked.\nDrab(katelynn) ::: Katelynn is drab.\n¬Drab(montague) ::: Montague is not drab.\n¬Mushy(ansel) ::: Ansel is not mushy.\n¬Wicked(joseph) ::: Joseph is not wicked.\nBroadMinded(joseph) ::: Joseph is broad-minded.\nDrab(olive) ::: Olive is drab.\n¬Drab(ansel) ::: Ansel is not drab.\n¬Wicked(montague) ::: Montague is not wicked.\n((Mushy(montague) ∧ ¬Wicked(katelynn))) → (¬Aggressive(ansel)) ::: Montague being mushy and Katelynn being not wicked imply that Ansel is not aggressive.\n(BroadMinded(joseph)) ↔ (¬Impossible(joseph)) ::: Joseph is broad-minded if and only if Joseph is not impossible.\n(∃x (¬Mushy(x))) → ((¬Aggressive(whitney) ∧ Impossible(cyril))) ::: If there is at least one people who is not mushy, then Whitney is not aggressive and Cyril is impossible.\n(∃x (BroadMinded(x) ∨ Impossible(x))) → ((Aggressive(olive))) ::: If there is someone who is either broad-minded or impossible, then Olive is aggressive.\n(¬∃x (¬x)) → ((¬BroadMinded(cyril) ∧ Aggressive(ansel))) ::: If there is nobody who is not, then Cyril is not broad-minded and Ansel is aggressive.\n((Wicked(olive) ∧ Drab(katelynn))) ↔ ((Aggressive(joseph) ∧ ¬BroadMinded(montague))) ::: Olive is wicked and Katelynn is drab if and only if Joseph is aggressive and Montague is not broad-minded.\n(∃x (Mushy(x))) → ((BroadMinded(katelynn) ∧ ¬Aggressive(joseph))) ::: If there is at least one people who is mushy, then Katelynn is broad-minded and Joseph is not aggressive.\n((Wicked(olive) ∨ BroadMinded(cyril))) → ((Aggressive(katelynn))) ::: Olive being wicked or Cyril being broad-minded implies that Katelynn is aggressive.\n(∃x (Wicked(x) ∧ ¬Mushy(x))) → ((¬Drab(montague))) ::: If there is someone who is both wicked and not mushy, then Montague is not drab.\n(¬Impossible(whitney)) → ((¬Mushy(cyril) ∧ BroadMinded(joseph))) ::: Whitney being not impossible implies that Cyril is not mushy and Joseph is broad-minded.\n(∀x (¬Aggressive(x))) ↔ (∀x (¬Impossible(x))) ::: Someone is not aggressive if and only if he is not impossible.\n(∀x (Aggressive(x) ∧ ¬Drab(x))) ↔ (∀x (¬Impossible(x))) ::: Someone is aggressive and not drab if and only if he is not impossible.\n",
                "First-Order-Logic Question": "¬Mushy(ansel) ::: Ansel is not mushy."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "Aggressive(montague) ::: Montague is aggressive.\nImpossible(ansel) ::: Ansel is impossible.\n¬Wicked(cyril) ::: Cyril is not wicked.\n¬Wicked(ansel) ::: Ansel is not wicked.\nDrab(katelynn) ::: Katelynn is drab.\n¬Drab(montague) ::: Montague is not drab.\n¬Mushy(ansel) ::: Ansel is not mushy.\n¬Wicked(joseph) ::: Joseph is not wicked.\nBroadMinded(joseph) ::: Joseph is broad-minded.\nDrab(olive) ::: Olive is drab.\n¬Drab(ansel) ::: Ansel is not drab.\n¬Wicked(montague) ::: Montague is not wicked.\n((Mushy(montague) ∧ ¬Wicked(katelynn))) → (¬Aggressive(ansel)) ::: Montague being mushy and Katelynn being not wicked imply that Ansel is not aggressive.\n(BroadMinded(joseph)) ↔ (¬Impossible(joseph)) ::: Joseph is broad-minded if and only if Joseph is not impossible.\n(∃x (¬Mushy(x))) → ((¬Aggressive(whitney) ∧ Impossible(cyril))) ::: If there is at least one people who is not mushy, then Whitney is not aggressive and Cyril is impossible.\n(∃x (BroadMinded(x) ∨ Impossible(x))) → ((Aggressive(olive))) ::: If there is someone who is either broad-minded or impossible, then Olive is aggressive.\n¬∃x(¬(¬(BroadMinded(x)))) ::: If there is nobody who is not, then Cyril is not broad-minded and Ansel is aggressive.\n((Wicked(olive) ∧ Drab(katelynn))) ↔ ((Aggressive(joseph) ∧ ¬BroadMinded(montague))) ::: Olive is wicked and Katelynn is drab if and only if Joseph is aggressive and Montague is not broad-minded.\n(∃x (Mushy(x))) → ((BroadMinded(katelynn) ∧ ¬Aggressive(joseph))) ::: If there is at least one people who is mushy, then Katelynn is broad-minded and Joseph is not aggressive.\n((Wicked(olive) ∨ BroadMinded(cyril))) → ((Aggressive(katelynn))) ::: Olive being wicked or Cyril being broad-minded implies that Katelynn is aggressive.\n(∃x (Wicked(x) ∧ ¬Mushy(x))) → ((¬Drab(montague))) ::: If there is someone who is both wicked and not mushy, then Montague is not drab.\n(¬Impossible(whitney)) → ((¬Mushy(cyril) ∧ BroadMinded(joseph))) ::: Whitney being not impossible implies that Cyril is not mushy and Joseph is broad-minded.\n(∀x (¬Aggressive(x))) ↔ (∀x (¬Impossible(x))) ::: Someone is not aggressive if and only if he is not impossible.\n(∀x (Aggressive(x) ∧ ¬Drab(x))) ↔ (∀x (¬Impossible(x))) ::: Someone is aggressive and not drab if and only if he is not impossible.\n",
                "First-Order-Logic Question": "¬Mushy(ansel) ::: Ansel is not mushy."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬x)) → ((¬BroadMinded(cyril) ∧ Aggressive(ansel))) ::: If there is nobody who is not, then Cyril is not broad-minded and Ansel is aggressive.",
                    "gram": "¬∃x(¬(¬(BroadMinded(x)))) ::: If there is nobody who is not, then Cyril is not broad-minded and Ansel is aggressive."
                }
            ],
            "answer": "A",
            "grammar_answer": "A",
            "backup_answer": "A"
        },
        {
            "id": 565,
            "raw_prog": {
                "First-Order-Logic Rules": "Aggressive(montague) ::: Montague is aggressive.\nImpossible(ansel) ::: Ansel is impossible.\n¬Wicked(cyril) ::: Cyril is not wicked.\n¬Wicked(ansel) ::: Ansel is not wicked.\nDrab(katelynn) ::: Katelynn is drab.\n¬Drab(montague) ::: Montague is not drab.\n¬Mushy(ansel) ::: Ansel is not mushy.\n¬Wicked(joseph) ::: Joseph is not wicked.\nDrab(olive) ::: Olive is drab.\nBroadMinded(joseph) ::: Joseph is broad-minded.\n¬Drab(ansel) ::: Ansel is not drab.\n¬Wicked(montague) ::: Montague is not wicked.\n((Mushy(montague) ∧ ¬Wicked(katelynn))) → ((¬Aggressive(ansel))) ::: Montague being mushy and Katelynn being not wicked imply that Ansel is not aggressive.\n((BroadMinded(joseph))) ↔ ((¬Impossible(joseph))) ::: Joseph is broad-minded if and only if Joseph is not impossible.\n(∃x (¬Mushy(x))) → ((¬Aggressive(whitney) ∧ Impossible(cyril))) ::: If there is at least one people who is not mushy, then Whitney is not aggressive and Cyril is impossible.\n(∃x (BroadMinded(x) ∨ Impossible(x))) → ((Aggressive(olive))) ::: If there is someone who is either broad-minded or impossible, then Olive is aggressive.\n(¬∃x (¬x)) → ((¬BroadMinded(cyril) ∧ Aggressive(ansel))) ::: If there is nobody who is not, then Cyril is not broad-minded and Ansel is aggressive.\n((Wicked(olive) ∧ Drab(katelynn))) ↔ ((Aggressive(joseph) ∧ ¬BroadMinded(montague))) ::: Olive is wicked and Katelynn is drab if and only if Joseph is aggressive and Montague is not broad-minded.\n(∃x (Mushy(x))) → ((BroadMinded(katelynn) ∧ ¬Aggressive(joseph))) ::: If there is at least one people who is mushy, then Katelynn is broad-minded and Joseph is not aggressive.\n((Wicked(olive) ∨ BroadMinded(cyril))) → ((Aggressive(katelynn))) ::: Olive being wicked or Cyril being broad-minded implies that Katelynn is aggressive.\n(∃x (Wicked(x) ∧ ¬Mushy(x))) → ((¬Drab(montague))) ::: If there is someone who is both wicked and not mushy, then Montague is not drab.\n((¬Impossible(whitney))) → ((¬Mushy(cyril) ∧ BroadMinded(joseph))) ::: Whitney being not impossible implies that Cyril is not mushy and Joseph is broad-minded.\n(∀x (¬Aggressive(x))) ↔ (∀x (¬Impossible(x))) ::: Someone is not aggressive if and only if he is not impossible.\n(∀x (Aggressive(x) ∧ ¬Drab(x))) ↔ (∀x (¬Impossible(x))) ::: Someone is aggressive and not drab if and only if he is not impossible.\n",
                "First-Order-Logic Question": "Impossible(ansel) ::: Ansel is impossible."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "Aggressive(montague) ::: Montague is aggressive.\nImpossible(ansel) ::: Ansel is impossible.\n¬Wicked(cyril) ::: Cyril is not wicked.\n¬Wicked(ansel) ::: Ansel is not wicked.\nDrab(katelynn) ::: Katelynn is drab.\n¬Drab(montague) ::: Montague is not drab.\n¬Mushy(ansel) ::: Ansel is not mushy.\n¬Wicked(joseph) ::: Joseph is not wicked.\nDrab(olive) ::: Olive is drab.\nBroadMinded(joseph) ::: Joseph is broad-minded.\n¬Drab(ansel) ::: Ansel is not drab.\n¬Wicked(montague) ::: Montague is not wicked.\n((Mushy(montague) ∧ ¬Wicked(katelynn))) → ((¬Aggressive(ansel))) ::: Montague being mushy and Katelynn being not wicked imply that Ansel is not aggressive.\n((BroadMinded(joseph))) ↔ ((¬Impossible(joseph))) ::: Joseph is broad-minded if and only if Joseph is not impossible.\n(∃x (¬Mushy(x))) → ((¬Aggressive(whitney) ∧ Impossible(cyril))) ::: If there is at least one people who is not mushy, then Whitney is not aggressive and Cyril is impossible.\n(∃x (BroadMinded(x) ∨ Impossible(x))) → ((Aggressive(olive))) ::: If there is someone who is either broad-minded or impossible, then Olive is aggressive.\n¬∃x((¬BroadMinded(x)∧Aggressive(x))) ::: If there is nobody who is not, then Cyril is not broad-minded and Ansel is aggressive.\n((Wicked(olive) ∧ Drab(katelynn))) ↔ ((Aggressive(joseph) ∧ ¬BroadMinded(montague))) ::: Olive is wicked and Katelynn is drab if and only if Joseph is aggressive and Montague is not broad-minded.\n(∃x (Mushy(x))) → ((BroadMinded(katelynn) ∧ ¬Aggressive(joseph))) ::: If there is at least one people who is mushy, then Katelynn is broad-minded and Joseph is not aggressive.\n((Wicked(olive) ∨ BroadMinded(cyril))) → ((Aggressive(katelynn))) ::: Olive being wicked or Cyril being broad-minded implies that Katelynn is aggressive.\n(∃x (Wicked(x) ∧ ¬Mushy(x))) → ((¬Drab(montague))) ::: If there is someone who is both wicked and not mushy, then Montague is not drab.\n((¬Impossible(whitney))) → ((¬Mushy(cyril) ∧ BroadMinded(joseph))) ::: Whitney being not impossible implies that Cyril is not mushy and Joseph is broad-minded.\n(∀x (¬Aggressive(x))) ↔ (∀x (¬Impossible(x))) ::: Someone is not aggressive if and only if he is not impossible.\n(∀x (Aggressive(x) ∧ ¬Drab(x))) ↔ (∀x (¬Impossible(x))) ::: Someone is aggressive and not drab if and only if he is not impossible.\n",
                "First-Order-Logic Question": "Impossible(ansel) ::: Ansel is impossible."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬x)) → ((¬BroadMinded(cyril) ∧ Aggressive(ansel))) ::: If there is nobody who is not, then Cyril is not broad-minded and Ansel is aggressive.",
                    "gram": "¬∃x((¬BroadMinded(x)∧Aggressive(x))) ::: If there is nobody who is not, then Cyril is not broad-minded and Ansel is aggressive."
                }
            ],
            "answer": "C",
            "grammar_answer": "B",
            "backup_answer": "B"
        },
        {
            "id": 567,
            "raw_prog": {
                "First-Order-Logic Rules": "Aggressive(montague) ::: Montague is aggressive.\nImpossible(ansel) ::: Ansel is impossible.\n¬Wicked(cyril) ::: Cyril is not wicked.\n¬Wicked(ansel) ::: Ansel is not wicked.\nDrab(katelynn) ::: Katelynn is drab.\n¬Drab(montague) ::: Montague is not drab.\n¬Mushy(ansel) ::: Ansel is not mushy.\n¬Wicked(joseph) ::: Joseph is not wicked.\nBroadMinded(joseph) ::: Joseph is broad-minded.\nDrab(olive) ::: Olive is drab.\n¬Drab(ansel) ::: Ansel is not drab.\n¬Wicked(montague) ::: Montague is not wicked.\n((Mushy(montague) ∧ ¬Wicked(katelynn))) → (¬Aggressive(ansel)) ::: Montague being mushy and Katelynn being not wicked imply that Ansel is not aggressive.\n(BroadMinded(joseph)) ↔ (¬Impossible(joseph)) ::: Joseph is broad-minded if and only if Joseph is not impossible.\n(∃x (¬Mushy(x))) → ((¬Aggressive(whitney) ∧ Impossible(cyril))) ::: If there is at least one people who is not mushy, then Whitney is not aggressive and Cyril is impossible.\n(∃x (BroadMinded(x) ∨ Impossible(x))) → ((Aggressive(olive))) ::: If there is someone who is either broad-minded or impossible, then Olive is aggressive.\n(¬∃x (¬x)) → ((¬BroadMinded(cyril) ∧ Aggressive(ansel))) ::: If there is nobody who is not, then Cyril is not broad-minded and Ansel is aggressive.\n((Wicked(olive) ∧ Drab(katelynn))) ↔ ((Aggressive(joseph) ∧ ¬BroadMinded(montague))) ::: Olive is wicked and Katelynn is drab if and only if Joseph is aggressive and Montague is not broad-minded.\n(∃x (Mushy(x))) → ((BroadMinded(katelynn) ∧ ¬Aggressive(joseph))) ::: If there is at least one people who is mushy, then Katelynn is broad-minded and Joseph is not aggressive.\n((Wicked(olive) ∨ BroadMinded(cyril))) → ((Aggressive(katelynn))) ::: Olive being wicked or Cyril being broad-minded implies that Katelynn is aggressive.\n(∃x (Wicked(x) ∧ ¬Mushy(x))) → ((¬Drab(montague))) ::: If there is someone who is both wicked and not mushy, then Montague is not drab.\n(¬Impossible(whitney)) → ((¬Mushy(cyril) ∧ BroadMinded(joseph))) ::: Whitney being not impossible implies that Cyril is not mushy and Joseph is broad-minded.\n(∀x (¬Aggressive(x))) ↔ (∀x (¬Impossible(x))) ::: Someone is not aggressive if and only if he is not impossible.\n(∀x (Aggressive(x) ∧ ¬Drab(x))) ↔ (∀x (¬Impossible(x))) ::: Someone is aggressive and not drab if and only if he is not impossible.\n",
                "First-Order-Logic Question": "¬BroadMinded(olive) ::: Olive is not broad-minded."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "Aggressive(montague) ::: Montague is aggressive.\nImpossible(ansel) ::: Ansel is impossible.\n¬Wicked(cyril) ::: Cyril is not wicked.\n¬Wicked(ansel) ::: Ansel is not wicked.\nDrab(katelynn) ::: Katelynn is drab.\n¬Drab(montague) ::: Montague is not drab.\n¬Mushy(ansel) ::: Ansel is not mushy.\n¬Wicked(joseph) ::: Joseph is not wicked.\nBroadMinded(joseph) ::: Joseph is broad-minded.\nDrab(olive) ::: Olive is drab.\n¬Drab(ansel) ::: Ansel is not drab.\n¬Wicked(montague) ::: Montague is not wicked.\n((Mushy(montague) ∧ ¬Wicked(katelynn))) → (¬Aggressive(ansel)) ::: Montague being mushy and Katelynn being not wicked imply that Ansel is not aggressive.\n(BroadMinded(joseph)) ↔ (¬Impossible(joseph)) ::: Joseph is broad-minded if and only if Joseph is not impossible.\n(∃x (¬Mushy(x))) → ((¬Aggressive(whitney) ∧ Impossible(cyril))) ::: If there is at least one people who is not mushy, then Whitney is not aggressive and Cyril is impossible.\n(∃x (BroadMinded(x) ∨ Impossible(x))) → ((Aggressive(olive))) ::: If there is someone who is either broad-minded or impossible, then Olive is aggressive.\n¬∃x((¬BroadMinded(x)∧Aggressive(x))) ::: If there is nobody who is not, then Cyril is not broad-minded and Ansel is aggressive.\n((Wicked(olive) ∧ Drab(katelynn))) ↔ ((Aggressive(joseph) ∧ ¬BroadMinded(montague))) ::: Olive is wicked and Katelynn is drab if and only if Joseph is aggressive and Montague is not broad-minded.\n(∃x (Mushy(x))) → ((BroadMinded(katelynn) ∧ ¬Aggressive(joseph))) ::: If there is at least one people who is mushy, then Katelynn is broad-minded and Joseph is not aggressive.\n((Wicked(olive) ∨ BroadMinded(cyril))) → ((Aggressive(katelynn))) ::: Olive being wicked or Cyril being broad-minded implies that Katelynn is aggressive.\n(∃x (Wicked(x) ∧ ¬Mushy(x))) → ((¬Drab(montague))) ::: If there is someone who is both wicked and not mushy, then Montague is not drab.\n(¬Impossible(whitney)) → ((¬Mushy(cyril) ∧ BroadMinded(joseph))) ::: Whitney being not impossible implies that Cyril is not mushy and Joseph is broad-minded.\n(∀x (¬Aggressive(x))) ↔ (∀x (¬Impossible(x))) ::: Someone is not aggressive if and only if he is not impossible.\n(∀x (Aggressive(x) ∧ ¬Drab(x))) ↔ (∀x (¬Impossible(x))) ::: Someone is aggressive and not drab if and only if he is not impossible.\n",
                "First-Order-Logic Question": "¬BroadMinded(olive) ::: Olive is not broad-minded."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬x)) → ((¬BroadMinded(cyril) ∧ Aggressive(ansel))) ::: If there is nobody who is not, then Cyril is not broad-minded and Ansel is aggressive.",
                    "gram": "¬∃x((¬BroadMinded(x)∧Aggressive(x))) ::: If there is nobody who is not, then Cyril is not broad-minded and Ansel is aggressive."
                }
            ],
            "answer": "A",
            "grammar_answer": "A",
            "backup_answer": "C"
        },
        {
            "id": 568,
            "raw_prog": {
                "First-Order-Logic Rules": "Aggressive(montague) ::: Montague is aggressive.\nImpossible(ansel) ::: Ansel is impossible.\n¬Wicked(cyril) ::: Cyril is not wicked.\n¬Wicked(ansel) ::: Ansel is not wicked.\nDrab(katelynn) ::: Katelynn is drab.\n¬Drab(montague) ::: Montague is not drab.\n¬Mushy(ansel) ::: Ansel is not mushy.\n¬Wicked(joseph) ::: Joseph is not wicked.\nBroadMinded(joseph) ::: Joseph is broad-minded.\nDrab(olive) ::: Olive is drab.\n¬Drab(ansel) ::: Ansel is not drab.\n¬Wicked(montague) ::: Montague is not wicked.\n((Mushy(montague) ∧ ¬Wicked(katelynn))) → (¬Aggressive(ansel)) ::: Montague being mushy and Katelynn being not wicked imply that Ansel is not aggressive.\n(BroadMinded(joseph)) ↔ (¬Impossible(joseph)) ::: Joseph is broad-minded if and only if Joseph is not impossible.\n(∃x (¬Mushy(x))) → ((¬Aggressive(whitney) ∧ Impossible(cyril))) ::: If there is at least one people who is not mushy, then Whitney is not aggressive and Cyril is impossible.\n(∃x (BroadMinded(x) ∨ Impossible(x))) → (Aggressive(olive)) ::: If there is someone who is either broad-minded or impossible, then Olive is aggressive.\n(∀x (¬x)) → ((¬BroadMinded(cyril) ∧ Aggressive(ansel))) ::: If there is nobody who is not, then Cyril is not broad-minded and Ansel is aggressive.\n((Wicked(olive) ∧ Drab(katelynn))) ↔ ((Aggressive(joseph) ∧ ¬BroadMinded(montague))) ::: Olive is wicked and Katelynn is drab if and only if Joseph is aggressive and Montague is not broad-minded.\n(∃x (Mushy(x))) → ((BroadMinded(katelynn) ∧ ¬Aggressive(joseph))) ::: If there is at least one people who is mushy, then Katelynn is broad-minded and Joseph is not aggressive.\n((Wicked(olive) ∨ BroadMinded(cyril))) → (Aggressive(katelynn)) ::: Olive being wicked or Cyril being broad-minded implies that Katelynn is aggressive.\n(∃x (Wicked(x) ∧ ¬Mushy(x))) → (¬Drab(montague)) ::: If there is someone who is both wicked and not mushy, then Montague is not drab.\n(¬Impossible(whitney)) → ((¬Mushy(cyril) ∧ BroadMinded(joseph))) ::: Whitney being not impossible implies that Cyril is not mushy and Joseph is broad-minded.\n(∀x (¬Aggressive(x))) ↔ (∀x (¬Impossible(x))) ::: Someone is not aggressive if and only if he is not impossible.\n(∀x (Aggressive(x) ∧ ¬Drab(x))) ↔ (∀x (¬Impossible(x))) ::: Someone is aggressive and not drab if and only if he is not impossible.\n",
                "First-Order-Logic Question": "¬Wicked(montague) ::: Montague is not wicked."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "Aggressive(montague) ::: Montague is aggressive.\nImpossible(ansel) ::: Ansel is impossible.\n¬Wicked(cyril) ::: Cyril is not wicked.\n¬Wicked(ansel) ::: Ansel is not wicked.\nDrab(katelynn) ::: Katelynn is drab.\n¬Drab(montague) ::: Montague is not drab.\n¬Mushy(ansel) ::: Ansel is not mushy.\n¬Wicked(joseph) ::: Joseph is not wicked.\nBroadMinded(joseph) ::: Joseph is broad-minded.\nDrab(olive) ::: Olive is drab.\n¬Drab(ansel) ::: Ansel is not drab.\n¬Wicked(montague) ::: Montague is not wicked.\n((Mushy(montague) ∧ ¬Wicked(katelynn))) → (¬Aggressive(ansel)) ::: Montague being mushy and Katelynn being not wicked imply that Ansel is not aggressive.\n(BroadMinded(joseph)) ↔ (¬Impossible(joseph)) ::: Joseph is broad-minded if and only if Joseph is not impossible.\n(∃x (¬Mushy(x))) → ((¬Aggressive(whitney) ∧ Impossible(cyril))) ::: If there is at least one people who is not mushy, then Whitney is not aggressive and Cyril is impossible.\n(∃x (BroadMinded(x) ∨ Impossible(x))) → (Aggressive(olive)) ::: If there is someone who is either broad-minded or impossible, then Olive is aggressive.\n¬(¬BroadMinded(x))→((¬Aggressive(x))) ::: If there is nobody who is not, then Cyril is not broad-minded and Ansel is aggressive.\n((Wicked(olive) ∧ Drab(katelynn))) ↔ ((Aggressive(joseph) ∧ ¬BroadMinded(montague))) ::: Olive is wicked and Katelynn is drab if and only if Joseph is aggressive and Montague is not broad-minded.\n(∃x (Mushy(x))) → ((BroadMinded(katelynn) ∧ ¬Aggressive(joseph))) ::: If there is at least one people who is mushy, then Katelynn is broad-minded and Joseph is not aggressive.\n((Wicked(olive) ∨ BroadMinded(cyril))) → (Aggressive(katelynn)) ::: Olive being wicked or Cyril being broad-minded implies that Katelynn is aggressive.\n(∃x (Wicked(x) ∧ ¬Mushy(x))) → (¬Drab(montague)) ::: If there is someone who is both wicked and not mushy, then Montague is not drab.\n(¬Impossible(whitney)) → ((¬Mushy(cyril) ∧ BroadMinded(joseph))) ::: Whitney being not impossible implies that Cyril is not mushy and Joseph is broad-minded.\n(∀x (¬Aggressive(x))) ↔ (∀x (¬Impossible(x))) ::: Someone is not aggressive if and only if he is not impossible.\n(∀x (Aggressive(x) ∧ ¬Drab(x))) ↔ (∀x (¬Impossible(x))) ::: Someone is aggressive and not drab if and only if he is not impossible.\n",
                "First-Order-Logic Question": "¬Wicked(montague) ::: Montague is not wicked."
            },
            "diff": [
                {
                    "raw": "(∀x (¬x)) → ((¬BroadMinded(cyril) ∧ Aggressive(ansel))) ::: If there is nobody who is not, then Cyril is not broad-minded and Ansel is aggressive.",
                    "gram": "¬(¬BroadMinded(x))→((¬Aggressive(x))) ::: If there is nobody who is not, then Cyril is not broad-minded and Ansel is aggressive."
                }
            ],
            "answer": "B",
            "grammar_answer": "B",
            "backup_answer": "A"
        },
        {
            "id": 569,
            "raw_prog": {
                "First-Order-Logic Rules": "Aggressive(montague) ::: Montague is aggressive.\nImpossible(ansel) ::: Ansel is impossible.\n¬Wicked(cyril) ::: Cyril is not wicked.\n¬Wicked(ansel) ::: Ansel is not wicked.\nDrab(katelynn) ::: Katelynn is drab.\n¬Drab(montague) ::: Montague is not drab.\n¬Mushy(ansel) ::: Ansel is not mushy.\n¬Wicked(joseph) ::: Joseph is not wicked.\nBroadMinded(joseph) ::: Joseph is broad-minded.\nDrab(olive) ::: Olive is drab.\n¬Drab(ansel) ::: Ansel is not drab.\n¬Wicked(montague) ::: Montague is not wicked.\n((Mushy(montague) ∧ ¬Wicked(katelynn))) → (¬Aggressive(ansel)) ::: Montague being mushy and Katelynn being not wicked imply that Ansel is not aggressive.\n(BroadMinded(joseph)) ↔ (¬Impossible(joseph)) ::: Joseph is broad-minded if and only if Joseph is not impossible.\n(∃x (¬Mushy(x))) → ((¬Aggressive(whitney) ∧ Impossible(cyril))) ::: If there is at least one people who is not mushy, then Whitney is not aggressive and Cyril is impossible.\n(∃x (BroadMinded(x) ∨ Impossible(x))) → (Aggressive(olive)) ::: If there is someone who is either broad-minded or impossible, then Olive is aggressive.\n(∀x (¬x)) → ((¬BroadMinded(cyril) ∧ Aggressive(ansel))) ::: If there is nobody who is not, then Cyril is not broad-minded and Ansel is aggressive.\n((Wicked(olive) ∧ Drab(katelynn))) ↔ ((Aggressive(joseph) ∧ ¬BroadMinded(montague))) ::: Olive is wicked and Katelynn is drab if and only if Joseph is aggressive and Montague is not broad-minded.\n(∃x (Mushy(x))) → ((BroadMinded(katelynn) ∧ ¬Aggressive(joseph))) ::: If there is at least one people who is mushy, then Katelynn is broad-minded and Joseph is not aggressive.\n((Wicked(olive) ∨ BroadMinded(cyril))) → (Aggressive(katelynn)) ::: Olive being wicked or Cyril being broad-minded implies that Katelynn is aggressive.\n(∃x (Wicked(x) ∧ ¬Mushy(x))) → (¬Drab(montague)) ::: If there is someone who is both wicked and not mushy, then Montague is not drab.\n(¬Impossible(whitney)) → ((¬Mushy(cyril) ∧ BroadMinded(joseph))) ::: Whitney being not impossible implies that Cyril is not mushy and Joseph is broad-minded.\n(∀x (¬Aggressive(x))) ↔ (∀x (¬Impossible(x))) ::: Someone is not aggressive if and only if he is not impossible.\n(∀x (Aggressive(x) ∧ ¬Drab(x))) ↔ (∀x (¬Impossible(x))) ::: Someone is aggressive and not drab if and only if he is not impossible.\n",
                "First-Order-Logic Question": "Wicked(joseph) ::: Joseph is wicked."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "Aggressive(montague) ::: Montague is aggressive.\nImpossible(ansel) ::: Ansel is impossible.\n¬Wicked(cyril) ::: Cyril is not wicked.\n¬Wicked(ansel) ::: Ansel is not wicked.\nDrab(katelynn) ::: Katelynn is drab.\n¬Drab(montague) ::: Montague is not drab.\n¬Mushy(ansel) ::: Ansel is not mushy.\n¬Wicked(joseph) ::: Joseph is not wicked.\nBroadMinded(joseph) ::: Joseph is broad-minded.\nDrab(olive) ::: Olive is drab.\n¬Drab(ansel) ::: Ansel is not drab.\n¬Wicked(montague) ::: Montague is not wicked.\n((Mushy(montague) ∧ ¬Wicked(katelynn))) → (¬Aggressive(ansel)) ::: Montague being mushy and Katelynn being not wicked imply that Ansel is not aggressive.\n(BroadMinded(joseph)) ↔ (¬Impossible(joseph)) ::: Joseph is broad-minded if and only if Joseph is not impossible.\n(∃x (¬Mushy(x))) → ((¬Aggressive(whitney) ∧ Impossible(cyril))) ::: If there is at least one people who is not mushy, then Whitney is not aggressive and Cyril is impossible.\n(∃x (BroadMinded(x) ∨ Impossible(x))) → (Aggressive(olive)) ::: If there is someone who is either broad-minded or impossible, then Olive is aggressive.\n¬(¬BroadMinded(x))→((¬Aggressive(x))) ::: If there is nobody who is not, then Cyril is not broad-minded and Ansel is aggressive.\n((Wicked(olive) ∧ Drab(katelynn))) ↔ ((Aggressive(joseph) ∧ ¬BroadMinded(montague))) ::: Olive is wicked and Katelynn is drab if and only if Joseph is aggressive and Montague is not broad-minded.\n(∃x (Mushy(x))) → ((BroadMinded(katelynn) ∧ ¬Aggressive(joseph))) ::: If there is at least one people who is mushy, then Katelynn is broad-minded and Joseph is not aggressive.\n((Wicked(olive) ∨ BroadMinded(cyril))) → (Aggressive(katelynn)) ::: Olive being wicked or Cyril being broad-minded implies that Katelynn is aggressive.\n(∃x (Wicked(x) ∧ ¬Mushy(x))) → (¬Drab(montague)) ::: If there is someone who is both wicked and not mushy, then Montague is not drab.\n(¬Impossible(whitney)) → ((¬Mushy(cyril) ∧ BroadMinded(joseph))) ::: Whitney being not impossible implies that Cyril is not mushy and Joseph is broad-minded.\n(∀x (¬Aggressive(x))) ↔ (∀x (¬Impossible(x))) ::: Someone is not aggressive if and only if he is not impossible.\n(∀x (Aggressive(x) ∧ ¬Drab(x))) ↔ (∀x (¬Impossible(x))) ::: Someone is aggressive and not drab if and only if he is not impossible.\n",
                "First-Order-Logic Question": "Wicked(joseph) ::: Joseph is wicked."
            },
            "diff": [
                {
                    "raw": "(∀x (¬x)) → ((¬BroadMinded(cyril) ∧ Aggressive(ansel))) ::: If there is nobody who is not, then Cyril is not broad-minded and Ansel is aggressive.",
                    "gram": "¬(¬BroadMinded(x))→((¬Aggressive(x))) ::: If there is nobody who is not, then Cyril is not broad-minded and Ansel is aggressive."
                }
            ],
            "answer": "C",
            "grammar_answer": "C",
            "backup_answer": "B"
        },
        {
            "id": 767,
            "raw_prog": {
                "First-Order-Logic Rules": "¬Hollow(graciela) ::: Graciela is not hollow.\nStrong(lancelot) ::: Lancelot is strong.\nStrong(graciela) ::: Graciela is strong.\n¬Strong(roderick) ::: Roderick is not strong.\nBusy(roderick) ::: Roderick is busy.\nCareful(conrad) ::: Conrad is careful.\nPutrid(conrad) ::: Conrad is putrid.\n¬Careful(lancelot) ::: Lancelot is not careful.\n¬Strong(sandra) ::: Sandra is not strong.\nWonderful(graciela) ::: Graciela is wonderful.\nStrong(molly) ::: Molly is strong.\n(∀x (Hollow(x) ∨ ¬Strong(x))) → (∀x (¬Putrid(x) ∧ ¬Careful(x))) ::: Someone who is hollow or not strong is always not putrid and not careful.\n(∀x (Wonderful(x) ∧ ¬Strong(x))) ↔ (∀x (¬Hollow(x))) ::: If someone is wonderful and not strong, then he is not hollow, and vice versa.\n(∀x (Putrid(x))) ↔ (∀x (Busy(x))) ::: If someone is putrid, then he is busy, and vice versa.\n(∀x (Careful(x))) → (∀x (¬Putrid(x))) ::: If someone is careful, then he is not putrid.\n(∀x (¬Busy(x) ∧ ¬Careful(x))) ↔ (∀x (Wonderful(x) ∧ ¬Hollow(x))) ::: Someone being neither busy nor careful is equivalent to being wonderful and not hollow.\n((¬Strong(sandra))) → ((¬Wonderful(whitney))) ::: Sandra being not strong implies that Whitney is not wonderful.\n(∀x (Hollow(x) ∨ ¬Strong(x))) → (∀x (¬Wonderful(x))) ::: If someone is hollow or not strong, then he is not wonderful.\n(∃x (¬Wonderful(x))) → ((Busy(conrad))) ::: If there is at least one people who is not wonderful, then Conrad is busy.\n(∀x (¬Hollow(x) ∧ ¬Busy(x))) ↔ (∀x (Putrid(x))) ::: Someone is not hollow and not busy if and only if he is putrid.\n(∀x (¬Putrid(x) ∨ Busy(x))) → (∀x (Careful(x))) ::: If someone is not putrid or busy, then he is careful.\n((Putrid(graciela) ∧ ¬Careful(lancelot))) → ((¬Hollow(graciela))) ::: Graciela being putrid and Lancelot being not careful imply that Graciela is not hollow.\n((Hollow(lancelot))) ↔ ((¬Careful(sandra) ∧ Wonderful(molly))) ::: Lancelot is hollow if and only if Sandra is not careful and Molly is wonderful.\n",
                "First-Order-Logic Question": "¬Wonderful(whitney) ::: Whitney is not wonderful."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "¬Hollow(graciela) ::: Graciela is not hollow.\nStrong(lancelot) ::: Lancelot is strong.\nStrong(graciela) ::: Graciela is strong.\n¬Strong(roderick) ::: Roderick is not strong.\nBusy(roderick) ::: Roderick is busy.\nCareful(conrad) ::: Conrad is careful.\nPutrid(conrad) ::: Conrad is putrid.\n¬Careful(lancelot) ::: Lancelot is not careful.\n¬Strong(sandra) ::: Sandra is not strong.\nWonderful(graciela) ::: Graciela is wonderful.\nStrong(molly) ::: Molly is strong.\n(∀x (Hollow(x) ∨ ¬Strong(x))) → (∀x (¬Putrid(x) ∧ ¬Careful(x))) ::: Someone who is hollow or not strong is always not putrid and not careful.\n(∀x (Wonderful(x) ∧ ¬Strong(x))) ↔ (∀x (¬Hollow(x))) ::: If someone is wonderful and not strong, then he is not hollow, and vice versa.\n(∀x (Putrid(x))) ↔ (∀x (Busy(x))) ::: If someone is putrid, then he is busy, and vice versa.\n(∀x (Careful(x))) → (∀x (¬Putrid(x))) ::: If someone is careful, then he is not putrid.\n(∀x (¬Busy(x) ∧ ¬Careful(x))) ↔ (∀x (Wonderful(x) ∧ ¬Hollow(x))) ::: Someone being neither busy nor careful is equivalent to being wonderful and not hollow.\n((¬Strong(sandra))) → ((¬Wonderful(whitney))) ::: Sandra being not strong implies that Whitney is not wonderful.\n(∀x (Hollow(x) ∨ ¬Strong(x))) → (∀x (¬Wonderful(x))) ::: If someone is hollow or not strong, then he is not wonderful.\n(∃x (¬Wonderful(x))) → ((Busy(conrad))) ::: If there is at least one people who is not wonderful, then Conrad is busy.\n(∀x (¬Hollow(x) ∧ ¬Busy(x))) ↔ (∀x (Putrid(x))) ::: Someone is not hollow and not busy if and only if he is putrid.\n(∀x (¬Putrid(x) ∨ Busy(x))) → (∀x (Careful(x))) ::: If someone is not putrid or busy, then he is careful.\n((Putrid(graciela) ∧ ¬Careful(lancelot))) → ((¬Hollow(graciela))) ::: Graciela being putrid and Lancelot being not careful imply that Graciela is not hollow.\n((Hollow(lancelot))) ↔ ((¬Careful(sandra) ∧ Wonderful(molly))) ::: Lancelot is hollow if and only if Sandra is not careful and Molly is wonderful.\n",
                "First-Order-Logic Question": "¬Wonderful(whitney) ::: Whitney is not wonderful."
            },
            "diff": [],
            "answer": "C",
            "grammar_answer": "C",
            "backup_answer": "A"
        },
        {
            "id": 780,
            "raw_prog": {
                "First-Order-Logic Rules": "Octagonal(owen) ::: Owen is octagonal.\n¬Sour(molly) ::: Molly is not sour.\n¬Significant(owen) ::: Owen is not significant.\n¬Wild(tristan) ::: Tristan is not wild.\nSignificant(luther) ::: Luther is significant.\n¬Wild(adam) ::: Adam is not wild.\n¬Wonderful(adam) ::: Adam is not wonderful.\nSour(morgan) ::: Morgan is sour.\nSour(tristan) ::: Tristan is sour.\nSour(godwin) ::: Godwin is sour.\nWonderful(owen) ::: Owen is wonderful.\n¬Wild(molly) ::: Molly is not wild.\n(∀x (Putrid(x) ∧ ¬Sour(x))) ↔ (∀x (Octagonal(x) ∧ ¬Wonderful(x))) ::: Someone is putrid and not sour if and only if he is octagonal and not wonderful.\n(¬∃x (¬Significant(x))) → (Significant(owen)) ::: If there is nobody who is not significant, then Owen is significant.\n(∀x (Significant(x))) ↔ (∀x (¬Wonderful(x))) ::: Someone is significant if and only if he is not wonderful.\n(∃x (¬Significant(x))) → ((¬Putrid(godwin) ∧ Wild(molly))) ::: If there is at least one people who is not significant, then Godwin is not putrid and Molly is wild.\n(∀x (Wonderful(x) ∨ Sour(x))) → (∀x (Wild(x))) ::: If someone is wonderful or he is sour, then he is wild.\n((Putrid(owen))) → ((¬Octagonal(molly) ∧ ¬Wonderful(adam))) ::: Owen being putrid implies that Molly is not octagonal and Adam is not wonderful.\n(∀x (¬Sour(x))) → (∀x (¬Significant(x))) ::: All not sour people are not significant.\n(∀x (¬Significant(x))) → ((Wonderful(godwin) ∧ ¬Octagonal(luther))) ::: If everyone is not significant, then Godwin is wonderful and Luther is not octagonal.\n(∀x (Wild(x))) → (∀x (Wonderful(x))) ::: If someone is wild, then he is wonderful.\n(∃x (Wild(x))) → ((Octagonal(godwin) ∧ Sour(morgan))) ::: If there is someone who is wild, then Godwin is octagonal and Morgan is sour.\n(∀x (¬Wonderful(x) ∧ ¬Putrid(x))) ↔ (∀x (Wild(x))) ::: Someone is not wonderful and not putrid if and only if he is wild.\n((Sour(molly) ∧ ¬Wild(molly))) → (¬Wonderful(owen)) ::: It can be concluded that Owen is not wonderful once knowing that Molly is sour and Molly is not wild.\n",
                "First-Order-Logic Question": "¬Wonderful(luther) ::: Luther is not wonderful."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "Octagonal(owen) ::: Owen is octagonal.\n¬Sour(molly) ::: Molly is not sour.\n¬Significant(owen) ::: Owen is not significant.\n¬Wild(tristan) ::: Tristan is not wild.\nSignificant(luther) ::: Luther is significant.\n¬Wild(adam) ::: Adam is not wild.\n¬Wonderful(adam) ::: Adam is not wonderful.\nSour(morgan) ::: Morgan is sour.\nSour(tristan) ::: Tristan is sour.\nSour(godwin) ::: Godwin is sour.\nWonderful(owen) ::: Owen is wonderful.\n¬Wild(molly) ::: Molly is not wild.\n(∀x (Putrid(x) ∧ ¬Sour(x))) ↔ (∀x (Octagonal(x) ∧ ¬Wonderful(x))) ::: Someone is putrid and not sour if and only if he is octagonal and not wonderful.\n¬∃x(¬Significant(x))→Significant(x) ::: If there is nobody who is not significant, then Owen is significant.\n(∀x (Significant(x))) ↔ (∀x (¬Wonderful(x))) ::: Someone is significant if and only if he is not wonderful.\n(∃x (¬Significant(x))) → ((¬Putrid(godwin) ∧ Wild(molly))) ::: If there is at least one people who is not significant, then Godwin is not putrid and Molly is wild.\n(∀x (Wonderful(x) ∨ Sour(x))) → (∀x (Wild(x))) ::: If someone is wonderful or he is sour, then he is wild.\n((Putrid(owen))) → ((¬Octagonal(molly) ∧ ¬Wonderful(adam))) ::: Owen being putrid implies that Molly is not octagonal and Adam is not wonderful.\n(∀x (¬Sour(x))) → (∀x (¬Significant(x))) ::: All not sour people are not significant.\n(∀x (¬Significant(x))) → ((Wonderful(godwin) ∧ ¬Octagonal(luther))) ::: If everyone is not significant, then Godwin is wonderful and Luther is not octagonal.\n(∀x (Wild(x))) → (∀x (Wonderful(x))) ::: If someone is wild, then he is wonderful.\n(∃x (Wild(x))) → ((Octagonal(godwin) ∧ Sour(morgan))) ::: If there is someone who is wild, then Godwin is octagonal and Morgan is sour.\n(∀x (¬Wonderful(x) ∧ ¬Putrid(x))) ↔ (∀x (Wild(x))) ::: Someone is not wonderful and not putrid if and only if he is wild.\n((Sour(molly) ∧ ¬Wild(molly))) → (¬Wonderful(owen)) ::: It can be concluded that Owen is not wonderful once knowing that Molly is sour and Molly is not wild.\n",
                "First-Order-Logic Question": "¬Wonderful(luther) ::: Luther is not wonderful."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬Significant(x))) → (Significant(owen)) ::: If there is nobody who is not significant, then Owen is significant.",
                    "gram": "¬∃x(¬Significant(x))→Significant(x) ::: If there is nobody who is not significant, then Owen is significant."
                }
            ],
            "answer": "A",
            "grammar_answer": "A",
            "backup_answer": "A"
        },
        {
            "id": 781,
            "raw_prog": {
                "First-Order-Logic Rules": [
                    "Octagonal(owen) ::: Owen is octagonal.",
                    "¬Sour(molly) ::: Molly is not sour.",
                    "¬Significant(owen) ::: Owen is not significant.",
                    "¬Wild(tristan) ::: Tristan is not wild.",
                    "Significant(luther) ::: Luther is significant.",
                    "¬Wild(adam) ::: Adam is not wild.",
                    "¬Wonderful(adam) ::: Adam is not wonderful.",
                    "Sour(morgan) ::: Morgan is sour.",
                    "Sour(tristan) ::: Tristan is sour.",
                    "Sour(godwin) ::: Godwin is sour.",
                    "Wonderful(owen) ::: Owen is wonderful.",
                    "¬Wild(molly) ::: Molly is not wild.",
                    "(∀x (Putrid(x) ∧ ¬Sour(x))) ↔ (∀x (Octagonal(x) ∧ ¬Wonderful(x))) ::: Someone is putrid and not sour if and only if he is octagonal and not wonderful.",
                    "(¬∃x (¬Significant(x))) → (Significant(owen)) ::: If there is nobody who is not significant, then Owen is significant.",
                    "(∀x (Significant(x))) ↔ (∀x (¬Wonderful(x))) ::: Someone is significant if and only if he is not wonderful.",
                    "(∃x (¬Significant(x))) → ((¬Putrid(godwin) ∧ Wild(molly))) ::: If there is at least one people who is not significant, then Godwin is not putrid and Molly is wild.",
                    "(∀x (Wonderful(x) ∨ Sour(x))) → (∀x (Wild(x))) ::: If someone is wonderful or he is sour, then he is wild.",
                    "(Putrid(owen)) → ((¬Octagonal(molly) ∧ ¬Wonderful(adam))) ::: Owen being putrid implies that Molly is not octagonal and Adam is not wonderful.",
                    "(∀x (¬Sour(x))) → (∀x (¬Significant(x))) ::: All not sour people are not significant.",
                    "(∀x (¬Significant(x))) → ((Wonderful(godwin) ∧ ¬Octagonal(luther))) ::: If everyone is not significant, then Godwin is wonderful and Luther is not octagonal.",
                    "(∀x (Wild(x))) → (∀x (Wonderful(x))) ::: If someone is wild, then he is wonderful.",
                    "(∃x (Wild(x))) → ((Octagonal(godwin) ∧ Sour(morgan))) ::: If there is someone who is wild, then Godwin is octagonal and Morgan is sour.",
                    "(∀x (¬Wonderful(x) ∧ ¬Putrid(x))) ↔ (∀x (Wild(x))) ::: Someone is not wonderful and not putrid if and only if he is wild.",
                    "((Sour(molly) ∧ ¬Wild(molly))) → (¬Wonderful(owen)) ::: It can be concluded that Owen is not wonderful once knowing that Molly is sour and Molly is not wild."
                ],
                "First-Order-Logic Question": "¬Wonderful(adam) ::: Adam is not wonderful."
            },
            "gram_prog": {
                "First-Order-Logic Rules": [
                    "Octagonal(owen) ::: Owen is octagonal.",
                    "¬Sour(molly) ::: Molly is not sour.",
                    "¬Significant(owen) ::: Owen is not significant.",
                    "¬Wild(tristan) ::: Tristan is not wild.",
                    "Significant(luther) ::: Luther is significant.",
                    "¬Wild(adam) ::: Adam is not wild.",
                    "¬Wonderful(adam) ::: Adam is not wonderful.",
                    "Sour(morgan) ::: Morgan is sour.",
                    "Sour(tristan) ::: Tristan is sour.",
                    "Sour(godwin) ::: Godwin is sour.",
                    "Wonderful(owen) ::: Owen is wonderful.",
                    "¬Wild(molly) ::: Molly is not wild.",
                    "(∀x (Putrid(x) ∧ ¬Sour(x))) ↔ (∀x (Octagonal(x) ∧ ¬Wonderful(x))) ::: Someone is putrid and not sour if and only if he is octagonal and not wonderful.",
                    "¬∃x(¬Significant(x))→Significant(x) ::: If there is nobody who is not significant, then Owen is significant.",
                    "(∀x (Significant(x))) ↔ (∀x (¬Wonderful(x))) ::: Someone is significant if and only if he is not wonderful.",
                    "(∃x (¬Significant(x))) → ((¬Putrid(godwin) ∧ Wild(molly))) ::: If there is at least one people who is not significant, then Godwin is not putrid and Molly is wild.",
                    "(∀x (Wonderful(x) ∨ Sour(x))) → (∀x (Wild(x))) ::: If someone is wonderful or he is sour, then he is wild.",
                    "(Putrid(owen)) → ((¬Octagonal(molly) ∧ ¬Wonderful(adam))) ::: Owen being putrid implies that Molly is not octagonal and Adam is not wonderful.",
                    "(∀x (¬Sour(x))) → (∀x (¬Significant(x))) ::: All not sour people are not significant.",
                    "(∀x (¬Significant(x))) → ((Wonderful(godwin) ∧ ¬Octagonal(luther))) ::: If everyone is not significant, then Godwin is wonderful and Luther is not octagonal.",
                    "(∀x (Wild(x))) → (∀x (Wonderful(x))) ::: If someone is wild, then he is wonderful.",
                    "(∃x (Wild(x))) → ((Octagonal(godwin) ∧ Sour(morgan))) ::: If there is someone who is wild, then Godwin is octagonal and Morgan is sour.",
                    "(∀x (¬Wonderful(x) ∧ ¬Putrid(x))) ↔ (∀x (Wild(x))) ::: Someone is not wonderful and not putrid if and only if he is wild.",
                    "((Sour(molly) ∧ ¬Wild(molly))) → (¬Wonderful(owen)) ::: It can be concluded that Owen is not wonderful once knowing that Molly is sour and Molly is not wild."
                ],
                "First-Order-Logic Question": "¬Wonderful(adam) ::: Adam is not wonderful."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬Significant(x))) → (Significant(owen)) ::: If there is nobody who is not significant, then Owen is significant.",
                    "gram": "¬∃x(¬Significant(x))→Significant(x) ::: If there is nobody who is not significant, then Owen is significant."
                }
            ],
            "answer": "A",
            "grammar_answer": "A",
            "backup_answer": "A"
        },
        {
            "id": 782,
            "raw_prog": {
                "First-Order-Logic Rules": "Octagonal(owen) ::: Owen is octagonal.\n¬Sour(molly) ::: Molly is not sour.\n¬Significant(owen) ::: Owen is not significant.\n¬Wild(tristan) ::: Tristan is not wild.\nSignificant(luther) ::: Luther is significant.\n¬Wild(adam) ::: Adam is not wild.\n¬Wonderful(adam) ::: Adam is not wonderful.\nSour(morgan) ::: Morgan is sour.\nSour(tristan) ::: Tristan is sour.\nSour(godwin) ::: Godwin is sour.\nWonderful(owen) ::: Owen is wonderful.\n¬Wild(molly) ::: Molly is not wild.\n(∀x (Putrid(x) ∧ ¬Sour(x))) ↔ (∀x (Octagonal(x) ∧ ¬Wonderful(x))) ::: Someone is putrid and not sour if and only if he is octagonal and not wonderful.\n(¬∃x (¬x)) → (Significant(owen)) ::: If there is nobody who is not, then Owen is significant.\n(∀x (Significant(x))) ↔ (∀x (¬Wonderful(x))) ::: Someone is significant if and only if he is not wonderful.\n(∃x (¬Significant(x))) → ((¬Putrid(godwin) ∧ Wild(molly))) ::: If there is at least one people who is not significant, then Godwin is not putrid and Molly is wild.\n(∀x (Wonderful(x) ∨ Sour(x))) → (∀x (Wild(x))) ::: If someone is wonderful or he is sour, then he is wild.\n((Putrid(owen))) → ((¬Octagonal(molly) ∧ ¬Wonderful(adam))) ::: Owen being putrid implies that Molly is not octagonal and Adam is not wonderful.\n(∀x (¬Sour(x))) → (∀x (¬Significant(x))) ::: All not sour people are not significant.\n(∀x (¬Significant(x))) → ((Wonderful(godwin) ∧ ¬Octagonal(luther))) ::: If everyone is not significant, then Godwin is wonderful and Luther is not octagonal.\n(∀x (Wild(x))) → (∀x (Wonderful(x))) ::: If someone is wild, then he is wonderful.\n(∃x (Wild(x))) → ((Octagonal(godwin) ∧ Sour(morgan))) ::: If there is someone who is wild, then Godwin is octagonal and Morgan is sour.\n(∀x (¬Wonderful(x) ∧ ¬Putrid(x))) ↔ (∀x (Wild(x))) ::: Someone is not wonderful and not putrid if and only if he is wild.\n((Sour(molly) ∧ ¬Wild(molly))) → ((¬Wonderful(owen))) ::: It can be concluded that Owen is not wonderful once knowing that Molly is sour and Molly is not wild.\n",
                "First-Order-Logic Question": "Wild(morgan) ::: Morgan is wild."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "Octagonal(owen) ::: Owen is octagonal.\n¬Sour(molly) ::: Molly is not sour.\n¬Significant(owen) ::: Owen is not significant.\n¬Wild(tristan) ::: Tristan is not wild.\nSignificant(luther) ::: Luther is significant.\n¬Wild(adam) ::: Adam is not wild.\n¬Wonderful(adam) ::: Adam is not wonderful.\nSour(morgan) ::: Morgan is sour.\nSour(tristan) ::: Tristan is sour.\nSour(godwin) ::: Godwin is sour.\nWonderful(owen) ::: Owen is wonderful.\n¬Wild(molly) ::: Molly is not wild.\n(∀x (Putrid(x) ∧ ¬Sour(x))) ↔ (∀x (Octagonal(x) ∧ ¬Wonderful(x))) ::: Someone is putrid and not sour if and only if he is octagonal and not wonderful.\n¬∃x(¬(¬(Octagonal(x)))) ::: If there is nobody who is not, then Owen is significant.\n(∀x (Significant(x))) ↔ (∀x (¬Wonderful(x))) ::: Someone is significant if and only if he is not wonderful.\n(∃x (¬Significant(x))) → ((¬Putrid(godwin) ∧ Wild(molly))) ::: If there is at least one people who is not significant, then Godwin is not putrid and Molly is wild.\n(∀x (Wonderful(x) ∨ Sour(x))) → (∀x (Wild(x))) ::: If someone is wonderful or he is sour, then he is wild.\n((Putrid(owen))) → ((¬Octagonal(molly) ∧ ¬Wonderful(adam))) ::: Owen being putrid implies that Molly is not octagonal and Adam is not wonderful.\n(∀x (¬Sour(x))) → (∀x (¬Significant(x))) ::: All not sour people are not significant.\n(∀x (¬Significant(x))) → ((Wonderful(godwin) ∧ ¬Octagonal(luther))) ::: If everyone is not significant, then Godwin is wonderful and Luther is not octagonal.\n(∀x (Wild(x))) → (∀x (Wonderful(x))) ::: If someone is wild, then he is wonderful.\n(∃x (Wild(x))) → ((Octagonal(godwin) ∧ Sour(morgan))) ::: If there is someone who is wild, then Godwin is octagonal and Morgan is sour.\n(∀x (¬Wonderful(x) ∧ ¬Putrid(x))) ↔ (∀x (Wild(x))) ::: Someone is not wonderful and not putrid if and only if he is wild.\n((Sour(molly) ∧ ¬Wild(molly))) → ((¬Wonderful(owen))) ::: It can be concluded that Owen is not wonderful once knowing that Molly is sour and Molly is not wild.\n",
                "First-Order-Logic Question": "Wild(morgan) ::: Morgan is wild."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬x)) → (Significant(owen)) ::: If there is nobody who is not, then Owen is significant.",
                    "gram": "¬∃x(¬(¬(Octagonal(x)))) ::: If there is nobody who is not, then Owen is significant."
                }
            ],
            "answer": "C",
            "grammar_answer": "A",
            "backup_answer": "A"
        },
        {
            "id": 783,
            "raw_prog": {
                "First-Order-Logic Rules": "Octagonal(owen) ::: Owen is octagonal.\n¬Sour(molly) ::: Molly is not sour.\n¬Significant(owen) ::: Owen is not significant.\n¬Wild(tristan) ::: Tristan is not wild.\nSignificant(luther) ::: Luther is significant.\n¬Wild(adam) ::: Adam is not wild.\n¬Wonderful(adam) ::: Adam is not wonderful.\nSour(morgan) ::: Morgan is sour.\nSour(tristan) ::: Tristan is sour.\nSour(godwin) ::: Godwin is sour.\nWonderful(owen) ::: Owen is wonderful.\n¬Wild(molly) ::: Molly is not wild.\n(∀x (Putrid(x) ∧ ¬Sour(x))) ↔ (∀x (Octagonal(x) ∧ ¬Wonderful(x))) ::: Someone is putrid and not sour if and only if he is octagonal and not wonderful.\n(¬∃x (¬Significant(x))) → (Significant(owen)) ::: If there is nobody who is not significant, then Owen is significant.\n(∀x (Significant(x))) ↔ (∀x (¬Wonderful(x))) ::: Someone is significant if and only if he is not wonderful.\n(∃x (¬Significant(x))) → ((¬Putrid(godwin) ∧ Wild(molly))) ::: If there is at least one people who is not significant, then Godwin is not putrid and Molly is wild.\n(∀x (Wonderful(x) ∨ Sour(x))) → (∀x (Wild(x))) ::: If someone is wonderful or he is sour, then he is wild.\n((Putrid(owen))) → ((¬Octagonal(molly) ∧ ¬Wonderful(adam))) ::: Owen being putrid implies that Molly is not octagonal and Adam is not wonderful.\n(∀x (¬Sour(x))) → (∀x (¬Significant(x))) ::: All not sour people are not significant.\n(∀x (¬Significant(x))) → ((Wonderful(godwin) ∧ ¬Octagonal(luther))) ::: If everyone is not significant, then Godwin is wonderful and Luther is not octagonal.\n(∀x (Wild(x))) → (∀x (Wonderful(x))) ::: If someone is wild, then he is wonderful.\n(∃x (Wild(x))) → ((Octagonal(godwin) ∧ Sour(morgan))) ::: If there is someone who is wild, then Godwin is octagonal and Morgan is sour.\n(∀x (¬Wonderful(x) ∧ ¬Putrid(x))) ↔ (∀x (Wild(x))) ::: Someone is not wonderful and not putrid if and only if he is wild.\n((Sour(molly) ∧ ¬Wild(molly))) → ((¬Wonderful(owen))) ::: It can be concluded that Owen is not wonderful once knowing that Molly is sour and Molly is not wild.\n",
                "First-Order-Logic Question": "¬Sour(luther) ::: Luther is not sour."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "Octagonal(owen) ::: Owen is octagonal.\n¬Sour(molly) ::: Molly is not sour.\n¬Significant(owen) ::: Owen is not significant.\n¬Wild(tristan) ::: Tristan is not wild.\nSignificant(luther) ::: Luther is significant.\n¬Wild(adam) ::: Adam is not wild.\n¬Wonderful(adam) ::: Adam is not wonderful.\nSour(morgan) ::: Morgan is sour.\nSour(tristan) ::: Tristan is sour.\nSour(godwin) ::: Godwin is sour.\nWonderful(owen) ::: Owen is wonderful.\n¬Wild(molly) ::: Molly is not wild.\n(∀x (Putrid(x) ∧ ¬Sour(x))) ↔ (∀x (Octagonal(x) ∧ ¬Wonderful(x))) ::: Someone is putrid and not sour if and only if he is octagonal and not wonderful.\n¬∃x(¬Significant(x))→Significant(x) ::: If there is nobody who is not significant, then Owen is significant.\n(∀x (Significant(x))) ↔ (∀x (¬Wonderful(x))) ::: Someone is significant if and only if he is not wonderful.\n(∃x (¬Significant(x))) → ((¬Putrid(godwin) ∧ Wild(molly))) ::: If there is at least one people who is not significant, then Godwin is not putrid and Molly is wild.\n(∀x (Wonderful(x) ∨ Sour(x))) → (∀x (Wild(x))) ::: If someone is wonderful or he is sour, then he is wild.\n((Putrid(owen))) → ((¬Octagonal(molly) ∧ ¬Wonderful(adam))) ::: Owen being putrid implies that Molly is not octagonal and Adam is not wonderful.\n(∀x (¬Sour(x))) → (∀x (¬Significant(x))) ::: All not sour people are not significant.\n(∀x (¬Significant(x))) → ((Wonderful(godwin) ∧ ¬Octagonal(luther))) ::: If everyone is not significant, then Godwin is wonderful and Luther is not octagonal.\n(∀x (Wild(x))) → (∀x (Wonderful(x))) ::: If someone is wild, then he is wonderful.\n(∃x (Wild(x))) → ((Octagonal(godwin) ∧ Sour(morgan))) ::: If there is someone who is wild, then Godwin is octagonal and Morgan is sour.\n(∀x (¬Wonderful(x) ∧ ¬Putrid(x))) ↔ (∀x (Wild(x))) ::: Someone is not wonderful and not putrid if and only if he is wild.\n((Sour(molly) ∧ ¬Wild(molly))) → ((¬Wonderful(owen))) ::: It can be concluded that Owen is not wonderful once knowing that Molly is sour and Molly is not wild.\n",
                "First-Order-Logic Question": "¬Sour(luther) ::: Luther is not sour."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬Significant(x))) → (Significant(owen)) ::: If there is nobody who is not significant, then Owen is significant.",
                    "gram": "¬∃x(¬Significant(x))→Significant(x) ::: If there is nobody who is not significant, then Owen is significant."
                }
            ],
            "answer": "C",
            "grammar_answer": "A",
            "backup_answer": "B"
        },
        {
            "id": 784,
            "raw_prog": {
                "First-Order-Logic Rules": "Octagonal(owen) ::: Owen is octagonal.\n¬Sour(molly) ::: Molly is not sour.\n¬Significant(owen) ::: Owen is not significant.\n¬Wild(tristan) ::: Tristan is not wild.\nSignificant(luther) ::: Luther is significant.\n¬Wild(adam) ::: Adam is not wild.\n¬Wonderful(adam) ::: Adam is not wonderful.\nSour(morgan) ::: Morgan is sour.\nSour(tristan) ::: Tristan is sour.\nSour(godwin) ::: Godwin is sour.\nWonderful(owen) ::: Owen is wonderful.\n¬Wild(molly) ::: Molly is not wild.\n(∀x (Putrid(x) ∧ ¬Sour(x))) ↔ (∀x (Octagonal(x) ∧ ¬Wonderful(x))) ::: Someone is putrid and not sour if and only if he is octagonal and not wonderful.\n(¬∃x (¬Significant(x))) → (Significant(owen)) ::: If there is nobody who is not significant, then Owen is significant.\n(∀x (Significant(x))) ↔ (∀x (¬Wonderful(x))) ::: Someone is significant if and only if he is not wonderful.\n(∃x (¬Significant(x))) → ((¬Putrid(godwin) ∧ Wild(molly))) ::: If there is at least one people who is not significant, then Godwin is not putrid and Molly is wild.\n(∀x (Wonderful(x) ∨ Sour(x))) → (∀x (Wild(x))) ::: If someone is wonderful or he is sour, then he is wild.\n((Putrid(owen))) → ((¬Octagonal(molly) ∧ ¬Wonderful(adam))) ::: Owen being putrid implies that Molly is not octagonal and Adam is not wonderful.\n(∀x (¬Sour(x))) → (∀x (¬Significant(x))) ::: All not sour people are not significant.\n(∀x (¬Significant(x))) → ((Wonderful(godwin) ∧ ¬Octagonal(luther))) ::: If everyone is not significant, then Godwin is wonderful and Luther is not octagonal.\n(∀x (Wild(x))) → (∀x (Wonderful(x))) ::: If someone is wild, then he is wonderful.\n(∃x (Wild(x))) → ((Octagonal(godwin) ∧ Sour(morgan))) ::: If there is someone who is wild, then Godwin is octagonal and Morgan is sour.\n(∀x (¬Wonderful(x) ∧ ¬Putrid(x))) ↔ (∀x (Wild(x))) ::: Someone is not wonderful and not putrid if and only if he is wild.\n((Sour(molly) ∧ ¬Wild(molly))) → ((¬Wonderful(owen))) ::: It can be concluded that Owen is not wonderful once knowing that Molly is sour and Molly is not wild.\n",
                "First-Order-Logic Question": "Sour(luther) ::: Luther is sour."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "Octagonal(owen) ::: Owen is octagonal.\n¬Sour(molly) ::: Molly is not sour.\n¬Significant(owen) ::: Owen is not significant.\n¬Wild(tristan) ::: Tristan is not wild.\nSignificant(luther) ::: Luther is significant.\n¬Wild(adam) ::: Adam is not wild.\n¬Wonderful(adam) ::: Adam is not wonderful.\nSour(morgan) ::: Morgan is sour.\nSour(tristan) ::: Tristan is sour.\nSour(godwin) ::: Godwin is sour.\nWonderful(owen) ::: Owen is wonderful.\n¬Wild(molly) ::: Molly is not wild.\n(∀x (Putrid(x) ∧ ¬Sour(x))) ↔ (∀x (Octagonal(x) ∧ ¬Wonderful(x))) ::: Someone is putrid and not sour if and only if he is octagonal and not wonderful.\n¬∃x(¬Significant(x))→Significant(x) ::: If there is nobody who is not significant, then Owen is significant.\n(∀x (Significant(x))) ↔ (∀x (¬Wonderful(x))) ::: Someone is significant if and only if he is not wonderful.\n(∃x (¬Significant(x))) → ((¬Putrid(godwin) ∧ Wild(molly))) ::: If there is at least one people who is not significant, then Godwin is not putrid and Molly is wild.\n(∀x (Wonderful(x) ∨ Sour(x))) → (∀x (Wild(x))) ::: If someone is wonderful or he is sour, then he is wild.\n((Putrid(owen))) → ((¬Octagonal(molly) ∧ ¬Wonderful(adam))) ::: Owen being putrid implies that Molly is not octagonal and Adam is not wonderful.\n(∀x (¬Sour(x))) → (∀x (¬Significant(x))) ::: All not sour people are not significant.\n(∀x (¬Significant(x))) → ((Wonderful(godwin) ∧ ¬Octagonal(luther))) ::: If everyone is not significant, then Godwin is wonderful and Luther is not octagonal.\n(∀x (Wild(x))) → (∀x (Wonderful(x))) ::: If someone is wild, then he is wonderful.\n(∃x (Wild(x))) → ((Octagonal(godwin) ∧ Sour(morgan))) ::: If there is someone who is wild, then Godwin is octagonal and Morgan is sour.\n(∀x (¬Wonderful(x) ∧ ¬Putrid(x))) ↔ (∀x (Wild(x))) ::: Someone is not wonderful and not putrid if and only if he is wild.\n((Sour(molly) ∧ ¬Wild(molly))) → ((¬Wonderful(owen))) ::: It can be concluded that Owen is not wonderful once knowing that Molly is sour and Molly is not wild.\n",
                "First-Order-Logic Question": "Sour(luther) ::: Luther is sour."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬Significant(x))) → (Significant(owen)) ::: If there is nobody who is not significant, then Owen is significant.",
                    "gram": "¬∃x(¬Significant(x))→Significant(x) ::: If there is nobody who is not significant, then Owen is significant."
                }
            ],
            "answer": "B",
            "grammar_answer": "A",
            "backup_answer": "A"
        },
        {
            "id": 785,
            "raw_prog": {
                "First-Order-Logic Rules": "Octagonal(owen) ::: Owen is octagonal.\n¬Sour(molly) ::: Molly is not sour.\n¬Significant(owen) ::: Owen is not significant.\n¬Wild(tristan) ::: Tristan is not wild.\nSignificant(luther) ::: Luther is significant.\n¬Wild(adam) ::: Adam is not wild.\n¬Wonderful(adam) ::: Adam is not wonderful.\nSour(morgan) ::: Morgan is sour.\nSour(tristan) ::: Tristan is sour.\nSour(godwin) ::: Godwin is sour.\nWonderful(owen) ::: Owen is wonderful.\n¬Wild(molly) ::: Molly is not wild.\n(∀x (Putrid(x) ∧ ¬Sour(x))) ↔ (∀x (Octagonal(x) ∧ ¬Wonderful(x))) ::: Someone is putrid and not sour if and only if he is octagonal and not wonderful.\n(¬∃x (¬Significant(x))) → (Significant(owen)) ::: If there is nobody who is not significant, then Owen is significant.\n(∀x (Significant(x))) ↔ (∀x (¬Wonderful(x))) ::: Someone is significant if and only if he is not wonderful.\n(∃x (¬Significant(x))) → ((¬Putrid(godwin) ∧ Wild(molly))) ::: If there is at least one people who is not significant, then Godwin is not putrid and Molly is wild.\n(∀x (Wonderful(x) ∨ Sour(x))) → (∀x (Wild(x))) ::: If someone is wonderful or he is sour, then he is wild.\n((Putrid(owen))) → ((¬Octagonal(molly) ∧ ¬Wonderful(adam))) ::: Owen being putrid implies that Molly is not octagonal and Adam is not wonderful.\n(∀x (¬Sour(x))) → (∀x (¬Significant(x))) ::: All not sour people are not significant.\n(∀x (¬Significant(x))) → ((Wonderful(godwin) ∧ ¬Octagonal(luther))) ::: If everyone is not significant, then Godwin is wonderful and Luther is not octagonal.\n(∀x (Wild(x))) → (∀x (Wonderful(x))) ::: If someone is wild, then he is wonderful.\n(∃x (Wild(x))) → ((Octagonal(godwin) ∧ Sour(morgan))) ::: If there is someone who is wild, then Godwin is octagonal and Morgan is sour.\n(∀x (¬Wonderful(x) ∧ ¬Putrid(x))) ↔ (∀x (Wild(x))) ::: Someone is not wonderful and not putrid if and only if he is wild.\n((Sour(molly) ∧ ¬Wild(molly))) → ((¬Wonderful(owen))) ::: It can be concluded that Owen is not wonderful once knowing that Molly is sour and Molly is not wild.\n",
                "First-Order-Logic Question": "¬Sour(morgan) ::: Morgan is not sour."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "Octagonal(owen) ::: Owen is octagonal.\n¬Sour(molly) ::: Molly is not sour.\n¬Significant(owen) ::: Owen is not significant.\n¬Wild(tristan) ::: Tristan is not wild.\nSignificant(luther) ::: Luther is significant.\n¬Wild(adam) ::: Adam is not wild.\n¬Wonderful(adam) ::: Adam is not wonderful.\nSour(morgan) ::: Morgan is sour.\nSour(tristan) ::: Tristan is sour.\nSour(godwin) ::: Godwin is sour.\nWonderful(owen) ::: Owen is wonderful.\n¬Wild(molly) ::: Molly is not wild.\n(∀x (Putrid(x) ∧ ¬Sour(x))) ↔ (∀x (Octagonal(x) ∧ ¬Wonderful(x))) ::: Someone is putrid and not sour if and only if he is octagonal and not wonderful.\n¬∃x(¬Significant(x))→Significant(x) ::: If there is nobody who is not significant, then Owen is significant.\n(∀x (Significant(x))) ↔ (∀x (¬Wonderful(x))) ::: Someone is significant if and only if he is not wonderful.\n(∃x (¬Significant(x))) → ((¬Putrid(godwin) ∧ Wild(molly))) ::: If there is at least one people who is not significant, then Godwin is not putrid and Molly is wild.\n(∀x (Wonderful(x) ∨ Sour(x))) → (∀x (Wild(x))) ::: If someone is wonderful or he is sour, then he is wild.\n((Putrid(owen))) → ((¬Octagonal(molly) ∧ ¬Wonderful(adam))) ::: Owen being putrid implies that Molly is not octagonal and Adam is not wonderful.\n(∀x (¬Sour(x))) → (∀x (¬Significant(x))) ::: All not sour people are not significant.\n(∀x (¬Significant(x))) → ((Wonderful(godwin) ∧ ¬Octagonal(luther))) ::: If everyone is not significant, then Godwin is wonderful and Luther is not octagonal.\n(∀x (Wild(x))) → (∀x (Wonderful(x))) ::: If someone is wild, then he is wonderful.\n(∃x (Wild(x))) → ((Octagonal(godwin) ∧ Sour(morgan))) ::: If there is someone who is wild, then Godwin is octagonal and Morgan is sour.\n(∀x (¬Wonderful(x) ∧ ¬Putrid(x))) ↔ (∀x (Wild(x))) ::: Someone is not wonderful and not putrid if and only if he is wild.\n((Sour(molly) ∧ ¬Wild(molly))) → ((¬Wonderful(owen))) ::: It can be concluded that Owen is not wonderful once knowing that Molly is sour and Molly is not wild.\n",
                "First-Order-Logic Question": "¬Sour(morgan) ::: Morgan is not sour."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬Significant(x))) → (Significant(owen)) ::: If there is nobody who is not significant, then Owen is significant.",
                    "gram": "¬∃x(¬Significant(x))→Significant(x) ::: If there is nobody who is not significant, then Owen is significant."
                }
            ],
            "answer": "C",
            "grammar_answer": "A",
            "backup_answer": "B"
        },
        {
            "id": 786,
            "raw_prog": {
                "First-Order-Logic Rules": "Octagonal(owen) ::: Owen is octagonal.\n¬Sour(molly) ::: Molly is not sour.\n¬Significant(owen) ::: Owen is not significant.\n¬Wild(tristan) ::: Tristan is not wild.\nSignificant(luther) ::: Luther is significant.\n¬Wild(adam) ::: Adam is not wild.\n¬Wonderful(adam) ::: Adam is not wonderful.\nSour(morgan) ::: Morgan is sour.\nSour(tristan) ::: Tristan is sour.\nSour(godwin) ::: Godwin is sour.\nWonderful(owen) ::: Owen is wonderful.\n¬Wild(molly) ::: Molly is not wild.\n(∀x (Putrid(x) ∧ ¬Sour(x))) ↔ (∀x (Octagonal(x) ∧ ¬Wonderful(x))) ::: Someone is putrid and not sour if and only if he is octagonal and not wonderful.\n(¬∃x (¬Significant(x))) → (Significant(owen)) ::: If there is nobody who is not significant, then Owen is significant.\n(∀x (Significant(x))) ↔ (∀x (¬Wonderful(x))) ::: Someone is significant if and only if he is not wonderful.\n(∃x (¬Significant(x))) → ((¬Putrid(godwin) ∧ Wild(molly))) ::: If there is at least one people who is not significant, then Godwin is not putrid and Molly is wild.\n(∀x (Wonderful(x) ∨ Sour(x))) → (∀x (Wild(x))) ::: If someone is wonderful or he is sour, then he is wild.\n((Putrid(owen))) → ((¬Octagonal(molly) ∧ ¬Wonderful(adam))) ::: Owen being putrid implies that Molly is not octagonal and Adam is not wonderful.\n(∀x (¬Sour(x))) → (∀x (¬Significant(x))) ::: All not sour people are not significant.\n(∀x (¬Significant(x))) → ((Wonderful(godwin) ∧ ¬Octagonal(luther))) ::: If everyone is not significant, then Godwin is wonderful and Luther is not octagonal.\n(∀x (Wild(x))) → (∀x (Wonderful(x))) ::: If someone is wild, then he is wonderful.\n(∃x (Wild(x))) → ((Octagonal(godwin) ∧ Sour(morgan))) ::: If there is someone who is wild, then Godwin is octagonal and Morgan is sour.\n(∀x (¬Wonderful(x) ∧ ¬Putrid(x))) ↔ (∀x (Wild(x))) ::: Someone is not wonderful and not putrid if and only if he is wild.\n((Sour(molly) ∧ ¬Wild(molly))) → ((¬Wonderful(owen))) ::: It can be concluded that Owen is not wonderful once knowing that Molly is sour and Molly is not wild.\n",
                "First-Order-Logic Question": "¬Sour(adam) ::: Adam is not sour."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "Octagonal(owen) ::: Owen is octagonal.\n¬Sour(molly) ::: Molly is not sour.\n¬Significant(owen) ::: Owen is not significant.\n¬Wild(tristan) ::: Tristan is not wild.\nSignificant(luther) ::: Luther is significant.\n¬Wild(adam) ::: Adam is not wild.\n¬Wonderful(adam) ::: Adam is not wonderful.\nSour(morgan) ::: Morgan is sour.\nSour(tristan) ::: Tristan is sour.\nSour(godwin) ::: Godwin is sour.\nWonderful(owen) ::: Owen is wonderful.\n¬Wild(molly) ::: Molly is not wild.\n(∀x (Putrid(x) ∧ ¬Sour(x))) ↔ (∀x (Octagonal(x) ∧ ¬Wonderful(x))) ::: Someone is putrid and not sour if and only if he is octagonal and not wonderful.\n¬∃x(¬Significant(x))→Significant(x) ::: If there is nobody who is not significant, then Owen is significant.\n(∀x (Significant(x))) ↔ (∀x (¬Wonderful(x))) ::: Someone is significant if and only if he is not wonderful.\n(∃x (¬Significant(x))) → ((¬Putrid(godwin) ∧ Wild(molly))) ::: If there is at least one people who is not significant, then Godwin is not putrid and Molly is wild.\n(∀x (Wonderful(x) ∨ Sour(x))) → (∀x (Wild(x))) ::: If someone is wonderful or he is sour, then he is wild.\n((Putrid(owen))) → ((¬Octagonal(molly) ∧ ¬Wonderful(adam))) ::: Owen being putrid implies that Molly is not octagonal and Adam is not wonderful.\n(∀x (¬Sour(x))) → (∀x (¬Significant(x))) ::: All not sour people are not significant.\n(∀x (¬Significant(x))) → ((Wonderful(godwin) ∧ ¬Octagonal(luther))) ::: If everyone is not significant, then Godwin is wonderful and Luther is not octagonal.\n(∀x (Wild(x))) → (∀x (Wonderful(x))) ::: If someone is wild, then he is wonderful.\n(∃x (Wild(x))) → ((Octagonal(godwin) ∧ Sour(morgan))) ::: If there is someone who is wild, then Godwin is octagonal and Morgan is sour.\n(∀x (¬Wonderful(x) ∧ ¬Putrid(x))) ↔ (∀x (Wild(x))) ::: Someone is not wonderful and not putrid if and only if he is wild.\n((Sour(molly) ∧ ¬Wild(molly))) → ((¬Wonderful(owen))) ::: It can be concluded that Owen is not wonderful once knowing that Molly is sour and Molly is not wild.\n",
                "First-Order-Logic Question": "¬Sour(adam) ::: Adam is not sour."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬Significant(x))) → (Significant(owen)) ::: If there is nobody who is not significant, then Owen is significant.",
                    "gram": "¬∃x(¬Significant(x))→Significant(x) ::: If there is nobody who is not significant, then Owen is significant."
                }
            ],
            "answer": "C",
            "grammar_answer": "A",
            "backup_answer": "C"
        },
        {
            "id": 787,
            "raw_prog": {
                "First-Order-Logic Rules": [
                    "Octagonal(owen) ::: Owen is octagonal.",
                    "¬Sour(molly) ::: Molly is not sour.",
                    "¬Significant(owen) ::: Owen is not significant.",
                    "¬Wild(tristan) ::: Tristan is not wild.",
                    "Significant(luther) ::: Luther is significant.",
                    "¬Wild(adam) ::: Adam is not wild.",
                    "¬Wonderful(adam) ::: Adam is not wonderful.",
                    "Sour(morgan) ::: Morgan is sour.",
                    "Sour(tristan) ::: Tristan is sour.",
                    "Sour(godwin) ::: Godwin is sour.",
                    "Wonderful(owen) ::: Owen is wonderful.",
                    "¬Wild(molly) ::: Molly is not wild.",
                    "(∀x (Putrid(x) ∧ ¬Sour(x))) ↔ (∀x (Octagonal(x) ∧ ¬Wonderful(x))) ::: Someone is putrid and not sour if and only if he is octagonal and not wonderful.",
                    "(¬∃x (¬Significant(x))) → (Significant(owen)) ::: If there is nobody who is not significant, then Owen is significant.",
                    "(∀x (Significant(x))) ↔ (∀x (¬Wonderful(x))) ::: Someone is significant if and only if he is not wonderful.",
                    "(∃x (¬Significant(x))) → ((¬Putrid(godwin) ∧ Wild(molly))) ::: If there is at least one person who is not significant, then Godwin is not putrid and Molly is wild.",
                    "(∀x (Wonderful(x) ∨ Sour(x))) → (∀x (Wild(x))) ::: If someone is wonderful or he is sour, then he is wild.",
                    "(Putrid(owen)) → ((¬Octagonal(molly) ∧ ¬Wonderful(adam))) ::: Owen being putrid implies that Molly is not octagonal and Adam is not wonderful.",
                    "(∀x (¬Sour(x))) → (∀x (¬Significant(x))) ::: All not sour people are not significant.",
                    "(∀x (¬Significant(x))) → ((Wonderful(godwin) ∧ ¬Octagonal(luther))) ::: If everyone is not significant, then Godwin is wonderful and Luther is not octagonal.",
                    "(∀x (Wild(x))) → (∀x (Wonderful(x))) ::: If someone is wild, then he is wonderful.",
                    "(∃x (Wild(x))) → ((Octagonal(godwin) ∧ Sour(morgan))) ::: If there is someone who is wild, then Godwin is octagonal and Morgan is sour.",
                    "(∀x (¬Wonderful(x) ∧ ¬Putrid(x))) ↔ (∀x (Wild(x))) ::: Someone is not wonderful and not putrid if and only if he is wild.",
                    "((Sour(molly) ∧ ¬Wild(molly))) → (¬Wonderful(owen)) ::: It can be concluded that Owen is not wonderful once knowing that Molly is sour and Molly is not wild."
                ],
                "First-Order-Logic Question": "Octagonal(morgan) ::: Morgan is octagonal."
            },
            "gram_prog": {
                "First-Order-Logic Rules": [
                    "Octagonal(owen) ::: Owen is octagonal.",
                    "¬Sour(molly) ::: Molly is not sour.",
                    "¬Significant(owen) ::: Owen is not significant.",
                    "¬Wild(tristan) ::: Tristan is not wild.",
                    "Significant(luther) ::: Luther is significant.",
                    "¬Wild(adam) ::: Adam is not wild.",
                    "¬Wonderful(adam) ::: Adam is not wonderful.",
                    "Sour(morgan) ::: Morgan is sour.",
                    "Sour(tristan) ::: Tristan is sour.",
                    "Sour(godwin) ::: Godwin is sour.",
                    "Wonderful(owen) ::: Owen is wonderful.",
                    "¬Wild(molly) ::: Molly is not wild.",
                    "(∀x (Putrid(x) ∧ ¬Sour(x))) ↔ (∀x (Octagonal(x) ∧ ¬Wonderful(x))) ::: Someone is putrid and not sour if and only if he is octagonal and not wonderful.",
                    "¬∃x(¬Significant(x))→Significant(x) ::: If there is nobody who is not significant, then Owen is significant.",
                    "(∀x (Significant(x))) ↔ (∀x (¬Wonderful(x))) ::: Someone is significant if and only if he is not wonderful.",
                    "(∃x (¬Significant(x))) → ((¬Putrid(godwin) ∧ Wild(molly))) ::: If there is at least one person who is not significant, then Godwin is not putrid and Molly is wild.",
                    "(∀x (Wonderful(x) ∨ Sour(x))) → (∀x (Wild(x))) ::: If someone is wonderful or he is sour, then he is wild.",
                    "(Putrid(owen)) → ((¬Octagonal(molly) ∧ ¬Wonderful(adam))) ::: Owen being putrid implies that Molly is not octagonal and Adam is not wonderful.",
                    "(∀x (¬Sour(x))) → (∀x (¬Significant(x))) ::: All not sour people are not significant.",
                    "(∀x (¬Significant(x))) → ((Wonderful(godwin) ∧ ¬Octagonal(luther))) ::: If everyone is not significant, then Godwin is wonderful and Luther is not octagonal.",
                    "(∀x (Wild(x))) → (∀x (Wonderful(x))) ::: If someone is wild, then he is wonderful.",
                    "(∃x (Wild(x))) → ((Octagonal(godwin) ∧ Sour(morgan))) ::: If there is someone who is wild, then Godwin is octagonal and Morgan is sour.",
                    "(∀x (¬Wonderful(x) ∧ ¬Putrid(x))) ↔ (∀x (Wild(x))) ::: Someone is not wonderful and not putrid if and only if he is wild.",
                    "((Sour(molly) ∧ ¬Wild(molly))) → (¬Wonderful(owen)) ::: It can be concluded that Owen is not wonderful once knowing that Molly is sour and Molly is not wild."
                ],
                "First-Order-Logic Question": "Octagonal(morgan) ::: Morgan is octagonal."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬Significant(x))) → (Significant(owen)) ::: If there is nobody who is not significant, then Owen is significant.",
                    "gram": "¬∃x(¬Significant(x))→Significant(x) ::: If there is nobody who is not significant, then Owen is significant."
                }
            ],
            "answer": "C",
            "grammar_answer": "A",
            "backup_answer": "C"
        },
        {
            "id": 788,
            "raw_prog": {
                "First-Order-Logic Rules": "Octagonal(owen) ::: Owen is octagonal.\n¬Sour(molly) ::: Molly is not sour.\n¬Significant(owen) ::: Owen is not significant.\n¬Wild(tristan) ::: Tristan is not wild.\nSignificant(luther) ::: Luther is significant.\n¬Wild(adam) ::: Adam is not wild.\n¬Wonderful(adam) ::: Adam is not wonderful.\nSour(morgan) ::: Morgan is sour.\nSour(tristan) ::: Tristan is sour.\nSour(godwin) ::: Godwin is sour.\nWonderful(owen) ::: Owen is wonderful.\n¬Wild(molly) ::: Molly is not wild.\n(∀x (Putrid(x) ∧ ¬Sour(x))) ↔ (∀x (Octagonal(x) ∧ ¬Wonderful(x))) ::: Someone is putrid and not sour if and only if he is octagonal and not wonderful.\n(¬∃x (¬x)) → (Significant(owen)) ::: If there is nobody who is not, then Owen is significant.\n(∀x (Significant(x))) ↔ (∀x (¬Wonderful(x))) ::: Someone is significant if and only if he is not wonderful.\n(∃x (¬Significant(x))) → ((¬Putrid(godwin) ∧ Wild(molly))) ::: If there is at least one people who is not significant, then Godwin is not putrid and Molly is wild.\n(∀x (Wonderful(x) ∨ Sour(x))) → (∀x (Wild(x))) ::: If someone is wonderful or he is sour, then he is wild.\n((Putrid(owen))) → ((¬Octagonal(molly) ∧ ¬Wonderful(adam))) ::: Owen being putrid implies that Molly is not octagonal and Adam is not wonderful.\n(∀x (¬Sour(x))) → (∀x (¬Significant(x))) ::: All not sour people are not significant.\n(∀x (¬Significant(x))) → ((Wonderful(godwin) ∧ ¬Octagonal(luther))) ::: If everyone is not significant, then Godwin is wonderful and Luther is not octagonal.\n(∀x (Wild(x))) → (∀x (Wonderful(x))) ::: If someone is wild, then he is wonderful.\n(∃x (Wild(x))) → ((Octagonal(godwin) ∧ Sour(morgan))) ::: If there is someone who is wild, then Godwin is octagonal and Morgan is sour.\n(∀x (¬Wonderful(x) ∧ ¬Putrid(x))) ↔ (∀x (Wild(x))) ::: Someone is not wonderful and not putrid if and only if he is wild.\n((Sour(molly) ∧ ¬Wild(molly))) → ((¬Wonderful(owen))) ::: It can be concluded that Owen is not wonderful once knowing that Molly is sour and Molly is not wild.\n",
                "First-Order-Logic Question": "Octagonal(tristan) ::: Tristan is octagonal."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "Octagonal(owen) ::: Owen is octagonal.\n¬Sour(molly) ::: Molly is not sour.\n¬Significant(owen) ::: Owen is not significant.\n¬Wild(tristan) ::: Tristan is not wild.\nSignificant(luther) ::: Luther is significant.\n¬Wild(adam) ::: Adam is not wild.\n¬Wonderful(adam) ::: Adam is not wonderful.\nSour(morgan) ::: Morgan is sour.\nSour(tristan) ::: Tristan is sour.\nSour(godwin) ::: Godwin is sour.\nWonderful(owen) ::: Owen is wonderful.\n¬Wild(molly) ::: Molly is not wild.\n(∀x (Putrid(x) ∧ ¬Sour(x))) ↔ (∀x (Octagonal(x) ∧ ¬Wonderful(x))) ::: Someone is putrid and not sour if and only if he is octagonal and not wonderful.\n¬∃x(¬(¬(Octagonal(x)))) ::: If there is nobody who is not, then Owen is significant.\n(∀x (Significant(x))) ↔ (∀x (¬Wonderful(x))) ::: Someone is significant if and only if he is not wonderful.\n(∃x (¬Significant(x))) → ((¬Putrid(godwin) ∧ Wild(molly))) ::: If there is at least one people who is not significant, then Godwin is not putrid and Molly is wild.\n(∀x (Wonderful(x) ∨ Sour(x))) → (∀x (Wild(x))) ::: If someone is wonderful or he is sour, then he is wild.\n((Putrid(owen))) → ((¬Octagonal(molly) ∧ ¬Wonderful(adam))) ::: Owen being putrid implies that Molly is not octagonal and Adam is not wonderful.\n(∀x (¬Sour(x))) → (∀x (¬Significant(x))) ::: All not sour people are not significant.\n(∀x (¬Significant(x))) → ((Wonderful(godwin) ∧ ¬Octagonal(luther))) ::: If everyone is not significant, then Godwin is wonderful and Luther is not octagonal.\n(∀x (Wild(x))) → (∀x (Wonderful(x))) ::: If someone is wild, then he is wonderful.\n(∃x (Wild(x))) → ((Octagonal(godwin) ∧ Sour(morgan))) ::: If there is someone who is wild, then Godwin is octagonal and Morgan is sour.\n(∀x (¬Wonderful(x) ∧ ¬Putrid(x))) ↔ (∀x (Wild(x))) ::: Someone is not wonderful and not putrid if and only if he is wild.\n((Sour(molly) ∧ ¬Wild(molly))) → ((¬Wonderful(owen))) ::: It can be concluded that Owen is not wonderful once knowing that Molly is sour and Molly is not wild.\n",
                "First-Order-Logic Question": "Octagonal(tristan) ::: Tristan is octagonal."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬x)) → (Significant(owen)) ::: If there is nobody who is not, then Owen is significant.",
                    "gram": "¬∃x(¬(¬(Octagonal(x)))) ::: If there is nobody who is not, then Owen is significant."
                }
            ],
            "answer": "B",
            "grammar_answer": "A",
            "backup_answer": "C"
        },
        {
            "id": 789,
            "raw_prog": {
                "First-Order-Logic Rules": "Octagonal(owen) ::: Owen is octagonal.\n¬Sour(molly) ::: Molly is not sour.\n¬Significant(owen) ::: Owen is not significant.\n¬Wild(tristan) ::: Tristan is not wild.\nSignificant(luther) ::: Luther is significant.\n¬Wild(adam) ::: Adam is not wild.\n¬Wonderful(adam) ::: Adam is not wonderful.\nSour(morgan) ::: Morgan is sour.\nSour(tristan) ::: Tristan is sour.\nSour(godwin) ::: Godwin is sour.\nWonderful(owen) ::: Owen is wonderful.\n¬Wild(molly) ::: Molly is not wild.\n(∀x (Putrid(x) ∧ ¬Sour(x))) ↔ (∀x (Octagonal(x) ∧ ¬Wonderful(x))) ::: Someone is putrid and not sour if and only if he is octagonal and not wonderful.\n(¬∃x (¬x)) → (Significant(owen)) ::: If there is nobody who is not, then Owen is significant.\n(∀x (Significant(x))) ↔ (∀x (¬Wonderful(x))) ::: Someone is significant if and only if he is not wonderful.\n(∃x (¬Significant(x))) → ((¬Putrid(godwin) ∧ Wild(molly))) ::: If there is at least one people who is not significant, then Godwin is not putrid and Molly is wild.\n((Wonderful(x) ∨ Sour(x))) → (Wild(x)) ::: If someone is wonderful or he is sour, then he is wild.\n((Putrid(owen))) → ((¬Octagonal(molly) ∧ ¬Wonderful(adam))) ::: Owen being putrid implies that Molly is not octagonal and Adam is not wonderful.\n(∀x (¬Sour(x))) → (∀x (¬Significant(x))) ::: All not sour people are not significant.\n(∀x (¬Significant(x))) → ((Wonderful(godwin) ∧ ¬Octagonal(luther))) ::: If everyone is not significant, then Godwin is wonderful and Luther is not octagonal.\n(∀x (Wild(x))) → (∀x (Wonderful(x))) ::: If someone is wild, then he is wonderful.\n(∃x (Wild(x))) → ((Octagonal(godwin) ∧ Sour(morgan))) ::: If there is someone who is wild, then Godwin is octagonal and Morgan is sour.\n(∀x (¬Wonderful(x) ∧ ¬Putrid(x))) ↔ (∀x (Wild(x))) ::: Someone is not wonderful and not putrid if and only if he is wild.\n((Sour(molly) ∧ ¬Wild(molly))) → (¬Wonderful(owen)) ::: It can be concluded that Owen is not wonderful once knowing that Molly is sour and Molly is not wild.\n",
                "First-Order-Logic Question": "¬Significant(morgan) ::: Morgan is not significant."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "Octagonal(owen) ::: Owen is octagonal.\n¬Sour(molly) ::: Molly is not sour.\n¬Significant(owen) ::: Owen is not significant.\n¬Wild(tristan) ::: Tristan is not wild.\nSignificant(luther) ::: Luther is significant.\n¬Wild(adam) ::: Adam is not wild.\n¬Wonderful(adam) ::: Adam is not wonderful.\nSour(morgan) ::: Morgan is sour.\nSour(tristan) ::: Tristan is sour.\nSour(godwin) ::: Godwin is sour.\nWonderful(owen) ::: Owen is wonderful.\n¬Wild(molly) ::: Molly is not wild.\n(∀x (Putrid(x) ∧ ¬Sour(x))) ↔ (∀x (Octagonal(x) ∧ ¬Wonderful(x))) ::: Someone is putrid and not sour if and only if he is octagonal and not wonderful.\n¬∃x(¬(¬(Octagonal(x)))) ::: If there is nobody who is not, then Owen is significant.\n(∀x (Significant(x))) ↔ (∀x (¬Wonderful(x))) ::: Someone is significant if and only if he is not wonderful.\n(∃x (¬Significant(x))) → ((¬Putrid(godwin) ∧ Wild(molly))) ::: If there is at least one people who is not significant, then Godwin is not putrid and Molly is wild.\n((Wonderful(x) ∨ Sour(x))) → (Wild(x)) ::: If someone is wonderful or he is sour, then he is wild.\n((Putrid(owen))) → ((¬Octagonal(molly) ∧ ¬Wonderful(adam))) ::: Owen being putrid implies that Molly is not octagonal and Adam is not wonderful.\n(∀x (¬Sour(x))) → (∀x (¬Significant(x))) ::: All not sour people are not significant.\n(∀x (¬Significant(x))) → ((Wonderful(godwin) ∧ ¬Octagonal(luther))) ::: If everyone is not significant, then Godwin is wonderful and Luther is not octagonal.\n(∀x (Wild(x))) → (∀x (Wonderful(x))) ::: If someone is wild, then he is wonderful.\n(∃x (Wild(x))) → ((Octagonal(godwin) ∧ Sour(morgan))) ::: If there is someone who is wild, then Godwin is octagonal and Morgan is sour.\n(∀x (¬Wonderful(x) ∧ ¬Putrid(x))) ↔ (∀x (Wild(x))) ::: Someone is not wonderful and not putrid if and only if he is wild.\n((Sour(molly) ∧ ¬Wild(molly))) → (¬Wonderful(owen)) ::: It can be concluded that Owen is not wonderful once knowing that Molly is sour and Molly is not wild.\n",
                "First-Order-Logic Question": "¬Significant(morgan) ::: Morgan is not significant."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬x)) → (Significant(owen)) ::: If there is nobody who is not, then Owen is significant.",
                    "gram": "¬∃x(¬(¬(Octagonal(x)))) ::: If there is nobody who is not, then Owen is significant."
                }
            ],
            "answer": "B",
            "grammar_answer": "A",
            "backup_answer": "C"
        },
        {
            "id": 790,
            "raw_prog": {
                "First-Order-Logic Rules": "Octagonal(owen) ::: Owen is octagonal.\n¬Sour(molly) ::: Molly is not sour.\n¬Significant(owen) ::: Owen is not significant.\n¬Wild(tristan) ::: Tristan is not wild.\nSignificant(luther) ::: Luther is significant.\n¬Wild(adam) ::: Adam is not wild.\n¬Wonderful(adam) ::: Adam is not wonderful.\nSour(morgan) ::: Morgan is sour.\nSour(tristan) ::: Tristan is sour.\nSour(godwin) ::: Godwin is sour.\nWonderful(owen) ::: Owen is wonderful.\n¬Wild(molly) ::: Molly is not wild.\n(∀x (Putrid(x) ∧ ¬Sour(x))) ↔ (∀x (Octagonal(x) ∧ ¬Wonderful(x))) ::: Someone is putrid and not sour if and only if he is octagonal and not wonderful.\n(¬∃x (¬Significant(x))) → (Significant(owen)) ::: If there is nobody who is not significant, then Owen is significant.\n(∀x (Significant(x))) ↔ (∀x (¬Wonderful(x))) ::: Someone is significant if and only if he is not wonderful.\n(∃x (¬Significant(x))) → ((¬Putrid(godwin) ∧ Wild(molly))) ::: If there is at least one people who is not significant, then Godwin is not putrid and Molly is wild.\n(∀x (Wonderful(x) ∨ Sour(x))) → (∀x (Wild(x))) ::: If someone is wonderful or he is sour, then he is wild.\n(Putrid(owen)) → ((¬Octagonal(molly) ∧ ¬Wonderful(adam))) ::: Owen being putrid implies that Molly is not octagonal and Adam is not wonderful.\n(∀x (¬Sour(x))) → (∀x (¬Significant(x))) ::: All not sour people are not significant.\n(∀x (¬Significant(x))) → ((Wonderful(godwin) ∧ ¬Octagonal(luther))) ::: If everyone is not significant, then Godwin is wonderful and Luther is not octagonal.\n(∀x (Wild(x))) → (∀x (Wonderful(x))) ::: If someone is wild, then he is wonderful.\n(∃x (Wild(x))) → ((Octagonal(godwin) ∧ Sour(morgan))) ::: If there is someone who is wild, then Godwin is octagonal and Morgan is sour.\n(∀x (¬Wonderful(x) ∧ ¬Putrid(x))) ↔ (∀x (Wild(x))) ::: Someone is not wonderful and not putrid if and only if he is wild.\n((Sour(molly) ∧ ¬Wild(molly))) → (¬Wonderful(owen)) ::: It can be concluded that Owen is not wonderful once knowing that Molly is sour and Molly is not wild.\n",
                "First-Order-Logic Question": "¬Octagonal(owen) ::: Owen is not octagonal."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "Octagonal(owen) ::: Owen is octagonal.\n¬Sour(molly) ::: Molly is not sour.\n¬Significant(owen) ::: Owen is not significant.\n¬Wild(tristan) ::: Tristan is not wild.\nSignificant(luther) ::: Luther is significant.\n¬Wild(adam) ::: Adam is not wild.\n¬Wonderful(adam) ::: Adam is not wonderful.\nSour(morgan) ::: Morgan is sour.\nSour(tristan) ::: Tristan is sour.\nSour(godwin) ::: Godwin is sour.\nWonderful(owen) ::: Owen is wonderful.\n¬Wild(molly) ::: Molly is not wild.\n(∀x (Putrid(x) ∧ ¬Sour(x))) ↔ (∀x (Octagonal(x) ∧ ¬Wonderful(x))) ::: Someone is putrid and not sour if and only if he is octagonal and not wonderful.\n¬∃x(¬Significant(x))→Significant(x) ::: If there is nobody who is not significant, then Owen is significant.\n(∀x (Significant(x))) ↔ (∀x (¬Wonderful(x))) ::: Someone is significant if and only if he is not wonderful.\n(∃x (¬Significant(x))) → ((¬Putrid(godwin) ∧ Wild(molly))) ::: If there is at least one people who is not significant, then Godwin is not putrid and Molly is wild.\n(∀x (Wonderful(x) ∨ Sour(x))) → (∀x (Wild(x))) ::: If someone is wonderful or he is sour, then he is wild.\n(Putrid(owen)) → ((¬Octagonal(molly) ∧ ¬Wonderful(adam))) ::: Owen being putrid implies that Molly is not octagonal and Adam is not wonderful.\n(∀x (¬Sour(x))) → (∀x (¬Significant(x))) ::: All not sour people are not significant.\n(∀x (¬Significant(x))) → ((Wonderful(godwin) ∧ ¬Octagonal(luther))) ::: If everyone is not significant, then Godwin is wonderful and Luther is not octagonal.\n(∀x (Wild(x))) → (∀x (Wonderful(x))) ::: If someone is wild, then he is wonderful.\n(∃x (Wild(x))) → ((Octagonal(godwin) ∧ Sour(morgan))) ::: If there is someone who is wild, then Godwin is octagonal and Morgan is sour.\n(∀x (¬Wonderful(x) ∧ ¬Putrid(x))) ↔ (∀x (Wild(x))) ::: Someone is not wonderful and not putrid if and only if he is wild.\n((Sour(molly) ∧ ¬Wild(molly))) → (¬Wonderful(owen)) ::: It can be concluded that Owen is not wonderful once knowing that Molly is sour and Molly is not wild.\n",
                "First-Order-Logic Question": "¬Octagonal(owen) ::: Owen is not octagonal."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬Significant(x))) → (Significant(owen)) ::: If there is nobody who is not significant, then Owen is significant.",
                    "gram": "¬∃x(¬Significant(x))→Significant(x) ::: If there is nobody who is not significant, then Owen is significant."
                }
            ],
            "answer": "B",
            "grammar_answer": "A",
            "backup_answer": "B"
        },
        {
            "id": 791,
            "raw_prog": {
                "First-Order-Logic Rules": "Octagonal(owen) ::: Owen is octagonal.\n¬Sour(molly) ::: Molly is not sour.\n¬Significant(owen) ::: Owen is not significant.\n¬Wild(tristan) ::: Tristan is not wild.\nSignificant(luther) ::: Luther is significant.\n¬Wild(adam) ::: Adam is not wild.\n¬Wonderful(adam) ::: Adam is not wonderful.\nSour(morgan) ::: Morgan is sour.\nSour(tristan) ::: Tristan is sour.\nSour(godwin) ::: Godwin is sour.\nWonderful(owen) ::: Owen is wonderful.\n¬Wild(molly) ::: Molly is not wild.\n(∀x (Putrid(x) ∧ ¬Sour(x))) ↔ (∀x (Octagonal(x) ∧ ¬Wonderful(x))) ::: Someone is putrid and not sour if and only if he is octagonal and not wonderful.\n(¬∃x (¬x)) → (Significant(owen)) ::: If there is nobody who is not, then Owen is significant.\n(∀x (Significant(x))) ↔ (∀x (¬Wonderful(x))) ::: Someone is significant if and only if he is not wonderful.\n(∃x (¬Significant(x))) → ((¬Putrid(godwin) ∧ Wild(molly))) ::: If there is at least one people who is not significant, then Godwin is not putrid and Molly is wild.\n(∀x (Wonderful(x) ∨ Sour(x))) → (∀x (Wild(x))) ::: If someone is wonderful or he is sour, then he is wild.\n((Putrid(owen))) → ((¬Octagonal(molly) ∧ ¬Wonderful(adam))) ::: Owen being putrid implies that Molly is not octagonal and Adam is not wonderful.\n(∀x (¬Sour(x))) → (∀x (¬Significant(x))) ::: All not sour people are not significant.\n(∀x (¬Significant(x))) → ((Wonderful(godwin) ∧ ¬Octagonal(luther))) ::: If everyone is not significant, then Godwin is wonderful and Luther is not octagonal.\n(∀x (Wild(x))) → (∀x (Wonderful(x))) ::: If someone is wild, then he is wonderful.\n(∃x (Wild(x))) → ((Octagonal(godwin) ∧ Sour(morgan))) ::: If there is someone who is wild, then Godwin is octagonal and Morgan is sour.\n(∀x (¬Wonderful(x) ∧ ¬Putrid(x))) ↔ (∀x (Wild(x))) ::: Someone is not wonderful and not putrid if and only if he is wild.\n((Sour(molly) ∧ ¬Wild(molly))) → ((¬Wonderful(owen))) ::: It can be concluded that Owen is not wonderful once knowing that Molly is sour and Molly is not wild.\n",
                "First-Order-Logic Question": "Putrid(tristan) ::: Tristan is putrid."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "Octagonal(owen) ::: Owen is octagonal.\n¬Sour(molly) ::: Molly is not sour.\n¬Significant(owen) ::: Owen is not significant.\n¬Wild(tristan) ::: Tristan is not wild.\nSignificant(luther) ::: Luther is significant.\n¬Wild(adam) ::: Adam is not wild.\n¬Wonderful(adam) ::: Adam is not wonderful.\nSour(morgan) ::: Morgan is sour.\nSour(tristan) ::: Tristan is sour.\nSour(godwin) ::: Godwin is sour.\nWonderful(owen) ::: Owen is wonderful.\n¬Wild(molly) ::: Molly is not wild.\n(∀x (Putrid(x) ∧ ¬Sour(x))) ↔ (∀x (Octagonal(x) ∧ ¬Wonderful(x))) ::: Someone is putrid and not sour if and only if he is octagonal and not wonderful.\n¬∃x(¬(¬(Octagonal(x)))) ::: If there is nobody who is not, then Owen is significant.\n(∀x (Significant(x))) ↔ (∀x (¬Wonderful(x))) ::: Someone is significant if and only if he is not wonderful.\n(∃x (¬Significant(x))) → ((¬Putrid(godwin) ∧ Wild(molly))) ::: If there is at least one people who is not significant, then Godwin is not putrid and Molly is wild.\n(∀x (Wonderful(x) ∨ Sour(x))) → (∀x (Wild(x))) ::: If someone is wonderful or he is sour, then he is wild.\n((Putrid(owen))) → ((¬Octagonal(molly) ∧ ¬Wonderful(adam))) ::: Owen being putrid implies that Molly is not octagonal and Adam is not wonderful.\n(∀x (¬Sour(x))) → (∀x (¬Significant(x))) ::: All not sour people are not significant.\n(∀x (¬Significant(x))) → ((Wonderful(godwin) ∧ ¬Octagonal(luther))) ::: If everyone is not significant, then Godwin is wonderful and Luther is not octagonal.\n(∀x (Wild(x))) → (∀x (Wonderful(x))) ::: If someone is wild, then he is wonderful.\n(∃x (Wild(x))) → ((Octagonal(godwin) ∧ Sour(morgan))) ::: If there is someone who is wild, then Godwin is octagonal and Morgan is sour.\n(∀x (¬Wonderful(x) ∧ ¬Putrid(x))) ↔ (∀x (Wild(x))) ::: Someone is not wonderful and not putrid if and only if he is wild.\n((Sour(molly) ∧ ¬Wild(molly))) → ((¬Wonderful(owen))) ::: It can be concluded that Owen is not wonderful once knowing that Molly is sour and Molly is not wild.\n",
                "First-Order-Logic Question": "Putrid(tristan) ::: Tristan is putrid."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬x)) → (Significant(owen)) ::: If there is nobody who is not, then Owen is significant.",
                    "gram": "¬∃x(¬(¬(Octagonal(x)))) ::: If there is nobody who is not, then Owen is significant."
                }
            ],
            "answer": "A",
            "grammar_answer": "A",
            "backup_answer": "C"
        },
        {
            "id": 792,
            "raw_prog": {
                "First-Order-Logic Rules": "Octagonal(owen) ::: Owen is octagonal.\n¬Sour(molly) ::: Molly is not sour.\n¬Significant(owen) ::: Owen is not significant.\n¬Wild(tristan) ::: Tristan is not wild.\nSignificant(luther) ::: Luther is significant.\n¬Wild(adam) ::: Adam is not wild.\n¬Wonderful(adam) ::: Adam is not wonderful.\nSour(morgan) ::: Morgan is sour.\nSour(tristan) ::: Tristan is sour.\nSour(godwin) ::: Godwin is sour.\nWonderful(owen) ::: Owen is wonderful.\n¬Wild(molly) ::: Molly is not wild.\n(∀x (Putrid(x) ∧ ¬Sour(x))) ↔ (∀x (Octagonal(x) ∧ ¬Wonderful(x))) ::: Someone is putrid and not sour if and only if he is octagonal and not wonderful.\n(¬∃x (¬x)) → (Significant(owen)) ::: If there is nobody who is not, then Owen is significant.\n(∀x (Significant(x))) ↔ (∀x (¬Wonderful(x))) ::: Someone is significant if and only if he is not wonderful.\n(∃x (¬Significant(x))) → ((¬Putrid(godwin) ∧ Wild(molly))) ::: If there is at least one people who is not significant, then Godwin is not putrid and Molly is wild.\n((Wonderful(x) ∨ Sour(x))) → (Wild(x)) ::: If someone is wonderful or he is sour, then he is wild.\n((Putrid(owen))) → ((¬Octagonal(molly) ∧ ¬Wonderful(adam))) ::: Owen being putrid implies that Molly is not octagonal and Adam is not wonderful.\n(∀x (¬Sour(x))) → (∀x (¬Significant(x))) ::: All not sour people are not significant.\n(∀x (¬Significant(x))) → ((Wonderful(godwin) ∧ ¬Octagonal(luther))) ::: If everyone is not significant, then Godwin is wonderful and Luther is not octagonal.\n(∀x (Wild(x))) → (∀x (Wonderful(x))) ::: If someone is wild, then he is wonderful.\n(∃x (Wild(x))) → ((Octagonal(godwin) ∧ Sour(morgan))) ::: If there is someone who is wild, then Godwin is octagonal and Morgan is sour.\n(∀x (¬Wonderful(x) ∧ ¬Putrid(x))) ↔ (∀x (Wild(x))) ::: Someone is not wonderful and not putrid if and only if he is wild.\n((Sour(molly) ∧ ¬Wild(molly))) → (¬Wonderful(owen)) ::: It can be concluded that Owen is not wonderful once knowing that Molly is sour and Molly is not wild.\n",
                "First-Order-Logic Question": "¬Sour(owen) ::: Owen is not sour."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "Octagonal(owen) ::: Owen is octagonal.\n¬Sour(molly) ::: Molly is not sour.\n¬Significant(owen) ::: Owen is not significant.\n¬Wild(tristan) ::: Tristan is not wild.\nSignificant(luther) ::: Luther is significant.\n¬Wild(adam) ::: Adam is not wild.\n¬Wonderful(adam) ::: Adam is not wonderful.\nSour(morgan) ::: Morgan is sour.\nSour(tristan) ::: Tristan is sour.\nSour(godwin) ::: Godwin is sour.\nWonderful(owen) ::: Owen is wonderful.\n¬Wild(molly) ::: Molly is not wild.\n(∀x (Putrid(x) ∧ ¬Sour(x))) ↔ (∀x (Octagonal(x) ∧ ¬Wonderful(x))) ::: Someone is putrid and not sour if and only if he is octagonal and not wonderful.\n¬∃x(¬(¬(Octagonal(x)))) ::: If there is nobody who is not, then Owen is significant.\n(∀x (Significant(x))) ↔ (∀x (¬Wonderful(x))) ::: Someone is significant if and only if he is not wonderful.\n(∃x (¬Significant(x))) → ((¬Putrid(godwin) ∧ Wild(molly))) ::: If there is at least one people who is not significant, then Godwin is not putrid and Molly is wild.\n((Wonderful(x) ∨ Sour(x))) → (Wild(x)) ::: If someone is wonderful or he is sour, then he is wild.\n((Putrid(owen))) → ((¬Octagonal(molly) ∧ ¬Wonderful(adam))) ::: Owen being putrid implies that Molly is not octagonal and Adam is not wonderful.\n(∀x (¬Sour(x))) → (∀x (¬Significant(x))) ::: All not sour people are not significant.\n(∀x (¬Significant(x))) → ((Wonderful(godwin) ∧ ¬Octagonal(luther))) ::: If everyone is not significant, then Godwin is wonderful and Luther is not octagonal.\n(∀x (Wild(x))) → (∀x (Wonderful(x))) ::: If someone is wild, then he is wonderful.\n(∃x (Wild(x))) → ((Octagonal(godwin) ∧ Sour(morgan))) ::: If there is someone who is wild, then Godwin is octagonal and Morgan is sour.\n(∀x (¬Wonderful(x) ∧ ¬Putrid(x))) ↔ (∀x (Wild(x))) ::: Someone is not wonderful and not putrid if and only if he is wild.\n((Sour(molly) ∧ ¬Wild(molly))) → (¬Wonderful(owen)) ::: It can be concluded that Owen is not wonderful once knowing that Molly is sour and Molly is not wild.\n",
                "First-Order-Logic Question": "¬Sour(owen) ::: Owen is not sour."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬x)) → (Significant(owen)) ::: If there is nobody who is not, then Owen is significant.",
                    "gram": "¬∃x(¬(¬(Octagonal(x)))) ::: If there is nobody who is not, then Owen is significant."
                }
            ],
            "answer": "B",
            "grammar_answer": "A",
            "backup_answer": "B"
        },
        {
            "id": 793,
            "raw_prog": {
                "First-Order-Logic Rules": "Octagonal(owen) ::: Owen is octagonal.\n¬Sour(molly) ::: Molly is not sour.\n¬Significant(owen) ::: Owen is not significant.\n¬Wild(tristan) ::: Tristan is not wild.\nSignificant(luther) ::: Luther is significant.\n¬Wild(adam) ::: Adam is not wild.\n¬Wonderful(adam) ::: Adam is not wonderful.\nSour(morgan) ::: Morgan is sour.\nSour(tristan) ::: Tristan is sour.\nSour(godwin) ::: Godwin is sour.\nWonderful(owen) ::: Owen is wonderful.\n¬Wild(molly) ::: Molly is not wild.\n(∀x (Putrid(x) ∧ ¬Sour(x))) ↔ (∀x (Octagonal(x) ∧ ¬Wonderful(x))) ::: Someone is putrid and not sour if and only if he is octagonal and not wonderful.\n(¬∃x (¬Significant(x))) → (Significant(owen)) ::: If there is nobody who is not significant, then Owen is significant.\n(∀x (Significant(x))) ↔ (∀x (¬Wonderful(x))) ::: Someone is significant if and only if he is not wonderful.\n(∃x (¬Significant(x))) → ((¬Putrid(godwin) ∧ Wild(molly))) ::: If there is at least one people who is not significant, then Godwin is not putrid and Molly is wild.\n(∀x (Wonderful(x) ∨ Sour(x))) → (∀x (Wild(x))) ::: If someone is wonderful or he is sour, then he is wild.\n((Putrid(owen))) → ((¬Octagonal(molly) ∧ ¬Wonderful(adam))) ::: Owen being putrid implies that Molly is not octagonal and Adam is not wonderful.\n(∀x (¬Sour(x))) → (∀x (¬Significant(x))) ::: All not sour people are not significant.\n(∀x (¬Significant(x))) → ((Wonderful(godwin) ∧ ¬Octagonal(luther))) ::: If everyone is not significant, then Godwin is wonderful and Luther is not octagonal.\n(∀x (Wild(x))) → (∀x (Wonderful(x))) ::: If someone is wild, then he is wonderful.\n(∃x (Wild(x))) → ((Octagonal(godwin) ∧ Sour(morgan))) ::: If there is someone who is wild, then Godwin is octagonal and Morgan is sour.\n(∀x (¬Wonderful(x) ∧ ¬Putrid(x))) ↔ (∀x (Wild(x))) ::: Someone is not wonderful and not putrid if and only if he is wild.\n((Sour(molly) ∧ ¬Wild(molly))) → (¬Wonderful(owen)) ::: It can be concluded that Owen is not wonderful once knowing that Molly is sour and Molly is not wild.\n",
                "First-Order-Logic Question": "¬Sour(tristan) ::: Tristan is not sour."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "Octagonal(owen) ::: Owen is octagonal.\n¬Sour(molly) ::: Molly is not sour.\n¬Significant(owen) ::: Owen is not significant.\n¬Wild(tristan) ::: Tristan is not wild.\nSignificant(luther) ::: Luther is significant.\n¬Wild(adam) ::: Adam is not wild.\n¬Wonderful(adam) ::: Adam is not wonderful.\nSour(morgan) ::: Morgan is sour.\nSour(tristan) ::: Tristan is sour.\nSour(godwin) ::: Godwin is sour.\nWonderful(owen) ::: Owen is wonderful.\n¬Wild(molly) ::: Molly is not wild.\n(∀x (Putrid(x) ∧ ¬Sour(x))) ↔ (∀x (Octagonal(x) ∧ ¬Wonderful(x))) ::: Someone is putrid and not sour if and only if he is octagonal and not wonderful.\n¬∃x(¬Significant(x))→Significant(x) ::: If there is nobody who is not significant, then Owen is significant.\n(∀x (Significant(x))) ↔ (∀x (¬Wonderful(x))) ::: Someone is significant if and only if he is not wonderful.\n(∃x (¬Significant(x))) → ((¬Putrid(godwin) ∧ Wild(molly))) ::: If there is at least one people who is not significant, then Godwin is not putrid and Molly is wild.\n(∀x (Wonderful(x) ∨ Sour(x))) → (∀x (Wild(x))) ::: If someone is wonderful or he is sour, then he is wild.\n((Putrid(owen))) → ((¬Octagonal(molly) ∧ ¬Wonderful(adam))) ::: Owen being putrid implies that Molly is not octagonal and Adam is not wonderful.\n(∀x (¬Sour(x))) → (∀x (¬Significant(x))) ::: All not sour people are not significant.\n(∀x (¬Significant(x))) → ((Wonderful(godwin) ∧ ¬Octagonal(luther))) ::: If everyone is not significant, then Godwin is wonderful and Luther is not octagonal.\n(∀x (Wild(x))) → (∀x (Wonderful(x))) ::: If someone is wild, then he is wonderful.\n(∃x (Wild(x))) → ((Octagonal(godwin) ∧ Sour(morgan))) ::: If there is someone who is wild, then Godwin is octagonal and Morgan is sour.\n(∀x (¬Wonderful(x) ∧ ¬Putrid(x))) ↔ (∀x (Wild(x))) ::: Someone is not wonderful and not putrid if and only if he is wild.\n((Sour(molly) ∧ ¬Wild(molly))) → (¬Wonderful(owen)) ::: It can be concluded that Owen is not wonderful once knowing that Molly is sour and Molly is not wild.\n",
                "First-Order-Logic Question": "¬Sour(tristan) ::: Tristan is not sour."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬Significant(x))) → (Significant(owen)) ::: If there is nobody who is not significant, then Owen is significant.",
                    "gram": "¬∃x(¬Significant(x))→Significant(x) ::: If there is nobody who is not significant, then Owen is significant."
                }
            ],
            "answer": "A",
            "grammar_answer": "A",
            "backup_answer": "B"
        },
        {
            "id": 794,
            "raw_prog": {
                "First-Order-Logic Rules": [
                    "Octagonal(owen) ::: Owen is octagonal.",
                    "¬Sour(molly) ::: Molly is not sour.",
                    "¬Significant(owen) ::: Owen is not significant.",
                    "¬Wild(tristan) ::: Tristan is not wild.",
                    "Significant(luther) ::: Luther is significant.",
                    "¬Wild(adam) ::: Adam is not wild.",
                    "¬Wonderful(adam) ::: Adam is not wonderful.",
                    "Sour(morgan) ::: Morgan is sour.",
                    "Sour(tristan) ::: Tristan is sour.",
                    "Sour(godwin) ::: Godwin is sour.",
                    "Wonderful(owen) ::: Owen is wonderful.",
                    "¬Wild(molly) ::: Molly is not wild.",
                    "(∀x (Putrid(x) ∧ ¬Sour(x))) ↔ (∀x (Octagonal(x) ∧ ¬Wonderful(x))) ::: Someone is putrid and not sour if and only if he is octagonal and not wonderful.",
                    "(¬∃x (¬x)) → (Significant(owen)) ::: If there is nobody who is not, then Owen is significant.",
                    "(∀x (Significant(x))) ↔ (∀x (¬Wonderful(x))) ::: Someone is significant if and only if he is not wonderful.",
                    "(∃x (¬Significant(x))) → ((¬Putrid(godwin) ∧ Wild(molly))) ::: If there is at least one people who is not significant, then Godwin is not putrid and Molly is wild.",
                    "(∀x (Wonderful(x) ∨ Sour(x))) → (∀x (Wild(x))) ::: If someone is wonderful or he is sour, then he is wild.",
                    "(Putrid(owen)) → ((¬Octagonal(molly) ∧ ¬Wonderful(adam))) ::: Owen being putrid implies that Molly is not octagonal and Adam is not wonderful.",
                    "(∀x (¬Sour(x))) → (∀x (¬Significant(x))) ::: All not sour people are not significant.",
                    "(∀x (¬Significant(x))) → ((Wonderful(godwin) ∧ ¬Octagonal(luther))) ::: If everyone is not significant, then Godwin is wonderful and Luther is not octagonal.",
                    "(∀x (Wild(x))) → (∀x (Wonderful(x))) ::: If someone is wild, then he is wonderful.",
                    "(∃x (Wild(x))) → ((Octagonal(godwin) ∧ Sour(morgan))) ::: If there is someone who is wild, then Godwin is octagonal and Morgan is sour.",
                    "(∀x (¬Wonderful(x) ∧ ¬Putrid(x))) ↔ (∀x (Wild(x))) ::: Someone is not wonderful and not putrid if and only if he is wild.",
                    "((Sour(molly) ∧ ¬Wild(molly))) → (¬Wonderful(owen)) ::: It can be concluded that Owen is not wonderful once knowing that Molly is sour and Molly is not wild."
                ],
                "First-Order-Logic Question": "Octagonal(godwin) ::: Godwin is octagonal."
            },
            "gram_prog": {
                "First-Order-Logic Rules": [
                    "Octagonal(owen) ::: Owen is octagonal.",
                    "¬Sour(molly) ::: Molly is not sour.",
                    "¬Significant(owen) ::: Owen is not significant.",
                    "¬Wild(tristan) ::: Tristan is not wild.",
                    "Significant(luther) ::: Luther is significant.",
                    "¬Wild(adam) ::: Adam is not wild.",
                    "¬Wonderful(adam) ::: Adam is not wonderful.",
                    "Sour(morgan) ::: Morgan is sour.",
                    "Sour(tristan) ::: Tristan is sour.",
                    "Sour(godwin) ::: Godwin is sour.",
                    "Wonderful(owen) ::: Owen is wonderful.",
                    "¬Wild(molly) ::: Molly is not wild.",
                    "(∀x (Putrid(x) ∧ ¬Sour(x))) ↔ (∀x (Octagonal(x) ∧ ¬Wonderful(x))) ::: Someone is putrid and not sour if and only if he is octagonal and not wonderful.",
                    "¬∃x(¬(¬(Octagonal(x)))) ::: If there is nobody who is not, then Owen is significant.",
                    "(∀x (Significant(x))) ↔ (∀x (¬Wonderful(x))) ::: Someone is significant if and only if he is not wonderful.",
                    "(∃x (¬Significant(x))) → ((¬Putrid(godwin) ∧ Wild(molly))) ::: If there is at least one people who is not significant, then Godwin is not putrid and Molly is wild.",
                    "(∀x (Wonderful(x) ∨ Sour(x))) → (∀x (Wild(x))) ::: If someone is wonderful or he is sour, then he is wild.",
                    "(Putrid(owen)) → ((¬Octagonal(molly) ∧ ¬Wonderful(adam))) ::: Owen being putrid implies that Molly is not octagonal and Adam is not wonderful.",
                    "(∀x (¬Sour(x))) → (∀x (¬Significant(x))) ::: All not sour people are not significant.",
                    "(∀x (¬Significant(x))) → ((Wonderful(godwin) ∧ ¬Octagonal(luther))) ::: If everyone is not significant, then Godwin is wonderful and Luther is not octagonal.",
                    "(∀x (Wild(x))) → (∀x (Wonderful(x))) ::: If someone is wild, then he is wonderful.",
                    "(∃x (Wild(x))) → ((Octagonal(godwin) ∧ Sour(morgan))) ::: If there is someone who is wild, then Godwin is octagonal and Morgan is sour.",
                    "(∀x (¬Wonderful(x) ∧ ¬Putrid(x))) ↔ (∀x (Wild(x))) ::: Someone is not wonderful and not putrid if and only if he is wild.",
                    "((Sour(molly) ∧ ¬Wild(molly))) → (¬Wonderful(owen)) ::: It can be concluded that Owen is not wonderful once knowing that Molly is sour and Molly is not wild."
                ],
                "First-Order-Logic Question": "Octagonal(godwin) ::: Godwin is octagonal."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬x)) → (Significant(owen)) ::: If there is nobody who is not, then Owen is significant.",
                    "gram": "¬∃x(¬(¬(Octagonal(x)))) ::: If there is nobody who is not, then Owen is significant."
                }
            ],
            "answer": "C",
            "grammar_answer": "C",
            "backup_answer": "C"
        },
        {
            "id": 800,
            "raw_prog": {
                "First-Order-Logic Rules": "¬Zany(dan) ::: Dan is not zany.\n¬Sour(kenyon) ::: Kenyon is not sour.\nAggressive(terry) ::: Terry is aggressive.\nZany(lesley) ::: Lesley is zany.\nAggressive(kenyon) ::: Kenyon is aggressive.\n¬Comfortable(melvin) ::: Melvin is not comfortable.\nHappy(melvin) ::: Melvin is happy.\nHappy(kenyon) ::: Kenyon is happy.\nComfortable(dan) ::: Dan is comfortable.\nZany(christopher) ::: Christopher is zany.\n¬Comfortable(christopher) ::: Christopher is not comfortable.\n¬Sour(terry) ::: Terry is not sour.\n(Bad(terry)) → (Zany(melvin)) ::: If Terry is bad, then Melvin is zany.\n(∀x (¬Bad(x) ∨ ¬Aggressive(x))) → (∀x (Sour(x))) ::: If someone is not bad or not aggressive, then he is sour.\n(Aggressive(melvin) ∨ ¬Bad(melvin)) → (¬Comfortable(terry)) ::: If Melvin is aggressive or Melvin is not bad, then Terry is not comfortable.\n(∀x (Aggressive(x))) ↔ (∀x (Zany(x))) ::: If someone is aggressive, then he is zany, and vice versa.\n(Comfortable(melvin) ∧ ¬Bad(melvin)) → (Aggressive(graciela)) ::: If Melvin is comfortable and Melvin is not bad, then Graciela is aggressive.\n(Aggressive(lesley)) ↔ (¬Happy(christopher) ∧ ¬Comfortable(kenyon)) ::: Lesley is aggressive if and only if Christopher is not happy and Kenyon is not comfortable.\n(∀x (Happy(x) ∨ ¬Bad(x))) → (∀x (¬Aggressive(x))) ::: If someone is he or not bad is happy, then he is not aggressive.\n(∃x (¬Comfortable(x) ∧ ¬Happy(x))) → ((¬Aggressive(terry) ∧ Sour(terry))) ::: If there is someone who is neither comfortable nor happy, then Terry is not aggressive and Terry is sour.\n(∀x (Happy(x) ∨ ¬Zany(x))) → (∀x (¬Comfortable(x))) ::: If someone is he or not zany is happy, then he is not comfortable.\n(∀x (Sour(x) ∧ ¬Comfortable(x))) ↔ (∀x (Zany(x))) ::: If someone is sour and not comfortable, then he is zany, and vice versa.\n(∀x (Comfortable(x) ∧ ¬Aggressive(x))) → (∀x (Sour(x) ∧ ¬Bad(x))) ::: Someone who is comfortable and not aggressive is always sour and not bad.\n(∃x (¬Happy(x))) → (¬Bad(melvin)) ::: If there is at least one people who is not happy, then Melvin is not bad.\n",
                "First-Order-Logic Question": "¬Comfortable(melvin) ::: Melvin is not comfortable."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "¬Zany(dan) ::: Dan is not zany.\n¬Sour(kenyon) ::: Kenyon is not sour.\nAggressive(terry) ::: Terry is aggressive.\nZany(lesley) ::: Lesley is zany.\nAggressive(kenyon) ::: Kenyon is aggressive.\n¬Comfortable(melvin) ::: Melvin is not comfortable.\nHappy(melvin) ::: Melvin is happy.\nHappy(kenyon) ::: Kenyon is happy.\nComfortable(dan) ::: Dan is comfortable.\nZany(christopher) ::: Christopher is zany.\n¬Comfortable(christopher) ::: Christopher is not comfortable.\n¬Sour(terry) ::: Terry is not sour.\n(Bad(terry)) → (Zany(melvin)) ::: If Terry is bad, then Melvin is zany.\n(∀x (¬Bad(x) ∨ ¬Aggressive(x))) → (∀x (Sour(x))) ::: If someone is not bad or not aggressive, then he is sour.\n(Aggressive(melvin) ∨ ¬Bad(melvin)) → (¬Comfortable(terry)) ::: If Melvin is aggressive or Melvin is not bad, then Terry is not comfortable.\n(∀x (Aggressive(x))) ↔ (∀x (Zany(x))) ::: If someone is aggressive, then he is zany, and vice versa.\n(Comfortable(melvin) ∧ ¬Bad(melvin)) → (Aggressive(graciela)) ::: If Melvin is comfortable and Melvin is not bad, then Graciela is aggressive.\n(Aggressive(lesley)) ↔ (¬Happy(christopher) ∧ ¬Comfortable(kenyon)) ::: Lesley is aggressive if and only if Christopher is not happy and Kenyon is not comfortable.\n(∀x (Happy(x) ∨ ¬Bad(x))) → (∀x (¬Aggressive(x))) ::: If someone is he or not bad is happy, then he is not aggressive.\n(∃x (¬Comfortable(x) ∧ ¬Happy(x))) → ((¬Aggressive(terry) ∧ Sour(terry))) ::: If there is someone who is neither comfortable nor happy, then Terry is not aggressive and Terry is sour.\n(∀x (Happy(x) ∨ ¬Zany(x))) → (∀x (¬Comfortable(x))) ::: If someone is he or not zany is happy, then he is not comfortable.\n(∀x (Sour(x) ∧ ¬Comfortable(x))) ↔ (∀x (Zany(x))) ::: If someone is sour and not comfortable, then he is zany, and vice versa.\n(∀x (Comfortable(x) ∧ ¬Aggressive(x))) → (∀x (Sour(x) ∧ ¬Bad(x))) ::: Someone who is comfortable and not aggressive is always sour and not bad.\n(∃x (¬Happy(x))) → (¬Bad(melvin)) ::: If there is at least one people who is not happy, then Melvin is not bad.\n",
                "First-Order-Logic Question": "¬Comfortable(melvin) ::: Melvin is not comfortable."
            },
            "diff": [],
            "answer": "A",
            "grammar_answer": "A",
            "backup_answer": "A"
        },
        {
            "id": 803,
            "raw_prog": {
                "First-Order-Logic Rules": "¬Zany(dan) ::: Dan is not zany.\n¬Sour(kenyon) ::: Kenyon is not sour.\nAggressive(terry) ::: Terry is aggressive.\nZany(lesley) ::: Lesley is zany.\nAggressive(kenyon) ::: Kenyon is aggressive.\n¬Comfortable(melvin) ::: Melvin is not comfortable.\nHappy(melvin) ::: Melvin is happy.\nHappy(kenyon) ::: Kenyon is happy.\nComfortable(dan) ::: Dan is comfortable.\nZany(christopher) ::: Christopher is zany.\n¬Comfortable(christopher) ::: Christopher is not comfortable.\n¬Sour(terry) ::: Terry is not sour.\n((Bad(terry))) → ((Zany(melvin))) ::: If Terry is bad, then Melvin is zany.\n(∀x (¬Bad(x) ∨ ¬Aggressive(x))) → (∀x (Sour(x))) ::: If someone is not bad or not aggressive, then he is sour.\n((Aggressive(melvin) ∨ ¬Bad(melvin))) → ((¬Comfortable(terry))) ::: If Melvin is aggressive or Melvin is not bad, then Terry is not comfortable.\n(∀x (Aggressive(x))) ↔ (∀x (Zany(x))) ::: If someone is aggressive, then he is zany, and vice versa.\n((Comfortable(melvin) ∧ ¬Bad(melvin))) → ((Aggressive(graciela))) ::: If Melvin is comfortable and Melvin is not bad, then Graciela is aggressive.\n((Aggressive(lesley))) ↔ ((¬Happy(christopher) ∧ ¬Comfortable(kenyon))) ::: Lesley is aggressive if and only if Christopher is not happy and Kenyon is not comfortable.\n(∀x (Happy(x) ∧ ¬Bad(x))) → (∀x (¬Aggressive(x))) ::: If someone is he or not bad is happy, then he is not aggressive.\n(∃x (¬Comfortable(x) ∧ ¬Happy(x))) → ((¬Aggressive(terry) ∧ Sour(terry))) ::: If there is someone who is neither comfortable nor happy, then Terry is not aggressive and Terry is sour.\n(∀x (Happy(x) ∧ ¬Zany(x))) → (∀x (¬Comfortable(x))) ::: If someone is he or not zany is happy, then he is not comfortable.\n(∀x (Sour(x) ∧ ¬Comfortable(x))) ↔ (∀x (Zany(x))) ::: If someone is sour and not comfortable, then he is zany, and vice versa.\n(∀x (Comfortable(x) ∧ ¬Aggressive(x))) → (∀x (Sour(x) ∧ ¬Bad(x))) ::: Someone who is comfortable and not aggressive is always sour and not bad.\n(∃x (¬Happy(x))) → ((¬Bad(melvin))) ::: If there is at least one people who is not happy, then Melvin is not bad.\n",
                "First-Order-Logic Question": "Bad(lesley) ::: Lesley is bad."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "¬Zany(dan) ::: Dan is not zany.\n¬Sour(kenyon) ::: Kenyon is not sour.\nAggressive(terry) ::: Terry is aggressive.\nZany(lesley) ::: Lesley is zany.\nAggressive(kenyon) ::: Kenyon is aggressive.\n¬Comfortable(melvin) ::: Melvin is not comfortable.\nHappy(melvin) ::: Melvin is happy.\nHappy(kenyon) ::: Kenyon is happy.\nComfortable(dan) ::: Dan is comfortable.\nZany(christopher) ::: Christopher is zany.\n¬Comfortable(christopher) ::: Christopher is not comfortable.\n¬Sour(terry) ::: Terry is not sour.\n((Bad(terry))) → ((Zany(melvin))) ::: If Terry is bad, then Melvin is zany.\n(∀x (¬Bad(x) ∨ ¬Aggressive(x))) → (∀x (Sour(x))) ::: If someone is not bad or not aggressive, then he is sour.\n((Aggressive(melvin) ∨ ¬Bad(melvin))) → ((¬Comfortable(terry))) ::: If Melvin is aggressive or Melvin is not bad, then Terry is not comfortable.\n(∀x (Aggressive(x))) ↔ (∀x (Zany(x))) ::: If someone is aggressive, then he is zany, and vice versa.\n((Comfortable(melvin) ∧ ¬Bad(melvin))) → ((Aggressive(graciela))) ::: If Melvin is comfortable and Melvin is not bad, then Graciela is aggressive.\n((Aggressive(lesley))) ↔ ((¬Happy(christopher) ∧ ¬Comfortable(kenyon))) ::: Lesley is aggressive if and only if Christopher is not happy and Kenyon is not comfortable.\n(∀x (Happy(x) ∧ ¬Bad(x))) → (∀x (¬Aggressive(x))) ::: If someone is he or not bad is happy, then he is not aggressive.\n(∃x (¬Comfortable(x) ∧ ¬Happy(x))) → ((¬Aggressive(terry) ∧ Sour(terry))) ::: If there is someone who is neither comfortable nor happy, then Terry is not aggressive and Terry is sour.\n(∀x (Happy(x) ∧ ¬Zany(x))) → (∀x (¬Comfortable(x))) ::: If someone is he or not zany is happy, then he is not comfortable.\n(∀x (Sour(x) ∧ ¬Comfortable(x))) ↔ (∀x (Zany(x))) ::: If someone is sour and not comfortable, then he is zany, and vice versa.\n(∀x (Comfortable(x) ∧ ¬Aggressive(x))) → (∀x (Sour(x) ∧ ¬Bad(x))) ::: Someone who is comfortable and not aggressive is always sour and not bad.\n(∃x (¬Happy(x))) → ((¬Bad(melvin))) ::: If there is at least one people who is not happy, then Melvin is not bad.\n",
                "First-Order-Logic Question": "Bad(lesley) ::: Lesley is bad."
            },
            "diff": [],
            "answer": "A",
            "grammar_answer": "A",
            "backup_answer": "C"
        },
        {
            "id": 1200,
            "raw_prog": {
                "First-Order-Logic Rules": "¬Several(rolf) ::: Rolf is not several.\n¬Precious(sigmund) ::: Sigmund is not precious.\nPrecious(godwin) ::: Godwin is precious.\nFearless(sigmund) ::: Sigmund is fearless.\nPrecious(rolf) ::: Rolf is precious.\n¬Stubborn(rose) ::: Rose is not stubborn.\nJittery(conrad) ::: Conrad is jittery.\n¬Fearless(brandi) ::: Brandi is not fearless.\n¬Sour(brandi) ::: Brandi is not sour.\nJittery(rolf) ::: Rolf is jittery.\nStubborn(owen) ::: Owen is stubborn.\n¬Fearless(godwin) ::: Godwin is not fearless.\n(¬∃x (¬x)) → (¬Jittery(godwin)) ::: If there is nobody who is not, then Godwin is not jittery.\n(∃x (Several(x) ∨ ¬Sour(x))) → (¬Stubborn(brandi)) ::: If there is someone who is either several or not sour, then Brandi is not stubborn.\n(∃x (¬Sour(x))) → (¬Stubborn(owen) ∧ ¬Several(conrad)) ::: If there is at least one people who is not sour, then Owen is not stubborn and Conrad is not several.\n(∀x (Several(x) → ¬Sour(x))) → (∀x (Stubborn(x))) ::: If someone who is several is also not sour, then he is stubborn.\n(∃x (Sour(x) ∨ Jittery(x))) → (¬Several(brandi) ∧ Stubborn(conrad)) ::: If there is at least one people who is either sour or jittery, then Brandi is not several and Conrad is stubborn.\n(¬Fearless(rolf)) → (¬Jittery(conrad)) ::: If Rolf is not fearless, then Conrad is not jittery.\n(¬Precious(godwin)) → (Jittery(godwin) ∧ ¬Fearless(owen)) ::: It can be concluded that Godwin is jittery and Owen is not fearless once knowing that Godwin is not precious.\n(¬Jittery(godwin) ∧ ¬Several(sigmund)) → (Precious(sigmund)) ::: It can be concluded that Sigmund is precious once knowing that Godwin is not jittery and Sigmund is not several.\n(Several(rolf) ∨ Fearless(brandi)) → (¬Precious(brandi)) ::: If Rolf is several or Brandi is fearless, then Brandi is not precious.\n(¬Jittery(godwin) ∧ Several(conrad)) → (Sour(owen)) ::: If Godwin is not jittery and Conrad is several, then Owen is sour.\n(∀x (Precious(x))) → (∀x (¬Several(x))) ::: Someone who is precious is always not several.\n(¬Fearless(godwin)) ↔ (Several(brandi)) ::: If Godwin is not fearless, then Brandi is several, and vice versa.\n",
                "First-Order-Logic Question": "Sour(brandi) ::: Brandi is sour."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "¬Several(rolf) ::: Rolf is not several.\n¬Precious(sigmund) ::: Sigmund is not precious.\nPrecious(godwin) ::: Godwin is precious.\nFearless(sigmund) ::: Sigmund is fearless.\nPrecious(rolf) ::: Rolf is precious.\n¬Stubborn(rose) ::: Rose is not stubborn.\nJittery(conrad) ::: Conrad is jittery.\n¬Fearless(brandi) ::: Brandi is not fearless.\n¬Sour(brandi) ::: Brandi is not sour.\nJittery(rolf) ::: Rolf is jittery.\nStubborn(owen) ::: Owen is stubborn.\n¬Fearless(godwin) ::: Godwin is not fearless.\n¬∃x(¬(¬(Several(x)))) ::: If there is nobody who is not, then Godwin is not jittery.\n(∃x (Several(x) ∨ ¬Sour(x))) → (¬Stubborn(brandi)) ::: If there is someone who is either several or not sour, then Brandi is not stubborn.\n(∃x (¬Sour(x))) → (¬Stubborn(owen) ∧ ¬Several(conrad)) ::: If there is at least one people who is not sour, then Owen is not stubborn and Conrad is not several.\n(∀x (Several(x) → ¬Sour(x))) → (∀x (Stubborn(x))) ::: If someone who is several is also not sour, then he is stubborn.\n(∃x (Sour(x) ∨ Jittery(x))) → (¬Several(brandi) ∧ Stubborn(conrad)) ::: If there is at least one people who is either sour or jittery, then Brandi is not several and Conrad is stubborn.\n(¬Fearless(rolf)) → (¬Jittery(conrad)) ::: If Rolf is not fearless, then Conrad is not jittery.\n(¬Precious(godwin)) → (Jittery(godwin) ∧ ¬Fearless(owen)) ::: It can be concluded that Godwin is jittery and Owen is not fearless once knowing that Godwin is not precious.\n(¬Jittery(godwin) ∧ ¬Several(sigmund)) → (Precious(sigmund)) ::: It can be concluded that Sigmund is precious once knowing that Godwin is not jittery and Sigmund is not several.\n(Several(rolf) ∨ Fearless(brandi)) → (¬Precious(brandi)) ::: If Rolf is several or Brandi is fearless, then Brandi is not precious.\n(¬Jittery(godwin) ∧ Several(conrad)) → (Sour(owen)) ::: If Godwin is not jittery and Conrad is several, then Owen is sour.\n(∀x (Precious(x))) → (∀x (¬Several(x))) ::: Someone who is precious is always not several.\n(¬Fearless(godwin)) ↔ (Several(brandi)) ::: If Godwin is not fearless, then Brandi is several, and vice versa.\n",
                "First-Order-Logic Question": "Sour(brandi) ::: Brandi is sour."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬x)) → (¬Jittery(godwin)) ::: If there is nobody who is not, then Godwin is not jittery.",
                    "gram": "¬∃x(¬(¬(Several(x)))) ::: If there is nobody who is not, then Godwin is not jittery."
                }
            ],
            "answer": "C",
            "grammar_answer": "A",
            "backup_answer": "B"
        },
        {
            "id": 1201,
            "raw_prog": {
                "First-Order-Logic Rules": "¬Several(rolf) ::: Rolf is not several.\n¬Precious(sigmund) ::: Sigmund is not precious.\nPrecious(godwin) ::: Godwin is precious.\nFearless(sigmund) ::: Sigmund is fearless.\nPrecious(rolf) ::: Rolf is precious.\n¬Stubborn(rose) ::: Rose is not stubborn.\nJittery(conrad) ::: Conrad is jittery.\n¬Fearless(brandi) ::: Brandi is not fearless.\n¬Sour(brandi) ::: Brandi is not sour.\nJittery(rolf) ::: Rolf is jittery.\nStubborn(owen) ::: Owen is stubborn.\n¬Fearless(godwin) ::: Godwin is not fearless.\n(¬∃x (¬x)) → (¬Jittery(godwin)) ::: If there is nobody who is not, then Godwin is not jittery.\n(∃x (Several(x) ∨ ¬Sour(x))) → (¬Stubborn(brandi)) ::: If there is someone who is either several or not sour, then Brandi is not stubborn.\n(∃x (¬Sour(x))) → ((¬Stubborn(owen) ∧ ¬Several(conrad))) ::: If there is at least one people who is not sour, then Owen is not stubborn and Conrad is not several.\n(∀x (Several(x) → ¬Sour(x))) → (∀x (Stubborn(x))) ::: If someone who is several is also not sour, then he is stubborn.\n(∃x (Sour(x) ∨ Jittery(x))) → ((¬Several(brandi) ∧ Stubborn(conrad))) ::: If there is at least one people who is either sour or jittery, then Brandi is not several and Conrad is stubborn.\n(¬Fearless(rolf)) → (¬Jittery(conrad)) ::: If Rolf is not fearless, then Conrad is not jittery.\n(¬Precious(godwin)) → ((Jittery(godwin) ∧ ¬Fearless(owen))) ::: It can be concluded that Godwin is jittery and Owen is not fearless once knowing that Godwin is not precious.\n((¬Jittery(godwin) ∧ ¬Several(sigmund))) → (Precious(sigmund)) ::: It can be concluded that Sigmund is precious once knowing that Godwin is not jittery and Sigmund is not several.\n((Several(rolf) ∨ Fearless(brandi))) → (¬Precious(brandi)) ::: If Rolf is several or Brandi is fearless, then Brandi is not precious.\n((¬Jittery(godwin) ∧ Several(conrad))) → (Sour(owen)) ::: If Godwin is not jittery and Conrad is several, then Owen is sour.\n(∀x (Precious(x))) → (∀x (¬Several(x))) ::: Someone who is precious is always not several.\n((¬Fearless(godwin))) ↔ ((Several(brandi))) ::: If Godwin is not fearless, then Brandi is several, and vice versa.\n",
                "First-Order-Logic Question": "¬Fearless(rose) ::: Rose is not fearless."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "¬Several(rolf) ::: Rolf is not several.\n¬Precious(sigmund) ::: Sigmund is not precious.\nPrecious(godwin) ::: Godwin is precious.\nFearless(sigmund) ::: Sigmund is fearless.\nPrecious(rolf) ::: Rolf is precious.\n¬Stubborn(rose) ::: Rose is not stubborn.\nJittery(conrad) ::: Conrad is jittery.\n¬Fearless(brandi) ::: Brandi is not fearless.\n¬Sour(brandi) ::: Brandi is not sour.\nJittery(rolf) ::: Rolf is jittery.\nStubborn(owen) ::: Owen is stubborn.\n¬Fearless(godwin) ::: Godwin is not fearless.\n¬∃x(¬(¬(Several(x)))) ::: If there is nobody who is not, then Godwin is not jittery.\n(∃x (Several(x) ∨ ¬Sour(x))) → (¬Stubborn(brandi)) ::: If there is someone who is either several or not sour, then Brandi is not stubborn.\n(∃x (¬Sour(x))) → ((¬Stubborn(owen) ∧ ¬Several(conrad))) ::: If there is at least one people who is not sour, then Owen is not stubborn and Conrad is not several.\n(∀x (Several(x) → ¬Sour(x))) → (∀x (Stubborn(x))) ::: If someone who is several is also not sour, then he is stubborn.\n(∃x (Sour(x) ∨ Jittery(x))) → ((¬Several(brandi) ∧ Stubborn(conrad))) ::: If there is at least one people who is either sour or jittery, then Brandi is not several and Conrad is stubborn.\n(¬Fearless(rolf)) → (¬Jittery(conrad)) ::: If Rolf is not fearless, then Conrad is not jittery.\n(¬Precious(godwin)) → ((Jittery(godwin) ∧ ¬Fearless(owen))) ::: It can be concluded that Godwin is jittery and Owen is not fearless once knowing that Godwin is not precious.\n((¬Jittery(godwin) ∧ ¬Several(sigmund))) → (Precious(sigmund)) ::: It can be concluded that Sigmund is precious once knowing that Godwin is not jittery and Sigmund is not several.\n((Several(rolf) ∨ Fearless(brandi))) → (¬Precious(brandi)) ::: If Rolf is several or Brandi is fearless, then Brandi is not precious.\n((¬Jittery(godwin) ∧ Several(conrad))) → (Sour(owen)) ::: If Godwin is not jittery and Conrad is several, then Owen is sour.\n(∀x (Precious(x))) → (∀x (¬Several(x))) ::: Someone who is precious is always not several.\n((¬Fearless(godwin))) ↔ ((Several(brandi))) ::: If Godwin is not fearless, then Brandi is several, and vice versa.\n",
                "First-Order-Logic Question": "¬Fearless(rose) ::: Rose is not fearless."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬x)) → (¬Jittery(godwin)) ::: If there is nobody who is not, then Godwin is not jittery.",
                    "gram": "¬∃x(¬(¬(Several(x)))) ::: If there is nobody who is not, then Godwin is not jittery."
                }
            ],
            "answer": "C",
            "grammar_answer": "A",
            "backup_answer": "C"
        },
        {
            "id": 1202,
            "raw_prog": {
                "First-Order-Logic Rules": "¬Several(rolf) ::: Rolf is not several.\n¬Precious(sigmund) ::: Sigmund is not precious.\nPrecious(godwin) ::: Godwin is precious.\nFearless(sigmund) ::: Sigmund is fearless.\nPrecious(rolf) ::: Rolf is precious.\n¬Stubborn(rose) ::: Rose is not stubborn.\nJittery(conrad) ::: Conrad is jittery.\n¬Fearless(brandi) ::: Brandi is not fearless.\n¬Sour(brandi) ::: Brandi is not sour.\nJittery(rolf) ::: Rolf is jittery.\nStubborn(owen) ::: Owen is stubborn.\n¬Fearless(godwin) ::: Godwin is not fearless.\n(¬∃x (¬x)) → (¬Jittery(godwin)) ::: If there is nobody who is not, then Godwin is not jittery.\n(∃x (Several(x) ∨ ¬Sour(x))) → (¬Stubborn(brandi)) ::: If there is someone who is either several or not sour, then Brandi is not stubborn.\n(∃x (¬Sour(x))) → ((¬Stubborn(owen) ∧ ¬Several(conrad))) ::: If there is at least one people who is not sour, then Owen is not stubborn and Conrad is not several.\n(∀x (Several(x) ∧ ¬Sour(x))) → (∀x (Stubborn(x))) ::: If someone who is several is also not sour, then he is stubborn.\n(∃x (Sour(x) ∨ Jittery(x))) → ((¬Several(brandi) ∧ Stubborn(conrad))) ::: If there is at least one people who is either sour or jittery, then Brandi is not several and Conrad is stubborn.\n(¬Fearless(rolf)) → (¬Jittery(conrad)) ::: If Rolf is not fearless, then Conrad is not jittery.\n((¬Precious(godwin))) → ((Jittery(godwin) ∧ ¬Fearless(owen))) ::: It can be concluded that Godwin is jittery and Owen is not fearless once knowing that Godwin is not precious.\n((¬Jittery(godwin) ∧ ¬Several(sigmund))) → ((Precious(sigmund))) ::: It can be concluded that Sigmund is precious once knowing that Godwin is not jittery and Sigmund is not several.\n((Several(rolf) ∨ Fearless(brandi))) → (¬Precious(brandi)) ::: If Rolf is several or Brandi is fearless, then Brandi is not precious.\n((¬Jittery(godwin) ∧ Several(conrad))) → ((Sour(owen))) ::: If Godwin is not jittery and Conrad is several, then Owen is sour.\n(∀x (Precious(x))) → (∀x (¬Several(x))) ::: Someone who is precious is always not several.\n((¬Fearless(godwin))) ↔ ((Several(brandi))) ::: If Godwin is not fearless, then Brandi is several, and vice versa.\n",
                "First-Order-Logic Question": "Several(owen) ::: Owen is several."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "¬Several(rolf) ::: Rolf is not several.\n¬Precious(sigmund) ::: Sigmund is not precious.\nPrecious(godwin) ::: Godwin is precious.\nFearless(sigmund) ::: Sigmund is fearless.\nPrecious(rolf) ::: Rolf is precious.\n¬Stubborn(rose) ::: Rose is not stubborn.\nJittery(conrad) ::: Conrad is jittery.\n¬Fearless(brandi) ::: Brandi is not fearless.\n¬Sour(brandi) ::: Brandi is not sour.\nJittery(rolf) ::: Rolf is jittery.\nStubborn(owen) ::: Owen is stubborn.\n¬Fearless(godwin) ::: Godwin is not fearless.\n¬∃x(¬(¬(Several(x)))) ::: If there is nobody who is not, then Godwin is not jittery.\n(∃x (Several(x) ∨ ¬Sour(x))) → (¬Stubborn(brandi)) ::: If there is someone who is either several or not sour, then Brandi is not stubborn.\n(∃x (¬Sour(x))) → ((¬Stubborn(owen) ∧ ¬Several(conrad))) ::: If there is at least one people who is not sour, then Owen is not stubborn and Conrad is not several.\n(∀x (Several(x) ∧ ¬Sour(x))) → (∀x (Stubborn(x))) ::: If someone who is several is also not sour, then he is stubborn.\n(∃x (Sour(x) ∨ Jittery(x))) → ((¬Several(brandi) ∧ Stubborn(conrad))) ::: If there is at least one people who is either sour or jittery, then Brandi is not several and Conrad is stubborn.\n(¬Fearless(rolf)) → (¬Jittery(conrad)) ::: If Rolf is not fearless, then Conrad is not jittery.\n((¬Precious(godwin))) → ((Jittery(godwin) ∧ ¬Fearless(owen))) ::: It can be concluded that Godwin is jittery and Owen is not fearless once knowing that Godwin is not precious.\n((¬Jittery(godwin) ∧ ¬Several(sigmund))) → ((Precious(sigmund))) ::: It can be concluded that Sigmund is precious once knowing that Godwin is not jittery and Sigmund is not several.\n((Several(rolf) ∨ Fearless(brandi))) → (¬Precious(brandi)) ::: If Rolf is several or Brandi is fearless, then Brandi is not precious.\n((¬Jittery(godwin) ∧ Several(conrad))) → ((Sour(owen))) ::: If Godwin is not jittery and Conrad is several, then Owen is sour.\n(∀x (Precious(x))) → (∀x (¬Several(x))) ::: Someone who is precious is always not several.\n((¬Fearless(godwin))) ↔ ((Several(brandi))) ::: If Godwin is not fearless, then Brandi is several, and vice versa.\n",
                "First-Order-Logic Question": "Several(owen) ::: Owen is several."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬x)) → (¬Jittery(godwin)) ::: If there is nobody who is not, then Godwin is not jittery.",
                    "gram": "¬∃x(¬(¬(Several(x)))) ::: If there is nobody who is not, then Godwin is not jittery."
                }
            ],
            "answer": "B",
            "grammar_answer": "A",
            "backup_answer": "C"
        },
        {
            "id": 1203,
            "raw_prog": {
                "First-Order-Logic Rules": "¬Several(rolf) ::: Rolf is not several.\n¬Precious(sigmund) ::: Sigmund is not precious.\nPrecious(godwin) ::: Godwin is precious.\nFearless(sigmund) ::: Sigmund is fearless.\nPrecious(rolf) ::: Rolf is precious.\n¬Stubborn(rose) ::: Rose is not stubborn.\nJittery(conrad) ::: Conrad is jittery.\n¬Fearless(brandi) ::: Brandi is not fearless.\n¬Sour(brandi) ::: Brandi is not sour.\nJittery(rolf) ::: Rolf is jittery.\nStubborn(owen) ::: Owen is stubborn.\n¬Fearless(godwin) ::: Godwin is not fearless.\n(¬∃x (¬x)) → (¬Jittery(godwin)) ::: If there is nobody who is not, then Godwin is not jittery.\n(∃x (Several(x) ∨ ¬Sour(x))) → (¬Stubborn(brandi)) ::: If there is someone who is either several or not sour, then Brandi is not stubborn.\n(∃x (¬Sour(x))) → ((¬Stubborn(owen) ∧ ¬Several(conrad))) ::: If there is at least one people who is not sour, then Owen is not stubborn and Conrad is not several.\n(∀x (Several(x) ∧ ¬Sour(x))) → (∀x (Stubborn(x))) ::: If someone who is several is also not sour, then he is stubborn.\n(∃x (Sour(x) ∨ Jittery(x))) → ((¬Several(brandi) ∧ Stubborn(conrad))) ::: If there is at least one people who is either sour or jittery, then Brandi is not several and Conrad is stubborn.\n(¬Fearless(rolf)) → (¬Jittery(conrad)) ::: If Rolf is not fearless, then Conrad is not jittery.\n(¬Precious(godwin)) → ((Jittery(godwin) ∧ ¬Fearless(owen))) ::: It can be concluded that Godwin is jittery and Owen is not fearless once knowing that Godwin is not precious.\n((¬Jittery(godwin) ∧ ¬Several(sigmund))) → (Precious(sigmund)) ::: It can be concluded that Sigmund is precious once knowing that Godwin is not jittery and Sigmund is not several.\n((Several(rolf) ∨ Fearless(brandi))) → (¬Precious(brandi)) ::: If Rolf is several or Brandi is fearless, then Brandi is not precious.\n((¬Jittery(godwin) ∧ Several(conrad))) → (Sour(owen)) ::: If Godwin is not jittery and Conrad is several, then Owen is sour.\n(∀x (Precious(x))) → (∀x (¬Several(x))) ::: Someone who is precious is always not several.\n(¬Fearless(godwin)) ↔ (Several(brandi)) ::: If Godwin is not fearless, then Brandi is several, and vice versa.\n",
                "First-Order-Logic Question": "¬Fearless(sigmund) ::: Sigmund is not fearless."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "¬Several(rolf) ::: Rolf is not several.\n¬Precious(sigmund) ::: Sigmund is not precious.\nPrecious(godwin) ::: Godwin is precious.\nFearless(sigmund) ::: Sigmund is fearless.\nPrecious(rolf) ::: Rolf is precious.\n¬Stubborn(rose) ::: Rose is not stubborn.\nJittery(conrad) ::: Conrad is jittery.\n¬Fearless(brandi) ::: Brandi is not fearless.\n¬Sour(brandi) ::: Brandi is not sour.\nJittery(rolf) ::: Rolf is jittery.\nStubborn(owen) ::: Owen is stubborn.\n¬Fearless(godwin) ::: Godwin is not fearless.\n¬∃x(¬(¬(Several(x)))) ::: If there is nobody who is not, then Godwin is not jittery.\n(∃x (Several(x) ∨ ¬Sour(x))) → (¬Stubborn(brandi)) ::: If there is someone who is either several or not sour, then Brandi is not stubborn.\n(∃x (¬Sour(x))) → ((¬Stubborn(owen) ∧ ¬Several(conrad))) ::: If there is at least one people who is not sour, then Owen is not stubborn and Conrad is not several.\n(∀x (Several(x) ∧ ¬Sour(x))) → (∀x (Stubborn(x))) ::: If someone who is several is also not sour, then he is stubborn.\n(∃x (Sour(x) ∨ Jittery(x))) → ((¬Several(brandi) ∧ Stubborn(conrad))) ::: If there is at least one people who is either sour or jittery, then Brandi is not several and Conrad is stubborn.\n(¬Fearless(rolf)) → (¬Jittery(conrad)) ::: If Rolf is not fearless, then Conrad is not jittery.\n(¬Precious(godwin)) → ((Jittery(godwin) ∧ ¬Fearless(owen))) ::: It can be concluded that Godwin is jittery and Owen is not fearless once knowing that Godwin is not precious.\n((¬Jittery(godwin) ∧ ¬Several(sigmund))) → (Precious(sigmund)) ::: It can be concluded that Sigmund is precious once knowing that Godwin is not jittery and Sigmund is not several.\n((Several(rolf) ∨ Fearless(brandi))) → (¬Precious(brandi)) ::: If Rolf is several or Brandi is fearless, then Brandi is not precious.\n((¬Jittery(godwin) ∧ Several(conrad))) → (Sour(owen)) ::: If Godwin is not jittery and Conrad is several, then Owen is sour.\n(∀x (Precious(x))) → (∀x (¬Several(x))) ::: Someone who is precious is always not several.\n(¬Fearless(godwin)) ↔ (Several(brandi)) ::: If Godwin is not fearless, then Brandi is several, and vice versa.\n",
                "First-Order-Logic Question": "¬Fearless(sigmund) ::: Sigmund is not fearless."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬x)) → (¬Jittery(godwin)) ::: If there is nobody who is not, then Godwin is not jittery.",
                    "gram": "¬∃x(¬(¬(Several(x)))) ::: If there is nobody who is not, then Godwin is not jittery."
                }
            ],
            "answer": "A",
            "grammar_answer": "A",
            "backup_answer": "B"
        },
        {
            "id": 1204,
            "raw_prog": {
                "First-Order-Logic Rules": "¬Several(rolf) ::: Rolf is not several.\n¬Precious(sigmund) ::: Sigmund is not precious.\nPrecious(godwin) ::: Godwin is precious.\nFearless(sigmund) ::: Sigmund is fearless.\nPrecious(rolf) ::: Rolf is precious.\n¬Stubborn(rose) ::: Rose is not stubborn.\nJittery(conrad) ::: Conrad is jittery.\n¬Fearless(brandi) ::: Brandi is not fearless.\n¬Sour(brandi) ::: Brandi is not sour.\nJittery(rolf) ::: Rolf is jittery.\nStubborn(owen) ::: Owen is stubborn.\n¬Fearless(godwin) ::: Godwin is not fearless.\n(¬∃x (¬x)) → (¬Jittery(godwin)) ::: If there is nobody who is not, then Godwin is not jittery.\n(∃x (Several(x) ∨ ¬Sour(x))) → (¬Stubborn(brandi)) ::: If there is someone who is either several or not sour, then Brandi is not stubborn.\n(∃x (¬Sour(x))) → ((¬Stubborn(owen) ∧ ¬Several(conrad))) ::: If there is at least one people who is not sour, then Owen is not stubborn and Conrad is not several.\n(∀x (Several(x) → ¬Sour(x))) → (∀x (Stubborn(x))) ::: If someone who is several is also not sour, then he is stubborn.\n(∃x (Sour(x) ∨ Jittery(x))) → ((¬Several(brandi) ∧ Stubborn(conrad))) ::: If there is at least one people who is either sour or jittery, then Brandi is not several and Conrad is stubborn.\n(¬Fearless(rolf)) → (¬Jittery(conrad)) ::: If Rolf is not fearless, then Conrad is not jittery.\n(¬Precious(godwin)) → ((Jittery(godwin) ∧ ¬Fearless(owen))) ::: It can be concluded that Godwin is jittery and Owen is not fearless once knowing that Godwin is not precious.\n((¬Jittery(godwin) ∧ ¬Several(sigmund))) → (Precious(sigmund)) ::: It can be concluded that Sigmund is precious once knowing that Godwin is not jittery and Sigmund is not several.\n((Several(rolf) ∨ Fearless(brandi))) → (¬Precious(brandi)) ::: If Rolf is several or Brandi is fearless, then Brandi is not precious.\n((¬Jittery(godwin) ∧ Several(conrad))) → (Sour(owen)) ::: If Godwin is not jittery and Conrad is several, then Owen is sour.\n(∀x (Precious(x))) → (∀x (¬Several(x))) ::: Someone who is precious is always not several.\n(¬Fearless(godwin)) ↔ (Several(brandi)) ::: If Godwin is not fearless, then Brandi is several, and vice versa.\n",
                "First-Order-Logic Question": "Jittery(conrad) ::: Conrad is jittery."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "¬Several(rolf) ::: Rolf is not several.\n¬Precious(sigmund) ::: Sigmund is not precious.\nPrecious(godwin) ::: Godwin is precious.\nFearless(sigmund) ::: Sigmund is fearless.\nPrecious(rolf) ::: Rolf is precious.\n¬Stubborn(rose) ::: Rose is not stubborn.\nJittery(conrad) ::: Conrad is jittery.\n¬Fearless(brandi) ::: Brandi is not fearless.\n¬Sour(brandi) ::: Brandi is not sour.\nJittery(rolf) ::: Rolf is jittery.\nStubborn(owen) ::: Owen is stubborn.\n¬Fearless(godwin) ::: Godwin is not fearless.\n¬∃x(¬(¬(Several(x)))) ::: If there is nobody who is not, then Godwin is not jittery.\n(∃x (Several(x) ∨ ¬Sour(x))) → (¬Stubborn(brandi)) ::: If there is someone who is either several or not sour, then Brandi is not stubborn.\n(∃x (¬Sour(x))) → ((¬Stubborn(owen) ∧ ¬Several(conrad))) ::: If there is at least one people who is not sour, then Owen is not stubborn and Conrad is not several.\n(∀x (Several(x) → ¬Sour(x))) → (∀x (Stubborn(x))) ::: If someone who is several is also not sour, then he is stubborn.\n(∃x (Sour(x) ∨ Jittery(x))) → ((¬Several(brandi) ∧ Stubborn(conrad))) ::: If there is at least one people who is either sour or jittery, then Brandi is not several and Conrad is stubborn.\n(¬Fearless(rolf)) → (¬Jittery(conrad)) ::: If Rolf is not fearless, then Conrad is not jittery.\n(¬Precious(godwin)) → ((Jittery(godwin) ∧ ¬Fearless(owen))) ::: It can be concluded that Godwin is jittery and Owen is not fearless once knowing that Godwin is not precious.\n((¬Jittery(godwin) ∧ ¬Several(sigmund))) → (Precious(sigmund)) ::: It can be concluded that Sigmund is precious once knowing that Godwin is not jittery and Sigmund is not several.\n((Several(rolf) ∨ Fearless(brandi))) → (¬Precious(brandi)) ::: If Rolf is several or Brandi is fearless, then Brandi is not precious.\n((¬Jittery(godwin) ∧ Several(conrad))) → (Sour(owen)) ::: If Godwin is not jittery and Conrad is several, then Owen is sour.\n(∀x (Precious(x))) → (∀x (¬Several(x))) ::: Someone who is precious is always not several.\n(¬Fearless(godwin)) ↔ (Several(brandi)) ::: If Godwin is not fearless, then Brandi is several, and vice versa.\n",
                "First-Order-Logic Question": "Jittery(conrad) ::: Conrad is jittery."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬x)) → (¬Jittery(godwin)) ::: If there is nobody who is not, then Godwin is not jittery.",
                    "gram": "¬∃x(¬(¬(Several(x)))) ::: If there is nobody who is not, then Godwin is not jittery."
                }
            ],
            "answer": "C",
            "grammar_answer": "A",
            "backup_answer": "A"
        },
        {
            "id": 1205,
            "raw_prog": {
                "First-Order-Logic Rules": "¬Several(rolf) ::: Rolf is not several.\n¬Precious(sigmund) ::: Sigmund is not precious.\nPrecious(godwin) ::: Godwin is precious.\nFearless(sigmund) ::: Sigmund is fearless.\nPrecious(rolf) ::: Rolf is precious.\n¬Stubborn(rose) ::: Rose is not stubborn.\nJittery(conrad) ::: Conrad is jittery.\n¬Fearless(brandi) ::: Brandi is not fearless.\n¬Sour(brandi) ::: Brandi is not sour.\nJittery(rolf) ::: Rolf is jittery.\nStubborn(owen) ::: Owen is stubborn.\n¬Fearless(godwin) ::: Godwin is not fearless.\n(¬∃x (¬x)) → (¬Jittery(godwin)) ::: If there is nobody who is not, then Godwin is not jittery.\n(∃x (Several(x) ∨ ¬Sour(x))) → (¬Stubborn(brandi)) ::: If there is someone who is either several or not sour, then Brandi is not stubborn.\n(∃x (¬Sour(x))) → ((¬Stubborn(owen) ∧ ¬Several(conrad))) ::: If there is at least one people who is not sour, then Owen is not stubborn and Conrad is not several.\n(∀x (Several(x) ∧ ¬Sour(x))) → (∀x (Stubborn(x))) ::: If someone who is several is also not sour, then he is stubborn.\n(∃x (Sour(x) ∨ Jittery(x))) → ((¬Several(brandi) ∧ Stubborn(conrad))) ::: If there is at least one people who is either sour or jittery, then Brandi is not several and Conrad is stubborn.\n(¬Fearless(rolf)) → (¬Jittery(conrad)) ::: If Rolf is not fearless, then Conrad is not jittery.\n((¬Precious(godwin))) → ((Jittery(godwin) ∧ ¬Fearless(owen))) ::: It can be concluded that Godwin is jittery and Owen is not fearless once knowing that Godwin is not precious.\n((¬Jittery(godwin) ∧ ¬Several(sigmund))) → ((Precious(sigmund))) ::: It can be concluded that Sigmund is precious once knowing that Godwin is not jittery and Sigmund is not several.\n((Several(rolf) ∨ Fearless(brandi))) → ((¬Precious(brandi))) ::: If Rolf is several or Brandi is fearless, then Brandi is not precious.\n((¬Jittery(godwin) ∧ Several(conrad))) → ((Sour(owen))) ::: If Godwin is not jittery and Conrad is several, then Owen is sour.\n(∀x (Precious(x))) → (∀x (¬Several(x))) ::: Someone who is precious is always not several.\n((¬Fearless(godwin))) ↔ ((Several(brandi))) ::: If Godwin is not fearless, then Brandi is several, and vice versa.\n",
                "First-Order-Logic Question": "Fearless(owen) ::: Owen is fearless."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "¬Several(rolf) ::: Rolf is not several.\n¬Precious(sigmund) ::: Sigmund is not precious.\nPrecious(godwin) ::: Godwin is precious.\nFearless(sigmund) ::: Sigmund is fearless.\nPrecious(rolf) ::: Rolf is precious.\n¬Stubborn(rose) ::: Rose is not stubborn.\nJittery(conrad) ::: Conrad is jittery.\n¬Fearless(brandi) ::: Brandi is not fearless.\n¬Sour(brandi) ::: Brandi is not sour.\nJittery(rolf) ::: Rolf is jittery.\nStubborn(owen) ::: Owen is stubborn.\n¬Fearless(godwin) ::: Godwin is not fearless.\n¬∃x(¬(¬(Several(x)))) ::: If there is nobody who is not, then Godwin is not jittery.\n(∃x (Several(x) ∨ ¬Sour(x))) → (¬Stubborn(brandi)) ::: If there is someone who is either several or not sour, then Brandi is not stubborn.\n(∃x (¬Sour(x))) → ((¬Stubborn(owen) ∧ ¬Several(conrad))) ::: If there is at least one people who is not sour, then Owen is not stubborn and Conrad is not several.\n(∀x (Several(x) ∧ ¬Sour(x))) → (∀x (Stubborn(x))) ::: If someone who is several is also not sour, then he is stubborn.\n(∃x (Sour(x) ∨ Jittery(x))) → ((¬Several(brandi) ∧ Stubborn(conrad))) ::: If there is at least one people who is either sour or jittery, then Brandi is not several and Conrad is stubborn.\n(¬Fearless(rolf)) → (¬Jittery(conrad)) ::: If Rolf is not fearless, then Conrad is not jittery.\n((¬Precious(godwin))) → ((Jittery(godwin) ∧ ¬Fearless(owen))) ::: It can be concluded that Godwin is jittery and Owen is not fearless once knowing that Godwin is not precious.\n((¬Jittery(godwin) ∧ ¬Several(sigmund))) → ((Precious(sigmund))) ::: It can be concluded that Sigmund is precious once knowing that Godwin is not jittery and Sigmund is not several.\n((Several(rolf) ∨ Fearless(brandi))) → ((¬Precious(brandi))) ::: If Rolf is several or Brandi is fearless, then Brandi is not precious.\n((¬Jittery(godwin) ∧ Several(conrad))) → ((Sour(owen))) ::: If Godwin is not jittery and Conrad is several, then Owen is sour.\n(∀x (Precious(x))) → (∀x (¬Several(x))) ::: Someone who is precious is always not several.\n((¬Fearless(godwin))) ↔ ((Several(brandi))) ::: If Godwin is not fearless, then Brandi is several, and vice versa.\n",
                "First-Order-Logic Question": "Fearless(owen) ::: Owen is fearless."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬x)) → (¬Jittery(godwin)) ::: If there is nobody who is not, then Godwin is not jittery.",
                    "gram": "¬∃x(¬(¬(Several(x)))) ::: If there is nobody who is not, then Godwin is not jittery."
                }
            ],
            "answer": "A",
            "grammar_answer": "A",
            "backup_answer": "C"
        },
        {
            "id": 1206,
            "raw_prog": {
                "First-Order-Logic Rules": "¬Several(rolf) ::: Rolf is not several.\n¬Precious(sigmund) ::: Sigmund is not precious.\nPrecious(godwin) ::: Godwin is precious.\nFearless(sigmund) ::: Sigmund is fearless.\nPrecious(rolf) ::: Rolf is precious.\n¬Stubborn(rose) ::: Rose is not stubborn.\nJittery(conrad) ::: Conrad is jittery.\n¬Fearless(brandi) ::: Brandi is not fearless.\n¬Sour(brandi) ::: Brandi is not sour.\nJittery(rolf) ::: Rolf is jittery.\nStubborn(owen) ::: Owen is stubborn.\n¬Fearless(godwin) ::: Godwin is not fearless.\n(¬∃x (¬x)) → (¬Jittery(godwin)) ::: If there is nobody who is not, then Godwin is not jittery.\n(∃x (Several(x) ∨ ¬Sour(x))) → (¬Stubborn(brandi)) ::: If there is someone who is either several or not sour, then Brandi is not stubborn.\n(∃x (¬Sour(x))) → ((¬Stubborn(owen) ∧ ¬Several(conrad))) ::: If there is at least one people who is not sour, then Owen is not stubborn and Conrad is not several.\n(∀x (Several(x) ∧ ¬Sour(x))) → (∀x (Stubborn(x))) ::: If someone who is several is also not sour, then he is stubborn.\n(∃x (Sour(x) ∨ Jittery(x))) → ((¬Several(brandi) ∧ Stubborn(conrad))) ::: If there is at least one people who is either sour or jittery, then Brandi is not several and Conrad is stubborn.\n(¬Fearless(rolf)) → (¬Jittery(conrad)) ::: If Rolf is not fearless, then Conrad is not jittery.\n(¬Precious(godwin)) → ((Jittery(godwin) ∧ ¬Fearless(owen))) ::: It can be concluded that Godwin is jittery and Owen is not fearless once knowing that Godwin is not precious.\n((¬Jittery(godwin) ∧ ¬Several(sigmund))) → (Precious(sigmund)) ::: It can be concluded that Sigmund is precious once knowing that Godwin is not jittery and Sigmund is not several.\n((Several(rolf) ∨ Fearless(brandi))) → (¬Precious(brandi)) ::: If Rolf is several or Brandi is fearless, then Brandi is not precious.\n((¬Jittery(godwin) ∧ Several(conrad))) → (Sour(owen)) ::: If Godwin is not jittery and Conrad is several, then Owen is sour.\n(∀x (Precious(x))) → (∀x (¬Several(x))) ::: Someone who is precious is always not several.\n(¬Fearless(godwin)) ↔ (Several(brandi)) ::: If Godwin is not fearless, then Brandi is several, and vice versa.\n",
                "First-Order-Logic Question": "Fearless(sigmund) ::: Sigmund is fearless."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "¬Several(rolf) ::: Rolf is not several.\n¬Precious(sigmund) ::: Sigmund is not precious.\nPrecious(godwin) ::: Godwin is precious.\nFearless(sigmund) ::: Sigmund is fearless.\nPrecious(rolf) ::: Rolf is precious.\n¬Stubborn(rose) ::: Rose is not stubborn.\nJittery(conrad) ::: Conrad is jittery.\n¬Fearless(brandi) ::: Brandi is not fearless.\n¬Sour(brandi) ::: Brandi is not sour.\nJittery(rolf) ::: Rolf is jittery.\nStubborn(owen) ::: Owen is stubborn.\n¬Fearless(godwin) ::: Godwin is not fearless.\n¬∃x(¬(¬(Several(x)))) ::: If there is nobody who is not, then Godwin is not jittery.\n(∃x (Several(x) ∨ ¬Sour(x))) → (¬Stubborn(brandi)) ::: If there is someone who is either several or not sour, then Brandi is not stubborn.\n(∃x (¬Sour(x))) → ((¬Stubborn(owen) ∧ ¬Several(conrad))) ::: If there is at least one people who is not sour, then Owen is not stubborn and Conrad is not several.\n(∀x (Several(x) ∧ ¬Sour(x))) → (∀x (Stubborn(x))) ::: If someone who is several is also not sour, then he is stubborn.\n(∃x (Sour(x) ∨ Jittery(x))) → ((¬Several(brandi) ∧ Stubborn(conrad))) ::: If there is at least one people who is either sour or jittery, then Brandi is not several and Conrad is stubborn.\n(¬Fearless(rolf)) → (¬Jittery(conrad)) ::: If Rolf is not fearless, then Conrad is not jittery.\n(¬Precious(godwin)) → ((Jittery(godwin) ∧ ¬Fearless(owen))) ::: It can be concluded that Godwin is jittery and Owen is not fearless once knowing that Godwin is not precious.\n((¬Jittery(godwin) ∧ ¬Several(sigmund))) → (Precious(sigmund)) ::: It can be concluded that Sigmund is precious once knowing that Godwin is not jittery and Sigmund is not several.\n((Several(rolf) ∨ Fearless(brandi))) → (¬Precious(brandi)) ::: If Rolf is several or Brandi is fearless, then Brandi is not precious.\n((¬Jittery(godwin) ∧ Several(conrad))) → (Sour(owen)) ::: If Godwin is not jittery and Conrad is several, then Owen is sour.\n(∀x (Precious(x))) → (∀x (¬Several(x))) ::: Someone who is precious is always not several.\n(¬Fearless(godwin)) ↔ (Several(brandi)) ::: If Godwin is not fearless, then Brandi is several, and vice versa.\n",
                "First-Order-Logic Question": "Fearless(sigmund) ::: Sigmund is fearless."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬x)) → (¬Jittery(godwin)) ::: If there is nobody who is not, then Godwin is not jittery.",
                    "gram": "¬∃x(¬(¬(Several(x)))) ::: If there is nobody who is not, then Godwin is not jittery."
                }
            ],
            "answer": "C",
            "grammar_answer": "A",
            "backup_answer": "A"
        },
        {
            "id": 1207,
            "raw_prog": {
                "First-Order-Logic Rules": "¬Several(rolf) ::: Rolf is not several.\n¬Precious(sigmund) ::: Sigmund is not precious.\nPrecious(godwin) ::: Godwin is precious.\nFearless(sigmund) ::: Sigmund is fearless.\nPrecious(rolf) ::: Rolf is precious.\n¬Stubborn(rose) ::: Rose is not stubborn.\nJittery(conrad) ::: Conrad is jittery.\n¬Fearless(brandi) ::: Brandi is not fearless.\n¬Sour(brandi) ::: Brandi is not sour.\nJittery(rolf) ::: Rolf is jittery.\nStubborn(owen) ::: Owen is stubborn.\n¬Fearless(godwin) ::: Godwin is not fearless.\n(¬∃x (¬x)) → (¬Jittery(godwin)) ::: If there is nobody who is not, then Godwin is not jittery.\n(∃x (Several(x) ∨ ¬Sour(x))) → (¬Stubborn(brandi)) ::: If there is someone who is either several or not sour, then Brandi is not stubborn.\n(∃x (¬Sour(x))) → (¬Stubborn(owen) ∧ ¬Several(conrad)) ::: If there is at least one people who is not sour, then Owen is not stubborn and Conrad is not several.\n(∀x (Several(x) → ¬Sour(x))) → (∀x (Stubborn(x))) ::: If someone who is several is also not sour, then he is stubborn.\n(∃x (Sour(x) ∨ Jittery(x))) → (¬Several(brandi) ∧ Stubborn(conrad)) ::: If there is at least one people who is either sour or jittery, then Brandi is not several and Conrad is stubborn.\n(¬Fearless(rolf)) → (¬Jittery(conrad)) ::: If Rolf is not fearless, then Conrad is not jittery.\n(¬Precious(godwin)) → (Jittery(godwin) ∧ ¬Fearless(owen)) ::: It can be concluded that Godwin is jittery and Owen is not fearless once knowing that Godwin is not precious.\n(¬Jittery(godwin) ∧ ¬Several(sigmund)) → (Precious(sigmund)) ::: It can be concluded that Sigmund is precious once knowing that Godwin is not jittery and Sigmund is not several.\n(Several(rolf) ∨ Fearless(brandi)) → (¬Precious(brandi)) ::: If Rolf is several or Brandi is fearless, then Brandi is not precious.\n(¬Jittery(godwin) ∧ Several(conrad)) → (Sour(owen)) ::: If Godwin is not jittery and Conrad is several, then Owen is sour.\n(∀x (Precious(x))) → (∀x (¬Several(x))) ::: Someone who is precious is always not several.\n(¬Fearless(godwin)) ↔ (Several(brandi)) ::: If Godwin is not fearless, then Brandi is several, and vice versa.\n",
                "First-Order-Logic Question": "Precious(conrad) ::: Conrad is precious."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "¬Several(rolf) ::: Rolf is not several.\n¬Precious(sigmund) ::: Sigmund is not precious.\nPrecious(godwin) ::: Godwin is precious.\nFearless(sigmund) ::: Sigmund is fearless.\nPrecious(rolf) ::: Rolf is precious.\n¬Stubborn(rose) ::: Rose is not stubborn.\nJittery(conrad) ::: Conrad is jittery.\n¬Fearless(brandi) ::: Brandi is not fearless.\n¬Sour(brandi) ::: Brandi is not sour.\nJittery(rolf) ::: Rolf is jittery.\nStubborn(owen) ::: Owen is stubborn.\n¬Fearless(godwin) ::: Godwin is not fearless.\n¬∃x(¬(¬(Several(x)))) ::: If there is nobody who is not, then Godwin is not jittery.\n(∃x (Several(x) ∨ ¬Sour(x))) → (¬Stubborn(brandi)) ::: If there is someone who is either several or not sour, then Brandi is not stubborn.\n(∃x (¬Sour(x))) → (¬Stubborn(owen) ∧ ¬Several(conrad)) ::: If there is at least one people who is not sour, then Owen is not stubborn and Conrad is not several.\n(∀x (Several(x) → ¬Sour(x))) → (∀x (Stubborn(x))) ::: If someone who is several is also not sour, then he is stubborn.\n(∃x (Sour(x) ∨ Jittery(x))) → (¬Several(brandi) ∧ Stubborn(conrad)) ::: If there is at least one people who is either sour or jittery, then Brandi is not several and Conrad is stubborn.\n(¬Fearless(rolf)) → (¬Jittery(conrad)) ::: If Rolf is not fearless, then Conrad is not jittery.\n(¬Precious(godwin)) → (Jittery(godwin) ∧ ¬Fearless(owen)) ::: It can be concluded that Godwin is jittery and Owen is not fearless once knowing that Godwin is not precious.\n(¬Jittery(godwin) ∧ ¬Several(sigmund)) → (Precious(sigmund)) ::: It can be concluded that Sigmund is precious once knowing that Godwin is not jittery and Sigmund is not several.\n(Several(rolf) ∨ Fearless(brandi)) → (¬Precious(brandi)) ::: If Rolf is several or Brandi is fearless, then Brandi is not precious.\n(¬Jittery(godwin) ∧ Several(conrad)) → (Sour(owen)) ::: If Godwin is not jittery and Conrad is several, then Owen is sour.\n(∀x (Precious(x))) → (∀x (¬Several(x))) ::: Someone who is precious is always not several.\n(¬Fearless(godwin)) ↔ (Several(brandi)) ::: If Godwin is not fearless, then Brandi is several, and vice versa.\n",
                "First-Order-Logic Question": "Precious(conrad) ::: Conrad is precious."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬x)) → (¬Jittery(godwin)) ::: If there is nobody who is not, then Godwin is not jittery.",
                    "gram": "¬∃x(¬(¬(Several(x)))) ::: If there is nobody who is not, then Godwin is not jittery."
                }
            ],
            "answer": "B",
            "grammar_answer": "A",
            "backup_answer": "C"
        },
        {
            "id": 1208,
            "raw_prog": {
                "First-Order-Logic Rules": "¬Several(rolf) ::: Rolf is not several.\n¬Precious(sigmund) ::: Sigmund is not precious.\nPrecious(godwin) ::: Godwin is precious.\nFearless(sigmund) ::: Sigmund is fearless.\nPrecious(rolf) ::: Rolf is precious.\n¬Stubborn(rose) ::: Rose is not stubborn.\nJittery(conrad) ::: Conrad is jittery.\n¬Fearless(brandi) ::: Brandi is not fearless.\n¬Sour(brandi) ::: Brandi is not sour.\nJittery(rolf) ::: Rolf is jittery.\nStubborn(owen) ::: Owen is stubborn.\n¬Fearless(godwin) ::: Godwin is not fearless.\n(¬∃x (¬x)) → (¬Jittery(godwin)) ::: If there is nobody who is not, then Godwin is not jittery.\n(∃x (Several(x) ∨ ¬Sour(x))) → (¬Stubborn(brandi)) ::: If there is someone who is either several or not sour, then Brandi is not stubborn.\n(∃x (¬Sour(x))) → ((¬Stubborn(owen) ∧ ¬Several(conrad))) ::: If there is at least one people who is not sour, then Owen is not stubborn and Conrad is not several.\n(∀x (Several(x) ∧ ¬Sour(x))) → (∀x (Stubborn(x))) ::: If someone who is several is also not sour, then he is stubborn.\n(∃x (Sour(x) ∨ Jittery(x))) → ((¬Several(brandi) ∧ Stubborn(conrad))) ::: If there is at least one people who is either sour or jittery, then Brandi is not several and Conrad is stubborn.\n(¬Fearless(rolf)) → (¬Jittery(conrad)) ::: If Rolf is not fearless, then Conrad is not jittery.\n((¬Precious(godwin))) → ((Jittery(godwin) ∧ ¬Fearless(owen))) ::: It can be concluded that Godwin is jittery and Owen is not fearless once knowing that Godwin is not precious.\n((¬Jittery(godwin) ∧ ¬Several(sigmund))) → (Precious(sigmund)) ::: It can be concluded that Sigmund is precious once knowing that Godwin is not jittery and Sigmund is not several.\n((Several(rolf) ∨ Fearless(brandi))) → (¬Precious(brandi)) ::: If Rolf is several or Brandi is fearless, then Brandi is not precious.\n((¬Jittery(godwin) ∧ Several(conrad))) → (Sour(owen)) ::: If Godwin is not jittery and Conrad is several, then Owen is sour.\n(∀x (Precious(x))) → (∀x (¬Several(x))) ::: Someone who is precious is always not several.\n((¬Fearless(godwin))) ↔ ((Several(brandi))) ::: If Godwin is not fearless, then Brandi is several, and vice versa.\n",
                "First-Order-Logic Question": "Several(rolf) ::: Rolf is several."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "¬Several(rolf) ::: Rolf is not several.\n¬Precious(sigmund) ::: Sigmund is not precious.\nPrecious(godwin) ::: Godwin is precious.\nFearless(sigmund) ::: Sigmund is fearless.\nPrecious(rolf) ::: Rolf is precious.\n¬Stubborn(rose) ::: Rose is not stubborn.\nJittery(conrad) ::: Conrad is jittery.\n¬Fearless(brandi) ::: Brandi is not fearless.\n¬Sour(brandi) ::: Brandi is not sour.\nJittery(rolf) ::: Rolf is jittery.\nStubborn(owen) ::: Owen is stubborn.\n¬Fearless(godwin) ::: Godwin is not fearless.\n¬∃x(¬(¬(Several(x)))) ::: If there is nobody who is not, then Godwin is not jittery.\n(∃x (Several(x) ∨ ¬Sour(x))) → (¬Stubborn(brandi)) ::: If there is someone who is either several or not sour, then Brandi is not stubborn.\n(∃x (¬Sour(x))) → ((¬Stubborn(owen) ∧ ¬Several(conrad))) ::: If there is at least one people who is not sour, then Owen is not stubborn and Conrad is not several.\n(∀x (Several(x) ∧ ¬Sour(x))) → (∀x (Stubborn(x))) ::: If someone who is several is also not sour, then he is stubborn.\n(∃x (Sour(x) ∨ Jittery(x))) → ((¬Several(brandi) ∧ Stubborn(conrad))) ::: If there is at least one people who is either sour or jittery, then Brandi is not several and Conrad is stubborn.\n(¬Fearless(rolf)) → (¬Jittery(conrad)) ::: If Rolf is not fearless, then Conrad is not jittery.\n((¬Precious(godwin))) → ((Jittery(godwin) ∧ ¬Fearless(owen))) ::: It can be concluded that Godwin is jittery and Owen is not fearless once knowing that Godwin is not precious.\n((¬Jittery(godwin) ∧ ¬Several(sigmund))) → (Precious(sigmund)) ::: It can be concluded that Sigmund is precious once knowing that Godwin is not jittery and Sigmund is not several.\n((Several(rolf) ∨ Fearless(brandi))) → (¬Precious(brandi)) ::: If Rolf is several or Brandi is fearless, then Brandi is not precious.\n((¬Jittery(godwin) ∧ Several(conrad))) → (Sour(owen)) ::: If Godwin is not jittery and Conrad is several, then Owen is sour.\n(∀x (Precious(x))) → (∀x (¬Several(x))) ::: Someone who is precious is always not several.\n((¬Fearless(godwin))) ↔ ((Several(brandi))) ::: If Godwin is not fearless, then Brandi is several, and vice versa.\n",
                "First-Order-Logic Question": "Several(rolf) ::: Rolf is several."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬x)) → (¬Jittery(godwin)) ::: If there is nobody who is not, then Godwin is not jittery.",
                    "gram": "¬∃x(¬(¬(Several(x)))) ::: If there is nobody who is not, then Godwin is not jittery."
                }
            ],
            "answer": "A",
            "grammar_answer": "A",
            "backup_answer": "B"
        },
        {
            "id": 1209,
            "raw_prog": {
                "First-Order-Logic Rules": "¬Several(rolf) ::: Rolf is not several.\n¬Precious(sigmund) ::: Sigmund is not precious.\nPrecious(godwin) ::: Godwin is precious.\nFearless(sigmund) ::: Sigmund is fearless.\nPrecious(rolf) ::: Rolf is precious.\n¬Stubborn(rose) ::: Rose is not stubborn.\nJittery(conrad) ::: Conrad is jittery.\n¬Fearless(brandi) ::: Brandi is not fearless.\n¬Sour(brandi) ::: Brandi is not sour.\nJittery(rolf) ::: Rolf is jittery.\nStubborn(owen) ::: Owen is stubborn.\n¬Fearless(godwin) ::: Godwin is not fearless.\n(¬∃x (¬x)) → (¬Jittery(godwin)) ::: If there is nobody who is not, then Godwin is not jittery.\n(∃x (Several(x) ∨ ¬Sour(x))) → (¬Stubborn(brandi)) ::: If there is someone who is either several or not sour, then Brandi is not stubborn.\n(∃x (¬Sour(x))) → ((¬Stubborn(owen) ∧ ¬Several(conrad))) ::: If there is at least one people who is not sour, then Owen is not stubborn and Conrad is not several.\n(∀x (Several(x) ∧ ¬Sour(x))) → (∀x (Stubborn(x))) ::: If someone who is several is also not sour, then he is stubborn.\n(∃x (Sour(x) ∨ Jittery(x))) → ((¬Several(brandi) ∧ Stubborn(conrad))) ::: If there is at least one people who is either sour or jittery, then Brandi is not several and Conrad is stubborn.\n(¬Fearless(rolf)) → (¬Jittery(conrad)) ::: If Rolf is not fearless, then Conrad is not jittery.\n(¬Precious(godwin)) → ((Jittery(godwin) ∧ ¬Fearless(owen))) ::: It can be concluded that Godwin is jittery and Owen is not fearless once knowing that Godwin is not precious.\n((¬Jittery(godwin) ∧ ¬Several(sigmund))) → (Precious(sigmund)) ::: It can be concluded that Sigmund is precious once knowing that Godwin is not jittery and Sigmund is not several.\n((Several(rolf) ∨ Fearless(brandi))) → (¬Precious(brandi)) ::: If Rolf is several or Brandi is fearless, then Brandi is not precious.\n((¬Jittery(godwin) ∧ Several(conrad))) → (Sour(owen)) ::: If Godwin is not jittery and Conrad is several, then Owen is sour.\n(∀x (Precious(x))) → (∀x (¬Several(x))) ::: Someone who is precious is always not several.\n(¬Fearless(godwin)) ↔ (Several(brandi)) ::: If Godwin is not fearless, then Brandi is several, and vice versa.\n",
                "First-Order-Logic Question": "¬Sour(brandi) ::: Brandi is not sour."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "¬Several(rolf) ::: Rolf is not several.\n¬Precious(sigmund) ::: Sigmund is not precious.\nPrecious(godwin) ::: Godwin is precious.\nFearless(sigmund) ::: Sigmund is fearless.\nPrecious(rolf) ::: Rolf is precious.\n¬Stubborn(rose) ::: Rose is not stubborn.\nJittery(conrad) ::: Conrad is jittery.\n¬Fearless(brandi) ::: Brandi is not fearless.\n¬Sour(brandi) ::: Brandi is not sour.\nJittery(rolf) ::: Rolf is jittery.\nStubborn(owen) ::: Owen is stubborn.\n¬Fearless(godwin) ::: Godwin is not fearless.\n¬∃x(¬(¬(Several(x)))) ::: If there is nobody who is not, then Godwin is not jittery.\n(∃x (Several(x) ∨ ¬Sour(x))) → (¬Stubborn(brandi)) ::: If there is someone who is either several or not sour, then Brandi is not stubborn.\n(∃x (¬Sour(x))) → ((¬Stubborn(owen) ∧ ¬Several(conrad))) ::: If there is at least one people who is not sour, then Owen is not stubborn and Conrad is not several.\n(∀x (Several(x) ∧ ¬Sour(x))) → (∀x (Stubborn(x))) ::: If someone who is several is also not sour, then he is stubborn.\n(∃x (Sour(x) ∨ Jittery(x))) → ((¬Several(brandi) ∧ Stubborn(conrad))) ::: If there is at least one people who is either sour or jittery, then Brandi is not several and Conrad is stubborn.\n(¬Fearless(rolf)) → (¬Jittery(conrad)) ::: If Rolf is not fearless, then Conrad is not jittery.\n(¬Precious(godwin)) → ((Jittery(godwin) ∧ ¬Fearless(owen))) ::: It can be concluded that Godwin is jittery and Owen is not fearless once knowing that Godwin is not precious.\n((¬Jittery(godwin) ∧ ¬Several(sigmund))) → (Precious(sigmund)) ::: It can be concluded that Sigmund is precious once knowing that Godwin is not jittery and Sigmund is not several.\n((Several(rolf) ∨ Fearless(brandi))) → (¬Precious(brandi)) ::: If Rolf is several or Brandi is fearless, then Brandi is not precious.\n((¬Jittery(godwin) ∧ Several(conrad))) → (Sour(owen)) ::: If Godwin is not jittery and Conrad is several, then Owen is sour.\n(∀x (Precious(x))) → (∀x (¬Several(x))) ::: Someone who is precious is always not several.\n(¬Fearless(godwin)) ↔ (Several(brandi)) ::: If Godwin is not fearless, then Brandi is several, and vice versa.\n",
                "First-Order-Logic Question": "¬Sour(brandi) ::: Brandi is not sour."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬x)) → (¬Jittery(godwin)) ::: If there is nobody who is not, then Godwin is not jittery.",
                    "gram": "¬∃x(¬(¬(Several(x)))) ::: If there is nobody who is not, then Godwin is not jittery."
                }
            ],
            "answer": "B",
            "grammar_answer": "A",
            "backup_answer": "A"
        },
        {
            "id": 1210,
            "raw_prog": {
                "First-Order-Logic Rules": "¬Several(rolf) ::: Rolf is not several.\n¬Precious(sigmund) ::: Sigmund is not precious.\nPrecious(godwin) ::: Godwin is precious.\nFearless(sigmund) ::: Sigmund is fearless.\nPrecious(rolf) ::: Rolf is precious.\n¬Stubborn(rose) ::: Rose is not stubborn.\nJittery(conrad) ::: Conrad is jittery.\n¬Fearless(brandi) ::: Brandi is not fearless.\n¬Sour(brandi) ::: Brandi is not sour.\nJittery(rolf) ::: Rolf is jittery.\nStubborn(owen) ::: Owen is stubborn.\n¬Fearless(godwin) ::: Godwin is not fearless.\n(¬∃x (¬x)) → (¬Jittery(godwin)) ::: If there is nobody who is not, then Godwin is not jittery.\n(∃x (Several(x) ∨ ¬Sour(x))) → (¬Stubborn(brandi)) ::: If there is someone who is either several or not sour, then Brandi is not stubborn.\n(∃x (¬Sour(x))) → ((¬Stubborn(owen) ∧ ¬Several(conrad))) ::: If there is at least one people who is not sour, then Owen is not stubborn and Conrad is not several.\n(∀x (Several(x) ∧ ¬Sour(x))) → (∀x (Stubborn(x))) ::: If someone who is several is also not sour, then he is stubborn.\n(∃x (Sour(x) ∨ Jittery(x))) → ((¬Several(brandi) ∧ Stubborn(conrad))) ::: If there is at least one people who is either sour or jittery, then Brandi is not several and Conrad is stubborn.\n(¬Fearless(rolf)) → (¬Jittery(conrad)) ::: If Rolf is not fearless, then Conrad is not jittery.\n(¬Precious(godwin)) → ((Jittery(godwin) ∧ ¬Fearless(owen))) ::: It can be concluded that Godwin is jittery and Owen is not fearless once knowing that Godwin is not precious.\n((¬Jittery(godwin) ∧ ¬Several(sigmund))) → (Precious(sigmund)) ::: It can be concluded that Sigmund is precious once knowing that Godwin is not jittery and Sigmund is not several.\n(Several(rolf) ∨ Fearless(brandi)) → (¬Precious(brandi)) ::: If Rolf is several or Brandi is fearless, then Brandi is not precious.\n((¬Jittery(godwin) ∧ Several(conrad))) → (Sour(owen)) ::: If Godwin is not jittery and Conrad is several, then Owen is sour.\n(∀x (Precious(x))) → (∀x (¬Several(x))) ::: Someone who is precious is always not several.\n(¬Fearless(godwin)) ↔ (Several(brandi)) ::: If Godwin is not fearless, then Brandi is several, and vice versa.\n",
                "First-Order-Logic Question": "¬Precious(rolf) ::: Rolf is not precious."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "¬Several(rolf) ::: Rolf is not several.\n¬Precious(sigmund) ::: Sigmund is not precious.\nPrecious(godwin) ::: Godwin is precious.\nFearless(sigmund) ::: Sigmund is fearless.\nPrecious(rolf) ::: Rolf is precious.\n¬Stubborn(rose) ::: Rose is not stubborn.\nJittery(conrad) ::: Conrad is jittery.\n¬Fearless(brandi) ::: Brandi is not fearless.\n¬Sour(brandi) ::: Brandi is not sour.\nJittery(rolf) ::: Rolf is jittery.\nStubborn(owen) ::: Owen is stubborn.\n¬Fearless(godwin) ::: Godwin is not fearless.\n¬∃x(¬(¬(Several(x)))) ::: If there is nobody who is not, then Godwin is not jittery.\n(∃x (Several(x) ∨ ¬Sour(x))) → (¬Stubborn(brandi)) ::: If there is someone who is either several or not sour, then Brandi is not stubborn.\n(∃x (¬Sour(x))) → ((¬Stubborn(owen) ∧ ¬Several(conrad))) ::: If there is at least one people who is not sour, then Owen is not stubborn and Conrad is not several.\n(∀x (Several(x) ∧ ¬Sour(x))) → (∀x (Stubborn(x))) ::: If someone who is several is also not sour, then he is stubborn.\n(∃x (Sour(x) ∨ Jittery(x))) → ((¬Several(brandi) ∧ Stubborn(conrad))) ::: If there is at least one people who is either sour or jittery, then Brandi is not several and Conrad is stubborn.\n(¬Fearless(rolf)) → (¬Jittery(conrad)) ::: If Rolf is not fearless, then Conrad is not jittery.\n(¬Precious(godwin)) → ((Jittery(godwin) ∧ ¬Fearless(owen))) ::: It can be concluded that Godwin is jittery and Owen is not fearless once knowing that Godwin is not precious.\n((¬Jittery(godwin) ∧ ¬Several(sigmund))) → (Precious(sigmund)) ::: It can be concluded that Sigmund is precious once knowing that Godwin is not jittery and Sigmund is not several.\n(Several(rolf) ∨ Fearless(brandi)) → (¬Precious(brandi)) ::: If Rolf is several or Brandi is fearless, then Brandi is not precious.\n((¬Jittery(godwin) ∧ Several(conrad))) → (Sour(owen)) ::: If Godwin is not jittery and Conrad is several, then Owen is sour.\n(∀x (Precious(x))) → (∀x (¬Several(x))) ::: Someone who is precious is always not several.\n(¬Fearless(godwin)) ↔ (Several(brandi)) ::: If Godwin is not fearless, then Brandi is several, and vice versa.\n",
                "First-Order-Logic Question": "¬Precious(rolf) ::: Rolf is not precious."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬x)) → (¬Jittery(godwin)) ::: If there is nobody who is not, then Godwin is not jittery.",
                    "gram": "¬∃x(¬(¬(Several(x)))) ::: If there is nobody who is not, then Godwin is not jittery."
                }
            ],
            "answer": "A",
            "grammar_answer": "A",
            "backup_answer": "B"
        },
        {
            "id": 1211,
            "raw_prog": {
                "First-Order-Logic Rules": "¬Several(rolf) ::: Rolf is not several.\n¬Precious(sigmund) ::: Sigmund is not precious.\nPrecious(godwin) ::: Godwin is precious.\nFearless(sigmund) ::: Sigmund is fearless.\nPrecious(rolf) ::: Rolf is precious.\n¬Stubborn(rose) ::: Rose is not stubborn.\nJittery(conrad) ::: Conrad is jittery.\n¬Fearless(brandi) ::: Brandi is not fearless.\n¬Sour(brandi) ::: Brandi is not sour.\nJittery(rolf) ::: Rolf is jittery.\nStubborn(owen) ::: Owen is stubborn.\n¬Fearless(godwin) ::: Godwin is not fearless.\n(¬∃x (¬x)) → (¬Jittery(godwin)) ::: If there is nobody who is not, then Godwin is not jittery.\n(∃x (Several(x) ∨ ¬Sour(x))) → (¬Stubborn(brandi)) ::: If there is someone who is either several or not sour, then Brandi is not stubborn.\n(∃x (¬Sour(x))) → ((¬Stubborn(owen) ∧ ¬Several(conrad))) ::: If there is at least one people who is not sour, then Owen is not stubborn and Conrad is not several.\n(∀x (Several(x) ∧ ¬Sour(x))) → (∀x (Stubborn(x))) ::: If someone who is several is also not sour, then he is stubborn.\n(∃x (Sour(x) ∨ Jittery(x))) → ((¬Several(brandi) ∧ Stubborn(conrad))) ::: If there is at least one people who is either sour or jittery, then Brandi is not several and Conrad is stubborn.\n(¬Fearless(rolf)) → (¬Jittery(conrad)) ::: If Rolf is not fearless, then Conrad is not jittery.\n(¬Precious(godwin)) → ((Jittery(godwin) ∧ ¬Fearless(owen))) ::: It can be concluded that Godwin is jittery and Owen is not fearless once knowing that Godwin is not precious.\n((¬Jittery(godwin) ∧ ¬Several(sigmund))) → (Precious(sigmund)) ::: It can be concluded that Sigmund is precious once knowing that Godwin is not jittery and Sigmund is not several.\n((Several(rolf) ∨ Fearless(brandi))) → (¬Precious(brandi)) ::: If Rolf is several or Brandi is fearless, then Brandi is not precious.\n((¬Jittery(godwin) ∧ Several(conrad))) → (Sour(owen)) ::: If Godwin is not jittery and Conrad is several, then Owen is sour.\n(∀x (Precious(x))) → (∀x (¬Several(x))) ::: Someone who is precious is always not several.\n(¬Fearless(godwin)) ↔ (Several(brandi)) ::: If Godwin is not fearless, then Brandi is several, and vice versa.\n",
                "First-Order-Logic Question": "¬Fearless(godwin) ::: Godwin is not fearless."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "¬Several(rolf) ::: Rolf is not several.\n¬Precious(sigmund) ::: Sigmund is not precious.\nPrecious(godwin) ::: Godwin is precious.\nFearless(sigmund) ::: Sigmund is fearless.\nPrecious(rolf) ::: Rolf is precious.\n¬Stubborn(rose) ::: Rose is not stubborn.\nJittery(conrad) ::: Conrad is jittery.\n¬Fearless(brandi) ::: Brandi is not fearless.\n¬Sour(brandi) ::: Brandi is not sour.\nJittery(rolf) ::: Rolf is jittery.\nStubborn(owen) ::: Owen is stubborn.\n¬Fearless(godwin) ::: Godwin is not fearless.\n¬∃x(¬(¬(Several(x)))) ::: If there is nobody who is not, then Godwin is not jittery.\n(∃x (Several(x) ∨ ¬Sour(x))) → (¬Stubborn(brandi)) ::: If there is someone who is either several or not sour, then Brandi is not stubborn.\n(∃x (¬Sour(x))) → ((¬Stubborn(owen) ∧ ¬Several(conrad))) ::: If there is at least one people who is not sour, then Owen is not stubborn and Conrad is not several.\n(∀x (Several(x) ∧ ¬Sour(x))) → (∀x (Stubborn(x))) ::: If someone who is several is also not sour, then he is stubborn.\n(∃x (Sour(x) ∨ Jittery(x))) → ((¬Several(brandi) ∧ Stubborn(conrad))) ::: If there is at least one people who is either sour or jittery, then Brandi is not several and Conrad is stubborn.\n(¬Fearless(rolf)) → (¬Jittery(conrad)) ::: If Rolf is not fearless, then Conrad is not jittery.\n(¬Precious(godwin)) → ((Jittery(godwin) ∧ ¬Fearless(owen))) ::: It can be concluded that Godwin is jittery and Owen is not fearless once knowing that Godwin is not precious.\n((¬Jittery(godwin) ∧ ¬Several(sigmund))) → (Precious(sigmund)) ::: It can be concluded that Sigmund is precious once knowing that Godwin is not jittery and Sigmund is not several.\n((Several(rolf) ∨ Fearless(brandi))) → (¬Precious(brandi)) ::: If Rolf is several or Brandi is fearless, then Brandi is not precious.\n((¬Jittery(godwin) ∧ Several(conrad))) → (Sour(owen)) ::: If Godwin is not jittery and Conrad is several, then Owen is sour.\n(∀x (Precious(x))) → (∀x (¬Several(x))) ::: Someone who is precious is always not several.\n(¬Fearless(godwin)) ↔ (Several(brandi)) ::: If Godwin is not fearless, then Brandi is several, and vice versa.\n",
                "First-Order-Logic Question": "¬Fearless(godwin) ::: Godwin is not fearless."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬x)) → (¬Jittery(godwin)) ::: If there is nobody who is not, then Godwin is not jittery.",
                    "gram": "¬∃x(¬(¬(Several(x)))) ::: If there is nobody who is not, then Godwin is not jittery."
                }
            ],
            "answer": "C",
            "grammar_answer": "A",
            "backup_answer": "A"
        },
        {
            "id": 1212,
            "raw_prog": {
                "First-Order-Logic Rules": "¬Several(rolf) ::: Rolf is not several.\n¬Precious(sigmund) ::: Sigmund is not precious.\nPrecious(godwin) ::: Godwin is precious.\nFearless(sigmund) ::: Sigmund is fearless.\nPrecious(rolf) ::: Rolf is precious.\n¬Stubborn(rose) ::: Rose is not stubborn.\nJittery(conrad) ::: Conrad is jittery.\n¬Fearless(brandi) ::: Brandi is not fearless.\n¬Sour(brandi) ::: Brandi is not sour.\nJittery(rolf) ::: Rolf is jittery.\nStubborn(owen) ::: Owen is stubborn.\n¬Fearless(godwin) ::: Godwin is not fearless.\n(¬∃x (¬x)) → (¬Jittery(godwin)) ::: If there is nobody who is not, then Godwin is not jittery.\n(∃x (Several(x) ∨ ¬Sour(x))) → (¬Stubborn(brandi)) ::: If there is someone who is either several or not sour, then Brandi is not stubborn.\n(∃x (¬Sour(x))) → ((¬Stubborn(owen) ∧ ¬Several(conrad))) ::: If there is at least one people who is not sour, then Owen is not stubborn and Conrad is not several.\n(∀x (Several(x) ∧ ¬Sour(x))) → (∀x (Stubborn(x))) ::: If someone who is several is also not sour, then he is stubborn.\n(∃x (Sour(x) ∨ Jittery(x))) → ((¬Several(brandi) ∧ Stubborn(conrad))) ::: If there is at least one people who is either sour or jittery, then Brandi is not several and Conrad is stubborn.\n(¬Fearless(rolf)) → (¬Jittery(conrad)) ::: If Rolf is not fearless, then Conrad is not jittery.\n((¬Precious(godwin))) → ((Jittery(godwin) ∧ ¬Fearless(owen))) ::: It can be concluded that Godwin is jittery and Owen is not fearless once knowing that Godwin is not precious.\n((¬Jittery(godwin) ∧ ¬Several(sigmund))) → (Precious(sigmund)) ::: It can be concluded that Sigmund is precious once knowing that Godwin is not jittery and Sigmund is not several.\n((Several(rolf) ∨ Fearless(brandi))) → (¬Precious(brandi)) ::: If Rolf is several or Brandi is fearless, then Brandi is not precious.\n((¬Jittery(godwin) ∧ Several(conrad))) → (Sour(owen)) ::: If Godwin is not jittery and Conrad is several, then Owen is sour.\n(∀x (Precious(x))) → (∀x (¬Several(x))) ::: Someone who is precious is always not several.\n(¬Fearless(godwin)) ↔ (Several(brandi)) ::: If Godwin is not fearless, then Brandi is several, and vice versa.\n",
                "First-Order-Logic Question": "Jittery(brandi) ::: Brandi is jittery."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "¬Several(rolf) ::: Rolf is not several.\n¬Precious(sigmund) ::: Sigmund is not precious.\nPrecious(godwin) ::: Godwin is precious.\nFearless(sigmund) ::: Sigmund is fearless.\nPrecious(rolf) ::: Rolf is precious.\n¬Stubborn(rose) ::: Rose is not stubborn.\nJittery(conrad) ::: Conrad is jittery.\n¬Fearless(brandi) ::: Brandi is not fearless.\n¬Sour(brandi) ::: Brandi is not sour.\nJittery(rolf) ::: Rolf is jittery.\nStubborn(owen) ::: Owen is stubborn.\n¬Fearless(godwin) ::: Godwin is not fearless.\n¬∃x(¬(¬(Several(x)))) ::: If there is nobody who is not, then Godwin is not jittery.\n(∃x (Several(x) ∨ ¬Sour(x))) → (¬Stubborn(brandi)) ::: If there is someone who is either several or not sour, then Brandi is not stubborn.\n(∃x (¬Sour(x))) → ((¬Stubborn(owen) ∧ ¬Several(conrad))) ::: If there is at least one people who is not sour, then Owen is not stubborn and Conrad is not several.\n(∀x (Several(x) ∧ ¬Sour(x))) → (∀x (Stubborn(x))) ::: If someone who is several is also not sour, then he is stubborn.\n(∃x (Sour(x) ∨ Jittery(x))) → ((¬Several(brandi) ∧ Stubborn(conrad))) ::: If there is at least one people who is either sour or jittery, then Brandi is not several and Conrad is stubborn.\n(¬Fearless(rolf)) → (¬Jittery(conrad)) ::: If Rolf is not fearless, then Conrad is not jittery.\n((¬Precious(godwin))) → ((Jittery(godwin) ∧ ¬Fearless(owen))) ::: It can be concluded that Godwin is jittery and Owen is not fearless once knowing that Godwin is not precious.\n((¬Jittery(godwin) ∧ ¬Several(sigmund))) → (Precious(sigmund)) ::: It can be concluded that Sigmund is precious once knowing that Godwin is not jittery and Sigmund is not several.\n((Several(rolf) ∨ Fearless(brandi))) → (¬Precious(brandi)) ::: If Rolf is several or Brandi is fearless, then Brandi is not precious.\n((¬Jittery(godwin) ∧ Several(conrad))) → (Sour(owen)) ::: If Godwin is not jittery and Conrad is several, then Owen is sour.\n(∀x (Precious(x))) → (∀x (¬Several(x))) ::: Someone who is precious is always not several.\n(¬Fearless(godwin)) ↔ (Several(brandi)) ::: If Godwin is not fearless, then Brandi is several, and vice versa.\n",
                "First-Order-Logic Question": "Jittery(brandi) ::: Brandi is jittery."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬x)) → (¬Jittery(godwin)) ::: If there is nobody who is not, then Godwin is not jittery.",
                    "gram": "¬∃x(¬(¬(Several(x)))) ::: If there is nobody who is not, then Godwin is not jittery."
                }
            ],
            "answer": "B",
            "grammar_answer": "A",
            "backup_answer": "C"
        },
        {
            "id": 1213,
            "raw_prog": {
                "First-Order-Logic Rules": "¬Several(rolf) ::: Rolf is not several.\n¬Precious(sigmund) ::: Sigmund is not precious.\nPrecious(godwin) ::: Godwin is precious.\nFearless(sigmund) ::: Sigmund is fearless.\nPrecious(rolf) ::: Rolf is precious.\n¬Stubborn(rose) ::: Rose is not stubborn.\nJittery(conrad) ::: Conrad is jittery.\n¬Fearless(brandi) ::: Brandi is not fearless.\n¬Sour(brandi) ::: Brandi is not sour.\nJittery(rolf) ::: Rolf is jittery.\nStubborn(owen) ::: Owen is stubborn.\n¬Fearless(godwin) ::: Godwin is not fearless.\n(¬∃x (¬x)) → (¬Jittery(godwin)) ::: If there is nobody who is not, then Godwin is not jittery.\n(∃x (Several(x) ∨ ¬Sour(x))) → (¬Stubborn(brandi)) ::: If there is someone who is either several or not sour, then Brandi is not stubborn.\n(∃x (¬Sour(x))) → ((¬Stubborn(owen) ∧ ¬Several(conrad))) ::: If there is at least one people who is not sour, then Owen is not stubborn and Conrad is not several.\n(∀x (Several(x) ∧ ¬Sour(x))) → (∀x (Stubborn(x))) ::: If someone who is several is also not sour, then he is stubborn.\n(∃x (Sour(x) ∨ Jittery(x))) → ((¬Several(brandi) ∧ Stubborn(conrad))) ::: If there is at least one people who is either sour or jittery, then Brandi is not several and Conrad is stubborn.\n(¬Fearless(rolf)) → (¬Jittery(conrad)) ::: If Rolf is not fearless, then Conrad is not jittery.\n((¬Precious(godwin))) → ((Jittery(godwin) ∧ ¬Fearless(owen))) ::: It can be concluded that Godwin is jittery and Owen is not fearless once knowing that Godwin is not precious.\n((¬Jittery(godwin) ∧ ¬Several(sigmund))) → ((Precious(sigmund))) ::: It can be concluded that Sigmund is precious once knowing that Godwin is not jittery and Sigmund is not several.\n((Several(rolf) ∨ Fearless(brandi))) → ((¬Precious(brandi))) ::: If Rolf is several or Brandi is fearless, then Brandi is not precious.\n((¬Jittery(godwin) ∧ Several(conrad))) → ((Sour(owen))) ::: If Godwin is not jittery and Conrad is several, then Owen is sour.\n(∀x (Precious(x))) → (∀x (¬Several(x))) ::: Someone who is precious is always not several.\n((¬Fearless(godwin))) ↔ ((Several(brandi))) ::: If Godwin is not fearless, then Brandi is several, and vice versa.\n",
                "First-Order-Logic Question": "¬Precious(godwin) ::: Godwin is not precious."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "¬Several(rolf) ::: Rolf is not several.\n¬Precious(sigmund) ::: Sigmund is not precious.\nPrecious(godwin) ::: Godwin is precious.\nFearless(sigmund) ::: Sigmund is fearless.\nPrecious(rolf) ::: Rolf is precious.\n¬Stubborn(rose) ::: Rose is not stubborn.\nJittery(conrad) ::: Conrad is jittery.\n¬Fearless(brandi) ::: Brandi is not fearless.\n¬Sour(brandi) ::: Brandi is not sour.\nJittery(rolf) ::: Rolf is jittery.\nStubborn(owen) ::: Owen is stubborn.\n¬Fearless(godwin) ::: Godwin is not fearless.\n¬∃x(¬(¬(Several(x)))) ::: If there is nobody who is not, then Godwin is not jittery.\n(∃x (Several(x) ∨ ¬Sour(x))) → (¬Stubborn(brandi)) ::: If there is someone who is either several or not sour, then Brandi is not stubborn.\n(∃x (¬Sour(x))) → ((¬Stubborn(owen) ∧ ¬Several(conrad))) ::: If there is at least one people who is not sour, then Owen is not stubborn and Conrad is not several.\n(∀x (Several(x) ∧ ¬Sour(x))) → (∀x (Stubborn(x))) ::: If someone who is several is also not sour, then he is stubborn.\n(∃x (Sour(x) ∨ Jittery(x))) → ((¬Several(brandi) ∧ Stubborn(conrad))) ::: If there is at least one people who is either sour or jittery, then Brandi is not several and Conrad is stubborn.\n(¬Fearless(rolf)) → (¬Jittery(conrad)) ::: If Rolf is not fearless, then Conrad is not jittery.\n((¬Precious(godwin))) → ((Jittery(godwin) ∧ ¬Fearless(owen))) ::: It can be concluded that Godwin is jittery and Owen is not fearless once knowing that Godwin is not precious.\n((¬Jittery(godwin) ∧ ¬Several(sigmund))) → ((Precious(sigmund))) ::: It can be concluded that Sigmund is precious once knowing that Godwin is not jittery and Sigmund is not several.\n((Several(rolf) ∨ Fearless(brandi))) → ((¬Precious(brandi))) ::: If Rolf is several or Brandi is fearless, then Brandi is not precious.\n((¬Jittery(godwin) ∧ Several(conrad))) → ((Sour(owen))) ::: If Godwin is not jittery and Conrad is several, then Owen is sour.\n(∀x (Precious(x))) → (∀x (¬Several(x))) ::: Someone who is precious is always not several.\n((¬Fearless(godwin))) ↔ ((Several(brandi))) ::: If Godwin is not fearless, then Brandi is several, and vice versa.\n",
                "First-Order-Logic Question": "¬Precious(godwin) ::: Godwin is not precious."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬x)) → (¬Jittery(godwin)) ::: If there is nobody who is not, then Godwin is not jittery.",
                    "gram": "¬∃x(¬(¬(Several(x)))) ::: If there is nobody who is not, then Godwin is not jittery."
                }
            ],
            "answer": "A",
            "grammar_answer": "A",
            "backup_answer": "B"
        },
        {
            "id": 1214,
            "raw_prog": {
                "First-Order-Logic Rules": "¬Several(rolf) ::: Rolf is not several.\n¬Precious(sigmund) ::: Sigmund is not precious.\nPrecious(godwin) ::: Godwin is precious.\nFearless(sigmund) ::: Sigmund is fearless.\nPrecious(rolf) ::: Rolf is precious.\n¬Stubborn(rose) ::: Rose is not stubborn.\nJittery(conrad) ::: Conrad is jittery.\n¬Fearless(brandi) ::: Brandi is not fearless.\n¬Sour(brandi) ::: Brandi is not sour.\nJittery(rolf) ::: Rolf is jittery.\nStubborn(owen) ::: Owen is stubborn.\n¬Fearless(godwin) ::: Godwin is not fearless.\n(¬∃x (¬x)) → (¬Jittery(godwin)) ::: If there is nobody who is not, then Godwin is not jittery.\n(∃x (Several(x) ∨ ¬Sour(x))) → (¬Stubborn(brandi)) ::: If there is someone who is either several or not sour, then Brandi is not stubborn.\n(∃x (¬Sour(x))) → ((¬Stubborn(owen) ∧ ¬Several(conrad))) ::: If there is at least one people who is not sour, then Owen is not stubborn and Conrad is not several.\n(∀x (Several(x) ∧ ¬Sour(x))) → (∀x (Stubborn(x))) ::: If someone who is several is also not sour, then he is stubborn.\n(∃x (Sour(x) ∨ Jittery(x))) → ((¬Several(brandi) ∧ Stubborn(conrad))) ::: If there is at least one people who is either sour or jittery, then Brandi is not several and Conrad is stubborn.\n(¬Fearless(rolf)) → (¬Jittery(conrad)) ::: If Rolf is not fearless, then Conrad is not jittery.\n(¬Precious(godwin)) → ((Jittery(godwin) ∧ ¬Fearless(owen))) ::: It can be concluded that Godwin is jittery and Owen is not fearless once knowing that Godwin is not precious.\n((¬Jittery(godwin) ∧ ¬Several(sigmund))) → (Precious(sigmund)) ::: It can be concluded that Sigmund is precious once knowing that Godwin is not jittery and Sigmund is not several.\n(Several(rolf) ∨ Fearless(brandi)) → (¬Precious(brandi)) ::: If Rolf is several or Brandi is fearless, then Brandi is not precious.\n((¬Jittery(godwin) ∧ Several(conrad))) → (Sour(owen)) ::: If Godwin is not jittery and Conrad is several, then Owen is sour.\n(∀x (Precious(x))) → (∀x (¬Several(x))) ::: Someone who is precious is always not several.\n(¬Fearless(godwin)) ↔ (Several(brandi)) ::: If Godwin is not fearless, then Brandi is several, and vice versa.\n",
                "First-Order-Logic Question": "¬Several(rolf) ::: Rolf is not several."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "¬Several(rolf) ::: Rolf is not several.\n¬Precious(sigmund) ::: Sigmund is not precious.\nPrecious(godwin) ::: Godwin is precious.\nFearless(sigmund) ::: Sigmund is fearless.\nPrecious(rolf) ::: Rolf is precious.\n¬Stubborn(rose) ::: Rose is not stubborn.\nJittery(conrad) ::: Conrad is jittery.\n¬Fearless(brandi) ::: Brandi is not fearless.\n¬Sour(brandi) ::: Brandi is not sour.\nJittery(rolf) ::: Rolf is jittery.\nStubborn(owen) ::: Owen is stubborn.\n¬Fearless(godwin) ::: Godwin is not fearless.\n¬∃x(¬(¬(Several(x)))) ::: If there is nobody who is not, then Godwin is not jittery.\n(∃x (Several(x) ∨ ¬Sour(x))) → (¬Stubborn(brandi)) ::: If there is someone who is either several or not sour, then Brandi is not stubborn.\n(∃x (¬Sour(x))) → ((¬Stubborn(owen) ∧ ¬Several(conrad))) ::: If there is at least one people who is not sour, then Owen is not stubborn and Conrad is not several.\n(∀x (Several(x) ∧ ¬Sour(x))) → (∀x (Stubborn(x))) ::: If someone who is several is also not sour, then he is stubborn.\n(∃x (Sour(x) ∨ Jittery(x))) → ((¬Several(brandi) ∧ Stubborn(conrad))) ::: If there is at least one people who is either sour or jittery, then Brandi is not several and Conrad is stubborn.\n(¬Fearless(rolf)) → (¬Jittery(conrad)) ::: If Rolf is not fearless, then Conrad is not jittery.\n(¬Precious(godwin)) → ((Jittery(godwin) ∧ ¬Fearless(owen))) ::: It can be concluded that Godwin is jittery and Owen is not fearless once knowing that Godwin is not precious.\n((¬Jittery(godwin) ∧ ¬Several(sigmund))) → (Precious(sigmund)) ::: It can be concluded that Sigmund is precious once knowing that Godwin is not jittery and Sigmund is not several.\n(Several(rolf) ∨ Fearless(brandi)) → (¬Precious(brandi)) ::: If Rolf is several or Brandi is fearless, then Brandi is not precious.\n((¬Jittery(godwin) ∧ Several(conrad))) → (Sour(owen)) ::: If Godwin is not jittery and Conrad is several, then Owen is sour.\n(∀x (Precious(x))) → (∀x (¬Several(x))) ::: Someone who is precious is always not several.\n(¬Fearless(godwin)) ↔ (Several(brandi)) ::: If Godwin is not fearless, then Brandi is several, and vice versa.\n",
                "First-Order-Logic Question": "¬Several(rolf) ::: Rolf is not several."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬x)) → (¬Jittery(godwin)) ::: If there is nobody who is not, then Godwin is not jittery.",
                    "gram": "¬∃x(¬(¬(Several(x)))) ::: If there is nobody who is not, then Godwin is not jittery."
                }
            ],
            "answer": "A",
            "grammar_answer": "A",
            "backup_answer": "A"
        },
        {
            "id": 1245,
            "raw_prog": {
                "First-Order-Logic Rules": [
                    "¬Fat(barry) ::: Barry is not fat.",
                    "¬Scared(barry) ::: Barry is not scared.",
                    "Fat(roderick) ::: Roderick is fat.",
                    "¬Attractive(rolf) ::: Rolf is not attractive.",
                    "¬Drab(udolf) ::: Udolf is not drab.",
                    "¬Scared(rolf) ::: Rolf is not scared.",
                    "¬Hungry(udolf) ::: Udolf is not hungry.",
                    "¬Wicked(udolf) ::: Udolf is not wicked.",
                    "¬Scared(udolf) ::: Udolf is not scared.",
                    "¬Scared(owen) ::: Owen is not scared.",
                    "¬Hungry(joey) ::: Joey is not hungry.",
                    "Wicked(joey) ::: Joey is wicked.",
                    "(∃x (Hungry(x) ∨ ¬Scared(x))) → (¬Wicked(roderick) ∧ ¬Drab(rolf)) ::: If there is at least one people who is either hungry or not scared, then Roderick is not wicked and Rolf is not drab.",
                    "¬Scared(barry) ↔ ¬Attractive(rolf) ::: Barry being not scared is equivalent to Rolf being not attractive.",
                    "(∃x (¬Drab(x))) → (¬Fat(roderick)) ::: If there is at least one people who is not drab, then Roderick is not fat.",
                    "¬Wicked(barry) ↔ (Fat(christina) ∧ Drab(roderick)) ::: Barry being not wicked is equivalent to Christina being fat and Roderick being drab.",
                    "(∀x (¬Attractive(x) ∧ Fat(x))) → (∀x (Hungry(x))) ::: If someone who is not attractive is also fat, then he is hungry.",
                    "(∀x (¬Hungry(x) ∧ ¬Scared(x))) ↔ (∀x (Attractive(x) ∧ ¬Fat(x))) ::: If someone is not hungry and not scared, then he is both attractive and not fat, and vice versa.",
                    "(∀x (¬Attractive(x))) → (∀x (Hungry(x) ∧ ¬Drab(x))) ::: As long as someone is not attractive, he is hungry and not drab.",
                    "(∀x (Drab(x) ∧ Attractive(x))) ↔ (∀x (Wicked(x) ∧ Hungry(x))) ::: If someone is drab and attractive, then he is both wicked and hungry, and vice versa.",
                    "(¬∃x (¬Hungry(x))) → (Attractive(udolf) ∧ ¬Wicked(joey)) ::: If there is nobody who is not hungry, then Udolf is attractive and Joey is not wicked.",
                    "(∀x (¬Hungry(x))) → (∀x (¬Attractive(x))) ::: If someone is not hungry, then he is not attractive, and vice versa.",
                    "(∃x (Scared(x) ∧ ¬Fat(x))) → (¬Wicked(christina)) ::: If there is at least one people who is both scared and not fat, then Christina is not wicked.",
                    "(∃x (Fat(x) ∨ ¬Scared(x))) → (¬Wicked(roderick)) ::: If there is someone who is either fat or not scared, then Roderick is not wicked."
                ],
                "First-Order-Logic Question": "¬Wicked(joey) ::: Joey is not wicked."
            },
            "gram_prog": {
                "First-Order-Logic Rules": [
                    "¬Fat(barry) ::: Barry is not fat.",
                    "¬Scared(barry) ::: Barry is not scared.",
                    "Fat(roderick) ::: Roderick is fat.",
                    "¬Attractive(rolf) ::: Rolf is not attractive.",
                    "¬Drab(udolf) ::: Udolf is not drab.",
                    "¬Scared(rolf) ::: Rolf is not scared.",
                    "¬Hungry(udolf) ::: Udolf is not hungry.",
                    "¬Wicked(udolf) ::: Udolf is not wicked.",
                    "¬Scared(udolf) ::: Udolf is not scared.",
                    "¬Scared(owen) ::: Owen is not scared.",
                    "¬Hungry(joey) ::: Joey is not hungry.",
                    "Wicked(joey) ::: Joey is wicked.",
                    "(∃x (Hungry(x) ∨ ¬Scared(x))) → (¬Wicked(roderick) ∧ ¬Drab(rolf)) ::: If there is at least one people who is either hungry or not scared, then Roderick is not wicked and Rolf is not drab.",
                    "¬Scared(barry) ↔ ¬Attractive(rolf) ::: Barry being not scared is equivalent to Rolf being not attractive.",
                    "(∃x (¬Drab(x))) → (¬Fat(roderick)) ::: If there is at least one people who is not drab, then Roderick is not fat.",
                    "¬Wicked(barry) ↔ (Fat(christina) ∧ Drab(roderick)) ::: Barry being not wicked is equivalent to Christina being fat and Roderick being drab.",
                    "(∀x (¬Attractive(x) ∧ Fat(x))) → (∀x (Hungry(x))) ::: If someone who is not attractive is also fat, then he is hungry.",
                    "(∀x (¬Hungry(x) ∧ ¬Scared(x))) ↔ (∀x (Attractive(x) ∧ ¬Fat(x))) ::: If someone is not hungry and not scared, then he is both attractive and not fat, and vice versa.",
                    "(∀x (¬Attractive(x))) → (∀x (Hungry(x) ∧ ¬Drab(x))) ::: As long as someone is not attractive, he is hungry and not drab.",
                    "(∀x (Drab(x) ∧ Attractive(x))) ↔ (∀x (Wicked(x) ∧ Hungry(x))) ::: If someone is drab and attractive, then he is both wicked and hungry, and vice versa.",
                    "¬∃x(¬Hungry(x))→(Attractive(x)∧¬Wicked(x)) ::: If there is nobody who is not hungry, then Udolf is attractive and Joey is not wicked.",
                    "(∀x (¬Hungry(x))) → (∀x (¬Attractive(x))) ::: If someone is not hungry, then he is not attractive, and vice versa.",
                    "(∃x (Scared(x) ∧ ¬Fat(x))) → (¬Wicked(christina)) ::: If there is at least one people who is both scared and not fat, then Christina is not wicked.",
                    "(∃x (Fat(x) ∨ ¬Scared(x))) → (¬Wicked(roderick)) ::: If there is someone who is either fat or not scared, then Roderick is not wicked."
                ],
                "First-Order-Logic Question": "¬Wicked(joey) ::: Joey is not wicked."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬Hungry(x))) → (Attractive(udolf) ∧ ¬Wicked(joey)) ::: If there is nobody who is not hungry, then Udolf is attractive and Joey is not wicked.",
                    "gram": "¬∃x(¬Hungry(x))→(Attractive(x)∧¬Wicked(x)) ::: If there is nobody who is not hungry, then Udolf is attractive and Joey is not wicked."
                }
            ],
            "answer": "B",
            "grammar_answer": "A",
            "backup_answer": "B"
        },
        {
            "id": 1246,
            "raw_prog": {
                "First-Order-Logic Rules": "¬Fat(barry) ::: Barry is not fat.\n¬Scared(barry) ::: Barry is not scared.\nFat(roderick) ::: Roderick is fat.\n¬Attractive(rolf) ::: Rolf is not attractive.\n¬Drab(udolf) ::: Udolf is not drab.\n¬Scared(rolf) ::: Rolf is not scared.\n¬Hungry(udolf) ::: Udolf is not hungry.\n¬Wicked(udolf) ::: Udolf is not wicked.\n¬Scared(udolf) ::: Udolf is not scared.\n¬Scared(owen) ::: Owen is not scared.\n¬Hungry(joey) ::: Joey is not hungry.\nWicked(joey) ::: Joey is wicked.\n(∃x (Hungry(x) ∨ ¬Scared(x))) → ((¬Wicked(roderick) ∧ ¬Drab(rolf))) ::: If there is at least one people who is either hungry or not scared, then Roderick is not wicked and Rolf is not drab.\n((¬Scared(barry))) ↔ ((¬Attractive(rolf))) ::: Barry being not scared is equivalent to Rolf being not attractive.\n(∃x (¬Drab(x))) → ((¬Fat(roderick))) ::: If there is at least one people who is not drab, then Roderick is not fat.\n((¬Wicked(barry))) ↔ ((Fat(christina) ∧ Drab(roderick))) ::: Barry being not wicked is equivalent to Christina being fat and Roderick being drab.\n(∀x (¬Attractive(x) ∧ Fat(x))) → (∀x (Hungry(x))) ::: If someone who is not attractive is also fat, then he is hungry.\n(∀x (¬Hungry(x) ∧ ¬Scared(x))) ↔ (∀x (Attractive(x) ∧ ¬Fat(x))) ::: If someone is not hungry and not scared, then he is both attractive and not fat, and vice versa.\n(∀x (¬Attractive(x))) → (∀x (Hungry(x) ∧ ¬Drab(x))) ::: As long as someone is not attractive, he is hungry and not drab.\n(∀x (Drab(x) ∧ Attractive(x))) ↔ (∀x (Wicked(x) ∧ Hungry(x))) ::: If someone is drab and attractive, then he is both wicked and hungry, and vice versa.\n(¬∃x (¬Hungry(x))) → ((Attractive(udolf) ∧ ¬Wicked(joey))) ::: If there is nobody who is not hungry, then Udolf is attractive and Joey is not wicked.\n(∀x (¬Hungry(x))) → (∀x (¬Attractive(x))) ::: If someone is not hungry, then he is not attractive, and vice versa.\n(∃x (Scared(x) ∧ ¬Fat(x))) → ((¬Wicked(christina))) ::: If there is at least one people who is both scared and not fat, then Christina is not wicked.\n(∃x (Fat(x) ∨ ¬Scared(x))) → ((¬Wicked(roderick))) ::: If there is someone who is either fat or not scared, then Roderick is not wicked.\n",
                "First-Order-Logic Question": "Wicked(roderick) ::: Roderick is wicked."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "¬Fat(barry) ::: Barry is not fat.\n¬Scared(barry) ::: Barry is not scared.\nFat(roderick) ::: Roderick is fat.\n¬Attractive(rolf) ::: Rolf is not attractive.\n¬Drab(udolf) ::: Udolf is not drab.\n¬Scared(rolf) ::: Rolf is not scared.\n¬Hungry(udolf) ::: Udolf is not hungry.\n¬Wicked(udolf) ::: Udolf is not wicked.\n¬Scared(udolf) ::: Udolf is not scared.\n¬Scared(owen) ::: Owen is not scared.\n¬Hungry(joey) ::: Joey is not hungry.\nWicked(joey) ::: Joey is wicked.\n(∃x (Hungry(x) ∨ ¬Scared(x))) → ((¬Wicked(roderick) ∧ ¬Drab(rolf))) ::: If there is at least one people who is either hungry or not scared, then Roderick is not wicked and Rolf is not drab.\n((¬Scared(barry))) ↔ ((¬Attractive(rolf))) ::: Barry being not scared is equivalent to Rolf being not attractive.\n(∃x (¬Drab(x))) → ((¬Fat(roderick))) ::: If there is at least one people who is not drab, then Roderick is not fat.\n((¬Wicked(barry))) ↔ ((Fat(christina) ∧ Drab(roderick))) ::: Barry being not wicked is equivalent to Christina being fat and Roderick being drab.\n(∀x (¬Attractive(x) ∧ Fat(x))) → (∀x (Hungry(x))) ::: If someone who is not attractive is also fat, then he is hungry.\n(∀x (¬Hungry(x) ∧ ¬Scared(x))) ↔ (∀x (Attractive(x) ∧ ¬Fat(x))) ::: If someone is not hungry and not scared, then he is both attractive and not fat, and vice versa.\n(∀x (¬Attractive(x))) → (∀x (Hungry(x) ∧ ¬Drab(x))) ::: As long as someone is not attractive, he is hungry and not drab.\n(∀x (Drab(x) ∧ Attractive(x))) ↔ (∀x (Wicked(x) ∧ Hungry(x))) ::: If someone is drab and attractive, then he is both wicked and hungry, and vice versa.\n¬∃x(¬Hungry(x))→((Attractive(x))) ::: If there is nobody who is not hungry, then Udolf is attractive and Joey is not wicked.\n(∀x (¬Hungry(x))) → (∀x (¬Attractive(x))) ::: If someone is not hungry, then he is not attractive, and vice versa.\n(∃x (Scared(x) ∧ ¬Fat(x))) → ((¬Wicked(christina))) ::: If there is at least one people who is both scared and not fat, then Christina is not wicked.\n(∃x (Fat(x) ∨ ¬Scared(x))) → ((¬Wicked(roderick))) ::: If there is someone who is either fat or not scared, then Roderick is not wicked.\n",
                "First-Order-Logic Question": "Wicked(roderick) ::: Roderick is wicked."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬Hungry(x))) → ((Attractive(udolf) ∧ ¬Wicked(joey))) ::: If there is nobody who is not hungry, then Udolf is attractive and Joey is not wicked.",
                    "gram": "¬∃x(¬Hungry(x))→((Attractive(x))) ::: If there is nobody who is not hungry, then Udolf is attractive and Joey is not wicked."
                }
            ],
            "answer": "A",
            "grammar_answer": "A",
            "backup_answer": "B"
        },
        {
            "id": 1247,
            "raw_prog": {
                "First-Order-Logic Rules": "¬Fat(barry) ::: Barry is not fat.\n¬Scared(barry) ::: Barry is not scared.\nFat(roderick) ::: Roderick is fat.\n¬Attractive(rolf) ::: Rolf is not attractive.\n¬Drab(udolf) ::: Udolf is not drab.\n¬Scared(rolf) ::: Rolf is not scared.\n¬Hungry(udolf) ::: Udolf is not hungry.\n¬Wicked(udolf) ::: Udolf is not wicked.\n¬Scared(udolf) ::: Udolf is not scared.\n¬Scared(owen) ::: Owen is not scared.\n¬Hungry(joey) ::: Joey is not hungry.\nWicked(joey) ::: Joey is wicked.\n(∃x (Hungry(x) ∨ ¬Scared(x))) → ((¬Wicked(roderick) ∧ ¬Drab(rolf))) ::: If there is at least one people who is either hungry or not scared, then Roderick is not wicked and Rolf is not drab.\n((¬Scared(barry))) ↔ ((¬Attractive(rolf))) ::: Barry being not scared is equivalent to Rolf being not attractive.\n(∃x (¬Drab(x))) → ((¬Fat(roderick))) ::: If there is at least one people who is not drab, then Roderick is not fat.\n((¬Wicked(barry))) ↔ ((Fat(christina) ∧ Drab(roderick))) ::: Barry being not wicked is equivalent to Christina being fat and Roderick being drab.\n(∀x (¬Attractive(x) ∧ Fat(x))) → (∀x (Hungry(x))) ::: If someone who is not attractive is also fat, then he is hungry.\n(∀x (¬Hungry(x) ∧ ¬Scared(x))) ↔ (∀x (Attractive(x) ∧ ¬Fat(x))) ::: If someone is not hungry and not scared, then he is both attractive and not fat, and vice versa.\n(∀x (¬Attractive(x))) → (∀x (Hungry(x) ∧ ¬Drab(x))) ::: As long as someone is not attractive, he is hungry and not drab.\n(∀x (Drab(x) ∧ Attractive(x))) ↔ (∀x (Wicked(x) ∧ Hungry(x))) ::: If someone is drab and attractive, then he is both wicked and hungry, and vice versa.\n(¬∃x (¬Hungry(x))) → ((Attractive(udolf) ∧ ¬Wicked(joey))) ::: If there is nobody who is not hungry, then Udolf is attractive and Joey is not wicked.\n(∀x (¬Hungry(x))) → (∀x (¬Attractive(x))) ::: If someone is not hungry, then he is not attractive, and vice versa.\n(∃x (Scared(x) ∧ ¬Fat(x))) → ((¬Wicked(christina))) ::: If there is at least one people who is both scared and not fat, then Christina is not wicked.\n(∃x (Fat(x) ∨ ¬Scared(x))) → ((¬Wicked(roderick))) ::: If there is someone who is either fat or not scared, then Roderick is not wicked.\n",
                "First-Order-Logic Question": "¬Scared(udolf) ::: Udolf is not scared."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "¬Fat(barry) ::: Barry is not fat.\n¬Scared(barry) ::: Barry is not scared.\nFat(roderick) ::: Roderick is fat.\n¬Attractive(rolf) ::: Rolf is not attractive.\n¬Drab(udolf) ::: Udolf is not drab.\n¬Scared(rolf) ::: Rolf is not scared.\n¬Hungry(udolf) ::: Udolf is not hungry.\n¬Wicked(udolf) ::: Udolf is not wicked.\n¬Scared(udolf) ::: Udolf is not scared.\n¬Scared(owen) ::: Owen is not scared.\n¬Hungry(joey) ::: Joey is not hungry.\nWicked(joey) ::: Joey is wicked.\n(∃x (Hungry(x) ∨ ¬Scared(x))) → ((¬Wicked(roderick) ∧ ¬Drab(rolf))) ::: If there is at least one people who is either hungry or not scared, then Roderick is not wicked and Rolf is not drab.\n((¬Scared(barry))) ↔ ((¬Attractive(rolf))) ::: Barry being not scared is equivalent to Rolf being not attractive.\n(∃x (¬Drab(x))) → ((¬Fat(roderick))) ::: If there is at least one people who is not drab, then Roderick is not fat.\n((¬Wicked(barry))) ↔ ((Fat(christina) ∧ Drab(roderick))) ::: Barry being not wicked is equivalent to Christina being fat and Roderick being drab.\n(∀x (¬Attractive(x) ∧ Fat(x))) → (∀x (Hungry(x))) ::: If someone who is not attractive is also fat, then he is hungry.\n(∀x (¬Hungry(x) ∧ ¬Scared(x))) ↔ (∀x (Attractive(x) ∧ ¬Fat(x))) ::: If someone is not hungry and not scared, then he is both attractive and not fat, and vice versa.\n(∀x (¬Attractive(x))) → (∀x (Hungry(x) ∧ ¬Drab(x))) ::: As long as someone is not attractive, he is hungry and not drab.\n(∀x (Drab(x) ∧ Attractive(x))) ↔ (∀x (Wicked(x) ∧ Hungry(x))) ::: If someone is drab and attractive, then he is both wicked and hungry, and vice versa.\n¬∃x(¬Hungry(x))→((Attractive(x))) ::: If there is nobody who is not hungry, then Udolf is attractive and Joey is not wicked.\n(∀x (¬Hungry(x))) → (∀x (¬Attractive(x))) ::: If someone is not hungry, then he is not attractive, and vice versa.\n(∃x (Scared(x) ∧ ¬Fat(x))) → ((¬Wicked(christina))) ::: If there is at least one people who is both scared and not fat, then Christina is not wicked.\n(∃x (Fat(x) ∨ ¬Scared(x))) → ((¬Wicked(roderick))) ::: If there is someone who is either fat or not scared, then Roderick is not wicked.\n",
                "First-Order-Logic Question": "¬Scared(udolf) ::: Udolf is not scared."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬Hungry(x))) → ((Attractive(udolf) ∧ ¬Wicked(joey))) ::: If there is nobody who is not hungry, then Udolf is attractive and Joey is not wicked.",
                    "gram": "¬∃x(¬Hungry(x))→((Attractive(x))) ::: If there is nobody who is not hungry, then Udolf is attractive and Joey is not wicked."
                }
            ],
            "answer": "B",
            "grammar_answer": "A",
            "backup_answer": "A"
        },
        {
            "id": 1248,
            "raw_prog": {
                "First-Order-Logic Rules": "¬Fat(barry) ::: Barry is not fat.\n¬Scared(barry) ::: Barry is not scared.\nFat(roderick) ::: Roderick is fat.\n¬Attractive(rolf) ::: Rolf is not attractive.\n¬Drab(udolf) ::: Udolf is not drab.\n¬Scared(rolf) ::: Rolf is not scared.\n¬Hungry(udolf) ::: Udolf is not hungry.\n¬Wicked(udolf) ::: Udolf is not wicked.\n¬Scared(udolf) ::: Udolf is not scared.\n¬Scared(owen) ::: Owen is not scared.\n¬Hungry(joey) ::: Joey is not hungry.\nWicked(joey) ::: Joey is wicked.\n(∃x (Hungry(x) ∨ ¬Scared(x))) → ((¬Wicked(roderick) ∧ ¬Drab(rolf))) ::: If there is at least one people who is either hungry or not scared, then Roderick is not wicked and Rolf is not drab.\n(¬Scared(barry)) ↔ (¬Attractive(rolf)) ::: Barry being not scared is equivalent to Rolf being not attractive.\n(∃x (¬Drab(x))) → (¬Fat(roderick)) ::: If there is at least one people who is not drab, then Roderick is not fat.\n(¬Wicked(barry)) ↔ ((Fat(christina) ∧ Drab(roderick))) ::: Barry being not wicked is equivalent to Christina being fat and Roderick being drab.\n(∀x (¬Attractive(x) ∧ Fat(x))) → (∀x (Hungry(x))) ::: If someone who is not attractive is also fat, then he is hungry.\n(∀x (¬Hungry(x) ∧ ¬Scared(x))) ↔ (∀x (Attractive(x) ∧ ¬Fat(x))) ::: If someone is not hungry and not scared, then he is both attractive and not fat, and vice versa.\n(∀x (¬Attractive(x))) → (∀x (Hungry(x) ∧ ¬Drab(x))) ::: As long as someone is not attractive, he is hungry and not drab.\n(∀x (Drab(x) ∧ Attractive(x))) ↔ (∀x (Wicked(x) ∧ Hungry(x))) ::: If someone is drab and attractive, then he is both wicked and hungry, and vice versa.\n(¬∃x (¬Hungry(x))) → ((Attractive(udolf) ∧ ¬Wicked(joey))) ::: If there is nobody who is not hungry, then Udolf is attractive and Joey is not wicked.\n(∀x (¬Hungry(x))) → (∀x (¬Attractive(x))) ::: If someone is not hungry, then he is not attractive, and vice versa.\n(∃x (Scared(x) ∧ ¬Fat(x))) → (¬Wicked(christina)) ::: If there is at least one people who is both scared and not fat, then Christina is not wicked.\n(∃x (Fat(x) ∨ ¬Scared(x))) → (¬Wicked(roderick)) ::: If there is someone who is either fat or not scared, then Roderick is not wicked.\n",
                "First-Order-Logic Question": "Fat(udolf) ::: Udolf is fat."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "¬Fat(barry) ::: Barry is not fat.\n¬Scared(barry) ::: Barry is not scared.\nFat(roderick) ::: Roderick is fat.\n¬Attractive(rolf) ::: Rolf is not attractive.\n¬Drab(udolf) ::: Udolf is not drab.\n¬Scared(rolf) ::: Rolf is not scared.\n¬Hungry(udolf) ::: Udolf is not hungry.\n¬Wicked(udolf) ::: Udolf is not wicked.\n¬Scared(udolf) ::: Udolf is not scared.\n¬Scared(owen) ::: Owen is not scared.\n¬Hungry(joey) ::: Joey is not hungry.\nWicked(joey) ::: Joey is wicked.\n(∃x (Hungry(x) ∨ ¬Scared(x))) → ((¬Wicked(roderick) ∧ ¬Drab(rolf))) ::: If there is at least one people who is either hungry or not scared, then Roderick is not wicked and Rolf is not drab.\n(¬Scared(barry)) ↔ (¬Attractive(rolf)) ::: Barry being not scared is equivalent to Rolf being not attractive.\n(∃x (¬Drab(x))) → (¬Fat(roderick)) ::: If there is at least one people who is not drab, then Roderick is not fat.\n(¬Wicked(barry)) ↔ ((Fat(christina) ∧ Drab(roderick))) ::: Barry being not wicked is equivalent to Christina being fat and Roderick being drab.\n(∀x (¬Attractive(x) ∧ Fat(x))) → (∀x (Hungry(x))) ::: If someone who is not attractive is also fat, then he is hungry.\n(∀x (¬Hungry(x) ∧ ¬Scared(x))) ↔ (∀x (Attractive(x) ∧ ¬Fat(x))) ::: If someone is not hungry and not scared, then he is both attractive and not fat, and vice versa.\n(∀x (¬Attractive(x))) → (∀x (Hungry(x) ∧ ¬Drab(x))) ::: As long as someone is not attractive, he is hungry and not drab.\n(∀x (Drab(x) ∧ Attractive(x))) ↔ (∀x (Wicked(x) ∧ Hungry(x))) ::: If someone is drab and attractive, then he is both wicked and hungry, and vice versa.\n¬∃x(¬Hungry(x))→((Attractive(x))) ::: If there is nobody who is not hungry, then Udolf is attractive and Joey is not wicked.\n(∀x (¬Hungry(x))) → (∀x (¬Attractive(x))) ::: If someone is not hungry, then he is not attractive, and vice versa.\n(∃x (Scared(x) ∧ ¬Fat(x))) → (¬Wicked(christina)) ::: If there is at least one people who is both scared and not fat, then Christina is not wicked.\n(∃x (Fat(x) ∨ ¬Scared(x))) → (¬Wicked(roderick)) ::: If there is someone who is either fat or not scared, then Roderick is not wicked.\n",
                "First-Order-Logic Question": "Fat(udolf) ::: Udolf is fat."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬Hungry(x))) → ((Attractive(udolf) ∧ ¬Wicked(joey))) ::: If there is nobody who is not hungry, then Udolf is attractive and Joey is not wicked.",
                    "gram": "¬∃x(¬Hungry(x))→((Attractive(x))) ::: If there is nobody who is not hungry, then Udolf is attractive and Joey is not wicked."
                }
            ],
            "answer": "A",
            "grammar_answer": "A",
            "backup_answer": "C"
        },
        {
            "id": 1249,
            "raw_prog": {
                "First-Order-Logic Rules": "¬Fat(barry) ::: Barry is not fat.\n¬Scared(barry) ::: Barry is not scared.\nFat(roderick) ::: Roderick is fat.\n¬Attractive(rolf) ::: Rolf is not attractive.\n¬Drab(udolf) ::: Udolf is not drab.\n¬Scared(rolf) ::: Rolf is not scared.\n¬Hungry(udolf) ::: Udolf is not hungry.\n¬Wicked(udolf) ::: Udolf is not wicked.\n¬Scared(udolf) ::: Udolf is not scared.\n¬Scared(owen) ::: Owen is not scared.\n¬Hungry(joey) ::: Joey is not hungry.\nWicked(joey) ::: Joey is wicked.\n(∃x (Hungry(x) ∨ ¬Scared(x))) → ((¬Wicked(roderick) ∧ ¬Drab(rolf))) ::: If there is at least one people who is either hungry or not scared, then Roderick is not wicked and Rolf is not drab.\n(¬Scared(barry)) ↔ (¬Attractive(rolf)) ::: Barry being not scared is equivalent to Rolf being not attractive.\n(∃x (¬Drab(x))) → (¬Fat(roderick)) ::: If there is at least one people who is not drab, then Roderick is not fat.\n(¬Wicked(barry)) ↔ ((Fat(christina) ∧ Drab(roderick))) ::: Barry being not wicked is equivalent to Christina being fat and Roderick being drab.\n(∀x (¬Attractive(x) ∧ Fat(x))) → (∀x (Hungry(x))) ::: If someone who is not attractive is also fat, then he is hungry.\n(∀x (¬Hungry(x) ∧ ¬Scared(x))) ↔ (∀x (Attractive(x) ∧ ¬Fat(x))) ::: If someone is not hungry and not scared, then he is both attractive and not fat, and vice versa.\n(∀x (¬Attractive(x))) → (∀x (Hungry(x) ∧ ¬Drab(x))) ::: As long as someone is not attractive, he is hungry and not drab.\n(∀x (Drab(x) ∧ Attractive(x))) ↔ (∀x (Wicked(x) ∧ Hungry(x))) ::: If someone is drab and attractive, then he is both wicked and hungry, and vice versa.\n(¬∃x (¬Hungry(x))) → ((Attractive(udolf) ∧ ¬Wicked(joey))) ::: If there is nobody who is not hungry, then Udolf is attractive and Joey is not wicked.\n(∀x (¬Hungry(x))) → (∀x (¬Attractive(x))) ::: If someone is not hungry, then he is not attractive, and vice versa.\n(∃x (Scared(x) ∧ ¬Fat(x))) → (¬Wicked(christina)) ::: If there is at least one people who is both scared and not fat, then Christina is not wicked.\n(∃x (Fat(x) ∨ ¬Scared(x))) → (¬Wicked(roderick)) ::: If there is someone who is either fat or not scared, then Roderick is not wicked.\n",
                "First-Order-Logic Question": "¬Wicked(roderick) ::: Roderick is not wicked."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "¬Fat(barry) ::: Barry is not fat.\n¬Scared(barry) ::: Barry is not scared.\nFat(roderick) ::: Roderick is fat.\n¬Attractive(rolf) ::: Rolf is not attractive.\n¬Drab(udolf) ::: Udolf is not drab.\n¬Scared(rolf) ::: Rolf is not scared.\n¬Hungry(udolf) ::: Udolf is not hungry.\n¬Wicked(udolf) ::: Udolf is not wicked.\n¬Scared(udolf) ::: Udolf is not scared.\n¬Scared(owen) ::: Owen is not scared.\n¬Hungry(joey) ::: Joey is not hungry.\nWicked(joey) ::: Joey is wicked.\n(∃x (Hungry(x) ∨ ¬Scared(x))) → ((¬Wicked(roderick) ∧ ¬Drab(rolf))) ::: If there is at least one people who is either hungry or not scared, then Roderick is not wicked and Rolf is not drab.\n(¬Scared(barry)) ↔ (¬Attractive(rolf)) ::: Barry being not scared is equivalent to Rolf being not attractive.\n(∃x (¬Drab(x))) → (¬Fat(roderick)) ::: If there is at least one people who is not drab, then Roderick is not fat.\n(¬Wicked(barry)) ↔ ((Fat(christina) ∧ Drab(roderick))) ::: Barry being not wicked is equivalent to Christina being fat and Roderick being drab.\n(∀x (¬Attractive(x) ∧ Fat(x))) → (∀x (Hungry(x))) ::: If someone who is not attractive is also fat, then he is hungry.\n(∀x (¬Hungry(x) ∧ ¬Scared(x))) ↔ (∀x (Attractive(x) ∧ ¬Fat(x))) ::: If someone is not hungry and not scared, then he is both attractive and not fat, and vice versa.\n(∀x (¬Attractive(x))) → (∀x (Hungry(x) ∧ ¬Drab(x))) ::: As long as someone is not attractive, he is hungry and not drab.\n(∀x (Drab(x) ∧ Attractive(x))) ↔ (∀x (Wicked(x) ∧ Hungry(x))) ::: If someone is drab and attractive, then he is both wicked and hungry, and vice versa.\n¬∃x(¬Hungry(x))→((Attractive(x))) ::: If there is nobody who is not hungry, then Udolf is attractive and Joey is not wicked.\n(∀x (¬Hungry(x))) → (∀x (¬Attractive(x))) ::: If someone is not hungry, then he is not attractive, and vice versa.\n(∃x (Scared(x) ∧ ¬Fat(x))) → (¬Wicked(christina)) ::: If there is at least one people who is both scared and not fat, then Christina is not wicked.\n(∃x (Fat(x) ∨ ¬Scared(x))) → (¬Wicked(roderick)) ::: If there is someone who is either fat or not scared, then Roderick is not wicked.\n",
                "First-Order-Logic Question": "¬Wicked(roderick) ::: Roderick is not wicked."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬Hungry(x))) → ((Attractive(udolf) ∧ ¬Wicked(joey))) ::: If there is nobody who is not hungry, then Udolf is attractive and Joey is not wicked.",
                    "gram": "¬∃x(¬Hungry(x))→((Attractive(x))) ::: If there is nobody who is not hungry, then Udolf is attractive and Joey is not wicked."
                }
            ],
            "answer": "C",
            "grammar_answer": "A",
            "backup_answer": "A"
        },
        {
            "id": 1250,
            "raw_prog": {
                "First-Order-Logic Rules": "¬Fat(barry) ::: Barry is not fat.\n¬Scared(barry) ::: Barry is not scared.\nFat(roderick) ::: Roderick is fat.\n¬Attractive(rolf) ::: Rolf is not attractive.\n¬Drab(udolf) ::: Udolf is not drab.\n¬Scared(rolf) ::: Rolf is not scared.\n¬Hungry(udolf) ::: Udolf is not hungry.\n¬Wicked(udolf) ::: Udolf is not wicked.\n¬Scared(udolf) ::: Udolf is not scared.\n¬Scared(owen) ::: Owen is not scared.\n¬Hungry(joey) ::: Joey is not hungry.\nWicked(joey) ::: Joey is wicked.\n(∃x (Hungry(x) ∨ ¬Scared(x))) → ((¬Wicked(roderick) ∧ ¬Drab(rolf))) ::: If there is at least one people who is either hungry or not scared, then Roderick is not wicked and Rolf is not drab.\n((¬Scared(barry))) ↔ ((¬Attractive(rolf))) ::: Barry being not scared is equivalent to Rolf being not attractive.\n(∃x (¬Drab(x))) → ((¬Fat(roderick))) ::: If there is at least one people who is not drab, then Roderick is not fat.\n((¬Wicked(barry))) ↔ ((Fat(christina) ∧ Drab(roderick))) ::: Barry being not wicked is equivalent to Christina being fat and Roderick being drab.\n(∀x (¬Attractive(x) ∧ Fat(x))) → (∀x (Hungry(x))) ::: If someone who is not attractive is also fat, then he is hungry.\n(∀x (¬Hungry(x) ∧ ¬Scared(x))) ↔ (∀x (Attractive(x) ∧ ¬Fat(x))) ::: If someone is not hungry and not scared, then he is both attractive and not fat, and vice versa.\n(∀x (¬Attractive(x))) → (∀x (Hungry(x) ∧ ¬Drab(x))) ::: As long as someone is not attractive, he is hungry and not drab.\n(∀x (Drab(x) ∧ Attractive(x))) ↔ (∀x (Wicked(x) ∧ Hungry(x))) ::: If someone is drab and attractive, then he is both wicked and hungry, and vice versa.\n(¬∃x (¬Hungry(x))) → ((Attractive(udolf) ∧ ¬Wicked(joey))) ::: If there is nobody who is not hungry, then Udolf is attractive and Joey is not wicked.\n(∀x (¬Hungry(x))) → (∀x (¬Attractive(x))) ::: If someone is not hungry, then he is not attractive, and vice versa.\n(∃x (Scared(x) ∧ ¬Fat(x))) → ((¬Wicked(christina))) ::: If there is at least one people who is both scared and not fat, then Christina is not wicked.\n(∃x (Fat(x) ∨ ¬Scared(x))) → ((¬Wicked(roderick))) ::: If there is someone who is either fat or not scared, then Roderick is not wicked.\n",
                "First-Order-Logic Question": "¬Fat(joey) ::: Joey is not fat."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "¬Fat(barry) ::: Barry is not fat.\n¬Scared(barry) ::: Barry is not scared.\nFat(roderick) ::: Roderick is fat.\n¬Attractive(rolf) ::: Rolf is not attractive.\n¬Drab(udolf) ::: Udolf is not drab.\n¬Scared(rolf) ::: Rolf is not scared.\n¬Hungry(udolf) ::: Udolf is not hungry.\n¬Wicked(udolf) ::: Udolf is not wicked.\n¬Scared(udolf) ::: Udolf is not scared.\n¬Scared(owen) ::: Owen is not scared.\n¬Hungry(joey) ::: Joey is not hungry.\nWicked(joey) ::: Joey is wicked.\n(∃x (Hungry(x) ∨ ¬Scared(x))) → ((¬Wicked(roderick) ∧ ¬Drab(rolf))) ::: If there is at least one people who is either hungry or not scared, then Roderick is not wicked and Rolf is not drab.\n((¬Scared(barry))) ↔ ((¬Attractive(rolf))) ::: Barry being not scared is equivalent to Rolf being not attractive.\n(∃x (¬Drab(x))) → ((¬Fat(roderick))) ::: If there is at least one people who is not drab, then Roderick is not fat.\n((¬Wicked(barry))) ↔ ((Fat(christina) ∧ Drab(roderick))) ::: Barry being not wicked is equivalent to Christina being fat and Roderick being drab.\n(∀x (¬Attractive(x) ∧ Fat(x))) → (∀x (Hungry(x))) ::: If someone who is not attractive is also fat, then he is hungry.\n(∀x (¬Hungry(x) ∧ ¬Scared(x))) ↔ (∀x (Attractive(x) ∧ ¬Fat(x))) ::: If someone is not hungry and not scared, then he is both attractive and not fat, and vice versa.\n(∀x (¬Attractive(x))) → (∀x (Hungry(x) ∧ ¬Drab(x))) ::: As long as someone is not attractive, he is hungry and not drab.\n(∀x (Drab(x) ∧ Attractive(x))) ↔ (∀x (Wicked(x) ∧ Hungry(x))) ::: If someone is drab and attractive, then he is both wicked and hungry, and vice versa.\n¬∃x(¬Hungry(x))→((Attractive(x))) ::: If there is nobody who is not hungry, then Udolf is attractive and Joey is not wicked.\n(∀x (¬Hungry(x))) → (∀x (¬Attractive(x))) ::: If someone is not hungry, then he is not attractive, and vice versa.\n(∃x (Scared(x) ∧ ¬Fat(x))) → ((¬Wicked(christina))) ::: If there is at least one people who is both scared and not fat, then Christina is not wicked.\n(∃x (Fat(x) ∨ ¬Scared(x))) → ((¬Wicked(roderick))) ::: If there is someone who is either fat or not scared, then Roderick is not wicked.\n",
                "First-Order-Logic Question": "¬Fat(joey) ::: Joey is not fat."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬Hungry(x))) → ((Attractive(udolf) ∧ ¬Wicked(joey))) ::: If there is nobody who is not hungry, then Udolf is attractive and Joey is not wicked.",
                    "gram": "¬∃x(¬Hungry(x))→((Attractive(x))) ::: If there is nobody who is not hungry, then Udolf is attractive and Joey is not wicked."
                }
            ],
            "answer": "A",
            "grammar_answer": "A",
            "backup_answer": "A"
        },
        {
            "id": 1251,
            "raw_prog": {
                "First-Order-Logic Rules": "¬Fat(barry) ::: Barry is not fat.\n¬Scared(barry) ::: Barry is not scared.\nFat(roderick) ::: Roderick is fat.\n¬Attractive(rolf) ::: Rolf is not attractive.\n¬Drab(udolf) ::: Udolf is not drab.\n¬Scared(rolf) ::: Rolf is not scared.\n¬Hungry(udolf) ::: Udolf is not hungry.\n¬Wicked(udolf) ::: Udolf is not wicked.\n¬Scared(udolf) ::: Udolf is not scared.\n¬Scared(owen) ::: Owen is not scared.\n¬Hungry(joey) ::: Joey is not hungry.\nWicked(joey) ::: Joey is wicked.\n(∃x (Hungry(x) ∨ ¬Scared(x))) → ((¬Wicked(roderick) ∧ ¬Drab(rolf))) ::: If there is at least one people who is either hungry or not scared, then Roderick is not wicked and Rolf is not drab.\n(¬Scared(barry)) ↔ (¬Attractive(rolf)) ::: Barry being not scared is equivalent to Rolf being not attractive.\n(∃x (¬Drab(x))) → (¬Fat(roderick)) ::: If there is at least one people who is not drab, then Roderick is not fat.\n(¬Wicked(barry)) ↔ ((Fat(christina) ∧ Drab(roderick))) ::: Barry being not wicked is equivalent to Christina being fat and Roderick being drab.\n(∀x (¬Attractive(x) ∧ Fat(x))) → (∀x (Hungry(x))) ::: If someone who is not attractive is also fat, then he is hungry.\n(∀x (¬Hungry(x) ∧ ¬Scared(x))) ↔ (∀x (Attractive(x) ∧ ¬Fat(x))) ::: If someone is not hungry and not scared, then he is both attractive and not fat, and vice versa.\n(∀x (¬Attractive(x))) → (∀x (Hungry(x) ∧ ¬Drab(x))) ::: As long as someone is not attractive, he is hungry and not drab.\n(∀x (Drab(x) ∧ Attractive(x))) ↔ (∀x (Wicked(x) ∧ Hungry(x))) ::: If someone is drab and attractive, then he is both wicked and hungry, and vice versa.\n(¬∃x (¬Hungry(x))) → ((Attractive(udolf) ∧ ¬Wicked(joey))) ::: If there is nobody who is not hungry, then Udolf is attractive and Joey is not wicked.\n(∀x (¬Hungry(x))) → (∀x (¬Attractive(x))) ::: If someone is not hungry, then he is not attractive, and vice versa.\n(∃x (Scared(x) ∧ ¬Fat(x))) → (¬Wicked(christina)) ::: If there is at least one people who is both scared and not fat, then Christina is not wicked.\n(∃x (Fat(x) ∨ ¬Scared(x))) → (¬Wicked(roderick)) ::: If there is someone who is either fat or not scared, then Roderick is not wicked.\n",
                "First-Order-Logic Question": "¬Scared(barry) ::: Barry is not scared."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "¬Fat(barry) ::: Barry is not fat.\n¬Scared(barry) ::: Barry is not scared.\nFat(roderick) ::: Roderick is fat.\n¬Attractive(rolf) ::: Rolf is not attractive.\n¬Drab(udolf) ::: Udolf is not drab.\n¬Scared(rolf) ::: Rolf is not scared.\n¬Hungry(udolf) ::: Udolf is not hungry.\n¬Wicked(udolf) ::: Udolf is not wicked.\n¬Scared(udolf) ::: Udolf is not scared.\n¬Scared(owen) ::: Owen is not scared.\n¬Hungry(joey) ::: Joey is not hungry.\nWicked(joey) ::: Joey is wicked.\n(∃x (Hungry(x) ∨ ¬Scared(x))) → ((¬Wicked(roderick) ∧ ¬Drab(rolf))) ::: If there is at least one people who is either hungry or not scared, then Roderick is not wicked and Rolf is not drab.\n(¬Scared(barry)) ↔ (¬Attractive(rolf)) ::: Barry being not scared is equivalent to Rolf being not attractive.\n(∃x (¬Drab(x))) → (¬Fat(roderick)) ::: If there is at least one people who is not drab, then Roderick is not fat.\n(¬Wicked(barry)) ↔ ((Fat(christina) ∧ Drab(roderick))) ::: Barry being not wicked is equivalent to Christina being fat and Roderick being drab.\n(∀x (¬Attractive(x) ∧ Fat(x))) → (∀x (Hungry(x))) ::: If someone who is not attractive is also fat, then he is hungry.\n(∀x (¬Hungry(x) ∧ ¬Scared(x))) ↔ (∀x (Attractive(x) ∧ ¬Fat(x))) ::: If someone is not hungry and not scared, then he is both attractive and not fat, and vice versa.\n(∀x (¬Attractive(x))) → (∀x (Hungry(x) ∧ ¬Drab(x))) ::: As long as someone is not attractive, he is hungry and not drab.\n(∀x (Drab(x) ∧ Attractive(x))) ↔ (∀x (Wicked(x) ∧ Hungry(x))) ::: If someone is drab and attractive, then he is both wicked and hungry, and vice versa.\n¬∃x(¬Hungry(x))→((Attractive(x))) ::: If there is nobody who is not hungry, then Udolf is attractive and Joey is not wicked.\n(∀x (¬Hungry(x))) → (∀x (¬Attractive(x))) ::: If someone is not hungry, then he is not attractive, and vice versa.\n(∃x (Scared(x) ∧ ¬Fat(x))) → (¬Wicked(christina)) ::: If there is at least one people who is both scared and not fat, then Christina is not wicked.\n(∃x (Fat(x) ∨ ¬Scared(x))) → (¬Wicked(roderick)) ::: If there is someone who is either fat or not scared, then Roderick is not wicked.\n",
                "First-Order-Logic Question": "¬Scared(barry) ::: Barry is not scared."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬Hungry(x))) → ((Attractive(udolf) ∧ ¬Wicked(joey))) ::: If there is nobody who is not hungry, then Udolf is attractive and Joey is not wicked.",
                    "gram": "¬∃x(¬Hungry(x))→((Attractive(x))) ::: If there is nobody who is not hungry, then Udolf is attractive and Joey is not wicked."
                }
            ],
            "answer": "B",
            "grammar_answer": "A",
            "backup_answer": "A"
        },
        {
            "id": 1252,
            "raw_prog": {
                "First-Order-Logic Rules": "¬Fat(barry) ::: Barry is not fat.\n¬Scared(barry) ::: Barry is not scared.\nFat(roderick) ::: Roderick is fat.\n¬Attractive(rolf) ::: Rolf is not attractive.\n¬Drab(udolf) ::: Udolf is not drab.\n¬Scared(rolf) ::: Rolf is not scared.\n¬Hungry(udolf) ::: Udolf is not hungry.\n¬Wicked(udolf) ::: Udolf is not wicked.\n¬Scared(udolf) ::: Udolf is not scared.\n¬Scared(owen) ::: Owen is not scared.\n¬Hungry(joey) ::: Joey is not hungry.\nWicked(joey) ::: Joey is wicked.\n(∃x (Hungry(x) ∨ ¬Scared(x))) → ((¬Wicked(roderick) ∧ ¬Drab(rolf))) ::: If there is at least one people who is either hungry or not scared, then Roderick is not wicked and Rolf is not drab.\n(¬Scared(barry)) ↔ (¬Attractive(rolf)) ::: Barry being not scared is equivalent to Rolf being not attractive.\n(∃x (¬Drab(x))) → (¬Fat(roderick)) ::: If there is at least one people who is not drab, then Roderick is not fat.\n(¬Wicked(barry)) ↔ ((Fat(christina) ∧ Drab(roderick))) ::: Barry being not wicked is equivalent to Christina being fat and Roderick being drab.\n(∀x (¬Attractive(x) ∧ Fat(x))) → (∀x (Hungry(x))) ::: If someone who is not attractive is also fat, then he is hungry.\n(∀x (¬Hungry(x) ∧ ¬Scared(x))) ↔ (∀x (Attractive(x) ∧ ¬Fat(x))) ::: If someone is not hungry and not scared, then he is both attractive and not fat, and vice versa.\n(∀x (¬Attractive(x))) → (∀x (Hungry(x) ∧ ¬Drab(x))) ::: As long as someone is not attractive, he is hungry and not drab.\n(∀x (Drab(x) ∧ Attractive(x))) ↔ (∀x (Wicked(x) ∧ Hungry(x))) ::: If someone is drab and attractive, then he is both wicked and hungry, and vice versa.\n(¬∃x (¬Hungry(x))) → ((Attractive(udolf) ∧ ¬Wicked(joey))) ::: If there is nobody who is not hungry, then Udolf is attractive and Joey is not wicked.\n(∀x (¬Hungry(x))) → (∀x (¬Attractive(x))) ::: If someone is not hungry, then he is not attractive, and vice versa.\n(∃x (Scared(x) ∧ ¬Fat(x))) → (¬Wicked(christina)) ::: If there is at least one people who is both scared and not fat, then Christina is not wicked.\n(∃x (Fat(x) ∨ ¬Scared(x))) → (¬Wicked(roderick)) ::: If there is someone who is either fat or not scared, then Roderick is not wicked.\n",
                "First-Order-Logic Question": "Fat(barry) ::: Barry is fat."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "¬Fat(barry) ::: Barry is not fat.\n¬Scared(barry) ::: Barry is not scared.\nFat(roderick) ::: Roderick is fat.\n¬Attractive(rolf) ::: Rolf is not attractive.\n¬Drab(udolf) ::: Udolf is not drab.\n¬Scared(rolf) ::: Rolf is not scared.\n¬Hungry(udolf) ::: Udolf is not hungry.\n¬Wicked(udolf) ::: Udolf is not wicked.\n¬Scared(udolf) ::: Udolf is not scared.\n¬Scared(owen) ::: Owen is not scared.\n¬Hungry(joey) ::: Joey is not hungry.\nWicked(joey) ::: Joey is wicked.\n(∃x (Hungry(x) ∨ ¬Scared(x))) → ((¬Wicked(roderick) ∧ ¬Drab(rolf))) ::: If there is at least one people who is either hungry or not scared, then Roderick is not wicked and Rolf is not drab.\n(¬Scared(barry)) ↔ (¬Attractive(rolf)) ::: Barry being not scared is equivalent to Rolf being not attractive.\n(∃x (¬Drab(x))) → (¬Fat(roderick)) ::: If there is at least one people who is not drab, then Roderick is not fat.\n(¬Wicked(barry)) ↔ ((Fat(christina) ∧ Drab(roderick))) ::: Barry being not wicked is equivalent to Christina being fat and Roderick being drab.\n(∀x (¬Attractive(x) ∧ Fat(x))) → (∀x (Hungry(x))) ::: If someone who is not attractive is also fat, then he is hungry.\n(∀x (¬Hungry(x) ∧ ¬Scared(x))) ↔ (∀x (Attractive(x) ∧ ¬Fat(x))) ::: If someone is not hungry and not scared, then he is both attractive and not fat, and vice versa.\n(∀x (¬Attractive(x))) → (∀x (Hungry(x) ∧ ¬Drab(x))) ::: As long as someone is not attractive, he is hungry and not drab.\n(∀x (Drab(x) ∧ Attractive(x))) ↔ (∀x (Wicked(x) ∧ Hungry(x))) ::: If someone is drab and attractive, then he is both wicked and hungry, and vice versa.\n¬∃x(¬Hungry(x))→((Attractive(x))) ::: If there is nobody who is not hungry, then Udolf is attractive and Joey is not wicked.\n(∀x (¬Hungry(x))) → (∀x (¬Attractive(x))) ::: If someone is not hungry, then he is not attractive, and vice versa.\n(∃x (Scared(x) ∧ ¬Fat(x))) → (¬Wicked(christina)) ::: If there is at least one people who is both scared and not fat, then Christina is not wicked.\n(∃x (Fat(x) ∨ ¬Scared(x))) → (¬Wicked(roderick)) ::: If there is someone who is either fat or not scared, then Roderick is not wicked.\n",
                "First-Order-Logic Question": "Fat(barry) ::: Barry is fat."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬Hungry(x))) → ((Attractive(udolf) ∧ ¬Wicked(joey))) ::: If there is nobody who is not hungry, then Udolf is attractive and Joey is not wicked.",
                    "gram": "¬∃x(¬Hungry(x))→((Attractive(x))) ::: If there is nobody who is not hungry, then Udolf is attractive and Joey is not wicked."
                }
            ],
            "answer": "A",
            "grammar_answer": "A",
            "backup_answer": "B"
        },
        {
            "id": 1253,
            "raw_prog": {
                "First-Order-Logic Rules": [
                    "¬Fat(barry) ::: Barry is not fat.",
                    "¬Scared(barry) ::: Barry is not scared.",
                    "Fat(roderick) ::: Roderick is fat.",
                    "¬Attractive(rolf) ::: Rolf is not attractive.",
                    "¬Drab(udolf) ::: Udolf is not drab.",
                    "¬Scared(rolf) ::: Rolf is not scared.",
                    "¬Hungry(udolf) ::: Udolf is not hungry.",
                    "¬Wicked(udolf) ::: Udolf is not wicked.",
                    "¬Scared(udolf) ::: Udolf is not scared.",
                    "¬Scared(owen) ::: Owen is not scared.",
                    "¬Hungry(joey) ::: Joey is not hungry.",
                    "Wicked(joey) ::: Joey is wicked.",
                    "(∃x (Hungry(x) ∨ ¬Scared(x))) → (¬Wicked(roderick) ∧ ¬Drab(rolf)) ::: If there is at least one people who is either hungry or not scared, then Roderick is not wicked and Rolf is not drab.",
                    "¬Scared(barry) ↔ ¬Attractive(rolf) ::: Barry being not scared is equivalent to Rolf being not attractive.",
                    "(∃x (¬Drab(x))) → (¬Fat(roderick)) ::: If there is at least one people who is not drab, then Roderick is not fat.",
                    "¬Wicked(barry) ↔ (Fat(christina) ∧ Drab(roderick)) ::: Barry being not wicked is equivalent to Christina being fat and Roderick being drab.",
                    "(∀x (¬Attractive(x) ∧ Fat(x))) → (∀x (Hungry(x))) ::: If someone who is not attractive is also fat, then he is hungry.",
                    "(∀x (¬Hungry(x) ∧ ¬Scared(x))) ↔ (∀x (Attractive(x) ∧ ¬Fat(x))) ::: If someone is not hungry and not scared, then he is both attractive and not fat, and vice versa.",
                    "(∀x (¬Attractive(x))) → (∀x (Hungry(x) ∧ ¬Drab(x))) ::: As long as someone is not attractive, he is hungry and not drab.",
                    "(∀x (Drab(x) ∧ Attractive(x))) ↔ (∀x (Wicked(x) ∧ Hungry(x))) ::: If someone is drab and attractive, then he is both wicked and hungry, and vice versa.",
                    "(¬∃x (¬Hungry(x))) → (Attractive(udolf) ∧ ¬Wicked(joey)) ::: If there is nobody who is not hungry, then Udolf is attractive and Joey is not wicked.",
                    "(∀x (¬Hungry(x))) → (∀x (¬Attractive(x))) ::: If someone is not hungry, then he is not attractive, and vice versa.",
                    "(∃x (Scared(x) ∧ ¬Fat(x))) → (¬Wicked(christina)) ::: If there is at least one people who is both scared and not fat, then Christina is not wicked.",
                    "(∃x (Fat(x) ∨ ¬Scared(x))) → (¬Wicked(roderick)) ::: If there is someone who is either fat or not scared, then Roderick is not wicked."
                ],
                "First-Order-Logic Question": "¬Fat(udolf) ::: Udolf is not fat."
            },
            "gram_prog": {
                "First-Order-Logic Rules": [
                    "¬Fat(barry) ::: Barry is not fat.",
                    "¬Scared(barry) ::: Barry is not scared.",
                    "Fat(roderick) ::: Roderick is fat.",
                    "¬Attractive(rolf) ::: Rolf is not attractive.",
                    "¬Drab(udolf) ::: Udolf is not drab.",
                    "¬Scared(rolf) ::: Rolf is not scared.",
                    "¬Hungry(udolf) ::: Udolf is not hungry.",
                    "¬Wicked(udolf) ::: Udolf is not wicked.",
                    "¬Scared(udolf) ::: Udolf is not scared.",
                    "¬Scared(owen) ::: Owen is not scared.",
                    "¬Hungry(joey) ::: Joey is not hungry.",
                    "Wicked(joey) ::: Joey is wicked.",
                    "(∃x (Hungry(x) ∨ ¬Scared(x))) → (¬Wicked(roderick) ∧ ¬Drab(rolf)) ::: If there is at least one people who is either hungry or not scared, then Roderick is not wicked and Rolf is not drab.",
                    "¬Scared(barry) ↔ ¬Attractive(rolf) ::: Barry being not scared is equivalent to Rolf being not attractive.",
                    "(∃x (¬Drab(x))) → (¬Fat(roderick)) ::: If there is at least one people who is not drab, then Roderick is not fat.",
                    "¬Wicked(barry) ↔ (Fat(christina) ∧ Drab(roderick)) ::: Barry being not wicked is equivalent to Christina being fat and Roderick being drab.",
                    "(∀x (¬Attractive(x) ∧ Fat(x))) → (∀x (Hungry(x))) ::: If someone who is not attractive is also fat, then he is hungry.",
                    "(∀x (¬Hungry(x) ∧ ¬Scared(x))) ↔ (∀x (Attractive(x) ∧ ¬Fat(x))) ::: If someone is not hungry and not scared, then he is both attractive and not fat, and vice versa.",
                    "(∀x (¬Attractive(x))) → (∀x (Hungry(x) ∧ ¬Drab(x))) ::: As long as someone is not attractive, he is hungry and not drab.",
                    "(∀x (Drab(x) ∧ Attractive(x))) ↔ (∀x (Wicked(x) ∧ Hungry(x))) ::: If someone is drab and attractive, then he is both wicked and hungry, and vice versa.",
                    "¬∃x(¬Hungry(x))→(Attractive(x)∧¬Wicked(x)) ::: If there is nobody who is not hungry, then Udolf is attractive and Joey is not wicked.",
                    "(∀x (¬Hungry(x))) → (∀x (¬Attractive(x))) ::: If someone is not hungry, then he is not attractive, and vice versa.",
                    "(∃x (Scared(x) ∧ ¬Fat(x))) → (¬Wicked(christina)) ::: If there is at least one people who is both scared and not fat, then Christina is not wicked.",
                    "(∃x (Fat(x) ∨ ¬Scared(x))) → (¬Wicked(roderick)) ::: If there is someone who is either fat or not scared, then Roderick is not wicked."
                ],
                "First-Order-Logic Question": "¬Fat(udolf) ::: Udolf is not fat."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬Hungry(x))) → (Attractive(udolf) ∧ ¬Wicked(joey)) ::: If there is nobody who is not hungry, then Udolf is attractive and Joey is not wicked.",
                    "gram": "¬∃x(¬Hungry(x))→(Attractive(x)∧¬Wicked(x)) ::: If there is nobody who is not hungry, then Udolf is attractive and Joey is not wicked."
                }
            ],
            "answer": "C",
            "grammar_answer": "A",
            "backup_answer": "A"
        },
        {
            "id": 1254,
            "raw_prog": {
                "First-Order-Logic Rules": "¬Fat(barry) ::: Barry is not fat.\n¬Scared(barry) ::: Barry is not scared.\nFat(roderick) ::: Roderick is fat.\n¬Attractive(rolf) ::: Rolf is not attractive.\n¬Drab(udolf) ::: Udolf is not drab.\n¬Scared(rolf) ::: Rolf is not scared.\n¬Hungry(udolf) ::: Udolf is not hungry.\n¬Wicked(udolf) ::: Udolf is not wicked.\n¬Scared(udolf) ::: Udolf is not scared.\n¬Scared(owen) ::: Owen is not scared.\n¬Hungry(joey) ::: Joey is not hungry.\nWicked(joey) ::: Joey is wicked.\n(∃x (Hungry(x) ∨ ¬Scared(x))) → ((¬Wicked(roderick) ∧ ¬Drab(rolf))) ::: If there is at least one people who is either hungry or not scared, then Roderick is not wicked and Rolf is not drab.\n(¬Scared(barry)) ↔ (¬Attractive(rolf)) ::: Barry being not scared is equivalent to Rolf being not attractive.\n(∃x (¬Drab(x))) → (¬Fat(roderick)) ::: If there is at least one people who is not drab, then Roderick is not fat.\n(¬Wicked(barry)) ↔ ((Fat(christina) ∧ Drab(roderick))) ::: Barry being not wicked is equivalent to Christina being fat and Roderick being drab.\n(∀x (¬Attractive(x) ∧ Fat(x))) → (∀x (Hungry(x))) ::: If someone who is not attractive is also fat, then he is hungry.\n(∀x (¬Hungry(x) ∧ ¬Scared(x))) ↔ (∀x (Attractive(x) ∧ ¬Fat(x))) ::: If someone is not hungry and not scared, then he is both attractive and not fat, and vice versa.\n(∀x (¬Attractive(x))) → (∀x (Hungry(x) ∧ ¬Drab(x))) ::: As long as someone is not attractive, he is hungry and not drab.\n(∀x (Drab(x) ∧ Attractive(x))) ↔ (∀x (Wicked(x) ∧ Hungry(x))) ::: If someone is drab and attractive, then he is both wicked and hungry, and vice versa.\n(¬∃x (¬Hungry(x))) → ((Attractive(udolf) ∧ ¬Wicked(joey))) ::: If there is nobody who is not hungry, then Udolf is attractive and Joey is not wicked.\n(∀x (¬Hungry(x))) → (∀x (¬Attractive(x))) ::: If someone is not hungry, then he is not attractive, and vice versa.\n(∃x (Scared(x) ∧ ¬Fat(x))) → (¬Wicked(christina)) ::: If there is at least one people who is both scared and not fat, then Christina is not wicked.\n(∃x (Fat(x) ∨ ¬Scared(x))) → (¬Wicked(roderick)) ::: If there is someone who is either fat or not scared, then Roderick is not wicked.\n",
                "First-Order-Logic Question": "¬Hungry(barry) ::: Barry is not hungry."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "¬Fat(barry) ::: Barry is not fat.\n¬Scared(barry) ::: Barry is not scared.\nFat(roderick) ::: Roderick is fat.\n¬Attractive(rolf) ::: Rolf is not attractive.\n¬Drab(udolf) ::: Udolf is not drab.\n¬Scared(rolf) ::: Rolf is not scared.\n¬Hungry(udolf) ::: Udolf is not hungry.\n¬Wicked(udolf) ::: Udolf is not wicked.\n¬Scared(udolf) ::: Udolf is not scared.\n¬Scared(owen) ::: Owen is not scared.\n¬Hungry(joey) ::: Joey is not hungry.\nWicked(joey) ::: Joey is wicked.\n(∃x (Hungry(x) ∨ ¬Scared(x))) → ((¬Wicked(roderick) ∧ ¬Drab(rolf))) ::: If there is at least one people who is either hungry or not scared, then Roderick is not wicked and Rolf is not drab.\n(¬Scared(barry)) ↔ (¬Attractive(rolf)) ::: Barry being not scared is equivalent to Rolf being not attractive.\n(∃x (¬Drab(x))) → (¬Fat(roderick)) ::: If there is at least one people who is not drab, then Roderick is not fat.\n(¬Wicked(barry)) ↔ ((Fat(christina) ∧ Drab(roderick))) ::: Barry being not wicked is equivalent to Christina being fat and Roderick being drab.\n(∀x (¬Attractive(x) ∧ Fat(x))) → (∀x (Hungry(x))) ::: If someone who is not attractive is also fat, then he is hungry.\n(∀x (¬Hungry(x) ∧ ¬Scared(x))) ↔ (∀x (Attractive(x) ∧ ¬Fat(x))) ::: If someone is not hungry and not scared, then he is both attractive and not fat, and vice versa.\n(∀x (¬Attractive(x))) → (∀x (Hungry(x) ∧ ¬Drab(x))) ::: As long as someone is not attractive, he is hungry and not drab.\n(∀x (Drab(x) ∧ Attractive(x))) ↔ (∀x (Wicked(x) ∧ Hungry(x))) ::: If someone is drab and attractive, then he is both wicked and hungry, and vice versa.\n¬∃x(¬Hungry(x))→((Attractive(x))) ::: If there is nobody who is not hungry, then Udolf is attractive and Joey is not wicked.\n(∀x (¬Hungry(x))) → (∀x (¬Attractive(x))) ::: If someone is not hungry, then he is not attractive, and vice versa.\n(∃x (Scared(x) ∧ ¬Fat(x))) → (¬Wicked(christina)) ::: If there is at least one people who is both scared and not fat, then Christina is not wicked.\n(∃x (Fat(x) ∨ ¬Scared(x))) → (¬Wicked(roderick)) ::: If there is someone who is either fat or not scared, then Roderick is not wicked.\n",
                "First-Order-Logic Question": "¬Hungry(barry) ::: Barry is not hungry."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬Hungry(x))) → ((Attractive(udolf) ∧ ¬Wicked(joey))) ::: If there is nobody who is not hungry, then Udolf is attractive and Joey is not wicked.",
                    "gram": "¬∃x(¬Hungry(x))→((Attractive(x))) ::: If there is nobody who is not hungry, then Udolf is attractive and Joey is not wicked."
                }
            ],
            "answer": "A",
            "grammar_answer": "A",
            "backup_answer": "A"
        },
        {
            "id": 1255,
            "raw_prog": {
                "First-Order-Logic Rules": "¬Fat(barry) ::: Barry is not fat.\n¬Scared(barry) ::: Barry is not scared.\nFat(roderick) ::: Roderick is fat.\n¬Attractive(rolf) ::: Rolf is not attractive.\n¬Drab(udolf) ::: Udolf is not drab.\n¬Scared(rolf) ::: Rolf is not scared.\n¬Hungry(udolf) ::: Udolf is not hungry.\n¬Wicked(udolf) ::: Udolf is not wicked.\n¬Scared(udolf) ::: Udolf is not scared.\n¬Scared(owen) ::: Owen is not scared.\n¬Hungry(joey) ::: Joey is not hungry.\nWicked(joey) ::: Joey is wicked.\n(∃x (Hungry(x) ∨ ¬Scared(x))) → ((¬Wicked(roderick) ∧ ¬Drab(rolf))) ::: If there is at least one people who is either hungry or not scared, then Roderick is not wicked and Rolf is not drab.\n((¬Scared(barry))) ↔ ((¬Attractive(rolf))) ::: Barry being not scared is equivalent to Rolf being not attractive.\n(∃x (¬Drab(x))) → ((¬Fat(roderick))) ::: If there is at least one people who is not drab, then Roderick is not fat.\n((¬Wicked(barry))) ↔ ((Fat(christina) ∧ Drab(roderick))) ::: Barry being not wicked is equivalent to Christina being fat and Roderick being drab.\n(∀x (¬Attractive(x) ∧ Fat(x))) → (∀x (Hungry(x))) ::: If someone who is not attractive is also fat, then he is hungry.\n(∀x (¬Hungry(x) ∧ ¬Scared(x))) ↔ (∀x (Attractive(x) ∧ ¬Fat(x))) ::: If someone is not hungry and not scared, then he is both attractive and not fat, and vice versa.\n(∀x (¬Attractive(x))) → (∀x (Hungry(x) ∧ ¬Drab(x))) ::: As long as someone is not attractive, he is hungry and not drab.\n(∀x (Drab(x) ∧ Attractive(x))) ↔ (∀x (Wicked(x) ∧ Hungry(x))) ::: If someone is drab and attractive, then he is both wicked and hungry, and vice versa.\n(¬∃x (¬Hungry(x))) → ((Attractive(udolf) ∧ ¬Wicked(joey))) ::: If there is nobody who is not hungry, then Udolf is attractive and Joey is not wicked.\n(∀x (¬Hungry(x))) → (∀x (¬Attractive(x))) ::: If someone is not hungry, then he is not attractive, and vice versa.\n(∃x (Scared(x) ∧ ¬Fat(x))) → ((¬Wicked(christina))) ::: If there is at least one people who is both scared and not fat, then Christina is not wicked.\n(∃x (Fat(x) ∨ ¬Scared(x))) → ((¬Wicked(roderick))) ::: If there is someone who is either fat or not scared, then Roderick is not wicked.\n",
                "First-Order-Logic Question": "¬Fat(rolf) ::: Rolf is not fat."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "¬Fat(barry) ::: Barry is not fat.\n¬Scared(barry) ::: Barry is not scared.\nFat(roderick) ::: Roderick is fat.\n¬Attractive(rolf) ::: Rolf is not attractive.\n¬Drab(udolf) ::: Udolf is not drab.\n¬Scared(rolf) ::: Rolf is not scared.\n¬Hungry(udolf) ::: Udolf is not hungry.\n¬Wicked(udolf) ::: Udolf is not wicked.\n¬Scared(udolf) ::: Udolf is not scared.\n¬Scared(owen) ::: Owen is not scared.\n¬Hungry(joey) ::: Joey is not hungry.\nWicked(joey) ::: Joey is wicked.\n(∃x (Hungry(x) ∨ ¬Scared(x))) → ((¬Wicked(roderick) ∧ ¬Drab(rolf))) ::: If there is at least one people who is either hungry or not scared, then Roderick is not wicked and Rolf is not drab.\n((¬Scared(barry))) ↔ ((¬Attractive(rolf))) ::: Barry being not scared is equivalent to Rolf being not attractive.\n(∃x (¬Drab(x))) → ((¬Fat(roderick))) ::: If there is at least one people who is not drab, then Roderick is not fat.\n((¬Wicked(barry))) ↔ ((Fat(christina) ∧ Drab(roderick))) ::: Barry being not wicked is equivalent to Christina being fat and Roderick being drab.\n(∀x (¬Attractive(x) ∧ Fat(x))) → (∀x (Hungry(x))) ::: If someone who is not attractive is also fat, then he is hungry.\n(∀x (¬Hungry(x) ∧ ¬Scared(x))) ↔ (∀x (Attractive(x) ∧ ¬Fat(x))) ::: If someone is not hungry and not scared, then he is both attractive and not fat, and vice versa.\n(∀x (¬Attractive(x))) → (∀x (Hungry(x) ∧ ¬Drab(x))) ::: As long as someone is not attractive, he is hungry and not drab.\n(∀x (Drab(x) ∧ Attractive(x))) ↔ (∀x (Wicked(x) ∧ Hungry(x))) ::: If someone is drab and attractive, then he is both wicked and hungry, and vice versa.\n¬∃x(¬Hungry(x))→((Attractive(x))) ::: If there is nobody who is not hungry, then Udolf is attractive and Joey is not wicked.\n(∀x (¬Hungry(x))) → (∀x (¬Attractive(x))) ::: If someone is not hungry, then he is not attractive, and vice versa.\n(∃x (Scared(x) ∧ ¬Fat(x))) → ((¬Wicked(christina))) ::: If there is at least one people who is both scared and not fat, then Christina is not wicked.\n(∃x (Fat(x) ∨ ¬Scared(x))) → ((¬Wicked(roderick))) ::: If there is someone who is either fat or not scared, then Roderick is not wicked.\n",
                "First-Order-Logic Question": "¬Fat(rolf) ::: Rolf is not fat."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬Hungry(x))) → ((Attractive(udolf) ∧ ¬Wicked(joey))) ::: If there is nobody who is not hungry, then Udolf is attractive and Joey is not wicked.",
                    "gram": "¬∃x(¬Hungry(x))→((Attractive(x))) ::: If there is nobody who is not hungry, then Udolf is attractive and Joey is not wicked."
                }
            ],
            "answer": "B",
            "grammar_answer": "A",
            "backup_answer": "C"
        },
        {
            "id": 1256,
            "raw_prog": {
                "First-Order-Logic Rules": "¬Fat(barry) ::: Barry is not fat.\n¬Scared(barry) ::: Barry is not scared.\nFat(roderick) ::: Roderick is fat.\n¬Attractive(rolf) ::: Rolf is not attractive.\n¬Drab(udolf) ::: Udolf is not drab.\n¬Scared(rolf) ::: Rolf is not scared.\n¬Hungry(udolf) ::: Udolf is not hungry.\n¬Wicked(udolf) ::: Udolf is not wicked.\n¬Scared(udolf) ::: Udolf is not scared.\n¬Scared(owen) ::: Owen is not scared.\n¬Hungry(joey) ::: Joey is not hungry.\nWicked(joey) ::: Joey is wicked.\n(∃x (Hungry(x) ∨ ¬Scared(x))) → ((¬Wicked(roderick) ∧ ¬Drab(rolf))) ::: If there is at least one people who is either hungry or not scared, then Roderick is not wicked and Rolf is not drab.\n(¬Scared(barry)) ↔ (¬Attractive(rolf)) ::: Barry being not scared is equivalent to Rolf being not attractive.\n(∃x (¬Drab(x))) → (¬Fat(roderick)) ::: If there is at least one people who is not drab, then Roderick is not fat.\n(¬Wicked(barry)) ↔ ((Fat(christina) ∧ Drab(roderick))) ::: Barry being not wicked is equivalent to Christina being fat and Roderick being drab.\n(∀x (¬Attractive(x) ∧ Fat(x))) → (∀x (Hungry(x))) ::: If someone who is not attractive is also fat, then he is hungry.\n(∀x (¬Hungry(x) ∧ ¬Scared(x))) ↔ (∀x (Attractive(x) ∧ ¬Fat(x))) ::: If someone is not hungry and not scared, then he is both attractive and not fat, and vice versa.\n(∀x (¬Attractive(x))) → (∀x (Hungry(x) ∧ ¬Drab(x))) ::: As long as someone is not attractive, he is hungry and not drab.\n(∀x (Drab(x) ∧ Attractive(x))) ↔ (∀x (Wicked(x) ∧ Hungry(x))) ::: If someone is drab and attractive, then he is both wicked and hungry, and vice versa.\n(¬∃x (¬Hungry(x))) → ((Attractive(udolf) ∧ ¬Wicked(joey))) ::: If there is nobody who is not hungry, then Udolf is attractive and Joey is not wicked.\n(∀x (¬Hungry(x))) → (∀x (¬Attractive(x))) ::: If someone is not hungry, then he is not attractive, and vice versa.\n(∃x (Scared(x) ∧ ¬Fat(x))) → (¬Wicked(christina)) ::: If there is at least one people who is both scared and not fat, then Christina is not wicked.\n(∃x (Fat(x) ∨ ¬Scared(x))) → (¬Wicked(roderick)) ::: If there is someone who is either fat or not scared, then Roderick is not wicked.\n",
                "First-Order-Logic Question": "Scared(rolf) ::: Rolf is scared."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "¬Fat(barry) ::: Barry is not fat.\n¬Scared(barry) ::: Barry is not scared.\nFat(roderick) ::: Roderick is fat.\n¬Attractive(rolf) ::: Rolf is not attractive.\n¬Drab(udolf) ::: Udolf is not drab.\n¬Scared(rolf) ::: Rolf is not scared.\n¬Hungry(udolf) ::: Udolf is not hungry.\n¬Wicked(udolf) ::: Udolf is not wicked.\n¬Scared(udolf) ::: Udolf is not scared.\n¬Scared(owen) ::: Owen is not scared.\n¬Hungry(joey) ::: Joey is not hungry.\nWicked(joey) ::: Joey is wicked.\n(∃x (Hungry(x) ∨ ¬Scared(x))) → ((¬Wicked(roderick) ∧ ¬Drab(rolf))) ::: If there is at least one people who is either hungry or not scared, then Roderick is not wicked and Rolf is not drab.\n(¬Scared(barry)) ↔ (¬Attractive(rolf)) ::: Barry being not scared is equivalent to Rolf being not attractive.\n(∃x (¬Drab(x))) → (¬Fat(roderick)) ::: If there is at least one people who is not drab, then Roderick is not fat.\n(¬Wicked(barry)) ↔ ((Fat(christina) ∧ Drab(roderick))) ::: Barry being not wicked is equivalent to Christina being fat and Roderick being drab.\n(∀x (¬Attractive(x) ∧ Fat(x))) → (∀x (Hungry(x))) ::: If someone who is not attractive is also fat, then he is hungry.\n(∀x (¬Hungry(x) ∧ ¬Scared(x))) ↔ (∀x (Attractive(x) ∧ ¬Fat(x))) ::: If someone is not hungry and not scared, then he is both attractive and not fat, and vice versa.\n(∀x (¬Attractive(x))) → (∀x (Hungry(x) ∧ ¬Drab(x))) ::: As long as someone is not attractive, he is hungry and not drab.\n(∀x (Drab(x) ∧ Attractive(x))) ↔ (∀x (Wicked(x) ∧ Hungry(x))) ::: If someone is drab and attractive, then he is both wicked and hungry, and vice versa.\n¬∃x(¬Hungry(x))→((Attractive(x))) ::: If there is nobody who is not hungry, then Udolf is attractive and Joey is not wicked.\n(∀x (¬Hungry(x))) → (∀x (¬Attractive(x))) ::: If someone is not hungry, then he is not attractive, and vice versa.\n(∃x (Scared(x) ∧ ¬Fat(x))) → (¬Wicked(christina)) ::: If there is at least one people who is both scared and not fat, then Christina is not wicked.\n(∃x (Fat(x) ∨ ¬Scared(x))) → (¬Wicked(roderick)) ::: If there is someone who is either fat or not scared, then Roderick is not wicked.\n",
                "First-Order-Logic Question": "Scared(rolf) ::: Rolf is scared."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬Hungry(x))) → ((Attractive(udolf) ∧ ¬Wicked(joey))) ::: If there is nobody who is not hungry, then Udolf is attractive and Joey is not wicked.",
                    "gram": "¬∃x(¬Hungry(x))→((Attractive(x))) ::: If there is nobody who is not hungry, then Udolf is attractive and Joey is not wicked."
                }
            ],
            "answer": "C",
            "grammar_answer": "A",
            "backup_answer": "B"
        },
        {
            "id": 1257,
            "raw_prog": {
                "First-Order-Logic Rules": "¬Fat(barry) ::: Barry is not fat.\n¬Scared(barry) ::: Barry is not scared.\nFat(roderick) ::: Roderick is fat.\n¬Attractive(rolf) ::: Rolf is not attractive.\n¬Drab(udolf) ::: Udolf is not drab.\n¬Scared(rolf) ::: Rolf is not scared.\n¬Hungry(udolf) ::: Udolf is not hungry.\n¬Wicked(udolf) ::: Udolf is not wicked.\n¬Scared(udolf) ::: Udolf is not scared.\n¬Scared(owen) ::: Owen is not scared.\n¬Hungry(joey) ::: Joey is not hungry.\nWicked(joey) ::: Joey is wicked.\n(∃x (Hungry(x) ∨ ¬Scared(x))) → ((¬Wicked(roderick) ∧ ¬Drab(rolf))) ::: If there is at least one people who is either hungry or not scared, then Roderick is not wicked and Rolf is not drab.\n(¬Scared(barry)) ↔ (¬Attractive(rolf)) ::: Barry being not scared is equivalent to Rolf being not attractive.\n(∃x (¬Drab(x))) → (¬Fat(roderick)) ::: If there is at least one people who is not drab, then Roderick is not fat.\n(¬Wicked(barry)) ↔ ((Fat(christina) ∧ Drab(roderick))) ::: Barry being not wicked is equivalent to Christina being fat and Roderick being drab.\n(∀x (¬Attractive(x) ∧ Fat(x))) → (∀x (Hungry(x))) ::: If someone who is not attractive is also fat, then he is hungry.\n(∀x (¬Hungry(x) ∧ ¬Scared(x))) ↔ (∀x (Attractive(x) ∧ ¬Fat(x))) ::: If someone is not hungry and not scared, then he is both attractive and not fat, and vice versa.\n(∀x (¬Attractive(x))) → (∀x (Hungry(x) ∧ ¬Drab(x))) ::: As long as someone is not attractive, he is hungry and not drab.\n(∀x (Drab(x) ∧ Attractive(x))) ↔ (∀x (Wicked(x) ∧ Hungry(x))) ::: If someone is drab and attractive, then he is both wicked and hungry, and vice versa.\n(¬∃x (¬Hungry(x))) → ((Attractive(udolf) ∧ ¬Wicked(joey))) ::: If there is nobody who is not hungry, then Udolf is attractive and Joey is not wicked.\n(∀x (¬Hungry(x))) → (∀x (¬Attractive(x))) ::: If someone is not hungry, then he is not attractive, and vice versa.\n(∃x (Scared(x) ∧ ¬Fat(x))) → (¬Wicked(christina)) ::: If there is at least one people who is both scared and not fat, then Christina is not wicked.\n(∃x (Fat(x) ∨ ¬Scared(x))) → (¬Wicked(roderick)) ::: If there is someone who is either fat or not scared, then Roderick is not wicked.\n",
                "First-Order-Logic Question": "¬Fat(christina) ::: Christina is not fat."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "¬Fat(barry) ::: Barry is not fat.\n¬Scared(barry) ::: Barry is not scared.\nFat(roderick) ::: Roderick is fat.\n¬Attractive(rolf) ::: Rolf is not attractive.\n¬Drab(udolf) ::: Udolf is not drab.\n¬Scared(rolf) ::: Rolf is not scared.\n¬Hungry(udolf) ::: Udolf is not hungry.\n¬Wicked(udolf) ::: Udolf is not wicked.\n¬Scared(udolf) ::: Udolf is not scared.\n¬Scared(owen) ::: Owen is not scared.\n¬Hungry(joey) ::: Joey is not hungry.\nWicked(joey) ::: Joey is wicked.\n(∃x (Hungry(x) ∨ ¬Scared(x))) → ((¬Wicked(roderick) ∧ ¬Drab(rolf))) ::: If there is at least one people who is either hungry or not scared, then Roderick is not wicked and Rolf is not drab.\n(¬Scared(barry)) ↔ (¬Attractive(rolf)) ::: Barry being not scared is equivalent to Rolf being not attractive.\n(∃x (¬Drab(x))) → (¬Fat(roderick)) ::: If there is at least one people who is not drab, then Roderick is not fat.\n(¬Wicked(barry)) ↔ ((Fat(christina) ∧ Drab(roderick))) ::: Barry being not wicked is equivalent to Christina being fat and Roderick being drab.\n(∀x (¬Attractive(x) ∧ Fat(x))) → (∀x (Hungry(x))) ::: If someone who is not attractive is also fat, then he is hungry.\n(∀x (¬Hungry(x) ∧ ¬Scared(x))) ↔ (∀x (Attractive(x) ∧ ¬Fat(x))) ::: If someone is not hungry and not scared, then he is both attractive and not fat, and vice versa.\n(∀x (¬Attractive(x))) → (∀x (Hungry(x) ∧ ¬Drab(x))) ::: As long as someone is not attractive, he is hungry and not drab.\n(∀x (Drab(x) ∧ Attractive(x))) ↔ (∀x (Wicked(x) ∧ Hungry(x))) ::: If someone is drab and attractive, then he is both wicked and hungry, and vice versa.\n¬∃x(¬Hungry(x))→((Attractive(x))) ::: If there is nobody who is not hungry, then Udolf is attractive and Joey is not wicked.\n(∀x (¬Hungry(x))) → (∀x (¬Attractive(x))) ::: If someone is not hungry, then he is not attractive, and vice versa.\n(∃x (Scared(x) ∧ ¬Fat(x))) → (¬Wicked(christina)) ::: If there is at least one people who is both scared and not fat, then Christina is not wicked.\n(∃x (Fat(x) ∨ ¬Scared(x))) → (¬Wicked(roderick)) ::: If there is someone who is either fat or not scared, then Roderick is not wicked.\n",
                "First-Order-Logic Question": "¬Fat(christina) ::: Christina is not fat."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬Hungry(x))) → ((Attractive(udolf) ∧ ¬Wicked(joey))) ::: If there is nobody who is not hungry, then Udolf is attractive and Joey is not wicked.",
                    "gram": "¬∃x(¬Hungry(x))→((Attractive(x))) ::: If there is nobody who is not hungry, then Udolf is attractive and Joey is not wicked."
                }
            ],
            "answer": "C",
            "grammar_answer": "A",
            "backup_answer": "B"
        },
        {
            "id": 1258,
            "raw_prog": {
                "First-Order-Logic Rules": "¬Fat(barry) ::: Barry is not fat.\n¬Scared(barry) ::: Barry is not scared.\nFat(roderick) ::: Roderick is fat.\n¬Attractive(rolf) ::: Rolf is not attractive.\n¬Drab(udolf) ::: Udolf is not drab.\n¬Scared(rolf) ::: Rolf is not scared.\n¬Hungry(udolf) ::: Udolf is not hungry.\n¬Wicked(udolf) ::: Udolf is not wicked.\n¬Scared(udolf) ::: Udolf is not scared.\n¬Scared(owen) ::: Owen is not scared.\n¬Hungry(joey) ::: Joey is not hungry.\nWicked(joey) ::: Joey is wicked.\n(∃x (Hungry(x) ∨ ¬Scared(x))) → ((¬Wicked(roderick) ∧ ¬Drab(rolf))) ::: If there is at least one people who is either hungry or not scared, then Roderick is not wicked and Rolf is not drab.\n(¬Scared(barry)) ↔ (¬Attractive(rolf)) ::: Barry being not scared is equivalent to Rolf being not attractive.\n(∃x (¬Drab(x))) → (¬Fat(roderick)) ::: If there is at least one people who is not drab, then Roderick is not fat.\n(¬Wicked(barry)) ↔ ((Fat(christina) ∧ Drab(roderick))) ::: Barry being not wicked is equivalent to Christina being fat and Roderick being drab.\n(∀x (¬Attractive(x) ∧ Fat(x))) → (∀x (Hungry(x))) ::: If someone who is not attractive is also fat, then he is hungry.\n(∀x (¬Hungry(x) ∧ ¬Scared(x))) ↔ (∀x (Attractive(x) ∧ ¬Fat(x))) ::: If someone is not hungry and not scared, then he is both attractive and not fat, and vice versa.\n(∀x (¬Attractive(x))) → (∀x (Hungry(x) ∧ ¬Drab(x))) ::: As long as someone is not attractive, he is hungry and not drab.\n(∀x (Drab(x) ∧ Attractive(x))) ↔ (∀x (Wicked(x) ∧ Hungry(x))) ::: If someone is drab and attractive, then he is both wicked and hungry, and vice versa.\n(¬∃x (¬Hungry(x))) → ((Attractive(udolf) ∧ ¬Wicked(joey))) ::: If there is nobody who is not hungry, then Udolf is attractive and Joey is not wicked.\n(∀x (¬Hungry(x))) → (∀x (¬Attractive(x))) ::: If someone is not hungry, then he is not attractive, and vice versa.\n(∃x (Scared(x) ∧ ¬Fat(x))) → (¬Wicked(christina)) ::: If there is at least one people who is both scared and not fat, then Christina is not wicked.\n(∃x (Fat(x) ∨ ¬Scared(x))) → (¬Wicked(roderick)) ::: If there is someone who is either fat or not scared, then Roderick is not wicked.\n",
                "First-Order-Logic Question": "¬Attractive(christina) ::: Christina is not attractive."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "¬Fat(barry) ::: Barry is not fat.\n¬Scared(barry) ::: Barry is not scared.\nFat(roderick) ::: Roderick is fat.\n¬Attractive(rolf) ::: Rolf is not attractive.\n¬Drab(udolf) ::: Udolf is not drab.\n¬Scared(rolf) ::: Rolf is not scared.\n¬Hungry(udolf) ::: Udolf is not hungry.\n¬Wicked(udolf) ::: Udolf is not wicked.\n¬Scared(udolf) ::: Udolf is not scared.\n¬Scared(owen) ::: Owen is not scared.\n¬Hungry(joey) ::: Joey is not hungry.\nWicked(joey) ::: Joey is wicked.\n(∃x (Hungry(x) ∨ ¬Scared(x))) → ((¬Wicked(roderick) ∧ ¬Drab(rolf))) ::: If there is at least one people who is either hungry or not scared, then Roderick is not wicked and Rolf is not drab.\n(¬Scared(barry)) ↔ (¬Attractive(rolf)) ::: Barry being not scared is equivalent to Rolf being not attractive.\n(∃x (¬Drab(x))) → (¬Fat(roderick)) ::: If there is at least one people who is not drab, then Roderick is not fat.\n(¬Wicked(barry)) ↔ ((Fat(christina) ∧ Drab(roderick))) ::: Barry being not wicked is equivalent to Christina being fat and Roderick being drab.\n(∀x (¬Attractive(x) ∧ Fat(x))) → (∀x (Hungry(x))) ::: If someone who is not attractive is also fat, then he is hungry.\n(∀x (¬Hungry(x) ∧ ¬Scared(x))) ↔ (∀x (Attractive(x) ∧ ¬Fat(x))) ::: If someone is not hungry and not scared, then he is both attractive and not fat, and vice versa.\n(∀x (¬Attractive(x))) → (∀x (Hungry(x) ∧ ¬Drab(x))) ::: As long as someone is not attractive, he is hungry and not drab.\n(∀x (Drab(x) ∧ Attractive(x))) ↔ (∀x (Wicked(x) ∧ Hungry(x))) ::: If someone is drab and attractive, then he is both wicked and hungry, and vice versa.\n¬∃x(¬Hungry(x))→((Attractive(x))) ::: If there is nobody who is not hungry, then Udolf is attractive and Joey is not wicked.\n(∀x (¬Hungry(x))) → (∀x (¬Attractive(x))) ::: If someone is not hungry, then he is not attractive, and vice versa.\n(∃x (Scared(x) ∧ ¬Fat(x))) → (¬Wicked(christina)) ::: If there is at least one people who is both scared and not fat, then Christina is not wicked.\n(∃x (Fat(x) ∨ ¬Scared(x))) → (¬Wicked(roderick)) ::: If there is someone who is either fat or not scared, then Roderick is not wicked.\n",
                "First-Order-Logic Question": "¬Attractive(christina) ::: Christina is not attractive."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬Hungry(x))) → ((Attractive(udolf) ∧ ¬Wicked(joey))) ::: If there is nobody who is not hungry, then Udolf is attractive and Joey is not wicked.",
                    "gram": "¬∃x(¬Hungry(x))→((Attractive(x))) ::: If there is nobody who is not hungry, then Udolf is attractive and Joey is not wicked."
                }
            ],
            "answer": "C",
            "grammar_answer": "A",
            "backup_answer": "C"
        },
        {
            "id": 1259,
            "raw_prog": {
                "First-Order-Logic Rules": "¬Fat(barry) ::: Barry is not fat.\n¬Scared(barry) ::: Barry is not scared.\nFat(roderick) ::: Roderick is fat.\n¬Attractive(rolf) ::: Rolf is not attractive.\n¬Drab(udolf) ::: Udolf is not drab.\n¬Scared(rolf) ::: Rolf is not scared.\n¬Hungry(udolf) ::: Udolf is not hungry.\n¬Wicked(udolf) ::: Udolf is not wicked.\n¬Scared(udolf) ::: Udolf is not scared.\n¬Scared(owen) ::: Owen is not scared.\n¬Hungry(joey) ::: Joey is not hungry.\nWicked(joey) ::: Joey is wicked.\n(∃x (Hungry(x) ∨ ¬Scared(x))) → ((¬Wicked(roderick) ∧ ¬Drab(rolf))) ::: If there is at least one people who is either hungry or not scared, then Roderick is not wicked and Rolf is not drab.\n(¬Scared(barry)) ↔ (¬Attractive(rolf)) ::: Barry being not scared is equivalent to Rolf being not attractive.\n(∃x (¬Drab(x))) → (¬Fat(roderick)) ::: If there is at least one people who is not drab, then Roderick is not fat.\n(¬Wicked(barry)) ↔ ((Fat(christina) ∧ Drab(roderick))) ::: Barry being not wicked is equivalent to Christina being fat and Roderick being drab.\n(∀x (¬Attractive(x) ∧ Fat(x))) → (∀x (Hungry(x))) ::: If someone who is not attractive is also fat, then he is hungry.\n(∀x (¬Hungry(x) ∧ ¬Scared(x))) ↔ (∀x (Attractive(x) ∧ ¬Fat(x))) ::: If someone is not hungry and not scared, then he is both attractive and not fat, and vice versa.\n(∀x (¬Attractive(x))) → (∀x (Hungry(x) ∧ ¬Drab(x))) ::: As long as someone is not attractive, he is hungry and not drab.\n(∀x (Drab(x) ∧ Attractive(x))) ↔ (∀x (Wicked(x) ∧ Hungry(x))) ::: If someone is drab and attractive, then he is both wicked and hungry, and vice versa.\n(¬∃x (¬Hungry(x))) → ((Attractive(udolf) ∧ ¬Wicked(joey))) ::: If there is nobody who is not hungry, then Udolf is attractive and Joey is not wicked.\n(∀x (¬Hungry(x))) → (∀x (¬Attractive(x))) ::: If someone is not hungry, then he is not attractive, and vice versa.\n(∃x (Scared(x) ∧ ¬Fat(x))) → (¬Wicked(christina)) ::: If there is at least one people who is both scared and not fat, then Christina is not wicked.\n(∃x (Fat(x) ∨ ¬Scared(x))) → (¬Wicked(roderick)) ::: If there is someone who is either fat or not scared, then Roderick is not wicked.\n",
                "First-Order-Logic Question": "¬Scared(christina) ::: Christina is not scared."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "¬Fat(barry) ::: Barry is not fat.\n¬Scared(barry) ::: Barry is not scared.\nFat(roderick) ::: Roderick is fat.\n¬Attractive(rolf) ::: Rolf is not attractive.\n¬Drab(udolf) ::: Udolf is not drab.\n¬Scared(rolf) ::: Rolf is not scared.\n¬Hungry(udolf) ::: Udolf is not hungry.\n¬Wicked(udolf) ::: Udolf is not wicked.\n¬Scared(udolf) ::: Udolf is not scared.\n¬Scared(owen) ::: Owen is not scared.\n¬Hungry(joey) ::: Joey is not hungry.\nWicked(joey) ::: Joey is wicked.\n(∃x (Hungry(x) ∨ ¬Scared(x))) → ((¬Wicked(roderick) ∧ ¬Drab(rolf))) ::: If there is at least one people who is either hungry or not scared, then Roderick is not wicked and Rolf is not drab.\n(¬Scared(barry)) ↔ (¬Attractive(rolf)) ::: Barry being not scared is equivalent to Rolf being not attractive.\n(∃x (¬Drab(x))) → (¬Fat(roderick)) ::: If there is at least one people who is not drab, then Roderick is not fat.\n(¬Wicked(barry)) ↔ ((Fat(christina) ∧ Drab(roderick))) ::: Barry being not wicked is equivalent to Christina being fat and Roderick being drab.\n(∀x (¬Attractive(x) ∧ Fat(x))) → (∀x (Hungry(x))) ::: If someone who is not attractive is also fat, then he is hungry.\n(∀x (¬Hungry(x) ∧ ¬Scared(x))) ↔ (∀x (Attractive(x) ∧ ¬Fat(x))) ::: If someone is not hungry and not scared, then he is both attractive and not fat, and vice versa.\n(∀x (¬Attractive(x))) → (∀x (Hungry(x) ∧ ¬Drab(x))) ::: As long as someone is not attractive, he is hungry and not drab.\n(∀x (Drab(x) ∧ Attractive(x))) ↔ (∀x (Wicked(x) ∧ Hungry(x))) ::: If someone is drab and attractive, then he is both wicked and hungry, and vice versa.\n¬∃x(¬Hungry(x))→((Attractive(x))) ::: If there is nobody who is not hungry, then Udolf is attractive and Joey is not wicked.\n(∀x (¬Hungry(x))) → (∀x (¬Attractive(x))) ::: If someone is not hungry, then he is not attractive, and vice versa.\n(∃x (Scared(x) ∧ ¬Fat(x))) → (¬Wicked(christina)) ::: If there is at least one people who is both scared and not fat, then Christina is not wicked.\n(∃x (Fat(x) ∨ ¬Scared(x))) → (¬Wicked(roderick)) ::: If there is someone who is either fat or not scared, then Roderick is not wicked.\n",
                "First-Order-Logic Question": "¬Scared(christina) ::: Christina is not scared."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬Hungry(x))) → ((Attractive(udolf) ∧ ¬Wicked(joey))) ::: If there is nobody who is not hungry, then Udolf is attractive and Joey is not wicked.",
                    "gram": "¬∃x(¬Hungry(x))→((Attractive(x))) ::: If there is nobody who is not hungry, then Udolf is attractive and Joey is not wicked."
                }
            ],
            "answer": "A",
            "grammar_answer": "A",
            "backup_answer": "C"
        }
    ],
    "outputs_2": [
        {
            "id": 120,
            "raw_prog": {
                "First-Order-Logic Rules": "¬Hungry(gregory) ::: Gregory is not hungry.\nMushy(ronald) ::: Ronald is mushy.\nTeak(keith) ::: Keith is teak.\nPoised(crosby) ::: Crosby is poised.\nFrank(shane) ::: Shane is frank.\nPoised(gregory) ::: Gregory is poised.\n¬Poised(shane) ::: Shane is not poised.\nMushy(keith) ::: Keith is mushy.\n¬Frank(noel) ::: Noel is not frank.\nFrank(george) ::: George is frank.\nWicked(george) ::: George is wicked.\nFrank(keith) ::: Keith is frank.\n(∀x (Mushy(x) ∨ ¬Poised(x))) → (∀x (Hungry(x) ∧ ¬Wicked(x))) ::: If someone is either mushy or not poised, then he is hungry and not wicked.\n(¬Poised(gregory)) → (Mushy(shane)) ::: If Gregory is not poised, then Shane is mushy.\n(∃x (Wicked(x))) → ((¬Poised(shane) ∧ ¬Frank(george))) ::: If there is at least one people who is wicked, then Shane is not poised and George is not frank.\n((Teak(noel))) ↔ ((¬Poised(noel))) ::: If Noel is teak, then Noel is not poised, and vice versa.\n(∀x (¬x)) → ((Teak(shane) ∧ ¬Poised(shane))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised.\n(∀x (Wicked(x) ∧ Mushy(x))) ↔ (∀x (Poised(x))) ::: Someone is wicked and mushy if and only if he is poised.\n(∃x (Poised(x) ∨ ¬Hungry(x))) → ((¬Mushy(george))) ::: If there is at least one people who is poised or not hungry, then George is not mushy.\n(∃x (Wicked(x) ∧ ¬Teak(x))) → ((Poised(crosby))) ::: If there is at least one people who is both wicked and not teak, then Crosby is poised.\n((Teak(keith))) ↔ ((¬Poised(gregory) ∧ ¬Wicked(noel))) ::: Keith is teak if and only if Gregory is not poised and Noel is not wicked.\n((Teak(noel))) ↔ ((Hungry(shane))) ::: Noel is teak if and only if Shane is hungry.\n((¬Teak(gregory) ∧ Wicked(crosby))) → ((¬Mushy(keith))) ::: If Gregory is not teak and Crosby is wicked, then Keith is not mushy.\n(∃x (Hungry(x) ∧ Wicked(x))) → ((Teak(noel))) ::: If there is at least one people who is both hungry and wicked, then Noel is teak.\n",
                "First-Order-Logic Question": "¬Mushy(noel) ::: Noel is not mushy."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "¬Hungry(gregory) ::: Gregory is not hungry.\nMushy(ronald) ::: Ronald is mushy.\nTeak(keith) ::: Keith is teak.\nPoised(crosby) ::: Crosby is poised.\nFrank(shane) ::: Shane is frank.\nPoised(gregory) ::: Gregory is poised.\n¬Poised(shane) ::: Shane is not poised.\nMushy(keith) ::: Keith is mushy.\n¬Frank(noel) ::: Noel is not frank.\nFrank(george) ::: George is frank.\nWicked(george) ::: George is wicked.\nFrank(keith) ::: Keith is frank.\n(∀x (Mushy(x) ∨ ¬Poised(x))) → (∀x (Hungry(x) ∧ ¬Wicked(x))) ::: If someone is either mushy or not poised, then he is hungry and not wicked.\n(¬Poised(gregory)) → (Mushy(shane)) ::: If Gregory is not poised, then Shane is mushy.\n(∃x (Wicked(x))) → ((¬Poised(shane) ∧ ¬Frank(george))) ::: If there is at least one people who is wicked, then Shane is not poised and George is not frank.\n((Teak(noel))) ↔ ((¬Poised(noel))) ::: If Noel is teak, then Noel is not poised, and vice versa.\n¬(Hungry(x))→((Teak(x))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised.\n(∀x (Wicked(x) ∧ Mushy(x))) ↔ (∀x (Poised(x))) ::: Someone is wicked and mushy if and only if he is poised.\n(∃x (Poised(x) ∨ ¬Hungry(x))) → ((¬Mushy(george))) ::: If there is at least one people who is poised or not hungry, then George is not mushy.\n(∃x (Wicked(x) ∧ ¬Teak(x))) → ((Poised(crosby))) ::: If there is at least one people who is both wicked and not teak, then Crosby is poised.\n((Teak(keith))) ↔ ((¬Poised(gregory) ∧ ¬Wicked(noel))) ::: Keith is teak if and only if Gregory is not poised and Noel is not wicked.\n((Teak(noel))) ↔ ((Hungry(shane))) ::: Noel is teak if and only if Shane is hungry.\n((¬Teak(gregory) ∧ Wicked(crosby))) → ((¬Mushy(keith))) ::: If Gregory is not teak and Crosby is wicked, then Keith is not mushy.\n(∃x (Hungry(x) ∧ Wicked(x))) → ((Teak(noel))) ::: If there is at least one people who is both hungry and wicked, then Noel is teak.\n",
                "First-Order-Logic Question": "¬Mushy(noel) ::: Noel is not mushy."
            },
            "diff": [
                {
                    "raw": "(∀x (¬x)) → ((Teak(shane) ∧ ¬Poised(shane))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised.",
                    "gram": "¬(Hungry(x))→((Teak(x))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised."
                }
            ],
            "answer": "C",
            "grammar_answer": "A",
            "backup_answer": "C"
        },
        {
            "id": 121,
            "raw_prog": {
                "First-Order-Logic Rules": "¬Hungry(gregory) ::: Gregory is not hungry.\nMushy(ronald) ::: Ronald is mushy.\nTeak(keith) ::: Keith is teak.\nPoised(crosby) ::: Crosby is poised.\nFrank(shane) ::: Shane is frank.\nPoised(gregory) ::: Gregory is poised.\n¬Poised(shane) ::: Shane is not poised.\nMushy(keith) ::: Keith is mushy.\n¬Frank(noel) ::: Noel is not frank.\nFrank(george) ::: George is frank.\nWicked(george) ::: George is wicked.\nFrank(keith) ::: Keith is frank.\n(∀x (Mushy(x) ∨ ¬Poised(x))) → (∀x (Hungry(x) ∧ ¬Wicked(x))) ::: If someone is either mushy or not poised, then he is hungry and not wicked.\n(¬Poised(gregory)) → (Mushy(shane)) ::: If Gregory is not poised, then Shane is mushy.\n(∃x (Wicked(x))) → ((¬Poised(shane) ∧ ¬Frank(george))) ::: If there is at least one people who is wicked, then Shane is not poised and George is not frank.\n((Teak(noel))) ↔ ((¬Poised(noel))) ::: If Noel is teak, then Noel is not poised, and vice versa.\n(¬∃x (¬x)) → ((Teak(shane) ∧ ¬Poised(shane))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised.\n(∀x (Wicked(x) ∧ Mushy(x))) ↔ (∀x (Poised(x))) ::: Someone is wicked and mushy if and only if he is poised.\n(∃x (Poised(x) ∨ ¬Hungry(x))) → ((¬Mushy(george))) ::: If there is at least one people who is poised or not hungry, then George is not mushy.\n(∃x (Wicked(x) ∧ ¬Teak(x))) → ((Poised(crosby))) ::: If there is at least one people who is both wicked and not teak, then Crosby is poised.\n((Teak(keith))) ↔ ((¬Poised(gregory) ∧ ¬Wicked(noel))) ::: Keith is teak if and only if Gregory is not poised and Noel is not wicked.\n((Teak(noel))) ↔ ((Hungry(shane))) ::: Noel is teak if and only if Shane is hungry.\n((¬Teak(gregory) ∧ Wicked(crosby))) → ((¬Mushy(keith))) ::: If Gregory is not teak and Crosby is wicked, then Keith is not mushy.\n(∃x (Hungry(x) ∧ Wicked(x))) → ((Teak(noel))) ::: If there is at least one people who is both hungry and wicked, then Noel is teak.\n",
                "First-Order-Logic Question": "¬Mushy(shane) ::: Shane is not mushy."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "¬Hungry(gregory) ::: Gregory is not hungry.\nMushy(ronald) ::: Ronald is mushy.\nTeak(keith) ::: Keith is teak.\nPoised(crosby) ::: Crosby is poised.\nFrank(shane) ::: Shane is frank.\nPoised(gregory) ::: Gregory is poised.\n¬Poised(shane) ::: Shane is not poised.\nMushy(keith) ::: Keith is mushy.\n¬Frank(noel) ::: Noel is not frank.\nFrank(george) ::: George is frank.\nWicked(george) ::: George is wicked.\nFrank(keith) ::: Keith is frank.\n(∀x (Mushy(x) ∨ ¬Poised(x))) → (∀x (Hungry(x) ∧ ¬Wicked(x))) ::: If someone is either mushy or not poised, then he is hungry and not wicked.\n(¬Poised(gregory)) → (Mushy(shane)) ::: If Gregory is not poised, then Shane is mushy.\n(∃x (Wicked(x))) → ((¬Poised(shane) ∧ ¬Frank(george))) ::: If there is at least one people who is wicked, then Shane is not poised and George is not frank.\n((Teak(noel))) ↔ ((¬Poised(noel))) ::: If Noel is teak, then Noel is not poised, and vice versa.\n¬∃x((¬(¬Frank(x)))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised.\n(∀x (Wicked(x) ∧ Mushy(x))) ↔ (∀x (Poised(x))) ::: Someone is wicked and mushy if and only if he is poised.\n(∃x (Poised(x) ∨ ¬Hungry(x))) → ((¬Mushy(george))) ::: If there is at least one people who is poised or not hungry, then George is not mushy.\n(∃x (Wicked(x) ∧ ¬Teak(x))) → ((Poised(crosby))) ::: If there is at least one people who is both wicked and not teak, then Crosby is poised.\n((Teak(keith))) ↔ ((¬Poised(gregory) ∧ ¬Wicked(noel))) ::: Keith is teak if and only if Gregory is not poised and Noel is not wicked.\n((Teak(noel))) ↔ ((Hungry(shane))) ::: Noel is teak if and only if Shane is hungry.\n((¬Teak(gregory) ∧ Wicked(crosby))) → ((¬Mushy(keith))) ::: If Gregory is not teak and Crosby is wicked, then Keith is not mushy.\n(∃x (Hungry(x) ∧ Wicked(x))) → ((Teak(noel))) ::: If there is at least one people who is both hungry and wicked, then Noel is teak.\n",
                "First-Order-Logic Question": "¬Mushy(shane) ::: Shane is not mushy."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬x)) → ((Teak(shane) ∧ ¬Poised(shane))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised.",
                    "gram": "¬∃x((¬(¬Frank(x)))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised."
                }
            ],
            "answer": "B",
            "grammar_answer": "A",
            "backup_answer": "A"
        },
        {
            "id": 122,
            "raw_prog": {
                "First-Order-Logic Rules": "¬Hungry(gregory) ::: Gregory is not hungry.\nMushy(ronald) ::: Ronald is mushy.\nTeak(keith) ::: Keith is teak.\nPoised(crosby) ::: Crosby is poised.\nFrank(shane) ::: Shane is frank.\nPoised(gregory) ::: Gregory is poised.\n¬Poised(shane) ::: Shane is not poised.\nMushy(keith) ::: Keith is mushy.\n¬Frank(noel) ::: Noel is not frank.\nFrank(george) ::: George is frank.\nWicked(george) ::: George is wicked.\nFrank(keith) ::: Keith is frank.\n(∀x (Mushy(x) ∨ ¬Poised(x))) → (∀x (Hungry(x) ∧ ¬Wicked(x))) ::: If someone is either mushy or not poised, then he is hungry and not wicked.\n(¬Poised(gregory)) → (Mushy(shane)) ::: If Gregory is not poised, then Shane is mushy.\n(∃x (Wicked(x))) → ((¬Poised(shane) ∧ ¬Frank(george))) ::: If there is at least one people who is wicked, then Shane is not poised and George is not frank.\n((Teak(noel))) ↔ ((¬Poised(noel))) ::: If Noel is teak, then Noel is not poised, and vice versa.\n(¬∃x (¬x)) → ((Teak(shane) ∧ ¬Poised(shane))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised.\n(∀x (Wicked(x) ∧ Mushy(x))) ↔ (∀x (Poised(x))) ::: Someone is wicked and mushy if and only if he is poised.\n(∃x (Poised(x) ∨ ¬Hungry(x))) → ((¬Mushy(george))) ::: If there is at least one people who is poised or not hungry, then George is not mushy.\n(∃x (Wicked(x) ∧ ¬Teak(x))) → ((Poised(crosby))) ::: If there is at least one people who is both wicked and not teak, then Crosby is poised.\n((Teak(keith))) ↔ ((¬Poised(gregory) ∧ ¬Wicked(noel))) ::: Keith is teak if and only if Gregory is not poised and Noel is not wicked.\n((Teak(noel))) ↔ ((Hungry(shane))) ::: Noel is teak if and only if Shane is hungry.\n((¬Teak(gregory) ∧ Wicked(crosby))) → ((¬Mushy(keith))) ::: If Gregory is not teak and Crosby is wicked, then Keith is not mushy.\n(∃x (Hungry(x) ∧ Wicked(x))) → ((Teak(noel))) ::: If there is at least one people who is both hungry and wicked, then Noel is teak.\n",
                "First-Order-Logic Question": "Hungry(crosby) ::: Crosby is hungry."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "¬Hungry(gregory) ::: Gregory is not hungry.\nMushy(ronald) ::: Ronald is mushy.\nTeak(keith) ::: Keith is teak.\nPoised(crosby) ::: Crosby is poised.\nFrank(shane) ::: Shane is frank.\nPoised(gregory) ::: Gregory is poised.\n¬Poised(shane) ::: Shane is not poised.\nMushy(keith) ::: Keith is mushy.\n¬Frank(noel) ::: Noel is not frank.\nFrank(george) ::: George is frank.\nWicked(george) ::: George is wicked.\nFrank(keith) ::: Keith is frank.\n(∀x (Mushy(x) ∨ ¬Poised(x))) → (∀x (Hungry(x) ∧ ¬Wicked(x))) ::: If someone is either mushy or not poised, then he is hungry and not wicked.\n(¬Poised(gregory)) → (Mushy(shane)) ::: If Gregory is not poised, then Shane is mushy.\n(∃x (Wicked(x))) → ((¬Poised(shane) ∧ ¬Frank(george))) ::: If there is at least one people who is wicked, then Shane is not poised and George is not frank.\n((Teak(noel))) ↔ ((¬Poised(noel))) ::: If Noel is teak, then Noel is not poised, and vice versa.\n¬∃x((¬(¬Frank(x)))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised.\n(∀x (Wicked(x) ∧ Mushy(x))) ↔ (∀x (Poised(x))) ::: Someone is wicked and mushy if and only if he is poised.\n(∃x (Poised(x) ∨ ¬Hungry(x))) → ((¬Mushy(george))) ::: If there is at least one people who is poised or not hungry, then George is not mushy.\n(∃x (Wicked(x) ∧ ¬Teak(x))) → ((Poised(crosby))) ::: If there is at least one people who is both wicked and not teak, then Crosby is poised.\n((Teak(keith))) ↔ ((¬Poised(gregory) ∧ ¬Wicked(noel))) ::: Keith is teak if and only if Gregory is not poised and Noel is not wicked.\n((Teak(noel))) ↔ ((Hungry(shane))) ::: Noel is teak if and only if Shane is hungry.\n((¬Teak(gregory) ∧ Wicked(crosby))) → ((¬Mushy(keith))) ::: If Gregory is not teak and Crosby is wicked, then Keith is not mushy.\n(∃x (Hungry(x) ∧ Wicked(x))) → ((Teak(noel))) ::: If there is at least one people who is both hungry and wicked, then Noel is teak.\n",
                "First-Order-Logic Question": "Hungry(crosby) ::: Crosby is hungry."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬x)) → ((Teak(shane) ∧ ¬Poised(shane))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised.",
                    "gram": "¬∃x((¬(¬Frank(x)))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised."
                }
            ],
            "answer": "A",
            "grammar_answer": "A",
            "backup_answer": "B"
        },
        {
            "id": 123,
            "raw_prog": {
                "First-Order-Logic Rules": "¬Hungry(gregory) ::: Gregory is not hungry.\nMushy(ronald) ::: Ronald is mushy.\nTeak(keith) ::: Keith is teak.\nPoised(crosby) ::: Crosby is poised.\nFrank(shane) ::: Shane is frank.\nPoised(gregory) ::: Gregory is poised.\n¬Poised(shane) ::: Shane is not poised.\nMushy(keith) ::: Keith is mushy.\n¬Frank(noel) ::: Noel is not frank.\nFrank(george) ::: George is frank.\nWicked(george) ::: George is wicked.\nFrank(keith) ::: Keith is frank.\n(∀x (Mushy(x) ∨ ¬Poised(x))) → (∀x (Hungry(x) ∧ ¬Wicked(x))) ::: If someone is either mushy or not poised, then he is hungry and not wicked.\n(¬Poised(gregory)) → (Mushy(shane)) ::: If Gregory is not poised, then Shane is mushy.\n(∃x (Wicked(x))) → ((¬Poised(shane) ∧ ¬Frank(george))) ::: If there is at least one people who is wicked, then Shane is not poised and George is not frank.\n((Teak(noel))) ↔ ((¬Poised(noel))) ::: If Noel is teak, then Noel is not poised, and vice versa.\n(¬∃x (¬x)) → ((Teak(shane) ∧ ¬Poised(shane))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised.\n(∀x (Wicked(x) ∧ Mushy(x))) ↔ (∀x (Poised(x))) ::: Someone is wicked and mushy if and only if he is poised.\n(∃x (Poised(x) ∨ ¬Hungry(x))) → ((¬Mushy(george))) ::: If there is at least one people who is poised or not hungry, then George is not mushy.\n(∃x (Wicked(x) ∧ ¬Teak(x))) → ((Poised(crosby))) ::: If there is at least one people who is both wicked and not teak, then Crosby is poised.\n((Teak(keith))) ↔ ((¬Poised(gregory) ∧ ¬Wicked(noel))) ::: Keith is teak if and only if Gregory is not poised and Noel is not wicked.\n((Teak(noel))) ↔ ((Hungry(shane))) ::: Noel is teak if and only if Shane is hungry.\n((¬Teak(gregory) ∧ Wicked(crosby))) → ((¬Mushy(keith))) ::: If Gregory is not teak and Crosby is wicked, then Keith is not mushy.\n(∃x (Hungry(x) ∧ Wicked(x))) → ((Teak(noel))) ::: If there is at least one people who is both hungry and wicked, then Noel is teak.\n",
                "First-Order-Logic Question": "¬Wicked(shane) ::: Shane is not wicked."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "¬Hungry(gregory) ::: Gregory is not hungry.\nMushy(ronald) ::: Ronald is mushy.\nTeak(keith) ::: Keith is teak.\nPoised(crosby) ::: Crosby is poised.\nFrank(shane) ::: Shane is frank.\nPoised(gregory) ::: Gregory is poised.\n¬Poised(shane) ::: Shane is not poised.\nMushy(keith) ::: Keith is mushy.\n¬Frank(noel) ::: Noel is not frank.\nFrank(george) ::: George is frank.\nWicked(george) ::: George is wicked.\nFrank(keith) ::: Keith is frank.\n(∀x (Mushy(x) ∨ ¬Poised(x))) → (∀x (Hungry(x) ∧ ¬Wicked(x))) ::: If someone is either mushy or not poised, then he is hungry and not wicked.\n(¬Poised(gregory)) → (Mushy(shane)) ::: If Gregory is not poised, then Shane is mushy.\n(∃x (Wicked(x))) → ((¬Poised(shane) ∧ ¬Frank(george))) ::: If there is at least one people who is wicked, then Shane is not poised and George is not frank.\n((Teak(noel))) ↔ ((¬Poised(noel))) ::: If Noel is teak, then Noel is not poised, and vice versa.\n¬∃x((¬(¬Frank(x)))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised.\n(∀x (Wicked(x) ∧ Mushy(x))) ↔ (∀x (Poised(x))) ::: Someone is wicked and mushy if and only if he is poised.\n(∃x (Poised(x) ∨ ¬Hungry(x))) → ((¬Mushy(george))) ::: If there is at least one people who is poised or not hungry, then George is not mushy.\n(∃x (Wicked(x) ∧ ¬Teak(x))) → ((Poised(crosby))) ::: If there is at least one people who is both wicked and not teak, then Crosby is poised.\n((Teak(keith))) ↔ ((¬Poised(gregory) ∧ ¬Wicked(noel))) ::: Keith is teak if and only if Gregory is not poised and Noel is not wicked.\n((Teak(noel))) ↔ ((Hungry(shane))) ::: Noel is teak if and only if Shane is hungry.\n((¬Teak(gregory) ∧ Wicked(crosby))) → ((¬Mushy(keith))) ::: If Gregory is not teak and Crosby is wicked, then Keith is not mushy.\n(∃x (Hungry(x) ∧ Wicked(x))) → ((Teak(noel))) ::: If there is at least one people who is both hungry and wicked, then Noel is teak.\n",
                "First-Order-Logic Question": "¬Wicked(shane) ::: Shane is not wicked."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬x)) → ((Teak(shane) ∧ ¬Poised(shane))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised.",
                    "gram": "¬∃x((¬(¬Frank(x)))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised."
                }
            ],
            "answer": "A",
            "grammar_answer": "A",
            "backup_answer": "A"
        },
        {
            "id": 124,
            "raw_prog": {
                "First-Order-Logic Rules": "¬Hungry(gregory) ::: Gregory is not hungry.\nMushy(ronald) ::: Ronald is mushy.\nTeak(keith) ::: Keith is teak.\nPoised(crosby) ::: Crosby is poised.\nFrank(shane) ::: Shane is frank.\nPoised(gregory) ::: Gregory is poised.\n¬Poised(shane) ::: Shane is not poised.\nMushy(keith) ::: Keith is mushy.\n¬Frank(noel) ::: Noel is not frank.\nFrank(george) ::: George is frank.\nWicked(george) ::: George is wicked.\nFrank(keith) ::: Keith is frank.\n(∀x (Mushy(x) ∨ ¬Poised(x))) → (∀x (Hungry(x) ∧ ¬Wicked(x))) ::: If someone is either mushy or not poised, then he is hungry and not wicked.\n(¬Poised(gregory)) → (Mushy(shane)) ::: If Gregory is not poised, then Shane is mushy.\n(∃x (Wicked(x))) → ((¬Poised(shane) ∧ ¬Frank(george))) ::: If there is at least one people who is wicked, then Shane is not poised and George is not frank.\n((Teak(noel))) ↔ ((¬Poised(noel))) ::: If Noel is teak, then Noel is not poised, and vice versa.\n(¬∃x (¬x)) → ((Teak(shane) ∧ ¬Poised(shane))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised.\n(∀x (Wicked(x) ∧ Mushy(x))) ↔ (∀x (Poised(x))) ::: Someone is wicked and mushy if and only if he is poised.\n(∃x (Poised(x) ∨ ¬Hungry(x))) → ((¬Mushy(george))) ::: If there is at least one people who is poised or not hungry, then George is not mushy.\n(∃x (Wicked(x) ∧ ¬Teak(x))) → ((Poised(crosby))) ::: If there is at least one people who is both wicked and not teak, then Crosby is poised.\n((Teak(keith))) ↔ ((¬Poised(gregory) ∧ ¬Wicked(noel))) ::: Keith is teak if and only if Gregory is not poised and Noel is not wicked.\n((Teak(noel))) ↔ ((Hungry(shane))) ::: Noel is teak if and only if Shane is hungry.\n((¬Teak(gregory) ∧ Wicked(crosby))) → ((¬Mushy(keith))) ::: If Gregory is not teak and Crosby is wicked, then Keith is not mushy.\n(∃x (Hungry(x) ∧ Wicked(x))) → ((Teak(noel))) ::: If there is at least one people who is both hungry and wicked, then Noel is teak.\n",
                "First-Order-Logic Question": "¬Hungry(shane) ::: Shane is not hungry."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "¬Hungry(gregory) ::: Gregory is not hungry.\nMushy(ronald) ::: Ronald is mushy.\nTeak(keith) ::: Keith is teak.\nPoised(crosby) ::: Crosby is poised.\nFrank(shane) ::: Shane is frank.\nPoised(gregory) ::: Gregory is poised.\n¬Poised(shane) ::: Shane is not poised.\nMushy(keith) ::: Keith is mushy.\n¬Frank(noel) ::: Noel is not frank.\nFrank(george) ::: George is frank.\nWicked(george) ::: George is wicked.\nFrank(keith) ::: Keith is frank.\n(∀x (Mushy(x) ∨ ¬Poised(x))) → (∀x (Hungry(x) ∧ ¬Wicked(x))) ::: If someone is either mushy or not poised, then he is hungry and not wicked.\n(¬Poised(gregory)) → (Mushy(shane)) ::: If Gregory is not poised, then Shane is mushy.\n(∃x (Wicked(x))) → ((¬Poised(shane) ∧ ¬Frank(george))) ::: If there is at least one people who is wicked, then Shane is not poised and George is not frank.\n((Teak(noel))) ↔ ((¬Poised(noel))) ::: If Noel is teak, then Noel is not poised, and vice versa.\n¬∃x((¬(¬Frank(x)))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised.\n(∀x (Wicked(x) ∧ Mushy(x))) ↔ (∀x (Poised(x))) ::: Someone is wicked and mushy if and only if he is poised.\n(∃x (Poised(x) ∨ ¬Hungry(x))) → ((¬Mushy(george))) ::: If there is at least one people who is poised or not hungry, then George is not mushy.\n(∃x (Wicked(x) ∧ ¬Teak(x))) → ((Poised(crosby))) ::: If there is at least one people who is both wicked and not teak, then Crosby is poised.\n((Teak(keith))) ↔ ((¬Poised(gregory) ∧ ¬Wicked(noel))) ::: Keith is teak if and only if Gregory is not poised and Noel is not wicked.\n((Teak(noel))) ↔ ((Hungry(shane))) ::: Noel is teak if and only if Shane is hungry.\n((¬Teak(gregory) ∧ Wicked(crosby))) → ((¬Mushy(keith))) ::: If Gregory is not teak and Crosby is wicked, then Keith is not mushy.\n(∃x (Hungry(x) ∧ Wicked(x))) → ((Teak(noel))) ::: If there is at least one people who is both hungry and wicked, then Noel is teak.\n",
                "First-Order-Logic Question": "¬Hungry(shane) ::: Shane is not hungry."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬x)) → ((Teak(shane) ∧ ¬Poised(shane))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised.",
                    "gram": "¬∃x((¬(¬Frank(x)))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised."
                }
            ],
            "answer": "B",
            "grammar_answer": "A",
            "backup_answer": "B"
        },
        {
            "id": 125,
            "raw_prog": {
                "First-Order-Logic Rules": "¬Hungry(gregory) ::: Gregory is not hungry.\nMushy(ronald) ::: Ronald is mushy.\nTeak(keith) ::: Keith is teak.\nPoised(crosby) ::: Crosby is poised.\nFrank(shane) ::: Shane is frank.\nPoised(gregory) ::: Gregory is poised.\n¬Poised(shane) ::: Shane is not poised.\nMushy(keith) ::: Keith is mushy.\n¬Frank(noel) ::: Noel is not frank.\nFrank(george) ::: George is frank.\nWicked(george) ::: George is wicked.\nFrank(keith) ::: Keith is frank.\n(∀x (Mushy(x) ∨ ¬Poised(x))) → (∀x (Hungry(x) ∧ ¬Wicked(x))) ::: If someone is either mushy or not poised, then he is hungry and not wicked.\n(¬Poised(gregory)) → (Mushy(shane)) ::: If Gregory is not poised, then Shane is mushy.\n(∃x (Wicked(x))) → ((¬Poised(shane) ∧ ¬Frank(george))) ::: If there is at least one people who is wicked, then Shane is not poised and George is not frank.\n((Teak(noel))) ↔ ((¬Poised(noel))) ::: If Noel is teak, then Noel is not poised, and vice versa.\n(¬∃x (¬x)) → ((Teak(shane) ∧ ¬Poised(shane))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised.\n(∀x (Wicked(x) ∧ Mushy(x))) ↔ (∀x (Poised(x))) ::: Someone is wicked and mushy if and only if he is poised.\n(∃x (Poised(x) ∨ ¬Hungry(x))) → ((¬Mushy(george))) ::: If there is at least one people who is poised or not hungry, then George is not mushy.\n(∃x (Wicked(x) ∧ ¬Teak(x))) → ((Poised(crosby))) ::: If there is at least one people who is both wicked and not teak, then Crosby is poised.\n((Teak(keith))) ↔ ((¬Poised(gregory) ∧ ¬Wicked(noel))) ::: Keith is teak if and only if Gregory is not poised and Noel is not wicked.\n((Teak(noel))) ↔ ((Hungry(shane))) ::: Noel is teak if and only if Shane is hungry.\n((¬Teak(gregory) ∧ Wicked(crosby))) → ((¬Mushy(keith))) ::: If Gregory is not teak and Crosby is wicked, then Keith is not mushy.\n(∃x (Hungry(x) ∧ Wicked(x))) → ((Teak(noel))) ::: If there is at least one people who is both hungry and wicked, then Noel is teak.\n",
                "First-Order-Logic Question": "Mushy(noel) ::: Noel is mushy."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "¬Hungry(gregory) ::: Gregory is not hungry.\nMushy(ronald) ::: Ronald is mushy.\nTeak(keith) ::: Keith is teak.\nPoised(crosby) ::: Crosby is poised.\nFrank(shane) ::: Shane is frank.\nPoised(gregory) ::: Gregory is poised.\n¬Poised(shane) ::: Shane is not poised.\nMushy(keith) ::: Keith is mushy.\n¬Frank(noel) ::: Noel is not frank.\nFrank(george) ::: George is frank.\nWicked(george) ::: George is wicked.\nFrank(keith) ::: Keith is frank.\n(∀x (Mushy(x) ∨ ¬Poised(x))) → (∀x (Hungry(x) ∧ ¬Wicked(x))) ::: If someone is either mushy or not poised, then he is hungry and not wicked.\n(¬Poised(gregory)) → (Mushy(shane)) ::: If Gregory is not poised, then Shane is mushy.\n(∃x (Wicked(x))) → ((¬Poised(shane) ∧ ¬Frank(george))) ::: If there is at least one people who is wicked, then Shane is not poised and George is not frank.\n((Teak(noel))) ↔ ((¬Poised(noel))) ::: If Noel is teak, then Noel is not poised, and vice versa.\n¬∃x((¬(¬Frank(x)))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised.\n(∀x (Wicked(x) ∧ Mushy(x))) ↔ (∀x (Poised(x))) ::: Someone is wicked and mushy if and only if he is poised.\n(∃x (Poised(x) ∨ ¬Hungry(x))) → ((¬Mushy(george))) ::: If there is at least one people who is poised or not hungry, then George is not mushy.\n(∃x (Wicked(x) ∧ ¬Teak(x))) → ((Poised(crosby))) ::: If there is at least one people who is both wicked and not teak, then Crosby is poised.\n((Teak(keith))) ↔ ((¬Poised(gregory) ∧ ¬Wicked(noel))) ::: Keith is teak if and only if Gregory is not poised and Noel is not wicked.\n((Teak(noel))) ↔ ((Hungry(shane))) ::: Noel is teak if and only if Shane is hungry.\n((¬Teak(gregory) ∧ Wicked(crosby))) → ((¬Mushy(keith))) ::: If Gregory is not teak and Crosby is wicked, then Keith is not mushy.\n(∃x (Hungry(x) ∧ Wicked(x))) → ((Teak(noel))) ::: If there is at least one people who is both hungry and wicked, then Noel is teak.\n",
                "First-Order-Logic Question": "Mushy(noel) ::: Noel is mushy."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬x)) → ((Teak(shane) ∧ ¬Poised(shane))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised.",
                    "gram": "¬∃x((¬(¬Frank(x)))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised."
                }
            ],
            "answer": "C",
            "grammar_answer": "A",
            "backup_answer": "B"
        },
        {
            "id": 126,
            "raw_prog": {
                "First-Order-Logic Rules": "¬Hungry(gregory) ::: Gregory is not hungry.\nMushy(ronald) ::: Ronald is mushy.\nTeak(keith) ::: Keith is teak.\nPoised(crosby) ::: Crosby is poised.\nFrank(shane) ::: Shane is frank.\nPoised(gregory) ::: Gregory is poised.\n¬Poised(shane) ::: Shane is not poised.\nMushy(keith) ::: Keith is mushy.\n¬Frank(noel) ::: Noel is not frank.\nFrank(george) ::: George is frank.\nWicked(george) ::: George is wicked.\nFrank(keith) ::: Keith is frank.\n(∀x (Mushy(x) ∨ ¬Poised(x))) → (∀x (Hungry(x) ∧ ¬Wicked(x))) ::: If someone is either mushy or not poised, then he is hungry and not wicked.\n(¬Poised(gregory)) → ((Mushy(shane))) ::: If Gregory is not poised, then Shane is mushy.\n(∃x (Wicked(x))) → ((¬Poised(shane) ∧ ¬Frank(george))) ::: If there is at least one people who is wicked, then Shane is not poised and George is not frank.\n((Teak(noel))) ↔ ((¬Poised(noel))) ::: If Noel is teak, then Noel is not poised, and vice versa.\n(∀x (¬x)) → ((Teak(shane) ∧ ¬Poised(shane))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised.\n(∀x (Wicked(x) ∧ Mushy(x))) ↔ (∀x (Poised(x))) ::: Someone is wicked and mushy if and only if he is poised.\n(∃x (Poised(x) ∨ ¬Hungry(x))) → ((¬Mushy(george))) ::: If there is at least one people who is poised or not hungry, then George is not mushy.\n(∃x (Wicked(x) ∧ ¬Teak(x))) → ((Poised(crosby))) ::: If there is at least one people who is both wicked and not teak, then Crosby is poised.\n((Teak(keith))) ↔ ((¬Poised(gregory) ∧ ¬Wicked(noel))) ::: Keith is teak if and only if Gregory is not poised and Noel is not wicked.\n((Teak(noel))) ↔ ((Hungry(shane))) ::: Noel is teak if and only if Shane is hungry.\n((¬Teak(gregory) ∧ Wicked(crosby))) → ((¬Mushy(keith))) ::: If Gregory is not teak and Crosby is wicked, then Keith is not mushy.\n(∃x (Hungry(x) ∧ Wicked(x))) → ((Teak(noel))) ::: If there is at least one people who is both hungry and wicked, then Noel is teak.\n",
                "First-Order-Logic Question": "¬Mushy(george) ::: George is not mushy."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "¬Hungry(gregory) ::: Gregory is not hungry.\nMushy(ronald) ::: Ronald is mushy.\nTeak(keith) ::: Keith is teak.\nPoised(crosby) ::: Crosby is poised.\nFrank(shane) ::: Shane is frank.\nPoised(gregory) ::: Gregory is poised.\n¬Poised(shane) ::: Shane is not poised.\nMushy(keith) ::: Keith is mushy.\n¬Frank(noel) ::: Noel is not frank.\nFrank(george) ::: George is frank.\nWicked(george) ::: George is wicked.\nFrank(keith) ::: Keith is frank.\n(∀x (Mushy(x) ∨ ¬Poised(x))) → (∀x (Hungry(x) ∧ ¬Wicked(x))) ::: If someone is either mushy or not poised, then he is hungry and not wicked.\n(¬Poised(gregory)) → ((Mushy(shane))) ::: If Gregory is not poised, then Shane is mushy.\n(∃x (Wicked(x))) → ((¬Poised(shane) ∧ ¬Frank(george))) ::: If there is at least one people who is wicked, then Shane is not poised and George is not frank.\n((Teak(noel))) ↔ ((¬Poised(noel))) ::: If Noel is teak, then Noel is not poised, and vice versa.\n¬(Hungry(x))→((Teak(x))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised.\n(∀x (Wicked(x) ∧ Mushy(x))) ↔ (∀x (Poised(x))) ::: Someone is wicked and mushy if and only if he is poised.\n(∃x (Poised(x) ∨ ¬Hungry(x))) → ((¬Mushy(george))) ::: If there is at least one people who is poised or not hungry, then George is not mushy.\n(∃x (Wicked(x) ∧ ¬Teak(x))) → ((Poised(crosby))) ::: If there is at least one people who is both wicked and not teak, then Crosby is poised.\n((Teak(keith))) ↔ ((¬Poised(gregory) ∧ ¬Wicked(noel))) ::: Keith is teak if and only if Gregory is not poised and Noel is not wicked.\n((Teak(noel))) ↔ ((Hungry(shane))) ::: Noel is teak if and only if Shane is hungry.\n((¬Teak(gregory) ∧ Wicked(crosby))) → ((¬Mushy(keith))) ::: If Gregory is not teak and Crosby is wicked, then Keith is not mushy.\n(∃x (Hungry(x) ∧ Wicked(x))) → ((Teak(noel))) ::: If there is at least one people who is both hungry and wicked, then Noel is teak.\n",
                "First-Order-Logic Question": "¬Mushy(george) ::: George is not mushy."
            },
            "diff": [
                {
                    "raw": "(∀x (¬x)) → ((Teak(shane) ∧ ¬Poised(shane))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised.",
                    "gram": "¬(Hungry(x))→((Teak(x))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised."
                }
            ],
            "answer": "A",
            "grammar_answer": "A",
            "backup_answer": "A"
        },
        {
            "id": 127,
            "raw_prog": {
                "First-Order-Logic Rules": "¬Hungry(gregory) ::: Gregory is not hungry.\nMushy(ronald) ::: Ronald is mushy.\nTeak(keith) ::: Keith is teak.\nPoised(crosby) ::: Crosby is poised.\nFrank(shane) ::: Shane is frank.\nPoised(gregory) ::: Gregory is poised.\n¬Poised(shane) ::: Shane is not poised.\nMushy(keith) ::: Keith is mushy.\n¬Frank(noel) ::: Noel is not frank.\nFrank(george) ::: George is frank.\nWicked(george) ::: George is wicked.\nFrank(keith) ::: Keith is frank.\n(∀x (Mushy(x) ∨ ¬Poised(x))) → (∀x (Hungry(x) ∧ ¬Wicked(x))) ::: If someone is either mushy or not poised, then he is hungry and not wicked.\n(¬Poised(gregory)) → (Mushy(shane)) ::: If Gregory is not poised, then Shane is mushy.\n(∃x (Wicked(x))) → ((¬Poised(shane) ∧ ¬Frank(george))) ::: If there is at least one people who is wicked, then Shane is not poised and George is not frank.\n((Teak(noel))) ↔ ((¬Poised(noel))) ::: If Noel is teak, then Noel is not poised, and vice versa.\n(¬∃x (¬x)) → ((Teak(shane) ∧ ¬Poised(shane))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised.\n(∀x (Wicked(x) ∧ Mushy(x))) ↔ (∀x (Poised(x))) ::: Someone is wicked and mushy if and only if he is poised.\n(∃x (Poised(x) ∨ ¬Hungry(x))) → ((¬Mushy(george))) ::: If there is at least one people who is poised or not hungry, then George is not mushy.\n(∃x (Wicked(x) ∧ ¬Teak(x))) → ((Poised(crosby))) ::: If there is at least one people who is both wicked and not teak, then Crosby is poised.\n((Teak(keith))) ↔ ((¬Poised(gregory) ∧ ¬Wicked(noel))) ::: Keith is teak if and only if Gregory is not poised and Noel is not wicked.\n((Teak(noel))) ↔ ((Hungry(shane))) ::: Noel is teak if and only if Shane is hungry.\n((¬Teak(gregory) ∧ Wicked(crosby))) → ((¬Mushy(keith))) ::: If Gregory is not teak and Crosby is wicked, then Keith is not mushy.\n(∃x (Hungry(x) ∧ Wicked(x))) → ((Teak(noel))) ::: If there is at least one people who is both hungry and wicked, then Noel is teak.\n",
                "First-Order-Logic Question": "¬Teak(ronald) ::: Ronald is not teak."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "¬Hungry(gregory) ::: Gregory is not hungry.\nMushy(ronald) ::: Ronald is mushy.\nTeak(keith) ::: Keith is teak.\nPoised(crosby) ::: Crosby is poised.\nFrank(shane) ::: Shane is frank.\nPoised(gregory) ::: Gregory is poised.\n¬Poised(shane) ::: Shane is not poised.\nMushy(keith) ::: Keith is mushy.\n¬Frank(noel) ::: Noel is not frank.\nFrank(george) ::: George is frank.\nWicked(george) ::: George is wicked.\nFrank(keith) ::: Keith is frank.\n(∀x (Mushy(x) ∨ ¬Poised(x))) → (∀x (Hungry(x) ∧ ¬Wicked(x))) ::: If someone is either mushy or not poised, then he is hungry and not wicked.\n(¬Poised(gregory)) → (Mushy(shane)) ::: If Gregory is not poised, then Shane is mushy.\n(∃x (Wicked(x))) → ((¬Poised(shane) ∧ ¬Frank(george))) ::: If there is at least one people who is wicked, then Shane is not poised and George is not frank.\n((Teak(noel))) ↔ ((¬Poised(noel))) ::: If Noel is teak, then Noel is not poised, and vice versa.\n¬∃x((¬(¬Frank(x)))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised.\n(∀x (Wicked(x) ∧ Mushy(x))) ↔ (∀x (Poised(x))) ::: Someone is wicked and mushy if and only if he is poised.\n(∃x (Poised(x) ∨ ¬Hungry(x))) → ((¬Mushy(george))) ::: If there is at least one people who is poised or not hungry, then George is not mushy.\n(∃x (Wicked(x) ∧ ¬Teak(x))) → ((Poised(crosby))) ::: If there is at least one people who is both wicked and not teak, then Crosby is poised.\n((Teak(keith))) ↔ ((¬Poised(gregory) ∧ ¬Wicked(noel))) ::: Keith is teak if and only if Gregory is not poised and Noel is not wicked.\n((Teak(noel))) ↔ ((Hungry(shane))) ::: Noel is teak if and only if Shane is hungry.\n((¬Teak(gregory) ∧ Wicked(crosby))) → ((¬Mushy(keith))) ::: If Gregory is not teak and Crosby is wicked, then Keith is not mushy.\n(∃x (Hungry(x) ∧ Wicked(x))) → ((Teak(noel))) ::: If there is at least one people who is both hungry and wicked, then Noel is teak.\n",
                "First-Order-Logic Question": "¬Teak(ronald) ::: Ronald is not teak."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬x)) → ((Teak(shane) ∧ ¬Poised(shane))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised.",
                    "gram": "¬∃x((¬(¬Frank(x)))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised."
                }
            ],
            "answer": "C",
            "grammar_answer": "A",
            "backup_answer": "C"
        },
        {
            "id": 128,
            "raw_prog": {
                "First-Order-Logic Rules": "¬Hungry(gregory) ::: Gregory is not hungry.\nMushy(ronald) ::: Ronald is mushy.\nTeak(keith) ::: Keith is teak.\nPoised(crosby) ::: Crosby is poised.\nFrank(shane) ::: Shane is frank.\nPoised(gregory) ::: Gregory is poised.\n¬Poised(shane) ::: Shane is not poised.\nMushy(keith) ::: Keith is mushy.\n¬Frank(noel) ::: Noel is not frank.\nFrank(george) ::: George is frank.\nWicked(george) ::: George is wicked.\nFrank(keith) ::: Keith is frank.\n(∀x (Mushy(x) ∨ ¬Poised(x))) → (∀x (Hungry(x) ∧ ¬Wicked(x))) ::: If someone is either mushy or not poised, then he is hungry and not wicked.\n(¬Poised(gregory)) → (Mushy(shane)) ::: If Gregory is not poised, then Shane is mushy.\n(∃x (Wicked(x))) → ((¬Poised(shane) ∧ ¬Frank(george))) ::: If there is at least one people who is wicked, then Shane is not poised and George is not frank.\n((Teak(noel))) ↔ ((¬Poised(noel))) ::: If Noel is teak, then Noel is not poised, and vice versa.\n(¬∃x (¬x)) → ((Teak(shane) ∧ ¬Poised(shane))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised.\n(∀x (Wicked(x) ∧ Mushy(x))) ↔ (∀x (Poised(x))) ::: Someone is wicked and mushy if and only if he is poised.\n(∃x (Poised(x) ∨ ¬Hungry(x))) → ((¬Mushy(george))) ::: If there is at least one people who is poised or not hungry, then George is not mushy.\n(∃x (Wicked(x) ∧ ¬Teak(x))) → ((Poised(crosby))) ::: If there is at least one people who is both wicked and not teak, then Crosby is poised.\n((Teak(keith))) ↔ ((¬Poised(gregory) ∧ ¬Wicked(noel))) ::: Keith is teak if and only if Gregory is not poised and Noel is not wicked.\n((Teak(noel))) ↔ ((Hungry(shane))) ::: Noel is teak if and only if Shane is hungry.\n((¬Teak(gregory) ∧ Wicked(crosby))) → ((¬Mushy(keith))) ::: If Gregory is not teak and Crosby is wicked, then Keith is not mushy.\n(∃x (Hungry(x) ∧ Wicked(x))) → ((Teak(noel))) ::: If there is at least one people who is both hungry and wicked, then Noel is teak.\n",
                "First-Order-Logic Question": "¬Hungry(crosby) ::: Crosby is not hungry."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "¬Hungry(gregory) ::: Gregory is not hungry.\nMushy(ronald) ::: Ronald is mushy.\nTeak(keith) ::: Keith is teak.\nPoised(crosby) ::: Crosby is poised.\nFrank(shane) ::: Shane is frank.\nPoised(gregory) ::: Gregory is poised.\n¬Poised(shane) ::: Shane is not poised.\nMushy(keith) ::: Keith is mushy.\n¬Frank(noel) ::: Noel is not frank.\nFrank(george) ::: George is frank.\nWicked(george) ::: George is wicked.\nFrank(keith) ::: Keith is frank.\n(∀x (Mushy(x) ∨ ¬Poised(x))) → (∀x (Hungry(x) ∧ ¬Wicked(x))) ::: If someone is either mushy or not poised, then he is hungry and not wicked.\n(¬Poised(gregory)) → (Mushy(shane)) ::: If Gregory is not poised, then Shane is mushy.\n(∃x (Wicked(x))) → ((¬Poised(shane) ∧ ¬Frank(george))) ::: If there is at least one people who is wicked, then Shane is not poised and George is not frank.\n((Teak(noel))) ↔ ((¬Poised(noel))) ::: If Noel is teak, then Noel is not poised, and vice versa.\n¬∃x((¬(¬Frank(x)))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised.\n(∀x (Wicked(x) ∧ Mushy(x))) ↔ (∀x (Poised(x))) ::: Someone is wicked and mushy if and only if he is poised.\n(∃x (Poised(x) ∨ ¬Hungry(x))) → ((¬Mushy(george))) ::: If there is at least one people who is poised or not hungry, then George is not mushy.\n(∃x (Wicked(x) ∧ ¬Teak(x))) → ((Poised(crosby))) ::: If there is at least one people who is both wicked and not teak, then Crosby is poised.\n((Teak(keith))) ↔ ((¬Poised(gregory) ∧ ¬Wicked(noel))) ::: Keith is teak if and only if Gregory is not poised and Noel is not wicked.\n((Teak(noel))) ↔ ((Hungry(shane))) ::: Noel is teak if and only if Shane is hungry.\n((¬Teak(gregory) ∧ Wicked(crosby))) → ((¬Mushy(keith))) ::: If Gregory is not teak and Crosby is wicked, then Keith is not mushy.\n(∃x (Hungry(x) ∧ Wicked(x))) → ((Teak(noel))) ::: If there is at least one people who is both hungry and wicked, then Noel is teak.\n",
                "First-Order-Logic Question": "¬Hungry(crosby) ::: Crosby is not hungry."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬x)) → ((Teak(shane) ∧ ¬Poised(shane))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised.",
                    "gram": "¬∃x((¬(¬Frank(x)))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised."
                }
            ],
            "answer": "B",
            "grammar_answer": "A",
            "backup_answer": "C"
        },
        {
            "id": 129,
            "raw_prog": {
                "First-Order-Logic Rules": "¬Hungry(gregory) ::: Gregory is not hungry.\nMushy(ronald) ::: Ronald is mushy.\nTeak(keith) ::: Keith is teak.\nPoised(crosby) ::: Crosby is poised.\nFrank(shane) ::: Shane is frank.\nPoised(gregory) ::: Gregory is poised.\n¬Poised(shane) ::: Shane is not poised.\nMushy(keith) ::: Keith is mushy.\n¬Frank(noel) ::: Noel is not frank.\nFrank(george) ::: George is frank.\nWicked(george) ::: George is wicked.\nFrank(keith) ::: Keith is frank.\n(∀x (Mushy(x) ∨ ¬Poised(x))) → (∀x (Hungry(x) ∧ ¬Wicked(x))) ::: If someone is either mushy or not poised, then he is hungry and not wicked.\n(¬Poised(gregory)) → (Mushy(shane)) ::: If Gregory is not poised, then Shane is mushy.\n(∃x (Wicked(x))) → ((¬Poised(shane) ∧ ¬Frank(george))) ::: If there is at least one people who is wicked, then Shane is not poised and George is not frank.\n((Teak(noel))) ↔ ((¬Poised(noel))) ::: If Noel is teak, then Noel is not poised, and vice versa.\n(¬∃x (¬x)) → ((Teak(shane) ∧ ¬Poised(shane))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised.\n(∀x (Wicked(x) ∧ Mushy(x))) ↔ (∀x (Poised(x))) ::: Someone is wicked and mushy if and only if he is poised.\n(∃x (Poised(x) ∨ ¬Hungry(x))) → ((¬Mushy(george))) ::: If there is at least one people who is poised or not hungry, then George is not mushy.\n(∃x (Wicked(x) ∧ ¬Teak(x))) → ((Poised(crosby))) ::: If there is at least one people who is both wicked and not teak, then Crosby is poised.\n((Teak(keith))) ↔ ((¬Poised(gregory) ∧ ¬Wicked(noel))) ::: Keith is teak if and only if Gregory is not poised and Noel is not wicked.\n((Teak(noel))) ↔ ((Hungry(shane))) ::: Noel is teak if and only if Shane is hungry.\n((¬Teak(gregory) ∧ Wicked(crosby))) → ((¬Mushy(keith))) ::: If Gregory is not teak and Crosby is wicked, then Keith is not mushy.\n(∃x (Hungry(x) ∧ Wicked(x))) → ((Teak(noel))) ::: If there is at least one people who is both hungry and wicked, then Noel is teak.\n",
                "First-Order-Logic Question": "¬Mushy(keith) ::: Keith is not mushy."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "¬Hungry(gregory) ::: Gregory is not hungry.\nMushy(ronald) ::: Ronald is mushy.\nTeak(keith) ::: Keith is teak.\nPoised(crosby) ::: Crosby is poised.\nFrank(shane) ::: Shane is frank.\nPoised(gregory) ::: Gregory is poised.\n¬Poised(shane) ::: Shane is not poised.\nMushy(keith) ::: Keith is mushy.\n¬Frank(noel) ::: Noel is not frank.\nFrank(george) ::: George is frank.\nWicked(george) ::: George is wicked.\nFrank(keith) ::: Keith is frank.\n(∀x (Mushy(x) ∨ ¬Poised(x))) → (∀x (Hungry(x) ∧ ¬Wicked(x))) ::: If someone is either mushy or not poised, then he is hungry and not wicked.\n(¬Poised(gregory)) → (Mushy(shane)) ::: If Gregory is not poised, then Shane is mushy.\n(∃x (Wicked(x))) → ((¬Poised(shane) ∧ ¬Frank(george))) ::: If there is at least one people who is wicked, then Shane is not poised and George is not frank.\n((Teak(noel))) ↔ ((¬Poised(noel))) ::: If Noel is teak, then Noel is not poised, and vice versa.\n¬∃x((¬(¬Frank(x)))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised.\n(∀x (Wicked(x) ∧ Mushy(x))) ↔ (∀x (Poised(x))) ::: Someone is wicked and mushy if and only if he is poised.\n(∃x (Poised(x) ∨ ¬Hungry(x))) → ((¬Mushy(george))) ::: If there is at least one people who is poised or not hungry, then George is not mushy.\n(∃x (Wicked(x) ∧ ¬Teak(x))) → ((Poised(crosby))) ::: If there is at least one people who is both wicked and not teak, then Crosby is poised.\n((Teak(keith))) ↔ ((¬Poised(gregory) ∧ ¬Wicked(noel))) ::: Keith is teak if and only if Gregory is not poised and Noel is not wicked.\n((Teak(noel))) ↔ ((Hungry(shane))) ::: Noel is teak if and only if Shane is hungry.\n((¬Teak(gregory) ∧ Wicked(crosby))) → ((¬Mushy(keith))) ::: If Gregory is not teak and Crosby is wicked, then Keith is not mushy.\n(∃x (Hungry(x) ∧ Wicked(x))) → ((Teak(noel))) ::: If there is at least one people who is both hungry and wicked, then Noel is teak.\n",
                "First-Order-Logic Question": "¬Mushy(keith) ::: Keith is not mushy."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬x)) → ((Teak(shane) ∧ ¬Poised(shane))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised.",
                    "gram": "¬∃x((¬(¬Frank(x)))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised."
                }
            ],
            "answer": "B",
            "grammar_answer": "A",
            "backup_answer": "B"
        },
        {
            "id": 130,
            "raw_prog": {
                "First-Order-Logic Rules": "¬Hungry(gregory) ::: Gregory is not hungry.\nMushy(ronald) ::: Ronald is mushy.\nTeak(keith) ::: Keith is teak.\nPoised(crosby) ::: Crosby is poised.\nFrank(shane) ::: Shane is frank.\nPoised(gregory) ::: Gregory is poised.\n¬Poised(shane) ::: Shane is not poised.\nMushy(keith) ::: Keith is mushy.\n¬Frank(noel) ::: Noel is not frank.\nFrank(george) ::: George is frank.\nWicked(george) ::: George is wicked.\nFrank(keith) ::: Keith is frank.\n(∀x (Mushy(x) ∨ ¬Poised(x))) → (∀x (Hungry(x) ∧ ¬Wicked(x))) ::: If someone is either mushy or not poised, then he is hungry and not wicked.\n(¬Poised(gregory)) → (Mushy(shane)) ::: If Gregory is not poised, then Shane is mushy.\n(∃x (Wicked(x))) → ((¬Poised(shane) ∧ ¬Frank(george))) ::: If there is at least one people who is wicked, then Shane is not poised and George is not frank.\n((Teak(noel))) ↔ ((¬Poised(noel))) ::: If Noel is teak, then Noel is not poised, and vice versa.\n(¬∃x (¬x)) → ((Teak(shane) ∧ ¬Poised(shane))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised.\n(∀x (Wicked(x) ∧ Mushy(x))) ↔ (∀x (Poised(x))) ::: Someone is wicked and mushy if and only if he is poised.\n(∃x (Poised(x) ∨ ¬Hungry(x))) → ((¬Mushy(george))) ::: If there is at least one people who is poised or not hungry, then George is not mushy.\n(∃x (Wicked(x) ∧ ¬Teak(x))) → ((Poised(crosby))) ::: If there is at least one people who is both wicked and not teak, then Crosby is poised.\n((Teak(keith))) ↔ ((¬Poised(gregory) ∧ ¬Wicked(noel))) ::: Keith is teak if and only if Gregory is not poised and Noel is not wicked.\n((Teak(noel))) ↔ ((Hungry(shane))) ::: Noel is teak if and only if Shane is hungry.\n((¬Teak(gregory) ∧ Wicked(crosby))) → ((¬Mushy(keith))) ::: If Gregory is not teak and Crosby is wicked, then Keith is not mushy.\n(∃x (Hungry(x) ∧ Wicked(x))) → ((Teak(noel))) ::: If there is at least one people who is both hungry and wicked, then Noel is teak.\n",
                "First-Order-Logic Question": "Poised(keith) ::: Keith is poised."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "¬Hungry(gregory) ::: Gregory is not hungry.\nMushy(ronald) ::: Ronald is mushy.\nTeak(keith) ::: Keith is teak.\nPoised(crosby) ::: Crosby is poised.\nFrank(shane) ::: Shane is frank.\nPoised(gregory) ::: Gregory is poised.\n¬Poised(shane) ::: Shane is not poised.\nMushy(keith) ::: Keith is mushy.\n¬Frank(noel) ::: Noel is not frank.\nFrank(george) ::: George is frank.\nWicked(george) ::: George is wicked.\nFrank(keith) ::: Keith is frank.\n(∀x (Mushy(x) ∨ ¬Poised(x))) → (∀x (Hungry(x) ∧ ¬Wicked(x))) ::: If someone is either mushy or not poised, then he is hungry and not wicked.\n(¬Poised(gregory)) → (Mushy(shane)) ::: If Gregory is not poised, then Shane is mushy.\n(∃x (Wicked(x))) → ((¬Poised(shane) ∧ ¬Frank(george))) ::: If there is at least one people who is wicked, then Shane is not poised and George is not frank.\n((Teak(noel))) ↔ ((¬Poised(noel))) ::: If Noel is teak, then Noel is not poised, and vice versa.\n¬∃x((¬(¬Frank(x)))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised.\n(∀x (Wicked(x) ∧ Mushy(x))) ↔ (∀x (Poised(x))) ::: Someone is wicked and mushy if and only if he is poised.\n(∃x (Poised(x) ∨ ¬Hungry(x))) → ((¬Mushy(george))) ::: If there is at least one people who is poised or not hungry, then George is not mushy.\n(∃x (Wicked(x) ∧ ¬Teak(x))) → ((Poised(crosby))) ::: If there is at least one people who is both wicked and not teak, then Crosby is poised.\n((Teak(keith))) ↔ ((¬Poised(gregory) ∧ ¬Wicked(noel))) ::: Keith is teak if and only if Gregory is not poised and Noel is not wicked.\n((Teak(noel))) ↔ ((Hungry(shane))) ::: Noel is teak if and only if Shane is hungry.\n((¬Teak(gregory) ∧ Wicked(crosby))) → ((¬Mushy(keith))) ::: If Gregory is not teak and Crosby is wicked, then Keith is not mushy.\n(∃x (Hungry(x) ∧ Wicked(x))) → ((Teak(noel))) ::: If there is at least one people who is both hungry and wicked, then Noel is teak.\n",
                "First-Order-Logic Question": "Poised(keith) ::: Keith is poised."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬x)) → ((Teak(shane) ∧ ¬Poised(shane))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised.",
                    "gram": "¬∃x((¬(¬Frank(x)))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised."
                }
            ],
            "answer": "C",
            "grammar_answer": "A",
            "backup_answer": "C"
        },
        {
            "id": 131,
            "raw_prog": {
                "First-Order-Logic Rules": "¬Hungry(gregory) ::: Gregory is not hungry.\nMushy(ronald) ::: Ronald is mushy.\nTeak(keith) ::: Keith is teak.\nPoised(crosby) ::: Crosby is poised.\nFrank(shane) ::: Shane is frank.\nPoised(gregory) ::: Gregory is poised.\n¬Poised(shane) ::: Shane is not poised.\nMushy(keith) ::: Keith is mushy.\n¬Frank(noel) ::: Noel is not frank.\nFrank(george) ::: George is frank.\nWicked(george) ::: George is wicked.\nFrank(keith) ::: Keith is frank.\n(∀x (Mushy(x) ∨ ¬Poised(x))) → (∀x (Hungry(x) ∧ ¬Wicked(x))) ::: If someone is either mushy or not poised, then he is hungry and not wicked.\n(¬Poised(gregory)) → (Mushy(shane)) ::: If Gregory is not poised, then Shane is mushy.\n(∃x (Wicked(x))) → ((¬Poised(shane) ∧ ¬Frank(george))) ::: If there is at least one people who is wicked, then Shane is not poised and George is not frank.\n((Teak(noel))) ↔ ((¬Poised(noel))) ::: If Noel is teak, then Noel is not poised, and vice versa.\n(¬∃x (¬x)) → ((Teak(shane) ∧ ¬Poised(shane))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised.\n(∀x (Wicked(x) ∧ Mushy(x))) ↔ (∀x (Poised(x))) ::: Someone is wicked and mushy if and only if he is poised.\n(∃x (Poised(x) ∨ ¬Hungry(x))) → ((¬Mushy(george))) ::: If there is at least one people who is poised or not hungry, then George is not mushy.\n(∃x (Wicked(x) ∧ ¬Teak(x))) → ((Poised(crosby))) ::: If there is at least one people who is both wicked and not teak, then Crosby is poised.\n((Teak(keith))) ↔ ((¬Poised(gregory) ∧ ¬Wicked(noel))) ::: Keith is teak if and only if Gregory is not poised and Noel is not wicked.\n((Teak(noel))) ↔ ((Hungry(shane))) ::: Noel is teak if and only if Shane is hungry.\n((¬Teak(gregory) ∧ Wicked(crosby))) → ((¬Mushy(keith))) ::: If Gregory is not teak and Crosby is wicked, then Keith is not mushy.\n(∃x (Hungry(x) ∧ Wicked(x))) → ((Teak(noel))) ::: If there is at least one people who is both hungry and wicked, then Noel is teak.\n",
                "First-Order-Logic Question": "Poised(george) ::: George is poised."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "¬Hungry(gregory) ::: Gregory is not hungry.\nMushy(ronald) ::: Ronald is mushy.\nTeak(keith) ::: Keith is teak.\nPoised(crosby) ::: Crosby is poised.\nFrank(shane) ::: Shane is frank.\nPoised(gregory) ::: Gregory is poised.\n¬Poised(shane) ::: Shane is not poised.\nMushy(keith) ::: Keith is mushy.\n¬Frank(noel) ::: Noel is not frank.\nFrank(george) ::: George is frank.\nWicked(george) ::: George is wicked.\nFrank(keith) ::: Keith is frank.\n(∀x (Mushy(x) ∨ ¬Poised(x))) → (∀x (Hungry(x) ∧ ¬Wicked(x))) ::: If someone is either mushy or not poised, then he is hungry and not wicked.\n(¬Poised(gregory)) → (Mushy(shane)) ::: If Gregory is not poised, then Shane is mushy.\n(∃x (Wicked(x))) → ((¬Poised(shane) ∧ ¬Frank(george))) ::: If there is at least one people who is wicked, then Shane is not poised and George is not frank.\n((Teak(noel))) ↔ ((¬Poised(noel))) ::: If Noel is teak, then Noel is not poised, and vice versa.\n¬∃x((¬(¬Frank(x)))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised.\n(∀x (Wicked(x) ∧ Mushy(x))) ↔ (∀x (Poised(x))) ::: Someone is wicked and mushy if and only if he is poised.\n(∃x (Poised(x) ∨ ¬Hungry(x))) → ((¬Mushy(george))) ::: If there is at least one people who is poised or not hungry, then George is not mushy.\n(∃x (Wicked(x) ∧ ¬Teak(x))) → ((Poised(crosby))) ::: If there is at least one people who is both wicked and not teak, then Crosby is poised.\n((Teak(keith))) ↔ ((¬Poised(gregory) ∧ ¬Wicked(noel))) ::: Keith is teak if and only if Gregory is not poised and Noel is not wicked.\n((Teak(noel))) ↔ ((Hungry(shane))) ::: Noel is teak if and only if Shane is hungry.\n((¬Teak(gregory) ∧ Wicked(crosby))) → ((¬Mushy(keith))) ::: If Gregory is not teak and Crosby is wicked, then Keith is not mushy.\n(∃x (Hungry(x) ∧ Wicked(x))) → ((Teak(noel))) ::: If there is at least one people who is both hungry and wicked, then Noel is teak.\n",
                "First-Order-Logic Question": "Poised(george) ::: George is poised."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬x)) → ((Teak(shane) ∧ ¬Poised(shane))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised.",
                    "gram": "¬∃x((¬(¬Frank(x)))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised."
                }
            ],
            "answer": "C",
            "grammar_answer": "A",
            "backup_answer": "C"
        },
        {
            "id": 132,
            "raw_prog": {
                "First-Order-Logic Rules": "¬Hungry(gregory) ::: Gregory is not hungry.\nMushy(ronald) ::: Ronald is mushy.\nTeak(keith) ::: Keith is teak.\nPoised(crosby) ::: Crosby is poised.\nFrank(shane) ::: Shane is frank.\nPoised(gregory) ::: Gregory is poised.\n¬Poised(shane) ::: Shane is not poised.\nMushy(keith) ::: Keith is mushy.\n¬Frank(noel) ::: Noel is not frank.\nFrank(george) ::: George is frank.\nWicked(george) ::: George is wicked.\nFrank(keith) ::: Keith is frank.\n(∀x (Mushy(x) ∨ ¬Poised(x))) → (∀x (Hungry(x) ∧ ¬Wicked(x))) ::: If someone is either mushy or not poised, then he is hungry and not wicked.\n(¬Poised(gregory)) → (Mushy(shane)) ::: If Gregory is not poised, then Shane is mushy.\n(∃x (Wicked(x))) → ((¬Poised(shane) ∧ ¬Frank(george))) ::: If there is at least one people who is wicked, then Shane is not poised and George is not frank.\n((Teak(noel))) ↔ ((¬Poised(noel))) ::: If Noel is teak, then Noel is not poised, and vice versa.\n(¬∃x (¬x)) → ((Teak(shane) ∧ ¬Poised(shane))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised.\n(∀x (Wicked(x) ∧ Mushy(x))) ↔ (∀x (Poised(x))) ::: Someone is wicked and mushy if and only if he is poised.\n(∃x (Poised(x) ∨ ¬Hungry(x))) → ((¬Mushy(george))) ::: If there is at least one people who is poised or not hungry, then George is not mushy.\n(∃x (Wicked(x) ∧ ¬Teak(x))) → ((Poised(crosby))) ::: If there is at least one people who is both wicked and not teak, then Crosby is poised.\n((Teak(keith))) ↔ ((¬Poised(gregory) ∧ ¬Wicked(noel))) ::: Keith is teak if and only if Gregory is not poised and Noel is not wicked.\n((Teak(noel))) ↔ ((Hungry(shane))) ::: Noel is teak if and only if Shane is hungry.\n((¬Teak(gregory) ∧ Wicked(crosby))) → ((¬Mushy(keith))) ::: If Gregory is not teak and Crosby is wicked, then Keith is not mushy.\n(∃x (Hungry(x) ∧ Wicked(x))) → ((Teak(noel))) ::: If there is at least one people who is both hungry and wicked, then Noel is teak.\n",
                "First-Order-Logic Question": "Poised(noel) ::: Noel is poised."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "¬Hungry(gregory) ::: Gregory is not hungry.\nMushy(ronald) ::: Ronald is mushy.\nTeak(keith) ::: Keith is teak.\nPoised(crosby) ::: Crosby is poised.\nFrank(shane) ::: Shane is frank.\nPoised(gregory) ::: Gregory is poised.\n¬Poised(shane) ::: Shane is not poised.\nMushy(keith) ::: Keith is mushy.\n¬Frank(noel) ::: Noel is not frank.\nFrank(george) ::: George is frank.\nWicked(george) ::: George is wicked.\nFrank(keith) ::: Keith is frank.\n(∀x (Mushy(x) ∨ ¬Poised(x))) → (∀x (Hungry(x) ∧ ¬Wicked(x))) ::: If someone is either mushy or not poised, then he is hungry and not wicked.\n(¬Poised(gregory)) → (Mushy(shane)) ::: If Gregory is not poised, then Shane is mushy.\n(∃x (Wicked(x))) → ((¬Poised(shane) ∧ ¬Frank(george))) ::: If there is at least one people who is wicked, then Shane is not poised and George is not frank.\n((Teak(noel))) ↔ ((¬Poised(noel))) ::: If Noel is teak, then Noel is not poised, and vice versa.\n¬∃x((¬(¬Frank(x)))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised.\n(∀x (Wicked(x) ∧ Mushy(x))) ↔ (∀x (Poised(x))) ::: Someone is wicked and mushy if and only if he is poised.\n(∃x (Poised(x) ∨ ¬Hungry(x))) → ((¬Mushy(george))) ::: If there is at least one people who is poised or not hungry, then George is not mushy.\n(∃x (Wicked(x) ∧ ¬Teak(x))) → ((Poised(crosby))) ::: If there is at least one people who is both wicked and not teak, then Crosby is poised.\n((Teak(keith))) ↔ ((¬Poised(gregory) ∧ ¬Wicked(noel))) ::: Keith is teak if and only if Gregory is not poised and Noel is not wicked.\n((Teak(noel))) ↔ ((Hungry(shane))) ::: Noel is teak if and only if Shane is hungry.\n((¬Teak(gregory) ∧ Wicked(crosby))) → ((¬Mushy(keith))) ::: If Gregory is not teak and Crosby is wicked, then Keith is not mushy.\n(∃x (Hungry(x) ∧ Wicked(x))) → ((Teak(noel))) ::: If there is at least one people who is both hungry and wicked, then Noel is teak.\n",
                "First-Order-Logic Question": "Poised(noel) ::: Noel is poised."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬x)) → ((Teak(shane) ∧ ¬Poised(shane))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised.",
                    "gram": "¬∃x((¬(¬Frank(x)))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised."
                }
            ],
            "answer": "B",
            "grammar_answer": "A",
            "backup_answer": "C"
        },
        {
            "id": 133,
            "raw_prog": {
                "First-Order-Logic Rules": "¬Hungry(gregory) ::: Gregory is not hungry.\nMushy(ronald) ::: Ronald is mushy.\nTeak(keith) ::: Keith is teak.\nPoised(crosby) ::: Crosby is poised.\nFrank(shane) ::: Shane is frank.\nPoised(gregory) ::: Gregory is poised.\n¬Poised(shane) ::: Shane is not poised.\nMushy(keith) ::: Keith is mushy.\n¬Frank(noel) ::: Noel is not frank.\nFrank(george) ::: George is frank.\nWicked(george) ::: George is wicked.\nFrank(keith) ::: Keith is frank.\n(∀x (Mushy(x) ∨ ¬Poised(x))) → (∀x (Hungry(x) ∧ ¬Wicked(x))) ::: If someone is either mushy or not poised, then he is hungry and not wicked.\n(¬Poised(gregory)) → (Mushy(shane)) ::: If Gregory is not poised, then Shane is mushy.\n(∃x (Wicked(x))) → ((¬Poised(shane) ∧ ¬Frank(george))) ::: If there is at least one people who is wicked, then Shane is not poised and George is not frank.\n((Teak(noel))) ↔ ((¬Poised(noel))) ::: If Noel is teak, then Noel is not poised, and vice versa.\n(¬∃x (¬x)) → ((Teak(shane) ∧ ¬Poised(shane))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised.\n(∀x (Wicked(x) ∧ Mushy(x))) ↔ (∀x (Poised(x))) ::: Someone is wicked and mushy if and only if he is poised.\n(∃x (Poised(x) ∨ ¬Hungry(x))) → ((¬Mushy(george))) ::: If there is at least one people who is poised or not hungry, then George is not mushy.\n(∃x (Wicked(x) ∧ ¬Teak(x))) → ((Poised(crosby))) ::: If there is at least one people who is both wicked and not teak, then Crosby is poised.\n((Teak(keith))) ↔ ((¬Poised(gregory) ∧ ¬Wicked(noel))) ::: Keith is teak if and only if Gregory is not poised and Noel is not wicked.\n((Teak(noel))) ↔ ((Hungry(shane))) ::: Noel is teak if and only if Shane is hungry.\n((¬Teak(gregory) ∧ Wicked(crosby))) → ((¬Mushy(keith))) ::: If Gregory is not teak and Crosby is wicked, then Keith is not mushy.\n(∃x (Hungry(x) ∧ Wicked(x))) → ((Teak(noel))) ::: If there is at least one people who is both hungry and wicked, then Noel is teak.\n",
                "First-Order-Logic Question": "Mushy(crosby) ::: Crosby is mushy."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "¬Hungry(gregory) ::: Gregory is not hungry.\nMushy(ronald) ::: Ronald is mushy.\nTeak(keith) ::: Keith is teak.\nPoised(crosby) ::: Crosby is poised.\nFrank(shane) ::: Shane is frank.\nPoised(gregory) ::: Gregory is poised.\n¬Poised(shane) ::: Shane is not poised.\nMushy(keith) ::: Keith is mushy.\n¬Frank(noel) ::: Noel is not frank.\nFrank(george) ::: George is frank.\nWicked(george) ::: George is wicked.\nFrank(keith) ::: Keith is frank.\n(∀x (Mushy(x) ∨ ¬Poised(x))) → (∀x (Hungry(x) ∧ ¬Wicked(x))) ::: If someone is either mushy or not poised, then he is hungry and not wicked.\n(¬Poised(gregory)) → (Mushy(shane)) ::: If Gregory is not poised, then Shane is mushy.\n(∃x (Wicked(x))) → ((¬Poised(shane) ∧ ¬Frank(george))) ::: If there is at least one people who is wicked, then Shane is not poised and George is not frank.\n((Teak(noel))) ↔ ((¬Poised(noel))) ::: If Noel is teak, then Noel is not poised, and vice versa.\n¬∃x((¬(¬Frank(x)))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised.\n(∀x (Wicked(x) ∧ Mushy(x))) ↔ (∀x (Poised(x))) ::: Someone is wicked and mushy if and only if he is poised.\n(∃x (Poised(x) ∨ ¬Hungry(x))) → ((¬Mushy(george))) ::: If there is at least one people who is poised or not hungry, then George is not mushy.\n(∃x (Wicked(x) ∧ ¬Teak(x))) → ((Poised(crosby))) ::: If there is at least one people who is both wicked and not teak, then Crosby is poised.\n((Teak(keith))) ↔ ((¬Poised(gregory) ∧ ¬Wicked(noel))) ::: Keith is teak if and only if Gregory is not poised and Noel is not wicked.\n((Teak(noel))) ↔ ((Hungry(shane))) ::: Noel is teak if and only if Shane is hungry.\n((¬Teak(gregory) ∧ Wicked(crosby))) → ((¬Mushy(keith))) ::: If Gregory is not teak and Crosby is wicked, then Keith is not mushy.\n(∃x (Hungry(x) ∧ Wicked(x))) → ((Teak(noel))) ::: If there is at least one people who is both hungry and wicked, then Noel is teak.\n",
                "First-Order-Logic Question": "Mushy(crosby) ::: Crosby is mushy."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬x)) → ((Teak(shane) ∧ ¬Poised(shane))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised.",
                    "gram": "¬∃x((¬(¬Frank(x)))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised."
                }
            ],
            "answer": "A",
            "grammar_answer": "A",
            "backup_answer": "B"
        },
        {
            "id": 134,
            "raw_prog": {
                "First-Order-Logic Rules": "¬Hungry(gregory) ::: Gregory is not hungry.\nMushy(ronald) ::: Ronald is mushy.\nTeak(keith) ::: Keith is teak.\nPoised(crosby) ::: Crosby is poised.\nFrank(shane) ::: Shane is frank.\nPoised(gregory) ::: Gregory is poised.\n¬Poised(shane) ::: Shane is not poised.\nMushy(keith) ::: Keith is mushy.\n¬Frank(noel) ::: Noel is not frank.\nFrank(george) ::: George is frank.\nWicked(george) ::: George is wicked.\nFrank(keith) ::: Keith is frank.\n(∀x (Mushy(x) ∨ ¬Poised(x))) → (∀x (Hungry(x) ∧ ¬Wicked(x))) ::: If someone is either mushy or not poised, then he is hungry and not wicked.\n(¬Poised(gregory)) → (Mushy(shane)) ::: If Gregory is not poised, then Shane is mushy.\n(∃x (Wicked(x))) → ((¬Poised(shane) ∧ ¬Frank(george))) ::: If there is at least one people who is wicked, then Shane is not poised and George is not frank.\n((Teak(noel))) ↔ ((¬Poised(noel))) ::: If Noel is teak, then Noel is not poised, and vice versa.\n(¬∃x (¬x)) → ((Teak(shane) ∧ ¬Poised(shane))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised.\n(∀x (Wicked(x) ∧ Mushy(x))) ↔ (∀x (Poised(x))) ::: Someone is wicked and mushy if and only if he is poised.\n(∃x (Poised(x) ∨ ¬Hungry(x))) → ((¬Mushy(george))) ::: If there is at least one people who is poised or not hungry, then George is not mushy.\n(∃x (Wicked(x) ∧ ¬Teak(x))) → ((Poised(crosby))) ::: If there is at least one people who is both wicked and not teak, then Crosby is poised.\n((Teak(keith))) ↔ ((¬Poised(gregory) ∧ ¬Wicked(noel))) ::: Keith is teak if and only if Gregory is not poised and Noel is not wicked.\n((Teak(noel))) ↔ ((Hungry(shane))) ::: Noel is teak if and only if Shane is hungry.\n((¬Teak(gregory) ∧ Wicked(crosby))) → ((¬Mushy(keith))) ::: If Gregory is not teak and Crosby is wicked, then Keith is not mushy.\n(∃x (Hungry(x) ∧ Wicked(x))) → ((Teak(noel))) ::: If there is at least one people who is both hungry and wicked, then Noel is teak.\n",
                "First-Order-Logic Question": "Frank(keith) ::: Keith is frank."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "¬Hungry(gregory) ::: Gregory is not hungry.\nMushy(ronald) ::: Ronald is mushy.\nTeak(keith) ::: Keith is teak.\nPoised(crosby) ::: Crosby is poised.\nFrank(shane) ::: Shane is frank.\nPoised(gregory) ::: Gregory is poised.\n¬Poised(shane) ::: Shane is not poised.\nMushy(keith) ::: Keith is mushy.\n¬Frank(noel) ::: Noel is not frank.\nFrank(george) ::: George is frank.\nWicked(george) ::: George is wicked.\nFrank(keith) ::: Keith is frank.\n(∀x (Mushy(x) ∨ ¬Poised(x))) → (∀x (Hungry(x) ∧ ¬Wicked(x))) ::: If someone is either mushy or not poised, then he is hungry and not wicked.\n(¬Poised(gregory)) → (Mushy(shane)) ::: If Gregory is not poised, then Shane is mushy.\n(∃x (Wicked(x))) → ((¬Poised(shane) ∧ ¬Frank(george))) ::: If there is at least one people who is wicked, then Shane is not poised and George is not frank.\n((Teak(noel))) ↔ ((¬Poised(noel))) ::: If Noel is teak, then Noel is not poised, and vice versa.\n¬∃x((¬(¬Frank(x)))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised.\n(∀x (Wicked(x) ∧ Mushy(x))) ↔ (∀x (Poised(x))) ::: Someone is wicked and mushy if and only if he is poised.\n(∃x (Poised(x) ∨ ¬Hungry(x))) → ((¬Mushy(george))) ::: If there is at least one people who is poised or not hungry, then George is not mushy.\n(∃x (Wicked(x) ∧ ¬Teak(x))) → ((Poised(crosby))) ::: If there is at least one people who is both wicked and not teak, then Crosby is poised.\n((Teak(keith))) ↔ ((¬Poised(gregory) ∧ ¬Wicked(noel))) ::: Keith is teak if and only if Gregory is not poised and Noel is not wicked.\n((Teak(noel))) ↔ ((Hungry(shane))) ::: Noel is teak if and only if Shane is hungry.\n((¬Teak(gregory) ∧ Wicked(crosby))) → ((¬Mushy(keith))) ::: If Gregory is not teak and Crosby is wicked, then Keith is not mushy.\n(∃x (Hungry(x) ∧ Wicked(x))) → ((Teak(noel))) ::: If there is at least one people who is both hungry and wicked, then Noel is teak.\n",
                "First-Order-Logic Question": "Frank(keith) ::: Keith is frank."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬x)) → ((Teak(shane) ∧ ¬Poised(shane))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised.",
                    "gram": "¬∃x((¬(¬Frank(x)))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised."
                }
            ],
            "answer": "A",
            "grammar_answer": "A",
            "backup_answer": "A"
        },
        {
            "id": 360,
            "raw_prog": {
                "First-Order-Logic Rules": "¬Able(jasper) ::: Jasper is not able.\n¬Frank(jack) ::: Jack is not frank.\nCivil(jasper) ::: Jasper is civil.\n¬Civil(george) ::: George is not civil.\nFrank(burgess) ::: Burgess is frank.\nJolly(roderick) ::: Roderick is jolly.\n¬Civil(myra) ::: Myra is not civil.\nPrecious(roderick) ::: Roderick is precious.\nJolly(jack) ::: Jack is jolly.\n¬Able(burgess) ::: Burgess is not able.\n¬Jolly(miles) ::: Miles is not jolly.\nJolly(jasper) ::: Jasper is jolly.\n((Jolly(burgess))) → ((¬Able(roderick))) ::: It can be concluded that Roderick is not able once knowing that Burgess is jolly.\n(∃x (Able(x) ∧ Jolly(x))) → ((¬Frank(jasper))) ::: If there is someone who is both able and jolly, then Jasper is not frank.\n(∃x (¬Frank(x) ∨ ¬Civil(x))) → ((Able(roderick))) ::: If there is at least one people who is not frank or not civil, then Roderick is able.\n(∃x (Able(x))) → ((¬Frank(george) ∧ ¬Technical(jack))) ::: If there is someone who is able, then George is not frank and Jack is not technical.\n(¬∃x (¬x)) → ((¬Frank(jack))) ::: If there is nobody who is not, then Jack is not frank.\n(∃x (¬Frank(x) ∨ ¬Precious(x))) → ((¬Able(roderick))) ::: If there is at least one people who is not frank or not precious, then Roderick is not able.\n(∀x (Frank(x))) → (∀x (¬Precious(x) ∧ ¬Civil(x))) ::: If someone is frank, then he is neither precious nor civil.\n((¬Jolly(burgess) ∨ ¬Civil(roderick))) → ((¬Technical(george))) ::: It can be concluded that George is not technical once knowing that Burgess is not jolly or Roderick is not civil.\n(∀x (Precious(x))) ↔ (∀x (¬Frank(x))) ::: If someone is precious, then he is not frank, and vice versa.\n(∀x (x ∨ ¬Precious(x))) → (∀x (¬Jolly(x))) ::: If someone is he or not precious is technical, then he is not jolly.\n(∀x (¬Civil(x) ∧ ¬Jolly(x))) ↔ (∀x (Able(x))) ::: If someone is not civil and not jolly, then he is able, and vice versa.\n((Able(roderick))) → ((Precious(burgess) ∧ ¬Civil(jack))) ::: Roderick being able implies that Burgess is precious and Jack is not civil.\n",
                "First-Order-Logic Question": "Civil(myra) ::: Myra is civil."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "¬Able(jasper) ::: Jasper is not able.\n¬Frank(jack) ::: Jack is not frank.\nCivil(jasper) ::: Jasper is civil.\n¬Civil(george) ::: George is not civil.\nFrank(burgess) ::: Burgess is frank.\nJolly(roderick) ::: Roderick is jolly.\n¬Civil(myra) ::: Myra is not civil.\nPrecious(roderick) ::: Roderick is precious.\nJolly(jack) ::: Jack is jolly.\n¬Able(burgess) ::: Burgess is not able.\n¬Jolly(miles) ::: Miles is not jolly.\nJolly(jasper) ::: Jasper is jolly.\n((Jolly(burgess))) → ((¬Able(roderick))) ::: It can be concluded that Roderick is not able once knowing that Burgess is jolly.\n(∃x (Able(x) ∧ Jolly(x))) → ((¬Frank(jasper))) ::: If there is someone who is both able and jolly, then Jasper is not frank.\n(∃x (¬Frank(x) ∨ ¬Civil(x))) → ((Able(roderick))) ::: If there is at least one people who is not frank or not civil, then Roderick is able.\n(∃x (Able(x))) → ((¬Frank(george) ∧ ¬Technical(jack))) ::: If there is someone who is able, then George is not frank and Jack is not technical.\n¬∃x((¬Frank(x))→(¬Frank(x))) ::: If there is nobody who is not, then Jack is not frank.\n(∃x (¬Frank(x) ∨ ¬Precious(x))) → ((¬Able(roderick))) ::: If there is at least one people who is not frank or not precious, then Roderick is not able.\n(∀x (Frank(x))) → (∀x (¬Precious(x) ∧ ¬Civil(x))) ::: If someone is frank, then he is neither precious nor civil.\n((¬Jolly(burgess) ∨ ¬Civil(roderick))) → ((¬Technical(george))) ::: It can be concluded that George is not technical once knowing that Burgess is not jolly or Roderick is not civil.\n(∀x (Precious(x))) ↔ (∀x (¬Frank(x))) ::: If someone is precious, then he is not frank, and vice versa.\n∀x((Able(x)∨¬Precious(x))) ::: If someone is he or not precious is technical, then he is not jolly.\n(∀x (¬Civil(x) ∧ ¬Jolly(x))) ↔ (∀x (Able(x))) ::: If someone is not civil and not jolly, then he is able, and vice versa.\n((Able(roderick))) → ((Precious(burgess) ∧ ¬Civil(jack))) ::: Roderick being able implies that Burgess is precious and Jack is not civil.\n",
                "First-Order-Logic Question": "Civil(myra) ::: Myra is civil."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬x)) → ((¬Frank(jack))) ::: If there is nobody who is not, then Jack is not frank.",
                    "gram": "¬∃x((¬Frank(x))→(¬Frank(x))) ::: If there is nobody who is not, then Jack is not frank."
                },
                {
                    "raw": "(∀x (x ∨ ¬Precious(x))) → (∀x (¬Jolly(x))) ::: If someone is he or not precious is technical, then he is not jolly.",
                    "gram": "∀x((Able(x)∨¬Precious(x))) ::: If someone is he or not precious is technical, then he is not jolly."
                }
            ],
            "answer": "B",
            "grammar_answer": "A",
            "backup_answer": "B"
        },
        {
            "id": 361,
            "raw_prog": {
                "First-Order-Logic Rules": "¬Able(jasper) ::: Jasper is not able.\n¬Frank(jack) ::: Jack is not frank.\nCivil(jasper) ::: Jasper is civil.\n¬Civil(george) ::: George is not civil.\nFrank(burgess) ::: Burgess is frank.\nJolly(roderick) ::: Roderick is jolly.\n¬Civil(myra) ::: Myra is not civil.\nPrecious(roderick) ::: Roderick is precious.\nJolly(jack) ::: Jack is jolly.\n¬Able(burgess) ::: Burgess is not able.\n¬Jolly(miles) ::: Miles is not jolly.\nJolly(jasper) ::: Jasper is jolly.\n((Jolly(burgess))) → ((¬Able(roderick))) ::: It can be concluded that Roderick is not able once knowing that Burgess is jolly.\n(∃x (Able(x) ∧ Jolly(x))) → ((¬Frank(jasper))) ::: If there is someone who is both able and jolly, then Jasper is not frank.\n(∃x (¬Frank(x) ∨ ¬Civil(x))) → ((Able(roderick))) ::: If there is at least one people who is not frank or not civil, then Roderick is able.\n(∃x (Able(x))) → ((¬Frank(george) ∧ ¬Technical(jack))) ::: If there is someone who is able, then George is not frank and Jack is not technical.\n(¬∃x (¬x)) → ((¬Frank(jack))) ::: If there is nobody who is not, then Jack is not frank.\n(∃x (¬Frank(x) ∨ ¬Precious(x))) → ((¬Able(roderick))) ::: If there is at least one people who is not frank or not precious, then Roderick is not able.\n(∀x (Frank(x))) → (∀x (¬Precious(x) ∧ ¬Civil(x))) ::: If someone is frank, then he is neither precious nor civil.\n((¬Jolly(burgess) ∨ ¬Civil(roderick))) → ((¬Technical(george))) ::: It can be concluded that George is not technical once knowing that Burgess is not jolly or Roderick is not civil.\n(∀x (Precious(x))) ↔ (∀x (¬Frank(x))) ::: If someone is precious, then he is not frank, and vice versa.\n(∀x (x ∨ ¬Precious(x))) → (∀x (¬Jolly(x))) ::: If someone is he or not precious is technical, then he is not jolly.\n(∀x (¬Civil(x) ∧ ¬Jolly(x))) ↔ (∀x (Able(x))) ::: If someone is not civil and not jolly, then he is able, and vice versa.\n((Able(roderick))) → ((Precious(burgess) ∧ ¬Civil(jack))) ::: Roderick being able implies that Burgess is precious and Jack is not civil.\n",
                "First-Order-Logic Question": "Civil(jasper) ::: Jasper is civil."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "¬Able(jasper) ::: Jasper is not able.\n¬Frank(jack) ::: Jack is not frank.\nCivil(jasper) ::: Jasper is civil.\n¬Civil(george) ::: George is not civil.\nFrank(burgess) ::: Burgess is frank.\nJolly(roderick) ::: Roderick is jolly.\n¬Civil(myra) ::: Myra is not civil.\nPrecious(roderick) ::: Roderick is precious.\nJolly(jack) ::: Jack is jolly.\n¬Able(burgess) ::: Burgess is not able.\n¬Jolly(miles) ::: Miles is not jolly.\nJolly(jasper) ::: Jasper is jolly.\n((Jolly(burgess))) → ((¬Able(roderick))) ::: It can be concluded that Roderick is not able once knowing that Burgess is jolly.\n(∃x (Able(x) ∧ Jolly(x))) → ((¬Frank(jasper))) ::: If there is someone who is both able and jolly, then Jasper is not frank.\n(∃x (¬Frank(x) ∨ ¬Civil(x))) → ((Able(roderick))) ::: If there is at least one people who is not frank or not civil, then Roderick is able.\n(∃x (Able(x))) → ((¬Frank(george) ∧ ¬Technical(jack))) ::: If there is someone who is able, then George is not frank and Jack is not technical.\n¬∃x((¬Frank(x))→(¬Frank(x))) ::: If there is nobody who is not, then Jack is not frank.\n(∃x (¬Frank(x) ∨ ¬Precious(x))) → ((¬Able(roderick))) ::: If there is at least one people who is not frank or not precious, then Roderick is not able.\n(∀x (Frank(x))) → (∀x (¬Precious(x) ∧ ¬Civil(x))) ::: If someone is frank, then he is neither precious nor civil.\n((¬Jolly(burgess) ∨ ¬Civil(roderick))) → ((¬Technical(george))) ::: It can be concluded that George is not technical once knowing that Burgess is not jolly or Roderick is not civil.\n(∀x (Precious(x))) ↔ (∀x (¬Frank(x))) ::: If someone is precious, then he is not frank, and vice versa.\n∀x((Able(x)∨¬Precious(x))) ::: If someone is he or not precious is technical, then he is not jolly.\n(∀x (¬Civil(x) ∧ ¬Jolly(x))) ↔ (∀x (Able(x))) ::: If someone is not civil and not jolly, then he is able, and vice versa.\n((Able(roderick))) → ((Precious(burgess) ∧ ¬Civil(jack))) ::: Roderick being able implies that Burgess is precious and Jack is not civil.\n",
                "First-Order-Logic Question": "Civil(jasper) ::: Jasper is civil."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬x)) → ((¬Frank(jack))) ::: If there is nobody who is not, then Jack is not frank.",
                    "gram": "¬∃x((¬Frank(x))→(¬Frank(x))) ::: If there is nobody who is not, then Jack is not frank."
                },
                {
                    "raw": "(∀x (x ∨ ¬Precious(x))) → (∀x (¬Jolly(x))) ::: If someone is he or not precious is technical, then he is not jolly.",
                    "gram": "∀x((Able(x)∨¬Precious(x))) ::: If someone is he or not precious is technical, then he is not jolly."
                }
            ],
            "answer": "A",
            "grammar_answer": "A",
            "backup_answer": "A"
        },
        {
            "id": 362,
            "raw_prog": {
                "First-Order-Logic Rules": "¬Able(jasper) ::: Jasper is not able.\n¬Frank(jack) ::: Jack is not frank.\nCivil(jasper) ::: Jasper is civil.\n¬Civil(george) ::: George is not civil.\nFrank(burgess) ::: Burgess is frank.\nJolly(roderick) ::: Roderick is jolly.\n¬Civil(myra) ::: Myra is not civil.\nPrecious(roderick) ::: Roderick is precious.\nJolly(jack) ::: Jack is jolly.\n¬Able(burgess) ::: Burgess is not able.\n¬Jolly(miles) ::: Miles is not jolly.\nJolly(jasper) ::: Jasper is jolly.\n((Jolly(burgess))) → ((¬Able(roderick))) ::: It can be concluded that Roderick is not able once knowing that Burgess is jolly.\n(∃x (Able(x) ∧ Jolly(x))) → ((¬Frank(jasper))) ::: If there is someone who is both able and jolly, then Jasper is not frank.\n(∃x (¬Frank(x) ∨ ¬Civil(x))) → ((Able(roderick))) ::: If there is at least one people who is not frank or not civil, then Roderick is able.\n(∃x (Able(x))) → ((¬Frank(george) ∧ ¬Technical(jack))) ::: If there is someone who is able, then George is not frank and Jack is not technical.\n(¬∃x (¬x)) → ((¬Frank(jack))) ::: If there is nobody who is not, then Jack is not frank.\n(∃x (¬Frank(x) ∨ ¬Precious(x))) → ((¬Able(roderick))) ::: If there is at least one people who is not frank or not precious, then Roderick is not able.\n(∀x (Frank(x))) → (∀x (¬Precious(x) ∧ ¬Civil(x))) ::: If someone is frank, then he is neither precious nor civil.\n((¬Jolly(burgess) ∨ ¬Civil(roderick))) → ((¬Technical(george))) ::: It can be concluded that George is not technical once knowing that Burgess is not jolly or Roderick is not civil.\n(∀x (Precious(x))) ↔ (∀x (¬Frank(x))) ::: If someone is precious, then he is not frank, and vice versa.\n(∀x (x ∨ ¬Precious(x))) → (∀x (¬Jolly(x))) ::: If someone is he or not precious is technical, then he is not jolly.\n(∀x (¬Civil(x) ∧ ¬Jolly(x))) ↔ (∀x (Able(x))) ::: If someone is not civil and not jolly, then he is able, and vice versa.\n((Able(roderick))) → ((Precious(burgess) ∧ ¬Civil(jack))) ::: Roderick being able implies that Burgess is precious and Jack is not civil.\n",
                "First-Order-Logic Question": "Precious(myra) ::: Myra is precious."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "¬Able(jasper) ::: Jasper is not able.\n¬Frank(jack) ::: Jack is not frank.\nCivil(jasper) ::: Jasper is civil.\n¬Civil(george) ::: George is not civil.\nFrank(burgess) ::: Burgess is frank.\nJolly(roderick) ::: Roderick is jolly.\n¬Civil(myra) ::: Myra is not civil.\nPrecious(roderick) ::: Roderick is precious.\nJolly(jack) ::: Jack is jolly.\n¬Able(burgess) ::: Burgess is not able.\n¬Jolly(miles) ::: Miles is not jolly.\nJolly(jasper) ::: Jasper is jolly.\n((Jolly(burgess))) → ((¬Able(roderick))) ::: It can be concluded that Roderick is not able once knowing that Burgess is jolly.\n(∃x (Able(x) ∧ Jolly(x))) → ((¬Frank(jasper))) ::: If there is someone who is both able and jolly, then Jasper is not frank.\n(∃x (¬Frank(x) ∨ ¬Civil(x))) → ((Able(roderick))) ::: If there is at least one people who is not frank or not civil, then Roderick is able.\n(∃x (Able(x))) → ((¬Frank(george) ∧ ¬Technical(jack))) ::: If there is someone who is able, then George is not frank and Jack is not technical.\n¬∃x((¬Frank(x))→(¬Frank(x))) ::: If there is nobody who is not, then Jack is not frank.\n(∃x (¬Frank(x) ∨ ¬Precious(x))) → ((¬Able(roderick))) ::: If there is at least one people who is not frank or not precious, then Roderick is not able.\n(∀x (Frank(x))) → (∀x (¬Precious(x) ∧ ¬Civil(x))) ::: If someone is frank, then he is neither precious nor civil.\n((¬Jolly(burgess) ∨ ¬Civil(roderick))) → ((¬Technical(george))) ::: It can be concluded that George is not technical once knowing that Burgess is not jolly or Roderick is not civil.\n(∀x (Precious(x))) ↔ (∀x (¬Frank(x))) ::: If someone is precious, then he is not frank, and vice versa.\n∀x((Able(x)∨¬Precious(x))) ::: If someone is he or not precious is technical, then he is not jolly.\n(∀x (¬Civil(x) ∧ ¬Jolly(x))) ↔ (∀x (Able(x))) ::: If someone is not civil and not jolly, then he is able, and vice versa.\n((Able(roderick))) → ((Precious(burgess) ∧ ¬Civil(jack))) ::: Roderick being able implies that Burgess is precious and Jack is not civil.\n",
                "First-Order-Logic Question": "Precious(myra) ::: Myra is precious."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬x)) → ((¬Frank(jack))) ::: If there is nobody who is not, then Jack is not frank.",
                    "gram": "¬∃x((¬Frank(x))→(¬Frank(x))) ::: If there is nobody who is not, then Jack is not frank."
                },
                {
                    "raw": "(∀x (x ∨ ¬Precious(x))) → (∀x (¬Jolly(x))) ::: If someone is he or not precious is technical, then he is not jolly.",
                    "gram": "∀x((Able(x)∨¬Precious(x))) ::: If someone is he or not precious is technical, then he is not jolly."
                }
            ],
            "answer": "C",
            "grammar_answer": "A",
            "backup_answer": "C"
        },
        {
            "id": 363,
            "raw_prog": {
                "First-Order-Logic Rules": "¬Able(jasper) ::: Jasper is not able.\n¬Frank(jack) ::: Jack is not frank.\nCivil(jasper) ::: Jasper is civil.\n¬Civil(george) ::: George is not civil.\nFrank(burgess) ::: Burgess is frank.\nJolly(roderick) ::: Roderick is jolly.\n¬Civil(myra) ::: Myra is not civil.\nPrecious(roderick) ::: Roderick is precious.\nJolly(jack) ::: Jack is jolly.\n¬Able(burgess) ::: Burgess is not able.\n¬Jolly(miles) ::: Miles is not jolly.\nJolly(jasper) ::: Jasper is jolly.\n((Jolly(burgess))) → ((¬Able(roderick))) ::: It can be concluded that Roderick is not able once knowing that Burgess is jolly.\n(∃x (Able(x) ∧ Jolly(x))) → ((¬Frank(jasper))) ::: If there is someone who is both able and jolly, then Jasper is not frank.\n(∃x (¬Frank(x) ∨ ¬Civil(x))) → ((Able(roderick))) ::: If there is at least one people who is not frank or not civil, then Roderick is able.\n(∃x (Able(x))) → ((¬Frank(george) ∧ ¬Technical(jack))) ::: If there is someone who is able, then George is not frank and Jack is not technical.\n(¬∃x (¬x)) → ((¬Frank(jack))) ::: If there is nobody who is not, then Jack is not frank.\n(∃x (¬Frank(x) ∨ ¬Precious(x))) → ((¬Able(roderick))) ::: If there is at least one people who is not frank or not precious, then Roderick is not able.\n(∀x (Frank(x))) → (∀x (¬Precious(x) ∧ ¬Civil(x))) ::: If someone is frank, then he is neither precious nor civil.\n((¬Jolly(burgess) ∨ ¬Civil(roderick))) → ((¬Technical(george))) ::: It can be concluded that George is not technical once knowing that Burgess is not jolly or Roderick is not civil.\n(∀x (Precious(x))) → (∀x (¬Frank(x))) ∧ (∀x (¬Frank(x))) → (∀x (¬Precious(x))) ::: If someone is precious, then he is not frank, and vice versa.\n(∀x (¬Civil(x) ∧ ¬Jolly(x))) ↔ (∀x (Able(x))) ::: If someone is not civil and not jolly, then he is able, and vice versa.\n((Able(roderick))) → ((Precious(burgess) ∧ ¬Civil(jack))) ::: Roderick being able implies that Burgess is precious and Jack is not civil.\n",
                "First-Order-Logic Question": "¬Technical(burgess) ::: Burgess is not technical."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "¬Able(jasper) ::: Jasper is not able.\n¬Frank(jack) ::: Jack is not frank.\nCivil(jasper) ::: Jasper is civil.\n¬Civil(george) ::: George is not civil.\nFrank(burgess) ::: Burgess is frank.\nJolly(roderick) ::: Roderick is jolly.\n¬Civil(myra) ::: Myra is not civil.\nPrecious(roderick) ::: Roderick is precious.\nJolly(jack) ::: Jack is jolly.\n¬Able(burgess) ::: Burgess is not able.\n¬Jolly(miles) ::: Miles is not jolly.\nJolly(jasper) ::: Jasper is jolly.\n((Jolly(burgess))) → ((¬Able(roderick))) ::: It can be concluded that Roderick is not able once knowing that Burgess is jolly.\n(∃x (Able(x) ∧ Jolly(x))) → ((¬Frank(jasper))) ::: If there is someone who is both able and jolly, then Jasper is not frank.\n(∃x (¬Frank(x) ∨ ¬Civil(x))) → ((Able(roderick))) ::: If there is at least one people who is not frank or not civil, then Roderick is able.\n(∃x (Able(x))) → ((¬Frank(george) ∧ ¬Technical(jack))) ::: If there is someone who is able, then George is not frank and Jack is not technical.\n¬∃x((¬Frank(x))→(¬Frank(x))) ::: If there is nobody who is not, then Jack is not frank.\n(∃x (¬Frank(x) ∨ ¬Precious(x))) → ((¬Able(roderick))) ::: If there is at least one people who is not frank or not precious, then Roderick is not able.\n(∀x (Frank(x))) → (∀x (¬Precious(x) ∧ ¬Civil(x))) ::: If someone is frank, then he is neither precious nor civil.\n((¬Jolly(burgess) ∨ ¬Civil(roderick))) → ((¬Technical(george))) ::: It can be concluded that George is not technical once knowing that Burgess is not jolly or Roderick is not civil.\n(∀x (Precious(x))) → (∀x (¬Frank(x))) ∧ (∀x (¬Frank(x))) → (∀x (¬Precious(x))) ::: If someone is precious, then he is not frank, and vice versa.\n(∀x (¬Civil(x) ∧ ¬Jolly(x))) ↔ (∀x (Able(x))) ::: If someone is not civil and not jolly, then he is able, and vice versa.\n((Able(roderick))) → ((Precious(burgess) ∧ ¬Civil(jack))) ::: Roderick being able implies that Burgess is precious and Jack is not civil.\n",
                "First-Order-Logic Question": "¬Technical(burgess) ::: Burgess is not technical."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬x)) → ((¬Frank(jack))) ::: If there is nobody who is not, then Jack is not frank.",
                    "gram": "¬∃x((¬Frank(x))→(¬Frank(x))) ::: If there is nobody who is not, then Jack is not frank."
                }
            ],
            "answer": "C",
            "grammar_answer": "A",
            "backup_answer": "B"
        },
        {
            "id": 364,
            "raw_prog": {
                "First-Order-Logic Rules": "¬Able(jasper) ::: Jasper is not able.\n¬Frank(jack) ::: Jack is not frank.\nCivil(jasper) ::: Jasper is civil.\n¬Civil(george) ::: George is not civil.\nFrank(burgess) ::: Burgess is frank.\nJolly(roderick) ::: Roderick is jolly.\n¬Civil(myra) ::: Myra is not civil.\nPrecious(roderick) ::: Roderick is precious.\nJolly(jack) ::: Jack is jolly.\n¬Able(burgess) ::: Burgess is not able.\n¬Jolly(miles) ::: Miles is not jolly.\nJolly(jasper) ::: Jasper is jolly.\n((Jolly(burgess))) → ((¬Able(roderick))) ::: It can be concluded that Roderick is not able once knowing that Burgess is jolly.\n(∃x (Able(x) ∧ Jolly(x))) → ((¬Frank(jasper))) ::: If there is someone who is both able and jolly, then Jasper is not frank.\n(∃x (¬Frank(x) ∨ ¬Civil(x))) → ((Able(roderick))) ::: If there is at least one people who is not frank or not civil, then Roderick is able.\n(∃x (Able(x))) → ((¬Frank(george) ∧ ¬Technical(jack))) ::: If there is someone who is able, then George is not frank and Jack is not technical.\n(¬∃x (¬Frank(x))) → ((¬Frank(jack))) ::: If there is nobody who is not, then Jack is not frank.\n(∃x (¬Frank(x) ∨ ¬Precious(x))) → ((¬Able(roderick))) ::: If there is at least one people who is not frank or not precious, then Roderick is not able.\n(∀x (Frank(x))) → (∀x (¬Precious(x) ∧ ¬Civil(x))) ::: If someone is frank, then he is neither precious nor civil.\n((¬Jolly(burgess) ∨ ¬Civil(roderick))) → ((¬Technical(george))) ::: It can be concluded that George is not technical once knowing that Burgess is not jolly or Roderick is not civil.\n(∀x (Precious(x))) ↔ (∀x (¬Frank(x))) ::: If someone is precious, then he is not frank, and vice versa.\n(∀x (¬Precious(x) ∨ Technical(x))) → (∀x (¬Jolly(x))) ::: If someone is he or not precious is technical, then he is not jolly.\n(∀x (¬Civil(x) ∧ ¬Jolly(x))) ↔ (∀x (Able(x))) ::: If someone is not civil and not jolly, then he is able, and vice versa.\n((Able(roderick))) → ((Precious(burgess) ∧ ¬Civil(jack))) ::: Roderick being able implies that Burgess is precious and Jack is not civil.\n",
                "First-Order-Logic Question": "¬Precious(roderick) ::: Roderick is not precious."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "¬Able(jasper) ::: Jasper is not able.\n¬Frank(jack) ::: Jack is not frank.\nCivil(jasper) ::: Jasper is civil.\n¬Civil(george) ::: George is not civil.\nFrank(burgess) ::: Burgess is frank.\nJolly(roderick) ::: Roderick is jolly.\n¬Civil(myra) ::: Myra is not civil.\nPrecious(roderick) ::: Roderick is precious.\nJolly(jack) ::: Jack is jolly.\n¬Able(burgess) ::: Burgess is not able.\n¬Jolly(miles) ::: Miles is not jolly.\nJolly(jasper) ::: Jasper is jolly.\n((Jolly(burgess))) → ((¬Able(roderick))) ::: It can be concluded that Roderick is not able once knowing that Burgess is jolly.\n(∃x (Able(x) ∧ Jolly(x))) → ((¬Frank(jasper))) ::: If there is someone who is both able and jolly, then Jasper is not frank.\n(∃x (¬Frank(x) ∨ ¬Civil(x))) → ((Able(roderick))) ::: If there is at least one people who is not frank or not civil, then Roderick is able.\n(∃x (Able(x))) → ((¬Frank(george) ∧ ¬Technical(jack))) ::: If there is someone who is able, then George is not frank and Jack is not technical.\n¬∃x(¬Frank(x))→((¬Frank(x))) ::: If there is nobody who is not, then Jack is not frank.\n(∃x (¬Frank(x) ∨ ¬Precious(x))) → ((¬Able(roderick))) ::: If there is at least one people who is not frank or not precious, then Roderick is not able.\n(∀x (Frank(x))) → (∀x (¬Precious(x) ∧ ¬Civil(x))) ::: If someone is frank, then he is neither precious nor civil.\n((¬Jolly(burgess) ∨ ¬Civil(roderick))) → ((¬Technical(george))) ::: It can be concluded that George is not technical once knowing that Burgess is not jolly or Roderick is not civil.\n(∀x (Precious(x))) ↔ (∀x (¬Frank(x))) ::: If someone is precious, then he is not frank, and vice versa.\n(∀x (¬Precious(x) ∨ Technical(x))) → (∀x (¬Jolly(x))) ::: If someone is he or not precious is technical, then he is not jolly.\n(∀x (¬Civil(x) ∧ ¬Jolly(x))) ↔ (∀x (Able(x))) ::: If someone is not civil and not jolly, then he is able, and vice versa.\n((Able(roderick))) → ((Precious(burgess) ∧ ¬Civil(jack))) ::: Roderick being able implies that Burgess is precious and Jack is not civil.\n",
                "First-Order-Logic Question": "¬Precious(roderick) ::: Roderick is not precious."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬Frank(x))) → ((¬Frank(jack))) ::: If there is nobody who is not, then Jack is not frank.",
                    "gram": "¬∃x(¬Frank(x))→((¬Frank(x))) ::: If there is nobody who is not, then Jack is not frank."
                }
            ],
            "answer": "B",
            "grammar_answer": "A",
            "backup_answer": "B"
        },
        {
            "id": 365,
            "raw_prog": {
                "First-Order-Logic Rules": "¬Able(jasper) ::: Jasper is not able.\n¬Frank(jack) ::: Jack is not frank.\nCivil(jasper) ::: Jasper is civil.\n¬Civil(george) ::: George is not civil.\nFrank(burgess) ::: Burgess is frank.\nJolly(roderick) ::: Roderick is jolly.\n¬Civil(myra) ::: Myra is not civil.\nPrecious(roderick) ::: Roderick is precious.\nJolly(jack) ::: Jack is jolly.\n¬Able(burgess) ::: Burgess is not able.\n¬Jolly(miles) ::: Miles is not jolly.\nJolly(jasper) ::: Jasper is jolly.\n((Jolly(burgess))) → ((¬Able(roderick))) ::: It can be concluded that Roderick is not able once knowing that Burgess is jolly.\n(∃x (Able(x) ∧ Jolly(x))) → ((¬Frank(jasper))) ::: If there is someone who is both able and jolly, then Jasper is not frank.\n(∃x (¬Frank(x) ∨ ¬Civil(x))) → ((Able(roderick))) ::: If there is at least one people who is not frank or not civil, then Roderick is able.\n(∃x (Able(x))) → ((¬Frank(george) ∧ ¬Technical(jack))) ::: If there is someone who is able, then George is not frank and Jack is not technical.\n(¬∃x (¬x)) → ((¬Frank(jack))) ::: If there is nobody who is not, then Jack is not frank.\n(∃x (¬Frank(x) ∨ ¬Precious(x))) → ((¬Able(roderick))) ::: If there is at least one people who is not frank or not precious, then Roderick is not able.\n(∀x (Frank(x))) → (∀x (¬Precious(x) ∧ ¬Civil(x))) ::: If someone is frank, then he is neither precious nor civil.\n((¬Jolly(burgess) ∨ ¬Civil(roderick))) → ((¬Technical(george))) ::: It can be concluded that George is not technical once knowing that Burgess is not jolly or Roderick is not civil.\n(∀x (Precious(x))) → (∀x (¬Frank(x))) ∧ (∀x (¬Frank(x))) → (∀x (¬Precious(x))) ::: If someone is precious, then he is not frank, and vice versa.\n(∀x (¬Civil(x) ∧ ¬Jolly(x))) ↔ (∀x (Able(x))) ::: If someone is not civil and not jolly, then he is able, and vice versa.\n((Able(roderick))) → ((Precious(burgess) ∧ ¬Civil(jack))) ::: Roderick being able implies that Burgess is precious and Jack is not civil.\n",
                "First-Order-Logic Question": "Civil(roderick) ::: Roderick is civil."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "¬Able(jasper) ::: Jasper is not able.\n¬Frank(jack) ::: Jack is not frank.\nCivil(jasper) ::: Jasper is civil.\n¬Civil(george) ::: George is not civil.\nFrank(burgess) ::: Burgess is frank.\nJolly(roderick) ::: Roderick is jolly.\n¬Civil(myra) ::: Myra is not civil.\nPrecious(roderick) ::: Roderick is precious.\nJolly(jack) ::: Jack is jolly.\n¬Able(burgess) ::: Burgess is not able.\n¬Jolly(miles) ::: Miles is not jolly.\nJolly(jasper) ::: Jasper is jolly.\n((Jolly(burgess))) → ((¬Able(roderick))) ::: It can be concluded that Roderick is not able once knowing that Burgess is jolly.\n(∃x (Able(x) ∧ Jolly(x))) → ((¬Frank(jasper))) ::: If there is someone who is both able and jolly, then Jasper is not frank.\n(∃x (¬Frank(x) ∨ ¬Civil(x))) → ((Able(roderick))) ::: If there is at least one people who is not frank or not civil, then Roderick is able.\n(∃x (Able(x))) → ((¬Frank(george) ∧ ¬Technical(jack))) ::: If there is someone who is able, then George is not frank and Jack is not technical.\n¬∃x((¬Frank(x))→(¬Frank(x))) ::: If there is nobody who is not, then Jack is not frank.\n(∃x (¬Frank(x) ∨ ¬Precious(x))) → ((¬Able(roderick))) ::: If there is at least one people who is not frank or not precious, then Roderick is not able.\n(∀x (Frank(x))) → (∀x (¬Precious(x) ∧ ¬Civil(x))) ::: If someone is frank, then he is neither precious nor civil.\n((¬Jolly(burgess) ∨ ¬Civil(roderick))) → ((¬Technical(george))) ::: It can be concluded that George is not technical once knowing that Burgess is not jolly or Roderick is not civil.\n(∀x (Precious(x))) → (∀x (¬Frank(x))) ∧ (∀x (¬Frank(x))) → (∀x (¬Precious(x))) ::: If someone is precious, then he is not frank, and vice versa.\n(∀x (¬Civil(x) ∧ ¬Jolly(x))) ↔ (∀x (Able(x))) ::: If someone is not civil and not jolly, then he is able, and vice versa.\n((Able(roderick))) → ((Precious(burgess) ∧ ¬Civil(jack))) ::: Roderick being able implies that Burgess is precious and Jack is not civil.\n",
                "First-Order-Logic Question": "Civil(roderick) ::: Roderick is civil."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬x)) → ((¬Frank(jack))) ::: If there is nobody who is not, then Jack is not frank.",
                    "gram": "¬∃x((¬Frank(x))→(¬Frank(x))) ::: If there is nobody who is not, then Jack is not frank."
                }
            ],
            "answer": "B",
            "grammar_answer": "A",
            "backup_answer": "C"
        },
        {
            "id": 366,
            "raw_prog": {
                "First-Order-Logic Rules": "¬Able(jasper) ::: Jasper is not able.\n¬Frank(jack) ::: Jack is not frank.\nCivil(jasper) ::: Jasper is civil.\n¬Civil(george) ::: George is not civil.\nFrank(burgess) ::: Burgess is frank.\nJolly(roderick) ::: Roderick is jolly.\n¬Civil(myra) ::: Myra is not civil.\nPrecious(roderick) ::: Roderick is precious.\nJolly(jack) ::: Jack is jolly.\n¬Able(burgess) ::: Burgess is not able.\n¬Jolly(miles) ::: Miles is not jolly.\nJolly(jasper) ::: Jasper is jolly.\n((Jolly(burgess))) → ((¬Able(roderick))) ::: It can be concluded that Roderick is not able once knowing that Burgess is jolly.\n(∃x (Able(x) ∧ Jolly(x))) → ((¬Frank(jasper))) ::: If there is someone who is both able and jolly, then Jasper is not frank.\n(∃x (¬Frank(x) ∨ ¬Civil(x))) → ((Able(roderick))) ::: If there is at least one people who is not frank or not civil, then Roderick is able.\n(∃x (Able(x))) → ((¬Frank(george) ∧ ¬Technical(jack))) ::: If there is someone who is able, then George is not frank and Jack is not technical.\n(¬∃x (¬x)) → ((¬Frank(jack))) ::: If there is nobody who is not, then Jack is not frank.\n(∃x (¬Frank(x) ∨ ¬Precious(x))) → ((¬Able(roderick))) ::: If there is at least one people who is not frank or not precious, then Roderick is not able.\n(∀x (Frank(x))) → (∀x (¬Precious(x) ∧ ¬Civil(x))) ::: If someone is frank, then he is neither precious nor civil.\n((¬Jolly(burgess) ∨ ¬Civil(roderick))) → ((¬Technical(george))) ::: It can be concluded that George is not technical once knowing that Burgess is not jolly or Roderick is not civil.\n(∀x (Precious(x))) ↔ (∀x (¬Frank(x))) ::: If someone is precious, then he is not frank, and vice versa.\n(∀x (x ∨ ¬Precious(x))) → (∀x (¬Jolly(x))) ::: If someone is he or not precious is technical, then he is not jolly.\n(∀x (¬Civil(x) ∧ ¬Jolly(x))) ↔ (∀x (Able(x))) ::: If someone is not civil and not jolly, then he is able, and vice versa.\n((Able(roderick))) → ((Precious(burgess) ∧ ¬Civil(jack))) ::: Roderick being able implies that Burgess is precious and Jack is not civil.\n",
                "First-Order-Logic Question": "¬Technical(george) ::: George is not technical."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "¬Able(jasper) ::: Jasper is not able.\n¬Frank(jack) ::: Jack is not frank.\nCivil(jasper) ::: Jasper is civil.\n¬Civil(george) ::: George is not civil.\nFrank(burgess) ::: Burgess is frank.\nJolly(roderick) ::: Roderick is jolly.\n¬Civil(myra) ::: Myra is not civil.\nPrecious(roderick) ::: Roderick is precious.\nJolly(jack) ::: Jack is jolly.\n¬Able(burgess) ::: Burgess is not able.\n¬Jolly(miles) ::: Miles is not jolly.\nJolly(jasper) ::: Jasper is jolly.\n((Jolly(burgess))) → ((¬Able(roderick))) ::: It can be concluded that Roderick is not able once knowing that Burgess is jolly.\n(∃x (Able(x) ∧ Jolly(x))) → ((¬Frank(jasper))) ::: If there is someone who is both able and jolly, then Jasper is not frank.\n(∃x (¬Frank(x) ∨ ¬Civil(x))) → ((Able(roderick))) ::: If there is at least one people who is not frank or not civil, then Roderick is able.\n(∃x (Able(x))) → ((¬Frank(george) ∧ ¬Technical(jack))) ::: If there is someone who is able, then George is not frank and Jack is not technical.\n¬∃x((¬Frank(x))→(¬Frank(x))) ::: If there is nobody who is not, then Jack is not frank.\n(∃x (¬Frank(x) ∨ ¬Precious(x))) → ((¬Able(roderick))) ::: If there is at least one people who is not frank or not precious, then Roderick is not able.\n(∀x (Frank(x))) → (∀x (¬Precious(x) ∧ ¬Civil(x))) ::: If someone is frank, then he is neither precious nor civil.\n((¬Jolly(burgess) ∨ ¬Civil(roderick))) → ((¬Technical(george))) ::: It can be concluded that George is not technical once knowing that Burgess is not jolly or Roderick is not civil.\n(∀x (Precious(x))) ↔ (∀x (¬Frank(x))) ::: If someone is precious, then he is not frank, and vice versa.\n∀x((Able(x)∨¬Precious(x))) ::: If someone is he or not precious is technical, then he is not jolly.\n(∀x (¬Civil(x) ∧ ¬Jolly(x))) ↔ (∀x (Able(x))) ::: If someone is not civil and not jolly, then he is able, and vice versa.\n((Able(roderick))) → ((Precious(burgess) ∧ ¬Civil(jack))) ::: Roderick being able implies that Burgess is precious and Jack is not civil.\n",
                "First-Order-Logic Question": "¬Technical(george) ::: George is not technical."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬x)) → ((¬Frank(jack))) ::: If there is nobody who is not, then Jack is not frank.",
                    "gram": "¬∃x((¬Frank(x))→(¬Frank(x))) ::: If there is nobody who is not, then Jack is not frank."
                },
                {
                    "raw": "(∀x (x ∨ ¬Precious(x))) → (∀x (¬Jolly(x))) ::: If someone is he or not precious is technical, then he is not jolly.",
                    "gram": "∀x((Able(x)∨¬Precious(x))) ::: If someone is he or not precious is technical, then he is not jolly."
                }
            ],
            "answer": "A",
            "grammar_answer": "A",
            "backup_answer": "A"
        },
        {
            "id": 367,
            "raw_prog": {
                "First-Order-Logic Rules": "¬Able(jasper) ::: Jasper is not able.\n¬Frank(jack) ::: Jack is not frank.\nCivil(jasper) ::: Jasper is civil.\n¬Civil(george) ::: George is not civil.\nFrank(burgess) ::: Burgess is frank.\nJolly(roderick) ::: Roderick is jolly.\n¬Civil(myra) ::: Myra is not civil.\nPrecious(roderick) ::: Roderick is precious.\nJolly(jack) ::: Jack is jolly.\n¬Able(burgess) ::: Burgess is not able.\n¬Jolly(miles) ::: Miles is not jolly.\nJolly(jasper) ::: Jasper is jolly.\n((Jolly(burgess))) → ((¬Able(roderick))) ::: It can be concluded that Roderick is not able once knowing that Burgess is jolly.\n(∃x (Able(x) ∧ Jolly(x))) → ((¬Frank(jasper))) ::: If there is someone who is both able and jolly, then Jasper is not frank.\n(∃x (¬Frank(x) ∨ ¬Civil(x))) → ((Able(roderick))) ::: If there is at least one people who is not frank or not civil, then Roderick is able.\n(∃x (Able(x))) → ((¬Frank(george) ∧ ¬Technical(jack))) ::: If there is someone who is able, then George is not frank and Jack is not technical.\n(¬∃x (¬x)) → ((¬Frank(jack))) ::: If there is nobody who is not, then Jack is not frank.\n(∃x (¬Frank(x) ∨ ¬Precious(x))) → ((¬Able(roderick))) ::: If there is at least one people who is not frank or not precious, then Roderick is not able.\n(∀x (Frank(x))) → (∀x (¬Precious(x) ∧ ¬Civil(x))) ::: If someone is frank, then he is neither precious nor civil.\n((¬Jolly(burgess) ∨ ¬Civil(roderick))) → ((¬Technical(george))) ::: It can be concluded that George is not technical once knowing that Burgess is not jolly or Roderick is not civil.\n(∀x (Precious(x))) → (∀x (¬Frank(x))) ∧ (∀x (¬Frank(x))) → (∀x (¬Precious(x))) ::: If someone is precious, then he is not frank, and vice versa.\n(∀x (¬Civil(x) ∧ ¬Jolly(x))) ↔ (∀x (Able(x))) ::: If someone is not civil and not jolly, then he is able, and vice versa.\n((Able(roderick))) → ((Precious(burgess) ∧ ¬Civil(jack))) ::: Roderick being able implies that Burgess is precious and Jack is not civil.\n",
                "First-Order-Logic Question": "¬Jolly(miles) ::: Miles is not jolly."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "¬Able(jasper) ::: Jasper is not able.\n¬Frank(jack) ::: Jack is not frank.\nCivil(jasper) ::: Jasper is civil.\n¬Civil(george) ::: George is not civil.\nFrank(burgess) ::: Burgess is frank.\nJolly(roderick) ::: Roderick is jolly.\n¬Civil(myra) ::: Myra is not civil.\nPrecious(roderick) ::: Roderick is precious.\nJolly(jack) ::: Jack is jolly.\n¬Able(burgess) ::: Burgess is not able.\n¬Jolly(miles) ::: Miles is not jolly.\nJolly(jasper) ::: Jasper is jolly.\n((Jolly(burgess))) → ((¬Able(roderick))) ::: It can be concluded that Roderick is not able once knowing that Burgess is jolly.\n(∃x (Able(x) ∧ Jolly(x))) → ((¬Frank(jasper))) ::: If there is someone who is both able and jolly, then Jasper is not frank.\n(∃x (¬Frank(x) ∨ ¬Civil(x))) → ((Able(roderick))) ::: If there is at least one people who is not frank or not civil, then Roderick is able.\n(∃x (Able(x))) → ((¬Frank(george) ∧ ¬Technical(jack))) ::: If there is someone who is able, then George is not frank and Jack is not technical.\n¬∃x((¬Frank(x))→(¬Frank(x))) ::: If there is nobody who is not, then Jack is not frank.\n(∃x (¬Frank(x) ∨ ¬Precious(x))) → ((¬Able(roderick))) ::: If there is at least one people who is not frank or not precious, then Roderick is not able.\n(∀x (Frank(x))) → (∀x (¬Precious(x) ∧ ¬Civil(x))) ::: If someone is frank, then he is neither precious nor civil.\n((¬Jolly(burgess) ∨ ¬Civil(roderick))) → ((¬Technical(george))) ::: It can be concluded that George is not technical once knowing that Burgess is not jolly or Roderick is not civil.\n(∀x (Precious(x))) → (∀x (¬Frank(x))) ∧ (∀x (¬Frank(x))) → (∀x (¬Precious(x))) ::: If someone is precious, then he is not frank, and vice versa.\n(∀x (¬Civil(x) ∧ ¬Jolly(x))) ↔ (∀x (Able(x))) ::: If someone is not civil and not jolly, then he is able, and vice versa.\n((Able(roderick))) → ((Precious(burgess) ∧ ¬Civil(jack))) ::: Roderick being able implies that Burgess is precious and Jack is not civil.\n",
                "First-Order-Logic Question": "¬Jolly(miles) ::: Miles is not jolly."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬x)) → ((¬Frank(jack))) ::: If there is nobody who is not, then Jack is not frank.",
                    "gram": "¬∃x((¬Frank(x))→(¬Frank(x))) ::: If there is nobody who is not, then Jack is not frank."
                }
            ],
            "answer": "A",
            "grammar_answer": "A",
            "backup_answer": "A"
        },
        {
            "id": 368,
            "raw_prog": {
                "First-Order-Logic Rules": "¬Able(jasper) ::: Jasper is not able.\n¬Frank(jack) ::: Jack is not frank.\nCivil(jasper) ::: Jasper is civil.\n¬Civil(george) ::: George is not civil.\nFrank(burgess) ::: Burgess is frank.\nJolly(roderick) ::: Roderick is jolly.\n¬Civil(myra) ::: Myra is not civil.\nPrecious(roderick) ::: Roderick is precious.\nJolly(jack) ::: Jack is jolly.\n¬Able(burgess) ::: Burgess is not able.\n¬Jolly(miles) ::: Miles is not jolly.\nJolly(jasper) ::: Jasper is jolly.\n((Jolly(burgess))) → ((¬Able(roderick))) ::: It can be concluded that Roderick is not able once knowing that Burgess is jolly.\n(∃x (Able(x) ∧ Jolly(x))) → ((¬Frank(jasper))) ::: If there is someone who is both able and jolly, then Jasper is not frank.\n(∃x (¬Frank(x) ∨ ¬Civil(x))) → ((Able(roderick))) ::: If there is at least one people who is not frank or not civil, then Roderick is able.\n(∃x (Able(x))) → ((¬Frank(george) ∧ ¬Technical(jack))) ::: If there is someone who is able, then George is not frank and Jack is not technical.\n(¬∃x (¬Frank(x))) → ((¬Frank(jack))) ::: If there is nobody who is not, then Jack is not frank.\n(∃x (¬Frank(x) ∨ ¬Precious(x))) → ((¬Able(roderick))) ::: If there is at least one people who is not frank or not precious, then Roderick is not able.\n(∀x (Frank(x))) → (∀x (¬Precious(x) ∧ ¬Civil(x))) ::: If someone is frank, then he is neither precious nor civil.\n((¬Jolly(burgess) ∨ ¬Civil(roderick))) → ((¬Technical(george))) ::: It can be concluded that George is not technical once knowing that Burgess is not jolly or Roderick is not civil.\n(∀x (Precious(x))) ↔ (∀x (¬Frank(x))) ::: If someone is precious, then he is not frank, and vice versa.\n(∀x (¬Precious(x) ∨ Technical(x))) → (∀x (¬Jolly(x))) ::: If someone is he or not precious is technical, then he is not jolly.\n(∀x (¬Civil(x) ∧ ¬Jolly(x))) ↔ (∀x (Able(x))) ::: If someone is not civil and not jolly, then he is able, and vice versa.\n((Able(roderick))) → ((Precious(burgess) ∧ ¬Civil(jack))) ::: Roderick being able implies that Burgess is precious and Jack is not civil.\n",
                "First-Order-Logic Question": "¬Jolly(george) ::: George is not jolly."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "¬Able(jasper) ::: Jasper is not able.\n¬Frank(jack) ::: Jack is not frank.\nCivil(jasper) ::: Jasper is civil.\n¬Civil(george) ::: George is not civil.\nFrank(burgess) ::: Burgess is frank.\nJolly(roderick) ::: Roderick is jolly.\n¬Civil(myra) ::: Myra is not civil.\nPrecious(roderick) ::: Roderick is precious.\nJolly(jack) ::: Jack is jolly.\n¬Able(burgess) ::: Burgess is not able.\n¬Jolly(miles) ::: Miles is not jolly.\nJolly(jasper) ::: Jasper is jolly.\n((Jolly(burgess))) → ((¬Able(roderick))) ::: It can be concluded that Roderick is not able once knowing that Burgess is jolly.\n(∃x (Able(x) ∧ Jolly(x))) → ((¬Frank(jasper))) ::: If there is someone who is both able and jolly, then Jasper is not frank.\n(∃x (¬Frank(x) ∨ ¬Civil(x))) → ((Able(roderick))) ::: If there is at least one people who is not frank or not civil, then Roderick is able.\n(∃x (Able(x))) → ((¬Frank(george) ∧ ¬Technical(jack))) ::: If there is someone who is able, then George is not frank and Jack is not technical.\n¬∃x(¬Frank(x))→((¬Frank(x))) ::: If there is nobody who is not, then Jack is not frank.\n(∃x (¬Frank(x) ∨ ¬Precious(x))) → ((¬Able(roderick))) ::: If there is at least one people who is not frank or not precious, then Roderick is not able.\n(∀x (Frank(x))) → (∀x (¬Precious(x) ∧ ¬Civil(x))) ::: If someone is frank, then he is neither precious nor civil.\n((¬Jolly(burgess) ∨ ¬Civil(roderick))) → ((¬Technical(george))) ::: It can be concluded that George is not technical once knowing that Burgess is not jolly or Roderick is not civil.\n(∀x (Precious(x))) ↔ (∀x (¬Frank(x))) ::: If someone is precious, then he is not frank, and vice versa.\n(∀x (¬Precious(x) ∨ Technical(x))) → (∀x (¬Jolly(x))) ::: If someone is he or not precious is technical, then he is not jolly.\n(∀x (¬Civil(x) ∧ ¬Jolly(x))) ↔ (∀x (Able(x))) ::: If someone is not civil and not jolly, then he is able, and vice versa.\n((Able(roderick))) → ((Precious(burgess) ∧ ¬Civil(jack))) ::: Roderick being able implies that Burgess is precious and Jack is not civil.\n",
                "First-Order-Logic Question": "¬Jolly(george) ::: George is not jolly."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬Frank(x))) → ((¬Frank(jack))) ::: If there is nobody who is not, then Jack is not frank.",
                    "gram": "¬∃x(¬Frank(x))→((¬Frank(x))) ::: If there is nobody who is not, then Jack is not frank."
                }
            ],
            "answer": "C",
            "grammar_answer": "A",
            "backup_answer": "C"
        },
        {
            "id": 369,
            "raw_prog": {
                "First-Order-Logic Rules": "¬Able(jasper) ::: Jasper is not able.\n¬Frank(jack) ::: Jack is not frank.\nCivil(jasper) ::: Jasper is civil.\n¬Civil(george) ::: George is not civil.\nFrank(burgess) ::: Burgess is frank.\nJolly(roderick) ::: Roderick is jolly.\n¬Civil(myra) ::: Myra is not civil.\nPrecious(roderick) ::: Roderick is precious.\nJolly(jack) ::: Jack is jolly.\n¬Able(burgess) ::: Burgess is not able.\n¬Jolly(miles) ::: Miles is not jolly.\nJolly(jasper) ::: Jasper is jolly.\n((Jolly(burgess))) → ((¬Able(roderick))) ::: It can be concluded that Roderick is not able once knowing that Burgess is jolly.\n(∃x (Able(x) ∧ Jolly(x))) → ((¬Frank(jasper))) ::: If there is someone who is both able and jolly, then Jasper is not frank.\n(∃x (¬Frank(x) ∨ ¬Civil(x))) → ((Able(roderick))) ::: If there is at least one people who is not frank or not civil, then Roderick is able.\n(∃x (Able(x))) → ((¬Frank(george) ∧ ¬Technical(jack))) ::: If there is someone who is able, then George is not frank and Jack is not technical.\n(¬∃x (¬Frank(x))) → ((¬Frank(jack))) ::: If there is nobody who is not, then Jack is not frank.\n(∃x (¬Frank(x) ∨ ¬Precious(x))) → ((¬Able(roderick))) ::: If there is at least one people who is not frank or not precious, then Roderick is not able.\n(∀x (Frank(x))) → (∀x (¬Precious(x) ∧ ¬Civil(x))) ::: If someone is frank, then he is neither precious nor civil.\n((¬Jolly(burgess) ∨ ¬Civil(roderick))) → ((¬Technical(george))) ::: It can be concluded that George is not technical once knowing that Burgess is not jolly or Roderick is not civil.\n(∀x (Precious(x))) ↔ (∀x (¬Frank(x))) ::: If someone is precious, then he is not frank, and vice versa.\n(∀x (¬Precious(x) ∨ Technical(x))) → (∀x (¬Jolly(x))) ::: If someone is he or not precious is technical, then he is not jolly.\n(∀x (¬Civil(x) ∧ ¬Jolly(x))) ↔ (∀x (Able(x))) ::: If someone is not civil and not jolly, then he is able, and vice versa.\n((Able(roderick))) → ((Precious(burgess) ∧ ¬Civil(jack))) ::: Roderick being able implies that Burgess is precious and Jack is not civil.\n",
                "First-Order-Logic Question": "¬Frank(jack) ::: Jack is not frank."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "¬Able(jasper) ::: Jasper is not able.\n¬Frank(jack) ::: Jack is not frank.\nCivil(jasper) ::: Jasper is civil.\n¬Civil(george) ::: George is not civil.\nFrank(burgess) ::: Burgess is frank.\nJolly(roderick) ::: Roderick is jolly.\n¬Civil(myra) ::: Myra is not civil.\nPrecious(roderick) ::: Roderick is precious.\nJolly(jack) ::: Jack is jolly.\n¬Able(burgess) ::: Burgess is not able.\n¬Jolly(miles) ::: Miles is not jolly.\nJolly(jasper) ::: Jasper is jolly.\n((Jolly(burgess))) → ((¬Able(roderick))) ::: It can be concluded that Roderick is not able once knowing that Burgess is jolly.\n(∃x (Able(x) ∧ Jolly(x))) → ((¬Frank(jasper))) ::: If there is someone who is both able and jolly, then Jasper is not frank.\n(∃x (¬Frank(x) ∨ ¬Civil(x))) → ((Able(roderick))) ::: If there is at least one people who is not frank or not civil, then Roderick is able.\n(∃x (Able(x))) → ((¬Frank(george) ∧ ¬Technical(jack))) ::: If there is someone who is able, then George is not frank and Jack is not technical.\n¬∃x(¬Frank(x))→((¬Frank(x))) ::: If there is nobody who is not, then Jack is not frank.\n(∃x (¬Frank(x) ∨ ¬Precious(x))) → ((¬Able(roderick))) ::: If there is at least one people who is not frank or not precious, then Roderick is not able.\n(∀x (Frank(x))) → (∀x (¬Precious(x) ∧ ¬Civil(x))) ::: If someone is frank, then he is neither precious nor civil.\n((¬Jolly(burgess) ∨ ¬Civil(roderick))) → ((¬Technical(george))) ::: It can be concluded that George is not technical once knowing that Burgess is not jolly or Roderick is not civil.\n(∀x (Precious(x))) ↔ (∀x (¬Frank(x))) ::: If someone is precious, then he is not frank, and vice versa.\n(∀x (¬Precious(x) ∨ Technical(x))) → (∀x (¬Jolly(x))) ::: If someone is he or not precious is technical, then he is not jolly.\n(∀x (¬Civil(x) ∧ ¬Jolly(x))) ↔ (∀x (Able(x))) ::: If someone is not civil and not jolly, then he is able, and vice versa.\n((Able(roderick))) → ((Precious(burgess) ∧ ¬Civil(jack))) ::: Roderick being able implies that Burgess is precious and Jack is not civil.\n",
                "First-Order-Logic Question": "¬Frank(jack) ::: Jack is not frank."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬Frank(x))) → ((¬Frank(jack))) ::: If there is nobody who is not, then Jack is not frank.",
                    "gram": "¬∃x(¬Frank(x))→((¬Frank(x))) ::: If there is nobody who is not, then Jack is not frank."
                }
            ],
            "answer": "A",
            "grammar_answer": "A",
            "backup_answer": "A"
        },
        {
            "id": 370,
            "raw_prog": {
                "First-Order-Logic Rules": "¬Able(jasper) ::: Jasper is not able.\n¬Frank(jack) ::: Jack is not frank.\nCivil(jasper) ::: Jasper is civil.\n¬Civil(george) ::: George is not civil.\nFrank(burgess) ::: Burgess is frank.\nJolly(roderick) ::: Roderick is jolly.\n¬Civil(myra) ::: Myra is not civil.\nPrecious(roderick) ::: Roderick is precious.\nJolly(jack) ::: Jack is jolly.\n¬Able(burgess) ::: Burgess is not able.\n¬Jolly(miles) ::: Miles is not jolly.\nJolly(jasper) ::: Jasper is jolly.\n((Jolly(burgess))) → ((¬Able(roderick))) ::: It can be concluded that Roderick is not able once knowing that Burgess is jolly.\n(∃x (Able(x) ∧ Jolly(x))) → ((¬Frank(jasper))) ::: If there is someone who is both able and jolly, then Jasper is not frank.\n(∃x (¬Frank(x) ∨ ¬Civil(x))) → ((Able(roderick))) ::: If there is at least one people who is not frank or not civil, then Roderick is able.\n(∃x (Able(x))) → ((¬Frank(george) ∧ ¬Technical(jack))) ::: If there is someone who is able, then George is not frank and Jack is not technical.\n(¬∃x (¬x)) → ((¬Frank(jack))) ::: If there is nobody who is not, then Jack is not frank.\n(∃x (¬Frank(x) ∨ ¬Precious(x))) → ((¬Able(roderick))) ::: If there is at least one people who is not frank or not precious, then Roderick is not able.\n(∀x (Frank(x))) → (∀x (¬Precious(x) ∧ ¬Civil(x))) ::: If someone is frank, then he is neither precious nor civil.\n((¬Jolly(burgess) ∨ ¬Civil(roderick))) → ((¬Technical(george))) ::: It can be concluded that George is not technical once knowing that Burgess is not jolly or Roderick is not civil.\n(∀x (Precious(x))) → (∀x (¬Frank(x))) ∧ (∀x (¬Frank(x))) → (∀x (¬Precious(x))) ::: If someone is precious, then he is not frank, and vice versa.\n(∀x (¬Civil(x) ∧ ¬Jolly(x))) ↔ (∀x (Able(x))) ::: If someone is not civil and not jolly, then he is able, and vice versa.\n((Able(roderick))) → ((Precious(burgess) ∧ ¬Civil(jack))) ::: Roderick being able implies that Burgess is precious and Jack is not civil.\n",
                "First-Order-Logic Question": "¬Frank(roderick) ::: Roderick is not frank."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "¬Able(jasper) ::: Jasper is not able.\n¬Frank(jack) ::: Jack is not frank.\nCivil(jasper) ::: Jasper is civil.\n¬Civil(george) ::: George is not civil.\nFrank(burgess) ::: Burgess is frank.\nJolly(roderick) ::: Roderick is jolly.\n¬Civil(myra) ::: Myra is not civil.\nPrecious(roderick) ::: Roderick is precious.\nJolly(jack) ::: Jack is jolly.\n¬Able(burgess) ::: Burgess is not able.\n¬Jolly(miles) ::: Miles is not jolly.\nJolly(jasper) ::: Jasper is jolly.\n((Jolly(burgess))) → ((¬Able(roderick))) ::: It can be concluded that Roderick is not able once knowing that Burgess is jolly.\n(∃x (Able(x) ∧ Jolly(x))) → ((¬Frank(jasper))) ::: If there is someone who is both able and jolly, then Jasper is not frank.\n(∃x (¬Frank(x) ∨ ¬Civil(x))) → ((Able(roderick))) ::: If there is at least one people who is not frank or not civil, then Roderick is able.\n(∃x (Able(x))) → ((¬Frank(george) ∧ ¬Technical(jack))) ::: If there is someone who is able, then George is not frank and Jack is not technical.\n¬∃x((¬Frank(x))→(¬Frank(x))) ::: If there is nobody who is not, then Jack is not frank.\n(∃x (¬Frank(x) ∨ ¬Precious(x))) → ((¬Able(roderick))) ::: If there is at least one people who is not frank or not precious, then Roderick is not able.\n(∀x (Frank(x))) → (∀x (¬Precious(x) ∧ ¬Civil(x))) ::: If someone is frank, then he is neither precious nor civil.\n((¬Jolly(burgess) ∨ ¬Civil(roderick))) → ((¬Technical(george))) ::: It can be concluded that George is not technical once knowing that Burgess is not jolly or Roderick is not civil.\n(∀x (Precious(x))) → (∀x (¬Frank(x))) ∧ (∀x (¬Frank(x))) → (∀x (¬Precious(x))) ::: If someone is precious, then he is not frank, and vice versa.\n(∀x (¬Civil(x) ∧ ¬Jolly(x))) ↔ (∀x (Able(x))) ::: If someone is not civil and not jolly, then he is able, and vice versa.\n((Able(roderick))) → ((Precious(burgess) ∧ ¬Civil(jack))) ::: Roderick being able implies that Burgess is precious and Jack is not civil.\n",
                "First-Order-Logic Question": "¬Frank(roderick) ::: Roderick is not frank."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬x)) → ((¬Frank(jack))) ::: If there is nobody who is not, then Jack is not frank.",
                    "gram": "¬∃x((¬Frank(x))→(¬Frank(x))) ::: If there is nobody who is not, then Jack is not frank."
                }
            ],
            "answer": "A",
            "grammar_answer": "A",
            "backup_answer": "A"
        },
        {
            "id": 371,
            "raw_prog": {
                "First-Order-Logic Rules": "¬Able(jasper) ::: Jasper is not able.\n¬Frank(jack) ::: Jack is not frank.\nCivil(jasper) ::: Jasper is civil.\n¬Civil(george) ::: George is not civil.\nFrank(burgess) ::: Burgess is frank.\nJolly(roderick) ::: Roderick is jolly.\n¬Civil(myra) ::: Myra is not civil.\nPrecious(roderick) ::: Roderick is precious.\nJolly(jack) ::: Jack is jolly.\n¬Able(burgess) ::: Burgess is not able.\n¬Jolly(miles) ::: Miles is not jolly.\nJolly(jasper) ::: Jasper is jolly.\n((Jolly(burgess))) → ((¬Able(roderick))) ::: It can be concluded that Roderick is not able once knowing that Burgess is jolly.\n(∃x (Able(x) ∧ Jolly(x))) → ((¬Frank(jasper))) ::: If there is someone who is both able and jolly, then Jasper is not frank.\n(∃x (¬Frank(x) ∨ ¬Civil(x))) → ((Able(roderick))) ::: If there is at least one people who is not frank or not civil, then Roderick is able.\n(∃x (Able(x))) → ((¬Frank(george) ∧ ¬Technical(jack))) ::: If there is someone who is able, then George is not frank and Jack is not technical.\n(¬∃x (¬Frank(x))) → ((¬Frank(jack))) ::: If there is nobody who is not, then Jack is not frank.\n(∃x (¬Frank(x) ∨ ¬Precious(x))) → ((¬Able(roderick))) ::: If there is at least one people who is not frank or not precious, then Roderick is not able.\n(∀x (Frank(x))) → (∀x (¬Precious(x) ∧ ¬Civil(x))) ::: If someone is frank, then he is neither precious nor civil.\n((¬Jolly(burgess) ∨ ¬Civil(roderick))) → ((¬Technical(george))) ::: It can be concluded that George is not technical once knowing that Burgess is not jolly or Roderick is not civil.\n(∀x (Precious(x))) ↔ (∀x (¬Frank(x))) ::: If someone is precious, then he is not frank, and vice versa.\n(∀x (¬Precious(x) ∨ Technical(x))) → (∀x (¬Jolly(x))) ::: If someone is he or not precious is technical, then he is not jolly.\n(∀x (¬Civil(x) ∧ ¬Jolly(x))) ↔ (∀x (Able(x))) ::: If someone is not civil and not jolly, then he is able, and vice versa.\n((Able(roderick))) → ((Precious(burgess) ∧ ¬Civil(jack))) ::: Roderick being able implies that Burgess is precious and Jack is not civil.\n",
                "First-Order-Logic Question": "¬Able(myra) ::: Myra is not able."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "¬Able(jasper) ::: Jasper is not able.\n¬Frank(jack) ::: Jack is not frank.\nCivil(jasper) ::: Jasper is civil.\n¬Civil(george) ::: George is not civil.\nFrank(burgess) ::: Burgess is frank.\nJolly(roderick) ::: Roderick is jolly.\n¬Civil(myra) ::: Myra is not civil.\nPrecious(roderick) ::: Roderick is precious.\nJolly(jack) ::: Jack is jolly.\n¬Able(burgess) ::: Burgess is not able.\n¬Jolly(miles) ::: Miles is not jolly.\nJolly(jasper) ::: Jasper is jolly.\n((Jolly(burgess))) → ((¬Able(roderick))) ::: It can be concluded that Roderick is not able once knowing that Burgess is jolly.\n(∃x (Able(x) ∧ Jolly(x))) → ((¬Frank(jasper))) ::: If there is someone who is both able and jolly, then Jasper is not frank.\n(∃x (¬Frank(x) ∨ ¬Civil(x))) → ((Able(roderick))) ::: If there is at least one people who is not frank or not civil, then Roderick is able.\n(∃x (Able(x))) → ((¬Frank(george) ∧ ¬Technical(jack))) ::: If there is someone who is able, then George is not frank and Jack is not technical.\n¬∃x(¬Frank(x))→((¬Frank(x))) ::: If there is nobody who is not, then Jack is not frank.\n(∃x (¬Frank(x) ∨ ¬Precious(x))) → ((¬Able(roderick))) ::: If there is at least one people who is not frank or not precious, then Roderick is not able.\n(∀x (Frank(x))) → (∀x (¬Precious(x) ∧ ¬Civil(x))) ::: If someone is frank, then he is neither precious nor civil.\n((¬Jolly(burgess) ∨ ¬Civil(roderick))) → ((¬Technical(george))) ::: It can be concluded that George is not technical once knowing that Burgess is not jolly or Roderick is not civil.\n(∀x (Precious(x))) ↔ (∀x (¬Frank(x))) ::: If someone is precious, then he is not frank, and vice versa.\n(∀x (¬Precious(x) ∨ Technical(x))) → (∀x (¬Jolly(x))) ::: If someone is he or not precious is technical, then he is not jolly.\n(∀x (¬Civil(x) ∧ ¬Jolly(x))) ↔ (∀x (Able(x))) ::: If someone is not civil and not jolly, then he is able, and vice versa.\n((Able(roderick))) → ((Precious(burgess) ∧ ¬Civil(jack))) ::: Roderick being able implies that Burgess is precious and Jack is not civil.\n",
                "First-Order-Logic Question": "¬Able(myra) ::: Myra is not able."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬Frank(x))) → ((¬Frank(jack))) ::: If there is nobody who is not, then Jack is not frank.",
                    "gram": "¬∃x(¬Frank(x))→((¬Frank(x))) ::: If there is nobody who is not, then Jack is not frank."
                }
            ],
            "answer": "C",
            "grammar_answer": "A",
            "backup_answer": "B"
        },
        {
            "id": 372,
            "raw_prog": {
                "First-Order-Logic Rules": "¬Able(jasper) ::: Jasper is not able.\n¬Frank(jack) ::: Jack is not frank.\nCivil(jasper) ::: Jasper is civil.\n¬Civil(george) ::: George is not civil.\nFrank(burgess) ::: Burgess is frank.\nJolly(roderick) ::: Roderick is jolly.\n¬Civil(myra) ::: Myra is not civil.\nPrecious(roderick) ::: Roderick is precious.\nJolly(jack) ::: Jack is jolly.\n¬Able(burgess) ::: Burgess is not able.\n¬Jolly(miles) ::: Miles is not jolly.\nJolly(jasper) ::: Jasper is jolly.\n((Jolly(burgess))) → ((¬Able(roderick))) ::: It can be concluded that Roderick is not able once knowing that Burgess is jolly.\n(∃x (Able(x) ∧ Jolly(x))) → ((¬Frank(jasper))) ::: If there is someone who is both able and jolly, then Jasper is not frank.\n(∃x (¬Frank(x) ∨ ¬Civil(x))) → ((Able(roderick))) ::: If there is at least one people who is not frank or not civil, then Roderick is able.\n(∃x (Able(x))) → ((¬Frank(george) ∧ ¬Technical(jack))) ::: If there is someone who is able, then George is not frank and Jack is not technical.\n(¬∃x (¬Frank(x))) → ((¬Frank(jack))) ::: If there is nobody who is not, then Jack is not frank.\n(∃x (¬Frank(x) ∨ ¬Precious(x))) → ((¬Able(roderick))) ::: If there is at least one people who is not frank or not precious, then Roderick is not able.\n(∀x (Frank(x))) → (∀x (¬Precious(x) ∧ ¬Civil(x))) ::: If someone is frank, then he is neither precious nor civil.\n((¬Jolly(burgess) ∨ ¬Civil(roderick))) → ((¬Technical(george))) ::: It can be concluded that George is not technical once knowing that Burgess is not jolly or Roderick is not civil.\n(∀x (Precious(x))) ↔ (∀x (¬Frank(x))) ::: If someone is precious, then he is not frank, and vice versa.\n(∀x (¬Precious(x) ∨ Technical(x))) → (∀x (¬Jolly(x))) ::: If someone is he or not precious is technical, then he is not jolly.\n(∀x (¬Civil(x) ∧ ¬Jolly(x))) ↔ (∀x (Able(x))) ::: If someone is not civil and not jolly, then he is able, and vice versa.\n((Able(roderick))) → ((Precious(burgess) ∧ ¬Civil(jack))) ::: Roderick being able implies that Burgess is precious and Jack is not civil.\n",
                "First-Order-Logic Question": "¬Jolly(jack) ::: Jack is not jolly."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "¬Able(jasper) ::: Jasper is not able.\n¬Frank(jack) ::: Jack is not frank.\nCivil(jasper) ::: Jasper is civil.\n¬Civil(george) ::: George is not civil.\nFrank(burgess) ::: Burgess is frank.\nJolly(roderick) ::: Roderick is jolly.\n¬Civil(myra) ::: Myra is not civil.\nPrecious(roderick) ::: Roderick is precious.\nJolly(jack) ::: Jack is jolly.\n¬Able(burgess) ::: Burgess is not able.\n¬Jolly(miles) ::: Miles is not jolly.\nJolly(jasper) ::: Jasper is jolly.\n((Jolly(burgess))) → ((¬Able(roderick))) ::: It can be concluded that Roderick is not able once knowing that Burgess is jolly.\n(∃x (Able(x) ∧ Jolly(x))) → ((¬Frank(jasper))) ::: If there is someone who is both able and jolly, then Jasper is not frank.\n(∃x (¬Frank(x) ∨ ¬Civil(x))) → ((Able(roderick))) ::: If there is at least one people who is not frank or not civil, then Roderick is able.\n(∃x (Able(x))) → ((¬Frank(george) ∧ ¬Technical(jack))) ::: If there is someone who is able, then George is not frank and Jack is not technical.\n¬∃x(¬Frank(x))→((¬Frank(x))) ::: If there is nobody who is not, then Jack is not frank.\n(∃x (¬Frank(x) ∨ ¬Precious(x))) → ((¬Able(roderick))) ::: If there is at least one people who is not frank or not precious, then Roderick is not able.\n(∀x (Frank(x))) → (∀x (¬Precious(x) ∧ ¬Civil(x))) ::: If someone is frank, then he is neither precious nor civil.\n((¬Jolly(burgess) ∨ ¬Civil(roderick))) → ((¬Technical(george))) ::: It can be concluded that George is not technical once knowing that Burgess is not jolly or Roderick is not civil.\n(∀x (Precious(x))) ↔ (∀x (¬Frank(x))) ::: If someone is precious, then he is not frank, and vice versa.\n(∀x (¬Precious(x) ∨ Technical(x))) → (∀x (¬Jolly(x))) ::: If someone is he or not precious is technical, then he is not jolly.\n(∀x (¬Civil(x) ∧ ¬Jolly(x))) ↔ (∀x (Able(x))) ::: If someone is not civil and not jolly, then he is able, and vice versa.\n((Able(roderick))) → ((Precious(burgess) ∧ ¬Civil(jack))) ::: Roderick being able implies that Burgess is precious and Jack is not civil.\n",
                "First-Order-Logic Question": "¬Jolly(jack) ::: Jack is not jolly."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬Frank(x))) → ((¬Frank(jack))) ::: If there is nobody who is not, then Jack is not frank.",
                    "gram": "¬∃x(¬Frank(x))→((¬Frank(x))) ::: If there is nobody who is not, then Jack is not frank."
                }
            ],
            "answer": "B",
            "grammar_answer": "A",
            "backup_answer": "B"
        },
        {
            "id": 373,
            "raw_prog": {
                "First-Order-Logic Rules": "¬Able(jasper) ::: Jasper is not able.\n¬Frank(jack) ::: Jack is not frank.\nCivil(jasper) ::: Jasper is civil.\n¬Civil(george) ::: George is not civil.\nFrank(burgess) ::: Burgess is frank.\nJolly(roderick) ::: Roderick is jolly.\n¬Civil(myra) ::: Myra is not civil.\nPrecious(roderick) ::: Roderick is precious.\nJolly(jack) ::: Jack is jolly.\n¬Able(burgess) ::: Burgess is not able.\n¬Jolly(miles) ::: Miles is not jolly.\nJolly(jasper) ::: Jasper is jolly.\n((Jolly(burgess))) → ((¬Able(roderick))) ::: It can be concluded that Roderick is not able once knowing that Burgess is jolly.\n(∃x (Able(x) ∧ Jolly(x))) → ((¬Frank(jasper))) ::: If there is someone who is both able and jolly, then Jasper is not frank.\n(∃x (¬Frank(x) ∨ ¬Civil(x))) → ((Able(roderick))) ::: If there is at least one people who is not frank or not civil, then Roderick is able.\n(∃x (Able(x))) → ((¬Frank(george) ∧ ¬Technical(jack))) ::: If there is someone who is able, then George is not frank and Jack is not technical.\n(¬∃x (¬x)) → ((¬Frank(jack))) ::: If there is nobody who is not, then Jack is not frank.\n(∃x (¬Frank(x) ∨ ¬Precious(x))) → ((¬Able(roderick))) ::: If there is at least one people who is not frank or not precious, then Roderick is not able.\n(∀x (Frank(x))) → (∀x (¬Precious(x) ∧ ¬Civil(x))) ::: If someone is frank, then he is neither precious nor civil.\n((¬Jolly(burgess) ∨ ¬Civil(roderick))) → ((¬Technical(george))) ::: It can be concluded that George is not technical once knowing that Burgess is not jolly or Roderick is not civil.\n(∀x (Precious(x))) ↔ (∀x (¬Frank(x))) ::: If someone is precious, then he is not frank, and vice versa.\n(∀x (x ∨ ¬Precious(x))) → (∀x (¬Jolly(x))) ::: If someone is he or not precious is technical, then he is not jolly.\n(∀x (¬Civil(x) ∧ ¬Jolly(x))) ↔ (∀x (Able(x))) ::: If someone is not civil and not jolly, then he is able, and vice versa.\n((Able(roderick))) → ((Precious(burgess) ∧ ¬Civil(jack))) ::: Roderick being able implies that Burgess is precious and Jack is not civil.\n",
                "First-Order-Logic Question": "Jolly(george) ::: George is jolly."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "¬Able(jasper) ::: Jasper is not able.\n¬Frank(jack) ::: Jack is not frank.\nCivil(jasper) ::: Jasper is civil.\n¬Civil(george) ::: George is not civil.\nFrank(burgess) ::: Burgess is frank.\nJolly(roderick) ::: Roderick is jolly.\n¬Civil(myra) ::: Myra is not civil.\nPrecious(roderick) ::: Roderick is precious.\nJolly(jack) ::: Jack is jolly.\n¬Able(burgess) ::: Burgess is not able.\n¬Jolly(miles) ::: Miles is not jolly.\nJolly(jasper) ::: Jasper is jolly.\n((Jolly(burgess))) → ((¬Able(roderick))) ::: It can be concluded that Roderick is not able once knowing that Burgess is jolly.\n(∃x (Able(x) ∧ Jolly(x))) → ((¬Frank(jasper))) ::: If there is someone who is both able and jolly, then Jasper is not frank.\n(∃x (¬Frank(x) ∨ ¬Civil(x))) → ((Able(roderick))) ::: If there is at least one people who is not frank or not civil, then Roderick is able.\n(∃x (Able(x))) → ((¬Frank(george) ∧ ¬Technical(jack))) ::: If there is someone who is able, then George is not frank and Jack is not technical.\n¬∃x((¬Frank(x))→(¬Frank(x))) ::: If there is nobody who is not, then Jack is not frank.\n(∃x (¬Frank(x) ∨ ¬Precious(x))) → ((¬Able(roderick))) ::: If there is at least one people who is not frank or not precious, then Roderick is not able.\n(∀x (Frank(x))) → (∀x (¬Precious(x) ∧ ¬Civil(x))) ::: If someone is frank, then he is neither precious nor civil.\n((¬Jolly(burgess) ∨ ¬Civil(roderick))) → ((¬Technical(george))) ::: It can be concluded that George is not technical once knowing that Burgess is not jolly or Roderick is not civil.\n(∀x (Precious(x))) ↔ (∀x (¬Frank(x))) ::: If someone is precious, then he is not frank, and vice versa.\n∀x((Able(x)∨¬Precious(x))) ::: If someone is he or not precious is technical, then he is not jolly.\n(∀x (¬Civil(x) ∧ ¬Jolly(x))) ↔ (∀x (Able(x))) ::: If someone is not civil and not jolly, then he is able, and vice versa.\n((Able(roderick))) → ((Precious(burgess) ∧ ¬Civil(jack))) ::: Roderick being able implies that Burgess is precious and Jack is not civil.\n",
                "First-Order-Logic Question": "Jolly(george) ::: George is jolly."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬x)) → ((¬Frank(jack))) ::: If there is nobody who is not, then Jack is not frank.",
                    "gram": "¬∃x((¬Frank(x))→(¬Frank(x))) ::: If there is nobody who is not, then Jack is not frank."
                },
                {
                    "raw": "(∀x (x ∨ ¬Precious(x))) → (∀x (¬Jolly(x))) ::: If someone is he or not precious is technical, then he is not jolly.",
                    "gram": "∀x((Able(x)∨¬Precious(x))) ::: If someone is he or not precious is technical, then he is not jolly."
                }
            ],
            "answer": "C",
            "grammar_answer": "A",
            "backup_answer": "C"
        },
        {
            "id": 374,
            "raw_prog": {
                "First-Order-Logic Rules": "¬Able(jasper) ::: Jasper is not able.\n¬Frank(jack) ::: Jack is not frank.\nCivil(jasper) ::: Jasper is civil.\n¬Civil(george) ::: George is not civil.\nFrank(burgess) ::: Burgess is frank.\nJolly(roderick) ::: Roderick is jolly.\n¬Civil(myra) ::: Myra is not civil.\nPrecious(roderick) ::: Roderick is precious.\nJolly(jack) ::: Jack is jolly.\n¬Able(burgess) ::: Burgess is not able.\n¬Jolly(miles) ::: Miles is not jolly.\nJolly(jasper) ::: Jasper is jolly.\n((Jolly(burgess))) → ((¬Able(roderick))) ::: It can be concluded that Roderick is not able once knowing that Burgess is jolly.\n(∃x (Able(x) ∧ Jolly(x))) → ((¬Frank(jasper))) ::: If there is someone who is both able and jolly, then Jasper is not frank.\n(∃x (¬Frank(x) ∨ ¬Civil(x))) → ((Able(roderick))) ::: If there is at least one people who is not frank or not civil, then Roderick is able.\n(∃x (Able(x))) → ((¬Frank(george) ∧ ¬Technical(jack))) ::: If there is someone who is able, then George is not frank and Jack is not technical.\n(¬∃x (¬x)) → ((¬Frank(jack))) ::: If there is nobody who is not, then Jack is not frank.\n(∃x (¬Frank(x) ∨ ¬Precious(x))) → ((¬Able(roderick))) ::: If there is at least one people who is not frank or not precious, then Roderick is not able.\n(∀x (Frank(x))) → (∀x (¬Precious(x) ∧ ¬Civil(x))) ::: If someone is frank, then he is neither precious nor civil.\n((¬Jolly(burgess) ∨ ¬Civil(roderick))) → ((¬Technical(george))) ::: It can be concluded that George is not technical once knowing that Burgess is not jolly or Roderick is not civil.\n(∀x (Precious(x))) → (∀x (¬Frank(x))) ∧ (∀x (¬Frank(x))) → (∀x (¬Precious(x))) ::: If someone is precious, then he is not frank, and vice versa.\n(∀x (¬Civil(x) ∧ ¬Jolly(x))) ↔ (∀x (Able(x))) ::: If someone is not civil and not jolly, then he is able, and vice versa.\n((Able(roderick))) → ((Precious(burgess) ∧ ¬Civil(jack))) ::: Roderick being able implies that Burgess is precious and Jack is not civil.\n",
                "First-Order-Logic Question": "¬Civil(jasper) ::: Jasper is not civil."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "¬Able(jasper) ::: Jasper is not able.\n¬Frank(jack) ::: Jack is not frank.\nCivil(jasper) ::: Jasper is civil.\n¬Civil(george) ::: George is not civil.\nFrank(burgess) ::: Burgess is frank.\nJolly(roderick) ::: Roderick is jolly.\n¬Civil(myra) ::: Myra is not civil.\nPrecious(roderick) ::: Roderick is precious.\nJolly(jack) ::: Jack is jolly.\n¬Able(burgess) ::: Burgess is not able.\n¬Jolly(miles) ::: Miles is not jolly.\nJolly(jasper) ::: Jasper is jolly.\n((Jolly(burgess))) → ((¬Able(roderick))) ::: It can be concluded that Roderick is not able once knowing that Burgess is jolly.\n(∃x (Able(x) ∧ Jolly(x))) → ((¬Frank(jasper))) ::: If there is someone who is both able and jolly, then Jasper is not frank.\n(∃x (¬Frank(x) ∨ ¬Civil(x))) → ((Able(roderick))) ::: If there is at least one people who is not frank or not civil, then Roderick is able.\n(∃x (Able(x))) → ((¬Frank(george) ∧ ¬Technical(jack))) ::: If there is someone who is able, then George is not frank and Jack is not technical.\n¬∃x((¬Frank(x))→(¬Frank(x))) ::: If there is nobody who is not, then Jack is not frank.\n(∃x (¬Frank(x) ∨ ¬Precious(x))) → ((¬Able(roderick))) ::: If there is at least one people who is not frank or not precious, then Roderick is not able.\n(∀x (Frank(x))) → (∀x (¬Precious(x) ∧ ¬Civil(x))) ::: If someone is frank, then he is neither precious nor civil.\n((¬Jolly(burgess) ∨ ¬Civil(roderick))) → ((¬Technical(george))) ::: It can be concluded that George is not technical once knowing that Burgess is not jolly or Roderick is not civil.\n(∀x (Precious(x))) → (∀x (¬Frank(x))) ∧ (∀x (¬Frank(x))) → (∀x (¬Precious(x))) ::: If someone is precious, then he is not frank, and vice versa.\n(∀x (¬Civil(x) ∧ ¬Jolly(x))) ↔ (∀x (Able(x))) ::: If someone is not civil and not jolly, then he is able, and vice versa.\n((Able(roderick))) → ((Precious(burgess) ∧ ¬Civil(jack))) ::: Roderick being able implies that Burgess is precious and Jack is not civil.\n",
                "First-Order-Logic Question": "¬Civil(jasper) ::: Jasper is not civil."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬x)) → ((¬Frank(jack))) ::: If there is nobody who is not, then Jack is not frank.",
                    "gram": "¬∃x((¬Frank(x))→(¬Frank(x))) ::: If there is nobody who is not, then Jack is not frank."
                }
            ],
            "answer": "B",
            "grammar_answer": "A",
            "backup_answer": "B"
        },
        {
            "id": 420,
            "raw_prog": {
                "First-Order-Logic Rules": "Poor(jack) ::: Jack is poor.\n¬Fearless(lesley) ::: Lesley is not fearless.\nWonderful(lamont) ::: Lamont is wonderful.\n¬Poor(lamont) ::: Lamont is not poor.\n¬Combative(lesley) ::: Lesley is not combative.\n¬Bewildered(iver) ::: Iver is not bewildered.\n¬Fearless(blaine) ::: Blaine is not fearless.\nStubborn(lancelot) ::: Lancelot is stubborn.\nStubborn(lamont) ::: Lamont is stubborn.\n¬Bewildered(lancelot) ::: Lancelot is not bewildered.\nWonderful(lancelot) ::: Lancelot is wonderful.\nPoor(lancelot) ::: Lancelot is poor.\n(∀x (x ∨ Combative(x))) → (∀x (¬Poor(x))) ::: If someone is he or not wonderful is combative, then he is not poor.\n(∀x (Poor(x) ∧ Stubborn(x))) → (∀x (Fearless(x))) ::: If someone who is poor is also stubborn, then he is fearless.\n(∃x (Combative(x) ∧ ¬Poor(x))) → ((Bewildered(jack))) ::: If there is someone who is both combative and not poor, then Jack is bewildered.\n(∀x (¬Fearless(x) ∧ ¬Combative(x))) ↔ (∀x (Bewildered(x))) ::: If someone is not fearless and not combative, then he is bewildered, and vice versa.\n(¬Stubborn(lancelot)) ↔ (¬Poor(jack)) ::: Lancelot is not stubborn if and only if Jack is not poor.\n((Fearless(olive))) → ((Bewildered(lamont) ∧ Combative(lancelot))) ::: Olive being fearless implies that Lamont is bewildered and Lancelot is combative.\n(∀x (¬Bewildered(x))) → (∀x (Poor(x) ∧ ¬Stubborn(x))) ::: If someone is not bewildered, then he is both poor and not stubborn.\n(∀x (Stubborn(x))) → (∀x (¬Bewildered(x))) ::: If someone is stubborn, then he is not bewildered.\n((Poor(jack) ∧ ¬Fearless(lamont))) → ((Stubborn(blaine))) ::: It can be concluded that Blaine is stubborn once knowing that Jack is poor and Lamont is not fearless.\n(∃x (¬Fearless(x))) → ((¬Bewildered(iver))) ::: If there is someone who is not fearless, then Iver is not bewildered.\n(∃x (¬Fearless(x) ∨ ¬Stubborn(x))) → ((¬Wonderful(jack))) ::: If there is someone who is either not fearless or not stubborn, then Jack is not wonderful.\n(∀x (Bewildered(olive))) ↔ (∀x (Stubborn(blaine))) ::: Olive being bewildered is equivalent to Blaine being stubborn.\n",
                "First-Order-Logic Question": "Fearless(iver) ::: Iver is fearless."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "Poor(jack) ::: Jack is poor.\n¬Fearless(lesley) ::: Lesley is not fearless.\nWonderful(lamont) ::: Lamont is wonderful.\n¬Poor(lamont) ::: Lamont is not poor.\n¬Combative(lesley) ::: Lesley is not combative.\n¬Bewildered(iver) ::: Iver is not bewildered.\n¬Fearless(blaine) ::: Blaine is not fearless.\nStubborn(lancelot) ::: Lancelot is stubborn.\nStubborn(lamont) ::: Lamont is stubborn.\n¬Bewildered(lancelot) ::: Lancelot is not bewildered.\nWonderful(lancelot) ::: Lancelot is wonderful.\nPoor(lancelot) ::: Lancelot is poor.\n∀x((¬Poor(x))→(Combative(x))) ::: If someone is he or not wonderful is combative, then he is not poor.\n(∀x (Poor(x) ∧ Stubborn(x))) → (∀x (Fearless(x))) ::: If someone who is poor is also stubborn, then he is fearless.\n(∃x (Combative(x) ∧ ¬Poor(x))) → ((Bewildered(jack))) ::: If there is someone who is both combative and not poor, then Jack is bewildered.\n(∀x (¬Fearless(x) ∧ ¬Combative(x))) ↔ (∀x (Bewildered(x))) ::: If someone is not fearless and not combative, then he is bewildered, and vice versa.\n(¬Stubborn(lancelot)) ↔ (¬Poor(jack)) ::: Lancelot is not stubborn if and only if Jack is not poor.\n((Fearless(olive))) → ((Bewildered(lamont) ∧ Combative(lancelot))) ::: Olive being fearless implies that Lamont is bewildered and Lancelot is combative.\n(∀x (¬Bewildered(x))) → (∀x (Poor(x) ∧ ¬Stubborn(x))) ::: If someone is not bewildered, then he is both poor and not stubborn.\n(∀x (Stubborn(x))) → (∀x (¬Bewildered(x))) ::: If someone is stubborn, then he is not bewildered.\n((Poor(jack) ∧ ¬Fearless(lamont))) → ((Stubborn(blaine))) ::: It can be concluded that Blaine is stubborn once knowing that Jack is poor and Lamont is not fearless.\n(∃x (¬Fearless(x))) → ((¬Bewildered(iver))) ::: If there is someone who is not fearless, then Iver is not bewildered.\n(∃x (¬Fearless(x) ∨ ¬Stubborn(x))) → ((¬Wonderful(jack))) ::: If there is someone who is either not fearless or not stubborn, then Jack is not wonderful.\n(∀x (Bewildered(olive))) ↔ (∀x (Stubborn(blaine))) ::: Olive being bewildered is equivalent to Blaine being stubborn.\n",
                "First-Order-Logic Question": "Fearless(iver) ::: Iver is fearless."
            },
            "diff": [
                {
                    "raw": "(∀x (x ∨ Combative(x))) → (∀x (¬Poor(x))) ::: If someone is he or not wonderful is combative, then he is not poor.",
                    "gram": "∀x((¬Poor(x))→(Combative(x))) ::: If someone is he or not wonderful is combative, then he is not poor."
                }
            ],
            "answer": "C",
            "grammar_answer": "C",
            "backup_answer": "A"
        },
        {
            "id": 431,
            "raw_prog": {
                "First-Order-Logic Rules": "Poor(jack) ::: Jack is poor.\n¬Fearless(lesley) ::: Lesley is not fearless.\nWonderful(lamont) ::: Lamont is wonderful.\n¬Poor(lamont) ::: Lamont is not poor.\n¬Combative(lesley) ::: Lesley is not combative.\n¬Bewildered(iver) ::: Iver is not bewildered.\n¬Fearless(blaine) ::: Blaine is not fearless.\nStubborn(lancelot) ::: Lancelot is stubborn.\nStubborn(lamont) ::: Lamont is stubborn.\n¬Bewildered(lancelot) ::: Lancelot is not bewildered.\nWonderful(lancelot) ::: Lancelot is wonderful.\nPoor(lancelot) ::: Lancelot is poor.\n(∀x (x ∨ ¬Wonderful(x) ∧ Combative(x))) → (∀x (¬Poor(x))) ::: If someone is he or not wonderful is combative, then he is not poor.\n(∀x (Poor(x) ∧ Stubborn(x))) → (∀x (Fearless(x))) ::: If someone who is poor is also stubborn, then he is fearless.\n(∃x (Combative(x) ∧ ¬Poor(x))) → ((Bewildered(jack))) ::: If there is someone who is both combative and not poor, then Jack is bewildered.\n(∀x (¬Fearless(x) ∧ ¬Combative(x))) ↔ (∀x (Bewildered(x))) ::: If someone is not fearless and not combative, then he is bewildered, and vice versa.\n(¬Stubborn(lancelot)) ↔ (¬Poor(jack)) ::: Lancelot is not stubborn if and only if Jack is not poor.\n((Fearless(olive))) → ((Bewildered(lamont) ∧ Combative(lancelot))) ::: Olive being fearless implies that Lamont is bewildered and Lancelot is combative.\n(∀x (¬Bewildered(x))) → (∀x (Poor(x) ∧ ¬Stubborn(x))) ::: If someone is not bewildered, then he is both poor and not stubborn.\n(∀x (Stubborn(x))) → (∀x (¬Bewildered(x))) ::: If someone is stubborn, then he is not bewildered.\n((Poor(jack) ∧ ¬Fearless(lamont))) → ((Stubborn(blaine))) ::: It can be concluded that Blaine is stubborn once knowing that Jack is poor and Lamont is not fearless.\n(∃x (¬Fearless(x))) → ((¬Bewildered(iver))) ::: If there is someone who is not fearless, then Iver is not bewildered.\n(∃x (¬Fearless(x) ∨ ¬Stubborn(x))) → ((¬Wonderful(jack))) ::: If there is someone who is either not fearless or not stubborn, then Jack is not wonderful.\n(Bewildered(olive)) ↔ (Stubborn(blaine)) ::: Olive being bewildered is equivalent to Blaine being stubborn.\n",
                "First-Order-Logic Question": "Combative(lesley) ::: Lesley is combative."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "Poor(jack) ::: Jack is poor.\n¬Fearless(lesley) ::: Lesley is not fearless.\nWonderful(lamont) ::: Lamont is wonderful.\n¬Poor(lamont) ::: Lamont is not poor.\n¬Combative(lesley) ::: Lesley is not combative.\n¬Bewildered(iver) ::: Iver is not bewildered.\n¬Fearless(blaine) ::: Blaine is not fearless.\nStubborn(lancelot) ::: Lancelot is stubborn.\nStubborn(lamont) ::: Lamont is stubborn.\n¬Bewildered(lancelot) ::: Lancelot is not bewildered.\nWonderful(lancelot) ::: Lancelot is wonderful.\nPoor(lancelot) ::: Lancelot is poor.\n¬Poor(x)→(¬Wonderful(x)∧Combative(x)) ::: If someone is he or not wonderful is combative, then he is not poor.\n(∀x (Poor(x) ∧ Stubborn(x))) → (∀x (Fearless(x))) ::: If someone who is poor is also stubborn, then he is fearless.\n(∃x (Combative(x) ∧ ¬Poor(x))) → ((Bewildered(jack))) ::: If there is someone who is both combative and not poor, then Jack is bewildered.\n(∀x (¬Fearless(x) ∧ ¬Combative(x))) ↔ (∀x (Bewildered(x))) ::: If someone is not fearless and not combative, then he is bewildered, and vice versa.\n(¬Stubborn(lancelot)) ↔ (¬Poor(jack)) ::: Lancelot is not stubborn if and only if Jack is not poor.\n((Fearless(olive))) → ((Bewildered(lamont) ∧ Combative(lancelot))) ::: Olive being fearless implies that Lamont is bewildered and Lancelot is combative.\n(∀x (¬Bewildered(x))) → (∀x (Poor(x) ∧ ¬Stubborn(x))) ::: If someone is not bewildered, then he is both poor and not stubborn.\n(∀x (Stubborn(x))) → (∀x (¬Bewildered(x))) ::: If someone is stubborn, then he is not bewildered.\n((Poor(jack) ∧ ¬Fearless(lamont))) → ((Stubborn(blaine))) ::: It can be concluded that Blaine is stubborn once knowing that Jack is poor and Lamont is not fearless.\n(∃x (¬Fearless(x))) → ((¬Bewildered(iver))) ::: If there is someone who is not fearless, then Iver is not bewildered.\n(∃x (¬Fearless(x) ∨ ¬Stubborn(x))) → ((¬Wonderful(jack))) ::: If there is someone who is either not fearless or not stubborn, then Jack is not wonderful.\n(Bewildered(olive)) ↔ (Stubborn(blaine)) ::: Olive being bewildered is equivalent to Blaine being stubborn.\n",
                "First-Order-Logic Question": "Combative(lesley) ::: Lesley is combative."
            },
            "diff": [
                {
                    "raw": "(∀x (x ∨ ¬Wonderful(x) ∧ Combative(x))) → (∀x (¬Poor(x))) ::: If someone is he or not wonderful is combative, then he is not poor.",
                    "gram": "¬Poor(x)→(¬Wonderful(x)∧Combative(x)) ::: If someone is he or not wonderful is combative, then he is not poor."
                }
            ],
            "answer": "B",
            "grammar_answer": "A",
            "backup_answer": "B"
        },
        {
            "id": 555,
            "raw_prog": {
                "First-Order-Logic Rules": "Aggressive(montague) ::: Montague is aggressive.\nImpossible(ansel) ::: Ansel is impossible.\n¬Wicked(cyril) ::: Cyril is not wicked.\n¬Wicked(ansel) ::: Ansel is not wicked.\nDrab(katelynn) ::: Katelynn is drab.\n¬Drab(montague) ::: Montague is not drab.\n¬Mushy(ansel) ::: Ansel is not mushy.\n¬Wicked(joseph) ::: Joseph is not wicked.\nBroadMinded(joseph) ::: Joseph is broad-minded.\nDrab(olive) ::: Olive is drab.\n¬Drab(ansel) ::: Ansel is not drab.\n¬Wicked(montague) ::: Montague is not wicked.\n((Mushy(montague) ∧ ¬Wicked(katelynn))) → (¬Aggressive(ansel)) ::: Montague being mushy and Katelynn being not wicked imply that Ansel is not aggressive.\n(BroadMinded(joseph)) ↔ (¬Impossible(joseph)) ::: Joseph is broad-minded if and only if Joseph is not impossible.\n(∃x (¬Mushy(x))) → ((¬Aggressive(whitney) ∧ Impossible(cyril))) ::: If there is at least one people who is not mushy, then Whitney is not aggressive and Cyril is impossible.\n(∃x (BroadMinded(x) ∨ Impossible(x))) → ((Aggressive(olive))) ::: If there is someone who is either broad-minded or impossible, then Olive is aggressive.\n(¬∃x (¬x)) → ((¬BroadMinded(cyril) ∧ Aggressive(ansel))) ::: If there is nobody who is not, then Cyril is not broad-minded and Ansel is aggressive.\n((Wicked(olive) ∧ Drab(katelynn))) ↔ ((Aggressive(joseph) ∧ ¬BroadMinded(montague))) ::: Olive is wicked and Katelynn is drab if and only if Joseph is aggressive and Montague is not broad-minded.\n(∃x (Mushy(x))) → ((BroadMinded(katelynn) ∧ ¬Aggressive(joseph))) ::: If there is at least one people who is mushy, then Katelynn is broad-minded and Joseph is not aggressive.\n((Wicked(olive) ∨ BroadMinded(cyril))) → ((Aggressive(katelynn))) ::: Olive being wicked or Cyril being broad-minded implies that Katelynn is aggressive.\n(∃x (Wicked(x) ∧ ¬Mushy(x))) → ((¬Drab(montague))) ::: If there is someone who is both wicked and not mushy, then Montague is not drab.\n(¬Impossible(whitney)) → ((¬Mushy(cyril) ∧ BroadMinded(joseph))) ::: Whitney being not impossible implies that Cyril is not mushy and Joseph is broad-minded.\n(∀x (¬Aggressive(x))) ↔ (∀x (¬Impossible(x))) ::: Someone is not aggressive if and only if he is not impossible.\n(∀x (Aggressive(x) ∧ ¬Drab(x))) ↔ (∀x (¬Impossible(x))) ::: Someone is aggressive and not drab if and only if he is not impossible.\n",
                "First-Order-Logic Question": "¬Mushy(joseph) ::: Joseph is not mushy."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "Aggressive(montague) ::: Montague is aggressive.\nImpossible(ansel) ::: Ansel is impossible.\n¬Wicked(cyril) ::: Cyril is not wicked.\n¬Wicked(ansel) ::: Ansel is not wicked.\nDrab(katelynn) ::: Katelynn is drab.\n¬Drab(montague) ::: Montague is not drab.\n¬Mushy(ansel) ::: Ansel is not mushy.\n¬Wicked(joseph) ::: Joseph is not wicked.\nBroadMinded(joseph) ::: Joseph is broad-minded.\nDrab(olive) ::: Olive is drab.\n¬Drab(ansel) ::: Ansel is not drab.\n¬Wicked(montague) ::: Montague is not wicked.\n((Mushy(montague) ∧ ¬Wicked(katelynn))) → (¬Aggressive(ansel)) ::: Montague being mushy and Katelynn being not wicked imply that Ansel is not aggressive.\n(BroadMinded(joseph)) ↔ (¬Impossible(joseph)) ::: Joseph is broad-minded if and only if Joseph is not impossible.\n(∃x (¬Mushy(x))) → ((¬Aggressive(whitney) ∧ Impossible(cyril))) ::: If there is at least one people who is not mushy, then Whitney is not aggressive and Cyril is impossible.\n(∃x (BroadMinded(x) ∨ Impossible(x))) → ((Aggressive(olive))) ::: If there is someone who is either broad-minded or impossible, then Olive is aggressive.\n¬∃x((¬BroadMinded(x)∧Aggressive(x))) ::: If there is nobody who is not, then Cyril is not broad-minded and Ansel is aggressive.\n((Wicked(olive) ∧ Drab(katelynn))) ↔ ((Aggressive(joseph) ∧ ¬BroadMinded(montague))) ::: Olive is wicked and Katelynn is drab if and only if Joseph is aggressive and Montague is not broad-minded.\n(∃x (Mushy(x))) → ((BroadMinded(katelynn) ∧ ¬Aggressive(joseph))) ::: If there is at least one people who is mushy, then Katelynn is broad-minded and Joseph is not aggressive.\n((Wicked(olive) ∨ BroadMinded(cyril))) → ((Aggressive(katelynn))) ::: Olive being wicked or Cyril being broad-minded implies that Katelynn is aggressive.\n(∃x (Wicked(x) ∧ ¬Mushy(x))) → ((¬Drab(montague))) ::: If there is someone who is both wicked and not mushy, then Montague is not drab.\n(¬Impossible(whitney)) → ((¬Mushy(cyril) ∧ BroadMinded(joseph))) ::: Whitney being not impossible implies that Cyril is not mushy and Joseph is broad-minded.\n(∀x (¬Aggressive(x))) ↔ (∀x (¬Impossible(x))) ::: Someone is not aggressive if and only if he is not impossible.\n(∀x (Aggressive(x) ∧ ¬Drab(x))) ↔ (∀x (¬Impossible(x))) ::: Someone is aggressive and not drab if and only if he is not impossible.\n",
                "First-Order-Logic Question": "¬Mushy(joseph) ::: Joseph is not mushy."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬x)) → ((¬BroadMinded(cyril) ∧ Aggressive(ansel))) ::: If there is nobody who is not, then Cyril is not broad-minded and Ansel is aggressive.",
                    "gram": "¬∃x((¬BroadMinded(x)∧Aggressive(x))) ::: If there is nobody who is not, then Cyril is not broad-minded and Ansel is aggressive."
                }
            ],
            "answer": "C",
            "grammar_answer": "C",
            "backup_answer": "C"
        },
        {
            "id": 556,
            "raw_prog": {
                "First-Order-Logic Rules": "Aggressive(montague) ::: Montague is aggressive.\nImpossible(ansel) ::: Ansel is impossible.\n¬Wicked(cyril) ::: Cyril is not wicked.\n¬Wicked(ansel) ::: Ansel is not wicked.\nDrab(katelynn) ::: Katelynn is drab.\n¬Drab(montague) ::: Montague is not drab.\n¬Mushy(ansel) ::: Ansel is not mushy.\n¬Wicked(joseph) ::: Joseph is not wicked.\nBroadMinded(joseph) ::: Joseph is broad-minded.\nDrab(olive) ::: Olive is drab.\n¬Drab(ansel) ::: Ansel is not drab.\n¬Wicked(montague) ::: Montague is not wicked.\n((Mushy(montague) ∧ ¬Wicked(katelynn))) → (¬Aggressive(ansel)) ::: Montague being mushy and Katelynn being not wicked imply that Ansel is not aggressive.\n(BroadMinded(joseph)) ↔ (¬Impossible(joseph)) ::: Joseph is broad-minded if and only if Joseph is not impossible.\n(∃x (¬Mushy(x))) → ((¬Aggressive(whitney) ∧ Impossible(cyril))) ::: If there is at least one people who is not mushy, then Whitney is not aggressive and Cyril is impossible.\n(∃x (BroadMinded(x) ∨ Impossible(x))) → (Aggressive(olive)) ::: If there is someone who is either broad-minded or impossible, then Olive is aggressive.\n(¬∃x (¬x)) → ((¬BroadMinded(cyril) ∧ Aggressive(ansel))) ::: If there is nobody who is not, then Cyril is not broad-minded and Ansel is aggressive.\n((Wicked(olive) ∧ Drab(katelynn))) ↔ ((Aggressive(joseph) ∧ ¬BroadMinded(montague))) ::: Olive is wicked and Katelynn is drab if and only if Joseph is aggressive and Montague is not broad-minded.\n(∃x (Mushy(x))) → ((BroadMinded(katelynn) ∧ ¬Aggressive(joseph))) ::: If there is at least one people who is mushy, then Katelynn is broad-minded and Joseph is not aggressive.\n((Wicked(olive) ∨ BroadMinded(cyril))) → (Aggressive(katelynn)) ::: Olive being wicked or Cyril being broad-minded implies that Katelynn is aggressive.\n(∃x (Wicked(x) ∧ ¬Mushy(x))) → (¬Drab(montague)) ::: If there is someone who is both wicked and not mushy, then Montague is not drab.\n(¬Impossible(whitney)) → ((¬Mushy(cyril) ∧ BroadMinded(joseph))) ::: Whitney being not impossible implies that Cyril is not mushy and Joseph is broad-minded.\n(∀x (¬Aggressive(x))) ↔ (∀x (¬Impossible(x))) ::: Someone is not aggressive if and only if he is not impossible.\n(∀x (Aggressive(x) ∧ ¬Drab(x))) ↔ (∀x (¬Impossible(x))) ::: Someone is aggressive and not drab if and only if he is not impossible.\n",
                "First-Order-Logic Question": "Impossible(olive) ::: Olive is impossible."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "Aggressive(montague) ::: Montague is aggressive.\nImpossible(ansel) ::: Ansel is impossible.\n¬Wicked(cyril) ::: Cyril is not wicked.\n¬Wicked(ansel) ::: Ansel is not wicked.\nDrab(katelynn) ::: Katelynn is drab.\n¬Drab(montague) ::: Montague is not drab.\n¬Mushy(ansel) ::: Ansel is not mushy.\n¬Wicked(joseph) ::: Joseph is not wicked.\nBroadMinded(joseph) ::: Joseph is broad-minded.\nDrab(olive) ::: Olive is drab.\n¬Drab(ansel) ::: Ansel is not drab.\n¬Wicked(montague) ::: Montague is not wicked.\n((Mushy(montague) ∧ ¬Wicked(katelynn))) → (¬Aggressive(ansel)) ::: Montague being mushy and Katelynn being not wicked imply that Ansel is not aggressive.\n(BroadMinded(joseph)) ↔ (¬Impossible(joseph)) ::: Joseph is broad-minded if and only if Joseph is not impossible.\n(∃x (¬Mushy(x))) → ((¬Aggressive(whitney) ∧ Impossible(cyril))) ::: If there is at least one people who is not mushy, then Whitney is not aggressive and Cyril is impossible.\n(∃x (BroadMinded(x) ∨ Impossible(x))) → (Aggressive(olive)) ::: If there is someone who is either broad-minded or impossible, then Olive is aggressive.\n¬∃x(¬(¬(BroadMinded(x)))) ::: If there is nobody who is not, then Cyril is not broad-minded and Ansel is aggressive.\n((Wicked(olive) ∧ Drab(katelynn))) ↔ ((Aggressive(joseph) ∧ ¬BroadMinded(montague))) ::: Olive is wicked and Katelynn is drab if and only if Joseph is aggressive and Montague is not broad-minded.\n(∃x (Mushy(x))) → ((BroadMinded(katelynn) ∧ ¬Aggressive(joseph))) ::: If there is at least one people who is mushy, then Katelynn is broad-minded and Joseph is not aggressive.\n((Wicked(olive) ∨ BroadMinded(cyril))) → (Aggressive(katelynn)) ::: Olive being wicked or Cyril being broad-minded implies that Katelynn is aggressive.\n(∃x (Wicked(x) ∧ ¬Mushy(x))) → (¬Drab(montague)) ::: If there is someone who is both wicked and not mushy, then Montague is not drab.\n(¬Impossible(whitney)) → ((¬Mushy(cyril) ∧ BroadMinded(joseph))) ::: Whitney being not impossible implies that Cyril is not mushy and Joseph is broad-minded.\n(∀x (¬Aggressive(x))) ↔ (∀x (¬Impossible(x))) ::: Someone is not aggressive if and only if he is not impossible.\n(∀x (Aggressive(x) ∧ ¬Drab(x))) ↔ (∀x (¬Impossible(x))) ::: Someone is aggressive and not drab if and only if he is not impossible.\n",
                "First-Order-Logic Question": "Impossible(olive) ::: Olive is impossible."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬x)) → ((¬BroadMinded(cyril) ∧ Aggressive(ansel))) ::: If there is nobody who is not, then Cyril is not broad-minded and Ansel is aggressive.",
                    "gram": "¬∃x(¬(¬(BroadMinded(x)))) ::: If there is nobody who is not, then Cyril is not broad-minded and Ansel is aggressive."
                }
            ],
            "answer": "C",
            "grammar_answer": "A",
            "backup_answer": "C"
        },
        {
            "id": 557,
            "raw_prog": {
                "First-Order-Logic Rules": "Aggressive(montague) ::: Montague is aggressive.\nImpossible(ansel) ::: Ansel is impossible.\n¬Wicked(cyril) ::: Cyril is not wicked.\n¬Wicked(ansel) ::: Ansel is not wicked.\nDrab(katelynn) ::: Katelynn is drab.\n¬Drab(montague) ::: Montague is not drab.\n¬Mushy(ansel) ::: Ansel is not mushy.\n¬Wicked(joseph) ::: Joseph is not wicked.\nDrab(olive) ::: Olive is drab.\nBroadMinded(joseph) ::: Joseph is broad-minded.\n¬Drab(ansel) ::: Ansel is not drab.\n¬Wicked(montague) ::: Montague is not wicked.\n((Mushy(montague) ∧ ¬Wicked(katelynn))) → (¬Aggressive(ansel)) ::: Montague being mushy and Katelynn being not wicked imply that Ansel is not aggressive.\n(BroadMinded(joseph)) ↔ (¬Impossible(joseph)) ::: Joseph is broad-minded if and only if Joseph is not impossible.\n(∃x (¬Mushy(x))) → ((¬Aggressive(whitney) ∧ Impossible(cyril))) ::: If there is at least one people who is not mushy, then Whitney is not aggressive and Cyril is impossible.\n(∃x (BroadMinded(x) ∨ Impossible(x))) → ((Aggressive(olive))) ::: If there is someone who is either broad-minded or impossible, then Olive is aggressive.\n(¬∃x (¬x)) → ((¬BroadMinded(cyril) ∧ Aggressive(ansel))) ::: If there is nobody who is not, then Cyril is not broad-minded and Ansel is aggressive.\n((Wicked(olive) ∧ Drab(katelynn))) ↔ ((Aggressive(joseph) ∧ ¬BroadMinded(montague))) ::: Olive is wicked and Katelynn is drab if and only if Joseph is aggressive and Montague is not broad-minded.\n(∃x (Mushy(x))) → ((BroadMinded(katelynn) ∧ ¬Aggressive(joseph))) ::: If there is at least one people who is mushy, then Katelynn is broad-minded and Joseph is not aggressive.\n((Wicked(olive) ∨ BroadMinded(cyril))) → ((Aggressive(katelynn))) ::: Olive being wicked or Cyril being broad-minded implies that Katelynn is aggressive.\n(∃x (Wicked(x) ∧ ¬Mushy(x))) → ((¬Drab(montague))) ::: If there is someone who is both wicked and not mushy, then Montague is not drab.\n(¬Impossible(whitney)) → ((¬Mushy(cyril) ∧ BroadMinded(joseph))) ::: Whitney being not impossible implies that Cyril is not mushy and Joseph is broad-minded.\n(∀x (¬Aggressive(x))) ↔ (∀x (¬Impossible(x))) ::: Someone is not aggressive if and only if he is not impossible.\n(∀x (Aggressive(x) ∧ ¬Drab(x))) ↔ (∀x (¬Impossible(x))) ::: Someone is aggressive and not drab if and only if he is not impossible.\n",
                "First-Order-Logic Question": "BroadMinded(whitney) ::: Whitney is broad-minded."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "Aggressive(montague) ::: Montague is aggressive.\nImpossible(ansel) ::: Ansel is impossible.\n¬Wicked(cyril) ::: Cyril is not wicked.\n¬Wicked(ansel) ::: Ansel is not wicked.\nDrab(katelynn) ::: Katelynn is drab.\n¬Drab(montague) ::: Montague is not drab.\n¬Mushy(ansel) ::: Ansel is not mushy.\n¬Wicked(joseph) ::: Joseph is not wicked.\nDrab(olive) ::: Olive is drab.\nBroadMinded(joseph) ::: Joseph is broad-minded.\n¬Drab(ansel) ::: Ansel is not drab.\n¬Wicked(montague) ::: Montague is not wicked.\n((Mushy(montague) ∧ ¬Wicked(katelynn))) → (¬Aggressive(ansel)) ::: Montague being mushy and Katelynn being not wicked imply that Ansel is not aggressive.\n(BroadMinded(joseph)) ↔ (¬Impossible(joseph)) ::: Joseph is broad-minded if and only if Joseph is not impossible.\n(∃x (¬Mushy(x))) → ((¬Aggressive(whitney) ∧ Impossible(cyril))) ::: If there is at least one people who is not mushy, then Whitney is not aggressive and Cyril is impossible.\n(∃x (BroadMinded(x) ∨ Impossible(x))) → ((Aggressive(olive))) ::: If there is someone who is either broad-minded or impossible, then Olive is aggressive.\n¬∃x(¬(¬(BroadMinded(x)))) ::: If there is nobody who is not, then Cyril is not broad-minded and Ansel is aggressive.\n((Wicked(olive) ∧ Drab(katelynn))) ↔ ((Aggressive(joseph) ∧ ¬BroadMinded(montague))) ::: Olive is wicked and Katelynn is drab if and only if Joseph is aggressive and Montague is not broad-minded.\n(∃x (Mushy(x))) → ((BroadMinded(katelynn) ∧ ¬Aggressive(joseph))) ::: If there is at least one people who is mushy, then Katelynn is broad-minded and Joseph is not aggressive.\n((Wicked(olive) ∨ BroadMinded(cyril))) → ((Aggressive(katelynn))) ::: Olive being wicked or Cyril being broad-minded implies that Katelynn is aggressive.\n(∃x (Wicked(x) ∧ ¬Mushy(x))) → ((¬Drab(montague))) ::: If there is someone who is both wicked and not mushy, then Montague is not drab.\n(¬Impossible(whitney)) → ((¬Mushy(cyril) ∧ BroadMinded(joseph))) ::: Whitney being not impossible implies that Cyril is not mushy and Joseph is broad-minded.\n(∀x (¬Aggressive(x))) ↔ (∀x (¬Impossible(x))) ::: Someone is not aggressive if and only if he is not impossible.\n(∀x (Aggressive(x) ∧ ¬Drab(x))) ↔ (∀x (¬Impossible(x))) ::: Someone is aggressive and not drab if and only if he is not impossible.\n",
                "First-Order-Logic Question": "BroadMinded(whitney) ::: Whitney is broad-minded."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬x)) → ((¬BroadMinded(cyril) ∧ Aggressive(ansel))) ::: If there is nobody who is not, then Cyril is not broad-minded and Ansel is aggressive.",
                    "gram": "¬∃x(¬(¬(BroadMinded(x)))) ::: If there is nobody who is not, then Cyril is not broad-minded and Ansel is aggressive."
                }
            ],
            "answer": "C",
            "grammar_answer": "A",
            "backup_answer": "C"
        },
        {
            "id": 558,
            "raw_prog": {
                "First-Order-Logic Rules": "Aggressive(montague) ::: Montague is aggressive.\nImpossible(ansel) ::: Ansel is impossible.\n¬Wicked(cyril) ::: Cyril is not wicked.\n¬Wicked(ansel) ::: Ansel is not wicked.\nDrab(katelynn) ::: Katelynn is drab.\n¬Drab(montague) ::: Montague is not drab.\n¬Mushy(ansel) ::: Ansel is not mushy.\n¬Wicked(joseph) ::: Joseph is not wicked.\nDrab(olive) ::: Olive is drab.\nBroadMinded(joseph) ::: Joseph is broad-minded.\n¬Drab(ansel) ::: Ansel is not drab.\n¬Wicked(montague) ::: Montague is not wicked.\n((Mushy(montague) ∧ ¬Wicked(katelynn))) → (¬Aggressive(ansel)) ::: Montague being mushy and Katelynn being not wicked imply that Ansel is not aggressive.\n(BroadMinded(joseph)) ↔ (¬Impossible(joseph)) ::: Joseph is broad-minded if and only if Joseph is not impossible.\n(∃x (¬Mushy(x))) → ((¬Aggressive(whitney) ∧ Impossible(cyril))) ::: If there is at least one people who is not mushy, then Whitney is not aggressive and Cyril is impossible.\n(∃x (BroadMinded(x) ∨ Impossible(x))) → (Aggressive(olive)) ::: If there is someone who is either broad-minded or impossible, then Olive is aggressive.\n(∀x (¬x)) → ((¬BroadMinded(cyril) ∧ Aggressive(ansel))) ::: If there is nobody who is not, then Cyril is not broad-minded and Ansel is aggressive.\n((Wicked(olive) ∧ Drab(katelynn))) ↔ ((Aggressive(joseph) ∧ ¬BroadMinded(montague))) ::: Olive is wicked and Katelynn is drab if and only if Joseph is aggressive and Montague is not broad-minded.\n(∃x (Mushy(x))) → ((BroadMinded(katelynn) ∧ ¬Aggressive(joseph))) ::: If there is at least one people who is mushy, then Katelynn is broad-minded and Joseph is not aggressive.\n((Wicked(olive) ∨ BroadMinded(cyril))) → (Aggressive(katelynn)) ::: Olive being wicked or Cyril being broad-minded implies that Katelynn is aggressive.\n(∃x (Wicked(x) ∧ ¬Mushy(x))) → (¬Drab(montague)) ::: If there is someone who is both wicked and not mushy, then Montague is not drab.\n(¬Impossible(whitney)) → ((¬Mushy(cyril) ∧ BroadMinded(joseph))) ::: Whitney being not impossible implies that Cyril is not mushy and Joseph is broad-minded.\n(∀x (¬Aggressive(x))) ↔ (∀x (¬Impossible(x))) ::: Someone is not aggressive if and only if he is not impossible.\n(∀x (Aggressive(x) ∧ ¬Drab(x))) ↔ (∀x (¬Impossible(x))) ::: Someone is aggressive and not drab if and only if he is not impossible.\n",
                "First-Order-Logic Question": "Mushy(ansel) ::: Ansel is mushy."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "Aggressive(montague) ::: Montague is aggressive.\nImpossible(ansel) ::: Ansel is impossible.\n¬Wicked(cyril) ::: Cyril is not wicked.\n¬Wicked(ansel) ::: Ansel is not wicked.\nDrab(katelynn) ::: Katelynn is drab.\n¬Drab(montague) ::: Montague is not drab.\n¬Mushy(ansel) ::: Ansel is not mushy.\n¬Wicked(joseph) ::: Joseph is not wicked.\nDrab(olive) ::: Olive is drab.\nBroadMinded(joseph) ::: Joseph is broad-minded.\n¬Drab(ansel) ::: Ansel is not drab.\n¬Wicked(montague) ::: Montague is not wicked.\n((Mushy(montague) ∧ ¬Wicked(katelynn))) → (¬Aggressive(ansel)) ::: Montague being mushy and Katelynn being not wicked imply that Ansel is not aggressive.\n(BroadMinded(joseph)) ↔ (¬Impossible(joseph)) ::: Joseph is broad-minded if and only if Joseph is not impossible.\n(∃x (¬Mushy(x))) → ((¬Aggressive(whitney) ∧ Impossible(cyril))) ::: If there is at least one people who is not mushy, then Whitney is not aggressive and Cyril is impossible.\n(∃x (BroadMinded(x) ∨ Impossible(x))) → (Aggressive(olive)) ::: If there is someone who is either broad-minded or impossible, then Olive is aggressive.\n¬(¬BroadMinded(x))→((¬Aggressive(x))) ::: If there is nobody who is not, then Cyril is not broad-minded and Ansel is aggressive.\n((Wicked(olive) ∧ Drab(katelynn))) ↔ ((Aggressive(joseph) ∧ ¬BroadMinded(montague))) ::: Olive is wicked and Katelynn is drab if and only if Joseph is aggressive and Montague is not broad-minded.\n(∃x (Mushy(x))) → ((BroadMinded(katelynn) ∧ ¬Aggressive(joseph))) ::: If there is at least one people who is mushy, then Katelynn is broad-minded and Joseph is not aggressive.\n((Wicked(olive) ∨ BroadMinded(cyril))) → (Aggressive(katelynn)) ::: Olive being wicked or Cyril being broad-minded implies that Katelynn is aggressive.\n(∃x (Wicked(x) ∧ ¬Mushy(x))) → (¬Drab(montague)) ::: If there is someone who is both wicked and not mushy, then Montague is not drab.\n(¬Impossible(whitney)) → ((¬Mushy(cyril) ∧ BroadMinded(joseph))) ::: Whitney being not impossible implies that Cyril is not mushy and Joseph is broad-minded.\n(∀x (¬Aggressive(x))) ↔ (∀x (¬Impossible(x))) ::: Someone is not aggressive if and only if he is not impossible.\n(∀x (Aggressive(x) ∧ ¬Drab(x))) ↔ (∀x (¬Impossible(x))) ::: Someone is aggressive and not drab if and only if he is not impossible.\n",
                "First-Order-Logic Question": "Mushy(ansel) ::: Ansel is mushy."
            },
            "diff": [
                {
                    "raw": "(∀x (¬x)) → ((¬BroadMinded(cyril) ∧ Aggressive(ansel))) ::: If there is nobody who is not, then Cyril is not broad-minded and Ansel is aggressive.",
                    "gram": "¬(¬BroadMinded(x))→((¬Aggressive(x))) ::: If there is nobody who is not, then Cyril is not broad-minded and Ansel is aggressive."
                }
            ],
            "answer": "B",
            "grammar_answer": "B",
            "backup_answer": "B"
        },
        {
            "id": 559,
            "raw_prog": {
                "First-Order-Logic Rules": "Aggressive(montague) ::: Montague is aggressive.\nImpossible(ansel) ::: Ansel is impossible.\n¬Wicked(cyril) ::: Cyril is not wicked.\n¬Wicked(ansel) ::: Ansel is not wicked.\nDrab(katelynn) ::: Katelynn is drab.\n¬Drab(montague) ::: Montague is not drab.\n¬Mushy(ansel) ::: Ansel is not mushy.\n¬Wicked(joseph) ::: Joseph is not wicked.\nDrab(olive) ::: Olive is drab.\nBroadMinded(joseph) ::: Joseph is broad-minded.\n¬Drab(ansel) ::: Ansel is not drab.\n¬Wicked(montague) ::: Montague is not wicked.\n((Mushy(montague) ∧ ¬Wicked(katelynn))) → (¬Aggressive(ansel)) ::: Montague being mushy and Katelynn being not wicked imply that Ansel is not aggressive.\n(BroadMinded(joseph)) ↔ (¬Impossible(joseph)) ::: Joseph is broad-minded if and only if Joseph is not impossible.\n(∃x (¬Mushy(x))) → ((¬Aggressive(whitney) ∧ Impossible(cyril))) ::: If there is at least one people who is not mushy, then Whitney is not aggressive and Cyril is impossible.\n(∃x (BroadMinded(x) ∨ Impossible(x))) → ((Aggressive(olive))) ::: If there is someone who is either broad-minded or impossible, then Olive is aggressive.\n(¬∃x (¬x)) → ((¬BroadMinded(cyril) ∧ Aggressive(ansel))) ::: If there is nobody who is not, then Cyril is not broad-minded and Ansel is aggressive.\n((Wicked(olive) ∧ Drab(katelynn))) ↔ ((Aggressive(joseph) ∧ ¬BroadMinded(montague))) ::: Olive is wicked and Katelynn is drab if and only if Joseph is aggressive and Montague is not broad-minded.\n(∃x (Mushy(x))) → ((BroadMinded(katelynn) ∧ ¬Aggressive(joseph))) ::: If there is at least one people who is mushy, then Katelynn is broad-minded and Joseph is not aggressive.\n((Wicked(olive) ∨ BroadMinded(cyril))) → ((Aggressive(katelynn))) ::: Olive being wicked or Cyril being broad-minded implies that Katelynn is aggressive.\n(∃x (Wicked(x) ∧ ¬Mushy(x))) → ((¬Drab(montague))) ::: If there is someone who is both wicked and not mushy, then Montague is not drab.\n(¬Impossible(whitney)) → ((¬Mushy(cyril) ∧ BroadMinded(joseph))) ::: Whitney being not impossible implies that Cyril is not mushy and Joseph is broad-minded.\n(∀x (¬Aggressive(x))) ↔ (∀x (¬Impossible(x))) ::: Someone is not aggressive if and only if he is not impossible.\n(∀x (Aggressive(x) ∧ ¬Drab(x))) ↔ (∀x (¬Impossible(x))) ::: Someone is aggressive and not drab if and only if he is not impossible.\n",
                "First-Order-Logic Question": "¬Drab(ansel) ::: Ansel is not drab."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "Aggressive(montague) ::: Montague is aggressive.\nImpossible(ansel) ::: Ansel is impossible.\n¬Wicked(cyril) ::: Cyril is not wicked.\n¬Wicked(ansel) ::: Ansel is not wicked.\nDrab(katelynn) ::: Katelynn is drab.\n¬Drab(montague) ::: Montague is not drab.\n¬Mushy(ansel) ::: Ansel is not mushy.\n¬Wicked(joseph) ::: Joseph is not wicked.\nDrab(olive) ::: Olive is drab.\nBroadMinded(joseph) ::: Joseph is broad-minded.\n¬Drab(ansel) ::: Ansel is not drab.\n¬Wicked(montague) ::: Montague is not wicked.\n((Mushy(montague) ∧ ¬Wicked(katelynn))) → (¬Aggressive(ansel)) ::: Montague being mushy and Katelynn being not wicked imply that Ansel is not aggressive.\n(BroadMinded(joseph)) ↔ (¬Impossible(joseph)) ::: Joseph is broad-minded if and only if Joseph is not impossible.\n(∃x (¬Mushy(x))) → ((¬Aggressive(whitney) ∧ Impossible(cyril))) ::: If there is at least one people who is not mushy, then Whitney is not aggressive and Cyril is impossible.\n(∃x (BroadMinded(x) ∨ Impossible(x))) → ((Aggressive(olive))) ::: If there is someone who is either broad-minded or impossible, then Olive is aggressive.\n¬∃x((¬BroadMinded(x)∧Aggressive(x))) ::: If there is nobody who is not, then Cyril is not broad-minded and Ansel is aggressive.\n((Wicked(olive) ∧ Drab(katelynn))) ↔ ((Aggressive(joseph) ∧ ¬BroadMinded(montague))) ::: Olive is wicked and Katelynn is drab if and only if Joseph is aggressive and Montague is not broad-minded.\n(∃x (Mushy(x))) → ((BroadMinded(katelynn) ∧ ¬Aggressive(joseph))) ::: If there is at least one people who is mushy, then Katelynn is broad-minded and Joseph is not aggressive.\n((Wicked(olive) ∨ BroadMinded(cyril))) → ((Aggressive(katelynn))) ::: Olive being wicked or Cyril being broad-minded implies that Katelynn is aggressive.\n(∃x (Wicked(x) ∧ ¬Mushy(x))) → ((¬Drab(montague))) ::: If there is someone who is both wicked and not mushy, then Montague is not drab.\n(¬Impossible(whitney)) → ((¬Mushy(cyril) ∧ BroadMinded(joseph))) ::: Whitney being not impossible implies that Cyril is not mushy and Joseph is broad-minded.\n(∀x (¬Aggressive(x))) ↔ (∀x (¬Impossible(x))) ::: Someone is not aggressive if and only if he is not impossible.\n(∀x (Aggressive(x) ∧ ¬Drab(x))) ↔ (∀x (¬Impossible(x))) ::: Someone is aggressive and not drab if and only if he is not impossible.\n",
                "First-Order-Logic Question": "¬Drab(ansel) ::: Ansel is not drab."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬x)) → ((¬BroadMinded(cyril) ∧ Aggressive(ansel))) ::: If there is nobody who is not, then Cyril is not broad-minded and Ansel is aggressive.",
                    "gram": "¬∃x((¬BroadMinded(x)∧Aggressive(x))) ::: If there is nobody who is not, then Cyril is not broad-minded and Ansel is aggressive."
                }
            ],
            "answer": "A",
            "grammar_answer": "A",
            "backup_answer": "A"
        },
        {
            "id": 560,
            "raw_prog": {
                "First-Order-Logic Rules": "Aggressive(montague) ::: Montague is aggressive.\nImpossible(ansel) ::: Ansel is impossible.\n¬Wicked(cyril) ::: Cyril is not wicked.\n¬Wicked(ansel) ::: Ansel is not wicked.\nDrab(katelynn) ::: Katelynn is drab.\n¬Drab(montague) ::: Montague is not drab.\n¬Mushy(ansel) ::: Ansel is not mushy.\n¬Wicked(joseph) ::: Joseph is not wicked.\nDrab(olive) ::: Olive is drab.\nBroadMinded(joseph) ::: Joseph is broad-minded.\n¬Drab(ansel) ::: Ansel is not drab.\n¬Wicked(montague) ::: Montague is not wicked.\n((Mushy(montague) ∧ ¬Wicked(katelynn))) → (¬Aggressive(ansel)) ::: Montague being mushy and Katelynn being not wicked imply that Ansel is not aggressive.\n(BroadMinded(joseph)) ↔ (¬Impossible(joseph)) ::: Joseph is broad-minded if and only if Joseph is not impossible.\n(∃x (¬Mushy(x))) → ((¬Aggressive(whitney) ∧ Impossible(cyril))) ::: If there is at least one people who is not mushy, then Whitney is not aggressive and Cyril is impossible.\n(∃x (BroadMinded(x) ∨ Impossible(x))) → ((Aggressive(olive))) ::: If there is someone who is either broad-minded or impossible, then Olive is aggressive.\n(∀x (¬x)) → ((¬BroadMinded(cyril) ∧ Aggressive(ansel))) ::: If there is nobody who is not, then Cyril is not broad-minded and Ansel is aggressive.\n((Wicked(olive) ∧ Drab(katelynn))) ↔ ((Aggressive(joseph) ∧ ¬BroadMinded(montague))) ::: Olive is wicked and Katelynn is drab if and only if Joseph is aggressive and Montague is not broad-minded.\n(∃x (Mushy(x))) → ((BroadMinded(katelynn) ∧ ¬Aggressive(joseph))) ::: If there is at least one people who is mushy, then Katelynn is broad-minded and Joseph is not aggressive.\n((Wicked(olive) ∨ BroadMinded(cyril))) → ((Aggressive(katelynn))) ::: Olive being wicked or Cyril being broad-minded implies that Katelynn is aggressive.\n(∃x (Wicked(x) ∧ ¬Mushy(x))) → ((¬Drab(montague))) ::: If there is someone who is both wicked and not mushy, then Montague is not drab.\n((¬Impossible(whitney))) → ((¬Mushy(cyril) ∧ BroadMinded(joseph))) ::: Whitney being not impossible implies that Cyril is not mushy and Joseph is broad-minded.\n(∀x (¬Aggressive(x))) ↔ (∀x (¬Impossible(x))) ::: Someone is not aggressive if and only if he is not impossible.\n(∀x (Aggressive(x) ∧ ¬Drab(x))) ↔ (∀x (¬Impossible(x))) ::: Someone is aggressive and not drab if and only if he is not impossible.\n",
                "First-Order-Logic Question": "Impossible(katelynn) ::: Katelynn is impossible."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "Aggressive(montague) ::: Montague is aggressive.\nImpossible(ansel) ::: Ansel is impossible.\n¬Wicked(cyril) ::: Cyril is not wicked.\n¬Wicked(ansel) ::: Ansel is not wicked.\nDrab(katelynn) ::: Katelynn is drab.\n¬Drab(montague) ::: Montague is not drab.\n¬Mushy(ansel) ::: Ansel is not mushy.\n¬Wicked(joseph) ::: Joseph is not wicked.\nDrab(olive) ::: Olive is drab.\nBroadMinded(joseph) ::: Joseph is broad-minded.\n¬Drab(ansel) ::: Ansel is not drab.\n¬Wicked(montague) ::: Montague is not wicked.\n((Mushy(montague) ∧ ¬Wicked(katelynn))) → (¬Aggressive(ansel)) ::: Montague being mushy and Katelynn being not wicked imply that Ansel is not aggressive.\n(BroadMinded(joseph)) ↔ (¬Impossible(joseph)) ::: Joseph is broad-minded if and only if Joseph is not impossible.\n(∃x (¬Mushy(x))) → ((¬Aggressive(whitney) ∧ Impossible(cyril))) ::: If there is at least one people who is not mushy, then Whitney is not aggressive and Cyril is impossible.\n(∃x (BroadMinded(x) ∨ Impossible(x))) → ((Aggressive(olive))) ::: If there is someone who is either broad-minded or impossible, then Olive is aggressive.\n¬(¬BroadMinded(x))→((¬Aggressive(x))) ::: If there is nobody who is not, then Cyril is not broad-minded and Ansel is aggressive.\n((Wicked(olive) ∧ Drab(katelynn))) ↔ ((Aggressive(joseph) ∧ ¬BroadMinded(montague))) ::: Olive is wicked and Katelynn is drab if and only if Joseph is aggressive and Montague is not broad-minded.\n(∃x (Mushy(x))) → ((BroadMinded(katelynn) ∧ ¬Aggressive(joseph))) ::: If there is at least one people who is mushy, then Katelynn is broad-minded and Joseph is not aggressive.\n((Wicked(olive) ∨ BroadMinded(cyril))) → ((Aggressive(katelynn))) ::: Olive being wicked or Cyril being broad-minded implies that Katelynn is aggressive.\n(∃x (Wicked(x) ∧ ¬Mushy(x))) → ((¬Drab(montague))) ::: If there is someone who is both wicked and not mushy, then Montague is not drab.\n((¬Impossible(whitney))) → ((¬Mushy(cyril) ∧ BroadMinded(joseph))) ::: Whitney being not impossible implies that Cyril is not mushy and Joseph is broad-minded.\n(∀x (¬Aggressive(x))) ↔ (∀x (¬Impossible(x))) ::: Someone is not aggressive if and only if he is not impossible.\n(∀x (Aggressive(x) ∧ ¬Drab(x))) ↔ (∀x (¬Impossible(x))) ::: Someone is aggressive and not drab if and only if he is not impossible.\n",
                "First-Order-Logic Question": "Impossible(katelynn) ::: Katelynn is impossible."
            },
            "diff": [
                {
                    "raw": "(∀x (¬x)) → ((¬BroadMinded(cyril) ∧ Aggressive(ansel))) ::: If there is nobody who is not, then Cyril is not broad-minded and Ansel is aggressive.",
                    "gram": "¬(¬BroadMinded(x))→((¬Aggressive(x))) ::: If there is nobody who is not, then Cyril is not broad-minded and Ansel is aggressive."
                }
            ],
            "answer": "C",
            "grammar_answer": "C",
            "backup_answer": "A"
        },
        {
            "id": 562,
            "raw_prog": {
                "First-Order-Logic Rules": "Aggressive(montague) ::: Montague is aggressive.\nImpossible(ansel) ::: Ansel is impossible.\n¬Wicked(cyril) ::: Cyril is not wicked.\n¬Wicked(ansel) ::: Ansel is not wicked.\nDrab(katelynn) ::: Katelynn is drab.\n¬Drab(montague) ::: Montague is not drab.\n¬Mushy(ansel) ::: Ansel is not mushy.\n¬Wicked(joseph) ::: Joseph is not wicked.\nBroadMinded(joseph) ::: Joseph is broad-minded.\nDrab(olive) ::: Olive is drab.\n¬Drab(ansel) ::: Ansel is not drab.\n¬Wicked(montague) ::: Montague is not wicked.\n((Mushy(montague) ∧ ¬Wicked(katelynn))) → ((¬Aggressive(ansel))) ::: Montague being mushy and Katelynn being not wicked imply that Ansel is not aggressive.\n((BroadMinded(joseph))) ↔ ((¬Impossible(joseph))) ::: Joseph is broad-minded if and only if Joseph is not impossible.\n(∃x (¬Mushy(x))) → ((¬Aggressive(whitney) ∧ Impossible(cyril))) ::: If there is at least one people who is not mushy, then Whitney is not aggressive and Cyril is impossible.\n(∃x (BroadMinded(x) ∨ Impossible(x))) → ((Aggressive(olive))) ::: If there is someone who is either broad-minded or impossible, then Olive is aggressive.\n(∀x (¬x)) → ((¬BroadMinded(cyril) ∧ Aggressive(ansel))) ::: If there is nobody who is not, then Cyril is not broad-minded and Ansel is aggressive.\n((Wicked(olive) ∧ Drab(katelynn))) ↔ ((Aggressive(joseph) ∧ ¬BroadMinded(montague))) ::: Olive is wicked and Katelynn is drab if and only if Joseph is aggressive and Montague is not broad-minded.\n(∃x (Mushy(x))) → ((BroadMinded(katelynn) ∧ ¬Aggressive(joseph))) ::: If there is at least one people who is mushy, then Katelynn is broad-minded and Joseph is not aggressive.\n((Wicked(olive) ∨ BroadMinded(cyril))) → ((Aggressive(katelynn))) ::: Olive being wicked or Cyril being broad-minded implies that Katelynn is aggressive.\n(∃x (Wicked(x) ∧ ¬Mushy(x))) → ((¬Drab(montague))) ::: If there is someone who is both wicked and not mushy, then Montague is not drab.\n((¬Impossible(whitney))) → ((¬Mushy(cyril) ∧ BroadMinded(joseph))) ::: Whitney being not impossible implies that Cyril is not mushy and Joseph is broad-minded.\n(∀x (¬Aggressive(x))) ↔ (∀x (¬Impossible(x))) ::: Someone is not aggressive if and only if he is not impossible.\n(∀x (Aggressive(x) ∧ ¬Drab(x))) ↔ (∀x (¬Impossible(x))) ::: Someone is aggressive and not drab if and only if he is not impossible.\n",
                "First-Order-Logic Question": "Impossible(cyril) ::: Cyril is impossible."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "Aggressive(montague) ::: Montague is aggressive.\nImpossible(ansel) ::: Ansel is impossible.\n¬Wicked(cyril) ::: Cyril is not wicked.\n¬Wicked(ansel) ::: Ansel is not wicked.\nDrab(katelynn) ::: Katelynn is drab.\n¬Drab(montague) ::: Montague is not drab.\n¬Mushy(ansel) ::: Ansel is not mushy.\n¬Wicked(joseph) ::: Joseph is not wicked.\nBroadMinded(joseph) ::: Joseph is broad-minded.\nDrab(olive) ::: Olive is drab.\n¬Drab(ansel) ::: Ansel is not drab.\n¬Wicked(montague) ::: Montague is not wicked.\n((Mushy(montague) ∧ ¬Wicked(katelynn))) → ((¬Aggressive(ansel))) ::: Montague being mushy and Katelynn being not wicked imply that Ansel is not aggressive.\n((BroadMinded(joseph))) ↔ ((¬Impossible(joseph))) ::: Joseph is broad-minded if and only if Joseph is not impossible.\n(∃x (¬Mushy(x))) → ((¬Aggressive(whitney) ∧ Impossible(cyril))) ::: If there is at least one people who is not mushy, then Whitney is not aggressive and Cyril is impossible.\n(∃x (BroadMinded(x) ∨ Impossible(x))) → ((Aggressive(olive))) ::: If there is someone who is either broad-minded or impossible, then Olive is aggressive.\n¬(¬BroadMinded(x))→((¬Aggressive(x))) ::: If there is nobody who is not, then Cyril is not broad-minded and Ansel is aggressive.\n((Wicked(olive) ∧ Drab(katelynn))) ↔ ((Aggressive(joseph) ∧ ¬BroadMinded(montague))) ::: Olive is wicked and Katelynn is drab if and only if Joseph is aggressive and Montague is not broad-minded.\n(∃x (Mushy(x))) → ((BroadMinded(katelynn) ∧ ¬Aggressive(joseph))) ::: If there is at least one people who is mushy, then Katelynn is broad-minded and Joseph is not aggressive.\n((Wicked(olive) ∨ BroadMinded(cyril))) → ((Aggressive(katelynn))) ::: Olive being wicked or Cyril being broad-minded implies that Katelynn is aggressive.\n(∃x (Wicked(x) ∧ ¬Mushy(x))) → ((¬Drab(montague))) ::: If there is someone who is both wicked and not mushy, then Montague is not drab.\n((¬Impossible(whitney))) → ((¬Mushy(cyril) ∧ BroadMinded(joseph))) ::: Whitney being not impossible implies that Cyril is not mushy and Joseph is broad-minded.\n(∀x (¬Aggressive(x))) ↔ (∀x (¬Impossible(x))) ::: Someone is not aggressive if and only if he is not impossible.\n(∀x (Aggressive(x) ∧ ¬Drab(x))) ↔ (∀x (¬Impossible(x))) ::: Someone is aggressive and not drab if and only if he is not impossible.\n",
                "First-Order-Logic Question": "Impossible(cyril) ::: Cyril is impossible."
            },
            "diff": [
                {
                    "raw": "(∀x (¬x)) → ((¬BroadMinded(cyril) ∧ Aggressive(ansel))) ::: If there is nobody who is not, then Cyril is not broad-minded and Ansel is aggressive.",
                    "gram": "¬(¬BroadMinded(x))→((¬Aggressive(x))) ::: If there is nobody who is not, then Cyril is not broad-minded and Ansel is aggressive."
                }
            ],
            "answer": "A",
            "grammar_answer": "A",
            "backup_answer": "A"
        },
        {
            "id": 563,
            "raw_prog": {
                "First-Order-Logic Rules": "Aggressive(montague) ::: Montague is aggressive.\nImpossible(ansel) ::: Ansel is impossible.\n¬Wicked(cyril) ::: Cyril is not wicked.\n¬Wicked(ansel) ::: Ansel is not wicked.\nDrab(katelynn) ::: Katelynn is drab.\n¬Drab(montague) ::: Montague is not drab.\n¬Mushy(ansel) ::: Ansel is not mushy.\n¬Wicked(joseph) ::: Joseph is not wicked.\nBroadMinded(joseph) ::: Joseph is broad-minded.\nDrab(olive) ::: Olive is drab.\n¬Drab(ansel) ::: Ansel is not drab.\n¬Wicked(montague) ::: Montague is not wicked.\n((Mushy(montague) ∧ ¬Wicked(katelynn))) → (¬Aggressive(ansel)) ::: Montague being mushy and Katelynn being not wicked imply that Ansel is not aggressive.\n(BroadMinded(joseph)) ↔ (¬Impossible(joseph)) ::: Joseph is broad-minded if and only if Joseph is not impossible.\n(∃x (¬Mushy(x))) → ((¬Aggressive(whitney) ∧ Impossible(cyril))) ::: If there is at least one people who is not mushy, then Whitney is not aggressive and Cyril is impossible.\n(∃x (BroadMinded(x) ∨ Impossible(x))) → (Aggressive(olive)) ::: If there is someone who is either broad-minded or impossible, then Olive is aggressive.\n(¬∃x (¬x)) → ((¬BroadMinded(cyril) ∧ Aggressive(ansel))) ::: If there is nobody who is not, then Cyril is not broad-minded and Ansel is aggressive.\n((Wicked(olive) ∧ Drab(katelynn))) ↔ ((Aggressive(joseph) ∧ ¬BroadMinded(montague))) ::: Olive is wicked and Katelynn is drab if and only if Joseph is aggressive and Montague is not broad-minded.\n(∃x (Mushy(x))) → ((BroadMinded(katelynn) ∧ ¬Aggressive(joseph))) ::: If there is at least one people who is mushy, then Katelynn is broad-minded and Joseph is not aggressive.\n((Wicked(olive) ∨ BroadMinded(cyril))) → (Aggressive(katelynn)) ::: Olive being wicked or Cyril being broad-minded implies that Katelynn is aggressive.\n(∃x (Wicked(x) ∧ ¬Mushy(x))) → (¬Drab(montague)) ::: If there is someone who is both wicked and not mushy, then Montague is not drab.\n((¬Impossible(whitney))) → ((¬Mushy(cyril) ∧ BroadMinded(joseph))) ::: Whitney being not impossible implies that Cyril is not mushy and Joseph is broad-minded.\n(∀x (¬Aggressive(x))) ↔ (∀x (¬Impossible(x))) ::: Someone is not aggressive if and only if he is not impossible.\n(∀x (Aggressive(x) ∧ ¬Drab(x))) ↔ (∀x (¬Impossible(x))) ::: Someone is aggressive and not drab if and only if he is not impossible.\n",
                "First-Order-Logic Question": "Wicked(ansel) ::: Ansel is wicked."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "Aggressive(montague) ::: Montague is aggressive.\nImpossible(ansel) ::: Ansel is impossible.\n¬Wicked(cyril) ::: Cyril is not wicked.\n¬Wicked(ansel) ::: Ansel is not wicked.\nDrab(katelynn) ::: Katelynn is drab.\n¬Drab(montague) ::: Montague is not drab.\n¬Mushy(ansel) ::: Ansel is not mushy.\n¬Wicked(joseph) ::: Joseph is not wicked.\nBroadMinded(joseph) ::: Joseph is broad-minded.\nDrab(olive) ::: Olive is drab.\n¬Drab(ansel) ::: Ansel is not drab.\n¬Wicked(montague) ::: Montague is not wicked.\n((Mushy(montague) ∧ ¬Wicked(katelynn))) → (¬Aggressive(ansel)) ::: Montague being mushy and Katelynn being not wicked imply that Ansel is not aggressive.\n(BroadMinded(joseph)) ↔ (¬Impossible(joseph)) ::: Joseph is broad-minded if and only if Joseph is not impossible.\n(∃x (¬Mushy(x))) → ((¬Aggressive(whitney) ∧ Impossible(cyril))) ::: If there is at least one people who is not mushy, then Whitney is not aggressive and Cyril is impossible.\n(∃x (BroadMinded(x) ∨ Impossible(x))) → (Aggressive(olive)) ::: If there is someone who is either broad-minded or impossible, then Olive is aggressive.\n¬∃x((¬BroadMinded(x)∧Aggressive(x))) ::: If there is nobody who is not, then Cyril is not broad-minded and Ansel is aggressive.\n((Wicked(olive) ∧ Drab(katelynn))) ↔ ((Aggressive(joseph) ∧ ¬BroadMinded(montague))) ::: Olive is wicked and Katelynn is drab if and only if Joseph is aggressive and Montague is not broad-minded.\n(∃x (Mushy(x))) → ((BroadMinded(katelynn) ∧ ¬Aggressive(joseph))) ::: If there is at least one people who is mushy, then Katelynn is broad-minded and Joseph is not aggressive.\n((Wicked(olive) ∨ BroadMinded(cyril))) → (Aggressive(katelynn)) ::: Olive being wicked or Cyril being broad-minded implies that Katelynn is aggressive.\n(∃x (Wicked(x) ∧ ¬Mushy(x))) → (¬Drab(montague)) ::: If there is someone who is both wicked and not mushy, then Montague is not drab.\n((¬Impossible(whitney))) → ((¬Mushy(cyril) ∧ BroadMinded(joseph))) ::: Whitney being not impossible implies that Cyril is not mushy and Joseph is broad-minded.\n(∀x (¬Aggressive(x))) ↔ (∀x (¬Impossible(x))) ::: Someone is not aggressive if and only if he is not impossible.\n(∀x (Aggressive(x) ∧ ¬Drab(x))) ↔ (∀x (¬Impossible(x))) ::: Someone is aggressive and not drab if and only if he is not impossible.\n",
                "First-Order-Logic Question": "Wicked(ansel) ::: Ansel is wicked."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬x)) → ((¬BroadMinded(cyril) ∧ Aggressive(ansel))) ::: If there is nobody who is not, then Cyril is not broad-minded and Ansel is aggressive.",
                    "gram": "¬∃x((¬BroadMinded(x)∧Aggressive(x))) ::: If there is nobody who is not, then Cyril is not broad-minded and Ansel is aggressive."
                }
            ],
            "answer": "B",
            "grammar_answer": "B",
            "backup_answer": "B"
        },
        {
            "id": 564,
            "raw_prog": {
                "First-Order-Logic Rules": "Aggressive(montague) ::: Montague is aggressive.\nImpossible(ansel) ::: Ansel is impossible.\n¬Wicked(cyril) ::: Cyril is not wicked.\n¬Wicked(ansel) ::: Ansel is not wicked.\nDrab(katelynn) ::: Katelynn is drab.\n¬Drab(montague) ::: Montague is not drab.\n¬Mushy(ansel) ::: Ansel is not mushy.\n¬Wicked(joseph) ::: Joseph is not wicked.\nBroadMinded(joseph) ::: Joseph is broad-minded.\nDrab(olive) ::: Olive is drab.\n¬Drab(ansel) ::: Ansel is not drab.\n¬Wicked(montague) ::: Montague is not wicked.\n((Mushy(montague) ∧ ¬Wicked(katelynn))) → (¬Aggressive(ansel)) ::: Montague being mushy and Katelynn being not wicked imply that Ansel is not aggressive.\n(BroadMinded(joseph)) ↔ (¬Impossible(joseph)) ::: Joseph is broad-minded if and only if Joseph is not impossible.\n(∃x (¬Mushy(x))) → ((¬Aggressive(whitney) ∧ Impossible(cyril))) ::: If there is at least one people who is not mushy, then Whitney is not aggressive and Cyril is impossible.\n(∃x (BroadMinded(x) ∨ Impossible(x))) → ((Aggressive(olive))) ::: If there is someone who is either broad-minded or impossible, then Olive is aggressive.\n(¬∃x (¬x)) → ((¬BroadMinded(cyril) ∧ Aggressive(ansel))) ::: If there is nobody who is not, then Cyril is not broad-minded and Ansel is aggressive.\n((Wicked(olive) ∧ Drab(katelynn))) ↔ ((Aggressive(joseph) ∧ ¬BroadMinded(montague))) ::: Olive is wicked and Katelynn is drab if and only if Joseph is aggressive and Montague is not broad-minded.\n(∃x (Mushy(x))) → ((BroadMinded(katelynn) ∧ ¬Aggressive(joseph))) ::: If there is at least one people who is mushy, then Katelynn is broad-minded and Joseph is not aggressive.\n((Wicked(olive) ∨ BroadMinded(cyril))) → ((Aggressive(katelynn))) ::: Olive being wicked or Cyril being broad-minded implies that Katelynn is aggressive.\n(∃x (Wicked(x) ∧ ¬Mushy(x))) → ((¬Drab(montague))) ::: If there is someone who is both wicked and not mushy, then Montague is not drab.\n(¬Impossible(whitney)) → ((¬Mushy(cyril) ∧ BroadMinded(joseph))) ::: Whitney being not impossible implies that Cyril is not mushy and Joseph is broad-minded.\n(∀x (¬Aggressive(x))) ↔ (∀x (¬Impossible(x))) ::: Someone is not aggressive if and only if he is not impossible.\n(∀x (Aggressive(x) ∧ ¬Drab(x))) ↔ (∀x (¬Impossible(x))) ::: Someone is aggressive and not drab if and only if he is not impossible.\n",
                "First-Order-Logic Question": "¬Mushy(ansel) ::: Ansel is not mushy."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "Aggressive(montague) ::: Montague is aggressive.\nImpossible(ansel) ::: Ansel is impossible.\n¬Wicked(cyril) ::: Cyril is not wicked.\n¬Wicked(ansel) ::: Ansel is not wicked.\nDrab(katelynn) ::: Katelynn is drab.\n¬Drab(montague) ::: Montague is not drab.\n¬Mushy(ansel) ::: Ansel is not mushy.\n¬Wicked(joseph) ::: Joseph is not wicked.\nBroadMinded(joseph) ::: Joseph is broad-minded.\nDrab(olive) ::: Olive is drab.\n¬Drab(ansel) ::: Ansel is not drab.\n¬Wicked(montague) ::: Montague is not wicked.\n((Mushy(montague) ∧ ¬Wicked(katelynn))) → (¬Aggressive(ansel)) ::: Montague being mushy and Katelynn being not wicked imply that Ansel is not aggressive.\n(BroadMinded(joseph)) ↔ (¬Impossible(joseph)) ::: Joseph is broad-minded if and only if Joseph is not impossible.\n(∃x (¬Mushy(x))) → ((¬Aggressive(whitney) ∧ Impossible(cyril))) ::: If there is at least one people who is not mushy, then Whitney is not aggressive and Cyril is impossible.\n(∃x (BroadMinded(x) ∨ Impossible(x))) → ((Aggressive(olive))) ::: If there is someone who is either broad-minded or impossible, then Olive is aggressive.\n¬∃x(¬(¬(BroadMinded(x)))) ::: If there is nobody who is not, then Cyril is not broad-minded and Ansel is aggressive.\n((Wicked(olive) ∧ Drab(katelynn))) ↔ ((Aggressive(joseph) ∧ ¬BroadMinded(montague))) ::: Olive is wicked and Katelynn is drab if and only if Joseph is aggressive and Montague is not broad-minded.\n(∃x (Mushy(x))) → ((BroadMinded(katelynn) ∧ ¬Aggressive(joseph))) ::: If there is at least one people who is mushy, then Katelynn is broad-minded and Joseph is not aggressive.\n((Wicked(olive) ∨ BroadMinded(cyril))) → ((Aggressive(katelynn))) ::: Olive being wicked or Cyril being broad-minded implies that Katelynn is aggressive.\n(∃x (Wicked(x) ∧ ¬Mushy(x))) → ((¬Drab(montague))) ::: If there is someone who is both wicked and not mushy, then Montague is not drab.\n(¬Impossible(whitney)) → ((¬Mushy(cyril) ∧ BroadMinded(joseph))) ::: Whitney being not impossible implies that Cyril is not mushy and Joseph is broad-minded.\n(∀x (¬Aggressive(x))) ↔ (∀x (¬Impossible(x))) ::: Someone is not aggressive if and only if he is not impossible.\n(∀x (Aggressive(x) ∧ ¬Drab(x))) ↔ (∀x (¬Impossible(x))) ::: Someone is aggressive and not drab if and only if he is not impossible.\n",
                "First-Order-Logic Question": "¬Mushy(ansel) ::: Ansel is not mushy."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬x)) → ((¬BroadMinded(cyril) ∧ Aggressive(ansel))) ::: If there is nobody who is not, then Cyril is not broad-minded and Ansel is aggressive.",
                    "gram": "¬∃x(¬(¬(BroadMinded(x)))) ::: If there is nobody who is not, then Cyril is not broad-minded and Ansel is aggressive."
                }
            ],
            "answer": "A",
            "grammar_answer": "A",
            "backup_answer": "A"
        },
        {
            "id": 565,
            "raw_prog": {
                "First-Order-Logic Rules": "Aggressive(montague) ::: Montague is aggressive.\nImpossible(ansel) ::: Ansel is impossible.\n¬Wicked(cyril) ::: Cyril is not wicked.\n¬Wicked(ansel) ::: Ansel is not wicked.\nDrab(katelynn) ::: Katelynn is drab.\n¬Drab(montague) ::: Montague is not drab.\n¬Mushy(ansel) ::: Ansel is not mushy.\n¬Wicked(joseph) ::: Joseph is not wicked.\nDrab(olive) ::: Olive is drab.\nBroadMinded(joseph) ::: Joseph is broad-minded.\n¬Drab(ansel) ::: Ansel is not drab.\n¬Wicked(montague) ::: Montague is not wicked.\n((Mushy(montague) ∧ ¬Wicked(katelynn))) → ((¬Aggressive(ansel))) ::: Montague being mushy and Katelynn being not wicked imply that Ansel is not aggressive.\n((BroadMinded(joseph))) ↔ ((¬Impossible(joseph))) ::: Joseph is broad-minded if and only if Joseph is not impossible.\n(∃x (¬Mushy(x))) → ((¬Aggressive(whitney) ∧ Impossible(cyril))) ::: If there is at least one people who is not mushy, then Whitney is not aggressive and Cyril is impossible.\n(∃x (BroadMinded(x) ∨ Impossible(x))) → ((Aggressive(olive))) ::: If there is someone who is either broad-minded or impossible, then Olive is aggressive.\n(¬∃x (¬x)) → ((¬BroadMinded(cyril) ∧ Aggressive(ansel))) ::: If there is nobody who is not, then Cyril is not broad-minded and Ansel is aggressive.\n((Wicked(olive) ∧ Drab(katelynn))) ↔ ((Aggressive(joseph) ∧ ¬BroadMinded(montague))) ::: Olive is wicked and Katelynn is drab if and only if Joseph is aggressive and Montague is not broad-minded.\n(∃x (Mushy(x))) → ((BroadMinded(katelynn) ∧ ¬Aggressive(joseph))) ::: If there is at least one people who is mushy, then Katelynn is broad-minded and Joseph is not aggressive.\n((Wicked(olive) ∨ BroadMinded(cyril))) → ((Aggressive(katelynn))) ::: Olive being wicked or Cyril being broad-minded implies that Katelynn is aggressive.\n(∃x (Wicked(x) ∧ ¬Mushy(x))) → ((¬Drab(montague))) ::: If there is someone who is both wicked and not mushy, then Montague is not drab.\n((¬Impossible(whitney))) → ((¬Mushy(cyril) ∧ BroadMinded(joseph))) ::: Whitney being not impossible implies that Cyril is not mushy and Joseph is broad-minded.\n(∀x (¬Aggressive(x))) ↔ (∀x (¬Impossible(x))) ::: Someone is not aggressive if and only if he is not impossible.\n(∀x (Aggressive(x) ∧ ¬Drab(x))) ↔ (∀x (¬Impossible(x))) ::: Someone is aggressive and not drab if and only if he is not impossible.\n",
                "First-Order-Logic Question": "Impossible(ansel) ::: Ansel is impossible."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "Aggressive(montague) ::: Montague is aggressive.\nImpossible(ansel) ::: Ansel is impossible.\n¬Wicked(cyril) ::: Cyril is not wicked.\n¬Wicked(ansel) ::: Ansel is not wicked.\nDrab(katelynn) ::: Katelynn is drab.\n¬Drab(montague) ::: Montague is not drab.\n¬Mushy(ansel) ::: Ansel is not mushy.\n¬Wicked(joseph) ::: Joseph is not wicked.\nDrab(olive) ::: Olive is drab.\nBroadMinded(joseph) ::: Joseph is broad-minded.\n¬Drab(ansel) ::: Ansel is not drab.\n¬Wicked(montague) ::: Montague is not wicked.\n((Mushy(montague) ∧ ¬Wicked(katelynn))) → ((¬Aggressive(ansel))) ::: Montague being mushy and Katelynn being not wicked imply that Ansel is not aggressive.\n((BroadMinded(joseph))) ↔ ((¬Impossible(joseph))) ::: Joseph is broad-minded if and only if Joseph is not impossible.\n(∃x (¬Mushy(x))) → ((¬Aggressive(whitney) ∧ Impossible(cyril))) ::: If there is at least one people who is not mushy, then Whitney is not aggressive and Cyril is impossible.\n(∃x (BroadMinded(x) ∨ Impossible(x))) → ((Aggressive(olive))) ::: If there is someone who is either broad-minded or impossible, then Olive is aggressive.\n¬∃x((¬BroadMinded(x)∧Aggressive(x))) ::: If there is nobody who is not, then Cyril is not broad-minded and Ansel is aggressive.\n((Wicked(olive) ∧ Drab(katelynn))) ↔ ((Aggressive(joseph) ∧ ¬BroadMinded(montague))) ::: Olive is wicked and Katelynn is drab if and only if Joseph is aggressive and Montague is not broad-minded.\n(∃x (Mushy(x))) → ((BroadMinded(katelynn) ∧ ¬Aggressive(joseph))) ::: If there is at least one people who is mushy, then Katelynn is broad-minded and Joseph is not aggressive.\n((Wicked(olive) ∨ BroadMinded(cyril))) → ((Aggressive(katelynn))) ::: Olive being wicked or Cyril being broad-minded implies that Katelynn is aggressive.\n(∃x (Wicked(x) ∧ ¬Mushy(x))) → ((¬Drab(montague))) ::: If there is someone who is both wicked and not mushy, then Montague is not drab.\n((¬Impossible(whitney))) → ((¬Mushy(cyril) ∧ BroadMinded(joseph))) ::: Whitney being not impossible implies that Cyril is not mushy and Joseph is broad-minded.\n(∀x (¬Aggressive(x))) ↔ (∀x (¬Impossible(x))) ::: Someone is not aggressive if and only if he is not impossible.\n(∀x (Aggressive(x) ∧ ¬Drab(x))) ↔ (∀x (¬Impossible(x))) ::: Someone is aggressive and not drab if and only if he is not impossible.\n",
                "First-Order-Logic Question": "Impossible(ansel) ::: Ansel is impossible."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬x)) → ((¬BroadMinded(cyril) ∧ Aggressive(ansel))) ::: If there is nobody who is not, then Cyril is not broad-minded and Ansel is aggressive.",
                    "gram": "¬∃x((¬BroadMinded(x)∧Aggressive(x))) ::: If there is nobody who is not, then Cyril is not broad-minded and Ansel is aggressive."
                }
            ],
            "answer": "A",
            "grammar_answer": "A",
            "backup_answer": "B"
        },
        {
            "id": 567,
            "raw_prog": {
                "First-Order-Logic Rules": "Aggressive(montague) ::: Montague is aggressive.\nImpossible(ansel) ::: Ansel is impossible.\n¬Wicked(cyril) ::: Cyril is not wicked.\n¬Wicked(ansel) ::: Ansel is not wicked.\nDrab(katelynn) ::: Katelynn is drab.\n¬Drab(montague) ::: Montague is not drab.\n¬Mushy(ansel) ::: Ansel is not mushy.\n¬Wicked(joseph) ::: Joseph is not wicked.\nBroadMinded(joseph) ::: Joseph is broad-minded.\nDrab(olive) ::: Olive is drab.\n¬Drab(ansel) ::: Ansel is not drab.\n¬Wicked(montague) ::: Montague is not wicked.\n((Mushy(montague) ∧ ¬Wicked(katelynn))) → (¬Aggressive(ansel)) ::: Montague being mushy and Katelynn being not wicked imply that Ansel is not aggressive.\n(BroadMinded(joseph)) ↔ (¬Impossible(joseph)) ::: Joseph is broad-minded if and only if Joseph is not impossible.\n(∃x (¬Mushy(x))) → ((¬Aggressive(whitney) ∧ Impossible(cyril))) ::: If there is at least one people who is not mushy, then Whitney is not aggressive and Cyril is impossible.\n(∃x (BroadMinded(x) ∨ Impossible(x))) → ((Aggressive(olive))) ::: If there is someone who is either broad-minded or impossible, then Olive is aggressive.\n(¬∃x (¬x)) → ((¬BroadMinded(cyril) ∧ Aggressive(ansel))) ::: If there is nobody who is not, then Cyril is not broad-minded and Ansel is aggressive.\n((Wicked(olive) ∧ Drab(katelynn))) ↔ ((Aggressive(joseph) ∧ ¬BroadMinded(montague))) ::: Olive is wicked and Katelynn is drab if and only if Joseph is aggressive and Montague is not broad-minded.\n(∃x (Mushy(x))) → ((BroadMinded(katelynn) ∧ ¬Aggressive(joseph))) ::: If there is at least one people who is mushy, then Katelynn is broad-minded and Joseph is not aggressive.\n((Wicked(olive) ∨ BroadMinded(cyril))) → ((Aggressive(katelynn))) ::: Olive being wicked or Cyril being broad-minded implies that Katelynn is aggressive.\n(∃x (Wicked(x) ∧ ¬Mushy(x))) → ((¬Drab(montague))) ::: If there is someone who is both wicked and not mushy, then Montague is not drab.\n(¬Impossible(whitney)) → ((¬Mushy(cyril) ∧ BroadMinded(joseph))) ::: Whitney being not impossible implies that Cyril is not mushy and Joseph is broad-minded.\n(∀x (¬Aggressive(x))) ↔ (∀x (¬Impossible(x))) ::: Someone is not aggressive if and only if he is not impossible.\n(∀x (Aggressive(x) ∧ ¬Drab(x))) ↔ (∀x (¬Impossible(x))) ::: Someone is aggressive and not drab if and only if he is not impossible.\n",
                "First-Order-Logic Question": "¬BroadMinded(olive) ::: Olive is not broad-minded."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "Aggressive(montague) ::: Montague is aggressive.\nImpossible(ansel) ::: Ansel is impossible.\n¬Wicked(cyril) ::: Cyril is not wicked.\n¬Wicked(ansel) ::: Ansel is not wicked.\nDrab(katelynn) ::: Katelynn is drab.\n¬Drab(montague) ::: Montague is not drab.\n¬Mushy(ansel) ::: Ansel is not mushy.\n¬Wicked(joseph) ::: Joseph is not wicked.\nBroadMinded(joseph) ::: Joseph is broad-minded.\nDrab(olive) ::: Olive is drab.\n¬Drab(ansel) ::: Ansel is not drab.\n¬Wicked(montague) ::: Montague is not wicked.\n((Mushy(montague) ∧ ¬Wicked(katelynn))) → (¬Aggressive(ansel)) ::: Montague being mushy and Katelynn being not wicked imply that Ansel is not aggressive.\n(BroadMinded(joseph)) ↔ (¬Impossible(joseph)) ::: Joseph is broad-minded if and only if Joseph is not impossible.\n(∃x (¬Mushy(x))) → ((¬Aggressive(whitney) ∧ Impossible(cyril))) ::: If there is at least one people who is not mushy, then Whitney is not aggressive and Cyril is impossible.\n(∃x (BroadMinded(x) ∨ Impossible(x))) → ((Aggressive(olive))) ::: If there is someone who is either broad-minded or impossible, then Olive is aggressive.\n¬∃x((¬BroadMinded(x)∧Aggressive(x))) ::: If there is nobody who is not, then Cyril is not broad-minded and Ansel is aggressive.\n((Wicked(olive) ∧ Drab(katelynn))) ↔ ((Aggressive(joseph) ∧ ¬BroadMinded(montague))) ::: Olive is wicked and Katelynn is drab if and only if Joseph is aggressive and Montague is not broad-minded.\n(∃x (Mushy(x))) → ((BroadMinded(katelynn) ∧ ¬Aggressive(joseph))) ::: If there is at least one people who is mushy, then Katelynn is broad-minded and Joseph is not aggressive.\n((Wicked(olive) ∨ BroadMinded(cyril))) → ((Aggressive(katelynn))) ::: Olive being wicked or Cyril being broad-minded implies that Katelynn is aggressive.\n(∃x (Wicked(x) ∧ ¬Mushy(x))) → ((¬Drab(montague))) ::: If there is someone who is both wicked and not mushy, then Montague is not drab.\n(¬Impossible(whitney)) → ((¬Mushy(cyril) ∧ BroadMinded(joseph))) ::: Whitney being not impossible implies that Cyril is not mushy and Joseph is broad-minded.\n(∀x (¬Aggressive(x))) ↔ (∀x (¬Impossible(x))) ::: Someone is not aggressive if and only if he is not impossible.\n(∀x (Aggressive(x) ∧ ¬Drab(x))) ↔ (∀x (¬Impossible(x))) ::: Someone is aggressive and not drab if and only if he is not impossible.\n",
                "First-Order-Logic Question": "¬BroadMinded(olive) ::: Olive is not broad-minded."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬x)) → ((¬BroadMinded(cyril) ∧ Aggressive(ansel))) ::: If there is nobody who is not, then Cyril is not broad-minded and Ansel is aggressive.",
                    "gram": "¬∃x((¬BroadMinded(x)∧Aggressive(x))) ::: If there is nobody who is not, then Cyril is not broad-minded and Ansel is aggressive."
                }
            ],
            "answer": "C",
            "grammar_answer": "B",
            "backup_answer": "C"
        },
        {
            "id": 568,
            "raw_prog": {
                "First-Order-Logic Rules": "Aggressive(montague) ::: Montague is aggressive.\nImpossible(ansel) ::: Ansel is impossible.\n¬Wicked(cyril) ::: Cyril is not wicked.\n¬Wicked(ansel) ::: Ansel is not wicked.\nDrab(katelynn) ::: Katelynn is drab.\n¬Drab(montague) ::: Montague is not drab.\n¬Mushy(ansel) ::: Ansel is not mushy.\n¬Wicked(joseph) ::: Joseph is not wicked.\nBroadMinded(joseph) ::: Joseph is broad-minded.\nDrab(olive) ::: Olive is drab.\n¬Drab(ansel) ::: Ansel is not drab.\n¬Wicked(montague) ::: Montague is not wicked.\n((Mushy(montague) ∧ ¬Wicked(katelynn))) → (¬Aggressive(ansel)) ::: Montague being mushy and Katelynn being not wicked imply that Ansel is not aggressive.\n(BroadMinded(joseph)) ↔ (¬Impossible(joseph)) ::: Joseph is broad-minded if and only if Joseph is not impossible.\n(∃x (¬Mushy(x))) → ((¬Aggressive(whitney) ∧ Impossible(cyril))) ::: If there is at least one people who is not mushy, then Whitney is not aggressive and Cyril is impossible.\n(∃x (BroadMinded(x) ∨ Impossible(x))) → (Aggressive(olive)) ::: If there is someone who is either broad-minded or impossible, then Olive is aggressive.\n(∀x (¬x)) → ((¬BroadMinded(cyril) ∧ Aggressive(ansel))) ::: If there is nobody who is not, then Cyril is not broad-minded and Ansel is aggressive.\n((Wicked(olive) ∧ Drab(katelynn))) ↔ ((Aggressive(joseph) ∧ ¬BroadMinded(montague))) ::: Olive is wicked and Katelynn is drab if and only if Joseph is aggressive and Montague is not broad-minded.\n(∃x (Mushy(x))) → ((BroadMinded(katelynn) ∧ ¬Aggressive(joseph))) ::: If there is at least one people who is mushy, then Katelynn is broad-minded and Joseph is not aggressive.\n((Wicked(olive) ∨ BroadMinded(cyril))) → (Aggressive(katelynn)) ::: Olive being wicked or Cyril being broad-minded implies that Katelynn is aggressive.\n(∃x (Wicked(x) ∧ ¬Mushy(x))) → (¬Drab(montague)) ::: If there is someone who is both wicked and not mushy, then Montague is not drab.\n(¬Impossible(whitney)) → ((¬Mushy(cyril) ∧ BroadMinded(joseph))) ::: Whitney being not impossible implies that Cyril is not mushy and Joseph is broad-minded.\n(∀x (¬Aggressive(x))) ↔ (∀x (¬Impossible(x))) ::: Someone is not aggressive if and only if he is not impossible.\n(∀x (Aggressive(x) ∧ ¬Drab(x))) ↔ (∀x (¬Impossible(x))) ::: Someone is aggressive and not drab if and only if he is not impossible.\n",
                "First-Order-Logic Question": "¬Wicked(montague) ::: Montague is not wicked."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "Aggressive(montague) ::: Montague is aggressive.\nImpossible(ansel) ::: Ansel is impossible.\n¬Wicked(cyril) ::: Cyril is not wicked.\n¬Wicked(ansel) ::: Ansel is not wicked.\nDrab(katelynn) ::: Katelynn is drab.\n¬Drab(montague) ::: Montague is not drab.\n¬Mushy(ansel) ::: Ansel is not mushy.\n¬Wicked(joseph) ::: Joseph is not wicked.\nBroadMinded(joseph) ::: Joseph is broad-minded.\nDrab(olive) ::: Olive is drab.\n¬Drab(ansel) ::: Ansel is not drab.\n¬Wicked(montague) ::: Montague is not wicked.\n((Mushy(montague) ∧ ¬Wicked(katelynn))) → (¬Aggressive(ansel)) ::: Montague being mushy and Katelynn being not wicked imply that Ansel is not aggressive.\n(BroadMinded(joseph)) ↔ (¬Impossible(joseph)) ::: Joseph is broad-minded if and only if Joseph is not impossible.\n(∃x (¬Mushy(x))) → ((¬Aggressive(whitney) ∧ Impossible(cyril))) ::: If there is at least one people who is not mushy, then Whitney is not aggressive and Cyril is impossible.\n(∃x (BroadMinded(x) ∨ Impossible(x))) → (Aggressive(olive)) ::: If there is someone who is either broad-minded or impossible, then Olive is aggressive.\n¬(¬BroadMinded(x))→((¬Aggressive(x))) ::: If there is nobody who is not, then Cyril is not broad-minded and Ansel is aggressive.\n((Wicked(olive) ∧ Drab(katelynn))) ↔ ((Aggressive(joseph) ∧ ¬BroadMinded(montague))) ::: Olive is wicked and Katelynn is drab if and only if Joseph is aggressive and Montague is not broad-minded.\n(∃x (Mushy(x))) → ((BroadMinded(katelynn) ∧ ¬Aggressive(joseph))) ::: If there is at least one people who is mushy, then Katelynn is broad-minded and Joseph is not aggressive.\n((Wicked(olive) ∨ BroadMinded(cyril))) → (Aggressive(katelynn)) ::: Olive being wicked or Cyril being broad-minded implies that Katelynn is aggressive.\n(∃x (Wicked(x) ∧ ¬Mushy(x))) → (¬Drab(montague)) ::: If there is someone who is both wicked and not mushy, then Montague is not drab.\n(¬Impossible(whitney)) → ((¬Mushy(cyril) ∧ BroadMinded(joseph))) ::: Whitney being not impossible implies that Cyril is not mushy and Joseph is broad-minded.\n(∀x (¬Aggressive(x))) ↔ (∀x (¬Impossible(x))) ::: Someone is not aggressive if and only if he is not impossible.\n(∀x (Aggressive(x) ∧ ¬Drab(x))) ↔ (∀x (¬Impossible(x))) ::: Someone is aggressive and not drab if and only if he is not impossible.\n",
                "First-Order-Logic Question": "¬Wicked(montague) ::: Montague is not wicked."
            },
            "diff": [
                {
                    "raw": "(∀x (¬x)) → ((¬BroadMinded(cyril) ∧ Aggressive(ansel))) ::: If there is nobody who is not, then Cyril is not broad-minded and Ansel is aggressive.",
                    "gram": "¬(¬BroadMinded(x))→((¬Aggressive(x))) ::: If there is nobody who is not, then Cyril is not broad-minded and Ansel is aggressive."
                }
            ],
            "answer": "A",
            "grammar_answer": "A",
            "backup_answer": "A"
        },
        {
            "id": 569,
            "raw_prog": {
                "First-Order-Logic Rules": "Aggressive(montague) ::: Montague is aggressive.\nImpossible(ansel) ::: Ansel is impossible.\n¬Wicked(cyril) ::: Cyril is not wicked.\n¬Wicked(ansel) ::: Ansel is not wicked.\nDrab(katelynn) ::: Katelynn is drab.\n¬Drab(montague) ::: Montague is not drab.\n¬Mushy(ansel) ::: Ansel is not mushy.\n¬Wicked(joseph) ::: Joseph is not wicked.\nBroadMinded(joseph) ::: Joseph is broad-minded.\nDrab(olive) ::: Olive is drab.\n¬Drab(ansel) ::: Ansel is not drab.\n¬Wicked(montague) ::: Montague is not wicked.\n((Mushy(montague) ∧ ¬Wicked(katelynn))) → (¬Aggressive(ansel)) ::: Montague being mushy and Katelynn being not wicked imply that Ansel is not aggressive.\n(BroadMinded(joseph)) ↔ (¬Impossible(joseph)) ::: Joseph is broad-minded if and only if Joseph is not impossible.\n(∃x (¬Mushy(x))) → ((¬Aggressive(whitney) ∧ Impossible(cyril))) ::: If there is at least one people who is not mushy, then Whitney is not aggressive and Cyril is impossible.\n(∃x (BroadMinded(x) ∨ Impossible(x))) → (Aggressive(olive)) ::: If there is someone who is either broad-minded or impossible, then Olive is aggressive.\n(∀x (¬x)) → ((¬BroadMinded(cyril) ∧ Aggressive(ansel))) ::: If there is nobody who is not, then Cyril is not broad-minded and Ansel is aggressive.\n((Wicked(olive) ∧ Drab(katelynn))) ↔ ((Aggressive(joseph) ∧ ¬BroadMinded(montague))) ::: Olive is wicked and Katelynn is drab if and only if Joseph is aggressive and Montague is not broad-minded.\n(∃x (Mushy(x))) → ((BroadMinded(katelynn) ∧ ¬Aggressive(joseph))) ::: If there is at least one people who is mushy, then Katelynn is broad-minded and Joseph is not aggressive.\n((Wicked(olive) ∨ BroadMinded(cyril))) → (Aggressive(katelynn)) ::: Olive being wicked or Cyril being broad-minded implies that Katelynn is aggressive.\n(∃x (Wicked(x) ∧ ¬Mushy(x))) → (¬Drab(montague)) ::: If there is someone who is both wicked and not mushy, then Montague is not drab.\n(¬Impossible(whitney)) → ((¬Mushy(cyril) ∧ BroadMinded(joseph))) ::: Whitney being not impossible implies that Cyril is not mushy and Joseph is broad-minded.\n(∀x (¬Aggressive(x))) ↔ (∀x (¬Impossible(x))) ::: Someone is not aggressive if and only if he is not impossible.\n(∀x (Aggressive(x) ∧ ¬Drab(x))) ↔ (∀x (¬Impossible(x))) ::: Someone is aggressive and not drab if and only if he is not impossible.\n",
                "First-Order-Logic Question": "Wicked(joseph) ::: Joseph is wicked."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "Aggressive(montague) ::: Montague is aggressive.\nImpossible(ansel) ::: Ansel is impossible.\n¬Wicked(cyril) ::: Cyril is not wicked.\n¬Wicked(ansel) ::: Ansel is not wicked.\nDrab(katelynn) ::: Katelynn is drab.\n¬Drab(montague) ::: Montague is not drab.\n¬Mushy(ansel) ::: Ansel is not mushy.\n¬Wicked(joseph) ::: Joseph is not wicked.\nBroadMinded(joseph) ::: Joseph is broad-minded.\nDrab(olive) ::: Olive is drab.\n¬Drab(ansel) ::: Ansel is not drab.\n¬Wicked(montague) ::: Montague is not wicked.\n((Mushy(montague) ∧ ¬Wicked(katelynn))) → (¬Aggressive(ansel)) ::: Montague being mushy and Katelynn being not wicked imply that Ansel is not aggressive.\n(BroadMinded(joseph)) ↔ (¬Impossible(joseph)) ::: Joseph is broad-minded if and only if Joseph is not impossible.\n(∃x (¬Mushy(x))) → ((¬Aggressive(whitney) ∧ Impossible(cyril))) ::: If there is at least one people who is not mushy, then Whitney is not aggressive and Cyril is impossible.\n(∃x (BroadMinded(x) ∨ Impossible(x))) → (Aggressive(olive)) ::: If there is someone who is either broad-minded or impossible, then Olive is aggressive.\n¬(¬BroadMinded(x))→((¬Aggressive(x))) ::: If there is nobody who is not, then Cyril is not broad-minded and Ansel is aggressive.\n((Wicked(olive) ∧ Drab(katelynn))) ↔ ((Aggressive(joseph) ∧ ¬BroadMinded(montague))) ::: Olive is wicked and Katelynn is drab if and only if Joseph is aggressive and Montague is not broad-minded.\n(∃x (Mushy(x))) → ((BroadMinded(katelynn) ∧ ¬Aggressive(joseph))) ::: If there is at least one people who is mushy, then Katelynn is broad-minded and Joseph is not aggressive.\n((Wicked(olive) ∨ BroadMinded(cyril))) → (Aggressive(katelynn)) ::: Olive being wicked or Cyril being broad-minded implies that Katelynn is aggressive.\n(∃x (Wicked(x) ∧ ¬Mushy(x))) → (¬Drab(montague)) ::: If there is someone who is both wicked and not mushy, then Montague is not drab.\n(¬Impossible(whitney)) → ((¬Mushy(cyril) ∧ BroadMinded(joseph))) ::: Whitney being not impossible implies that Cyril is not mushy and Joseph is broad-minded.\n(∀x (¬Aggressive(x))) ↔ (∀x (¬Impossible(x))) ::: Someone is not aggressive if and only if he is not impossible.\n(∀x (Aggressive(x) ∧ ¬Drab(x))) ↔ (∀x (¬Impossible(x))) ::: Someone is aggressive and not drab if and only if he is not impossible.\n",
                "First-Order-Logic Question": "Wicked(joseph) ::: Joseph is wicked."
            },
            "diff": [
                {
                    "raw": "(∀x (¬x)) → ((¬BroadMinded(cyril) ∧ Aggressive(ansel))) ::: If there is nobody who is not, then Cyril is not broad-minded and Ansel is aggressive.",
                    "gram": "¬(¬BroadMinded(x))→((¬Aggressive(x))) ::: If there is nobody who is not, then Cyril is not broad-minded and Ansel is aggressive."
                }
            ],
            "answer": "B",
            "grammar_answer": "B",
            "backup_answer": "B"
        },
        {
            "id": 780,
            "raw_prog": {
                "First-Order-Logic Rules": "Octagonal(owen) ::: Owen is octagonal.\n¬Sour(molly) ::: Molly is not sour.\n¬Significant(owen) ::: Owen is not significant.\n¬Wild(tristan) ::: Tristan is not wild.\nSignificant(luther) ::: Luther is significant.\n¬Wild(adam) ::: Adam is not wild.\n¬Wonderful(adam) ::: Adam is not wonderful.\nSour(morgan) ::: Morgan is sour.\nSour(tristan) ::: Tristan is sour.\nSour(godwin) ::: Godwin is sour.\nWonderful(owen) ::: Owen is wonderful.\n¬Wild(molly) ::: Molly is not wild.\n(∀x (Putrid(x) ∧ ¬Sour(x))) ↔ (∀x (Octagonal(x) ∧ ¬Wonderful(x))) ::: Someone is putrid and not sour if and only if he is octagonal and not wonderful.\n(¬∃x (¬Significant(x))) → (Significant(owen)) ::: If there is nobody who is not significant, then Owen is significant.\n(∀x (Significant(x))) ↔ (∀x (¬Wonderful(x))) ::: Someone is significant if and only if he is not wonderful.\n(∃x (¬Significant(x))) → ((¬Putrid(godwin) ∧ Wild(molly))) ::: If there is at least one people who is not significant, then Godwin is not putrid and Molly is wild.\n(∀x (Wonderful(x) ∨ Sour(x))) → (∀x (Wild(x))) ::: If someone is wonderful or he is sour, then he is wild.\n((Putrid(owen))) → ((¬Octagonal(molly) ∧ ¬Wonderful(adam))) ::: Owen being putrid implies that Molly is not octagonal and Adam is not wonderful.\n(∀x (¬Sour(x))) → (∀x (¬Significant(x))) ::: All not sour people are not significant.\n(∀x (¬Significant(x))) → ((Wonderful(godwin) ∧ ¬Octagonal(luther))) ::: If everyone is not significant, then Godwin is wonderful and Luther is not octagonal.\n(∀x (Wild(x))) → (∀x (Wonderful(x))) ::: If someone is wild, then he is wonderful.\n(∃x (Wild(x))) → ((Octagonal(godwin) ∧ Sour(morgan))) ::: If there is someone who is wild, then Godwin is octagonal and Morgan is sour.\n(∀x (¬Wonderful(x) ∧ ¬Putrid(x))) ↔ (∀x (Wild(x))) ::: Someone is not wonderful and not putrid if and only if he is wild.\n((Sour(molly) ∧ ¬Wild(molly))) → (¬Wonderful(owen)) ::: It can be concluded that Owen is not wonderful once knowing that Molly is sour and Molly is not wild.\n",
                "First-Order-Logic Question": "¬Wonderful(luther) ::: Luther is not wonderful."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "Octagonal(owen) ::: Owen is octagonal.\n¬Sour(molly) ::: Molly is not sour.\n¬Significant(owen) ::: Owen is not significant.\n¬Wild(tristan) ::: Tristan is not wild.\nSignificant(luther) ::: Luther is significant.\n¬Wild(adam) ::: Adam is not wild.\n¬Wonderful(adam) ::: Adam is not wonderful.\nSour(morgan) ::: Morgan is sour.\nSour(tristan) ::: Tristan is sour.\nSour(godwin) ::: Godwin is sour.\nWonderful(owen) ::: Owen is wonderful.\n¬Wild(molly) ::: Molly is not wild.\n(∀x (Putrid(x) ∧ ¬Sour(x))) ↔ (∀x (Octagonal(x) ∧ ¬Wonderful(x))) ::: Someone is putrid and not sour if and only if he is octagonal and not wonderful.\n¬∃x(¬Significant(x))→Significant(x) ::: If there is nobody who is not significant, then Owen is significant.\n(∀x (Significant(x))) ↔ (∀x (¬Wonderful(x))) ::: Someone is significant if and only if he is not wonderful.\n(∃x (¬Significant(x))) → ((¬Putrid(godwin) ∧ Wild(molly))) ::: If there is at least one people who is not significant, then Godwin is not putrid and Molly is wild.\n(∀x (Wonderful(x) ∨ Sour(x))) → (∀x (Wild(x))) ::: If someone is wonderful or he is sour, then he is wild.\n((Putrid(owen))) → ((¬Octagonal(molly) ∧ ¬Wonderful(adam))) ::: Owen being putrid implies that Molly is not octagonal and Adam is not wonderful.\n(∀x (¬Sour(x))) → (∀x (¬Significant(x))) ::: All not sour people are not significant.\n(∀x (¬Significant(x))) → ((Wonderful(godwin) ∧ ¬Octagonal(luther))) ::: If everyone is not significant, then Godwin is wonderful and Luther is not octagonal.\n(∀x (Wild(x))) → (∀x (Wonderful(x))) ::: If someone is wild, then he is wonderful.\n(∃x (Wild(x))) → ((Octagonal(godwin) ∧ Sour(morgan))) ::: If there is someone who is wild, then Godwin is octagonal and Morgan is sour.\n(∀x (¬Wonderful(x) ∧ ¬Putrid(x))) ↔ (∀x (Wild(x))) ::: Someone is not wonderful and not putrid if and only if he is wild.\n((Sour(molly) ∧ ¬Wild(molly))) → (¬Wonderful(owen)) ::: It can be concluded that Owen is not wonderful once knowing that Molly is sour and Molly is not wild.\n",
                "First-Order-Logic Question": "¬Wonderful(luther) ::: Luther is not wonderful."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬Significant(x))) → (Significant(owen)) ::: If there is nobody who is not significant, then Owen is significant.",
                    "gram": "¬∃x(¬Significant(x))→Significant(x) ::: If there is nobody who is not significant, then Owen is significant."
                }
            ],
            "answer": "A",
            "grammar_answer": "A",
            "backup_answer": "A"
        },
        {
            "id": 781,
            "raw_prog": {
                "First-Order-Logic Rules": [
                    "Octagonal(owen) ::: Owen is octagonal.",
                    "¬Sour(molly) ::: Molly is not sour.",
                    "¬Significant(owen) ::: Owen is not significant.",
                    "¬Wild(tristan) ::: Tristan is not wild.",
                    "Significant(luther) ::: Luther is significant.",
                    "¬Wild(adam) ::: Adam is not wild.",
                    "¬Wonderful(adam) ::: Adam is not wonderful.",
                    "Sour(morgan) ::: Morgan is sour.",
                    "Sour(tristan) ::: Tristan is sour.",
                    "Sour(godwin) ::: Godwin is sour.",
                    "Wonderful(owen) ::: Owen is wonderful.",
                    "¬Wild(molly) ::: Molly is not wild.",
                    "(∀x (Putrid(x) ∧ ¬Sour(x))) ↔ (∀x (Octagonal(x) ∧ ¬Wonderful(x))) ::: Someone is putrid and not sour if and only if he is octagonal and not wonderful.",
                    "(¬∃x (¬Significant(x))) → (Significant(owen)) ::: If there is nobody who is not significant, then Owen is significant.",
                    "(∀x (Significant(x))) ↔ (∀x (¬Wonderful(x))) ::: Someone is significant if and only if he is not wonderful.",
                    "(∃x (¬Significant(x))) → ((¬Putrid(godwin) ∧ Wild(molly))) ::: If there is at least one people who is not significant, then Godwin is not putrid and Molly is wild.",
                    "(∀x (Wonderful(x) ∨ Sour(x))) → (∀x (Wild(x))) ::: If someone is wonderful or he is sour, then he is wild.",
                    "(Putrid(owen)) → ((¬Octagonal(molly) ∧ ¬Wonderful(adam))) ::: Owen being putrid implies that Molly is not octagonal and Adam is not wonderful.",
                    "(∀x (¬Sour(x))) → (∀x (¬Significant(x))) ::: All not sour people are not significant.",
                    "(∀x (¬Significant(x))) → ((Wonderful(godwin) ∧ ¬Octagonal(luther))) ::: If everyone is not significant, then Godwin is wonderful and Luther is not octagonal.",
                    "(∀x (Wild(x))) → (∀x (Wonderful(x))) ::: If someone is wild, then he is wonderful.",
                    "(∃x (Wild(x))) → ((Octagonal(godwin) ∧ Sour(morgan))) ::: If there is someone who is wild, then Godwin is octagonal and Morgan is sour.",
                    "(∀x (¬Wonderful(x) ∧ ¬Putrid(x))) ↔ (∀x (Wild(x))) ::: Someone is not wonderful and not putrid if and only if he is wild.",
                    "((Sour(molly) ∧ ¬Wild(molly))) → (¬Wonderful(owen)) ::: It can be concluded that Owen is not wonderful once knowing that Molly is sour and Molly is not wild."
                ],
                "First-Order-Logic Question": "¬Wonderful(adam) ::: Adam is not wonderful."
            },
            "gram_prog": {
                "First-Order-Logic Rules": [
                    "Octagonal(owen) ::: Owen is octagonal.",
                    "¬Sour(molly) ::: Molly is not sour.",
                    "¬Significant(owen) ::: Owen is not significant.",
                    "¬Wild(tristan) ::: Tristan is not wild.",
                    "Significant(luther) ::: Luther is significant.",
                    "¬Wild(adam) ::: Adam is not wild.",
                    "¬Wonderful(adam) ::: Adam is not wonderful.",
                    "Sour(morgan) ::: Morgan is sour.",
                    "Sour(tristan) ::: Tristan is sour.",
                    "Sour(godwin) ::: Godwin is sour.",
                    "Wonderful(owen) ::: Owen is wonderful.",
                    "¬Wild(molly) ::: Molly is not wild.",
                    "(∀x (Putrid(x) ∧ ¬Sour(x))) ↔ (∀x (Octagonal(x) ∧ ¬Wonderful(x))) ::: Someone is putrid and not sour if and only if he is octagonal and not wonderful.",
                    "¬∃x(¬Significant(x))→Significant(x) ::: If there is nobody who is not significant, then Owen is significant.",
                    "(∀x (Significant(x))) ↔ (∀x (¬Wonderful(x))) ::: Someone is significant if and only if he is not wonderful.",
                    "(∃x (¬Significant(x))) → ((¬Putrid(godwin) ∧ Wild(molly))) ::: If there is at least one people who is not significant, then Godwin is not putrid and Molly is wild.",
                    "(∀x (Wonderful(x) ∨ Sour(x))) → (∀x (Wild(x))) ::: If someone is wonderful or he is sour, then he is wild.",
                    "(Putrid(owen)) → ((¬Octagonal(molly) ∧ ¬Wonderful(adam))) ::: Owen being putrid implies that Molly is not octagonal and Adam is not wonderful.",
                    "(∀x (¬Sour(x))) → (∀x (¬Significant(x))) ::: All not sour people are not significant.",
                    "(∀x (¬Significant(x))) → ((Wonderful(godwin) ∧ ¬Octagonal(luther))) ::: If everyone is not significant, then Godwin is wonderful and Luther is not octagonal.",
                    "(∀x (Wild(x))) → (∀x (Wonderful(x))) ::: If someone is wild, then he is wonderful.",
                    "(∃x (Wild(x))) → ((Octagonal(godwin) ∧ Sour(morgan))) ::: If there is someone who is wild, then Godwin is octagonal and Morgan is sour.",
                    "(∀x (¬Wonderful(x) ∧ ¬Putrid(x))) ↔ (∀x (Wild(x))) ::: Someone is not wonderful and not putrid if and only if he is wild.",
                    "((Sour(molly) ∧ ¬Wild(molly))) → (¬Wonderful(owen)) ::: It can be concluded that Owen is not wonderful once knowing that Molly is sour and Molly is not wild."
                ],
                "First-Order-Logic Question": "¬Wonderful(adam) ::: Adam is not wonderful."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬Significant(x))) → (Significant(owen)) ::: If there is nobody who is not significant, then Owen is significant.",
                    "gram": "¬∃x(¬Significant(x))→Significant(x) ::: If there is nobody who is not significant, then Owen is significant."
                }
            ],
            "answer": "A",
            "grammar_answer": "A",
            "backup_answer": "A"
        },
        {
            "id": 782,
            "raw_prog": {
                "First-Order-Logic Rules": "Octagonal(owen) ::: Owen is octagonal.\n¬Sour(molly) ::: Molly is not sour.\n¬Significant(owen) ::: Owen is not significant.\n¬Wild(tristan) ::: Tristan is not wild.\nSignificant(luther) ::: Luther is significant.\n¬Wild(adam) ::: Adam is not wild.\n¬Wonderful(adam) ::: Adam is not wonderful.\nSour(morgan) ::: Morgan is sour.\nSour(tristan) ::: Tristan is sour.\nSour(godwin) ::: Godwin is sour.\nWonderful(owen) ::: Owen is wonderful.\n¬Wild(molly) ::: Molly is not wild.\n(∀x (Putrid(x) ∧ ¬Sour(x))) ↔ (∀x (Octagonal(x) ∧ ¬Wonderful(x))) ::: Someone is putrid and not sour if and only if he is octagonal and not wonderful.\n(¬∃x (¬x)) → (Significant(owen)) ::: If there is nobody who is not, then Owen is significant.\n(∀x (Significant(x))) ↔ (∀x (¬Wonderful(x))) ::: Someone is significant if and only if he is not wonderful.\n(∃x (¬Significant(x))) → ((¬Putrid(godwin) ∧ Wild(molly))) ::: If there is at least one people who is not significant, then Godwin is not putrid and Molly is wild.\n(∀x (Wonderful(x) ∨ Sour(x))) → (∀x (Wild(x))) ::: If someone is wonderful or he is sour, then he is wild.\n((Putrid(owen))) → ((¬Octagonal(molly) ∧ ¬Wonderful(adam))) ::: Owen being putrid implies that Molly is not octagonal and Adam is not wonderful.\n(∀x (¬Sour(x))) → (∀x (¬Significant(x))) ::: All not sour people are not significant.\n(∀x (¬Significant(x))) → ((Wonderful(godwin) ∧ ¬Octagonal(luther))) ::: If everyone is not significant, then Godwin is wonderful and Luther is not octagonal.\n(∀x (Wild(x))) → (∀x (Wonderful(x))) ::: If someone is wild, then he is wonderful.\n(∃x (Wild(x))) → ((Octagonal(godwin) ∧ Sour(morgan))) ::: If there is someone who is wild, then Godwin is octagonal and Morgan is sour.\n(∀x (¬Wonderful(x) ∧ ¬Putrid(x))) ↔ (∀x (Wild(x))) ::: Someone is not wonderful and not putrid if and only if he is wild.\n((Sour(molly) ∧ ¬Wild(molly))) → ((¬Wonderful(owen))) ::: It can be concluded that Owen is not wonderful once knowing that Molly is sour and Molly is not wild.\n",
                "First-Order-Logic Question": "Wild(morgan) ::: Morgan is wild."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "Octagonal(owen) ::: Owen is octagonal.\n¬Sour(molly) ::: Molly is not sour.\n¬Significant(owen) ::: Owen is not significant.\n¬Wild(tristan) ::: Tristan is not wild.\nSignificant(luther) ::: Luther is significant.\n¬Wild(adam) ::: Adam is not wild.\n¬Wonderful(adam) ::: Adam is not wonderful.\nSour(morgan) ::: Morgan is sour.\nSour(tristan) ::: Tristan is sour.\nSour(godwin) ::: Godwin is sour.\nWonderful(owen) ::: Owen is wonderful.\n¬Wild(molly) ::: Molly is not wild.\n(∀x (Putrid(x) ∧ ¬Sour(x))) ↔ (∀x (Octagonal(x) ∧ ¬Wonderful(x))) ::: Someone is putrid and not sour if and only if he is octagonal and not wonderful.\n¬∃x(¬(¬(Octagonal(x)))) ::: If there is nobody who is not, then Owen is significant.\n(∀x (Significant(x))) ↔ (∀x (¬Wonderful(x))) ::: Someone is significant if and only if he is not wonderful.\n(∃x (¬Significant(x))) → ((¬Putrid(godwin) ∧ Wild(molly))) ::: If there is at least one people who is not significant, then Godwin is not putrid and Molly is wild.\n(∀x (Wonderful(x) ∨ Sour(x))) → (∀x (Wild(x))) ::: If someone is wonderful or he is sour, then he is wild.\n((Putrid(owen))) → ((¬Octagonal(molly) ∧ ¬Wonderful(adam))) ::: Owen being putrid implies that Molly is not octagonal and Adam is not wonderful.\n(∀x (¬Sour(x))) → (∀x (¬Significant(x))) ::: All not sour people are not significant.\n(∀x (¬Significant(x))) → ((Wonderful(godwin) ∧ ¬Octagonal(luther))) ::: If everyone is not significant, then Godwin is wonderful and Luther is not octagonal.\n(∀x (Wild(x))) → (∀x (Wonderful(x))) ::: If someone is wild, then he is wonderful.\n(∃x (Wild(x))) → ((Octagonal(godwin) ∧ Sour(morgan))) ::: If there is someone who is wild, then Godwin is octagonal and Morgan is sour.\n(∀x (¬Wonderful(x) ∧ ¬Putrid(x))) ↔ (∀x (Wild(x))) ::: Someone is not wonderful and not putrid if and only if he is wild.\n((Sour(molly) ∧ ¬Wild(molly))) → ((¬Wonderful(owen))) ::: It can be concluded that Owen is not wonderful once knowing that Molly is sour and Molly is not wild.\n",
                "First-Order-Logic Question": "Wild(morgan) ::: Morgan is wild."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬x)) → (Significant(owen)) ::: If there is nobody who is not, then Owen is significant.",
                    "gram": "¬∃x(¬(¬(Octagonal(x)))) ::: If there is nobody who is not, then Owen is significant."
                }
            ],
            "answer": "A",
            "grammar_answer": "A",
            "backup_answer": "A"
        },
        {
            "id": 783,
            "raw_prog": {
                "First-Order-Logic Rules": "Octagonal(owen) ::: Owen is octagonal.\n¬Sour(molly) ::: Molly is not sour.\n¬Significant(owen) ::: Owen is not significant.\n¬Wild(tristan) ::: Tristan is not wild.\nSignificant(luther) ::: Luther is significant.\n¬Wild(adam) ::: Adam is not wild.\n¬Wonderful(adam) ::: Adam is not wonderful.\nSour(morgan) ::: Morgan is sour.\nSour(tristan) ::: Tristan is sour.\nSour(godwin) ::: Godwin is sour.\nWonderful(owen) ::: Owen is wonderful.\n¬Wild(molly) ::: Molly is not wild.\n(∀x (Putrid(x) ∧ ¬Sour(x))) ↔ (∀x (Octagonal(x) ∧ ¬Wonderful(x))) ::: Someone is putrid and not sour if and only if he is octagonal and not wonderful.\n(¬∃x (¬Significant(x))) → (Significant(owen)) ::: If there is nobody who is not significant, then Owen is significant.\n(∀x (Significant(x))) ↔ (∀x (¬Wonderful(x))) ::: Someone is significant if and only if he is not wonderful.\n(∃x (¬Significant(x))) → ((¬Putrid(godwin) ∧ Wild(molly))) ::: If there is at least one people who is not significant, then Godwin is not putrid and Molly is wild.\n(∀x (Wonderful(x) ∨ Sour(x))) → (∀x (Wild(x))) ::: If someone is wonderful or he is sour, then he is wild.\n((Putrid(owen))) → ((¬Octagonal(molly) ∧ ¬Wonderful(adam))) ::: Owen being putrid implies that Molly is not octagonal and Adam is not wonderful.\n(∀x (¬Sour(x))) → (∀x (¬Significant(x))) ::: All not sour people are not significant.\n(∀x (¬Significant(x))) → ((Wonderful(godwin) ∧ ¬Octagonal(luther))) ::: If everyone is not significant, then Godwin is wonderful and Luther is not octagonal.\n(∀x (Wild(x))) → (∀x (Wonderful(x))) ::: If someone is wild, then he is wonderful.\n(∃x (Wild(x))) → ((Octagonal(godwin) ∧ Sour(morgan))) ::: If there is someone who is wild, then Godwin is octagonal and Morgan is sour.\n(∀x (¬Wonderful(x) ∧ ¬Putrid(x))) ↔ (∀x (Wild(x))) ::: Someone is not wonderful and not putrid if and only if he is wild.\n((Sour(molly) ∧ ¬Wild(molly))) → ((¬Wonderful(owen))) ::: It can be concluded that Owen is not wonderful once knowing that Molly is sour and Molly is not wild.\n",
                "First-Order-Logic Question": "¬Sour(luther) ::: Luther is not sour."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "Octagonal(owen) ::: Owen is octagonal.\n¬Sour(molly) ::: Molly is not sour.\n¬Significant(owen) ::: Owen is not significant.\n¬Wild(tristan) ::: Tristan is not wild.\nSignificant(luther) ::: Luther is significant.\n¬Wild(adam) ::: Adam is not wild.\n¬Wonderful(adam) ::: Adam is not wonderful.\nSour(morgan) ::: Morgan is sour.\nSour(tristan) ::: Tristan is sour.\nSour(godwin) ::: Godwin is sour.\nWonderful(owen) ::: Owen is wonderful.\n¬Wild(molly) ::: Molly is not wild.\n(∀x (Putrid(x) ∧ ¬Sour(x))) ↔ (∀x (Octagonal(x) ∧ ¬Wonderful(x))) ::: Someone is putrid and not sour if and only if he is octagonal and not wonderful.\n¬∃x(¬Significant(x))→Significant(x) ::: If there is nobody who is not significant, then Owen is significant.\n(∀x (Significant(x))) ↔ (∀x (¬Wonderful(x))) ::: Someone is significant if and only if he is not wonderful.\n(∃x (¬Significant(x))) → ((¬Putrid(godwin) ∧ Wild(molly))) ::: If there is at least one people who is not significant, then Godwin is not putrid and Molly is wild.\n(∀x (Wonderful(x) ∨ Sour(x))) → (∀x (Wild(x))) ::: If someone is wonderful or he is sour, then he is wild.\n((Putrid(owen))) → ((¬Octagonal(molly) ∧ ¬Wonderful(adam))) ::: Owen being putrid implies that Molly is not octagonal and Adam is not wonderful.\n(∀x (¬Sour(x))) → (∀x (¬Significant(x))) ::: All not sour people are not significant.\n(∀x (¬Significant(x))) → ((Wonderful(godwin) ∧ ¬Octagonal(luther))) ::: If everyone is not significant, then Godwin is wonderful and Luther is not octagonal.\n(∀x (Wild(x))) → (∀x (Wonderful(x))) ::: If someone is wild, then he is wonderful.\n(∃x (Wild(x))) → ((Octagonal(godwin) ∧ Sour(morgan))) ::: If there is someone who is wild, then Godwin is octagonal and Morgan is sour.\n(∀x (¬Wonderful(x) ∧ ¬Putrid(x))) ↔ (∀x (Wild(x))) ::: Someone is not wonderful and not putrid if and only if he is wild.\n((Sour(molly) ∧ ¬Wild(molly))) → ((¬Wonderful(owen))) ::: It can be concluded that Owen is not wonderful once knowing that Molly is sour and Molly is not wild.\n",
                "First-Order-Logic Question": "¬Sour(luther) ::: Luther is not sour."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬Significant(x))) → (Significant(owen)) ::: If there is nobody who is not significant, then Owen is significant.",
                    "gram": "¬∃x(¬Significant(x))→Significant(x) ::: If there is nobody who is not significant, then Owen is significant."
                }
            ],
            "answer": "C",
            "grammar_answer": "A",
            "backup_answer": "B"
        },
        {
            "id": 784,
            "raw_prog": {
                "First-Order-Logic Rules": "Octagonal(owen) ::: Owen is octagonal.\n¬Sour(molly) ::: Molly is not sour.\n¬Significant(owen) ::: Owen is not significant.\n¬Wild(tristan) ::: Tristan is not wild.\nSignificant(luther) ::: Luther is significant.\n¬Wild(adam) ::: Adam is not wild.\n¬Wonderful(adam) ::: Adam is not wonderful.\nSour(morgan) ::: Morgan is sour.\nSour(tristan) ::: Tristan is sour.\nSour(godwin) ::: Godwin is sour.\nWonderful(owen) ::: Owen is wonderful.\n¬Wild(molly) ::: Molly is not wild.\n(∀x (Putrid(x) ∧ ¬Sour(x))) ↔ (∀x (Octagonal(x) ∧ ¬Wonderful(x))) ::: Someone is putrid and not sour if and only if he is octagonal and not wonderful.\n(¬∃x (¬Significant(x))) → (Significant(owen)) ::: If there is nobody who is not significant, then Owen is significant.\n(∀x (Significant(x))) ↔ (∀x (¬Wonderful(x))) ::: Someone is significant if and only if he is not wonderful.\n(∃x (¬Significant(x))) → ((¬Putrid(godwin) ∧ Wild(molly))) ::: If there is at least one people who is not significant, then Godwin is not putrid and Molly is wild.\n(∀x (Wonderful(x) ∨ Sour(x))) → (∀x (Wild(x))) ::: If someone is wonderful or he is sour, then he is wild.\n((Putrid(owen))) → ((¬Octagonal(molly) ∧ ¬Wonderful(adam))) ::: Owen being putrid implies that Molly is not octagonal and Adam is not wonderful.\n(∀x (¬Sour(x))) → (∀x (¬Significant(x))) ::: All not sour people are not significant.\n(∀x (¬Significant(x))) → ((Wonderful(godwin) ∧ ¬Octagonal(luther))) ::: If everyone is not significant, then Godwin is wonderful and Luther is not octagonal.\n(∀x (Wild(x))) → (∀x (Wonderful(x))) ::: If someone is wild, then he is wonderful.\n(∃x (Wild(x))) → ((Octagonal(godwin) ∧ Sour(morgan))) ::: If there is someone who is wild, then Godwin is octagonal and Morgan is sour.\n(∀x (¬Wonderful(x) ∧ ¬Putrid(x))) ↔ (∀x (Wild(x))) ::: Someone is not wonderful and not putrid if and only if he is wild.\n((Sour(molly) ∧ ¬Wild(molly))) → ((¬Wonderful(owen))) ::: It can be concluded that Owen is not wonderful once knowing that Molly is sour and Molly is not wild.\n",
                "First-Order-Logic Question": "Sour(luther) ::: Luther is sour."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "Octagonal(owen) ::: Owen is octagonal.\n¬Sour(molly) ::: Molly is not sour.\n¬Significant(owen) ::: Owen is not significant.\n¬Wild(tristan) ::: Tristan is not wild.\nSignificant(luther) ::: Luther is significant.\n¬Wild(adam) ::: Adam is not wild.\n¬Wonderful(adam) ::: Adam is not wonderful.\nSour(morgan) ::: Morgan is sour.\nSour(tristan) ::: Tristan is sour.\nSour(godwin) ::: Godwin is sour.\nWonderful(owen) ::: Owen is wonderful.\n¬Wild(molly) ::: Molly is not wild.\n(∀x (Putrid(x) ∧ ¬Sour(x))) ↔ (∀x (Octagonal(x) ∧ ¬Wonderful(x))) ::: Someone is putrid and not sour if and only if he is octagonal and not wonderful.\n¬∃x(¬Significant(x))→Significant(x) ::: If there is nobody who is not significant, then Owen is significant.\n(∀x (Significant(x))) ↔ (∀x (¬Wonderful(x))) ::: Someone is significant if and only if he is not wonderful.\n(∃x (¬Significant(x))) → ((¬Putrid(godwin) ∧ Wild(molly))) ::: If there is at least one people who is not significant, then Godwin is not putrid and Molly is wild.\n(∀x (Wonderful(x) ∨ Sour(x))) → (∀x (Wild(x))) ::: If someone is wonderful or he is sour, then he is wild.\n((Putrid(owen))) → ((¬Octagonal(molly) ∧ ¬Wonderful(adam))) ::: Owen being putrid implies that Molly is not octagonal and Adam is not wonderful.\n(∀x (¬Sour(x))) → (∀x (¬Significant(x))) ::: All not sour people are not significant.\n(∀x (¬Significant(x))) → ((Wonderful(godwin) ∧ ¬Octagonal(luther))) ::: If everyone is not significant, then Godwin is wonderful and Luther is not octagonal.\n(∀x (Wild(x))) → (∀x (Wonderful(x))) ::: If someone is wild, then he is wonderful.\n(∃x (Wild(x))) → ((Octagonal(godwin) ∧ Sour(morgan))) ::: If there is someone who is wild, then Godwin is octagonal and Morgan is sour.\n(∀x (¬Wonderful(x) ∧ ¬Putrid(x))) ↔ (∀x (Wild(x))) ::: Someone is not wonderful and not putrid if and only if he is wild.\n((Sour(molly) ∧ ¬Wild(molly))) → ((¬Wonderful(owen))) ::: It can be concluded that Owen is not wonderful once knowing that Molly is sour and Molly is not wild.\n",
                "First-Order-Logic Question": "Sour(luther) ::: Luther is sour."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬Significant(x))) → (Significant(owen)) ::: If there is nobody who is not significant, then Owen is significant.",
                    "gram": "¬∃x(¬Significant(x))→Significant(x) ::: If there is nobody who is not significant, then Owen is significant."
                }
            ],
            "answer": "C",
            "grammar_answer": "A",
            "backup_answer": "A"
        },
        {
            "id": 785,
            "raw_prog": {
                "First-Order-Logic Rules": "Octagonal(owen) ::: Owen is octagonal.\n¬Sour(molly) ::: Molly is not sour.\n¬Significant(owen) ::: Owen is not significant.\n¬Wild(tristan) ::: Tristan is not wild.\nSignificant(luther) ::: Luther is significant.\n¬Wild(adam) ::: Adam is not wild.\n¬Wonderful(adam) ::: Adam is not wonderful.\nSour(morgan) ::: Morgan is sour.\nSour(tristan) ::: Tristan is sour.\nSour(godwin) ::: Godwin is sour.\nWonderful(owen) ::: Owen is wonderful.\n¬Wild(molly) ::: Molly is not wild.\n(∀x (Putrid(x) ∧ ¬Sour(x))) ↔ (∀x (Octagonal(x) ∧ ¬Wonderful(x))) ::: Someone is putrid and not sour if and only if he is octagonal and not wonderful.\n(¬∃x (¬Significant(x))) → (Significant(owen)) ::: If there is nobody who is not significant, then Owen is significant.\n(∀x (Significant(x))) ↔ (∀x (¬Wonderful(x))) ::: Someone is significant if and only if he is not wonderful.\n(∃x (¬Significant(x))) → ((¬Putrid(godwin) ∧ Wild(molly))) ::: If there is at least one people who is not significant, then Godwin is not putrid and Molly is wild.\n(∀x (Wonderful(x) ∨ Sour(x))) → (∀x (Wild(x))) ::: If someone is wonderful or he is sour, then he is wild.\n((Putrid(owen))) → ((¬Octagonal(molly) ∧ ¬Wonderful(adam))) ::: Owen being putrid implies that Molly is not octagonal and Adam is not wonderful.\n(∀x (¬Sour(x))) → (∀x (¬Significant(x))) ::: All not sour people are not significant.\n(∀x (¬Significant(x))) → ((Wonderful(godwin) ∧ ¬Octagonal(luther))) ::: If everyone is not significant, then Godwin is wonderful and Luther is not octagonal.\n(∀x (Wild(x))) → (∀x (Wonderful(x))) ::: If someone is wild, then he is wonderful.\n(∃x (Wild(x))) → ((Octagonal(godwin) ∧ Sour(morgan))) ::: If there is someone who is wild, then Godwin is octagonal and Morgan is sour.\n(∀x (¬Wonderful(x) ∧ ¬Putrid(x))) ↔ (∀x (Wild(x))) ::: Someone is not wonderful and not putrid if and only if he is wild.\n((Sour(molly) ∧ ¬Wild(molly))) → ((¬Wonderful(owen))) ::: It can be concluded that Owen is not wonderful once knowing that Molly is sour and Molly is not wild.\n",
                "First-Order-Logic Question": "¬Sour(morgan) ::: Morgan is not sour."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "Octagonal(owen) ::: Owen is octagonal.\n¬Sour(molly) ::: Molly is not sour.\n¬Significant(owen) ::: Owen is not significant.\n¬Wild(tristan) ::: Tristan is not wild.\nSignificant(luther) ::: Luther is significant.\n¬Wild(adam) ::: Adam is not wild.\n¬Wonderful(adam) ::: Adam is not wonderful.\nSour(morgan) ::: Morgan is sour.\nSour(tristan) ::: Tristan is sour.\nSour(godwin) ::: Godwin is sour.\nWonderful(owen) ::: Owen is wonderful.\n¬Wild(molly) ::: Molly is not wild.\n(∀x (Putrid(x) ∧ ¬Sour(x))) ↔ (∀x (Octagonal(x) ∧ ¬Wonderful(x))) ::: Someone is putrid and not sour if and only if he is octagonal and not wonderful.\n¬∃x(¬Significant(x))→Significant(x) ::: If there is nobody who is not significant, then Owen is significant.\n(∀x (Significant(x))) ↔ (∀x (¬Wonderful(x))) ::: Someone is significant if and only if he is not wonderful.\n(∃x (¬Significant(x))) → ((¬Putrid(godwin) ∧ Wild(molly))) ::: If there is at least one people who is not significant, then Godwin is not putrid and Molly is wild.\n(∀x (Wonderful(x) ∨ Sour(x))) → (∀x (Wild(x))) ::: If someone is wonderful or he is sour, then he is wild.\n((Putrid(owen))) → ((¬Octagonal(molly) ∧ ¬Wonderful(adam))) ::: Owen being putrid implies that Molly is not octagonal and Adam is not wonderful.\n(∀x (¬Sour(x))) → (∀x (¬Significant(x))) ::: All not sour people are not significant.\n(∀x (¬Significant(x))) → ((Wonderful(godwin) ∧ ¬Octagonal(luther))) ::: If everyone is not significant, then Godwin is wonderful and Luther is not octagonal.\n(∀x (Wild(x))) → (∀x (Wonderful(x))) ::: If someone is wild, then he is wonderful.\n(∃x (Wild(x))) → ((Octagonal(godwin) ∧ Sour(morgan))) ::: If there is someone who is wild, then Godwin is octagonal and Morgan is sour.\n(∀x (¬Wonderful(x) ∧ ¬Putrid(x))) ↔ (∀x (Wild(x))) ::: Someone is not wonderful and not putrid if and only if he is wild.\n((Sour(molly) ∧ ¬Wild(molly))) → ((¬Wonderful(owen))) ::: It can be concluded that Owen is not wonderful once knowing that Molly is sour and Molly is not wild.\n",
                "First-Order-Logic Question": "¬Sour(morgan) ::: Morgan is not sour."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬Significant(x))) → (Significant(owen)) ::: If there is nobody who is not significant, then Owen is significant.",
                    "gram": "¬∃x(¬Significant(x))→Significant(x) ::: If there is nobody who is not significant, then Owen is significant."
                }
            ],
            "answer": "B",
            "grammar_answer": "A",
            "backup_answer": "B"
        },
        {
            "id": 786,
            "raw_prog": {
                "First-Order-Logic Rules": "Octagonal(owen) ::: Owen is octagonal.\n¬Sour(molly) ::: Molly is not sour.\n¬Significant(owen) ::: Owen is not significant.\n¬Wild(tristan) ::: Tristan is not wild.\nSignificant(luther) ::: Luther is significant.\n¬Wild(adam) ::: Adam is not wild.\n¬Wonderful(adam) ::: Adam is not wonderful.\nSour(morgan) ::: Morgan is sour.\nSour(tristan) ::: Tristan is sour.\nSour(godwin) ::: Godwin is sour.\nWonderful(owen) ::: Owen is wonderful.\n¬Wild(molly) ::: Molly is not wild.\n(∀x (Putrid(x) ∧ ¬Sour(x))) ↔ (∀x (Octagonal(x) ∧ ¬Wonderful(x))) ::: Someone is putrid and not sour if and only if he is octagonal and not wonderful.\n(¬∃x (¬Significant(x))) → (Significant(owen)) ::: If there is nobody who is not significant, then Owen is significant.\n(∀x (Significant(x))) ↔ (∀x (¬Wonderful(x))) ::: Someone is significant if and only if he is not wonderful.\n(∃x (¬Significant(x))) → ((¬Putrid(godwin) ∧ Wild(molly))) ::: If there is at least one people who is not significant, then Godwin is not putrid and Molly is wild.\n(∀x (Wonderful(x) ∨ Sour(x))) → (∀x (Wild(x))) ::: If someone is wonderful or he is sour, then he is wild.\n((Putrid(owen))) → ((¬Octagonal(molly) ∧ ¬Wonderful(adam))) ::: Owen being putrid implies that Molly is not octagonal and Adam is not wonderful.\n(∀x (¬Sour(x))) → (∀x (¬Significant(x))) ::: All not sour people are not significant.\n(∀x (¬Significant(x))) → ((Wonderful(godwin) ∧ ¬Octagonal(luther))) ::: If everyone is not significant, then Godwin is wonderful and Luther is not octagonal.\n(∀x (Wild(x))) → (∀x (Wonderful(x))) ::: If someone is wild, then he is wonderful.\n(∃x (Wild(x))) → ((Octagonal(godwin) ∧ Sour(morgan))) ::: If there is someone who is wild, then Godwin is octagonal and Morgan is sour.\n(∀x (¬Wonderful(x) ∧ ¬Putrid(x))) ↔ (∀x (Wild(x))) ::: Someone is not wonderful and not putrid if and only if he is wild.\n((Sour(molly) ∧ ¬Wild(molly))) → ((¬Wonderful(owen))) ::: It can be concluded that Owen is not wonderful once knowing that Molly is sour and Molly is not wild.\n",
                "First-Order-Logic Question": "¬Sour(adam) ::: Adam is not sour."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "Octagonal(owen) ::: Owen is octagonal.\n¬Sour(molly) ::: Molly is not sour.\n¬Significant(owen) ::: Owen is not significant.\n¬Wild(tristan) ::: Tristan is not wild.\nSignificant(luther) ::: Luther is significant.\n¬Wild(adam) ::: Adam is not wild.\n¬Wonderful(adam) ::: Adam is not wonderful.\nSour(morgan) ::: Morgan is sour.\nSour(tristan) ::: Tristan is sour.\nSour(godwin) ::: Godwin is sour.\nWonderful(owen) ::: Owen is wonderful.\n¬Wild(molly) ::: Molly is not wild.\n(∀x (Putrid(x) ∧ ¬Sour(x))) ↔ (∀x (Octagonal(x) ∧ ¬Wonderful(x))) ::: Someone is putrid and not sour if and only if he is octagonal and not wonderful.\n¬∃x(¬Significant(x))→Significant(x) ::: If there is nobody who is not significant, then Owen is significant.\n(∀x (Significant(x))) ↔ (∀x (¬Wonderful(x))) ::: Someone is significant if and only if he is not wonderful.\n(∃x (¬Significant(x))) → ((¬Putrid(godwin) ∧ Wild(molly))) ::: If there is at least one people who is not significant, then Godwin is not putrid and Molly is wild.\n(∀x (Wonderful(x) ∨ Sour(x))) → (∀x (Wild(x))) ::: If someone is wonderful or he is sour, then he is wild.\n((Putrid(owen))) → ((¬Octagonal(molly) ∧ ¬Wonderful(adam))) ::: Owen being putrid implies that Molly is not octagonal and Adam is not wonderful.\n(∀x (¬Sour(x))) → (∀x (¬Significant(x))) ::: All not sour people are not significant.\n(∀x (¬Significant(x))) → ((Wonderful(godwin) ∧ ¬Octagonal(luther))) ::: If everyone is not significant, then Godwin is wonderful and Luther is not octagonal.\n(∀x (Wild(x))) → (∀x (Wonderful(x))) ::: If someone is wild, then he is wonderful.\n(∃x (Wild(x))) → ((Octagonal(godwin) ∧ Sour(morgan))) ::: If there is someone who is wild, then Godwin is octagonal and Morgan is sour.\n(∀x (¬Wonderful(x) ∧ ¬Putrid(x))) ↔ (∀x (Wild(x))) ::: Someone is not wonderful and not putrid if and only if he is wild.\n((Sour(molly) ∧ ¬Wild(molly))) → ((¬Wonderful(owen))) ::: It can be concluded that Owen is not wonderful once knowing that Molly is sour and Molly is not wild.\n",
                "First-Order-Logic Question": "¬Sour(adam) ::: Adam is not sour."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬Significant(x))) → (Significant(owen)) ::: If there is nobody who is not significant, then Owen is significant.",
                    "gram": "¬∃x(¬Significant(x))→Significant(x) ::: If there is nobody who is not significant, then Owen is significant."
                }
            ],
            "answer": "C",
            "grammar_answer": "A",
            "backup_answer": "C"
        },
        {
            "id": 787,
            "raw_prog": {
                "First-Order-Logic Rules": [
                    "Octagonal(owen) ::: Owen is octagonal.",
                    "¬Sour(molly) ::: Molly is not sour.",
                    "¬Significant(owen) ::: Owen is not significant.",
                    "¬Wild(tristan) ::: Tristan is not wild.",
                    "Significant(luther) ::: Luther is significant.",
                    "¬Wild(adam) ::: Adam is not wild.",
                    "¬Wonderful(adam) ::: Adam is not wonderful.",
                    "Sour(morgan) ::: Morgan is sour.",
                    "Sour(tristan) ::: Tristan is sour.",
                    "Sour(godwin) ::: Godwin is sour.",
                    "Wonderful(owen) ::: Owen is wonderful.",
                    "¬Wild(molly) ::: Molly is not wild.",
                    "(∀x (Putrid(x) ∧ ¬Sour(x))) ↔ (∀x (Octagonal(x) ∧ ¬Wonderful(x))) ::: Someone is putrid and not sour if and only if he is octagonal and not wonderful.",
                    "(¬∃x (¬Significant(x))) → (Significant(owen)) ::: If there is nobody who is not significant, then Owen is significant.",
                    "(∀x (Significant(x))) ↔ (∀x (¬Wonderful(x))) ::: Someone is significant if and only if he is not wonderful.",
                    "(∃x (¬Significant(x))) → ((¬Putrid(godwin) ∧ Wild(molly))) ::: If there is at least one person who is not significant, then Godwin is not putrid and Molly is wild.",
                    "(∀x (Wonderful(x) ∨ Sour(x))) → (∀x (Wild(x))) ::: If someone is wonderful or he is sour, then he is wild.",
                    "(Putrid(owen)) → ((¬Octagonal(molly) ∧ ¬Wonderful(adam))) ::: Owen being putrid implies that Molly is not octagonal and Adam is not wonderful.",
                    "(∀x (¬Sour(x))) → (∀x (¬Significant(x))) ::: All not sour people are not significant.",
                    "(∀x (¬Significant(x))) → ((Wonderful(godwin) ∧ ¬Octagonal(luther))) ::: If everyone is not significant, then Godwin is wonderful and Luther is not octagonal.",
                    "(∀x (Wild(x))) → (∀x (Wonderful(x))) ::: If someone is wild, then he is wonderful.",
                    "(∃x (Wild(x))) → ((Octagonal(godwin) ∧ Sour(morgan))) ::: If there is someone who is wild, then Godwin is octagonal and Morgan is sour.",
                    "(∀x (¬Wonderful(x) ∧ ¬Putrid(x))) ↔ (∀x (Wild(x))) ::: Someone is not wonderful and not putrid if and only if he is wild.",
                    "((Sour(molly) ∧ ¬Wild(molly))) → (¬Wonderful(owen)) ::: It can be concluded that Owen is not wonderful once knowing that Molly is sour and Molly is not wild."
                ],
                "First-Order-Logic Question": "Octagonal(morgan) ::: Morgan is octagonal."
            },
            "gram_prog": {
                "First-Order-Logic Rules": [
                    "Octagonal(owen) ::: Owen is octagonal.",
                    "¬Sour(molly) ::: Molly is not sour.",
                    "¬Significant(owen) ::: Owen is not significant.",
                    "¬Wild(tristan) ::: Tristan is not wild.",
                    "Significant(luther) ::: Luther is significant.",
                    "¬Wild(adam) ::: Adam is not wild.",
                    "¬Wonderful(adam) ::: Adam is not wonderful.",
                    "Sour(morgan) ::: Morgan is sour.",
                    "Sour(tristan) ::: Tristan is sour.",
                    "Sour(godwin) ::: Godwin is sour.",
                    "Wonderful(owen) ::: Owen is wonderful.",
                    "¬Wild(molly) ::: Molly is not wild.",
                    "(∀x (Putrid(x) ∧ ¬Sour(x))) ↔ (∀x (Octagonal(x) ∧ ¬Wonderful(x))) ::: Someone is putrid and not sour if and only if he is octagonal and not wonderful.",
                    "¬∃x(¬Significant(x))→Significant(x) ::: If there is nobody who is not significant, then Owen is significant.",
                    "(∀x (Significant(x))) ↔ (∀x (¬Wonderful(x))) ::: Someone is significant if and only if he is not wonderful.",
                    "(∃x (¬Significant(x))) → ((¬Putrid(godwin) ∧ Wild(molly))) ::: If there is at least one person who is not significant, then Godwin is not putrid and Molly is wild.",
                    "(∀x (Wonderful(x) ∨ Sour(x))) → (∀x (Wild(x))) ::: If someone is wonderful or he is sour, then he is wild.",
                    "(Putrid(owen)) → ((¬Octagonal(molly) ∧ ¬Wonderful(adam))) ::: Owen being putrid implies that Molly is not octagonal and Adam is not wonderful.",
                    "(∀x (¬Sour(x))) → (∀x (¬Significant(x))) ::: All not sour people are not significant.",
                    "(∀x (¬Significant(x))) → ((Wonderful(godwin) ∧ ¬Octagonal(luther))) ::: If everyone is not significant, then Godwin is wonderful and Luther is not octagonal.",
                    "(∀x (Wild(x))) → (∀x (Wonderful(x))) ::: If someone is wild, then he is wonderful.",
                    "(∃x (Wild(x))) → ((Octagonal(godwin) ∧ Sour(morgan))) ::: If there is someone who is wild, then Godwin is octagonal and Morgan is sour.",
                    "(∀x (¬Wonderful(x) ∧ ¬Putrid(x))) ↔ (∀x (Wild(x))) ::: Someone is not wonderful and not putrid if and only if he is wild.",
                    "((Sour(molly) ∧ ¬Wild(molly))) → (¬Wonderful(owen)) ::: It can be concluded that Owen is not wonderful once knowing that Molly is sour and Molly is not wild."
                ],
                "First-Order-Logic Question": "Octagonal(morgan) ::: Morgan is octagonal."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬Significant(x))) → (Significant(owen)) ::: If there is nobody who is not significant, then Owen is significant.",
                    "gram": "¬∃x(¬Significant(x))→Significant(x) ::: If there is nobody who is not significant, then Owen is significant."
                }
            ],
            "answer": "C",
            "grammar_answer": "A",
            "backup_answer": "C"
        },
        {
            "id": 788,
            "raw_prog": {
                "First-Order-Logic Rules": "Octagonal(owen) ::: Owen is octagonal.\n¬Sour(molly) ::: Molly is not sour.\n¬Significant(owen) ::: Owen is not significant.\n¬Wild(tristan) ::: Tristan is not wild.\nSignificant(luther) ::: Luther is significant.\n¬Wild(adam) ::: Adam is not wild.\n¬Wonderful(adam) ::: Adam is not wonderful.\nSour(morgan) ::: Morgan is sour.\nSour(tristan) ::: Tristan is sour.\nSour(godwin) ::: Godwin is sour.\nWonderful(owen) ::: Owen is wonderful.\n¬Wild(molly) ::: Molly is not wild.\n(∀x (Putrid(x) ∧ ¬Sour(x))) ↔ (∀x (Octagonal(x) ∧ ¬Wonderful(x))) ::: Someone is putrid and not sour if and only if he is octagonal and not wonderful.\n(¬∃x (¬x)) → (Significant(owen)) ::: If there is nobody who is not, then Owen is significant.\n(∀x (Significant(x))) ↔ (∀x (¬Wonderful(x))) ::: Someone is significant if and only if he is not wonderful.\n(∃x (¬Significant(x))) → ((¬Putrid(godwin) ∧ Wild(molly))) ::: If there is at least one people who is not significant, then Godwin is not putrid and Molly is wild.\n(∀x (Wonderful(x) ∨ Sour(x))) → (∀x (Wild(x))) ::: If someone is wonderful or he is sour, then he is wild.\n((Putrid(owen))) → ((¬Octagonal(molly) ∧ ¬Wonderful(adam))) ::: Owen being putrid implies that Molly is not octagonal and Adam is not wonderful.\n(∀x (¬Sour(x))) → (∀x (¬Significant(x))) ::: All not sour people are not significant.\n(∀x (¬Significant(x))) → ((Wonderful(godwin) ∧ ¬Octagonal(luther))) ::: If everyone is not significant, then Godwin is wonderful and Luther is not octagonal.\n(∀x (Wild(x))) → (∀x (Wonderful(x))) ::: If someone is wild, then he is wonderful.\n(∃x (Wild(x))) → ((Octagonal(godwin) ∧ Sour(morgan))) ::: If there is someone who is wild, then Godwin is octagonal and Morgan is sour.\n(∀x (¬Wonderful(x) ∧ ¬Putrid(x))) ↔ (∀x (Wild(x))) ::: Someone is not wonderful and not putrid if and only if he is wild.\n((Sour(molly) ∧ ¬Wild(molly))) → ((¬Wonderful(owen))) ::: It can be concluded that Owen is not wonderful once knowing that Molly is sour and Molly is not wild.\n",
                "First-Order-Logic Question": "Octagonal(tristan) ::: Tristan is octagonal."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "Octagonal(owen) ::: Owen is octagonal.\n¬Sour(molly) ::: Molly is not sour.\n¬Significant(owen) ::: Owen is not significant.\n¬Wild(tristan) ::: Tristan is not wild.\nSignificant(luther) ::: Luther is significant.\n¬Wild(adam) ::: Adam is not wild.\n¬Wonderful(adam) ::: Adam is not wonderful.\nSour(morgan) ::: Morgan is sour.\nSour(tristan) ::: Tristan is sour.\nSour(godwin) ::: Godwin is sour.\nWonderful(owen) ::: Owen is wonderful.\n¬Wild(molly) ::: Molly is not wild.\n(∀x (Putrid(x) ∧ ¬Sour(x))) ↔ (∀x (Octagonal(x) ∧ ¬Wonderful(x))) ::: Someone is putrid and not sour if and only if he is octagonal and not wonderful.\n¬∃x(¬(¬(Octagonal(x)))) ::: If there is nobody who is not, then Owen is significant.\n(∀x (Significant(x))) ↔ (∀x (¬Wonderful(x))) ::: Someone is significant if and only if he is not wonderful.\n(∃x (¬Significant(x))) → ((¬Putrid(godwin) ∧ Wild(molly))) ::: If there is at least one people who is not significant, then Godwin is not putrid and Molly is wild.\n(∀x (Wonderful(x) ∨ Sour(x))) → (∀x (Wild(x))) ::: If someone is wonderful or he is sour, then he is wild.\n((Putrid(owen))) → ((¬Octagonal(molly) ∧ ¬Wonderful(adam))) ::: Owen being putrid implies that Molly is not octagonal and Adam is not wonderful.\n(∀x (¬Sour(x))) → (∀x (¬Significant(x))) ::: All not sour people are not significant.\n(∀x (¬Significant(x))) → ((Wonderful(godwin) ∧ ¬Octagonal(luther))) ::: If everyone is not significant, then Godwin is wonderful and Luther is not octagonal.\n(∀x (Wild(x))) → (∀x (Wonderful(x))) ::: If someone is wild, then he is wonderful.\n(∃x (Wild(x))) → ((Octagonal(godwin) ∧ Sour(morgan))) ::: If there is someone who is wild, then Godwin is octagonal and Morgan is sour.\n(∀x (¬Wonderful(x) ∧ ¬Putrid(x))) ↔ (∀x (Wild(x))) ::: Someone is not wonderful and not putrid if and only if he is wild.\n((Sour(molly) ∧ ¬Wild(molly))) → ((¬Wonderful(owen))) ::: It can be concluded that Owen is not wonderful once knowing that Molly is sour and Molly is not wild.\n",
                "First-Order-Logic Question": "Octagonal(tristan) ::: Tristan is octagonal."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬x)) → (Significant(owen)) ::: If there is nobody who is not, then Owen is significant.",
                    "gram": "¬∃x(¬(¬(Octagonal(x)))) ::: If there is nobody who is not, then Owen is significant."
                }
            ],
            "answer": "C",
            "grammar_answer": "A",
            "backup_answer": "C"
        },
        {
            "id": 789,
            "raw_prog": {
                "First-Order-Logic Rules": "Octagonal(owen) ::: Owen is octagonal.\n¬Sour(molly) ::: Molly is not sour.\n¬Significant(owen) ::: Owen is not significant.\n¬Wild(tristan) ::: Tristan is not wild.\nSignificant(luther) ::: Luther is significant.\n¬Wild(adam) ::: Adam is not wild.\n¬Wonderful(adam) ::: Adam is not wonderful.\nSour(morgan) ::: Morgan is sour.\nSour(tristan) ::: Tristan is sour.\nSour(godwin) ::: Godwin is sour.\nWonderful(owen) ::: Owen is wonderful.\n¬Wild(molly) ::: Molly is not wild.\n(∀x (Putrid(x) ∧ ¬Sour(x))) ↔ (∀x (Octagonal(x) ∧ ¬Wonderful(x))) ::: Someone is putrid and not sour if and only if he is octagonal and not wonderful.\n(¬∃x (¬x)) → (Significant(owen)) ::: If there is nobody who is not, then Owen is significant.\n(∀x (Significant(x))) ↔ (∀x (¬Wonderful(x))) ::: Someone is significant if and only if he is not wonderful.\n(∃x (¬Significant(x))) → ((¬Putrid(godwin) ∧ Wild(molly))) ::: If there is at least one people who is not significant, then Godwin is not putrid and Molly is wild.\n((Wonderful(x) ∨ Sour(x))) → (Wild(x)) ::: If someone is wonderful or he is sour, then he is wild.\n((Putrid(owen))) → ((¬Octagonal(molly) ∧ ¬Wonderful(adam))) ::: Owen being putrid implies that Molly is not octagonal and Adam is not wonderful.\n(∀x (¬Sour(x))) → (∀x (¬Significant(x))) ::: All not sour people are not significant.\n(∀x (¬Significant(x))) → ((Wonderful(godwin) ∧ ¬Octagonal(luther))) ::: If everyone is not significant, then Godwin is wonderful and Luther is not octagonal.\n(∀x (Wild(x))) → (∀x (Wonderful(x))) ::: If someone is wild, then he is wonderful.\n(∃x (Wild(x))) → ((Octagonal(godwin) ∧ Sour(morgan))) ::: If there is someone who is wild, then Godwin is octagonal and Morgan is sour.\n(∀x (¬Wonderful(x) ∧ ¬Putrid(x))) ↔ (∀x (Wild(x))) ::: Someone is not wonderful and not putrid if and only if he is wild.\n((Sour(molly) ∧ ¬Wild(molly))) → (¬Wonderful(owen)) ::: It can be concluded that Owen is not wonderful once knowing that Molly is sour and Molly is not wild.\n",
                "First-Order-Logic Question": "¬Significant(morgan) ::: Morgan is not significant."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "Octagonal(owen) ::: Owen is octagonal.\n¬Sour(molly) ::: Molly is not sour.\n¬Significant(owen) ::: Owen is not significant.\n¬Wild(tristan) ::: Tristan is not wild.\nSignificant(luther) ::: Luther is significant.\n¬Wild(adam) ::: Adam is not wild.\n¬Wonderful(adam) ::: Adam is not wonderful.\nSour(morgan) ::: Morgan is sour.\nSour(tristan) ::: Tristan is sour.\nSour(godwin) ::: Godwin is sour.\nWonderful(owen) ::: Owen is wonderful.\n¬Wild(molly) ::: Molly is not wild.\n(∀x (Putrid(x) ∧ ¬Sour(x))) ↔ (∀x (Octagonal(x) ∧ ¬Wonderful(x))) ::: Someone is putrid and not sour if and only if he is octagonal and not wonderful.\n¬∃x(¬(¬(Octagonal(x)))) ::: If there is nobody who is not, then Owen is significant.\n(∀x (Significant(x))) ↔ (∀x (¬Wonderful(x))) ::: Someone is significant if and only if he is not wonderful.\n(∃x (¬Significant(x))) → ((¬Putrid(godwin) ∧ Wild(molly))) ::: If there is at least one people who is not significant, then Godwin is not putrid and Molly is wild.\n((Wonderful(x) ∨ Sour(x))) → (Wild(x)) ::: If someone is wonderful or he is sour, then he is wild.\n((Putrid(owen))) → ((¬Octagonal(molly) ∧ ¬Wonderful(adam))) ::: Owen being putrid implies that Molly is not octagonal and Adam is not wonderful.\n(∀x (¬Sour(x))) → (∀x (¬Significant(x))) ::: All not sour people are not significant.\n(∀x (¬Significant(x))) → ((Wonderful(godwin) ∧ ¬Octagonal(luther))) ::: If everyone is not significant, then Godwin is wonderful and Luther is not octagonal.\n(∀x (Wild(x))) → (∀x (Wonderful(x))) ::: If someone is wild, then he is wonderful.\n(∃x (Wild(x))) → ((Octagonal(godwin) ∧ Sour(morgan))) ::: If there is someone who is wild, then Godwin is octagonal and Morgan is sour.\n(∀x (¬Wonderful(x) ∧ ¬Putrid(x))) ↔ (∀x (Wild(x))) ::: Someone is not wonderful and not putrid if and only if he is wild.\n((Sour(molly) ∧ ¬Wild(molly))) → (¬Wonderful(owen)) ::: It can be concluded that Owen is not wonderful once knowing that Molly is sour and Molly is not wild.\n",
                "First-Order-Logic Question": "¬Significant(morgan) ::: Morgan is not significant."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬x)) → (Significant(owen)) ::: If there is nobody who is not, then Owen is significant.",
                    "gram": "¬∃x(¬(¬(Octagonal(x)))) ::: If there is nobody who is not, then Owen is significant."
                }
            ],
            "answer": "B",
            "grammar_answer": "A",
            "backup_answer": "C"
        },
        {
            "id": 790,
            "raw_prog": {
                "First-Order-Logic Rules": "Octagonal(owen) ::: Owen is octagonal.\n¬Sour(molly) ::: Molly is not sour.\n¬Significant(owen) ::: Owen is not significant.\n¬Wild(tristan) ::: Tristan is not wild.\nSignificant(luther) ::: Luther is significant.\n¬Wild(adam) ::: Adam is not wild.\n¬Wonderful(adam) ::: Adam is not wonderful.\nSour(morgan) ::: Morgan is sour.\nSour(tristan) ::: Tristan is sour.\nSour(godwin) ::: Godwin is sour.\nWonderful(owen) ::: Owen is wonderful.\n¬Wild(molly) ::: Molly is not wild.\n(∀x (Putrid(x) ∧ ¬Sour(x))) ↔ (∀x (Octagonal(x) ∧ ¬Wonderful(x))) ::: Someone is putrid and not sour if and only if he is octagonal and not wonderful.\n(¬∃x (¬Significant(x))) → (Significant(owen)) ::: If there is nobody who is not significant, then Owen is significant.\n(∀x (Significant(x))) ↔ (∀x (¬Wonderful(x))) ::: Someone is significant if and only if he is not wonderful.\n(∃x (¬Significant(x))) → ((¬Putrid(godwin) ∧ Wild(molly))) ::: If there is at least one people who is not significant, then Godwin is not putrid and Molly is wild.\n(∀x (Wonderful(x) ∨ Sour(x))) → (∀x (Wild(x))) ::: If someone is wonderful or he is sour, then he is wild.\n(Putrid(owen)) → ((¬Octagonal(molly) ∧ ¬Wonderful(adam))) ::: Owen being putrid implies that Molly is not octagonal and Adam is not wonderful.\n(∀x (¬Sour(x))) → (∀x (¬Significant(x))) ::: All not sour people are not significant.\n(∀x (¬Significant(x))) → ((Wonderful(godwin) ∧ ¬Octagonal(luther))) ::: If everyone is not significant, then Godwin is wonderful and Luther is not octagonal.\n(∀x (Wild(x))) → (∀x (Wonderful(x))) ::: If someone is wild, then he is wonderful.\n(∃x (Wild(x))) → ((Octagonal(godwin) ∧ Sour(morgan))) ::: If there is someone who is wild, then Godwin is octagonal and Morgan is sour.\n(∀x (¬Wonderful(x) ∧ ¬Putrid(x))) ↔ (∀x (Wild(x))) ::: Someone is not wonderful and not putrid if and only if he is wild.\n((Sour(molly) ∧ ¬Wild(molly))) → (¬Wonderful(owen)) ::: It can be concluded that Owen is not wonderful once knowing that Molly is sour and Molly is not wild.\n",
                "First-Order-Logic Question": "¬Octagonal(owen) ::: Owen is not octagonal."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "Octagonal(owen) ::: Owen is octagonal.\n¬Sour(molly) ::: Molly is not sour.\n¬Significant(owen) ::: Owen is not significant.\n¬Wild(tristan) ::: Tristan is not wild.\nSignificant(luther) ::: Luther is significant.\n¬Wild(adam) ::: Adam is not wild.\n¬Wonderful(adam) ::: Adam is not wonderful.\nSour(morgan) ::: Morgan is sour.\nSour(tristan) ::: Tristan is sour.\nSour(godwin) ::: Godwin is sour.\nWonderful(owen) ::: Owen is wonderful.\n¬Wild(molly) ::: Molly is not wild.\n(∀x (Putrid(x) ∧ ¬Sour(x))) ↔ (∀x (Octagonal(x) ∧ ¬Wonderful(x))) ::: Someone is putrid and not sour if and only if he is octagonal and not wonderful.\n¬∃x(¬Significant(x))→Significant(x) ::: If there is nobody who is not significant, then Owen is significant.\n(∀x (Significant(x))) ↔ (∀x (¬Wonderful(x))) ::: Someone is significant if and only if he is not wonderful.\n(∃x (¬Significant(x))) → ((¬Putrid(godwin) ∧ Wild(molly))) ::: If there is at least one people who is not significant, then Godwin is not putrid and Molly is wild.\n(∀x (Wonderful(x) ∨ Sour(x))) → (∀x (Wild(x))) ::: If someone is wonderful or he is sour, then he is wild.\n(Putrid(owen)) → ((¬Octagonal(molly) ∧ ¬Wonderful(adam))) ::: Owen being putrid implies that Molly is not octagonal and Adam is not wonderful.\n(∀x (¬Sour(x))) → (∀x (¬Significant(x))) ::: All not sour people are not significant.\n(∀x (¬Significant(x))) → ((Wonderful(godwin) ∧ ¬Octagonal(luther))) ::: If everyone is not significant, then Godwin is wonderful and Luther is not octagonal.\n(∀x (Wild(x))) → (∀x (Wonderful(x))) ::: If someone is wild, then he is wonderful.\n(∃x (Wild(x))) → ((Octagonal(godwin) ∧ Sour(morgan))) ::: If there is someone who is wild, then Godwin is octagonal and Morgan is sour.\n(∀x (¬Wonderful(x) ∧ ¬Putrid(x))) ↔ (∀x (Wild(x))) ::: Someone is not wonderful and not putrid if and only if he is wild.\n((Sour(molly) ∧ ¬Wild(molly))) → (¬Wonderful(owen)) ::: It can be concluded that Owen is not wonderful once knowing that Molly is sour and Molly is not wild.\n",
                "First-Order-Logic Question": "¬Octagonal(owen) ::: Owen is not octagonal."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬Significant(x))) → (Significant(owen)) ::: If there is nobody who is not significant, then Owen is significant.",
                    "gram": "¬∃x(¬Significant(x))→Significant(x) ::: If there is nobody who is not significant, then Owen is significant."
                }
            ],
            "answer": "B",
            "grammar_answer": "A",
            "backup_answer": "B"
        },
        {
            "id": 791,
            "raw_prog": {
                "First-Order-Logic Rules": "Octagonal(owen) ::: Owen is octagonal.\n¬Sour(molly) ::: Molly is not sour.\n¬Significant(owen) ::: Owen is not significant.\n¬Wild(tristan) ::: Tristan is not wild.\nSignificant(luther) ::: Luther is significant.\n¬Wild(adam) ::: Adam is not wild.\n¬Wonderful(adam) ::: Adam is not wonderful.\nSour(morgan) ::: Morgan is sour.\nSour(tristan) ::: Tristan is sour.\nSour(godwin) ::: Godwin is sour.\nWonderful(owen) ::: Owen is wonderful.\n¬Wild(molly) ::: Molly is not wild.\n(∀x (Putrid(x) ∧ ¬Sour(x))) ↔ (∀x (Octagonal(x) ∧ ¬Wonderful(x))) ::: Someone is putrid and not sour if and only if he is octagonal and not wonderful.\n(¬∃x (¬x)) → (Significant(owen)) ::: If there is nobody who is not, then Owen is significant.\n(∀x (Significant(x))) ↔ (∀x (¬Wonderful(x))) ::: Someone is significant if and only if he is not wonderful.\n(∃x (¬Significant(x))) → ((¬Putrid(godwin) ∧ Wild(molly))) ::: If there is at least one people who is not significant, then Godwin is not putrid and Molly is wild.\n(∀x (Wonderful(x) ∨ Sour(x))) → (∀x (Wild(x))) ::: If someone is wonderful or he is sour, then he is wild.\n((Putrid(owen))) → ((¬Octagonal(molly) ∧ ¬Wonderful(adam))) ::: Owen being putrid implies that Molly is not octagonal and Adam is not wonderful.\n(∀x (¬Sour(x))) → (∀x (¬Significant(x))) ::: All not sour people are not significant.\n(∀x (¬Significant(x))) → ((Wonderful(godwin) ∧ ¬Octagonal(luther))) ::: If everyone is not significant, then Godwin is wonderful and Luther is not octagonal.\n(∀x (Wild(x))) → (∀x (Wonderful(x))) ::: If someone is wild, then he is wonderful.\n(∃x (Wild(x))) → ((Octagonal(godwin) ∧ Sour(morgan))) ::: If there is someone who is wild, then Godwin is octagonal and Morgan is sour.\n(∀x (¬Wonderful(x) ∧ ¬Putrid(x))) ↔ (∀x (Wild(x))) ::: Someone is not wonderful and not putrid if and only if he is wild.\n((Sour(molly) ∧ ¬Wild(molly))) → ((¬Wonderful(owen))) ::: It can be concluded that Owen is not wonderful once knowing that Molly is sour and Molly is not wild.\n",
                "First-Order-Logic Question": "Putrid(tristan) ::: Tristan is putrid."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "Octagonal(owen) ::: Owen is octagonal.\n¬Sour(molly) ::: Molly is not sour.\n¬Significant(owen) ::: Owen is not significant.\n¬Wild(tristan) ::: Tristan is not wild.\nSignificant(luther) ::: Luther is significant.\n¬Wild(adam) ::: Adam is not wild.\n¬Wonderful(adam) ::: Adam is not wonderful.\nSour(morgan) ::: Morgan is sour.\nSour(tristan) ::: Tristan is sour.\nSour(godwin) ::: Godwin is sour.\nWonderful(owen) ::: Owen is wonderful.\n¬Wild(molly) ::: Molly is not wild.\n(∀x (Putrid(x) ∧ ¬Sour(x))) ↔ (∀x (Octagonal(x) ∧ ¬Wonderful(x))) ::: Someone is putrid and not sour if and only if he is octagonal and not wonderful.\n¬∃x(¬(¬(Octagonal(x)))) ::: If there is nobody who is not, then Owen is significant.\n(∀x (Significant(x))) ↔ (∀x (¬Wonderful(x))) ::: Someone is significant if and only if he is not wonderful.\n(∃x (¬Significant(x))) → ((¬Putrid(godwin) ∧ Wild(molly))) ::: If there is at least one people who is not significant, then Godwin is not putrid and Molly is wild.\n(∀x (Wonderful(x) ∨ Sour(x))) → (∀x (Wild(x))) ::: If someone is wonderful or he is sour, then he is wild.\n((Putrid(owen))) → ((¬Octagonal(molly) ∧ ¬Wonderful(adam))) ::: Owen being putrid implies that Molly is not octagonal and Adam is not wonderful.\n(∀x (¬Sour(x))) → (∀x (¬Significant(x))) ::: All not sour people are not significant.\n(∀x (¬Significant(x))) → ((Wonderful(godwin) ∧ ¬Octagonal(luther))) ::: If everyone is not significant, then Godwin is wonderful and Luther is not octagonal.\n(∀x (Wild(x))) → (∀x (Wonderful(x))) ::: If someone is wild, then he is wonderful.\n(∃x (Wild(x))) → ((Octagonal(godwin) ∧ Sour(morgan))) ::: If there is someone who is wild, then Godwin is octagonal and Morgan is sour.\n(∀x (¬Wonderful(x) ∧ ¬Putrid(x))) ↔ (∀x (Wild(x))) ::: Someone is not wonderful and not putrid if and only if he is wild.\n((Sour(molly) ∧ ¬Wild(molly))) → ((¬Wonderful(owen))) ::: It can be concluded that Owen is not wonderful once knowing that Molly is sour and Molly is not wild.\n",
                "First-Order-Logic Question": "Putrid(tristan) ::: Tristan is putrid."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬x)) → (Significant(owen)) ::: If there is nobody who is not, then Owen is significant.",
                    "gram": "¬∃x(¬(¬(Octagonal(x)))) ::: If there is nobody who is not, then Owen is significant."
                }
            ],
            "answer": "B",
            "grammar_answer": "A",
            "backup_answer": "C"
        },
        {
            "id": 792,
            "raw_prog": {
                "First-Order-Logic Rules": "Octagonal(owen) ::: Owen is octagonal.\n¬Sour(molly) ::: Molly is not sour.\n¬Significant(owen) ::: Owen is not significant.\n¬Wild(tristan) ::: Tristan is not wild.\nSignificant(luther) ::: Luther is significant.\n¬Wild(adam) ::: Adam is not wild.\n¬Wonderful(adam) ::: Adam is not wonderful.\nSour(morgan) ::: Morgan is sour.\nSour(tristan) ::: Tristan is sour.\nSour(godwin) ::: Godwin is sour.\nWonderful(owen) ::: Owen is wonderful.\n¬Wild(molly) ::: Molly is not wild.\n(∀x (Putrid(x) ∧ ¬Sour(x))) ↔ (∀x (Octagonal(x) ∧ ¬Wonderful(x))) ::: Someone is putrid and not sour if and only if he is octagonal and not wonderful.\n(¬∃x (¬x)) → (Significant(owen)) ::: If there is nobody who is not, then Owen is significant.\n(∀x (Significant(x))) ↔ (∀x (¬Wonderful(x))) ::: Someone is significant if and only if he is not wonderful.\n(∃x (¬Significant(x))) → ((¬Putrid(godwin) ∧ Wild(molly))) ::: If there is at least one people who is not significant, then Godwin is not putrid and Molly is wild.\n((Wonderful(x) ∨ Sour(x))) → (Wild(x)) ::: If someone is wonderful or he is sour, then he is wild.\n((Putrid(owen))) → ((¬Octagonal(molly) ∧ ¬Wonderful(adam))) ::: Owen being putrid implies that Molly is not octagonal and Adam is not wonderful.\n(∀x (¬Sour(x))) → (∀x (¬Significant(x))) ::: All not sour people are not significant.\n(∀x (¬Significant(x))) → ((Wonderful(godwin) ∧ ¬Octagonal(luther))) ::: If everyone is not significant, then Godwin is wonderful and Luther is not octagonal.\n(∀x (Wild(x))) → (∀x (Wonderful(x))) ::: If someone is wild, then he is wonderful.\n(∃x (Wild(x))) → ((Octagonal(godwin) ∧ Sour(morgan))) ::: If there is someone who is wild, then Godwin is octagonal and Morgan is sour.\n(∀x (¬Wonderful(x) ∧ ¬Putrid(x))) ↔ (∀x (Wild(x))) ::: Someone is not wonderful and not putrid if and only if he is wild.\n((Sour(molly) ∧ ¬Wild(molly))) → (¬Wonderful(owen)) ::: It can be concluded that Owen is not wonderful once knowing that Molly is sour and Molly is not wild.\n",
                "First-Order-Logic Question": "¬Sour(owen) ::: Owen is not sour."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "Octagonal(owen) ::: Owen is octagonal.\n¬Sour(molly) ::: Molly is not sour.\n¬Significant(owen) ::: Owen is not significant.\n¬Wild(tristan) ::: Tristan is not wild.\nSignificant(luther) ::: Luther is significant.\n¬Wild(adam) ::: Adam is not wild.\n¬Wonderful(adam) ::: Adam is not wonderful.\nSour(morgan) ::: Morgan is sour.\nSour(tristan) ::: Tristan is sour.\nSour(godwin) ::: Godwin is sour.\nWonderful(owen) ::: Owen is wonderful.\n¬Wild(molly) ::: Molly is not wild.\n(∀x (Putrid(x) ∧ ¬Sour(x))) ↔ (∀x (Octagonal(x) ∧ ¬Wonderful(x))) ::: Someone is putrid and not sour if and only if he is octagonal and not wonderful.\n¬∃x(¬(¬(Octagonal(x)))) ::: If there is nobody who is not, then Owen is significant.\n(∀x (Significant(x))) ↔ (∀x (¬Wonderful(x))) ::: Someone is significant if and only if he is not wonderful.\n(∃x (¬Significant(x))) → ((¬Putrid(godwin) ∧ Wild(molly))) ::: If there is at least one people who is not significant, then Godwin is not putrid and Molly is wild.\n((Wonderful(x) ∨ Sour(x))) → (Wild(x)) ::: If someone is wonderful or he is sour, then he is wild.\n((Putrid(owen))) → ((¬Octagonal(molly) ∧ ¬Wonderful(adam))) ::: Owen being putrid implies that Molly is not octagonal and Adam is not wonderful.\n(∀x (¬Sour(x))) → (∀x (¬Significant(x))) ::: All not sour people are not significant.\n(∀x (¬Significant(x))) → ((Wonderful(godwin) ∧ ¬Octagonal(luther))) ::: If everyone is not significant, then Godwin is wonderful and Luther is not octagonal.\n(∀x (Wild(x))) → (∀x (Wonderful(x))) ::: If someone is wild, then he is wonderful.\n(∃x (Wild(x))) → ((Octagonal(godwin) ∧ Sour(morgan))) ::: If there is someone who is wild, then Godwin is octagonal and Morgan is sour.\n(∀x (¬Wonderful(x) ∧ ¬Putrid(x))) ↔ (∀x (Wild(x))) ::: Someone is not wonderful and not putrid if and only if he is wild.\n((Sour(molly) ∧ ¬Wild(molly))) → (¬Wonderful(owen)) ::: It can be concluded that Owen is not wonderful once knowing that Molly is sour and Molly is not wild.\n",
                "First-Order-Logic Question": "¬Sour(owen) ::: Owen is not sour."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬x)) → (Significant(owen)) ::: If there is nobody who is not, then Owen is significant.",
                    "gram": "¬∃x(¬(¬(Octagonal(x)))) ::: If there is nobody who is not, then Owen is significant."
                }
            ],
            "answer": "A",
            "grammar_answer": "A",
            "backup_answer": "B"
        },
        {
            "id": 793,
            "raw_prog": {
                "First-Order-Logic Rules": "Octagonal(owen) ::: Owen is octagonal.\n¬Sour(molly) ::: Molly is not sour.\n¬Significant(owen) ::: Owen is not significant.\n¬Wild(tristan) ::: Tristan is not wild.\nSignificant(luther) ::: Luther is significant.\n¬Wild(adam) ::: Adam is not wild.\n¬Wonderful(adam) ::: Adam is not wonderful.\nSour(morgan) ::: Morgan is sour.\nSour(tristan) ::: Tristan is sour.\nSour(godwin) ::: Godwin is sour.\nWonderful(owen) ::: Owen is wonderful.\n¬Wild(molly) ::: Molly is not wild.\n(∀x (Putrid(x) ∧ ¬Sour(x))) ↔ (∀x (Octagonal(x) ∧ ¬Wonderful(x))) ::: Someone is putrid and not sour if and only if he is octagonal and not wonderful.\n(¬∃x (¬Significant(x))) → (Significant(owen)) ::: If there is nobody who is not significant, then Owen is significant.\n(∀x (Significant(x))) ↔ (∀x (¬Wonderful(x))) ::: Someone is significant if and only if he is not wonderful.\n(∃x (¬Significant(x))) → ((¬Putrid(godwin) ∧ Wild(molly))) ::: If there is at least one people who is not significant, then Godwin is not putrid and Molly is wild.\n(∀x (Wonderful(x) ∨ Sour(x))) → (∀x (Wild(x))) ::: If someone is wonderful or he is sour, then he is wild.\n((Putrid(owen))) → ((¬Octagonal(molly) ∧ ¬Wonderful(adam))) ::: Owen being putrid implies that Molly is not octagonal and Adam is not wonderful.\n(∀x (¬Sour(x))) → (∀x (¬Significant(x))) ::: All not sour people are not significant.\n(∀x (¬Significant(x))) → ((Wonderful(godwin) ∧ ¬Octagonal(luther))) ::: If everyone is not significant, then Godwin is wonderful and Luther is not octagonal.\n(∀x (Wild(x))) → (∀x (Wonderful(x))) ::: If someone is wild, then he is wonderful.\n(∃x (Wild(x))) → ((Octagonal(godwin) ∧ Sour(morgan))) ::: If there is someone who is wild, then Godwin is octagonal and Morgan is sour.\n(∀x (¬Wonderful(x) ∧ ¬Putrid(x))) ↔ (∀x (Wild(x))) ::: Someone is not wonderful and not putrid if and only if he is wild.\n((Sour(molly) ∧ ¬Wild(molly))) → (¬Wonderful(owen)) ::: It can be concluded that Owen is not wonderful once knowing that Molly is sour and Molly is not wild.\n",
                "First-Order-Logic Question": "¬Sour(tristan) ::: Tristan is not sour."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "Octagonal(owen) ::: Owen is octagonal.\n¬Sour(molly) ::: Molly is not sour.\n¬Significant(owen) ::: Owen is not significant.\n¬Wild(tristan) ::: Tristan is not wild.\nSignificant(luther) ::: Luther is significant.\n¬Wild(adam) ::: Adam is not wild.\n¬Wonderful(adam) ::: Adam is not wonderful.\nSour(morgan) ::: Morgan is sour.\nSour(tristan) ::: Tristan is sour.\nSour(godwin) ::: Godwin is sour.\nWonderful(owen) ::: Owen is wonderful.\n¬Wild(molly) ::: Molly is not wild.\n(∀x (Putrid(x) ∧ ¬Sour(x))) ↔ (∀x (Octagonal(x) ∧ ¬Wonderful(x))) ::: Someone is putrid and not sour if and only if he is octagonal and not wonderful.\n¬∃x(¬Significant(x))→Significant(x) ::: If there is nobody who is not significant, then Owen is significant.\n(∀x (Significant(x))) ↔ (∀x (¬Wonderful(x))) ::: Someone is significant if and only if he is not wonderful.\n(∃x (¬Significant(x))) → ((¬Putrid(godwin) ∧ Wild(molly))) ::: If there is at least one people who is not significant, then Godwin is not putrid and Molly is wild.\n(∀x (Wonderful(x) ∨ Sour(x))) → (∀x (Wild(x))) ::: If someone is wonderful or he is sour, then he is wild.\n((Putrid(owen))) → ((¬Octagonal(molly) ∧ ¬Wonderful(adam))) ::: Owen being putrid implies that Molly is not octagonal and Adam is not wonderful.\n(∀x (¬Sour(x))) → (∀x (¬Significant(x))) ::: All not sour people are not significant.\n(∀x (¬Significant(x))) → ((Wonderful(godwin) ∧ ¬Octagonal(luther))) ::: If everyone is not significant, then Godwin is wonderful and Luther is not octagonal.\n(∀x (Wild(x))) → (∀x (Wonderful(x))) ::: If someone is wild, then he is wonderful.\n(∃x (Wild(x))) → ((Octagonal(godwin) ∧ Sour(morgan))) ::: If there is someone who is wild, then Godwin is octagonal and Morgan is sour.\n(∀x (¬Wonderful(x) ∧ ¬Putrid(x))) ↔ (∀x (Wild(x))) ::: Someone is not wonderful and not putrid if and only if he is wild.\n((Sour(molly) ∧ ¬Wild(molly))) → (¬Wonderful(owen)) ::: It can be concluded that Owen is not wonderful once knowing that Molly is sour and Molly is not wild.\n",
                "First-Order-Logic Question": "¬Sour(tristan) ::: Tristan is not sour."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬Significant(x))) → (Significant(owen)) ::: If there is nobody who is not significant, then Owen is significant.",
                    "gram": "¬∃x(¬Significant(x))→Significant(x) ::: If there is nobody who is not significant, then Owen is significant."
                }
            ],
            "answer": "B",
            "grammar_answer": "A",
            "backup_answer": "B"
        },
        {
            "id": 794,
            "raw_prog": {
                "First-Order-Logic Rules": [
                    "Octagonal(owen) ::: Owen is octagonal.",
                    "¬Sour(molly) ::: Molly is not sour.",
                    "¬Significant(owen) ::: Owen is not significant.",
                    "¬Wild(tristan) ::: Tristan is not wild.",
                    "Significant(luther) ::: Luther is significant.",
                    "¬Wild(adam) ::: Adam is not wild.",
                    "¬Wonderful(adam) ::: Adam is not wonderful.",
                    "Sour(morgan) ::: Morgan is sour.",
                    "Sour(tristan) ::: Tristan is sour.",
                    "Sour(godwin) ::: Godwin is sour.",
                    "Wonderful(owen) ::: Owen is wonderful.",
                    "¬Wild(molly) ::: Molly is not wild.",
                    "(∀x (Putrid(x) ∧ ¬Sour(x))) ↔ (∀x (Octagonal(x) ∧ ¬Wonderful(x))) ::: Someone is putrid and not sour if and only if he is octagonal and not wonderful.",
                    "(¬∃x (¬x)) → (Significant(owen)) ::: If there is nobody who is not, then Owen is significant.",
                    "(∀x (Significant(x))) ↔ (∀x (¬Wonderful(x))) ::: Someone is significant if and only if he is not wonderful.",
                    "(∃x (¬Significant(x))) → ((¬Putrid(godwin) ∧ Wild(molly))) ::: If there is at least one people who is not significant, then Godwin is not putrid and Molly is wild.",
                    "(∀x (Wonderful(x) ∨ Sour(x))) → (∀x (Wild(x))) ::: If someone is wonderful or he is sour, then he is wild.",
                    "(Putrid(owen)) → ((¬Octagonal(molly) ∧ ¬Wonderful(adam))) ::: Owen being putrid implies that Molly is not octagonal and Adam is not wonderful.",
                    "(∀x (¬Sour(x))) → (∀x (¬Significant(x))) ::: All not sour people are not significant.",
                    "(∀x (¬Significant(x))) → ((Wonderful(godwin) ∧ ¬Octagonal(luther))) ::: If everyone is not significant, then Godwin is wonderful and Luther is not octagonal.",
                    "(∀x (Wild(x))) → (∀x (Wonderful(x))) ::: If someone is wild, then he is wonderful.",
                    "(∃x (Wild(x))) → ((Octagonal(godwin) ∧ Sour(morgan))) ::: If there is someone who is wild, then Godwin is octagonal and Morgan is sour.",
                    "(∀x (¬Wonderful(x) ∧ ¬Putrid(x))) ↔ (∀x (Wild(x))) ::: Someone is not wonderful and not putrid if and only if he is wild.",
                    "((Sour(molly) ∧ ¬Wild(molly))) → (¬Wonderful(owen)) ::: It can be concluded that Owen is not wonderful once knowing that Molly is sour and Molly is not wild."
                ],
                "First-Order-Logic Question": "Octagonal(godwin) ::: Godwin is octagonal."
            },
            "gram_prog": {
                "First-Order-Logic Rules": [
                    "Octagonal(owen) ::: Owen is octagonal.",
                    "¬Sour(molly) ::: Molly is not sour.",
                    "¬Significant(owen) ::: Owen is not significant.",
                    "¬Wild(tristan) ::: Tristan is not wild.",
                    "Significant(luther) ::: Luther is significant.",
                    "¬Wild(adam) ::: Adam is not wild.",
                    "¬Wonderful(adam) ::: Adam is not wonderful.",
                    "Sour(morgan) ::: Morgan is sour.",
                    "Sour(tristan) ::: Tristan is sour.",
                    "Sour(godwin) ::: Godwin is sour.",
                    "Wonderful(owen) ::: Owen is wonderful.",
                    "¬Wild(molly) ::: Molly is not wild.",
                    "(∀x (Putrid(x) ∧ ¬Sour(x))) ↔ (∀x (Octagonal(x) ∧ ¬Wonderful(x))) ::: Someone is putrid and not sour if and only if he is octagonal and not wonderful.",
                    "¬∃x(¬(¬(Octagonal(x)))) ::: If there is nobody who is not, then Owen is significant.",
                    "(∀x (Significant(x))) ↔ (∀x (¬Wonderful(x))) ::: Someone is significant if and only if he is not wonderful.",
                    "(∃x (¬Significant(x))) → ((¬Putrid(godwin) ∧ Wild(molly))) ::: If there is at least one people who is not significant, then Godwin is not putrid and Molly is wild.",
                    "(∀x (Wonderful(x) ∨ Sour(x))) → (∀x (Wild(x))) ::: If someone is wonderful or he is sour, then he is wild.",
                    "(Putrid(owen)) → ((¬Octagonal(molly) ∧ ¬Wonderful(adam))) ::: Owen being putrid implies that Molly is not octagonal and Adam is not wonderful.",
                    "(∀x (¬Sour(x))) → (∀x (¬Significant(x))) ::: All not sour people are not significant.",
                    "(∀x (¬Significant(x))) → ((Wonderful(godwin) ∧ ¬Octagonal(luther))) ::: If everyone is not significant, then Godwin is wonderful and Luther is not octagonal.",
                    "(∀x (Wild(x))) → (∀x (Wonderful(x))) ::: If someone is wild, then he is wonderful.",
                    "(∃x (Wild(x))) → ((Octagonal(godwin) ∧ Sour(morgan))) ::: If there is someone who is wild, then Godwin is octagonal and Morgan is sour.",
                    "(∀x (¬Wonderful(x) ∧ ¬Putrid(x))) ↔ (∀x (Wild(x))) ::: Someone is not wonderful and not putrid if and only if he is wild.",
                    "((Sour(molly) ∧ ¬Wild(molly))) → (¬Wonderful(owen)) ::: It can be concluded that Owen is not wonderful once knowing that Molly is sour and Molly is not wild."
                ],
                "First-Order-Logic Question": "Octagonal(godwin) ::: Godwin is octagonal."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬x)) → (Significant(owen)) ::: If there is nobody who is not, then Owen is significant.",
                    "gram": "¬∃x(¬(¬(Octagonal(x)))) ::: If there is nobody who is not, then Owen is significant."
                }
            ],
            "answer": "A",
            "grammar_answer": "A",
            "backup_answer": "C"
        },
        {
            "id": 1125,
            "raw_prog": {
                "First-Order-Logic Rules": "¬Different(brandi) ::: Brandi is not different.\nAlert(julie) ::: Julie is alert.\nLong(leroy) ::: Leroy is long.\n¬Poised(leroy) ::: Leroy is not poised.\nLong(julie) ::: Julie is long.\nPoised(tristan) ::: Tristan is poised.\n¬Faithful(cyril) ::: Cyril is not faithful.\n¬Different(tristan) ::: Tristan is not different.\n¬Different(cyril) ::: Cyril is not different.\nLong(cyril) ::: Cyril is long.\nLong(brandi) ::: Brandi is long.\nPoised(shane) ::: Shane is poised.\n(∀x (Faithful(x) ∨ ¬Poised(x))) → (∀x (¬Short(x))) ::: Someone who is either faithful or not poised is always not short.\n(∀x (¬Faithful(x))) ↔ (∀x (¬Different(x))) ::: If someone is not faithful, then he is not different, and vice versa.\n(∃x (Short(x) ∨ ¬Different(x))) → ((Alert(julie) ∧ Faithful(cyril))) ::: If there is at least one people who is either short or not different, then Julie is alert and Cyril is faithful.\n(∀x (Alert(x))) ↔ (∀x (Poised(x))) ::: Someone is alert if and only if he is poised.\n((¬Poised(julie) ∨ Different(tristan))) → ((Long(leroy))) ::: If Julie is not poised or Tristan is different, then Leroy is long.\n(∀x (Short(x))) ↔ (∀x (Faithful(x))) ::: If someone is short, then he is faithful, and vice versa.\n((Alert(brandi) ∨ Short(cyril))) → ((¬Poised(cyril))) ::: If Brandi is alert or Cyril is short, then Cyril is not poised.\n(∃x (Alert(x) ∨ ¬Poised(x))) → ((¬Long(shane))) ::: If there is at least one people who is alert or not poised, then Shane is not long.\n(∀x (¬Poised(x) ∧ ¬Short(x))) → (∀x (¬Alert(x))) ::: If someone is neither poised nor short, then he is not alert.\n(∀x (Alert(x))) → ((¬Different(neal) ∧ Faithful(julie))) ::: If everyone is alert, then Neal is not different and Julie is faithful.\n(∀x (¬Faithful(x))) → (∀x (Alert(x))) ::: If someone is not faithful, then he is alert.\n(∀x (x ∨ ¬Long(x) ∧ ¬Different(x))) → (∀x (Alert(x))) ::: If someone is he or not long is not different, then he is alert.\n",
                "First-Order-Logic Question": "Faithful(neal) ::: Neal is faithful."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "¬Different(brandi) ::: Brandi is not different.\nAlert(julie) ::: Julie is alert.\nLong(leroy) ::: Leroy is long.\n¬Poised(leroy) ::: Leroy is not poised.\nLong(julie) ::: Julie is long.\nPoised(tristan) ::: Tristan is poised.\n¬Faithful(cyril) ::: Cyril is not faithful.\n¬Different(tristan) ::: Tristan is not different.\n¬Different(cyril) ::: Cyril is not different.\nLong(cyril) ::: Cyril is long.\nLong(brandi) ::: Brandi is long.\nPoised(shane) ::: Shane is poised.\n(∀x (Faithful(x) ∨ ¬Poised(x))) → (∀x (¬Short(x))) ::: Someone who is either faithful or not poised is always not short.\n(∀x (¬Faithful(x))) ↔ (∀x (¬Different(x))) ::: If someone is not faithful, then he is not different, and vice versa.\n(∃x (Short(x) ∨ ¬Different(x))) → ((Alert(julie) ∧ Faithful(cyril))) ::: If there is at least one people who is either short or not different, then Julie is alert and Cyril is faithful.\n(∀x (Alert(x))) ↔ (∀x (Poised(x))) ::: Someone is alert if and only if he is poised.\n((¬Poised(julie) ∨ Different(tristan))) → ((Long(leroy))) ::: If Julie is not poised or Tristan is different, then Leroy is long.\n(∀x (Short(x))) ↔ (∀x (Faithful(x))) ::: If someone is short, then he is faithful, and vice versa.\n((Alert(brandi) ∨ Short(cyril))) → ((¬Poised(cyril))) ::: If Brandi is alert or Cyril is short, then Cyril is not poised.\n(∃x (Alert(x) ∨ ¬Poised(x))) → ((¬Long(shane))) ::: If there is at least one people who is alert or not poised, then Shane is not long.\n(∀x (¬Poised(x) ∧ ¬Short(x))) → (∀x (¬Alert(x))) ::: If someone is neither poised nor short, then he is not alert.\n(∀x (Alert(x))) → ((¬Different(neal) ∧ Faithful(julie))) ::: If everyone is alert, then Neal is not different and Julie is faithful.\n(∀x (¬Faithful(x))) → (∀x (Alert(x))) ::: If someone is not faithful, then he is alert.\n∀x((¬Long(x)∨¬Different(x))) ::: If someone is he or not long is not different, then he is alert.\n",
                "First-Order-Logic Question": "Faithful(neal) ::: Neal is faithful."
            },
            "diff": [
                {
                    "raw": "(∀x (x ∨ ¬Long(x) ∧ ¬Different(x))) → (∀x (Alert(x))) ::: If someone is he or not long is not different, then he is alert.",
                    "gram": "∀x((¬Long(x)∨¬Different(x))) ::: If someone is he or not long is not different, then he is alert."
                }
            ],
            "answer": "C",
            "grammar_answer": "A",
            "backup_answer": "C"
        },
        {
            "id": 1133,
            "raw_prog": {
                "First-Order-Logic Rules": "¬Different(brandi) ::: Brandi is not different.\nAlert(julie) ::: Julie is alert.\nLong(leroy) ::: Leroy is long.\n¬Poised(leroy) ::: Leroy is not poised.\nLong(julie) ::: Julie is long.\nPoised(tristan) ::: Tristan is poised.\n¬Faithful(cyril) ::: Cyril is not faithful.\n¬Different(tristan) ::: Tristan is not different.\n¬Different(cyril) ::: Cyril is not different.\nLong(cyril) ::: Cyril is long.\nLong(brandi) ::: Brandi is long.\nPoised(shane) ::: Shane is poised.\n(∀x (Faithful(x) ∨ ¬Poised(x))) → (∀x (¬Short(x))) ::: Someone who is either faithful or not poised is always not short.\n(∀x (¬Faithful(x))) ↔ (∀x (¬Different(x))) ::: If someone is not faithful, then he is not different, and vice versa.\n(∃x (Short(x) ∨ ¬Different(x))) → ((Alert(julie) ∧ Faithful(cyril))) ::: If there is at least one people who is either short or not different, then Julie is alert and Cyril is faithful.\n(∀x (Alert(x))) ↔ (∀x (Poised(x))) ::: Someone is alert if and only if he is poised.\n((¬Poised(julie) ∨ Different(tristan))) → ((Long(leroy))) ::: If Julie is not poised or Tristan is different, then Leroy is long.\n(∀x (Short(x))) ↔ (∀x (Faithful(x))) ::: If someone is short, then he is faithful, and vice versa.\n((Alert(brandi) ∨ Short(cyril))) → ((¬Poised(cyril))) ::: If Brandi is alert or Cyril is short, then Cyril is not poised.\n(∃x (Alert(x) ∨ ¬Poised(x))) → ((¬Long(shane))) ::: If there is at least one people who is alert or not poised, then Shane is not long.\n(∀x (¬Poised(x) ∧ ¬Short(x))) → (∀x (¬Alert(x))) ::: If someone is neither poised nor short, then he is not alert.\n(∀x (Alert(x))) → ((¬Different(neal) ∧ Faithful(julie))) ::: If everyone is alert, then Neal is not different and Julie is faithful.\n(∀x (¬Faithful(x))) → (∀x (Alert(x))) ::: If someone is not faithful, then he is alert.\n(∀x (x ∨ ¬Long(x)) → (¬Different(x))) → (∀x (Alert(x))) ::: If someone is he or not long is not different, then he is alert.\n",
                "First-Order-Logic Question": "¬Alert(leroy) ::: Leroy is not alert."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "¬Different(brandi) ::: Brandi is not different.\nAlert(julie) ::: Julie is alert.\nLong(leroy) ::: Leroy is long.\n¬Poised(leroy) ::: Leroy is not poised.\nLong(julie) ::: Julie is long.\nPoised(tristan) ::: Tristan is poised.\n¬Faithful(cyril) ::: Cyril is not faithful.\n¬Different(tristan) ::: Tristan is not different.\n¬Different(cyril) ::: Cyril is not different.\nLong(cyril) ::: Cyril is long.\nLong(brandi) ::: Brandi is long.\nPoised(shane) ::: Shane is poised.\n(∀x (Faithful(x) ∨ ¬Poised(x))) → (∀x (¬Short(x))) ::: Someone who is either faithful or not poised is always not short.\n(∀x (¬Faithful(x))) ↔ (∀x (¬Different(x))) ::: If someone is not faithful, then he is not different, and vice versa.\n(∃x (Short(x) ∨ ¬Different(x))) → ((Alert(julie) ∧ Faithful(cyril))) ::: If there is at least one people who is either short or not different, then Julie is alert and Cyril is faithful.\n(∀x (Alert(x))) ↔ (∀x (Poised(x))) ::: Someone is alert if and only if he is poised.\n((¬Poised(julie) ∨ Different(tristan))) → ((Long(leroy))) ::: If Julie is not poised or Tristan is different, then Leroy is long.\n(∀x (Short(x))) ↔ (∀x (Faithful(x))) ::: If someone is short, then he is faithful, and vice versa.\n((Alert(brandi) ∨ Short(cyril))) → ((¬Poised(cyril))) ::: If Brandi is alert or Cyril is short, then Cyril is not poised.\n(∃x (Alert(x) ∨ ¬Poised(x))) → ((¬Long(shane))) ::: If there is at least one people who is alert or not poised, then Shane is not long.\n(∀x (¬Poised(x) ∧ ¬Short(x))) → (∀x (¬Alert(x))) ::: If someone is neither poised nor short, then he is not alert.\n(∀x (Alert(x))) → ((¬Different(neal) ∧ Faithful(julie))) ::: If everyone is alert, then Neal is not different and Julie is faithful.\n(∀x (¬Faithful(x))) → (∀x (Alert(x))) ::: If someone is not faithful, then he is alert.\n∀x((¬Long(x)→Alert(x))) ::: If someone is he or not long is not different, then he is alert.\n",
                "First-Order-Logic Question": "¬Alert(leroy) ::: Leroy is not alert."
            },
            "diff": [
                {
                    "raw": "(∀x (x ∨ ¬Long(x)) → (¬Different(x))) → (∀x (Alert(x))) ::: If someone is he or not long is not different, then he is alert.",
                    "gram": "∀x((¬Long(x)→Alert(x))) ::: If someone is he or not long is not different, then he is alert."
                }
            ],
            "answer": "A",
            "grammar_answer": "A",
            "backup_answer": "A"
        },
        {
            "id": 1135,
            "raw_prog": {
                "First-Order-Logic Rules": "¬Different(brandi) ::: Brandi is not different.\nAlert(julie) ::: Julie is alert.\nLong(leroy) ::: Leroy is long.\n¬Poised(leroy) ::: Leroy is not poised.\nLong(julie) ::: Julie is long.\nPoised(tristan) ::: Tristan is poised.\n¬Faithful(cyril) ::: Cyril is not faithful.\n¬Different(tristan) ::: Tristan is not different.\n¬Different(cyril) ::: Cyril is not different.\nLong(cyril) ::: Cyril is long.\nLong(brandi) ::: Brandi is long.\nPoised(shane) ::: Shane is poised.\n(∀x (Faithful(x) ∨ ¬Poised(x))) → (∀x (¬Short(x))) ::: Someone who is either faithful or not poised is always not short.\n(∀x (¬Faithful(x))) ↔ (∀x (¬Different(x))) ::: If someone is not faithful, then he is not different, and vice versa.\n(∃x (Short(x) ∨ ¬Different(x))) → ((Alert(julie) ∧ Faithful(cyril))) ::: If there is at least one people who is either short or not different, then Julie is alert and Cyril is faithful.\n(∀x (Alert(x))) ↔ (∀x (Poised(x))) ::: Someone is alert if and only if he is poised.\n((¬Poised(julie) ∨ Different(tristan))) → ((Long(leroy))) ::: If Julie is not poised or Tristan is different, then Leroy is long.\n(∀x (Short(x))) ↔ (∀x (Faithful(x))) ::: If someone is short, then he is faithful, and vice versa.\n((Alert(brandi) ∨ Short(cyril))) → ((¬Poised(cyril))) ::: If Brandi is alert or Cyril is short, then Cyril is not poised.\n(∃x (Alert(x) ∨ ¬Poised(x))) → ((¬Long(shane))) ::: If there is at least one people who is alert or not poised, then Shane is not long.\n(∀x (¬Poised(x) ∧ ¬Short(x))) → (∀x (¬Alert(x))) ::: If someone is neither poised nor short, then he is not alert.\n(∀x (Alert(x))) → ((¬Different(neal) ∧ Faithful(julie))) ::: If everyone is alert, then Neal is not different and Julie is faithful.\n(∀x (¬Faithful(x))) → (∀x (Alert(x))) ::: If someone is not faithful, then he is alert.\n(∀x (x ∨ ¬Long(x) ∧ ¬Different(x))) → (∀x (Alert(x))) ::: If someone is he or not long is not different, then he is alert.\n",
                "First-Order-Logic Question": "Alert(shane) ::: Shane is alert."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "¬Different(brandi) ::: Brandi is not different.\nAlert(julie) ::: Julie is alert.\nLong(leroy) ::: Leroy is long.\n¬Poised(leroy) ::: Leroy is not poised.\nLong(julie) ::: Julie is long.\nPoised(tristan) ::: Tristan is poised.\n¬Faithful(cyril) ::: Cyril is not faithful.\n¬Different(tristan) ::: Tristan is not different.\n¬Different(cyril) ::: Cyril is not different.\nLong(cyril) ::: Cyril is long.\nLong(brandi) ::: Brandi is long.\nPoised(shane) ::: Shane is poised.\n(∀x (Faithful(x) ∨ ¬Poised(x))) → (∀x (¬Short(x))) ::: Someone who is either faithful or not poised is always not short.\n(∀x (¬Faithful(x))) ↔ (∀x (¬Different(x))) ::: If someone is not faithful, then he is not different, and vice versa.\n(∃x (Short(x) ∨ ¬Different(x))) → ((Alert(julie) ∧ Faithful(cyril))) ::: If there is at least one people who is either short or not different, then Julie is alert and Cyril is faithful.\n(∀x (Alert(x))) ↔ (∀x (Poised(x))) ::: Someone is alert if and only if he is poised.\n((¬Poised(julie) ∨ Different(tristan))) → ((Long(leroy))) ::: If Julie is not poised or Tristan is different, then Leroy is long.\n(∀x (Short(x))) ↔ (∀x (Faithful(x))) ::: If someone is short, then he is faithful, and vice versa.\n((Alert(brandi) ∨ Short(cyril))) → ((¬Poised(cyril))) ::: If Brandi is alert or Cyril is short, then Cyril is not poised.\n(∃x (Alert(x) ∨ ¬Poised(x))) → ((¬Long(shane))) ::: If there is at least one people who is alert or not poised, then Shane is not long.\n(∀x (¬Poised(x) ∧ ¬Short(x))) → (∀x (¬Alert(x))) ::: If someone is neither poised nor short, then he is not alert.\n(∀x (Alert(x))) → ((¬Different(neal) ∧ Faithful(julie))) ::: If everyone is alert, then Neal is not different and Julie is faithful.\n(∀x (¬Faithful(x))) → (∀x (Alert(x))) ::: If someone is not faithful, then he is alert.\n∀x((¬Long(x)∨¬Different(x))) ::: If someone is he or not long is not different, then he is alert.\n",
                "First-Order-Logic Question": "Alert(shane) ::: Shane is alert."
            },
            "diff": [
                {
                    "raw": "(∀x (x ∨ ¬Long(x) ∧ ¬Different(x))) → (∀x (Alert(x))) ::: If someone is he or not long is not different, then he is alert.",
                    "gram": "∀x((¬Long(x)∨¬Different(x))) ::: If someone is he or not long is not different, then he is alert."
                }
            ],
            "answer": "A",
            "grammar_answer": "A",
            "backup_answer": "A"
        },
        {
            "id": 1200,
            "raw_prog": {
                "First-Order-Logic Rules": "¬Several(rolf) ::: Rolf is not several.\n¬Precious(sigmund) ::: Sigmund is not precious.\nPrecious(godwin) ::: Godwin is precious.\nFearless(sigmund) ::: Sigmund is fearless.\nPrecious(rolf) ::: Rolf is precious.\n¬Stubborn(rose) ::: Rose is not stubborn.\nJittery(conrad) ::: Conrad is jittery.\n¬Fearless(brandi) ::: Brandi is not fearless.\n¬Sour(brandi) ::: Brandi is not sour.\nJittery(rolf) ::: Rolf is jittery.\nStubborn(owen) ::: Owen is stubborn.\n¬Fearless(godwin) ::: Godwin is not fearless.\n(¬∃x (¬x)) → (¬Jittery(godwin)) ::: If there is nobody who is not, then Godwin is not jittery.\n(∃x (Several(x) ∨ ¬Sour(x))) → (¬Stubborn(brandi)) ::: If there is someone who is either several or not sour, then Brandi is not stubborn.\n(∃x (¬Sour(x))) → (¬Stubborn(owen) ∧ ¬Several(conrad)) ::: If there is at least one people who is not sour, then Owen is not stubborn and Conrad is not several.\n(∀x (Several(x) → ¬Sour(x))) → (∀x (Stubborn(x))) ::: If someone who is several is also not sour, then he is stubborn.\n(∃x (Sour(x) ∨ Jittery(x))) → (¬Several(brandi) ∧ Stubborn(conrad)) ::: If there is at least one people who is either sour or jittery, then Brandi is not several and Conrad is stubborn.\n(¬Fearless(rolf)) → (¬Jittery(conrad)) ::: If Rolf is not fearless, then Conrad is not jittery.\n(¬Precious(godwin)) → (Jittery(godwin) ∧ ¬Fearless(owen)) ::: It can be concluded that Godwin is jittery and Owen is not fearless once knowing that Godwin is not precious.\n(¬Jittery(godwin) ∧ ¬Several(sigmund)) → (Precious(sigmund)) ::: It can be concluded that Sigmund is precious once knowing that Godwin is not jittery and Sigmund is not several.\n(Several(rolf) ∨ Fearless(brandi)) → (¬Precious(brandi)) ::: If Rolf is several or Brandi is fearless, then Brandi is not precious.\n(¬Jittery(godwin) ∧ Several(conrad)) → (Sour(owen)) ::: If Godwin is not jittery and Conrad is several, then Owen is sour.\n(∀x (Precious(x))) → (∀x (¬Several(x))) ::: Someone who is precious is always not several.\n(¬Fearless(godwin)) ↔ (Several(brandi)) ::: If Godwin is not fearless, then Brandi is several, and vice versa.\n",
                "First-Order-Logic Question": "Sour(brandi) ::: Brandi is sour."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "¬Several(rolf) ::: Rolf is not several.\n¬Precious(sigmund) ::: Sigmund is not precious.\nPrecious(godwin) ::: Godwin is precious.\nFearless(sigmund) ::: Sigmund is fearless.\nPrecious(rolf) ::: Rolf is precious.\n¬Stubborn(rose) ::: Rose is not stubborn.\nJittery(conrad) ::: Conrad is jittery.\n¬Fearless(brandi) ::: Brandi is not fearless.\n¬Sour(brandi) ::: Brandi is not sour.\nJittery(rolf) ::: Rolf is jittery.\nStubborn(owen) ::: Owen is stubborn.\n¬Fearless(godwin) ::: Godwin is not fearless.\n¬∃x(¬(¬(Several(x)))) ::: If there is nobody who is not, then Godwin is not jittery.\n(∃x (Several(x) ∨ ¬Sour(x))) → (¬Stubborn(brandi)) ::: If there is someone who is either several or not sour, then Brandi is not stubborn.\n(∃x (¬Sour(x))) → (¬Stubborn(owen) ∧ ¬Several(conrad)) ::: If there is at least one people who is not sour, then Owen is not stubborn and Conrad is not several.\n(∀x (Several(x) → ¬Sour(x))) → (∀x (Stubborn(x))) ::: If someone who is several is also not sour, then he is stubborn.\n(∃x (Sour(x) ∨ Jittery(x))) → (¬Several(brandi) ∧ Stubborn(conrad)) ::: If there is at least one people who is either sour or jittery, then Brandi is not several and Conrad is stubborn.\n(¬Fearless(rolf)) → (¬Jittery(conrad)) ::: If Rolf is not fearless, then Conrad is not jittery.\n(¬Precious(godwin)) → (Jittery(godwin) ∧ ¬Fearless(owen)) ::: It can be concluded that Godwin is jittery and Owen is not fearless once knowing that Godwin is not precious.\n(¬Jittery(godwin) ∧ ¬Several(sigmund)) → (Precious(sigmund)) ::: It can be concluded that Sigmund is precious once knowing that Godwin is not jittery and Sigmund is not several.\n(Several(rolf) ∨ Fearless(brandi)) → (¬Precious(brandi)) ::: If Rolf is several or Brandi is fearless, then Brandi is not precious.\n(¬Jittery(godwin) ∧ Several(conrad)) → (Sour(owen)) ::: If Godwin is not jittery and Conrad is several, then Owen is sour.\n(∀x (Precious(x))) → (∀x (¬Several(x))) ::: Someone who is precious is always not several.\n(¬Fearless(godwin)) ↔ (Several(brandi)) ::: If Godwin is not fearless, then Brandi is several, and vice versa.\n",
                "First-Order-Logic Question": "Sour(brandi) ::: Brandi is sour."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬x)) → (¬Jittery(godwin)) ::: If there is nobody who is not, then Godwin is not jittery.",
                    "gram": "¬∃x(¬(¬(Several(x)))) ::: If there is nobody who is not, then Godwin is not jittery."
                }
            ],
            "answer": "B",
            "grammar_answer": "A",
            "backup_answer": "B"
        },
        {
            "id": 1201,
            "raw_prog": {
                "First-Order-Logic Rules": "¬Several(rolf) ::: Rolf is not several.\n¬Precious(sigmund) ::: Sigmund is not precious.\nPrecious(godwin) ::: Godwin is precious.\nFearless(sigmund) ::: Sigmund is fearless.\nPrecious(rolf) ::: Rolf is precious.\n¬Stubborn(rose) ::: Rose is not stubborn.\nJittery(conrad) ::: Conrad is jittery.\n¬Fearless(brandi) ::: Brandi is not fearless.\n¬Sour(brandi) ::: Brandi is not sour.\nJittery(rolf) ::: Rolf is jittery.\nStubborn(owen) ::: Owen is stubborn.\n¬Fearless(godwin) ::: Godwin is not fearless.\n(¬∃x (¬x)) → (¬Jittery(godwin)) ::: If there is nobody who is not, then Godwin is not jittery.\n(∃x (Several(x) ∨ ¬Sour(x))) → (¬Stubborn(brandi)) ::: If there is someone who is either several or not sour, then Brandi is not stubborn.\n(∃x (¬Sour(x))) → ((¬Stubborn(owen) ∧ ¬Several(conrad))) ::: If there is at least one people who is not sour, then Owen is not stubborn and Conrad is not several.\n(∀x (Several(x) → ¬Sour(x))) → (∀x (Stubborn(x))) ::: If someone who is several is also not sour, then he is stubborn.\n(∃x (Sour(x) ∨ Jittery(x))) → ((¬Several(brandi) ∧ Stubborn(conrad))) ::: If there is at least one people who is either sour or jittery, then Brandi is not several and Conrad is stubborn.\n(¬Fearless(rolf)) → (¬Jittery(conrad)) ::: If Rolf is not fearless, then Conrad is not jittery.\n(¬Precious(godwin)) → ((Jittery(godwin) ∧ ¬Fearless(owen))) ::: It can be concluded that Godwin is jittery and Owen is not fearless once knowing that Godwin is not precious.\n((¬Jittery(godwin) ∧ ¬Several(sigmund))) → (Precious(sigmund)) ::: It can be concluded that Sigmund is precious once knowing that Godwin is not jittery and Sigmund is not several.\n((Several(rolf) ∨ Fearless(brandi))) → (¬Precious(brandi)) ::: If Rolf is several or Brandi is fearless, then Brandi is not precious.\n((¬Jittery(godwin) ∧ Several(conrad))) → (Sour(owen)) ::: If Godwin is not jittery and Conrad is several, then Owen is sour.\n(∀x (Precious(x))) → (∀x (¬Several(x))) ::: Someone who is precious is always not several.\n((¬Fearless(godwin))) ↔ ((Several(brandi))) ::: If Godwin is not fearless, then Brandi is several, and vice versa.\n",
                "First-Order-Logic Question": "¬Fearless(rose) ::: Rose is not fearless."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "¬Several(rolf) ::: Rolf is not several.\n¬Precious(sigmund) ::: Sigmund is not precious.\nPrecious(godwin) ::: Godwin is precious.\nFearless(sigmund) ::: Sigmund is fearless.\nPrecious(rolf) ::: Rolf is precious.\n¬Stubborn(rose) ::: Rose is not stubborn.\nJittery(conrad) ::: Conrad is jittery.\n¬Fearless(brandi) ::: Brandi is not fearless.\n¬Sour(brandi) ::: Brandi is not sour.\nJittery(rolf) ::: Rolf is jittery.\nStubborn(owen) ::: Owen is stubborn.\n¬Fearless(godwin) ::: Godwin is not fearless.\n¬∃x(¬(¬(Several(x)))) ::: If there is nobody who is not, then Godwin is not jittery.\n(∃x (Several(x) ∨ ¬Sour(x))) → (¬Stubborn(brandi)) ::: If there is someone who is either several or not sour, then Brandi is not stubborn.\n(∃x (¬Sour(x))) → ((¬Stubborn(owen) ∧ ¬Several(conrad))) ::: If there is at least one people who is not sour, then Owen is not stubborn and Conrad is not several.\n(∀x (Several(x) → ¬Sour(x))) → (∀x (Stubborn(x))) ::: If someone who is several is also not sour, then he is stubborn.\n(∃x (Sour(x) ∨ Jittery(x))) → ((¬Several(brandi) ∧ Stubborn(conrad))) ::: If there is at least one people who is either sour or jittery, then Brandi is not several and Conrad is stubborn.\n(¬Fearless(rolf)) → (¬Jittery(conrad)) ::: If Rolf is not fearless, then Conrad is not jittery.\n(¬Precious(godwin)) → ((Jittery(godwin) ∧ ¬Fearless(owen))) ::: It can be concluded that Godwin is jittery and Owen is not fearless once knowing that Godwin is not precious.\n((¬Jittery(godwin) ∧ ¬Several(sigmund))) → (Precious(sigmund)) ::: It can be concluded that Sigmund is precious once knowing that Godwin is not jittery and Sigmund is not several.\n((Several(rolf) ∨ Fearless(brandi))) → (¬Precious(brandi)) ::: If Rolf is several or Brandi is fearless, then Brandi is not precious.\n((¬Jittery(godwin) ∧ Several(conrad))) → (Sour(owen)) ::: If Godwin is not jittery and Conrad is several, then Owen is sour.\n(∀x (Precious(x))) → (∀x (¬Several(x))) ::: Someone who is precious is always not several.\n((¬Fearless(godwin))) ↔ ((Several(brandi))) ::: If Godwin is not fearless, then Brandi is several, and vice versa.\n",
                "First-Order-Logic Question": "¬Fearless(rose) ::: Rose is not fearless."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬x)) → (¬Jittery(godwin)) ::: If there is nobody who is not, then Godwin is not jittery.",
                    "gram": "¬∃x(¬(¬(Several(x)))) ::: If there is nobody who is not, then Godwin is not jittery."
                }
            ],
            "answer": "C",
            "grammar_answer": "A",
            "backup_answer": "C"
        },
        {
            "id": 1202,
            "raw_prog": {
                "First-Order-Logic Rules": "¬Several(rolf) ::: Rolf is not several.\n¬Precious(sigmund) ::: Sigmund is not precious.\nPrecious(godwin) ::: Godwin is precious.\nFearless(sigmund) ::: Sigmund is fearless.\nPrecious(rolf) ::: Rolf is precious.\n¬Stubborn(rose) ::: Rose is not stubborn.\nJittery(conrad) ::: Conrad is jittery.\n¬Fearless(brandi) ::: Brandi is not fearless.\n¬Sour(brandi) ::: Brandi is not sour.\nJittery(rolf) ::: Rolf is jittery.\nStubborn(owen) ::: Owen is stubborn.\n¬Fearless(godwin) ::: Godwin is not fearless.\n(¬∃x (¬x)) → (¬Jittery(godwin)) ::: If there is nobody who is not, then Godwin is not jittery.\n(∃x (Several(x) ∨ ¬Sour(x))) → (¬Stubborn(brandi)) ::: If there is someone who is either several or not sour, then Brandi is not stubborn.\n(∃x (¬Sour(x))) → ((¬Stubborn(owen) ∧ ¬Several(conrad))) ::: If there is at least one people who is not sour, then Owen is not stubborn and Conrad is not several.\n(∀x (Several(x) ∧ ¬Sour(x))) → (∀x (Stubborn(x))) ::: If someone who is several is also not sour, then he is stubborn.\n(∃x (Sour(x) ∨ Jittery(x))) → ((¬Several(brandi) ∧ Stubborn(conrad))) ::: If there is at least one people who is either sour or jittery, then Brandi is not several and Conrad is stubborn.\n(¬Fearless(rolf)) → (¬Jittery(conrad)) ::: If Rolf is not fearless, then Conrad is not jittery.\n((¬Precious(godwin))) → ((Jittery(godwin) ∧ ¬Fearless(owen))) ::: It can be concluded that Godwin is jittery and Owen is not fearless once knowing that Godwin is not precious.\n((¬Jittery(godwin) ∧ ¬Several(sigmund))) → ((Precious(sigmund))) ::: It can be concluded that Sigmund is precious once knowing that Godwin is not jittery and Sigmund is not several.\n((Several(rolf) ∨ Fearless(brandi))) → (¬Precious(brandi)) ::: If Rolf is several or Brandi is fearless, then Brandi is not precious.\n((¬Jittery(godwin) ∧ Several(conrad))) → ((Sour(owen))) ::: If Godwin is not jittery and Conrad is several, then Owen is sour.\n(∀x (Precious(x))) → (∀x (¬Several(x))) ::: Someone who is precious is always not several.\n((¬Fearless(godwin))) ↔ ((Several(brandi))) ::: If Godwin is not fearless, then Brandi is several, and vice versa.\n",
                "First-Order-Logic Question": "Several(owen) ::: Owen is several."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "¬Several(rolf) ::: Rolf is not several.\n¬Precious(sigmund) ::: Sigmund is not precious.\nPrecious(godwin) ::: Godwin is precious.\nFearless(sigmund) ::: Sigmund is fearless.\nPrecious(rolf) ::: Rolf is precious.\n¬Stubborn(rose) ::: Rose is not stubborn.\nJittery(conrad) ::: Conrad is jittery.\n¬Fearless(brandi) ::: Brandi is not fearless.\n¬Sour(brandi) ::: Brandi is not sour.\nJittery(rolf) ::: Rolf is jittery.\nStubborn(owen) ::: Owen is stubborn.\n¬Fearless(godwin) ::: Godwin is not fearless.\n¬∃x(¬(¬(Several(x)))) ::: If there is nobody who is not, then Godwin is not jittery.\n(∃x (Several(x) ∨ ¬Sour(x))) → (¬Stubborn(brandi)) ::: If there is someone who is either several or not sour, then Brandi is not stubborn.\n(∃x (¬Sour(x))) → ((¬Stubborn(owen) ∧ ¬Several(conrad))) ::: If there is at least one people who is not sour, then Owen is not stubborn and Conrad is not several.\n(∀x (Several(x) ∧ ¬Sour(x))) → (∀x (Stubborn(x))) ::: If someone who is several is also not sour, then he is stubborn.\n(∃x (Sour(x) ∨ Jittery(x))) → ((¬Several(brandi) ∧ Stubborn(conrad))) ::: If there is at least one people who is either sour or jittery, then Brandi is not several and Conrad is stubborn.\n(¬Fearless(rolf)) → (¬Jittery(conrad)) ::: If Rolf is not fearless, then Conrad is not jittery.\n((¬Precious(godwin))) → ((Jittery(godwin) ∧ ¬Fearless(owen))) ::: It can be concluded that Godwin is jittery and Owen is not fearless once knowing that Godwin is not precious.\n((¬Jittery(godwin) ∧ ¬Several(sigmund))) → ((Precious(sigmund))) ::: It can be concluded that Sigmund is precious once knowing that Godwin is not jittery and Sigmund is not several.\n((Several(rolf) ∨ Fearless(brandi))) → (¬Precious(brandi)) ::: If Rolf is several or Brandi is fearless, then Brandi is not precious.\n((¬Jittery(godwin) ∧ Several(conrad))) → ((Sour(owen))) ::: If Godwin is not jittery and Conrad is several, then Owen is sour.\n(∀x (Precious(x))) → (∀x (¬Several(x))) ::: Someone who is precious is always not several.\n((¬Fearless(godwin))) ↔ ((Several(brandi))) ::: If Godwin is not fearless, then Brandi is several, and vice versa.\n",
                "First-Order-Logic Question": "Several(owen) ::: Owen is several."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬x)) → (¬Jittery(godwin)) ::: If there is nobody who is not, then Godwin is not jittery.",
                    "gram": "¬∃x(¬(¬(Several(x)))) ::: If there is nobody who is not, then Godwin is not jittery."
                }
            ],
            "answer": "C",
            "grammar_answer": "A",
            "backup_answer": "C"
        },
        {
            "id": 1203,
            "raw_prog": {
                "First-Order-Logic Rules": "¬Several(rolf) ::: Rolf is not several.\n¬Precious(sigmund) ::: Sigmund is not precious.\nPrecious(godwin) ::: Godwin is precious.\nFearless(sigmund) ::: Sigmund is fearless.\nPrecious(rolf) ::: Rolf is precious.\n¬Stubborn(rose) ::: Rose is not stubborn.\nJittery(conrad) ::: Conrad is jittery.\n¬Fearless(brandi) ::: Brandi is not fearless.\n¬Sour(brandi) ::: Brandi is not sour.\nJittery(rolf) ::: Rolf is jittery.\nStubborn(owen) ::: Owen is stubborn.\n¬Fearless(godwin) ::: Godwin is not fearless.\n(¬∃x (¬x)) → (¬Jittery(godwin)) ::: If there is nobody who is not, then Godwin is not jittery.\n(∃x (Several(x) ∨ ¬Sour(x))) → (¬Stubborn(brandi)) ::: If there is someone who is either several or not sour, then Brandi is not stubborn.\n(∃x (¬Sour(x))) → ((¬Stubborn(owen) ∧ ¬Several(conrad))) ::: If there is at least one people who is not sour, then Owen is not stubborn and Conrad is not several.\n(∀x (Several(x) ∧ ¬Sour(x))) → (∀x (Stubborn(x))) ::: If someone who is several is also not sour, then he is stubborn.\n(∃x (Sour(x) ∨ Jittery(x))) → ((¬Several(brandi) ∧ Stubborn(conrad))) ::: If there is at least one people who is either sour or jittery, then Brandi is not several and Conrad is stubborn.\n(¬Fearless(rolf)) → (¬Jittery(conrad)) ::: If Rolf is not fearless, then Conrad is not jittery.\n(¬Precious(godwin)) → ((Jittery(godwin) ∧ ¬Fearless(owen))) ::: It can be concluded that Godwin is jittery and Owen is not fearless once knowing that Godwin is not precious.\n((¬Jittery(godwin) ∧ ¬Several(sigmund))) → (Precious(sigmund)) ::: It can be concluded that Sigmund is precious once knowing that Godwin is not jittery and Sigmund is not several.\n((Several(rolf) ∨ Fearless(brandi))) → (¬Precious(brandi)) ::: If Rolf is several or Brandi is fearless, then Brandi is not precious.\n((¬Jittery(godwin) ∧ Several(conrad))) → (Sour(owen)) ::: If Godwin is not jittery and Conrad is several, then Owen is sour.\n(∀x (Precious(x))) → (∀x (¬Several(x))) ::: Someone who is precious is always not several.\n(¬Fearless(godwin)) ↔ (Several(brandi)) ::: If Godwin is not fearless, then Brandi is several, and vice versa.\n",
                "First-Order-Logic Question": "¬Fearless(sigmund) ::: Sigmund is not fearless."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "¬Several(rolf) ::: Rolf is not several.\n¬Precious(sigmund) ::: Sigmund is not precious.\nPrecious(godwin) ::: Godwin is precious.\nFearless(sigmund) ::: Sigmund is fearless.\nPrecious(rolf) ::: Rolf is precious.\n¬Stubborn(rose) ::: Rose is not stubborn.\nJittery(conrad) ::: Conrad is jittery.\n¬Fearless(brandi) ::: Brandi is not fearless.\n¬Sour(brandi) ::: Brandi is not sour.\nJittery(rolf) ::: Rolf is jittery.\nStubborn(owen) ::: Owen is stubborn.\n¬Fearless(godwin) ::: Godwin is not fearless.\n¬∃x(¬(¬(Several(x)))) ::: If there is nobody who is not, then Godwin is not jittery.\n(∃x (Several(x) ∨ ¬Sour(x))) → (¬Stubborn(brandi)) ::: If there is someone who is either several or not sour, then Brandi is not stubborn.\n(∃x (¬Sour(x))) → ((¬Stubborn(owen) ∧ ¬Several(conrad))) ::: If there is at least one people who is not sour, then Owen is not stubborn and Conrad is not several.\n(∀x (Several(x) ∧ ¬Sour(x))) → (∀x (Stubborn(x))) ::: If someone who is several is also not sour, then he is stubborn.\n(∃x (Sour(x) ∨ Jittery(x))) → ((¬Several(brandi) ∧ Stubborn(conrad))) ::: If there is at least one people who is either sour or jittery, then Brandi is not several and Conrad is stubborn.\n(¬Fearless(rolf)) → (¬Jittery(conrad)) ::: If Rolf is not fearless, then Conrad is not jittery.\n(¬Precious(godwin)) → ((Jittery(godwin) ∧ ¬Fearless(owen))) ::: It can be concluded that Godwin is jittery and Owen is not fearless once knowing that Godwin is not precious.\n((¬Jittery(godwin) ∧ ¬Several(sigmund))) → (Precious(sigmund)) ::: It can be concluded that Sigmund is precious once knowing that Godwin is not jittery and Sigmund is not several.\n((Several(rolf) ∨ Fearless(brandi))) → (¬Precious(brandi)) ::: If Rolf is several or Brandi is fearless, then Brandi is not precious.\n((¬Jittery(godwin) ∧ Several(conrad))) → (Sour(owen)) ::: If Godwin is not jittery and Conrad is several, then Owen is sour.\n(∀x (Precious(x))) → (∀x (¬Several(x))) ::: Someone who is precious is always not several.\n(¬Fearless(godwin)) ↔ (Several(brandi)) ::: If Godwin is not fearless, then Brandi is several, and vice versa.\n",
                "First-Order-Logic Question": "¬Fearless(sigmund) ::: Sigmund is not fearless."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬x)) → (¬Jittery(godwin)) ::: If there is nobody who is not, then Godwin is not jittery.",
                    "gram": "¬∃x(¬(¬(Several(x)))) ::: If there is nobody who is not, then Godwin is not jittery."
                }
            ],
            "answer": "B",
            "grammar_answer": "A",
            "backup_answer": "B"
        },
        {
            "id": 1204,
            "raw_prog": {
                "First-Order-Logic Rules": "¬Several(rolf) ::: Rolf is not several.\n¬Precious(sigmund) ::: Sigmund is not precious.\nPrecious(godwin) ::: Godwin is precious.\nFearless(sigmund) ::: Sigmund is fearless.\nPrecious(rolf) ::: Rolf is precious.\n¬Stubborn(rose) ::: Rose is not stubborn.\nJittery(conrad) ::: Conrad is jittery.\n¬Fearless(brandi) ::: Brandi is not fearless.\n¬Sour(brandi) ::: Brandi is not sour.\nJittery(rolf) ::: Rolf is jittery.\nStubborn(owen) ::: Owen is stubborn.\n¬Fearless(godwin) ::: Godwin is not fearless.\n(¬∃x (¬x)) → (¬Jittery(godwin)) ::: If there is nobody who is not, then Godwin is not jittery.\n(∃x (Several(x) ∨ ¬Sour(x))) → (¬Stubborn(brandi)) ::: If there is someone who is either several or not sour, then Brandi is not stubborn.\n(∃x (¬Sour(x))) → ((¬Stubborn(owen) ∧ ¬Several(conrad))) ::: If there is at least one people who is not sour, then Owen is not stubborn and Conrad is not several.\n(∀x (Several(x) → ¬Sour(x))) → (∀x (Stubborn(x))) ::: If someone who is several is also not sour, then he is stubborn.\n(∃x (Sour(x) ∨ Jittery(x))) → ((¬Several(brandi) ∧ Stubborn(conrad))) ::: If there is at least one people who is either sour or jittery, then Brandi is not several and Conrad is stubborn.\n(¬Fearless(rolf)) → (¬Jittery(conrad)) ::: If Rolf is not fearless, then Conrad is not jittery.\n(¬Precious(godwin)) → ((Jittery(godwin) ∧ ¬Fearless(owen))) ::: It can be concluded that Godwin is jittery and Owen is not fearless once knowing that Godwin is not precious.\n((¬Jittery(godwin) ∧ ¬Several(sigmund))) → (Precious(sigmund)) ::: It can be concluded that Sigmund is precious once knowing that Godwin is not jittery and Sigmund is not several.\n((Several(rolf) ∨ Fearless(brandi))) → (¬Precious(brandi)) ::: If Rolf is several or Brandi is fearless, then Brandi is not precious.\n((¬Jittery(godwin) ∧ Several(conrad))) → (Sour(owen)) ::: If Godwin is not jittery and Conrad is several, then Owen is sour.\n(∀x (Precious(x))) → (∀x (¬Several(x))) ::: Someone who is precious is always not several.\n(¬Fearless(godwin)) ↔ (Several(brandi)) ::: If Godwin is not fearless, then Brandi is several, and vice versa.\n",
                "First-Order-Logic Question": "Jittery(conrad) ::: Conrad is jittery."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "¬Several(rolf) ::: Rolf is not several.\n¬Precious(sigmund) ::: Sigmund is not precious.\nPrecious(godwin) ::: Godwin is precious.\nFearless(sigmund) ::: Sigmund is fearless.\nPrecious(rolf) ::: Rolf is precious.\n¬Stubborn(rose) ::: Rose is not stubborn.\nJittery(conrad) ::: Conrad is jittery.\n¬Fearless(brandi) ::: Brandi is not fearless.\n¬Sour(brandi) ::: Brandi is not sour.\nJittery(rolf) ::: Rolf is jittery.\nStubborn(owen) ::: Owen is stubborn.\n¬Fearless(godwin) ::: Godwin is not fearless.\n¬∃x(¬(¬(Several(x)))) ::: If there is nobody who is not, then Godwin is not jittery.\n(∃x (Several(x) ∨ ¬Sour(x))) → (¬Stubborn(brandi)) ::: If there is someone who is either several or not sour, then Brandi is not stubborn.\n(∃x (¬Sour(x))) → ((¬Stubborn(owen) ∧ ¬Several(conrad))) ::: If there is at least one people who is not sour, then Owen is not stubborn and Conrad is not several.\n(∀x (Several(x) → ¬Sour(x))) → (∀x (Stubborn(x))) ::: If someone who is several is also not sour, then he is stubborn.\n(∃x (Sour(x) ∨ Jittery(x))) → ((¬Several(brandi) ∧ Stubborn(conrad))) ::: If there is at least one people who is either sour or jittery, then Brandi is not several and Conrad is stubborn.\n(¬Fearless(rolf)) → (¬Jittery(conrad)) ::: If Rolf is not fearless, then Conrad is not jittery.\n(¬Precious(godwin)) → ((Jittery(godwin) ∧ ¬Fearless(owen))) ::: It can be concluded that Godwin is jittery and Owen is not fearless once knowing that Godwin is not precious.\n((¬Jittery(godwin) ∧ ¬Several(sigmund))) → (Precious(sigmund)) ::: It can be concluded that Sigmund is precious once knowing that Godwin is not jittery and Sigmund is not several.\n((Several(rolf) ∨ Fearless(brandi))) → (¬Precious(brandi)) ::: If Rolf is several or Brandi is fearless, then Brandi is not precious.\n((¬Jittery(godwin) ∧ Several(conrad))) → (Sour(owen)) ::: If Godwin is not jittery and Conrad is several, then Owen is sour.\n(∀x (Precious(x))) → (∀x (¬Several(x))) ::: Someone who is precious is always not several.\n(¬Fearless(godwin)) ↔ (Several(brandi)) ::: If Godwin is not fearless, then Brandi is several, and vice versa.\n",
                "First-Order-Logic Question": "Jittery(conrad) ::: Conrad is jittery."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬x)) → (¬Jittery(godwin)) ::: If there is nobody who is not, then Godwin is not jittery.",
                    "gram": "¬∃x(¬(¬(Several(x)))) ::: If there is nobody who is not, then Godwin is not jittery."
                }
            ],
            "answer": "A",
            "grammar_answer": "A",
            "backup_answer": "A"
        },
        {
            "id": 1205,
            "raw_prog": {
                "First-Order-Logic Rules": "¬Several(rolf) ::: Rolf is not several.\n¬Precious(sigmund) ::: Sigmund is not precious.\nPrecious(godwin) ::: Godwin is precious.\nFearless(sigmund) ::: Sigmund is fearless.\nPrecious(rolf) ::: Rolf is precious.\n¬Stubborn(rose) ::: Rose is not stubborn.\nJittery(conrad) ::: Conrad is jittery.\n¬Fearless(brandi) ::: Brandi is not fearless.\n¬Sour(brandi) ::: Brandi is not sour.\nJittery(rolf) ::: Rolf is jittery.\nStubborn(owen) ::: Owen is stubborn.\n¬Fearless(godwin) ::: Godwin is not fearless.\n(¬∃x (¬x)) → (¬Jittery(godwin)) ::: If there is nobody who is not, then Godwin is not jittery.\n(∃x (Several(x) ∨ ¬Sour(x))) → (¬Stubborn(brandi)) ::: If there is someone who is either several or not sour, then Brandi is not stubborn.\n(∃x (¬Sour(x))) → ((¬Stubborn(owen) ∧ ¬Several(conrad))) ::: If there is at least one people who is not sour, then Owen is not stubborn and Conrad is not several.\n(∀x (Several(x) ∧ ¬Sour(x))) → (∀x (Stubborn(x))) ::: If someone who is several is also not sour, then he is stubborn.\n(∃x (Sour(x) ∨ Jittery(x))) → ((¬Several(brandi) ∧ Stubborn(conrad))) ::: If there is at least one people who is either sour or jittery, then Brandi is not several and Conrad is stubborn.\n(¬Fearless(rolf)) → (¬Jittery(conrad)) ::: If Rolf is not fearless, then Conrad is not jittery.\n((¬Precious(godwin))) → ((Jittery(godwin) ∧ ¬Fearless(owen))) ::: It can be concluded that Godwin is jittery and Owen is not fearless once knowing that Godwin is not precious.\n((¬Jittery(godwin) ∧ ¬Several(sigmund))) → ((Precious(sigmund))) ::: It can be concluded that Sigmund is precious once knowing that Godwin is not jittery and Sigmund is not several.\n((Several(rolf) ∨ Fearless(brandi))) → ((¬Precious(brandi))) ::: If Rolf is several or Brandi is fearless, then Brandi is not precious.\n((¬Jittery(godwin) ∧ Several(conrad))) → ((Sour(owen))) ::: If Godwin is not jittery and Conrad is several, then Owen is sour.\n(∀x (Precious(x))) → (∀x (¬Several(x))) ::: Someone who is precious is always not several.\n((¬Fearless(godwin))) ↔ ((Several(brandi))) ::: If Godwin is not fearless, then Brandi is several, and vice versa.\n",
                "First-Order-Logic Question": "Fearless(owen) ::: Owen is fearless."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "¬Several(rolf) ::: Rolf is not several.\n¬Precious(sigmund) ::: Sigmund is not precious.\nPrecious(godwin) ::: Godwin is precious.\nFearless(sigmund) ::: Sigmund is fearless.\nPrecious(rolf) ::: Rolf is precious.\n¬Stubborn(rose) ::: Rose is not stubborn.\nJittery(conrad) ::: Conrad is jittery.\n¬Fearless(brandi) ::: Brandi is not fearless.\n¬Sour(brandi) ::: Brandi is not sour.\nJittery(rolf) ::: Rolf is jittery.\nStubborn(owen) ::: Owen is stubborn.\n¬Fearless(godwin) ::: Godwin is not fearless.\n¬∃x(¬(¬(Several(x)))) ::: If there is nobody who is not, then Godwin is not jittery.\n(∃x (Several(x) ∨ ¬Sour(x))) → (¬Stubborn(brandi)) ::: If there is someone who is either several or not sour, then Brandi is not stubborn.\n(∃x (¬Sour(x))) → ((¬Stubborn(owen) ∧ ¬Several(conrad))) ::: If there is at least one people who is not sour, then Owen is not stubborn and Conrad is not several.\n(∀x (Several(x) ∧ ¬Sour(x))) → (∀x (Stubborn(x))) ::: If someone who is several is also not sour, then he is stubborn.\n(∃x (Sour(x) ∨ Jittery(x))) → ((¬Several(brandi) ∧ Stubborn(conrad))) ::: If there is at least one people who is either sour or jittery, then Brandi is not several and Conrad is stubborn.\n(¬Fearless(rolf)) → (¬Jittery(conrad)) ::: If Rolf is not fearless, then Conrad is not jittery.\n((¬Precious(godwin))) → ((Jittery(godwin) ∧ ¬Fearless(owen))) ::: It can be concluded that Godwin is jittery and Owen is not fearless once knowing that Godwin is not precious.\n((¬Jittery(godwin) ∧ ¬Several(sigmund))) → ((Precious(sigmund))) ::: It can be concluded that Sigmund is precious once knowing that Godwin is not jittery and Sigmund is not several.\n((Several(rolf) ∨ Fearless(brandi))) → ((¬Precious(brandi))) ::: If Rolf is several or Brandi is fearless, then Brandi is not precious.\n((¬Jittery(godwin) ∧ Several(conrad))) → ((Sour(owen))) ::: If Godwin is not jittery and Conrad is several, then Owen is sour.\n(∀x (Precious(x))) → (∀x (¬Several(x))) ::: Someone who is precious is always not several.\n((¬Fearless(godwin))) ↔ ((Several(brandi))) ::: If Godwin is not fearless, then Brandi is several, and vice versa.\n",
                "First-Order-Logic Question": "Fearless(owen) ::: Owen is fearless."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬x)) → (¬Jittery(godwin)) ::: If there is nobody who is not, then Godwin is not jittery.",
                    "gram": "¬∃x(¬(¬(Several(x)))) ::: If there is nobody who is not, then Godwin is not jittery."
                }
            ],
            "answer": "C",
            "grammar_answer": "A",
            "backup_answer": "C"
        },
        {
            "id": 1206,
            "raw_prog": {
                "First-Order-Logic Rules": "¬Several(rolf) ::: Rolf is not several.\n¬Precious(sigmund) ::: Sigmund is not precious.\nPrecious(godwin) ::: Godwin is precious.\nFearless(sigmund) ::: Sigmund is fearless.\nPrecious(rolf) ::: Rolf is precious.\n¬Stubborn(rose) ::: Rose is not stubborn.\nJittery(conrad) ::: Conrad is jittery.\n¬Fearless(brandi) ::: Brandi is not fearless.\n¬Sour(brandi) ::: Brandi is not sour.\nJittery(rolf) ::: Rolf is jittery.\nStubborn(owen) ::: Owen is stubborn.\n¬Fearless(godwin) ::: Godwin is not fearless.\n(¬∃x (¬x)) → (¬Jittery(godwin)) ::: If there is nobody who is not, then Godwin is not jittery.\n(∃x (Several(x) ∨ ¬Sour(x))) → (¬Stubborn(brandi)) ::: If there is someone who is either several or not sour, then Brandi is not stubborn.\n(∃x (¬Sour(x))) → ((¬Stubborn(owen) ∧ ¬Several(conrad))) ::: If there is at least one people who is not sour, then Owen is not stubborn and Conrad is not several.\n(∀x (Several(x) ∧ ¬Sour(x))) → (∀x (Stubborn(x))) ::: If someone who is several is also not sour, then he is stubborn.\n(∃x (Sour(x) ∨ Jittery(x))) → ((¬Several(brandi) ∧ Stubborn(conrad))) ::: If there is at least one people who is either sour or jittery, then Brandi is not several and Conrad is stubborn.\n(¬Fearless(rolf)) → (¬Jittery(conrad)) ::: If Rolf is not fearless, then Conrad is not jittery.\n(¬Precious(godwin)) → ((Jittery(godwin) ∧ ¬Fearless(owen))) ::: It can be concluded that Godwin is jittery and Owen is not fearless once knowing that Godwin is not precious.\n((¬Jittery(godwin) ∧ ¬Several(sigmund))) → (Precious(sigmund)) ::: It can be concluded that Sigmund is precious once knowing that Godwin is not jittery and Sigmund is not several.\n((Several(rolf) ∨ Fearless(brandi))) → (¬Precious(brandi)) ::: If Rolf is several or Brandi is fearless, then Brandi is not precious.\n((¬Jittery(godwin) ∧ Several(conrad))) → (Sour(owen)) ::: If Godwin is not jittery and Conrad is several, then Owen is sour.\n(∀x (Precious(x))) → (∀x (¬Several(x))) ::: Someone who is precious is always not several.\n(¬Fearless(godwin)) ↔ (Several(brandi)) ::: If Godwin is not fearless, then Brandi is several, and vice versa.\n",
                "First-Order-Logic Question": "Fearless(sigmund) ::: Sigmund is fearless."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "¬Several(rolf) ::: Rolf is not several.\n¬Precious(sigmund) ::: Sigmund is not precious.\nPrecious(godwin) ::: Godwin is precious.\nFearless(sigmund) ::: Sigmund is fearless.\nPrecious(rolf) ::: Rolf is precious.\n¬Stubborn(rose) ::: Rose is not stubborn.\nJittery(conrad) ::: Conrad is jittery.\n¬Fearless(brandi) ::: Brandi is not fearless.\n¬Sour(brandi) ::: Brandi is not sour.\nJittery(rolf) ::: Rolf is jittery.\nStubborn(owen) ::: Owen is stubborn.\n¬Fearless(godwin) ::: Godwin is not fearless.\n¬∃x(¬(¬(Several(x)))) ::: If there is nobody who is not, then Godwin is not jittery.\n(∃x (Several(x) ∨ ¬Sour(x))) → (¬Stubborn(brandi)) ::: If there is someone who is either several or not sour, then Brandi is not stubborn.\n(∃x (¬Sour(x))) → ((¬Stubborn(owen) ∧ ¬Several(conrad))) ::: If there is at least one people who is not sour, then Owen is not stubborn and Conrad is not several.\n(∀x (Several(x) ∧ ¬Sour(x))) → (∀x (Stubborn(x))) ::: If someone who is several is also not sour, then he is stubborn.\n(∃x (Sour(x) ∨ Jittery(x))) → ((¬Several(brandi) ∧ Stubborn(conrad))) ::: If there is at least one people who is either sour or jittery, then Brandi is not several and Conrad is stubborn.\n(¬Fearless(rolf)) → (¬Jittery(conrad)) ::: If Rolf is not fearless, then Conrad is not jittery.\n(¬Precious(godwin)) → ((Jittery(godwin) ∧ ¬Fearless(owen))) ::: It can be concluded that Godwin is jittery and Owen is not fearless once knowing that Godwin is not precious.\n((¬Jittery(godwin) ∧ ¬Several(sigmund))) → (Precious(sigmund)) ::: It can be concluded that Sigmund is precious once knowing that Godwin is not jittery and Sigmund is not several.\n((Several(rolf) ∨ Fearless(brandi))) → (¬Precious(brandi)) ::: If Rolf is several or Brandi is fearless, then Brandi is not precious.\n((¬Jittery(godwin) ∧ Several(conrad))) → (Sour(owen)) ::: If Godwin is not jittery and Conrad is several, then Owen is sour.\n(∀x (Precious(x))) → (∀x (¬Several(x))) ::: Someone who is precious is always not several.\n(¬Fearless(godwin)) ↔ (Several(brandi)) ::: If Godwin is not fearless, then Brandi is several, and vice versa.\n",
                "First-Order-Logic Question": "Fearless(sigmund) ::: Sigmund is fearless."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬x)) → (¬Jittery(godwin)) ::: If there is nobody who is not, then Godwin is not jittery.",
                    "gram": "¬∃x(¬(¬(Several(x)))) ::: If there is nobody who is not, then Godwin is not jittery."
                }
            ],
            "answer": "A",
            "grammar_answer": "A",
            "backup_answer": "A"
        },
        {
            "id": 1207,
            "raw_prog": {
                "First-Order-Logic Rules": "¬Several(rolf) ::: Rolf is not several.\n¬Precious(sigmund) ::: Sigmund is not precious.\nPrecious(godwin) ::: Godwin is precious.\nFearless(sigmund) ::: Sigmund is fearless.\nPrecious(rolf) ::: Rolf is precious.\n¬Stubborn(rose) ::: Rose is not stubborn.\nJittery(conrad) ::: Conrad is jittery.\n¬Fearless(brandi) ::: Brandi is not fearless.\n¬Sour(brandi) ::: Brandi is not sour.\nJittery(rolf) ::: Rolf is jittery.\nStubborn(owen) ::: Owen is stubborn.\n¬Fearless(godwin) ::: Godwin is not fearless.\n(¬∃x (¬x)) → (¬Jittery(godwin)) ::: If there is nobody who is not, then Godwin is not jittery.\n(∃x (Several(x) ∨ ¬Sour(x))) → (¬Stubborn(brandi)) ::: If there is someone who is either several or not sour, then Brandi is not stubborn.\n(∃x (¬Sour(x))) → (¬Stubborn(owen) ∧ ¬Several(conrad)) ::: If there is at least one people who is not sour, then Owen is not stubborn and Conrad is not several.\n(∀x (Several(x) → ¬Sour(x))) → (∀x (Stubborn(x))) ::: If someone who is several is also not sour, then he is stubborn.\n(∃x (Sour(x) ∨ Jittery(x))) → (¬Several(brandi) ∧ Stubborn(conrad)) ::: If there is at least one people who is either sour or jittery, then Brandi is not several and Conrad is stubborn.\n(¬Fearless(rolf)) → (¬Jittery(conrad)) ::: If Rolf is not fearless, then Conrad is not jittery.\n(¬Precious(godwin)) → (Jittery(godwin) ∧ ¬Fearless(owen)) ::: It can be concluded that Godwin is jittery and Owen is not fearless once knowing that Godwin is not precious.\n(¬Jittery(godwin) ∧ ¬Several(sigmund)) → (Precious(sigmund)) ::: It can be concluded that Sigmund is precious once knowing that Godwin is not jittery and Sigmund is not several.\n(Several(rolf) ∨ Fearless(brandi)) → (¬Precious(brandi)) ::: If Rolf is several or Brandi is fearless, then Brandi is not precious.\n(¬Jittery(godwin) ∧ Several(conrad)) → (Sour(owen)) ::: If Godwin is not jittery and Conrad is several, then Owen is sour.\n(∀x (Precious(x))) → (∀x (¬Several(x))) ::: Someone who is precious is always not several.\n(¬Fearless(godwin)) ↔ (Several(brandi)) ::: If Godwin is not fearless, then Brandi is several, and vice versa.\n",
                "First-Order-Logic Question": "Precious(conrad) ::: Conrad is precious."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "¬Several(rolf) ::: Rolf is not several.\n¬Precious(sigmund) ::: Sigmund is not precious.\nPrecious(godwin) ::: Godwin is precious.\nFearless(sigmund) ::: Sigmund is fearless.\nPrecious(rolf) ::: Rolf is precious.\n¬Stubborn(rose) ::: Rose is not stubborn.\nJittery(conrad) ::: Conrad is jittery.\n¬Fearless(brandi) ::: Brandi is not fearless.\n¬Sour(brandi) ::: Brandi is not sour.\nJittery(rolf) ::: Rolf is jittery.\nStubborn(owen) ::: Owen is stubborn.\n¬Fearless(godwin) ::: Godwin is not fearless.\n¬∃x(¬(¬(Several(x)))) ::: If there is nobody who is not, then Godwin is not jittery.\n(∃x (Several(x) ∨ ¬Sour(x))) → (¬Stubborn(brandi)) ::: If there is someone who is either several or not sour, then Brandi is not stubborn.\n(∃x (¬Sour(x))) → (¬Stubborn(owen) ∧ ¬Several(conrad)) ::: If there is at least one people who is not sour, then Owen is not stubborn and Conrad is not several.\n(∀x (Several(x) → ¬Sour(x))) → (∀x (Stubborn(x))) ::: If someone who is several is also not sour, then he is stubborn.\n(∃x (Sour(x) ∨ Jittery(x))) → (¬Several(brandi) ∧ Stubborn(conrad)) ::: If there is at least one people who is either sour or jittery, then Brandi is not several and Conrad is stubborn.\n(¬Fearless(rolf)) → (¬Jittery(conrad)) ::: If Rolf is not fearless, then Conrad is not jittery.\n(¬Precious(godwin)) → (Jittery(godwin) ∧ ¬Fearless(owen)) ::: It can be concluded that Godwin is jittery and Owen is not fearless once knowing that Godwin is not precious.\n(¬Jittery(godwin) ∧ ¬Several(sigmund)) → (Precious(sigmund)) ::: It can be concluded that Sigmund is precious once knowing that Godwin is not jittery and Sigmund is not several.\n(Several(rolf) ∨ Fearless(brandi)) → (¬Precious(brandi)) ::: If Rolf is several or Brandi is fearless, then Brandi is not precious.\n(¬Jittery(godwin) ∧ Several(conrad)) → (Sour(owen)) ::: If Godwin is not jittery and Conrad is several, then Owen is sour.\n(∀x (Precious(x))) → (∀x (¬Several(x))) ::: Someone who is precious is always not several.\n(¬Fearless(godwin)) ↔ (Several(brandi)) ::: If Godwin is not fearless, then Brandi is several, and vice versa.\n",
                "First-Order-Logic Question": "Precious(conrad) ::: Conrad is precious."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬x)) → (¬Jittery(godwin)) ::: If there is nobody who is not, then Godwin is not jittery.",
                    "gram": "¬∃x(¬(¬(Several(x)))) ::: If there is nobody who is not, then Godwin is not jittery."
                }
            ],
            "answer": "C",
            "grammar_answer": "A",
            "backup_answer": "C"
        },
        {
            "id": 1208,
            "raw_prog": {
                "First-Order-Logic Rules": "¬Several(rolf) ::: Rolf is not several.\n¬Precious(sigmund) ::: Sigmund is not precious.\nPrecious(godwin) ::: Godwin is precious.\nFearless(sigmund) ::: Sigmund is fearless.\nPrecious(rolf) ::: Rolf is precious.\n¬Stubborn(rose) ::: Rose is not stubborn.\nJittery(conrad) ::: Conrad is jittery.\n¬Fearless(brandi) ::: Brandi is not fearless.\n¬Sour(brandi) ::: Brandi is not sour.\nJittery(rolf) ::: Rolf is jittery.\nStubborn(owen) ::: Owen is stubborn.\n¬Fearless(godwin) ::: Godwin is not fearless.\n(¬∃x (¬x)) → (¬Jittery(godwin)) ::: If there is nobody who is not, then Godwin is not jittery.\n(∃x (Several(x) ∨ ¬Sour(x))) → (¬Stubborn(brandi)) ::: If there is someone who is either several or not sour, then Brandi is not stubborn.\n(∃x (¬Sour(x))) → ((¬Stubborn(owen) ∧ ¬Several(conrad))) ::: If there is at least one people who is not sour, then Owen is not stubborn and Conrad is not several.\n(∀x (Several(x) ∧ ¬Sour(x))) → (∀x (Stubborn(x))) ::: If someone who is several is also not sour, then he is stubborn.\n(∃x (Sour(x) ∨ Jittery(x))) → ((¬Several(brandi) ∧ Stubborn(conrad))) ::: If there is at least one people who is either sour or jittery, then Brandi is not several and Conrad is stubborn.\n(¬Fearless(rolf)) → (¬Jittery(conrad)) ::: If Rolf is not fearless, then Conrad is not jittery.\n((¬Precious(godwin))) → ((Jittery(godwin) ∧ ¬Fearless(owen))) ::: It can be concluded that Godwin is jittery and Owen is not fearless once knowing that Godwin is not precious.\n((¬Jittery(godwin) ∧ ¬Several(sigmund))) → (Precious(sigmund)) ::: It can be concluded that Sigmund is precious once knowing that Godwin is not jittery and Sigmund is not several.\n((Several(rolf) ∨ Fearless(brandi))) → (¬Precious(brandi)) ::: If Rolf is several or Brandi is fearless, then Brandi is not precious.\n((¬Jittery(godwin) ∧ Several(conrad))) → (Sour(owen)) ::: If Godwin is not jittery and Conrad is several, then Owen is sour.\n(∀x (Precious(x))) → (∀x (¬Several(x))) ::: Someone who is precious is always not several.\n((¬Fearless(godwin))) ↔ ((Several(brandi))) ::: If Godwin is not fearless, then Brandi is several, and vice versa.\n",
                "First-Order-Logic Question": "Several(rolf) ::: Rolf is several."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "¬Several(rolf) ::: Rolf is not several.\n¬Precious(sigmund) ::: Sigmund is not precious.\nPrecious(godwin) ::: Godwin is precious.\nFearless(sigmund) ::: Sigmund is fearless.\nPrecious(rolf) ::: Rolf is precious.\n¬Stubborn(rose) ::: Rose is not stubborn.\nJittery(conrad) ::: Conrad is jittery.\n¬Fearless(brandi) ::: Brandi is not fearless.\n¬Sour(brandi) ::: Brandi is not sour.\nJittery(rolf) ::: Rolf is jittery.\nStubborn(owen) ::: Owen is stubborn.\n¬Fearless(godwin) ::: Godwin is not fearless.\n¬∃x(¬(¬(Several(x)))) ::: If there is nobody who is not, then Godwin is not jittery.\n(∃x (Several(x) ∨ ¬Sour(x))) → (¬Stubborn(brandi)) ::: If there is someone who is either several or not sour, then Brandi is not stubborn.\n(∃x (¬Sour(x))) → ((¬Stubborn(owen) ∧ ¬Several(conrad))) ::: If there is at least one people who is not sour, then Owen is not stubborn and Conrad is not several.\n(∀x (Several(x) ∧ ¬Sour(x))) → (∀x (Stubborn(x))) ::: If someone who is several is also not sour, then he is stubborn.\n(∃x (Sour(x) ∨ Jittery(x))) → ((¬Several(brandi) ∧ Stubborn(conrad))) ::: If there is at least one people who is either sour or jittery, then Brandi is not several and Conrad is stubborn.\n(¬Fearless(rolf)) → (¬Jittery(conrad)) ::: If Rolf is not fearless, then Conrad is not jittery.\n((¬Precious(godwin))) → ((Jittery(godwin) ∧ ¬Fearless(owen))) ::: It can be concluded that Godwin is jittery and Owen is not fearless once knowing that Godwin is not precious.\n((¬Jittery(godwin) ∧ ¬Several(sigmund))) → (Precious(sigmund)) ::: It can be concluded that Sigmund is precious once knowing that Godwin is not jittery and Sigmund is not several.\n((Several(rolf) ∨ Fearless(brandi))) → (¬Precious(brandi)) ::: If Rolf is several or Brandi is fearless, then Brandi is not precious.\n((¬Jittery(godwin) ∧ Several(conrad))) → (Sour(owen)) ::: If Godwin is not jittery and Conrad is several, then Owen is sour.\n(∀x (Precious(x))) → (∀x (¬Several(x))) ::: Someone who is precious is always not several.\n((¬Fearless(godwin))) ↔ ((Several(brandi))) ::: If Godwin is not fearless, then Brandi is several, and vice versa.\n",
                "First-Order-Logic Question": "Several(rolf) ::: Rolf is several."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬x)) → (¬Jittery(godwin)) ::: If there is nobody who is not, then Godwin is not jittery.",
                    "gram": "¬∃x(¬(¬(Several(x)))) ::: If there is nobody who is not, then Godwin is not jittery."
                }
            ],
            "answer": "B",
            "grammar_answer": "A",
            "backup_answer": "B"
        },
        {
            "id": 1209,
            "raw_prog": {
                "First-Order-Logic Rules": "¬Several(rolf) ::: Rolf is not several.\n¬Precious(sigmund) ::: Sigmund is not precious.\nPrecious(godwin) ::: Godwin is precious.\nFearless(sigmund) ::: Sigmund is fearless.\nPrecious(rolf) ::: Rolf is precious.\n¬Stubborn(rose) ::: Rose is not stubborn.\nJittery(conrad) ::: Conrad is jittery.\n¬Fearless(brandi) ::: Brandi is not fearless.\n¬Sour(brandi) ::: Brandi is not sour.\nJittery(rolf) ::: Rolf is jittery.\nStubborn(owen) ::: Owen is stubborn.\n¬Fearless(godwin) ::: Godwin is not fearless.\n(¬∃x (¬x)) → (¬Jittery(godwin)) ::: If there is nobody who is not, then Godwin is not jittery.\n(∃x (Several(x) ∨ ¬Sour(x))) → (¬Stubborn(brandi)) ::: If there is someone who is either several or not sour, then Brandi is not stubborn.\n(∃x (¬Sour(x))) → ((¬Stubborn(owen) ∧ ¬Several(conrad))) ::: If there is at least one people who is not sour, then Owen is not stubborn and Conrad is not several.\n(∀x (Several(x) ∧ ¬Sour(x))) → (∀x (Stubborn(x))) ::: If someone who is several is also not sour, then he is stubborn.\n(∃x (Sour(x) ∨ Jittery(x))) → ((¬Several(brandi) ∧ Stubborn(conrad))) ::: If there is at least one people who is either sour or jittery, then Brandi is not several and Conrad is stubborn.\n(¬Fearless(rolf)) → (¬Jittery(conrad)) ::: If Rolf is not fearless, then Conrad is not jittery.\n(¬Precious(godwin)) → ((Jittery(godwin) ∧ ¬Fearless(owen))) ::: It can be concluded that Godwin is jittery and Owen is not fearless once knowing that Godwin is not precious.\n((¬Jittery(godwin) ∧ ¬Several(sigmund))) → (Precious(sigmund)) ::: It can be concluded that Sigmund is precious once knowing that Godwin is not jittery and Sigmund is not several.\n((Several(rolf) ∨ Fearless(brandi))) → (¬Precious(brandi)) ::: If Rolf is several or Brandi is fearless, then Brandi is not precious.\n((¬Jittery(godwin) ∧ Several(conrad))) → (Sour(owen)) ::: If Godwin is not jittery and Conrad is several, then Owen is sour.\n(∀x (Precious(x))) → (∀x (¬Several(x))) ::: Someone who is precious is always not several.\n(¬Fearless(godwin)) ↔ (Several(brandi)) ::: If Godwin is not fearless, then Brandi is several, and vice versa.\n",
                "First-Order-Logic Question": "¬Sour(brandi) ::: Brandi is not sour."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "¬Several(rolf) ::: Rolf is not several.\n¬Precious(sigmund) ::: Sigmund is not precious.\nPrecious(godwin) ::: Godwin is precious.\nFearless(sigmund) ::: Sigmund is fearless.\nPrecious(rolf) ::: Rolf is precious.\n¬Stubborn(rose) ::: Rose is not stubborn.\nJittery(conrad) ::: Conrad is jittery.\n¬Fearless(brandi) ::: Brandi is not fearless.\n¬Sour(brandi) ::: Brandi is not sour.\nJittery(rolf) ::: Rolf is jittery.\nStubborn(owen) ::: Owen is stubborn.\n¬Fearless(godwin) ::: Godwin is not fearless.\n¬∃x(¬(¬(Several(x)))) ::: If there is nobody who is not, then Godwin is not jittery.\n(∃x (Several(x) ∨ ¬Sour(x))) → (¬Stubborn(brandi)) ::: If there is someone who is either several or not sour, then Brandi is not stubborn.\n(∃x (¬Sour(x))) → ((¬Stubborn(owen) ∧ ¬Several(conrad))) ::: If there is at least one people who is not sour, then Owen is not stubborn and Conrad is not several.\n(∀x (Several(x) ∧ ¬Sour(x))) → (∀x (Stubborn(x))) ::: If someone who is several is also not sour, then he is stubborn.\n(∃x (Sour(x) ∨ Jittery(x))) → ((¬Several(brandi) ∧ Stubborn(conrad))) ::: If there is at least one people who is either sour or jittery, then Brandi is not several and Conrad is stubborn.\n(¬Fearless(rolf)) → (¬Jittery(conrad)) ::: If Rolf is not fearless, then Conrad is not jittery.\n(¬Precious(godwin)) → ((Jittery(godwin) ∧ ¬Fearless(owen))) ::: It can be concluded that Godwin is jittery and Owen is not fearless once knowing that Godwin is not precious.\n((¬Jittery(godwin) ∧ ¬Several(sigmund))) → (Precious(sigmund)) ::: It can be concluded that Sigmund is precious once knowing that Godwin is not jittery and Sigmund is not several.\n((Several(rolf) ∨ Fearless(brandi))) → (¬Precious(brandi)) ::: If Rolf is several or Brandi is fearless, then Brandi is not precious.\n((¬Jittery(godwin) ∧ Several(conrad))) → (Sour(owen)) ::: If Godwin is not jittery and Conrad is several, then Owen is sour.\n(∀x (Precious(x))) → (∀x (¬Several(x))) ::: Someone who is precious is always not several.\n(¬Fearless(godwin)) ↔ (Several(brandi)) ::: If Godwin is not fearless, then Brandi is several, and vice versa.\n",
                "First-Order-Logic Question": "¬Sour(brandi) ::: Brandi is not sour."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬x)) → (¬Jittery(godwin)) ::: If there is nobody who is not, then Godwin is not jittery.",
                    "gram": "¬∃x(¬(¬(Several(x)))) ::: If there is nobody who is not, then Godwin is not jittery."
                }
            ],
            "answer": "A",
            "grammar_answer": "A",
            "backup_answer": "A"
        },
        {
            "id": 1210,
            "raw_prog": {
                "First-Order-Logic Rules": "¬Several(rolf) ::: Rolf is not several.\n¬Precious(sigmund) ::: Sigmund is not precious.\nPrecious(godwin) ::: Godwin is precious.\nFearless(sigmund) ::: Sigmund is fearless.\nPrecious(rolf) ::: Rolf is precious.\n¬Stubborn(rose) ::: Rose is not stubborn.\nJittery(conrad) ::: Conrad is jittery.\n¬Fearless(brandi) ::: Brandi is not fearless.\n¬Sour(brandi) ::: Brandi is not sour.\nJittery(rolf) ::: Rolf is jittery.\nStubborn(owen) ::: Owen is stubborn.\n¬Fearless(godwin) ::: Godwin is not fearless.\n(¬∃x (¬x)) → (¬Jittery(godwin)) ::: If there is nobody who is not, then Godwin is not jittery.\n(∃x (Several(x) ∨ ¬Sour(x))) → (¬Stubborn(brandi)) ::: If there is someone who is either several or not sour, then Brandi is not stubborn.\n(∃x (¬Sour(x))) → ((¬Stubborn(owen) ∧ ¬Several(conrad))) ::: If there is at least one people who is not sour, then Owen is not stubborn and Conrad is not several.\n(∀x (Several(x) ∧ ¬Sour(x))) → (∀x (Stubborn(x))) ::: If someone who is several is also not sour, then he is stubborn.\n(∃x (Sour(x) ∨ Jittery(x))) → ((¬Several(brandi) ∧ Stubborn(conrad))) ::: If there is at least one people who is either sour or jittery, then Brandi is not several and Conrad is stubborn.\n(¬Fearless(rolf)) → (¬Jittery(conrad)) ::: If Rolf is not fearless, then Conrad is not jittery.\n(¬Precious(godwin)) → ((Jittery(godwin) ∧ ¬Fearless(owen))) ::: It can be concluded that Godwin is jittery and Owen is not fearless once knowing that Godwin is not precious.\n((¬Jittery(godwin) ∧ ¬Several(sigmund))) → (Precious(sigmund)) ::: It can be concluded that Sigmund is precious once knowing that Godwin is not jittery and Sigmund is not several.\n(Several(rolf) ∨ Fearless(brandi)) → (¬Precious(brandi)) ::: If Rolf is several or Brandi is fearless, then Brandi is not precious.\n((¬Jittery(godwin) ∧ Several(conrad))) → (Sour(owen)) ::: If Godwin is not jittery and Conrad is several, then Owen is sour.\n(∀x (Precious(x))) → (∀x (¬Several(x))) ::: Someone who is precious is always not several.\n(¬Fearless(godwin)) ↔ (Several(brandi)) ::: If Godwin is not fearless, then Brandi is several, and vice versa.\n",
                "First-Order-Logic Question": "¬Precious(rolf) ::: Rolf is not precious."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "¬Several(rolf) ::: Rolf is not several.\n¬Precious(sigmund) ::: Sigmund is not precious.\nPrecious(godwin) ::: Godwin is precious.\nFearless(sigmund) ::: Sigmund is fearless.\nPrecious(rolf) ::: Rolf is precious.\n¬Stubborn(rose) ::: Rose is not stubborn.\nJittery(conrad) ::: Conrad is jittery.\n¬Fearless(brandi) ::: Brandi is not fearless.\n¬Sour(brandi) ::: Brandi is not sour.\nJittery(rolf) ::: Rolf is jittery.\nStubborn(owen) ::: Owen is stubborn.\n¬Fearless(godwin) ::: Godwin is not fearless.\n¬∃x(¬(¬(Several(x)))) ::: If there is nobody who is not, then Godwin is not jittery.\n(∃x (Several(x) ∨ ¬Sour(x))) → (¬Stubborn(brandi)) ::: If there is someone who is either several or not sour, then Brandi is not stubborn.\n(∃x (¬Sour(x))) → ((¬Stubborn(owen) ∧ ¬Several(conrad))) ::: If there is at least one people who is not sour, then Owen is not stubborn and Conrad is not several.\n(∀x (Several(x) ∧ ¬Sour(x))) → (∀x (Stubborn(x))) ::: If someone who is several is also not sour, then he is stubborn.\n(∃x (Sour(x) ∨ Jittery(x))) → ((¬Several(brandi) ∧ Stubborn(conrad))) ::: If there is at least one people who is either sour or jittery, then Brandi is not several and Conrad is stubborn.\n(¬Fearless(rolf)) → (¬Jittery(conrad)) ::: If Rolf is not fearless, then Conrad is not jittery.\n(¬Precious(godwin)) → ((Jittery(godwin) ∧ ¬Fearless(owen))) ::: It can be concluded that Godwin is jittery and Owen is not fearless once knowing that Godwin is not precious.\n((¬Jittery(godwin) ∧ ¬Several(sigmund))) → (Precious(sigmund)) ::: It can be concluded that Sigmund is precious once knowing that Godwin is not jittery and Sigmund is not several.\n(Several(rolf) ∨ Fearless(brandi)) → (¬Precious(brandi)) ::: If Rolf is several or Brandi is fearless, then Brandi is not precious.\n((¬Jittery(godwin) ∧ Several(conrad))) → (Sour(owen)) ::: If Godwin is not jittery and Conrad is several, then Owen is sour.\n(∀x (Precious(x))) → (∀x (¬Several(x))) ::: Someone who is precious is always not several.\n(¬Fearless(godwin)) ↔ (Several(brandi)) ::: If Godwin is not fearless, then Brandi is several, and vice versa.\n",
                "First-Order-Logic Question": "¬Precious(rolf) ::: Rolf is not precious."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬x)) → (¬Jittery(godwin)) ::: If there is nobody who is not, then Godwin is not jittery.",
                    "gram": "¬∃x(¬(¬(Several(x)))) ::: If there is nobody who is not, then Godwin is not jittery."
                }
            ],
            "answer": "B",
            "grammar_answer": "A",
            "backup_answer": "B"
        },
        {
            "id": 1211,
            "raw_prog": {
                "First-Order-Logic Rules": "¬Several(rolf) ::: Rolf is not several.\n¬Precious(sigmund) ::: Sigmund is not precious.\nPrecious(godwin) ::: Godwin is precious.\nFearless(sigmund) ::: Sigmund is fearless.\nPrecious(rolf) ::: Rolf is precious.\n¬Stubborn(rose) ::: Rose is not stubborn.\nJittery(conrad) ::: Conrad is jittery.\n¬Fearless(brandi) ::: Brandi is not fearless.\n¬Sour(brandi) ::: Brandi is not sour.\nJittery(rolf) ::: Rolf is jittery.\nStubborn(owen) ::: Owen is stubborn.\n¬Fearless(godwin) ::: Godwin is not fearless.\n(¬∃x (¬x)) → (¬Jittery(godwin)) ::: If there is nobody who is not, then Godwin is not jittery.\n(∃x (Several(x) ∨ ¬Sour(x))) → (¬Stubborn(brandi)) ::: If there is someone who is either several or not sour, then Brandi is not stubborn.\n(∃x (¬Sour(x))) → ((¬Stubborn(owen) ∧ ¬Several(conrad))) ::: If there is at least one people who is not sour, then Owen is not stubborn and Conrad is not several.\n(∀x (Several(x) ∧ ¬Sour(x))) → (∀x (Stubborn(x))) ::: If someone who is several is also not sour, then he is stubborn.\n(∃x (Sour(x) ∨ Jittery(x))) → ((¬Several(brandi) ∧ Stubborn(conrad))) ::: If there is at least one people who is either sour or jittery, then Brandi is not several and Conrad is stubborn.\n(¬Fearless(rolf)) → (¬Jittery(conrad)) ::: If Rolf is not fearless, then Conrad is not jittery.\n(¬Precious(godwin)) → ((Jittery(godwin) ∧ ¬Fearless(owen))) ::: It can be concluded that Godwin is jittery and Owen is not fearless once knowing that Godwin is not precious.\n((¬Jittery(godwin) ∧ ¬Several(sigmund))) → (Precious(sigmund)) ::: It can be concluded that Sigmund is precious once knowing that Godwin is not jittery and Sigmund is not several.\n((Several(rolf) ∨ Fearless(brandi))) → (¬Precious(brandi)) ::: If Rolf is several or Brandi is fearless, then Brandi is not precious.\n((¬Jittery(godwin) ∧ Several(conrad))) → (Sour(owen)) ::: If Godwin is not jittery and Conrad is several, then Owen is sour.\n(∀x (Precious(x))) → (∀x (¬Several(x))) ::: Someone who is precious is always not several.\n(¬Fearless(godwin)) ↔ (Several(brandi)) ::: If Godwin is not fearless, then Brandi is several, and vice versa.\n",
                "First-Order-Logic Question": "¬Fearless(godwin) ::: Godwin is not fearless."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "¬Several(rolf) ::: Rolf is not several.\n¬Precious(sigmund) ::: Sigmund is not precious.\nPrecious(godwin) ::: Godwin is precious.\nFearless(sigmund) ::: Sigmund is fearless.\nPrecious(rolf) ::: Rolf is precious.\n¬Stubborn(rose) ::: Rose is not stubborn.\nJittery(conrad) ::: Conrad is jittery.\n¬Fearless(brandi) ::: Brandi is not fearless.\n¬Sour(brandi) ::: Brandi is not sour.\nJittery(rolf) ::: Rolf is jittery.\nStubborn(owen) ::: Owen is stubborn.\n¬Fearless(godwin) ::: Godwin is not fearless.\n¬∃x(¬(¬(Several(x)))) ::: If there is nobody who is not, then Godwin is not jittery.\n(∃x (Several(x) ∨ ¬Sour(x))) → (¬Stubborn(brandi)) ::: If there is someone who is either several or not sour, then Brandi is not stubborn.\n(∃x (¬Sour(x))) → ((¬Stubborn(owen) ∧ ¬Several(conrad))) ::: If there is at least one people who is not sour, then Owen is not stubborn and Conrad is not several.\n(∀x (Several(x) ∧ ¬Sour(x))) → (∀x (Stubborn(x))) ::: If someone who is several is also not sour, then he is stubborn.\n(∃x (Sour(x) ∨ Jittery(x))) → ((¬Several(brandi) ∧ Stubborn(conrad))) ::: If there is at least one people who is either sour or jittery, then Brandi is not several and Conrad is stubborn.\n(¬Fearless(rolf)) → (¬Jittery(conrad)) ::: If Rolf is not fearless, then Conrad is not jittery.\n(¬Precious(godwin)) → ((Jittery(godwin) ∧ ¬Fearless(owen))) ::: It can be concluded that Godwin is jittery and Owen is not fearless once knowing that Godwin is not precious.\n((¬Jittery(godwin) ∧ ¬Several(sigmund))) → (Precious(sigmund)) ::: It can be concluded that Sigmund is precious once knowing that Godwin is not jittery and Sigmund is not several.\n((Several(rolf) ∨ Fearless(brandi))) → (¬Precious(brandi)) ::: If Rolf is several or Brandi is fearless, then Brandi is not precious.\n((¬Jittery(godwin) ∧ Several(conrad))) → (Sour(owen)) ::: If Godwin is not jittery and Conrad is several, then Owen is sour.\n(∀x (Precious(x))) → (∀x (¬Several(x))) ::: Someone who is precious is always not several.\n(¬Fearless(godwin)) ↔ (Several(brandi)) ::: If Godwin is not fearless, then Brandi is several, and vice versa.\n",
                "First-Order-Logic Question": "¬Fearless(godwin) ::: Godwin is not fearless."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬x)) → (¬Jittery(godwin)) ::: If there is nobody who is not, then Godwin is not jittery.",
                    "gram": "¬∃x(¬(¬(Several(x)))) ::: If there is nobody who is not, then Godwin is not jittery."
                }
            ],
            "answer": "A",
            "grammar_answer": "A",
            "backup_answer": "A"
        },
        {
            "id": 1212,
            "raw_prog": {
                "First-Order-Logic Rules": "¬Several(rolf) ::: Rolf is not several.\n¬Precious(sigmund) ::: Sigmund is not precious.\nPrecious(godwin) ::: Godwin is precious.\nFearless(sigmund) ::: Sigmund is fearless.\nPrecious(rolf) ::: Rolf is precious.\n¬Stubborn(rose) ::: Rose is not stubborn.\nJittery(conrad) ::: Conrad is jittery.\n¬Fearless(brandi) ::: Brandi is not fearless.\n¬Sour(brandi) ::: Brandi is not sour.\nJittery(rolf) ::: Rolf is jittery.\nStubborn(owen) ::: Owen is stubborn.\n¬Fearless(godwin) ::: Godwin is not fearless.\n(¬∃x (¬x)) → (¬Jittery(godwin)) ::: If there is nobody who is not, then Godwin is not jittery.\n(∃x (Several(x) ∨ ¬Sour(x))) → (¬Stubborn(brandi)) ::: If there is someone who is either several or not sour, then Brandi is not stubborn.\n(∃x (¬Sour(x))) → ((¬Stubborn(owen) ∧ ¬Several(conrad))) ::: If there is at least one people who is not sour, then Owen is not stubborn and Conrad is not several.\n(∀x (Several(x) ∧ ¬Sour(x))) → (∀x (Stubborn(x))) ::: If someone who is several is also not sour, then he is stubborn.\n(∃x (Sour(x) ∨ Jittery(x))) → ((¬Several(brandi) ∧ Stubborn(conrad))) ::: If there is at least one people who is either sour or jittery, then Brandi is not several and Conrad is stubborn.\n(¬Fearless(rolf)) → (¬Jittery(conrad)) ::: If Rolf is not fearless, then Conrad is not jittery.\n((¬Precious(godwin))) → ((Jittery(godwin) ∧ ¬Fearless(owen))) ::: It can be concluded that Godwin is jittery and Owen is not fearless once knowing that Godwin is not precious.\n((¬Jittery(godwin) ∧ ¬Several(sigmund))) → (Precious(sigmund)) ::: It can be concluded that Sigmund is precious once knowing that Godwin is not jittery and Sigmund is not several.\n((Several(rolf) ∨ Fearless(brandi))) → (¬Precious(brandi)) ::: If Rolf is several or Brandi is fearless, then Brandi is not precious.\n((¬Jittery(godwin) ∧ Several(conrad))) → (Sour(owen)) ::: If Godwin is not jittery and Conrad is several, then Owen is sour.\n(∀x (Precious(x))) → (∀x (¬Several(x))) ::: Someone who is precious is always not several.\n(¬Fearless(godwin)) ↔ (Several(brandi)) ::: If Godwin is not fearless, then Brandi is several, and vice versa.\n",
                "First-Order-Logic Question": "Jittery(brandi) ::: Brandi is jittery."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "¬Several(rolf) ::: Rolf is not several.\n¬Precious(sigmund) ::: Sigmund is not precious.\nPrecious(godwin) ::: Godwin is precious.\nFearless(sigmund) ::: Sigmund is fearless.\nPrecious(rolf) ::: Rolf is precious.\n¬Stubborn(rose) ::: Rose is not stubborn.\nJittery(conrad) ::: Conrad is jittery.\n¬Fearless(brandi) ::: Brandi is not fearless.\n¬Sour(brandi) ::: Brandi is not sour.\nJittery(rolf) ::: Rolf is jittery.\nStubborn(owen) ::: Owen is stubborn.\n¬Fearless(godwin) ::: Godwin is not fearless.\n¬∃x(¬(¬(Several(x)))) ::: If there is nobody who is not, then Godwin is not jittery.\n(∃x (Several(x) ∨ ¬Sour(x))) → (¬Stubborn(brandi)) ::: If there is someone who is either several or not sour, then Brandi is not stubborn.\n(∃x (¬Sour(x))) → ((¬Stubborn(owen) ∧ ¬Several(conrad))) ::: If there is at least one people who is not sour, then Owen is not stubborn and Conrad is not several.\n(∀x (Several(x) ∧ ¬Sour(x))) → (∀x (Stubborn(x))) ::: If someone who is several is also not sour, then he is stubborn.\n(∃x (Sour(x) ∨ Jittery(x))) → ((¬Several(brandi) ∧ Stubborn(conrad))) ::: If there is at least one people who is either sour or jittery, then Brandi is not several and Conrad is stubborn.\n(¬Fearless(rolf)) → (¬Jittery(conrad)) ::: If Rolf is not fearless, then Conrad is not jittery.\n((¬Precious(godwin))) → ((Jittery(godwin) ∧ ¬Fearless(owen))) ::: It can be concluded that Godwin is jittery and Owen is not fearless once knowing that Godwin is not precious.\n((¬Jittery(godwin) ∧ ¬Several(sigmund))) → (Precious(sigmund)) ::: It can be concluded that Sigmund is precious once knowing that Godwin is not jittery and Sigmund is not several.\n((Several(rolf) ∨ Fearless(brandi))) → (¬Precious(brandi)) ::: If Rolf is several or Brandi is fearless, then Brandi is not precious.\n((¬Jittery(godwin) ∧ Several(conrad))) → (Sour(owen)) ::: If Godwin is not jittery and Conrad is several, then Owen is sour.\n(∀x (Precious(x))) → (∀x (¬Several(x))) ::: Someone who is precious is always not several.\n(¬Fearless(godwin)) ↔ (Several(brandi)) ::: If Godwin is not fearless, then Brandi is several, and vice versa.\n",
                "First-Order-Logic Question": "Jittery(brandi) ::: Brandi is jittery."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬x)) → (¬Jittery(godwin)) ::: If there is nobody who is not, then Godwin is not jittery.",
                    "gram": "¬∃x(¬(¬(Several(x)))) ::: If there is nobody who is not, then Godwin is not jittery."
                }
            ],
            "answer": "C",
            "grammar_answer": "A",
            "backup_answer": "C"
        },
        {
            "id": 1213,
            "raw_prog": {
                "First-Order-Logic Rules": "¬Several(rolf) ::: Rolf is not several.\n¬Precious(sigmund) ::: Sigmund is not precious.\nPrecious(godwin) ::: Godwin is precious.\nFearless(sigmund) ::: Sigmund is fearless.\nPrecious(rolf) ::: Rolf is precious.\n¬Stubborn(rose) ::: Rose is not stubborn.\nJittery(conrad) ::: Conrad is jittery.\n¬Fearless(brandi) ::: Brandi is not fearless.\n¬Sour(brandi) ::: Brandi is not sour.\nJittery(rolf) ::: Rolf is jittery.\nStubborn(owen) ::: Owen is stubborn.\n¬Fearless(godwin) ::: Godwin is not fearless.\n(¬∃x (¬x)) → (¬Jittery(godwin)) ::: If there is nobody who is not, then Godwin is not jittery.\n(∃x (Several(x) ∨ ¬Sour(x))) → (¬Stubborn(brandi)) ::: If there is someone who is either several or not sour, then Brandi is not stubborn.\n(∃x (¬Sour(x))) → ((¬Stubborn(owen) ∧ ¬Several(conrad))) ::: If there is at least one people who is not sour, then Owen is not stubborn and Conrad is not several.\n(∀x (Several(x) ∧ ¬Sour(x))) → (∀x (Stubborn(x))) ::: If someone who is several is also not sour, then he is stubborn.\n(∃x (Sour(x) ∨ Jittery(x))) → ((¬Several(brandi) ∧ Stubborn(conrad))) ::: If there is at least one people who is either sour or jittery, then Brandi is not several and Conrad is stubborn.\n(¬Fearless(rolf)) → (¬Jittery(conrad)) ::: If Rolf is not fearless, then Conrad is not jittery.\n((¬Precious(godwin))) → ((Jittery(godwin) ∧ ¬Fearless(owen))) ::: It can be concluded that Godwin is jittery and Owen is not fearless once knowing that Godwin is not precious.\n((¬Jittery(godwin) ∧ ¬Several(sigmund))) → ((Precious(sigmund))) ::: It can be concluded that Sigmund is precious once knowing that Godwin is not jittery and Sigmund is not several.\n((Several(rolf) ∨ Fearless(brandi))) → ((¬Precious(brandi))) ::: If Rolf is several or Brandi is fearless, then Brandi is not precious.\n((¬Jittery(godwin) ∧ Several(conrad))) → ((Sour(owen))) ::: If Godwin is not jittery and Conrad is several, then Owen is sour.\n(∀x (Precious(x))) → (∀x (¬Several(x))) ::: Someone who is precious is always not several.\n((¬Fearless(godwin))) ↔ ((Several(brandi))) ::: If Godwin is not fearless, then Brandi is several, and vice versa.\n",
                "First-Order-Logic Question": "¬Precious(godwin) ::: Godwin is not precious."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "¬Several(rolf) ::: Rolf is not several.\n¬Precious(sigmund) ::: Sigmund is not precious.\nPrecious(godwin) ::: Godwin is precious.\nFearless(sigmund) ::: Sigmund is fearless.\nPrecious(rolf) ::: Rolf is precious.\n¬Stubborn(rose) ::: Rose is not stubborn.\nJittery(conrad) ::: Conrad is jittery.\n¬Fearless(brandi) ::: Brandi is not fearless.\n¬Sour(brandi) ::: Brandi is not sour.\nJittery(rolf) ::: Rolf is jittery.\nStubborn(owen) ::: Owen is stubborn.\n¬Fearless(godwin) ::: Godwin is not fearless.\n¬∃x(¬(¬(Several(x)))) ::: If there is nobody who is not, then Godwin is not jittery.\n(∃x (Several(x) ∨ ¬Sour(x))) → (¬Stubborn(brandi)) ::: If there is someone who is either several or not sour, then Brandi is not stubborn.\n(∃x (¬Sour(x))) → ((¬Stubborn(owen) ∧ ¬Several(conrad))) ::: If there is at least one people who is not sour, then Owen is not stubborn and Conrad is not several.\n(∀x (Several(x) ∧ ¬Sour(x))) → (∀x (Stubborn(x))) ::: If someone who is several is also not sour, then he is stubborn.\n(∃x (Sour(x) ∨ Jittery(x))) → ((¬Several(brandi) ∧ Stubborn(conrad))) ::: If there is at least one people who is either sour or jittery, then Brandi is not several and Conrad is stubborn.\n(¬Fearless(rolf)) → (¬Jittery(conrad)) ::: If Rolf is not fearless, then Conrad is not jittery.\n((¬Precious(godwin))) → ((Jittery(godwin) ∧ ¬Fearless(owen))) ::: It can be concluded that Godwin is jittery and Owen is not fearless once knowing that Godwin is not precious.\n((¬Jittery(godwin) ∧ ¬Several(sigmund))) → ((Precious(sigmund))) ::: It can be concluded that Sigmund is precious once knowing that Godwin is not jittery and Sigmund is not several.\n((Several(rolf) ∨ Fearless(brandi))) → ((¬Precious(brandi))) ::: If Rolf is several or Brandi is fearless, then Brandi is not precious.\n((¬Jittery(godwin) ∧ Several(conrad))) → ((Sour(owen))) ::: If Godwin is not jittery and Conrad is several, then Owen is sour.\n(∀x (Precious(x))) → (∀x (¬Several(x))) ::: Someone who is precious is always not several.\n((¬Fearless(godwin))) ↔ ((Several(brandi))) ::: If Godwin is not fearless, then Brandi is several, and vice versa.\n",
                "First-Order-Logic Question": "¬Precious(godwin) ::: Godwin is not precious."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬x)) → (¬Jittery(godwin)) ::: If there is nobody who is not, then Godwin is not jittery.",
                    "gram": "¬∃x(¬(¬(Several(x)))) ::: If there is nobody who is not, then Godwin is not jittery."
                }
            ],
            "answer": "B",
            "grammar_answer": "A",
            "backup_answer": "B"
        },
        {
            "id": 1214,
            "raw_prog": {
                "First-Order-Logic Rules": "¬Several(rolf) ::: Rolf is not several.\n¬Precious(sigmund) ::: Sigmund is not precious.\nPrecious(godwin) ::: Godwin is precious.\nFearless(sigmund) ::: Sigmund is fearless.\nPrecious(rolf) ::: Rolf is precious.\n¬Stubborn(rose) ::: Rose is not stubborn.\nJittery(conrad) ::: Conrad is jittery.\n¬Fearless(brandi) ::: Brandi is not fearless.\n¬Sour(brandi) ::: Brandi is not sour.\nJittery(rolf) ::: Rolf is jittery.\nStubborn(owen) ::: Owen is stubborn.\n¬Fearless(godwin) ::: Godwin is not fearless.\n(¬∃x (¬x)) → (¬Jittery(godwin)) ::: If there is nobody who is not, then Godwin is not jittery.\n(∃x (Several(x) ∨ ¬Sour(x))) → (¬Stubborn(brandi)) ::: If there is someone who is either several or not sour, then Brandi is not stubborn.\n(∃x (¬Sour(x))) → ((¬Stubborn(owen) ∧ ¬Several(conrad))) ::: If there is at least one people who is not sour, then Owen is not stubborn and Conrad is not several.\n(∀x (Several(x) ∧ ¬Sour(x))) → (∀x (Stubborn(x))) ::: If someone who is several is also not sour, then he is stubborn.\n(∃x (Sour(x) ∨ Jittery(x))) → ((¬Several(brandi) ∧ Stubborn(conrad))) ::: If there is at least one people who is either sour or jittery, then Brandi is not several and Conrad is stubborn.\n(¬Fearless(rolf)) → (¬Jittery(conrad)) ::: If Rolf is not fearless, then Conrad is not jittery.\n(¬Precious(godwin)) → ((Jittery(godwin) ∧ ¬Fearless(owen))) ::: It can be concluded that Godwin is jittery and Owen is not fearless once knowing that Godwin is not precious.\n((¬Jittery(godwin) ∧ ¬Several(sigmund))) → (Precious(sigmund)) ::: It can be concluded that Sigmund is precious once knowing that Godwin is not jittery and Sigmund is not several.\n(Several(rolf) ∨ Fearless(brandi)) → (¬Precious(brandi)) ::: If Rolf is several or Brandi is fearless, then Brandi is not precious.\n((¬Jittery(godwin) ∧ Several(conrad))) → (Sour(owen)) ::: If Godwin is not jittery and Conrad is several, then Owen is sour.\n(∀x (Precious(x))) → (∀x (¬Several(x))) ::: Someone who is precious is always not several.\n(¬Fearless(godwin)) ↔ (Several(brandi)) ::: If Godwin is not fearless, then Brandi is several, and vice versa.\n",
                "First-Order-Logic Question": "¬Several(rolf) ::: Rolf is not several."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "¬Several(rolf) ::: Rolf is not several.\n¬Precious(sigmund) ::: Sigmund is not precious.\nPrecious(godwin) ::: Godwin is precious.\nFearless(sigmund) ::: Sigmund is fearless.\nPrecious(rolf) ::: Rolf is precious.\n¬Stubborn(rose) ::: Rose is not stubborn.\nJittery(conrad) ::: Conrad is jittery.\n¬Fearless(brandi) ::: Brandi is not fearless.\n¬Sour(brandi) ::: Brandi is not sour.\nJittery(rolf) ::: Rolf is jittery.\nStubborn(owen) ::: Owen is stubborn.\n¬Fearless(godwin) ::: Godwin is not fearless.\n¬∃x(¬(¬(Several(x)))) ::: If there is nobody who is not, then Godwin is not jittery.\n(∃x (Several(x) ∨ ¬Sour(x))) → (¬Stubborn(brandi)) ::: If there is someone who is either several or not sour, then Brandi is not stubborn.\n(∃x (¬Sour(x))) → ((¬Stubborn(owen) ∧ ¬Several(conrad))) ::: If there is at least one people who is not sour, then Owen is not stubborn and Conrad is not several.\n(∀x (Several(x) ∧ ¬Sour(x))) → (∀x (Stubborn(x))) ::: If someone who is several is also not sour, then he is stubborn.\n(∃x (Sour(x) ∨ Jittery(x))) → ((¬Several(brandi) ∧ Stubborn(conrad))) ::: If there is at least one people who is either sour or jittery, then Brandi is not several and Conrad is stubborn.\n(¬Fearless(rolf)) → (¬Jittery(conrad)) ::: If Rolf is not fearless, then Conrad is not jittery.\n(¬Precious(godwin)) → ((Jittery(godwin) ∧ ¬Fearless(owen))) ::: It can be concluded that Godwin is jittery and Owen is not fearless once knowing that Godwin is not precious.\n((¬Jittery(godwin) ∧ ¬Several(sigmund))) → (Precious(sigmund)) ::: It can be concluded that Sigmund is precious once knowing that Godwin is not jittery and Sigmund is not several.\n(Several(rolf) ∨ Fearless(brandi)) → (¬Precious(brandi)) ::: If Rolf is several or Brandi is fearless, then Brandi is not precious.\n((¬Jittery(godwin) ∧ Several(conrad))) → (Sour(owen)) ::: If Godwin is not jittery and Conrad is several, then Owen is sour.\n(∀x (Precious(x))) → (∀x (¬Several(x))) ::: Someone who is precious is always not several.\n(¬Fearless(godwin)) ↔ (Several(brandi)) ::: If Godwin is not fearless, then Brandi is several, and vice versa.\n",
                "First-Order-Logic Question": "¬Several(rolf) ::: Rolf is not several."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬x)) → (¬Jittery(godwin)) ::: If there is nobody who is not, then Godwin is not jittery.",
                    "gram": "¬∃x(¬(¬(Several(x)))) ::: If there is nobody who is not, then Godwin is not jittery."
                }
            ],
            "answer": "A",
            "grammar_answer": "A",
            "backup_answer": "A"
        },
        {
            "id": 1245,
            "raw_prog": {
                "First-Order-Logic Rules": [
                    "¬Fat(barry) ::: Barry is not fat.",
                    "¬Scared(barry) ::: Barry is not scared.",
                    "Fat(roderick) ::: Roderick is fat.",
                    "¬Attractive(rolf) ::: Rolf is not attractive.",
                    "¬Drab(udolf) ::: Udolf is not drab.",
                    "¬Scared(rolf) ::: Rolf is not scared.",
                    "¬Hungry(udolf) ::: Udolf is not hungry.",
                    "¬Wicked(udolf) ::: Udolf is not wicked.",
                    "¬Scared(udolf) ::: Udolf is not scared.",
                    "¬Scared(owen) ::: Owen is not scared.",
                    "¬Hungry(joey) ::: Joey is not hungry.",
                    "Wicked(joey) ::: Joey is wicked.",
                    "(∃x (Hungry(x) ∨ ¬Scared(x))) → (¬Wicked(roderick) ∧ ¬Drab(rolf)) ::: If there is at least one people who is either hungry or not scared, then Roderick is not wicked and Rolf is not drab.",
                    "¬Scared(barry) ↔ ¬Attractive(rolf) ::: Barry being not scared is equivalent to Rolf being not attractive.",
                    "(∃x (¬Drab(x))) → (¬Fat(roderick)) ::: If there is at least one people who is not drab, then Roderick is not fat.",
                    "¬Wicked(barry) ↔ (Fat(christina) ∧ Drab(roderick)) ::: Barry being not wicked is equivalent to Christina being fat and Roderick being drab.",
                    "(∀x (¬Attractive(x) ∧ Fat(x))) → (∀x (Hungry(x))) ::: If someone who is not attractive is also fat, then he is hungry.",
                    "(∀x (¬Hungry(x) ∧ ¬Scared(x))) ↔ (∀x (Attractive(x) ∧ ¬Fat(x))) ::: If someone is not hungry and not scared, then he is both attractive and not fat, and vice versa.",
                    "(∀x (¬Attractive(x))) → (∀x (Hungry(x) ∧ ¬Drab(x))) ::: As long as someone is not attractive, he is hungry and not drab.",
                    "(∀x (Drab(x) ∧ Attractive(x))) ↔ (∀x (Wicked(x) ∧ Hungry(x))) ::: If someone is drab and attractive, then he is both wicked and hungry, and vice versa.",
                    "(¬∃x (¬Hungry(x))) → (Attractive(udolf) ∧ ¬Wicked(joey)) ::: If there is nobody who is not hungry, then Udolf is attractive and Joey is not wicked.",
                    "(∀x (¬Hungry(x))) → (∀x (¬Attractive(x))) ::: If someone is not hungry, then he is not attractive, and vice versa.",
                    "(∃x (Scared(x) ∧ ¬Fat(x))) → (¬Wicked(christina)) ::: If there is at least one people who is both scared and not fat, then Christina is not wicked.",
                    "(∃x (Fat(x) ∨ ¬Scared(x))) → (¬Wicked(roderick)) ::: If there is someone who is either fat or not scared, then Roderick is not wicked."
                ],
                "First-Order-Logic Question": "¬Wicked(joey) ::: Joey is not wicked."
            },
            "gram_prog": {
                "First-Order-Logic Rules": [
                    "¬Fat(barry) ::: Barry is not fat.",
                    "¬Scared(barry) ::: Barry is not scared.",
                    "Fat(roderick) ::: Roderick is fat.",
                    "¬Attractive(rolf) ::: Rolf is not attractive.",
                    "¬Drab(udolf) ::: Udolf is not drab.",
                    "¬Scared(rolf) ::: Rolf is not scared.",
                    "¬Hungry(udolf) ::: Udolf is not hungry.",
                    "¬Wicked(udolf) ::: Udolf is not wicked.",
                    "¬Scared(udolf) ::: Udolf is not scared.",
                    "¬Scared(owen) ::: Owen is not scared.",
                    "¬Hungry(joey) ::: Joey is not hungry.",
                    "Wicked(joey) ::: Joey is wicked.",
                    "(∃x (Hungry(x) ∨ ¬Scared(x))) → (¬Wicked(roderick) ∧ ¬Drab(rolf)) ::: If there is at least one people who is either hungry or not scared, then Roderick is not wicked and Rolf is not drab.",
                    "¬Scared(barry) ↔ ¬Attractive(rolf) ::: Barry being not scared is equivalent to Rolf being not attractive.",
                    "(∃x (¬Drab(x))) → (¬Fat(roderick)) ::: If there is at least one people who is not drab, then Roderick is not fat.",
                    "¬Wicked(barry) ↔ (Fat(christina) ∧ Drab(roderick)) ::: Barry being not wicked is equivalent to Christina being fat and Roderick being drab.",
                    "(∀x (¬Attractive(x) ∧ Fat(x))) → (∀x (Hungry(x))) ::: If someone who is not attractive is also fat, then he is hungry.",
                    "(∀x (¬Hungry(x) ∧ ¬Scared(x))) ↔ (∀x (Attractive(x) ∧ ¬Fat(x))) ::: If someone is not hungry and not scared, then he is both attractive and not fat, and vice versa.",
                    "(∀x (¬Attractive(x))) → (∀x (Hungry(x) ∧ ¬Drab(x))) ::: As long as someone is not attractive, he is hungry and not drab.",
                    "(∀x (Drab(x) ∧ Attractive(x))) ↔ (∀x (Wicked(x) ∧ Hungry(x))) ::: If someone is drab and attractive, then he is both wicked and hungry, and vice versa.",
                    "¬∃x(¬Hungry(x))→(Attractive(x)∧¬Wicked(x)) ::: If there is nobody who is not hungry, then Udolf is attractive and Joey is not wicked.",
                    "(∀x (¬Hungry(x))) → (∀x (¬Attractive(x))) ::: If someone is not hungry, then he is not attractive, and vice versa.",
                    "(∃x (Scared(x) ∧ ¬Fat(x))) → (¬Wicked(christina)) ::: If there is at least one people who is both scared and not fat, then Christina is not wicked.",
                    "(∃x (Fat(x) ∨ ¬Scared(x))) → (¬Wicked(roderick)) ::: If there is someone who is either fat or not scared, then Roderick is not wicked."
                ],
                "First-Order-Logic Question": "¬Wicked(joey) ::: Joey is not wicked."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬Hungry(x))) → (Attractive(udolf) ∧ ¬Wicked(joey)) ::: If there is nobody who is not hungry, then Udolf is attractive and Joey is not wicked.",
                    "gram": "¬∃x(¬Hungry(x))→(Attractive(x)∧¬Wicked(x)) ::: If there is nobody who is not hungry, then Udolf is attractive and Joey is not wicked."
                }
            ],
            "answer": "B",
            "grammar_answer": "A",
            "backup_answer": "B"
        },
        {
            "id": 1246,
            "raw_prog": {
                "First-Order-Logic Rules": "¬Fat(barry) ::: Barry is not fat.\n¬Scared(barry) ::: Barry is not scared.\nFat(roderick) ::: Roderick is fat.\n¬Attractive(rolf) ::: Rolf is not attractive.\n¬Drab(udolf) ::: Udolf is not drab.\n¬Scared(rolf) ::: Rolf is not scared.\n¬Hungry(udolf) ::: Udolf is not hungry.\n¬Wicked(udolf) ::: Udolf is not wicked.\n¬Scared(udolf) ::: Udolf is not scared.\n¬Scared(owen) ::: Owen is not scared.\n¬Hungry(joey) ::: Joey is not hungry.\nWicked(joey) ::: Joey is wicked.\n(∃x (Hungry(x) ∨ ¬Scared(x))) → ((¬Wicked(roderick) ∧ ¬Drab(rolf))) ::: If there is at least one people who is either hungry or not scared, then Roderick is not wicked and Rolf is not drab.\n((¬Scared(barry))) ↔ ((¬Attractive(rolf))) ::: Barry being not scared is equivalent to Rolf being not attractive.\n(∃x (¬Drab(x))) → ((¬Fat(roderick))) ::: If there is at least one people who is not drab, then Roderick is not fat.\n((¬Wicked(barry))) ↔ ((Fat(christina) ∧ Drab(roderick))) ::: Barry being not wicked is equivalent to Christina being fat and Roderick being drab.\n(∀x (¬Attractive(x) ∧ Fat(x))) → (∀x (Hungry(x))) ::: If someone who is not attractive is also fat, then he is hungry.\n(∀x (¬Hungry(x) ∧ ¬Scared(x))) ↔ (∀x (Attractive(x) ∧ ¬Fat(x))) ::: If someone is not hungry and not scared, then he is both attractive and not fat, and vice versa.\n(∀x (¬Attractive(x))) → (∀x (Hungry(x) ∧ ¬Drab(x))) ::: As long as someone is not attractive, he is hungry and not drab.\n(∀x (Drab(x) ∧ Attractive(x))) ↔ (∀x (Wicked(x) ∧ Hungry(x))) ::: If someone is drab and attractive, then he is both wicked and hungry, and vice versa.\n(¬∃x (¬Hungry(x))) → ((Attractive(udolf) ∧ ¬Wicked(joey))) ::: If there is nobody who is not hungry, then Udolf is attractive and Joey is not wicked.\n(∀x (¬Hungry(x))) → (∀x (¬Attractive(x))) ::: If someone is not hungry, then he is not attractive, and vice versa.\n(∃x (Scared(x) ∧ ¬Fat(x))) → ((¬Wicked(christina))) ::: If there is at least one people who is both scared and not fat, then Christina is not wicked.\n(∃x (Fat(x) ∨ ¬Scared(x))) → ((¬Wicked(roderick))) ::: If there is someone who is either fat or not scared, then Roderick is not wicked.\n",
                "First-Order-Logic Question": "Wicked(roderick) ::: Roderick is wicked."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "¬Fat(barry) ::: Barry is not fat.\n¬Scared(barry) ::: Barry is not scared.\nFat(roderick) ::: Roderick is fat.\n¬Attractive(rolf) ::: Rolf is not attractive.\n¬Drab(udolf) ::: Udolf is not drab.\n¬Scared(rolf) ::: Rolf is not scared.\n¬Hungry(udolf) ::: Udolf is not hungry.\n¬Wicked(udolf) ::: Udolf is not wicked.\n¬Scared(udolf) ::: Udolf is not scared.\n¬Scared(owen) ::: Owen is not scared.\n¬Hungry(joey) ::: Joey is not hungry.\nWicked(joey) ::: Joey is wicked.\n(∃x (Hungry(x) ∨ ¬Scared(x))) → ((¬Wicked(roderick) ∧ ¬Drab(rolf))) ::: If there is at least one people who is either hungry or not scared, then Roderick is not wicked and Rolf is not drab.\n((¬Scared(barry))) ↔ ((¬Attractive(rolf))) ::: Barry being not scared is equivalent to Rolf being not attractive.\n(∃x (¬Drab(x))) → ((¬Fat(roderick))) ::: If there is at least one people who is not drab, then Roderick is not fat.\n((¬Wicked(barry))) ↔ ((Fat(christina) ∧ Drab(roderick))) ::: Barry being not wicked is equivalent to Christina being fat and Roderick being drab.\n(∀x (¬Attractive(x) ∧ Fat(x))) → (∀x (Hungry(x))) ::: If someone who is not attractive is also fat, then he is hungry.\n(∀x (¬Hungry(x) ∧ ¬Scared(x))) ↔ (∀x (Attractive(x) ∧ ¬Fat(x))) ::: If someone is not hungry and not scared, then he is both attractive and not fat, and vice versa.\n(∀x (¬Attractive(x))) → (∀x (Hungry(x) ∧ ¬Drab(x))) ::: As long as someone is not attractive, he is hungry and not drab.\n(∀x (Drab(x) ∧ Attractive(x))) ↔ (∀x (Wicked(x) ∧ Hungry(x))) ::: If someone is drab and attractive, then he is both wicked and hungry, and vice versa.\n¬∃x(¬Hungry(x))→((Attractive(x))) ::: If there is nobody who is not hungry, then Udolf is attractive and Joey is not wicked.\n(∀x (¬Hungry(x))) → (∀x (¬Attractive(x))) ::: If someone is not hungry, then he is not attractive, and vice versa.\n(∃x (Scared(x) ∧ ¬Fat(x))) → ((¬Wicked(christina))) ::: If there is at least one people who is both scared and not fat, then Christina is not wicked.\n(∃x (Fat(x) ∨ ¬Scared(x))) → ((¬Wicked(roderick))) ::: If there is someone who is either fat or not scared, then Roderick is not wicked.\n",
                "First-Order-Logic Question": "Wicked(roderick) ::: Roderick is wicked."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬Hungry(x))) → ((Attractive(udolf) ∧ ¬Wicked(joey))) ::: If there is nobody who is not hungry, then Udolf is attractive and Joey is not wicked.",
                    "gram": "¬∃x(¬Hungry(x))→((Attractive(x))) ::: If there is nobody who is not hungry, then Udolf is attractive and Joey is not wicked."
                }
            ],
            "answer": "B",
            "grammar_answer": "A",
            "backup_answer": "B"
        },
        {
            "id": 1247,
            "raw_prog": {
                "First-Order-Logic Rules": "¬Fat(barry) ::: Barry is not fat.\n¬Scared(barry) ::: Barry is not scared.\nFat(roderick) ::: Roderick is fat.\n¬Attractive(rolf) ::: Rolf is not attractive.\n¬Drab(udolf) ::: Udolf is not drab.\n¬Scared(rolf) ::: Rolf is not scared.\n¬Hungry(udolf) ::: Udolf is not hungry.\n¬Wicked(udolf) ::: Udolf is not wicked.\n¬Scared(udolf) ::: Udolf is not scared.\n¬Scared(owen) ::: Owen is not scared.\n¬Hungry(joey) ::: Joey is not hungry.\nWicked(joey) ::: Joey is wicked.\n(∃x (Hungry(x) ∨ ¬Scared(x))) → ((¬Wicked(roderick) ∧ ¬Drab(rolf))) ::: If there is at least one people who is either hungry or not scared, then Roderick is not wicked and Rolf is not drab.\n((¬Scared(barry))) ↔ ((¬Attractive(rolf))) ::: Barry being not scared is equivalent to Rolf being not attractive.\n(∃x (¬Drab(x))) → ((¬Fat(roderick))) ::: If there is at least one people who is not drab, then Roderick is not fat.\n((¬Wicked(barry))) ↔ ((Fat(christina) ∧ Drab(roderick))) ::: Barry being not wicked is equivalent to Christina being fat and Roderick being drab.\n(∀x (¬Attractive(x) ∧ Fat(x))) → (∀x (Hungry(x))) ::: If someone who is not attractive is also fat, then he is hungry.\n(∀x (¬Hungry(x) ∧ ¬Scared(x))) ↔ (∀x (Attractive(x) ∧ ¬Fat(x))) ::: If someone is not hungry and not scared, then he is both attractive and not fat, and vice versa.\n(∀x (¬Attractive(x))) → (∀x (Hungry(x) ∧ ¬Drab(x))) ::: As long as someone is not attractive, he is hungry and not drab.\n(∀x (Drab(x) ∧ Attractive(x))) ↔ (∀x (Wicked(x) ∧ Hungry(x))) ::: If someone is drab and attractive, then he is both wicked and hungry, and vice versa.\n(¬∃x (¬Hungry(x))) → ((Attractive(udolf) ∧ ¬Wicked(joey))) ::: If there is nobody who is not hungry, then Udolf is attractive and Joey is not wicked.\n(∀x (¬Hungry(x))) → (∀x (¬Attractive(x))) ::: If someone is not hungry, then he is not attractive, and vice versa.\n(∃x (Scared(x) ∧ ¬Fat(x))) → ((¬Wicked(christina))) ::: If there is at least one people who is both scared and not fat, then Christina is not wicked.\n(∃x (Fat(x) ∨ ¬Scared(x))) → ((¬Wicked(roderick))) ::: If there is someone who is either fat or not scared, then Roderick is not wicked.\n",
                "First-Order-Logic Question": "¬Scared(udolf) ::: Udolf is not scared."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "¬Fat(barry) ::: Barry is not fat.\n¬Scared(barry) ::: Barry is not scared.\nFat(roderick) ::: Roderick is fat.\n¬Attractive(rolf) ::: Rolf is not attractive.\n¬Drab(udolf) ::: Udolf is not drab.\n¬Scared(rolf) ::: Rolf is not scared.\n¬Hungry(udolf) ::: Udolf is not hungry.\n¬Wicked(udolf) ::: Udolf is not wicked.\n¬Scared(udolf) ::: Udolf is not scared.\n¬Scared(owen) ::: Owen is not scared.\n¬Hungry(joey) ::: Joey is not hungry.\nWicked(joey) ::: Joey is wicked.\n(∃x (Hungry(x) ∨ ¬Scared(x))) → ((¬Wicked(roderick) ∧ ¬Drab(rolf))) ::: If there is at least one people who is either hungry or not scared, then Roderick is not wicked and Rolf is not drab.\n((¬Scared(barry))) ↔ ((¬Attractive(rolf))) ::: Barry being not scared is equivalent to Rolf being not attractive.\n(∃x (¬Drab(x))) → ((¬Fat(roderick))) ::: If there is at least one people who is not drab, then Roderick is not fat.\n((¬Wicked(barry))) ↔ ((Fat(christina) ∧ Drab(roderick))) ::: Barry being not wicked is equivalent to Christina being fat and Roderick being drab.\n(∀x (¬Attractive(x) ∧ Fat(x))) → (∀x (Hungry(x))) ::: If someone who is not attractive is also fat, then he is hungry.\n(∀x (¬Hungry(x) ∧ ¬Scared(x))) ↔ (∀x (Attractive(x) ∧ ¬Fat(x))) ::: If someone is not hungry and not scared, then he is both attractive and not fat, and vice versa.\n(∀x (¬Attractive(x))) → (∀x (Hungry(x) ∧ ¬Drab(x))) ::: As long as someone is not attractive, he is hungry and not drab.\n(∀x (Drab(x) ∧ Attractive(x))) ↔ (∀x (Wicked(x) ∧ Hungry(x))) ::: If someone is drab and attractive, then he is both wicked and hungry, and vice versa.\n¬∃x(¬Hungry(x))→((Attractive(x))) ::: If there is nobody who is not hungry, then Udolf is attractive and Joey is not wicked.\n(∀x (¬Hungry(x))) → (∀x (¬Attractive(x))) ::: If someone is not hungry, then he is not attractive, and vice versa.\n(∃x (Scared(x) ∧ ¬Fat(x))) → ((¬Wicked(christina))) ::: If there is at least one people who is both scared and not fat, then Christina is not wicked.\n(∃x (Fat(x) ∨ ¬Scared(x))) → ((¬Wicked(roderick))) ::: If there is someone who is either fat or not scared, then Roderick is not wicked.\n",
                "First-Order-Logic Question": "¬Scared(udolf) ::: Udolf is not scared."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬Hungry(x))) → ((Attractive(udolf) ∧ ¬Wicked(joey))) ::: If there is nobody who is not hungry, then Udolf is attractive and Joey is not wicked.",
                    "gram": "¬∃x(¬Hungry(x))→((Attractive(x))) ::: If there is nobody who is not hungry, then Udolf is attractive and Joey is not wicked."
                }
            ],
            "answer": "A",
            "grammar_answer": "A",
            "backup_answer": "A"
        },
        {
            "id": 1248,
            "raw_prog": {
                "First-Order-Logic Rules": "¬Fat(barry) ::: Barry is not fat.\n¬Scared(barry) ::: Barry is not scared.\nFat(roderick) ::: Roderick is fat.\n¬Attractive(rolf) ::: Rolf is not attractive.\n¬Drab(udolf) ::: Udolf is not drab.\n¬Scared(rolf) ::: Rolf is not scared.\n¬Hungry(udolf) ::: Udolf is not hungry.\n¬Wicked(udolf) ::: Udolf is not wicked.\n¬Scared(udolf) ::: Udolf is not scared.\n¬Scared(owen) ::: Owen is not scared.\n¬Hungry(joey) ::: Joey is not hungry.\nWicked(joey) ::: Joey is wicked.\n(∃x (Hungry(x) ∨ ¬Scared(x))) → ((¬Wicked(roderick) ∧ ¬Drab(rolf))) ::: If there is at least one people who is either hungry or not scared, then Roderick is not wicked and Rolf is not drab.\n(¬Scared(barry)) ↔ (¬Attractive(rolf)) ::: Barry being not scared is equivalent to Rolf being not attractive.\n(∃x (¬Drab(x))) → (¬Fat(roderick)) ::: If there is at least one people who is not drab, then Roderick is not fat.\n(¬Wicked(barry)) ↔ ((Fat(christina) ∧ Drab(roderick))) ::: Barry being not wicked is equivalent to Christina being fat and Roderick being drab.\n(∀x (¬Attractive(x) ∧ Fat(x))) → (∀x (Hungry(x))) ::: If someone who is not attractive is also fat, then he is hungry.\n(∀x (¬Hungry(x) ∧ ¬Scared(x))) ↔ (∀x (Attractive(x) ∧ ¬Fat(x))) ::: If someone is not hungry and not scared, then he is both attractive and not fat, and vice versa.\n(∀x (¬Attractive(x))) → (∀x (Hungry(x) ∧ ¬Drab(x))) ::: As long as someone is not attractive, he is hungry and not drab.\n(∀x (Drab(x) ∧ Attractive(x))) ↔ (∀x (Wicked(x) ∧ Hungry(x))) ::: If someone is drab and attractive, then he is both wicked and hungry, and vice versa.\n(¬∃x (¬Hungry(x))) → ((Attractive(udolf) ∧ ¬Wicked(joey))) ::: If there is nobody who is not hungry, then Udolf is attractive and Joey is not wicked.\n(∀x (¬Hungry(x))) → (∀x (¬Attractive(x))) ::: If someone is not hungry, then he is not attractive, and vice versa.\n(∃x (Scared(x) ∧ ¬Fat(x))) → (¬Wicked(christina)) ::: If there is at least one people who is both scared and not fat, then Christina is not wicked.\n(∃x (Fat(x) ∨ ¬Scared(x))) → (¬Wicked(roderick)) ::: If there is someone who is either fat or not scared, then Roderick is not wicked.\n",
                "First-Order-Logic Question": "Fat(udolf) ::: Udolf is fat."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "¬Fat(barry) ::: Barry is not fat.\n¬Scared(barry) ::: Barry is not scared.\nFat(roderick) ::: Roderick is fat.\n¬Attractive(rolf) ::: Rolf is not attractive.\n¬Drab(udolf) ::: Udolf is not drab.\n¬Scared(rolf) ::: Rolf is not scared.\n¬Hungry(udolf) ::: Udolf is not hungry.\n¬Wicked(udolf) ::: Udolf is not wicked.\n¬Scared(udolf) ::: Udolf is not scared.\n¬Scared(owen) ::: Owen is not scared.\n¬Hungry(joey) ::: Joey is not hungry.\nWicked(joey) ::: Joey is wicked.\n(∃x (Hungry(x) ∨ ¬Scared(x))) → ((¬Wicked(roderick) ∧ ¬Drab(rolf))) ::: If there is at least one people who is either hungry or not scared, then Roderick is not wicked and Rolf is not drab.\n(¬Scared(barry)) ↔ (¬Attractive(rolf)) ::: Barry being not scared is equivalent to Rolf being not attractive.\n(∃x (¬Drab(x))) → (¬Fat(roderick)) ::: If there is at least one people who is not drab, then Roderick is not fat.\n(¬Wicked(barry)) ↔ ((Fat(christina) ∧ Drab(roderick))) ::: Barry being not wicked is equivalent to Christina being fat and Roderick being drab.\n(∀x (¬Attractive(x) ∧ Fat(x))) → (∀x (Hungry(x))) ::: If someone who is not attractive is also fat, then he is hungry.\n(∀x (¬Hungry(x) ∧ ¬Scared(x))) ↔ (∀x (Attractive(x) ∧ ¬Fat(x))) ::: If someone is not hungry and not scared, then he is both attractive and not fat, and vice versa.\n(∀x (¬Attractive(x))) → (∀x (Hungry(x) ∧ ¬Drab(x))) ::: As long as someone is not attractive, he is hungry and not drab.\n(∀x (Drab(x) ∧ Attractive(x))) ↔ (∀x (Wicked(x) ∧ Hungry(x))) ::: If someone is drab and attractive, then he is both wicked and hungry, and vice versa.\n¬∃x(¬Hungry(x))→((Attractive(x))) ::: If there is nobody who is not hungry, then Udolf is attractive and Joey is not wicked.\n(∀x (¬Hungry(x))) → (∀x (¬Attractive(x))) ::: If someone is not hungry, then he is not attractive, and vice versa.\n(∃x (Scared(x) ∧ ¬Fat(x))) → (¬Wicked(christina)) ::: If there is at least one people who is both scared and not fat, then Christina is not wicked.\n(∃x (Fat(x) ∨ ¬Scared(x))) → (¬Wicked(roderick)) ::: If there is someone who is either fat or not scared, then Roderick is not wicked.\n",
                "First-Order-Logic Question": "Fat(udolf) ::: Udolf is fat."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬Hungry(x))) → ((Attractive(udolf) ∧ ¬Wicked(joey))) ::: If there is nobody who is not hungry, then Udolf is attractive and Joey is not wicked.",
                    "gram": "¬∃x(¬Hungry(x))→((Attractive(x))) ::: If there is nobody who is not hungry, then Udolf is attractive and Joey is not wicked."
                }
            ],
            "answer": "B",
            "grammar_answer": "A",
            "backup_answer": "C"
        },
        {
            "id": 1249,
            "raw_prog": {
                "First-Order-Logic Rules": "¬Fat(barry) ::: Barry is not fat.\n¬Scared(barry) ::: Barry is not scared.\nFat(roderick) ::: Roderick is fat.\n¬Attractive(rolf) ::: Rolf is not attractive.\n¬Drab(udolf) ::: Udolf is not drab.\n¬Scared(rolf) ::: Rolf is not scared.\n¬Hungry(udolf) ::: Udolf is not hungry.\n¬Wicked(udolf) ::: Udolf is not wicked.\n¬Scared(udolf) ::: Udolf is not scared.\n¬Scared(owen) ::: Owen is not scared.\n¬Hungry(joey) ::: Joey is not hungry.\nWicked(joey) ::: Joey is wicked.\n(∃x (Hungry(x) ∨ ¬Scared(x))) → ((¬Wicked(roderick) ∧ ¬Drab(rolf))) ::: If there is at least one people who is either hungry or not scared, then Roderick is not wicked and Rolf is not drab.\n(¬Scared(barry)) ↔ (¬Attractive(rolf)) ::: Barry being not scared is equivalent to Rolf being not attractive.\n(∃x (¬Drab(x))) → (¬Fat(roderick)) ::: If there is at least one people who is not drab, then Roderick is not fat.\n(¬Wicked(barry)) ↔ ((Fat(christina) ∧ Drab(roderick))) ::: Barry being not wicked is equivalent to Christina being fat and Roderick being drab.\n(∀x (¬Attractive(x) ∧ Fat(x))) → (∀x (Hungry(x))) ::: If someone who is not attractive is also fat, then he is hungry.\n(∀x (¬Hungry(x) ∧ ¬Scared(x))) ↔ (∀x (Attractive(x) ∧ ¬Fat(x))) ::: If someone is not hungry and not scared, then he is both attractive and not fat, and vice versa.\n(∀x (¬Attractive(x))) → (∀x (Hungry(x) ∧ ¬Drab(x))) ::: As long as someone is not attractive, he is hungry and not drab.\n(∀x (Drab(x) ∧ Attractive(x))) ↔ (∀x (Wicked(x) ∧ Hungry(x))) ::: If someone is drab and attractive, then he is both wicked and hungry, and vice versa.\n(¬∃x (¬Hungry(x))) → ((Attractive(udolf) ∧ ¬Wicked(joey))) ::: If there is nobody who is not hungry, then Udolf is attractive and Joey is not wicked.\n(∀x (¬Hungry(x))) → (∀x (¬Attractive(x))) ::: If someone is not hungry, then he is not attractive, and vice versa.\n(∃x (Scared(x) ∧ ¬Fat(x))) → (¬Wicked(christina)) ::: If there is at least one people who is both scared and not fat, then Christina is not wicked.\n(∃x (Fat(x) ∨ ¬Scared(x))) → (¬Wicked(roderick)) ::: If there is someone who is either fat or not scared, then Roderick is not wicked.\n",
                "First-Order-Logic Question": "¬Wicked(roderick) ::: Roderick is not wicked."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "¬Fat(barry) ::: Barry is not fat.\n¬Scared(barry) ::: Barry is not scared.\nFat(roderick) ::: Roderick is fat.\n¬Attractive(rolf) ::: Rolf is not attractive.\n¬Drab(udolf) ::: Udolf is not drab.\n¬Scared(rolf) ::: Rolf is not scared.\n¬Hungry(udolf) ::: Udolf is not hungry.\n¬Wicked(udolf) ::: Udolf is not wicked.\n¬Scared(udolf) ::: Udolf is not scared.\n¬Scared(owen) ::: Owen is not scared.\n¬Hungry(joey) ::: Joey is not hungry.\nWicked(joey) ::: Joey is wicked.\n(∃x (Hungry(x) ∨ ¬Scared(x))) → ((¬Wicked(roderick) ∧ ¬Drab(rolf))) ::: If there is at least one people who is either hungry or not scared, then Roderick is not wicked and Rolf is not drab.\n(¬Scared(barry)) ↔ (¬Attractive(rolf)) ::: Barry being not scared is equivalent to Rolf being not attractive.\n(∃x (¬Drab(x))) → (¬Fat(roderick)) ::: If there is at least one people who is not drab, then Roderick is not fat.\n(¬Wicked(barry)) ↔ ((Fat(christina) ∧ Drab(roderick))) ::: Barry being not wicked is equivalent to Christina being fat and Roderick being drab.\n(∀x (¬Attractive(x) ∧ Fat(x))) → (∀x (Hungry(x))) ::: If someone who is not attractive is also fat, then he is hungry.\n(∀x (¬Hungry(x) ∧ ¬Scared(x))) ↔ (∀x (Attractive(x) ∧ ¬Fat(x))) ::: If someone is not hungry and not scared, then he is both attractive and not fat, and vice versa.\n(∀x (¬Attractive(x))) → (∀x (Hungry(x) ∧ ¬Drab(x))) ::: As long as someone is not attractive, he is hungry and not drab.\n(∀x (Drab(x) ∧ Attractive(x))) ↔ (∀x (Wicked(x) ∧ Hungry(x))) ::: If someone is drab and attractive, then he is both wicked and hungry, and vice versa.\n¬∃x(¬Hungry(x))→((Attractive(x))) ::: If there is nobody who is not hungry, then Udolf is attractive and Joey is not wicked.\n(∀x (¬Hungry(x))) → (∀x (¬Attractive(x))) ::: If someone is not hungry, then he is not attractive, and vice versa.\n(∃x (Scared(x) ∧ ¬Fat(x))) → (¬Wicked(christina)) ::: If there is at least one people who is both scared and not fat, then Christina is not wicked.\n(∃x (Fat(x) ∨ ¬Scared(x))) → (¬Wicked(roderick)) ::: If there is someone who is either fat or not scared, then Roderick is not wicked.\n",
                "First-Order-Logic Question": "¬Wicked(roderick) ::: Roderick is not wicked."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬Hungry(x))) → ((Attractive(udolf) ∧ ¬Wicked(joey))) ::: If there is nobody who is not hungry, then Udolf is attractive and Joey is not wicked.",
                    "gram": "¬∃x(¬Hungry(x))→((Attractive(x))) ::: If there is nobody who is not hungry, then Udolf is attractive and Joey is not wicked."
                }
            ],
            "answer": "A",
            "grammar_answer": "A",
            "backup_answer": "A"
        },
        {
            "id": 1250,
            "raw_prog": {
                "First-Order-Logic Rules": "¬Fat(barry) ::: Barry is not fat.\n¬Scared(barry) ::: Barry is not scared.\nFat(roderick) ::: Roderick is fat.\n¬Attractive(rolf) ::: Rolf is not attractive.\n¬Drab(udolf) ::: Udolf is not drab.\n¬Scared(rolf) ::: Rolf is not scared.\n¬Hungry(udolf) ::: Udolf is not hungry.\n¬Wicked(udolf) ::: Udolf is not wicked.\n¬Scared(udolf) ::: Udolf is not scared.\n¬Scared(owen) ::: Owen is not scared.\n¬Hungry(joey) ::: Joey is not hungry.\nWicked(joey) ::: Joey is wicked.\n(∃x (Hungry(x) ∨ ¬Scared(x))) → ((¬Wicked(roderick) ∧ ¬Drab(rolf))) ::: If there is at least one people who is either hungry or not scared, then Roderick is not wicked and Rolf is not drab.\n((¬Scared(barry))) ↔ ((¬Attractive(rolf))) ::: Barry being not scared is equivalent to Rolf being not attractive.\n(∃x (¬Drab(x))) → ((¬Fat(roderick))) ::: If there is at least one people who is not drab, then Roderick is not fat.\n((¬Wicked(barry))) ↔ ((Fat(christina) ∧ Drab(roderick))) ::: Barry being not wicked is equivalent to Christina being fat and Roderick being drab.\n(∀x (¬Attractive(x) ∧ Fat(x))) → (∀x (Hungry(x))) ::: If someone who is not attractive is also fat, then he is hungry.\n(∀x (¬Hungry(x) ∧ ¬Scared(x))) ↔ (∀x (Attractive(x) ∧ ¬Fat(x))) ::: If someone is not hungry and not scared, then he is both attractive and not fat, and vice versa.\n(∀x (¬Attractive(x))) → (∀x (Hungry(x) ∧ ¬Drab(x))) ::: As long as someone is not attractive, he is hungry and not drab.\n(∀x (Drab(x) ∧ Attractive(x))) ↔ (∀x (Wicked(x) ∧ Hungry(x))) ::: If someone is drab and attractive, then he is both wicked and hungry, and vice versa.\n(¬∃x (¬Hungry(x))) → ((Attractive(udolf) ∧ ¬Wicked(joey))) ::: If there is nobody who is not hungry, then Udolf is attractive and Joey is not wicked.\n(∀x (¬Hungry(x))) → (∀x (¬Attractive(x))) ::: If someone is not hungry, then he is not attractive, and vice versa.\n(∃x (Scared(x) ∧ ¬Fat(x))) → ((¬Wicked(christina))) ::: If there is at least one people who is both scared and not fat, then Christina is not wicked.\n(∃x (Fat(x) ∨ ¬Scared(x))) → ((¬Wicked(roderick))) ::: If there is someone who is either fat or not scared, then Roderick is not wicked.\n",
                "First-Order-Logic Question": "¬Fat(joey) ::: Joey is not fat."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "¬Fat(barry) ::: Barry is not fat.\n¬Scared(barry) ::: Barry is not scared.\nFat(roderick) ::: Roderick is fat.\n¬Attractive(rolf) ::: Rolf is not attractive.\n¬Drab(udolf) ::: Udolf is not drab.\n¬Scared(rolf) ::: Rolf is not scared.\n¬Hungry(udolf) ::: Udolf is not hungry.\n¬Wicked(udolf) ::: Udolf is not wicked.\n¬Scared(udolf) ::: Udolf is not scared.\n¬Scared(owen) ::: Owen is not scared.\n¬Hungry(joey) ::: Joey is not hungry.\nWicked(joey) ::: Joey is wicked.\n(∃x (Hungry(x) ∨ ¬Scared(x))) → ((¬Wicked(roderick) ∧ ¬Drab(rolf))) ::: If there is at least one people who is either hungry or not scared, then Roderick is not wicked and Rolf is not drab.\n((¬Scared(barry))) ↔ ((¬Attractive(rolf))) ::: Barry being not scared is equivalent to Rolf being not attractive.\n(∃x (¬Drab(x))) → ((¬Fat(roderick))) ::: If there is at least one people who is not drab, then Roderick is not fat.\n((¬Wicked(barry))) ↔ ((Fat(christina) ∧ Drab(roderick))) ::: Barry being not wicked is equivalent to Christina being fat and Roderick being drab.\n(∀x (¬Attractive(x) ∧ Fat(x))) → (∀x (Hungry(x))) ::: If someone who is not attractive is also fat, then he is hungry.\n(∀x (¬Hungry(x) ∧ ¬Scared(x))) ↔ (∀x (Attractive(x) ∧ ¬Fat(x))) ::: If someone is not hungry and not scared, then he is both attractive and not fat, and vice versa.\n(∀x (¬Attractive(x))) → (∀x (Hungry(x) ∧ ¬Drab(x))) ::: As long as someone is not attractive, he is hungry and not drab.\n(∀x (Drab(x) ∧ Attractive(x))) ↔ (∀x (Wicked(x) ∧ Hungry(x))) ::: If someone is drab and attractive, then he is both wicked and hungry, and vice versa.\n¬∃x(¬Hungry(x))→((Attractive(x))) ::: If there is nobody who is not hungry, then Udolf is attractive and Joey is not wicked.\n(∀x (¬Hungry(x))) → (∀x (¬Attractive(x))) ::: If someone is not hungry, then he is not attractive, and vice versa.\n(∃x (Scared(x) ∧ ¬Fat(x))) → ((¬Wicked(christina))) ::: If there is at least one people who is both scared and not fat, then Christina is not wicked.\n(∃x (Fat(x) ∨ ¬Scared(x))) → ((¬Wicked(roderick))) ::: If there is someone who is either fat or not scared, then Roderick is not wicked.\n",
                "First-Order-Logic Question": "¬Fat(joey) ::: Joey is not fat."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬Hungry(x))) → ((Attractive(udolf) ∧ ¬Wicked(joey))) ::: If there is nobody who is not hungry, then Udolf is attractive and Joey is not wicked.",
                    "gram": "¬∃x(¬Hungry(x))→((Attractive(x))) ::: If there is nobody who is not hungry, then Udolf is attractive and Joey is not wicked."
                }
            ],
            "answer": "C",
            "grammar_answer": "A",
            "backup_answer": "A"
        },
        {
            "id": 1251,
            "raw_prog": {
                "First-Order-Logic Rules": "¬Fat(barry) ::: Barry is not fat.\n¬Scared(barry) ::: Barry is not scared.\nFat(roderick) ::: Roderick is fat.\n¬Attractive(rolf) ::: Rolf is not attractive.\n¬Drab(udolf) ::: Udolf is not drab.\n¬Scared(rolf) ::: Rolf is not scared.\n¬Hungry(udolf) ::: Udolf is not hungry.\n¬Wicked(udolf) ::: Udolf is not wicked.\n¬Scared(udolf) ::: Udolf is not scared.\n¬Scared(owen) ::: Owen is not scared.\n¬Hungry(joey) ::: Joey is not hungry.\nWicked(joey) ::: Joey is wicked.\n(∃x (Hungry(x) ∨ ¬Scared(x))) → ((¬Wicked(roderick) ∧ ¬Drab(rolf))) ::: If there is at least one people who is either hungry or not scared, then Roderick is not wicked and Rolf is not drab.\n(¬Scared(barry)) ↔ (¬Attractive(rolf)) ::: Barry being not scared is equivalent to Rolf being not attractive.\n(∃x (¬Drab(x))) → (¬Fat(roderick)) ::: If there is at least one people who is not drab, then Roderick is not fat.\n(¬Wicked(barry)) ↔ ((Fat(christina) ∧ Drab(roderick))) ::: Barry being not wicked is equivalent to Christina being fat and Roderick being drab.\n(∀x (¬Attractive(x) ∧ Fat(x))) → (∀x (Hungry(x))) ::: If someone who is not attractive is also fat, then he is hungry.\n(∀x (¬Hungry(x) ∧ ¬Scared(x))) ↔ (∀x (Attractive(x) ∧ ¬Fat(x))) ::: If someone is not hungry and not scared, then he is both attractive and not fat, and vice versa.\n(∀x (¬Attractive(x))) → (∀x (Hungry(x) ∧ ¬Drab(x))) ::: As long as someone is not attractive, he is hungry and not drab.\n(∀x (Drab(x) ∧ Attractive(x))) ↔ (∀x (Wicked(x) ∧ Hungry(x))) ::: If someone is drab and attractive, then he is both wicked and hungry, and vice versa.\n(¬∃x (¬Hungry(x))) → ((Attractive(udolf) ∧ ¬Wicked(joey))) ::: If there is nobody who is not hungry, then Udolf is attractive and Joey is not wicked.\n(∀x (¬Hungry(x))) → (∀x (¬Attractive(x))) ::: If someone is not hungry, then he is not attractive, and vice versa.\n(∃x (Scared(x) ∧ ¬Fat(x))) → (¬Wicked(christina)) ::: If there is at least one people who is both scared and not fat, then Christina is not wicked.\n(∃x (Fat(x) ∨ ¬Scared(x))) → (¬Wicked(roderick)) ::: If there is someone who is either fat or not scared, then Roderick is not wicked.\n",
                "First-Order-Logic Question": "¬Scared(barry) ::: Barry is not scared."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "¬Fat(barry) ::: Barry is not fat.\n¬Scared(barry) ::: Barry is not scared.\nFat(roderick) ::: Roderick is fat.\n¬Attractive(rolf) ::: Rolf is not attractive.\n¬Drab(udolf) ::: Udolf is not drab.\n¬Scared(rolf) ::: Rolf is not scared.\n¬Hungry(udolf) ::: Udolf is not hungry.\n¬Wicked(udolf) ::: Udolf is not wicked.\n¬Scared(udolf) ::: Udolf is not scared.\n¬Scared(owen) ::: Owen is not scared.\n¬Hungry(joey) ::: Joey is not hungry.\nWicked(joey) ::: Joey is wicked.\n(∃x (Hungry(x) ∨ ¬Scared(x))) → ((¬Wicked(roderick) ∧ ¬Drab(rolf))) ::: If there is at least one people who is either hungry or not scared, then Roderick is not wicked and Rolf is not drab.\n(¬Scared(barry)) ↔ (¬Attractive(rolf)) ::: Barry being not scared is equivalent to Rolf being not attractive.\n(∃x (¬Drab(x))) → (¬Fat(roderick)) ::: If there is at least one people who is not drab, then Roderick is not fat.\n(¬Wicked(barry)) ↔ ((Fat(christina) ∧ Drab(roderick))) ::: Barry being not wicked is equivalent to Christina being fat and Roderick being drab.\n(∀x (¬Attractive(x) ∧ Fat(x))) → (∀x (Hungry(x))) ::: If someone who is not attractive is also fat, then he is hungry.\n(∀x (¬Hungry(x) ∧ ¬Scared(x))) ↔ (∀x (Attractive(x) ∧ ¬Fat(x))) ::: If someone is not hungry and not scared, then he is both attractive and not fat, and vice versa.\n(∀x (¬Attractive(x))) → (∀x (Hungry(x) ∧ ¬Drab(x))) ::: As long as someone is not attractive, he is hungry and not drab.\n(∀x (Drab(x) ∧ Attractive(x))) ↔ (∀x (Wicked(x) ∧ Hungry(x))) ::: If someone is drab and attractive, then he is both wicked and hungry, and vice versa.\n¬∃x(¬Hungry(x))→((Attractive(x))) ::: If there is nobody who is not hungry, then Udolf is attractive and Joey is not wicked.\n(∀x (¬Hungry(x))) → (∀x (¬Attractive(x))) ::: If someone is not hungry, then he is not attractive, and vice versa.\n(∃x (Scared(x) ∧ ¬Fat(x))) → (¬Wicked(christina)) ::: If there is at least one people who is both scared and not fat, then Christina is not wicked.\n(∃x (Fat(x) ∨ ¬Scared(x))) → (¬Wicked(roderick)) ::: If there is someone who is either fat or not scared, then Roderick is not wicked.\n",
                "First-Order-Logic Question": "¬Scared(barry) ::: Barry is not scared."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬Hungry(x))) → ((Attractive(udolf) ∧ ¬Wicked(joey))) ::: If there is nobody who is not hungry, then Udolf is attractive and Joey is not wicked.",
                    "gram": "¬∃x(¬Hungry(x))→((Attractive(x))) ::: If there is nobody who is not hungry, then Udolf is attractive and Joey is not wicked."
                }
            ],
            "answer": "A",
            "grammar_answer": "A",
            "backup_answer": "A"
        },
        {
            "id": 1252,
            "raw_prog": {
                "First-Order-Logic Rules": "¬Fat(barry) ::: Barry is not fat.\n¬Scared(barry) ::: Barry is not scared.\nFat(roderick) ::: Roderick is fat.\n¬Attractive(rolf) ::: Rolf is not attractive.\n¬Drab(udolf) ::: Udolf is not drab.\n¬Scared(rolf) ::: Rolf is not scared.\n¬Hungry(udolf) ::: Udolf is not hungry.\n¬Wicked(udolf) ::: Udolf is not wicked.\n¬Scared(udolf) ::: Udolf is not scared.\n¬Scared(owen) ::: Owen is not scared.\n¬Hungry(joey) ::: Joey is not hungry.\nWicked(joey) ::: Joey is wicked.\n(∃x (Hungry(x) ∨ ¬Scared(x))) → ((¬Wicked(roderick) ∧ ¬Drab(rolf))) ::: If there is at least one people who is either hungry or not scared, then Roderick is not wicked and Rolf is not drab.\n(¬Scared(barry)) ↔ (¬Attractive(rolf)) ::: Barry being not scared is equivalent to Rolf being not attractive.\n(∃x (¬Drab(x))) → (¬Fat(roderick)) ::: If there is at least one people who is not drab, then Roderick is not fat.\n(¬Wicked(barry)) ↔ ((Fat(christina) ∧ Drab(roderick))) ::: Barry being not wicked is equivalent to Christina being fat and Roderick being drab.\n(∀x (¬Attractive(x) ∧ Fat(x))) → (∀x (Hungry(x))) ::: If someone who is not attractive is also fat, then he is hungry.\n(∀x (¬Hungry(x) ∧ ¬Scared(x))) ↔ (∀x (Attractive(x) ∧ ¬Fat(x))) ::: If someone is not hungry and not scared, then he is both attractive and not fat, and vice versa.\n(∀x (¬Attractive(x))) → (∀x (Hungry(x) ∧ ¬Drab(x))) ::: As long as someone is not attractive, he is hungry and not drab.\n(∀x (Drab(x) ∧ Attractive(x))) ↔ (∀x (Wicked(x) ∧ Hungry(x))) ::: If someone is drab and attractive, then he is both wicked and hungry, and vice versa.\n(¬∃x (¬Hungry(x))) → ((Attractive(udolf) ∧ ¬Wicked(joey))) ::: If there is nobody who is not hungry, then Udolf is attractive and Joey is not wicked.\n(∀x (¬Hungry(x))) → (∀x (¬Attractive(x))) ::: If someone is not hungry, then he is not attractive, and vice versa.\n(∃x (Scared(x) ∧ ¬Fat(x))) → (¬Wicked(christina)) ::: If there is at least one people who is both scared and not fat, then Christina is not wicked.\n(∃x (Fat(x) ∨ ¬Scared(x))) → (¬Wicked(roderick)) ::: If there is someone who is either fat or not scared, then Roderick is not wicked.\n",
                "First-Order-Logic Question": "Fat(barry) ::: Barry is fat."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "¬Fat(barry) ::: Barry is not fat.\n¬Scared(barry) ::: Barry is not scared.\nFat(roderick) ::: Roderick is fat.\n¬Attractive(rolf) ::: Rolf is not attractive.\n¬Drab(udolf) ::: Udolf is not drab.\n¬Scared(rolf) ::: Rolf is not scared.\n¬Hungry(udolf) ::: Udolf is not hungry.\n¬Wicked(udolf) ::: Udolf is not wicked.\n¬Scared(udolf) ::: Udolf is not scared.\n¬Scared(owen) ::: Owen is not scared.\n¬Hungry(joey) ::: Joey is not hungry.\nWicked(joey) ::: Joey is wicked.\n(∃x (Hungry(x) ∨ ¬Scared(x))) → ((¬Wicked(roderick) ∧ ¬Drab(rolf))) ::: If there is at least one people who is either hungry or not scared, then Roderick is not wicked and Rolf is not drab.\n(¬Scared(barry)) ↔ (¬Attractive(rolf)) ::: Barry being not scared is equivalent to Rolf being not attractive.\n(∃x (¬Drab(x))) → (¬Fat(roderick)) ::: If there is at least one people who is not drab, then Roderick is not fat.\n(¬Wicked(barry)) ↔ ((Fat(christina) ∧ Drab(roderick))) ::: Barry being not wicked is equivalent to Christina being fat and Roderick being drab.\n(∀x (¬Attractive(x) ∧ Fat(x))) → (∀x (Hungry(x))) ::: If someone who is not attractive is also fat, then he is hungry.\n(∀x (¬Hungry(x) ∧ ¬Scared(x))) ↔ (∀x (Attractive(x) ∧ ¬Fat(x))) ::: If someone is not hungry and not scared, then he is both attractive and not fat, and vice versa.\n(∀x (¬Attractive(x))) → (∀x (Hungry(x) ∧ ¬Drab(x))) ::: As long as someone is not attractive, he is hungry and not drab.\n(∀x (Drab(x) ∧ Attractive(x))) ↔ (∀x (Wicked(x) ∧ Hungry(x))) ::: If someone is drab and attractive, then he is both wicked and hungry, and vice versa.\n¬∃x(¬Hungry(x))→((Attractive(x))) ::: If there is nobody who is not hungry, then Udolf is attractive and Joey is not wicked.\n(∀x (¬Hungry(x))) → (∀x (¬Attractive(x))) ::: If someone is not hungry, then he is not attractive, and vice versa.\n(∃x (Scared(x) ∧ ¬Fat(x))) → (¬Wicked(christina)) ::: If there is at least one people who is both scared and not fat, then Christina is not wicked.\n(∃x (Fat(x) ∨ ¬Scared(x))) → (¬Wicked(roderick)) ::: If there is someone who is either fat or not scared, then Roderick is not wicked.\n",
                "First-Order-Logic Question": "Fat(barry) ::: Barry is fat."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬Hungry(x))) → ((Attractive(udolf) ∧ ¬Wicked(joey))) ::: If there is nobody who is not hungry, then Udolf is attractive and Joey is not wicked.",
                    "gram": "¬∃x(¬Hungry(x))→((Attractive(x))) ::: If there is nobody who is not hungry, then Udolf is attractive and Joey is not wicked."
                }
            ],
            "answer": "B",
            "grammar_answer": "A",
            "backup_answer": "B"
        },
        {
            "id": 1253,
            "raw_prog": {
                "First-Order-Logic Rules": [
                    "¬Fat(barry) ::: Barry is not fat.",
                    "¬Scared(barry) ::: Barry is not scared.",
                    "Fat(roderick) ::: Roderick is fat.",
                    "¬Attractive(rolf) ::: Rolf is not attractive.",
                    "¬Drab(udolf) ::: Udolf is not drab.",
                    "¬Scared(rolf) ::: Rolf is not scared.",
                    "¬Hungry(udolf) ::: Udolf is not hungry.",
                    "¬Wicked(udolf) ::: Udolf is not wicked.",
                    "¬Scared(udolf) ::: Udolf is not scared.",
                    "¬Scared(owen) ::: Owen is not scared.",
                    "¬Hungry(joey) ::: Joey is not hungry.",
                    "Wicked(joey) ::: Joey is wicked.",
                    "(∃x (Hungry(x) ∨ ¬Scared(x))) → (¬Wicked(roderick) ∧ ¬Drab(rolf)) ::: If there is at least one people who is either hungry or not scared, then Roderick is not wicked and Rolf is not drab.",
                    "¬Scared(barry) ↔ ¬Attractive(rolf) ::: Barry being not scared is equivalent to Rolf being not attractive.",
                    "(∃x (¬Drab(x))) → (¬Fat(roderick)) ::: If there is at least one people who is not drab, then Roderick is not fat.",
                    "¬Wicked(barry) ↔ (Fat(christina) ∧ Drab(roderick)) ::: Barry being not wicked is equivalent to Christina being fat and Roderick being drab.",
                    "(∀x (¬Attractive(x) ∧ Fat(x))) → (∀x (Hungry(x))) ::: If someone who is not attractive is also fat, then he is hungry.",
                    "(∀x (¬Hungry(x) ∧ ¬Scared(x))) ↔ (∀x (Attractive(x) ∧ ¬Fat(x))) ::: If someone is not hungry and not scared, then he is both attractive and not fat, and vice versa.",
                    "(∀x (¬Attractive(x))) → (∀x (Hungry(x) ∧ ¬Drab(x))) ::: As long as someone is not attractive, he is hungry and not drab.",
                    "(∀x (Drab(x) ∧ Attractive(x))) ↔ (∀x (Wicked(x) ∧ Hungry(x))) ::: If someone is drab and attractive, then he is both wicked and hungry, and vice versa.",
                    "(¬∃x (¬Hungry(x))) → (Attractive(udolf) ∧ ¬Wicked(joey)) ::: If there is nobody who is not hungry, then Udolf is attractive and Joey is not wicked.",
                    "(∀x (¬Hungry(x))) → (∀x (¬Attractive(x))) ::: If someone is not hungry, then he is not attractive, and vice versa.",
                    "(∃x (Scared(x) ∧ ¬Fat(x))) → (¬Wicked(christina)) ::: If there is at least one people who is both scared and not fat, then Christina is not wicked.",
                    "(∃x (Fat(x) ∨ ¬Scared(x))) → (¬Wicked(roderick)) ::: If there is someone who is either fat or not scared, then Roderick is not wicked."
                ],
                "First-Order-Logic Question": "¬Fat(udolf) ::: Udolf is not fat."
            },
            "gram_prog": {
                "First-Order-Logic Rules": [
                    "¬Fat(barry) ::: Barry is not fat.",
                    "¬Scared(barry) ::: Barry is not scared.",
                    "Fat(roderick) ::: Roderick is fat.",
                    "¬Attractive(rolf) ::: Rolf is not attractive.",
                    "¬Drab(udolf) ::: Udolf is not drab.",
                    "¬Scared(rolf) ::: Rolf is not scared.",
                    "¬Hungry(udolf) ::: Udolf is not hungry.",
                    "¬Wicked(udolf) ::: Udolf is not wicked.",
                    "¬Scared(udolf) ::: Udolf is not scared.",
                    "¬Scared(owen) ::: Owen is not scared.",
                    "¬Hungry(joey) ::: Joey is not hungry.",
                    "Wicked(joey) ::: Joey is wicked.",
                    "(∃x (Hungry(x) ∨ ¬Scared(x))) → (¬Wicked(roderick) ∧ ¬Drab(rolf)) ::: If there is at least one people who is either hungry or not scared, then Roderick is not wicked and Rolf is not drab.",
                    "¬Scared(barry) ↔ ¬Attractive(rolf) ::: Barry being not scared is equivalent to Rolf being not attractive.",
                    "(∃x (¬Drab(x))) → (¬Fat(roderick)) ::: If there is at least one people who is not drab, then Roderick is not fat.",
                    "¬Wicked(barry) ↔ (Fat(christina) ∧ Drab(roderick)) ::: Barry being not wicked is equivalent to Christina being fat and Roderick being drab.",
                    "(∀x (¬Attractive(x) ∧ Fat(x))) → (∀x (Hungry(x))) ::: If someone who is not attractive is also fat, then he is hungry.",
                    "(∀x (¬Hungry(x) ∧ ¬Scared(x))) ↔ (∀x (Attractive(x) ∧ ¬Fat(x))) ::: If someone is not hungry and not scared, then he is both attractive and not fat, and vice versa.",
                    "(∀x (¬Attractive(x))) → (∀x (Hungry(x) ∧ ¬Drab(x))) ::: As long as someone is not attractive, he is hungry and not drab.",
                    "(∀x (Drab(x) ∧ Attractive(x))) ↔ (∀x (Wicked(x) ∧ Hungry(x))) ::: If someone is drab and attractive, then he is both wicked and hungry, and vice versa.",
                    "¬∃x(¬Hungry(x))→(Attractive(x)∧¬Wicked(x)) ::: If there is nobody who is not hungry, then Udolf is attractive and Joey is not wicked.",
                    "(∀x (¬Hungry(x))) → (∀x (¬Attractive(x))) ::: If someone is not hungry, then he is not attractive, and vice versa.",
                    "(∃x (Scared(x) ∧ ¬Fat(x))) → (¬Wicked(christina)) ::: If there is at least one people who is both scared and not fat, then Christina is not wicked.",
                    "(∃x (Fat(x) ∨ ¬Scared(x))) → (¬Wicked(roderick)) ::: If there is someone who is either fat or not scared, then Roderick is not wicked."
                ],
                "First-Order-Logic Question": "¬Fat(udolf) ::: Udolf is not fat."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬Hungry(x))) → (Attractive(udolf) ∧ ¬Wicked(joey)) ::: If there is nobody who is not hungry, then Udolf is attractive and Joey is not wicked.",
                    "gram": "¬∃x(¬Hungry(x))→(Attractive(x)∧¬Wicked(x)) ::: If there is nobody who is not hungry, then Udolf is attractive and Joey is not wicked."
                }
            ],
            "answer": "A",
            "grammar_answer": "A",
            "backup_answer": "A"
        },
        {
            "id": 1254,
            "raw_prog": {
                "First-Order-Logic Rules": "¬Fat(barry) ::: Barry is not fat.\n¬Scared(barry) ::: Barry is not scared.\nFat(roderick) ::: Roderick is fat.\n¬Attractive(rolf) ::: Rolf is not attractive.\n¬Drab(udolf) ::: Udolf is not drab.\n¬Scared(rolf) ::: Rolf is not scared.\n¬Hungry(udolf) ::: Udolf is not hungry.\n¬Wicked(udolf) ::: Udolf is not wicked.\n¬Scared(udolf) ::: Udolf is not scared.\n¬Scared(owen) ::: Owen is not scared.\n¬Hungry(joey) ::: Joey is not hungry.\nWicked(joey) ::: Joey is wicked.\n(∃x (Hungry(x) ∨ ¬Scared(x))) → ((¬Wicked(roderick) ∧ ¬Drab(rolf))) ::: If there is at least one people who is either hungry or not scared, then Roderick is not wicked and Rolf is not drab.\n(¬Scared(barry)) ↔ (¬Attractive(rolf)) ::: Barry being not scared is equivalent to Rolf being not attractive.\n(∃x (¬Drab(x))) → (¬Fat(roderick)) ::: If there is at least one people who is not drab, then Roderick is not fat.\n(¬Wicked(barry)) ↔ ((Fat(christina) ∧ Drab(roderick))) ::: Barry being not wicked is equivalent to Christina being fat and Roderick being drab.\n(∀x (¬Attractive(x) ∧ Fat(x))) → (∀x (Hungry(x))) ::: If someone who is not attractive is also fat, then he is hungry.\n(∀x (¬Hungry(x) ∧ ¬Scared(x))) ↔ (∀x (Attractive(x) ∧ ¬Fat(x))) ::: If someone is not hungry and not scared, then he is both attractive and not fat, and vice versa.\n(∀x (¬Attractive(x))) → (∀x (Hungry(x) ∧ ¬Drab(x))) ::: As long as someone is not attractive, he is hungry and not drab.\n(∀x (Drab(x) ∧ Attractive(x))) ↔ (∀x (Wicked(x) ∧ Hungry(x))) ::: If someone is drab and attractive, then he is both wicked and hungry, and vice versa.\n(¬∃x (¬Hungry(x))) → ((Attractive(udolf) ∧ ¬Wicked(joey))) ::: If there is nobody who is not hungry, then Udolf is attractive and Joey is not wicked.\n(∀x (¬Hungry(x))) → (∀x (¬Attractive(x))) ::: If someone is not hungry, then he is not attractive, and vice versa.\n(∃x (Scared(x) ∧ ¬Fat(x))) → (¬Wicked(christina)) ::: If there is at least one people who is both scared and not fat, then Christina is not wicked.\n(∃x (Fat(x) ∨ ¬Scared(x))) → (¬Wicked(roderick)) ::: If there is someone who is either fat or not scared, then Roderick is not wicked.\n",
                "First-Order-Logic Question": "¬Hungry(barry) ::: Barry is not hungry."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "¬Fat(barry) ::: Barry is not fat.\n¬Scared(barry) ::: Barry is not scared.\nFat(roderick) ::: Roderick is fat.\n¬Attractive(rolf) ::: Rolf is not attractive.\n¬Drab(udolf) ::: Udolf is not drab.\n¬Scared(rolf) ::: Rolf is not scared.\n¬Hungry(udolf) ::: Udolf is not hungry.\n¬Wicked(udolf) ::: Udolf is not wicked.\n¬Scared(udolf) ::: Udolf is not scared.\n¬Scared(owen) ::: Owen is not scared.\n¬Hungry(joey) ::: Joey is not hungry.\nWicked(joey) ::: Joey is wicked.\n(∃x (Hungry(x) ∨ ¬Scared(x))) → ((¬Wicked(roderick) ∧ ¬Drab(rolf))) ::: If there is at least one people who is either hungry or not scared, then Roderick is not wicked and Rolf is not drab.\n(¬Scared(barry)) ↔ (¬Attractive(rolf)) ::: Barry being not scared is equivalent to Rolf being not attractive.\n(∃x (¬Drab(x))) → (¬Fat(roderick)) ::: If there is at least one people who is not drab, then Roderick is not fat.\n(¬Wicked(barry)) ↔ ((Fat(christina) ∧ Drab(roderick))) ::: Barry being not wicked is equivalent to Christina being fat and Roderick being drab.\n(∀x (¬Attractive(x) ∧ Fat(x))) → (∀x (Hungry(x))) ::: If someone who is not attractive is also fat, then he is hungry.\n(∀x (¬Hungry(x) ∧ ¬Scared(x))) ↔ (∀x (Attractive(x) ∧ ¬Fat(x))) ::: If someone is not hungry and not scared, then he is both attractive and not fat, and vice versa.\n(∀x (¬Attractive(x))) → (∀x (Hungry(x) ∧ ¬Drab(x))) ::: As long as someone is not attractive, he is hungry and not drab.\n(∀x (Drab(x) ∧ Attractive(x))) ↔ (∀x (Wicked(x) ∧ Hungry(x))) ::: If someone is drab and attractive, then he is both wicked and hungry, and vice versa.\n¬∃x(¬Hungry(x))→((Attractive(x))) ::: If there is nobody who is not hungry, then Udolf is attractive and Joey is not wicked.\n(∀x (¬Hungry(x))) → (∀x (¬Attractive(x))) ::: If someone is not hungry, then he is not attractive, and vice versa.\n(∃x (Scared(x) ∧ ¬Fat(x))) → (¬Wicked(christina)) ::: If there is at least one people who is both scared and not fat, then Christina is not wicked.\n(∃x (Fat(x) ∨ ¬Scared(x))) → (¬Wicked(roderick)) ::: If there is someone who is either fat or not scared, then Roderick is not wicked.\n",
                "First-Order-Logic Question": "¬Hungry(barry) ::: Barry is not hungry."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬Hungry(x))) → ((Attractive(udolf) ∧ ¬Wicked(joey))) ::: If there is nobody who is not hungry, then Udolf is attractive and Joey is not wicked.",
                    "gram": "¬∃x(¬Hungry(x))→((Attractive(x))) ::: If there is nobody who is not hungry, then Udolf is attractive and Joey is not wicked."
                }
            ],
            "answer": "C",
            "grammar_answer": "A",
            "backup_answer": "A"
        },
        {
            "id": 1255,
            "raw_prog": {
                "First-Order-Logic Rules": "¬Fat(barry) ::: Barry is not fat.\n¬Scared(barry) ::: Barry is not scared.\nFat(roderick) ::: Roderick is fat.\n¬Attractive(rolf) ::: Rolf is not attractive.\n¬Drab(udolf) ::: Udolf is not drab.\n¬Scared(rolf) ::: Rolf is not scared.\n¬Hungry(udolf) ::: Udolf is not hungry.\n¬Wicked(udolf) ::: Udolf is not wicked.\n¬Scared(udolf) ::: Udolf is not scared.\n¬Scared(owen) ::: Owen is not scared.\n¬Hungry(joey) ::: Joey is not hungry.\nWicked(joey) ::: Joey is wicked.\n(∃x (Hungry(x) ∨ ¬Scared(x))) → ((¬Wicked(roderick) ∧ ¬Drab(rolf))) ::: If there is at least one people who is either hungry or not scared, then Roderick is not wicked and Rolf is not drab.\n((¬Scared(barry))) ↔ ((¬Attractive(rolf))) ::: Barry being not scared is equivalent to Rolf being not attractive.\n(∃x (¬Drab(x))) → ((¬Fat(roderick))) ::: If there is at least one people who is not drab, then Roderick is not fat.\n((¬Wicked(barry))) ↔ ((Fat(christina) ∧ Drab(roderick))) ::: Barry being not wicked is equivalent to Christina being fat and Roderick being drab.\n(∀x (¬Attractive(x) ∧ Fat(x))) → (∀x (Hungry(x))) ::: If someone who is not attractive is also fat, then he is hungry.\n(∀x (¬Hungry(x) ∧ ¬Scared(x))) ↔ (∀x (Attractive(x) ∧ ¬Fat(x))) ::: If someone is not hungry and not scared, then he is both attractive and not fat, and vice versa.\n(∀x (¬Attractive(x))) → (∀x (Hungry(x) ∧ ¬Drab(x))) ::: As long as someone is not attractive, he is hungry and not drab.\n(∀x (Drab(x) ∧ Attractive(x))) ↔ (∀x (Wicked(x) ∧ Hungry(x))) ::: If someone is drab and attractive, then he is both wicked and hungry, and vice versa.\n(¬∃x (¬Hungry(x))) → ((Attractive(udolf) ∧ ¬Wicked(joey))) ::: If there is nobody who is not hungry, then Udolf is attractive and Joey is not wicked.\n(∀x (¬Hungry(x))) → (∀x (¬Attractive(x))) ::: If someone is not hungry, then he is not attractive, and vice versa.\n(∃x (Scared(x) ∧ ¬Fat(x))) → ((¬Wicked(christina))) ::: If there is at least one people who is both scared and not fat, then Christina is not wicked.\n(∃x (Fat(x) ∨ ¬Scared(x))) → ((¬Wicked(roderick))) ::: If there is someone who is either fat or not scared, then Roderick is not wicked.\n",
                "First-Order-Logic Question": "¬Fat(rolf) ::: Rolf is not fat."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "¬Fat(barry) ::: Barry is not fat.\n¬Scared(barry) ::: Barry is not scared.\nFat(roderick) ::: Roderick is fat.\n¬Attractive(rolf) ::: Rolf is not attractive.\n¬Drab(udolf) ::: Udolf is not drab.\n¬Scared(rolf) ::: Rolf is not scared.\n¬Hungry(udolf) ::: Udolf is not hungry.\n¬Wicked(udolf) ::: Udolf is not wicked.\n¬Scared(udolf) ::: Udolf is not scared.\n¬Scared(owen) ::: Owen is not scared.\n¬Hungry(joey) ::: Joey is not hungry.\nWicked(joey) ::: Joey is wicked.\n(∃x (Hungry(x) ∨ ¬Scared(x))) → ((¬Wicked(roderick) ∧ ¬Drab(rolf))) ::: If there is at least one people who is either hungry or not scared, then Roderick is not wicked and Rolf is not drab.\n((¬Scared(barry))) ↔ ((¬Attractive(rolf))) ::: Barry being not scared is equivalent to Rolf being not attractive.\n(∃x (¬Drab(x))) → ((¬Fat(roderick))) ::: If there is at least one people who is not drab, then Roderick is not fat.\n((¬Wicked(barry))) ↔ ((Fat(christina) ∧ Drab(roderick))) ::: Barry being not wicked is equivalent to Christina being fat and Roderick being drab.\n(∀x (¬Attractive(x) ∧ Fat(x))) → (∀x (Hungry(x))) ::: If someone who is not attractive is also fat, then he is hungry.\n(∀x (¬Hungry(x) ∧ ¬Scared(x))) ↔ (∀x (Attractive(x) ∧ ¬Fat(x))) ::: If someone is not hungry and not scared, then he is both attractive and not fat, and vice versa.\n(∀x (¬Attractive(x))) → (∀x (Hungry(x) ∧ ¬Drab(x))) ::: As long as someone is not attractive, he is hungry and not drab.\n(∀x (Drab(x) ∧ Attractive(x))) ↔ (∀x (Wicked(x) ∧ Hungry(x))) ::: If someone is drab and attractive, then he is both wicked and hungry, and vice versa.\n¬∃x(¬Hungry(x))→((Attractive(x))) ::: If there is nobody who is not hungry, then Udolf is attractive and Joey is not wicked.\n(∀x (¬Hungry(x))) → (∀x (¬Attractive(x))) ::: If someone is not hungry, then he is not attractive, and vice versa.\n(∃x (Scared(x) ∧ ¬Fat(x))) → ((¬Wicked(christina))) ::: If there is at least one people who is both scared and not fat, then Christina is not wicked.\n(∃x (Fat(x) ∨ ¬Scared(x))) → ((¬Wicked(roderick))) ::: If there is someone who is either fat or not scared, then Roderick is not wicked.\n",
                "First-Order-Logic Question": "¬Fat(rolf) ::: Rolf is not fat."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬Hungry(x))) → ((Attractive(udolf) ∧ ¬Wicked(joey))) ::: If there is nobody who is not hungry, then Udolf is attractive and Joey is not wicked.",
                    "gram": "¬∃x(¬Hungry(x))→((Attractive(x))) ::: If there is nobody who is not hungry, then Udolf is attractive and Joey is not wicked."
                }
            ],
            "answer": "A",
            "grammar_answer": "A",
            "backup_answer": "C"
        },
        {
            "id": 1256,
            "raw_prog": {
                "First-Order-Logic Rules": "¬Fat(barry) ::: Barry is not fat.\n¬Scared(barry) ::: Barry is not scared.\nFat(roderick) ::: Roderick is fat.\n¬Attractive(rolf) ::: Rolf is not attractive.\n¬Drab(udolf) ::: Udolf is not drab.\n¬Scared(rolf) ::: Rolf is not scared.\n¬Hungry(udolf) ::: Udolf is not hungry.\n¬Wicked(udolf) ::: Udolf is not wicked.\n¬Scared(udolf) ::: Udolf is not scared.\n¬Scared(owen) ::: Owen is not scared.\n¬Hungry(joey) ::: Joey is not hungry.\nWicked(joey) ::: Joey is wicked.\n(∃x (Hungry(x) ∨ ¬Scared(x))) → ((¬Wicked(roderick) ∧ ¬Drab(rolf))) ::: If there is at least one people who is either hungry or not scared, then Roderick is not wicked and Rolf is not drab.\n(¬Scared(barry)) ↔ (¬Attractive(rolf)) ::: Barry being not scared is equivalent to Rolf being not attractive.\n(∃x (¬Drab(x))) → (¬Fat(roderick)) ::: If there is at least one people who is not drab, then Roderick is not fat.\n(¬Wicked(barry)) ↔ ((Fat(christina) ∧ Drab(roderick))) ::: Barry being not wicked is equivalent to Christina being fat and Roderick being drab.\n(∀x (¬Attractive(x) ∧ Fat(x))) → (∀x (Hungry(x))) ::: If someone who is not attractive is also fat, then he is hungry.\n(∀x (¬Hungry(x) ∧ ¬Scared(x))) ↔ (∀x (Attractive(x) ∧ ¬Fat(x))) ::: If someone is not hungry and not scared, then he is both attractive and not fat, and vice versa.\n(∀x (¬Attractive(x))) → (∀x (Hungry(x) ∧ ¬Drab(x))) ::: As long as someone is not attractive, he is hungry and not drab.\n(∀x (Drab(x) ∧ Attractive(x))) ↔ (∀x (Wicked(x) ∧ Hungry(x))) ::: If someone is drab and attractive, then he is both wicked and hungry, and vice versa.\n(¬∃x (¬Hungry(x))) → ((Attractive(udolf) ∧ ¬Wicked(joey))) ::: If there is nobody who is not hungry, then Udolf is attractive and Joey is not wicked.\n(∀x (¬Hungry(x))) → (∀x (¬Attractive(x))) ::: If someone is not hungry, then he is not attractive, and vice versa.\n(∃x (Scared(x) ∧ ¬Fat(x))) → (¬Wicked(christina)) ::: If there is at least one people who is both scared and not fat, then Christina is not wicked.\n(∃x (Fat(x) ∨ ¬Scared(x))) → (¬Wicked(roderick)) ::: If there is someone who is either fat or not scared, then Roderick is not wicked.\n",
                "First-Order-Logic Question": "Scared(rolf) ::: Rolf is scared."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "¬Fat(barry) ::: Barry is not fat.\n¬Scared(barry) ::: Barry is not scared.\nFat(roderick) ::: Roderick is fat.\n¬Attractive(rolf) ::: Rolf is not attractive.\n¬Drab(udolf) ::: Udolf is not drab.\n¬Scared(rolf) ::: Rolf is not scared.\n¬Hungry(udolf) ::: Udolf is not hungry.\n¬Wicked(udolf) ::: Udolf is not wicked.\n¬Scared(udolf) ::: Udolf is not scared.\n¬Scared(owen) ::: Owen is not scared.\n¬Hungry(joey) ::: Joey is not hungry.\nWicked(joey) ::: Joey is wicked.\n(∃x (Hungry(x) ∨ ¬Scared(x))) → ((¬Wicked(roderick) ∧ ¬Drab(rolf))) ::: If there is at least one people who is either hungry or not scared, then Roderick is not wicked and Rolf is not drab.\n(¬Scared(barry)) ↔ (¬Attractive(rolf)) ::: Barry being not scared is equivalent to Rolf being not attractive.\n(∃x (¬Drab(x))) → (¬Fat(roderick)) ::: If there is at least one people who is not drab, then Roderick is not fat.\n(¬Wicked(barry)) ↔ ((Fat(christina) ∧ Drab(roderick))) ::: Barry being not wicked is equivalent to Christina being fat and Roderick being drab.\n(∀x (¬Attractive(x) ∧ Fat(x))) → (∀x (Hungry(x))) ::: If someone who is not attractive is also fat, then he is hungry.\n(∀x (¬Hungry(x) ∧ ¬Scared(x))) ↔ (∀x (Attractive(x) ∧ ¬Fat(x))) ::: If someone is not hungry and not scared, then he is both attractive and not fat, and vice versa.\n(∀x (¬Attractive(x))) → (∀x (Hungry(x) ∧ ¬Drab(x))) ::: As long as someone is not attractive, he is hungry and not drab.\n(∀x (Drab(x) ∧ Attractive(x))) ↔ (∀x (Wicked(x) ∧ Hungry(x))) ::: If someone is drab and attractive, then he is both wicked and hungry, and vice versa.\n¬∃x(¬Hungry(x))→((Attractive(x))) ::: If there is nobody who is not hungry, then Udolf is attractive and Joey is not wicked.\n(∀x (¬Hungry(x))) → (∀x (¬Attractive(x))) ::: If someone is not hungry, then he is not attractive, and vice versa.\n(∃x (Scared(x) ∧ ¬Fat(x))) → (¬Wicked(christina)) ::: If there is at least one people who is both scared and not fat, then Christina is not wicked.\n(∃x (Fat(x) ∨ ¬Scared(x))) → (¬Wicked(roderick)) ::: If there is someone who is either fat or not scared, then Roderick is not wicked.\n",
                "First-Order-Logic Question": "Scared(rolf) ::: Rolf is scared."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬Hungry(x))) → ((Attractive(udolf) ∧ ¬Wicked(joey))) ::: If there is nobody who is not hungry, then Udolf is attractive and Joey is not wicked.",
                    "gram": "¬∃x(¬Hungry(x))→((Attractive(x))) ::: If there is nobody who is not hungry, then Udolf is attractive and Joey is not wicked."
                }
            ],
            "answer": "B",
            "grammar_answer": "A",
            "backup_answer": "B"
        },
        {
            "id": 1257,
            "raw_prog": {
                "First-Order-Logic Rules": "¬Fat(barry) ::: Barry is not fat.\n¬Scared(barry) ::: Barry is not scared.\nFat(roderick) ::: Roderick is fat.\n¬Attractive(rolf) ::: Rolf is not attractive.\n¬Drab(udolf) ::: Udolf is not drab.\n¬Scared(rolf) ::: Rolf is not scared.\n¬Hungry(udolf) ::: Udolf is not hungry.\n¬Wicked(udolf) ::: Udolf is not wicked.\n¬Scared(udolf) ::: Udolf is not scared.\n¬Scared(owen) ::: Owen is not scared.\n¬Hungry(joey) ::: Joey is not hungry.\nWicked(joey) ::: Joey is wicked.\n(∃x (Hungry(x) ∨ ¬Scared(x))) → ((¬Wicked(roderick) ∧ ¬Drab(rolf))) ::: If there is at least one people who is either hungry or not scared, then Roderick is not wicked and Rolf is not drab.\n(¬Scared(barry)) ↔ (¬Attractive(rolf)) ::: Barry being not scared is equivalent to Rolf being not attractive.\n(∃x (¬Drab(x))) → (¬Fat(roderick)) ::: If there is at least one people who is not drab, then Roderick is not fat.\n(¬Wicked(barry)) ↔ ((Fat(christina) ∧ Drab(roderick))) ::: Barry being not wicked is equivalent to Christina being fat and Roderick being drab.\n(∀x (¬Attractive(x) ∧ Fat(x))) → (∀x (Hungry(x))) ::: If someone who is not attractive is also fat, then he is hungry.\n(∀x (¬Hungry(x) ∧ ¬Scared(x))) ↔ (∀x (Attractive(x) ∧ ¬Fat(x))) ::: If someone is not hungry and not scared, then he is both attractive and not fat, and vice versa.\n(∀x (¬Attractive(x))) → (∀x (Hungry(x) ∧ ¬Drab(x))) ::: As long as someone is not attractive, he is hungry and not drab.\n(∀x (Drab(x) ∧ Attractive(x))) ↔ (∀x (Wicked(x) ∧ Hungry(x))) ::: If someone is drab and attractive, then he is both wicked and hungry, and vice versa.\n(¬∃x (¬Hungry(x))) → ((Attractive(udolf) ∧ ¬Wicked(joey))) ::: If there is nobody who is not hungry, then Udolf is attractive and Joey is not wicked.\n(∀x (¬Hungry(x))) → (∀x (¬Attractive(x))) ::: If someone is not hungry, then he is not attractive, and vice versa.\n(∃x (Scared(x) ∧ ¬Fat(x))) → (¬Wicked(christina)) ::: If there is at least one people who is both scared and not fat, then Christina is not wicked.\n(∃x (Fat(x) ∨ ¬Scared(x))) → (¬Wicked(roderick)) ::: If there is someone who is either fat or not scared, then Roderick is not wicked.\n",
                "First-Order-Logic Question": "¬Fat(christina) ::: Christina is not fat."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "¬Fat(barry) ::: Barry is not fat.\n¬Scared(barry) ::: Barry is not scared.\nFat(roderick) ::: Roderick is fat.\n¬Attractive(rolf) ::: Rolf is not attractive.\n¬Drab(udolf) ::: Udolf is not drab.\n¬Scared(rolf) ::: Rolf is not scared.\n¬Hungry(udolf) ::: Udolf is not hungry.\n¬Wicked(udolf) ::: Udolf is not wicked.\n¬Scared(udolf) ::: Udolf is not scared.\n¬Scared(owen) ::: Owen is not scared.\n¬Hungry(joey) ::: Joey is not hungry.\nWicked(joey) ::: Joey is wicked.\n(∃x (Hungry(x) ∨ ¬Scared(x))) → ((¬Wicked(roderick) ∧ ¬Drab(rolf))) ::: If there is at least one people who is either hungry or not scared, then Roderick is not wicked and Rolf is not drab.\n(¬Scared(barry)) ↔ (¬Attractive(rolf)) ::: Barry being not scared is equivalent to Rolf being not attractive.\n(∃x (¬Drab(x))) → (¬Fat(roderick)) ::: If there is at least one people who is not drab, then Roderick is not fat.\n(¬Wicked(barry)) ↔ ((Fat(christina) ∧ Drab(roderick))) ::: Barry being not wicked is equivalent to Christina being fat and Roderick being drab.\n(∀x (¬Attractive(x) ∧ Fat(x))) → (∀x (Hungry(x))) ::: If someone who is not attractive is also fat, then he is hungry.\n(∀x (¬Hungry(x) ∧ ¬Scared(x))) ↔ (∀x (Attractive(x) ∧ ¬Fat(x))) ::: If someone is not hungry and not scared, then he is both attractive and not fat, and vice versa.\n(∀x (¬Attractive(x))) → (∀x (Hungry(x) ∧ ¬Drab(x))) ::: As long as someone is not attractive, he is hungry and not drab.\n(∀x (Drab(x) ∧ Attractive(x))) ↔ (∀x (Wicked(x) ∧ Hungry(x))) ::: If someone is drab and attractive, then he is both wicked and hungry, and vice versa.\n¬∃x(¬Hungry(x))→((Attractive(x))) ::: If there is nobody who is not hungry, then Udolf is attractive and Joey is not wicked.\n(∀x (¬Hungry(x))) → (∀x (¬Attractive(x))) ::: If someone is not hungry, then he is not attractive, and vice versa.\n(∃x (Scared(x) ∧ ¬Fat(x))) → (¬Wicked(christina)) ::: If there is at least one people who is both scared and not fat, then Christina is not wicked.\n(∃x (Fat(x) ∨ ¬Scared(x))) → (¬Wicked(roderick)) ::: If there is someone who is either fat or not scared, then Roderick is not wicked.\n",
                "First-Order-Logic Question": "¬Fat(christina) ::: Christina is not fat."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬Hungry(x))) → ((Attractive(udolf) ∧ ¬Wicked(joey))) ::: If there is nobody who is not hungry, then Udolf is attractive and Joey is not wicked.",
                    "gram": "¬∃x(¬Hungry(x))→((Attractive(x))) ::: If there is nobody who is not hungry, then Udolf is attractive and Joey is not wicked."
                }
            ],
            "answer": "C",
            "grammar_answer": "A",
            "backup_answer": "B"
        },
        {
            "id": 1258,
            "raw_prog": {
                "First-Order-Logic Rules": "¬Fat(barry) ::: Barry is not fat.\n¬Scared(barry) ::: Barry is not scared.\nFat(roderick) ::: Roderick is fat.\n¬Attractive(rolf) ::: Rolf is not attractive.\n¬Drab(udolf) ::: Udolf is not drab.\n¬Scared(rolf) ::: Rolf is not scared.\n¬Hungry(udolf) ::: Udolf is not hungry.\n¬Wicked(udolf) ::: Udolf is not wicked.\n¬Scared(udolf) ::: Udolf is not scared.\n¬Scared(owen) ::: Owen is not scared.\n¬Hungry(joey) ::: Joey is not hungry.\nWicked(joey) ::: Joey is wicked.\n(∃x (Hungry(x) ∨ ¬Scared(x))) → ((¬Wicked(roderick) ∧ ¬Drab(rolf))) ::: If there is at least one people who is either hungry or not scared, then Roderick is not wicked and Rolf is not drab.\n(¬Scared(barry)) ↔ (¬Attractive(rolf)) ::: Barry being not scared is equivalent to Rolf being not attractive.\n(∃x (¬Drab(x))) → (¬Fat(roderick)) ::: If there is at least one people who is not drab, then Roderick is not fat.\n(¬Wicked(barry)) ↔ ((Fat(christina) ∧ Drab(roderick))) ::: Barry being not wicked is equivalent to Christina being fat and Roderick being drab.\n(∀x (¬Attractive(x) ∧ Fat(x))) → (∀x (Hungry(x))) ::: If someone who is not attractive is also fat, then he is hungry.\n(∀x (¬Hungry(x) ∧ ¬Scared(x))) ↔ (∀x (Attractive(x) ∧ ¬Fat(x))) ::: If someone is not hungry and not scared, then he is both attractive and not fat, and vice versa.\n(∀x (¬Attractive(x))) → (∀x (Hungry(x) ∧ ¬Drab(x))) ::: As long as someone is not attractive, he is hungry and not drab.\n(∀x (Drab(x) ∧ Attractive(x))) ↔ (∀x (Wicked(x) ∧ Hungry(x))) ::: If someone is drab and attractive, then he is both wicked and hungry, and vice versa.\n(¬∃x (¬Hungry(x))) → ((Attractive(udolf) ∧ ¬Wicked(joey))) ::: If there is nobody who is not hungry, then Udolf is attractive and Joey is not wicked.\n(∀x (¬Hungry(x))) → (∀x (¬Attractive(x))) ::: If someone is not hungry, then he is not attractive, and vice versa.\n(∃x (Scared(x) ∧ ¬Fat(x))) → (¬Wicked(christina)) ::: If there is at least one people who is both scared and not fat, then Christina is not wicked.\n(∃x (Fat(x) ∨ ¬Scared(x))) → (¬Wicked(roderick)) ::: If there is someone who is either fat or not scared, then Roderick is not wicked.\n",
                "First-Order-Logic Question": "¬Attractive(christina) ::: Christina is not attractive."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "¬Fat(barry) ::: Barry is not fat.\n¬Scared(barry) ::: Barry is not scared.\nFat(roderick) ::: Roderick is fat.\n¬Attractive(rolf) ::: Rolf is not attractive.\n¬Drab(udolf) ::: Udolf is not drab.\n¬Scared(rolf) ::: Rolf is not scared.\n¬Hungry(udolf) ::: Udolf is not hungry.\n¬Wicked(udolf) ::: Udolf is not wicked.\n¬Scared(udolf) ::: Udolf is not scared.\n¬Scared(owen) ::: Owen is not scared.\n¬Hungry(joey) ::: Joey is not hungry.\nWicked(joey) ::: Joey is wicked.\n(∃x (Hungry(x) ∨ ¬Scared(x))) → ((¬Wicked(roderick) ∧ ¬Drab(rolf))) ::: If there is at least one people who is either hungry or not scared, then Roderick is not wicked and Rolf is not drab.\n(¬Scared(barry)) ↔ (¬Attractive(rolf)) ::: Barry being not scared is equivalent to Rolf being not attractive.\n(∃x (¬Drab(x))) → (¬Fat(roderick)) ::: If there is at least one people who is not drab, then Roderick is not fat.\n(¬Wicked(barry)) ↔ ((Fat(christina) ∧ Drab(roderick))) ::: Barry being not wicked is equivalent to Christina being fat and Roderick being drab.\n(∀x (¬Attractive(x) ∧ Fat(x))) → (∀x (Hungry(x))) ::: If someone who is not attractive is also fat, then he is hungry.\n(∀x (¬Hungry(x) ∧ ¬Scared(x))) ↔ (∀x (Attractive(x) ∧ ¬Fat(x))) ::: If someone is not hungry and not scared, then he is both attractive and not fat, and vice versa.\n(∀x (¬Attractive(x))) → (∀x (Hungry(x) ∧ ¬Drab(x))) ::: As long as someone is not attractive, he is hungry and not drab.\n(∀x (Drab(x) ∧ Attractive(x))) ↔ (∀x (Wicked(x) ∧ Hungry(x))) ::: If someone is drab and attractive, then he is both wicked and hungry, and vice versa.\n¬∃x(¬Hungry(x))→((Attractive(x))) ::: If there is nobody who is not hungry, then Udolf is attractive and Joey is not wicked.\n(∀x (¬Hungry(x))) → (∀x (¬Attractive(x))) ::: If someone is not hungry, then he is not attractive, and vice versa.\n(∃x (Scared(x) ∧ ¬Fat(x))) → (¬Wicked(christina)) ::: If there is at least one people who is both scared and not fat, then Christina is not wicked.\n(∃x (Fat(x) ∨ ¬Scared(x))) → (¬Wicked(roderick)) ::: If there is someone who is either fat or not scared, then Roderick is not wicked.\n",
                "First-Order-Logic Question": "¬Attractive(christina) ::: Christina is not attractive."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬Hungry(x))) → ((Attractive(udolf) ∧ ¬Wicked(joey))) ::: If there is nobody who is not hungry, then Udolf is attractive and Joey is not wicked.",
                    "gram": "¬∃x(¬Hungry(x))→((Attractive(x))) ::: If there is nobody who is not hungry, then Udolf is attractive and Joey is not wicked."
                }
            ],
            "answer": "C",
            "grammar_answer": "A",
            "backup_answer": "C"
        },
        {
            "id": 1259,
            "raw_prog": {
                "First-Order-Logic Rules": "¬Fat(barry) ::: Barry is not fat.\n¬Scared(barry) ::: Barry is not scared.\nFat(roderick) ::: Roderick is fat.\n¬Attractive(rolf) ::: Rolf is not attractive.\n¬Drab(udolf) ::: Udolf is not drab.\n¬Scared(rolf) ::: Rolf is not scared.\n¬Hungry(udolf) ::: Udolf is not hungry.\n¬Wicked(udolf) ::: Udolf is not wicked.\n¬Scared(udolf) ::: Udolf is not scared.\n¬Scared(owen) ::: Owen is not scared.\n¬Hungry(joey) ::: Joey is not hungry.\nWicked(joey) ::: Joey is wicked.\n(∃x (Hungry(x) ∨ ¬Scared(x))) → ((¬Wicked(roderick) ∧ ¬Drab(rolf))) ::: If there is at least one people who is either hungry or not scared, then Roderick is not wicked and Rolf is not drab.\n(¬Scared(barry)) ↔ (¬Attractive(rolf)) ::: Barry being not scared is equivalent to Rolf being not attractive.\n(∃x (¬Drab(x))) → (¬Fat(roderick)) ::: If there is at least one people who is not drab, then Roderick is not fat.\n(¬Wicked(barry)) ↔ ((Fat(christina) ∧ Drab(roderick))) ::: Barry being not wicked is equivalent to Christina being fat and Roderick being drab.\n(∀x (¬Attractive(x) ∧ Fat(x))) → (∀x (Hungry(x))) ::: If someone who is not attractive is also fat, then he is hungry.\n(∀x (¬Hungry(x) ∧ ¬Scared(x))) ↔ (∀x (Attractive(x) ∧ ¬Fat(x))) ::: If someone is not hungry and not scared, then he is both attractive and not fat, and vice versa.\n(∀x (¬Attractive(x))) → (∀x (Hungry(x) ∧ ¬Drab(x))) ::: As long as someone is not attractive, he is hungry and not drab.\n(∀x (Drab(x) ∧ Attractive(x))) ↔ (∀x (Wicked(x) ∧ Hungry(x))) ::: If someone is drab and attractive, then he is both wicked and hungry, and vice versa.\n(¬∃x (¬Hungry(x))) → ((Attractive(udolf) ∧ ¬Wicked(joey))) ::: If there is nobody who is not hungry, then Udolf is attractive and Joey is not wicked.\n(∀x (¬Hungry(x))) → (∀x (¬Attractive(x))) ::: If someone is not hungry, then he is not attractive, and vice versa.\n(∃x (Scared(x) ∧ ¬Fat(x))) → (¬Wicked(christina)) ::: If there is at least one people who is both scared and not fat, then Christina is not wicked.\n(∃x (Fat(x) ∨ ¬Scared(x))) → (¬Wicked(roderick)) ::: If there is someone who is either fat or not scared, then Roderick is not wicked.\n",
                "First-Order-Logic Question": "¬Scared(christina) ::: Christina is not scared."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "¬Fat(barry) ::: Barry is not fat.\n¬Scared(barry) ::: Barry is not scared.\nFat(roderick) ::: Roderick is fat.\n¬Attractive(rolf) ::: Rolf is not attractive.\n¬Drab(udolf) ::: Udolf is not drab.\n¬Scared(rolf) ::: Rolf is not scared.\n¬Hungry(udolf) ::: Udolf is not hungry.\n¬Wicked(udolf) ::: Udolf is not wicked.\n¬Scared(udolf) ::: Udolf is not scared.\n¬Scared(owen) ::: Owen is not scared.\n¬Hungry(joey) ::: Joey is not hungry.\nWicked(joey) ::: Joey is wicked.\n(∃x (Hungry(x) ∨ ¬Scared(x))) → ((¬Wicked(roderick) ∧ ¬Drab(rolf))) ::: If there is at least one people who is either hungry or not scared, then Roderick is not wicked and Rolf is not drab.\n(¬Scared(barry)) ↔ (¬Attractive(rolf)) ::: Barry being not scared is equivalent to Rolf being not attractive.\n(∃x (¬Drab(x))) → (¬Fat(roderick)) ::: If there is at least one people who is not drab, then Roderick is not fat.\n(¬Wicked(barry)) ↔ ((Fat(christina) ∧ Drab(roderick))) ::: Barry being not wicked is equivalent to Christina being fat and Roderick being drab.\n(∀x (¬Attractive(x) ∧ Fat(x))) → (∀x (Hungry(x))) ::: If someone who is not attractive is also fat, then he is hungry.\n(∀x (¬Hungry(x) ∧ ¬Scared(x))) ↔ (∀x (Attractive(x) ∧ ¬Fat(x))) ::: If someone is not hungry and not scared, then he is both attractive and not fat, and vice versa.\n(∀x (¬Attractive(x))) → (∀x (Hungry(x) ∧ ¬Drab(x))) ::: As long as someone is not attractive, he is hungry and not drab.\n(∀x (Drab(x) ∧ Attractive(x))) ↔ (∀x (Wicked(x) ∧ Hungry(x))) ::: If someone is drab and attractive, then he is both wicked and hungry, and vice versa.\n¬∃x(¬Hungry(x))→((Attractive(x))) ::: If there is nobody who is not hungry, then Udolf is attractive and Joey is not wicked.\n(∀x (¬Hungry(x))) → (∀x (¬Attractive(x))) ::: If someone is not hungry, then he is not attractive, and vice versa.\n(∃x (Scared(x) ∧ ¬Fat(x))) → (¬Wicked(christina)) ::: If there is at least one people who is both scared and not fat, then Christina is not wicked.\n(∃x (Fat(x) ∨ ¬Scared(x))) → (¬Wicked(roderick)) ::: If there is someone who is either fat or not scared, then Roderick is not wicked.\n",
                "First-Order-Logic Question": "¬Scared(christina) ::: Christina is not scared."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬Hungry(x))) → ((Attractive(udolf) ∧ ¬Wicked(joey))) ::: If there is nobody who is not hungry, then Udolf is attractive and Joey is not wicked.",
                    "gram": "¬∃x(¬Hungry(x))→((Attractive(x))) ::: If there is nobody who is not hungry, then Udolf is attractive and Joey is not wicked."
                }
            ],
            "answer": "C",
            "grammar_answer": "A",
            "backup_answer": "C"
        }
    ],
    "outputs_3": [
        {
            "id": 34,
            "raw_prog": {
                "First-Order-Logic Rules": "Giant(juliana) ::: Juliana is giant.\n¬Technical(burgess) ::: Burgess is not technical.\n¬Gleaming(blaine) ::: Blaine is not gleaming.\n¬Gleaming(tristan) ::: Tristan is not gleaming.\n¬Alert(luther) ::: Luther is not alert.\n¬Technical(lyndon) ::: Lyndon is not technical.\n¬Attractive(lyndon) ::: Lyndon is not attractive.\nGiant(blaine) ::: Blaine is giant.\n¬Giant(tristan) ::: Tristan is not giant.\n¬Giant(luther) ::: Luther is not giant.\nTechnical(blaine) ::: Blaine is technical.\n¬Technical(tristan) ::: Tristan is not technical.\n(∀x (¬Attractive(x))) → (∀x (Technical(x) ∧ Gleaming(x))) ::: If someone is not attractive, then he is both technical and gleaming.\n(∀x (Technical(x) ∧ ¬Loving(x))) → (∀x (Giant(x))) ::: If someone is both technical and not loving, then he is giant.\n(∀x (¬Attractive(x))) ↔ (∀x (Alert(x))) ::: Someone is not attractive if and only if he is alert.\n(∀x (Alert(x) ∨ ¬Loving(x))) → (∀x (¬Giant(x))) ::: If someone is alert or he is not loving, then he is not giant.\n(∀x (Alert(x))) ↔ (∀x (¬Attractive(x))) ::: Someone being alert is equivalent to being not attractive.\n(∃x (Alert(x) ∨ ¬Loving(x))) → (Giant(blaine)) ::: If there is someone who is either alert or not loving, then Blaine is giant.\n(∀x (¬Gleaming(x))) ↔ (∀x (Alert(x))) ::: Someone being not gleaming is equivalent to being alert.\n(∀x (Alert(x) ∧ Technical(x))) → (∀x (Giant(x))) ::: Someone who is both alert and technical is always giant.\n(∀x (x ∨ ¬Technical(x))) → (∀x (Gleaming(x))) ::: If someone is he or not technical is not attractive, then he is gleaming.\n(∀x (Attractive(x) ∧ ¬Gleaming(x))) ↔ (∀x (Alert(x))) ::: If someone is attractive and not gleaming, then he is alert, and vice versa.\n(∃x (Alert(x) ∨ ¬Loving(x))) → (¬Technical(luther)) ::: If there is at least one people who is alert or not loving, then Luther is not technical.\n(∃x (Alert(x))) → ((Technical(lyndon) ∧ ¬Loving(juliana))) ::: If there is at least one people who is alert, then Lyndon is technical and Juliana is not loving.\n",
                "First-Order-Logic Question": "Attractive(jack) ::: Jack is attractive."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "Giant(juliana) ::: Juliana is giant.\n¬Technical(burgess) ::: Burgess is not technical.\n¬Gleaming(blaine) ::: Blaine is not gleaming.\n¬Gleaming(tristan) ::: Tristan is not gleaming.\n¬Alert(luther) ::: Luther is not alert.\n¬Technical(lyndon) ::: Lyndon is not technical.\n¬Attractive(lyndon) ::: Lyndon is not attractive.\nGiant(blaine) ::: Blaine is giant.\n¬Giant(tristan) ::: Tristan is not giant.\n¬Giant(luther) ::: Luther is not giant.\nTechnical(blaine) ::: Blaine is technical.\n¬Technical(tristan) ::: Tristan is not technical.\n(∀x (¬Attractive(x))) → (∀x (Technical(x) ∧ Gleaming(x))) ::: If someone is not attractive, then he is both technical and gleaming.\n(∀x (Technical(x) ∧ ¬Loving(x))) → (∀x (Giant(x))) ::: If someone is both technical and not loving, then he is giant.\n(∀x (¬Attractive(x))) ↔ (∀x (Alert(x))) ::: Someone is not attractive if and only if he is alert.\n(∀x (Alert(x) ∨ ¬Loving(x))) → (∀x (¬Giant(x))) ::: If someone is alert or he is not loving, then he is not giant.\n(∀x (Alert(x))) ↔ (∀x (¬Attractive(x))) ::: Someone being alert is equivalent to being not attractive.\n(∃x (Alert(x) ∨ ¬Loving(x))) → (Giant(blaine)) ::: If there is someone who is either alert or not loving, then Blaine is giant.\n(∀x (¬Gleaming(x))) ↔ (∀x (Alert(x))) ::: Someone being not gleaming is equivalent to being alert.\n(∀x (Alert(x) ∧ Technical(x))) → (∀x (Giant(x))) ::: Someone who is both alert and technical is always giant.\n∀x((Giant(x)∨¬Technical(x))) ::: If someone is he or not technical is not attractive, then he is gleaming.\n(∀x (Attractive(x) ∧ ¬Gleaming(x))) ↔ (∀x (Alert(x))) ::: If someone is attractive and not gleaming, then he is alert, and vice versa.\n(∃x (Alert(x) ∨ ¬Loving(x))) → (¬Technical(luther)) ::: If there is at least one people who is alert or not loving, then Luther is not technical.\n(∃x (Alert(x))) → ((Technical(lyndon) ∧ ¬Loving(juliana))) ::: If there is at least one people who is alert, then Lyndon is technical and Juliana is not loving.\n",
                "First-Order-Logic Question": "Attractive(jack) ::: Jack is attractive."
            },
            "diff": [
                {
                    "raw": "(∀x (x ∨ ¬Technical(x))) → (∀x (Gleaming(x))) ::: If someone is he or not technical is not attractive, then he is gleaming.",
                    "gram": "∀x((Giant(x)∨¬Technical(x))) ::: If someone is he or not technical is not attractive, then he is gleaming."
                }
            ],
            "answer": "C",
            "grammar_answer": "C",
            "backup_answer": "C"
        },
        {
            "id": 120,
            "raw_prog": {
                "First-Order-Logic Rules": "¬Hungry(gregory) ::: Gregory is not hungry.\nMushy(ronald) ::: Ronald is mushy.\nTeak(keith) ::: Keith is teak.\nPoised(crosby) ::: Crosby is poised.\nFrank(shane) ::: Shane is frank.\nPoised(gregory) ::: Gregory is poised.\n¬Poised(shane) ::: Shane is not poised.\nMushy(keith) ::: Keith is mushy.\n¬Frank(noel) ::: Noel is not frank.\nFrank(george) ::: George is frank.\nWicked(george) ::: George is wicked.\nFrank(keith) ::: Keith is frank.\n(∀x (Mushy(x) ∨ ¬Poised(x))) → (∀x (Hungry(x) ∧ ¬Wicked(x))) ::: If someone is either mushy or not poised, then he is hungry and not wicked.\n(¬Poised(gregory)) → (Mushy(shane)) ::: If Gregory is not poised, then Shane is mushy.\n(∃x (Wicked(x))) → ((¬Poised(shane) ∧ ¬Frank(george))) ::: If there is at least one people who is wicked, then Shane is not poised and George is not frank.\n((Teak(noel))) ↔ ((¬Poised(noel))) ::: If Noel is teak, then Noel is not poised, and vice versa.\n(∀x (¬x)) → ((Teak(shane) ∧ ¬Poised(shane))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised.\n(∀x (Wicked(x) ∧ Mushy(x))) ↔ (∀x (Poised(x))) ::: Someone is wicked and mushy if and only if he is poised.\n(∃x (Poised(x) ∨ ¬Hungry(x))) → ((¬Mushy(george))) ::: If there is at least one people who is poised or not hungry, then George is not mushy.\n(∃x (Wicked(x) ∧ ¬Teak(x))) → ((Poised(crosby))) ::: If there is at least one people who is both wicked and not teak, then Crosby is poised.\n((Teak(keith))) ↔ ((¬Poised(gregory) ∧ ¬Wicked(noel))) ::: Keith is teak if and only if Gregory is not poised and Noel is not wicked.\n((Teak(noel))) ↔ ((Hungry(shane))) ::: Noel is teak if and only if Shane is hungry.\n((¬Teak(gregory) ∧ Wicked(crosby))) → ((¬Mushy(keith))) ::: If Gregory is not teak and Crosby is wicked, then Keith is not mushy.\n(∃x (Hungry(x) ∧ Wicked(x))) → ((Teak(noel))) ::: If there is at least one people who is both hungry and wicked, then Noel is teak.\n",
                "First-Order-Logic Question": "¬Mushy(noel) ::: Noel is not mushy."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "¬Hungry(gregory) ::: Gregory is not hungry.\nMushy(ronald) ::: Ronald is mushy.\nTeak(keith) ::: Keith is teak.\nPoised(crosby) ::: Crosby is poised.\nFrank(shane) ::: Shane is frank.\nPoised(gregory) ::: Gregory is poised.\n¬Poised(shane) ::: Shane is not poised.\nMushy(keith) ::: Keith is mushy.\n¬Frank(noel) ::: Noel is not frank.\nFrank(george) ::: George is frank.\nWicked(george) ::: George is wicked.\nFrank(keith) ::: Keith is frank.\n(∀x (Mushy(x) ∨ ¬Poised(x))) → (∀x (Hungry(x) ∧ ¬Wicked(x))) ::: If someone is either mushy or not poised, then he is hungry and not wicked.\n(¬Poised(gregory)) → (Mushy(shane)) ::: If Gregory is not poised, then Shane is mushy.\n(∃x (Wicked(x))) → ((¬Poised(shane) ∧ ¬Frank(george))) ::: If there is at least one people who is wicked, then Shane is not poised and George is not frank.\n((Teak(noel))) ↔ ((¬Poised(noel))) ::: If Noel is teak, then Noel is not poised, and vice versa.\n¬(Hungry(x))→((Teak(x))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised.\n(∀x (Wicked(x) ∧ Mushy(x))) ↔ (∀x (Poised(x))) ::: Someone is wicked and mushy if and only if he is poised.\n(∃x (Poised(x) ∨ ¬Hungry(x))) → ((¬Mushy(george))) ::: If there is at least one people who is poised or not hungry, then George is not mushy.\n(∃x (Wicked(x) ∧ ¬Teak(x))) → ((Poised(crosby))) ::: If there is at least one people who is both wicked and not teak, then Crosby is poised.\n((Teak(keith))) ↔ ((¬Poised(gregory) ∧ ¬Wicked(noel))) ::: Keith is teak if and only if Gregory is not poised and Noel is not wicked.\n((Teak(noel))) ↔ ((Hungry(shane))) ::: Noel is teak if and only if Shane is hungry.\n((¬Teak(gregory) ∧ Wicked(crosby))) → ((¬Mushy(keith))) ::: If Gregory is not teak and Crosby is wicked, then Keith is not mushy.\n(∃x (Hungry(x) ∧ Wicked(x))) → ((Teak(noel))) ::: If there is at least one people who is both hungry and wicked, then Noel is teak.\n",
                "First-Order-Logic Question": "¬Mushy(noel) ::: Noel is not mushy."
            },
            "diff": [
                {
                    "raw": "(∀x (¬x)) → ((Teak(shane) ∧ ¬Poised(shane))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised.",
                    "gram": "¬(Hungry(x))→((Teak(x))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised."
                }
            ],
            "answer": "C",
            "grammar_answer": "A",
            "backup_answer": "C"
        },
        {
            "id": 121,
            "raw_prog": {
                "First-Order-Logic Rules": "¬Hungry(gregory) ::: Gregory is not hungry.\nMushy(ronald) ::: Ronald is mushy.\nTeak(keith) ::: Keith is teak.\nPoised(crosby) ::: Crosby is poised.\nFrank(shane) ::: Shane is frank.\nPoised(gregory) ::: Gregory is poised.\n¬Poised(shane) ::: Shane is not poised.\nMushy(keith) ::: Keith is mushy.\n¬Frank(noel) ::: Noel is not frank.\nFrank(george) ::: George is frank.\nWicked(george) ::: George is wicked.\nFrank(keith) ::: Keith is frank.\n(∀x (Mushy(x) ∨ ¬Poised(x))) → (∀x (Hungry(x) ∧ ¬Wicked(x))) ::: If someone is either mushy or not poised, then he is hungry and not wicked.\n(¬Poised(gregory)) → (Mushy(shane)) ::: If Gregory is not poised, then Shane is mushy.\n(∃x (Wicked(x))) → ((¬Poised(shane) ∧ ¬Frank(george))) ::: If there is at least one people who is wicked, then Shane is not poised and George is not frank.\n((Teak(noel))) ↔ ((¬Poised(noel))) ::: If Noel is teak, then Noel is not poised, and vice versa.\n(¬∃x (¬x)) → ((Teak(shane) ∧ ¬Poised(shane))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised.\n(∀x (Wicked(x) ∧ Mushy(x))) ↔ (∀x (Poised(x))) ::: Someone is wicked and mushy if and only if he is poised.\n(∃x (Poised(x) ∨ ¬Hungry(x))) → ((¬Mushy(george))) ::: If there is at least one people who is poised or not hungry, then George is not mushy.\n(∃x (Wicked(x) ∧ ¬Teak(x))) → ((Poised(crosby))) ::: If there is at least one people who is both wicked and not teak, then Crosby is poised.\n((Teak(keith))) ↔ ((¬Poised(gregory) ∧ ¬Wicked(noel))) ::: Keith is teak if and only if Gregory is not poised and Noel is not wicked.\n((Teak(noel))) ↔ ((Hungry(shane))) ::: Noel is teak if and only if Shane is hungry.\n((¬Teak(gregory) ∧ Wicked(crosby))) → ((¬Mushy(keith))) ::: If Gregory is not teak and Crosby is wicked, then Keith is not mushy.\n(∃x (Hungry(x) ∧ Wicked(x))) → ((Teak(noel))) ::: If there is at least one people who is both hungry and wicked, then Noel is teak.\n",
                "First-Order-Logic Question": "¬Mushy(shane) ::: Shane is not mushy."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "¬Hungry(gregory) ::: Gregory is not hungry.\nMushy(ronald) ::: Ronald is mushy.\nTeak(keith) ::: Keith is teak.\nPoised(crosby) ::: Crosby is poised.\nFrank(shane) ::: Shane is frank.\nPoised(gregory) ::: Gregory is poised.\n¬Poised(shane) ::: Shane is not poised.\nMushy(keith) ::: Keith is mushy.\n¬Frank(noel) ::: Noel is not frank.\nFrank(george) ::: George is frank.\nWicked(george) ::: George is wicked.\nFrank(keith) ::: Keith is frank.\n(∀x (Mushy(x) ∨ ¬Poised(x))) → (∀x (Hungry(x) ∧ ¬Wicked(x))) ::: If someone is either mushy or not poised, then he is hungry and not wicked.\n(¬Poised(gregory)) → (Mushy(shane)) ::: If Gregory is not poised, then Shane is mushy.\n(∃x (Wicked(x))) → ((¬Poised(shane) ∧ ¬Frank(george))) ::: If there is at least one people who is wicked, then Shane is not poised and George is not frank.\n((Teak(noel))) ↔ ((¬Poised(noel))) ::: If Noel is teak, then Noel is not poised, and vice versa.\n¬∃x((¬(¬Frank(x)))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised.\n(∀x (Wicked(x) ∧ Mushy(x))) ↔ (∀x (Poised(x))) ::: Someone is wicked and mushy if and only if he is poised.\n(∃x (Poised(x) ∨ ¬Hungry(x))) → ((¬Mushy(george))) ::: If there is at least one people who is poised or not hungry, then George is not mushy.\n(∃x (Wicked(x) ∧ ¬Teak(x))) → ((Poised(crosby))) ::: If there is at least one people who is both wicked and not teak, then Crosby is poised.\n((Teak(keith))) ↔ ((¬Poised(gregory) ∧ ¬Wicked(noel))) ::: Keith is teak if and only if Gregory is not poised and Noel is not wicked.\n((Teak(noel))) ↔ ((Hungry(shane))) ::: Noel is teak if and only if Shane is hungry.\n((¬Teak(gregory) ∧ Wicked(crosby))) → ((¬Mushy(keith))) ::: If Gregory is not teak and Crosby is wicked, then Keith is not mushy.\n(∃x (Hungry(x) ∧ Wicked(x))) → ((Teak(noel))) ::: If there is at least one people who is both hungry and wicked, then Noel is teak.\n",
                "First-Order-Logic Question": "¬Mushy(shane) ::: Shane is not mushy."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬x)) → ((Teak(shane) ∧ ¬Poised(shane))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised.",
                    "gram": "¬∃x((¬(¬Frank(x)))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised."
                }
            ],
            "answer": "B",
            "grammar_answer": "A",
            "backup_answer": "A"
        },
        {
            "id": 122,
            "raw_prog": {
                "First-Order-Logic Rules": "¬Hungry(gregory) ::: Gregory is not hungry.\nMushy(ronald) ::: Ronald is mushy.\nTeak(keith) ::: Keith is teak.\nPoised(crosby) ::: Crosby is poised.\nFrank(shane) ::: Shane is frank.\nPoised(gregory) ::: Gregory is poised.\n¬Poised(shane) ::: Shane is not poised.\nMushy(keith) ::: Keith is mushy.\n¬Frank(noel) ::: Noel is not frank.\nFrank(george) ::: George is frank.\nWicked(george) ::: George is wicked.\nFrank(keith) ::: Keith is frank.\n(∀x (Mushy(x) ∨ ¬Poised(x))) → (∀x (Hungry(x) ∧ ¬Wicked(x))) ::: If someone is either mushy or not poised, then he is hungry and not wicked.\n(¬Poised(gregory)) → (Mushy(shane)) ::: If Gregory is not poised, then Shane is mushy.\n(∃x (Wicked(x))) → ((¬Poised(shane) ∧ ¬Frank(george))) ::: If there is at least one people who is wicked, then Shane is not poised and George is not frank.\n((Teak(noel))) ↔ ((¬Poised(noel))) ::: If Noel is teak, then Noel is not poised, and vice versa.\n(¬∃x (¬x)) → ((Teak(shane) ∧ ¬Poised(shane))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised.\n(∀x (Wicked(x) ∧ Mushy(x))) ↔ (∀x (Poised(x))) ::: Someone is wicked and mushy if and only if he is poised.\n(∃x (Poised(x) ∨ ¬Hungry(x))) → ((¬Mushy(george))) ::: If there is at least one people who is poised or not hungry, then George is not mushy.\n(∃x (Wicked(x) ∧ ¬Teak(x))) → ((Poised(crosby))) ::: If there is at least one people who is both wicked and not teak, then Crosby is poised.\n((Teak(keith))) ↔ ((¬Poised(gregory) ∧ ¬Wicked(noel))) ::: Keith is teak if and only if Gregory is not poised and Noel is not wicked.\n((Teak(noel))) ↔ ((Hungry(shane))) ::: Noel is teak if and only if Shane is hungry.\n((¬Teak(gregory) ∧ Wicked(crosby))) → ((¬Mushy(keith))) ::: If Gregory is not teak and Crosby is wicked, then Keith is not mushy.\n(∃x (Hungry(x) ∧ Wicked(x))) → ((Teak(noel))) ::: If there is at least one people who is both hungry and wicked, then Noel is teak.\n",
                "First-Order-Logic Question": "Hungry(crosby) ::: Crosby is hungry."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "¬Hungry(gregory) ::: Gregory is not hungry.\nMushy(ronald) ::: Ronald is mushy.\nTeak(keith) ::: Keith is teak.\nPoised(crosby) ::: Crosby is poised.\nFrank(shane) ::: Shane is frank.\nPoised(gregory) ::: Gregory is poised.\n¬Poised(shane) ::: Shane is not poised.\nMushy(keith) ::: Keith is mushy.\n¬Frank(noel) ::: Noel is not frank.\nFrank(george) ::: George is frank.\nWicked(george) ::: George is wicked.\nFrank(keith) ::: Keith is frank.\n(∀x (Mushy(x) ∨ ¬Poised(x))) → (∀x (Hungry(x) ∧ ¬Wicked(x))) ::: If someone is either mushy or not poised, then he is hungry and not wicked.\n(¬Poised(gregory)) → (Mushy(shane)) ::: If Gregory is not poised, then Shane is mushy.\n(∃x (Wicked(x))) → ((¬Poised(shane) ∧ ¬Frank(george))) ::: If there is at least one people who is wicked, then Shane is not poised and George is not frank.\n((Teak(noel))) ↔ ((¬Poised(noel))) ::: If Noel is teak, then Noel is not poised, and vice versa.\n¬∃x((¬(¬Frank(x)))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised.\n(∀x (Wicked(x) ∧ Mushy(x))) ↔ (∀x (Poised(x))) ::: Someone is wicked and mushy if and only if he is poised.\n(∃x (Poised(x) ∨ ¬Hungry(x))) → ((¬Mushy(george))) ::: If there is at least one people who is poised or not hungry, then George is not mushy.\n(∃x (Wicked(x) ∧ ¬Teak(x))) → ((Poised(crosby))) ::: If there is at least one people who is both wicked and not teak, then Crosby is poised.\n((Teak(keith))) ↔ ((¬Poised(gregory) ∧ ¬Wicked(noel))) ::: Keith is teak if and only if Gregory is not poised and Noel is not wicked.\n((Teak(noel))) ↔ ((Hungry(shane))) ::: Noel is teak if and only if Shane is hungry.\n((¬Teak(gregory) ∧ Wicked(crosby))) → ((¬Mushy(keith))) ::: If Gregory is not teak and Crosby is wicked, then Keith is not mushy.\n(∃x (Hungry(x) ∧ Wicked(x))) → ((Teak(noel))) ::: If there is at least one people who is both hungry and wicked, then Noel is teak.\n",
                "First-Order-Logic Question": "Hungry(crosby) ::: Crosby is hungry."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬x)) → ((Teak(shane) ∧ ¬Poised(shane))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised.",
                    "gram": "¬∃x((¬(¬Frank(x)))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised."
                }
            ],
            "answer": "A",
            "grammar_answer": "A",
            "backup_answer": "B"
        },
        {
            "id": 123,
            "raw_prog": {
                "First-Order-Logic Rules": "¬Hungry(gregory) ::: Gregory is not hungry.\nMushy(ronald) ::: Ronald is mushy.\nTeak(keith) ::: Keith is teak.\nPoised(crosby) ::: Crosby is poised.\nFrank(shane) ::: Shane is frank.\nPoised(gregory) ::: Gregory is poised.\n¬Poised(shane) ::: Shane is not poised.\nMushy(keith) ::: Keith is mushy.\n¬Frank(noel) ::: Noel is not frank.\nFrank(george) ::: George is frank.\nWicked(george) ::: George is wicked.\nFrank(keith) ::: Keith is frank.\n(∀x (Mushy(x) ∨ ¬Poised(x))) → (∀x (Hungry(x) ∧ ¬Wicked(x))) ::: If someone is either mushy or not poised, then he is hungry and not wicked.\n(¬Poised(gregory)) → (Mushy(shane)) ::: If Gregory is not poised, then Shane is mushy.\n(∃x (Wicked(x))) → ((¬Poised(shane) ∧ ¬Frank(george))) ::: If there is at least one people who is wicked, then Shane is not poised and George is not frank.\n((Teak(noel))) ↔ ((¬Poised(noel))) ::: If Noel is teak, then Noel is not poised, and vice versa.\n(¬∃x (¬x)) → ((Teak(shane) ∧ ¬Poised(shane))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised.\n(∀x (Wicked(x) ∧ Mushy(x))) ↔ (∀x (Poised(x))) ::: Someone is wicked and mushy if and only if he is poised.\n(∃x (Poised(x) ∨ ¬Hungry(x))) → ((¬Mushy(george))) ::: If there is at least one people who is poised or not hungry, then George is not mushy.\n(∃x (Wicked(x) ∧ ¬Teak(x))) → ((Poised(crosby))) ::: If there is at least one people who is both wicked and not teak, then Crosby is poised.\n((Teak(keith))) ↔ ((¬Poised(gregory) ∧ ¬Wicked(noel))) ::: Keith is teak if and only if Gregory is not poised and Noel is not wicked.\n((Teak(noel))) ↔ ((Hungry(shane))) ::: Noel is teak if and only if Shane is hungry.\n((¬Teak(gregory) ∧ Wicked(crosby))) → ((¬Mushy(keith))) ::: If Gregory is not teak and Crosby is wicked, then Keith is not mushy.\n(∃x (Hungry(x) ∧ Wicked(x))) → ((Teak(noel))) ::: If there is at least one people who is both hungry and wicked, then Noel is teak.\n",
                "First-Order-Logic Question": "¬Wicked(shane) ::: Shane is not wicked."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "¬Hungry(gregory) ::: Gregory is not hungry.\nMushy(ronald) ::: Ronald is mushy.\nTeak(keith) ::: Keith is teak.\nPoised(crosby) ::: Crosby is poised.\nFrank(shane) ::: Shane is frank.\nPoised(gregory) ::: Gregory is poised.\n¬Poised(shane) ::: Shane is not poised.\nMushy(keith) ::: Keith is mushy.\n¬Frank(noel) ::: Noel is not frank.\nFrank(george) ::: George is frank.\nWicked(george) ::: George is wicked.\nFrank(keith) ::: Keith is frank.\n(∀x (Mushy(x) ∨ ¬Poised(x))) → (∀x (Hungry(x) ∧ ¬Wicked(x))) ::: If someone is either mushy or not poised, then he is hungry and not wicked.\n(¬Poised(gregory)) → (Mushy(shane)) ::: If Gregory is not poised, then Shane is mushy.\n(∃x (Wicked(x))) → ((¬Poised(shane) ∧ ¬Frank(george))) ::: If there is at least one people who is wicked, then Shane is not poised and George is not frank.\n((Teak(noel))) ↔ ((¬Poised(noel))) ::: If Noel is teak, then Noel is not poised, and vice versa.\n¬∃x((¬(¬Frank(x)))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised.\n(∀x (Wicked(x) ∧ Mushy(x))) ↔ (∀x (Poised(x))) ::: Someone is wicked and mushy if and only if he is poised.\n(∃x (Poised(x) ∨ ¬Hungry(x))) → ((¬Mushy(george))) ::: If there is at least one people who is poised or not hungry, then George is not mushy.\n(∃x (Wicked(x) ∧ ¬Teak(x))) → ((Poised(crosby))) ::: If there is at least one people who is both wicked and not teak, then Crosby is poised.\n((Teak(keith))) ↔ ((¬Poised(gregory) ∧ ¬Wicked(noel))) ::: Keith is teak if and only if Gregory is not poised and Noel is not wicked.\n((Teak(noel))) ↔ ((Hungry(shane))) ::: Noel is teak if and only if Shane is hungry.\n((¬Teak(gregory) ∧ Wicked(crosby))) → ((¬Mushy(keith))) ::: If Gregory is not teak and Crosby is wicked, then Keith is not mushy.\n(∃x (Hungry(x) ∧ Wicked(x))) → ((Teak(noel))) ::: If there is at least one people who is both hungry and wicked, then Noel is teak.\n",
                "First-Order-Logic Question": "¬Wicked(shane) ::: Shane is not wicked."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬x)) → ((Teak(shane) ∧ ¬Poised(shane))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised.",
                    "gram": "¬∃x((¬(¬Frank(x)))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised."
                }
            ],
            "answer": "A",
            "grammar_answer": "A",
            "backup_answer": "A"
        },
        {
            "id": 124,
            "raw_prog": {
                "First-Order-Logic Rules": "¬Hungry(gregory) ::: Gregory is not hungry.\nMushy(ronald) ::: Ronald is mushy.\nTeak(keith) ::: Keith is teak.\nPoised(crosby) ::: Crosby is poised.\nFrank(shane) ::: Shane is frank.\nPoised(gregory) ::: Gregory is poised.\n¬Poised(shane) ::: Shane is not poised.\nMushy(keith) ::: Keith is mushy.\n¬Frank(noel) ::: Noel is not frank.\nFrank(george) ::: George is frank.\nWicked(george) ::: George is wicked.\nFrank(keith) ::: Keith is frank.\n(∀x (Mushy(x) ∨ ¬Poised(x))) → (∀x (Hungry(x) ∧ ¬Wicked(x))) ::: If someone is either mushy or not poised, then he is hungry and not wicked.\n(¬Poised(gregory)) → (Mushy(shane)) ::: If Gregory is not poised, then Shane is mushy.\n(∃x (Wicked(x))) → ((¬Poised(shane) ∧ ¬Frank(george))) ::: If there is at least one people who is wicked, then Shane is not poised and George is not frank.\n((Teak(noel))) ↔ ((¬Poised(noel))) ::: If Noel is teak, then Noel is not poised, and vice versa.\n(¬∃x (¬x)) → ((Teak(shane) ∧ ¬Poised(shane))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised.\n(∀x (Wicked(x) ∧ Mushy(x))) ↔ (∀x (Poised(x))) ::: Someone is wicked and mushy if and only if he is poised.\n(∃x (Poised(x) ∨ ¬Hungry(x))) → ((¬Mushy(george))) ::: If there is at least one people who is poised or not hungry, then George is not mushy.\n(∃x (Wicked(x) ∧ ¬Teak(x))) → ((Poised(crosby))) ::: If there is at least one people who is both wicked and not teak, then Crosby is poised.\n((Teak(keith))) ↔ ((¬Poised(gregory) ∧ ¬Wicked(noel))) ::: Keith is teak if and only if Gregory is not poised and Noel is not wicked.\n((Teak(noel))) ↔ ((Hungry(shane))) ::: Noel is teak if and only if Shane is hungry.\n((¬Teak(gregory) ∧ Wicked(crosby))) → ((¬Mushy(keith))) ::: If Gregory is not teak and Crosby is wicked, then Keith is not mushy.\n(∃x (Hungry(x) ∧ Wicked(x))) → ((Teak(noel))) ::: If there is at least one people who is both hungry and wicked, then Noel is teak.\n",
                "First-Order-Logic Question": "¬Hungry(shane) ::: Shane is not hungry."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "¬Hungry(gregory) ::: Gregory is not hungry.\nMushy(ronald) ::: Ronald is mushy.\nTeak(keith) ::: Keith is teak.\nPoised(crosby) ::: Crosby is poised.\nFrank(shane) ::: Shane is frank.\nPoised(gregory) ::: Gregory is poised.\n¬Poised(shane) ::: Shane is not poised.\nMushy(keith) ::: Keith is mushy.\n¬Frank(noel) ::: Noel is not frank.\nFrank(george) ::: George is frank.\nWicked(george) ::: George is wicked.\nFrank(keith) ::: Keith is frank.\n(∀x (Mushy(x) ∨ ¬Poised(x))) → (∀x (Hungry(x) ∧ ¬Wicked(x))) ::: If someone is either mushy or not poised, then he is hungry and not wicked.\n(¬Poised(gregory)) → (Mushy(shane)) ::: If Gregory is not poised, then Shane is mushy.\n(∃x (Wicked(x))) → ((¬Poised(shane) ∧ ¬Frank(george))) ::: If there is at least one people who is wicked, then Shane is not poised and George is not frank.\n((Teak(noel))) ↔ ((¬Poised(noel))) ::: If Noel is teak, then Noel is not poised, and vice versa.\n¬∃x((¬(¬Frank(x)))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised.\n(∀x (Wicked(x) ∧ Mushy(x))) ↔ (∀x (Poised(x))) ::: Someone is wicked and mushy if and only if he is poised.\n(∃x (Poised(x) ∨ ¬Hungry(x))) → ((¬Mushy(george))) ::: If there is at least one people who is poised or not hungry, then George is not mushy.\n(∃x (Wicked(x) ∧ ¬Teak(x))) → ((Poised(crosby))) ::: If there is at least one people who is both wicked and not teak, then Crosby is poised.\n((Teak(keith))) ↔ ((¬Poised(gregory) ∧ ¬Wicked(noel))) ::: Keith is teak if and only if Gregory is not poised and Noel is not wicked.\n((Teak(noel))) ↔ ((Hungry(shane))) ::: Noel is teak if and only if Shane is hungry.\n((¬Teak(gregory) ∧ Wicked(crosby))) → ((¬Mushy(keith))) ::: If Gregory is not teak and Crosby is wicked, then Keith is not mushy.\n(∃x (Hungry(x) ∧ Wicked(x))) → ((Teak(noel))) ::: If there is at least one people who is both hungry and wicked, then Noel is teak.\n",
                "First-Order-Logic Question": "¬Hungry(shane) ::: Shane is not hungry."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬x)) → ((Teak(shane) ∧ ¬Poised(shane))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised.",
                    "gram": "¬∃x((¬(¬Frank(x)))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised."
                }
            ],
            "answer": "B",
            "grammar_answer": "A",
            "backup_answer": "B"
        },
        {
            "id": 125,
            "raw_prog": {
                "First-Order-Logic Rules": "¬Hungry(gregory) ::: Gregory is not hungry.\nMushy(ronald) ::: Ronald is mushy.\nTeak(keith) ::: Keith is teak.\nPoised(crosby) ::: Crosby is poised.\nFrank(shane) ::: Shane is frank.\nPoised(gregory) ::: Gregory is poised.\n¬Poised(shane) ::: Shane is not poised.\nMushy(keith) ::: Keith is mushy.\n¬Frank(noel) ::: Noel is not frank.\nFrank(george) ::: George is frank.\nWicked(george) ::: George is wicked.\nFrank(keith) ::: Keith is frank.\n(∀x (Mushy(x) ∨ ¬Poised(x))) → (∀x (Hungry(x) ∧ ¬Wicked(x))) ::: If someone is either mushy or not poised, then he is hungry and not wicked.\n(¬Poised(gregory)) → (Mushy(shane)) ::: If Gregory is not poised, then Shane is mushy.\n(∃x (Wicked(x))) → ((¬Poised(shane) ∧ ¬Frank(george))) ::: If there is at least one people who is wicked, then Shane is not poised and George is not frank.\n((Teak(noel))) ↔ ((¬Poised(noel))) ::: If Noel is teak, then Noel is not poised, and vice versa.\n(∀x (¬x)) → ((Teak(shane) ∧ ¬Poised(shane))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised.\n(∀x (Wicked(x) ∧ Mushy(x))) ↔ (∀x (Poised(x))) ::: Someone is wicked and mushy if and only if he is poised.\n(∃x (Poised(x) ∨ ¬Hungry(x))) → ((¬Mushy(george))) ::: If there is at least one people who is poised or not hungry, then George is not mushy.\n(∃x (Wicked(x) ∧ ¬Teak(x))) → ((Poised(crosby))) ::: If there is at least one people who is both wicked and not teak, then Crosby is poised.\n((Teak(keith))) ↔ ((¬Poised(gregory) ∧ ¬Wicked(noel))) ::: Keith is teak if and only if Gregory is not poised and Noel is not wicked.\n((Teak(noel))) ↔ ((Hungry(shane))) ::: Noel is teak if and only if Shane is hungry.\n((¬Teak(gregory) ∧ Wicked(crosby))) → ((¬Mushy(keith))) ::: If Gregory is not teak and Crosby is wicked, then Keith is not mushy.\n(∃x (Hungry(x) ∧ Wicked(x))) → ((Teak(noel))) ::: If there is at least one people who is both hungry and wicked, then Noel is teak.\n",
                "First-Order-Logic Question": "Mushy(noel) ::: Noel is mushy."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "¬Hungry(gregory) ::: Gregory is not hungry.\nMushy(ronald) ::: Ronald is mushy.\nTeak(keith) ::: Keith is teak.\nPoised(crosby) ::: Crosby is poised.\nFrank(shane) ::: Shane is frank.\nPoised(gregory) ::: Gregory is poised.\n¬Poised(shane) ::: Shane is not poised.\nMushy(keith) ::: Keith is mushy.\n¬Frank(noel) ::: Noel is not frank.\nFrank(george) ::: George is frank.\nWicked(george) ::: George is wicked.\nFrank(keith) ::: Keith is frank.\n(∀x (Mushy(x) ∨ ¬Poised(x))) → (∀x (Hungry(x) ∧ ¬Wicked(x))) ::: If someone is either mushy or not poised, then he is hungry and not wicked.\n(¬Poised(gregory)) → (Mushy(shane)) ::: If Gregory is not poised, then Shane is mushy.\n(∃x (Wicked(x))) → ((¬Poised(shane) ∧ ¬Frank(george))) ::: If there is at least one people who is wicked, then Shane is not poised and George is not frank.\n((Teak(noel))) ↔ ((¬Poised(noel))) ::: If Noel is teak, then Noel is not poised, and vice versa.\n¬(Hungry(x))→((Teak(x))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised.\n(∀x (Wicked(x) ∧ Mushy(x))) ↔ (∀x (Poised(x))) ::: Someone is wicked and mushy if and only if he is poised.\n(∃x (Poised(x) ∨ ¬Hungry(x))) → ((¬Mushy(george))) ::: If there is at least one people who is poised or not hungry, then George is not mushy.\n(∃x (Wicked(x) ∧ ¬Teak(x))) → ((Poised(crosby))) ::: If there is at least one people who is both wicked and not teak, then Crosby is poised.\n((Teak(keith))) ↔ ((¬Poised(gregory) ∧ ¬Wicked(noel))) ::: Keith is teak if and only if Gregory is not poised and Noel is not wicked.\n((Teak(noel))) ↔ ((Hungry(shane))) ::: Noel is teak if and only if Shane is hungry.\n((¬Teak(gregory) ∧ Wicked(crosby))) → ((¬Mushy(keith))) ::: If Gregory is not teak and Crosby is wicked, then Keith is not mushy.\n(∃x (Hungry(x) ∧ Wicked(x))) → ((Teak(noel))) ::: If there is at least one people who is both hungry and wicked, then Noel is teak.\n",
                "First-Order-Logic Question": "Mushy(noel) ::: Noel is mushy."
            },
            "diff": [
                {
                    "raw": "(∀x (¬x)) → ((Teak(shane) ∧ ¬Poised(shane))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised.",
                    "gram": "¬(Hungry(x))→((Teak(x))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised."
                }
            ],
            "answer": "C",
            "grammar_answer": "A",
            "backup_answer": "B"
        },
        {
            "id": 126,
            "raw_prog": {
                "First-Order-Logic Rules": "¬Hungry(gregory) ::: Gregory is not hungry.\nMushy(ronald) ::: Ronald is mushy.\nTeak(keith) ::: Keith is teak.\nPoised(crosby) ::: Crosby is poised.\nFrank(shane) ::: Shane is frank.\nPoised(gregory) ::: Gregory is poised.\n¬Poised(shane) ::: Shane is not poised.\nMushy(keith) ::: Keith is mushy.\n¬Frank(noel) ::: Noel is not frank.\nFrank(george) ::: George is frank.\nWicked(george) ::: George is wicked.\nFrank(keith) ::: Keith is frank.\n(∀x (Mushy(x) ∨ ¬Poised(x))) → (∀x (Hungry(x) ∧ ¬Wicked(x))) ::: If someone is either mushy or not poised, then he is hungry and not wicked.\n(¬Poised(gregory)) → (Mushy(shane)) ::: If Gregory is not poised, then Shane is mushy.\n(∃x (Wicked(x))) → ((¬Poised(shane) ∧ ¬Frank(george))) ::: If there is at least one people who is wicked, then Shane is not poised and George is not frank.\n((Teak(noel))) ↔ ((¬Poised(noel))) ::: If Noel is teak, then Noel is not poised, and vice versa.\n(¬∃x (¬x)) → ((Teak(shane) ∧ ¬Poised(shane))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised.\n(∀x (Wicked(x) ∧ Mushy(x))) ↔ (∀x (Poised(x))) ::: Someone is wicked and mushy if and only if he is poised.\n(∃x (Poised(x) ∨ ¬Hungry(x))) → ((¬Mushy(george))) ::: If there is at least one people who is poised or not hungry, then George is not mushy.\n(∃x (Wicked(x) ∧ ¬Teak(x))) → ((Poised(crosby))) ::: If there is at least one people who is both wicked and not teak, then Crosby is poised.\n((Teak(keith))) ↔ ((¬Poised(gregory) ∧ ¬Wicked(noel))) ::: Keith is teak if and only if Gregory is not poised and Noel is not wicked.\n((Teak(noel))) ↔ ((Hungry(shane))) ::: Noel is teak if and only if Shane is hungry.\n((¬Teak(gregory) ∧ Wicked(crosby))) → ((¬Mushy(keith))) ::: If Gregory is not teak and Crosby is wicked, then Keith is not mushy.\n(∃x (Hungry(x) ∧ Wicked(x))) → ((Teak(noel))) ::: If there is at least one people who is both hungry and wicked, then Noel is teak.\n",
                "First-Order-Logic Question": "¬Mushy(george) ::: George is not mushy."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "¬Hungry(gregory) ::: Gregory is not hungry.\nMushy(ronald) ::: Ronald is mushy.\nTeak(keith) ::: Keith is teak.\nPoised(crosby) ::: Crosby is poised.\nFrank(shane) ::: Shane is frank.\nPoised(gregory) ::: Gregory is poised.\n¬Poised(shane) ::: Shane is not poised.\nMushy(keith) ::: Keith is mushy.\n¬Frank(noel) ::: Noel is not frank.\nFrank(george) ::: George is frank.\nWicked(george) ::: George is wicked.\nFrank(keith) ::: Keith is frank.\n(∀x (Mushy(x) ∨ ¬Poised(x))) → (∀x (Hungry(x) ∧ ¬Wicked(x))) ::: If someone is either mushy or not poised, then he is hungry and not wicked.\n(¬Poised(gregory)) → (Mushy(shane)) ::: If Gregory is not poised, then Shane is mushy.\n(∃x (Wicked(x))) → ((¬Poised(shane) ∧ ¬Frank(george))) ::: If there is at least one people who is wicked, then Shane is not poised and George is not frank.\n((Teak(noel))) ↔ ((¬Poised(noel))) ::: If Noel is teak, then Noel is not poised, and vice versa.\n¬∃x((¬(¬Frank(x)))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised.\n(∀x (Wicked(x) ∧ Mushy(x))) ↔ (∀x (Poised(x))) ::: Someone is wicked and mushy if and only if he is poised.\n(∃x (Poised(x) ∨ ¬Hungry(x))) → ((¬Mushy(george))) ::: If there is at least one people who is poised or not hungry, then George is not mushy.\n(∃x (Wicked(x) ∧ ¬Teak(x))) → ((Poised(crosby))) ::: If there is at least one people who is both wicked and not teak, then Crosby is poised.\n((Teak(keith))) ↔ ((¬Poised(gregory) ∧ ¬Wicked(noel))) ::: Keith is teak if and only if Gregory is not poised and Noel is not wicked.\n((Teak(noel))) ↔ ((Hungry(shane))) ::: Noel is teak if and only if Shane is hungry.\n((¬Teak(gregory) ∧ Wicked(crosby))) → ((¬Mushy(keith))) ::: If Gregory is not teak and Crosby is wicked, then Keith is not mushy.\n(∃x (Hungry(x) ∧ Wicked(x))) → ((Teak(noel))) ::: If there is at least one people who is both hungry and wicked, then Noel is teak.\n",
                "First-Order-Logic Question": "¬Mushy(george) ::: George is not mushy."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬x)) → ((Teak(shane) ∧ ¬Poised(shane))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised.",
                    "gram": "¬∃x((¬(¬Frank(x)))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised."
                }
            ],
            "answer": "A",
            "grammar_answer": "A",
            "backup_answer": "A"
        },
        {
            "id": 127,
            "raw_prog": {
                "First-Order-Logic Rules": "¬Hungry(gregory) ::: Gregory is not hungry.\nMushy(ronald) ::: Ronald is mushy.\nTeak(keith) ::: Keith is teak.\nPoised(crosby) ::: Crosby is poised.\nFrank(shane) ::: Shane is frank.\nPoised(gregory) ::: Gregory is poised.\n¬Poised(shane) ::: Shane is not poised.\nMushy(keith) ::: Keith is mushy.\n¬Frank(noel) ::: Noel is not frank.\nFrank(george) ::: George is frank.\nWicked(george) ::: George is wicked.\nFrank(keith) ::: Keith is frank.\n(∀x (Mushy(x) ∨ ¬Poised(x))) → (∀x (Hungry(x) ∧ ¬Wicked(x))) ::: If someone is either mushy or not poised, then he is hungry and not wicked.\n(¬Poised(gregory)) → (Mushy(shane)) ::: If Gregory is not poised, then Shane is mushy.\n(∃x (Wicked(x))) → ((¬Poised(shane) ∧ ¬Frank(george))) ::: If there is at least one people who is wicked, then Shane is not poised and George is not frank.\n((Teak(noel))) ↔ ((¬Poised(noel))) ::: If Noel is teak, then Noel is not poised, and vice versa.\n(¬∃x (¬x)) → ((Teak(shane) ∧ ¬Poised(shane))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised.\n(∀x (Wicked(x) ∧ Mushy(x))) ↔ (∀x (Poised(x))) ::: Someone is wicked and mushy if and only if he is poised.\n(∃x (Poised(x) ∨ ¬Hungry(x))) → ((¬Mushy(george))) ::: If there is at least one people who is poised or not hungry, then George is not mushy.\n(∃x (Wicked(x) ∧ ¬Teak(x))) → ((Poised(crosby))) ::: If there is at least one people who is both wicked and not teak, then Crosby is poised.\n((Teak(keith))) ↔ ((¬Poised(gregory) ∧ ¬Wicked(noel))) ::: Keith is teak if and only if Gregory is not poised and Noel is not wicked.\n((Teak(noel))) ↔ ((Hungry(shane))) ::: Noel is teak if and only if Shane is hungry.\n((¬Teak(gregory) ∧ Wicked(crosby))) → ((¬Mushy(keith))) ::: If Gregory is not teak and Crosby is wicked, then Keith is not mushy.\n(∃x (Hungry(x) ∧ Wicked(x))) → ((Teak(noel))) ::: If there is at least one people who is both hungry and wicked, then Noel is teak.\n",
                "First-Order-Logic Question": "¬Teak(ronald) ::: Ronald is not teak."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "¬Hungry(gregory) ::: Gregory is not hungry.\nMushy(ronald) ::: Ronald is mushy.\nTeak(keith) ::: Keith is teak.\nPoised(crosby) ::: Crosby is poised.\nFrank(shane) ::: Shane is frank.\nPoised(gregory) ::: Gregory is poised.\n¬Poised(shane) ::: Shane is not poised.\nMushy(keith) ::: Keith is mushy.\n¬Frank(noel) ::: Noel is not frank.\nFrank(george) ::: George is frank.\nWicked(george) ::: George is wicked.\nFrank(keith) ::: Keith is frank.\n(∀x (Mushy(x) ∨ ¬Poised(x))) → (∀x (Hungry(x) ∧ ¬Wicked(x))) ::: If someone is either mushy or not poised, then he is hungry and not wicked.\n(¬Poised(gregory)) → (Mushy(shane)) ::: If Gregory is not poised, then Shane is mushy.\n(∃x (Wicked(x))) → ((¬Poised(shane) ∧ ¬Frank(george))) ::: If there is at least one people who is wicked, then Shane is not poised and George is not frank.\n((Teak(noel))) ↔ ((¬Poised(noel))) ::: If Noel is teak, then Noel is not poised, and vice versa.\n¬∃x((¬(¬Frank(x)))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised.\n(∀x (Wicked(x) ∧ Mushy(x))) ↔ (∀x (Poised(x))) ::: Someone is wicked and mushy if and only if he is poised.\n(∃x (Poised(x) ∨ ¬Hungry(x))) → ((¬Mushy(george))) ::: If there is at least one people who is poised or not hungry, then George is not mushy.\n(∃x (Wicked(x) ∧ ¬Teak(x))) → ((Poised(crosby))) ::: If there is at least one people who is both wicked and not teak, then Crosby is poised.\n((Teak(keith))) ↔ ((¬Poised(gregory) ∧ ¬Wicked(noel))) ::: Keith is teak if and only if Gregory is not poised and Noel is not wicked.\n((Teak(noel))) ↔ ((Hungry(shane))) ::: Noel is teak if and only if Shane is hungry.\n((¬Teak(gregory) ∧ Wicked(crosby))) → ((¬Mushy(keith))) ::: If Gregory is not teak and Crosby is wicked, then Keith is not mushy.\n(∃x (Hungry(x) ∧ Wicked(x))) → ((Teak(noel))) ::: If there is at least one people who is both hungry and wicked, then Noel is teak.\n",
                "First-Order-Logic Question": "¬Teak(ronald) ::: Ronald is not teak."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬x)) → ((Teak(shane) ∧ ¬Poised(shane))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised.",
                    "gram": "¬∃x((¬(¬Frank(x)))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised."
                }
            ],
            "answer": "C",
            "grammar_answer": "A",
            "backup_answer": "C"
        },
        {
            "id": 128,
            "raw_prog": {
                "First-Order-Logic Rules": "¬Hungry(gregory) ::: Gregory is not hungry.\nMushy(ronald) ::: Ronald is mushy.\nTeak(keith) ::: Keith is teak.\nPoised(crosby) ::: Crosby is poised.\nFrank(shane) ::: Shane is frank.\nPoised(gregory) ::: Gregory is poised.\n¬Poised(shane) ::: Shane is not poised.\nMushy(keith) ::: Keith is mushy.\n¬Frank(noel) ::: Noel is not frank.\nFrank(george) ::: George is frank.\nWicked(george) ::: George is wicked.\nFrank(keith) ::: Keith is frank.\n(∀x (Mushy(x) ∨ ¬Poised(x))) → (∀x (Hungry(x) ∧ ¬Wicked(x))) ::: If someone is either mushy or not poised, then he is hungry and not wicked.\n(¬Poised(gregory)) → (Mushy(shane)) ::: If Gregory is not poised, then Shane is mushy.\n(∃x (Wicked(x))) → ((¬Poised(shane) ∧ ¬Frank(george))) ::: If there is at least one people who is wicked, then Shane is not poised and George is not frank.\n((Teak(noel))) ↔ ((¬Poised(noel))) ::: If Noel is teak, then Noel is not poised, and vice versa.\n(¬∃x (¬x)) → ((Teak(shane) ∧ ¬Poised(shane))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised.\n(∀x (Wicked(x) ∧ Mushy(x))) ↔ (∀x (Poised(x))) ::: Someone is wicked and mushy if and only if he is poised.\n(∃x (Poised(x) ∨ ¬Hungry(x))) → ((¬Mushy(george))) ::: If there is at least one people who is poised or not hungry, then George is not mushy.\n(∃x (Wicked(x) ∧ ¬Teak(x))) → ((Poised(crosby))) ::: If there is at least one people who is both wicked and not teak, then Crosby is poised.\n((Teak(keith))) ↔ ((¬Poised(gregory) ∧ ¬Wicked(noel))) ::: Keith is teak if and only if Gregory is not poised and Noel is not wicked.\n((Teak(noel))) ↔ ((Hungry(shane))) ::: Noel is teak if and only if Shane is hungry.\n((¬Teak(gregory) ∧ Wicked(crosby))) → ((¬Mushy(keith))) ::: If Gregory is not teak and Crosby is wicked, then Keith is not mushy.\n(∃x (Hungry(x) ∧ Wicked(x))) → ((Teak(noel))) ::: If there is at least one people who is both hungry and wicked, then Noel is teak.\n",
                "First-Order-Logic Question": "¬Hungry(crosby) ::: Crosby is not hungry."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "¬Hungry(gregory) ::: Gregory is not hungry.\nMushy(ronald) ::: Ronald is mushy.\nTeak(keith) ::: Keith is teak.\nPoised(crosby) ::: Crosby is poised.\nFrank(shane) ::: Shane is frank.\nPoised(gregory) ::: Gregory is poised.\n¬Poised(shane) ::: Shane is not poised.\nMushy(keith) ::: Keith is mushy.\n¬Frank(noel) ::: Noel is not frank.\nFrank(george) ::: George is frank.\nWicked(george) ::: George is wicked.\nFrank(keith) ::: Keith is frank.\n(∀x (Mushy(x) ∨ ¬Poised(x))) → (∀x (Hungry(x) ∧ ¬Wicked(x))) ::: If someone is either mushy or not poised, then he is hungry and not wicked.\n(¬Poised(gregory)) → (Mushy(shane)) ::: If Gregory is not poised, then Shane is mushy.\n(∃x (Wicked(x))) → ((¬Poised(shane) ∧ ¬Frank(george))) ::: If there is at least one people who is wicked, then Shane is not poised and George is not frank.\n((Teak(noel))) ↔ ((¬Poised(noel))) ::: If Noel is teak, then Noel is not poised, and vice versa.\n¬∃x((¬(¬Frank(x)))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised.\n(∀x (Wicked(x) ∧ Mushy(x))) ↔ (∀x (Poised(x))) ::: Someone is wicked and mushy if and only if he is poised.\n(∃x (Poised(x) ∨ ¬Hungry(x))) → ((¬Mushy(george))) ::: If there is at least one people who is poised or not hungry, then George is not mushy.\n(∃x (Wicked(x) ∧ ¬Teak(x))) → ((Poised(crosby))) ::: If there is at least one people who is both wicked and not teak, then Crosby is poised.\n((Teak(keith))) ↔ ((¬Poised(gregory) ∧ ¬Wicked(noel))) ::: Keith is teak if and only if Gregory is not poised and Noel is not wicked.\n((Teak(noel))) ↔ ((Hungry(shane))) ::: Noel is teak if and only if Shane is hungry.\n((¬Teak(gregory) ∧ Wicked(crosby))) → ((¬Mushy(keith))) ::: If Gregory is not teak and Crosby is wicked, then Keith is not mushy.\n(∃x (Hungry(x) ∧ Wicked(x))) → ((Teak(noel))) ::: If there is at least one people who is both hungry and wicked, then Noel is teak.\n",
                "First-Order-Logic Question": "¬Hungry(crosby) ::: Crosby is not hungry."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬x)) → ((Teak(shane) ∧ ¬Poised(shane))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised.",
                    "gram": "¬∃x((¬(¬Frank(x)))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised."
                }
            ],
            "answer": "B",
            "grammar_answer": "A",
            "backup_answer": "C"
        },
        {
            "id": 129,
            "raw_prog": {
                "First-Order-Logic Rules": "¬Hungry(gregory) ::: Gregory is not hungry.\nMushy(ronald) ::: Ronald is mushy.\nTeak(keith) ::: Keith is teak.\nPoised(crosby) ::: Crosby is poised.\nFrank(shane) ::: Shane is frank.\nPoised(gregory) ::: Gregory is poised.\n¬Poised(shane) ::: Shane is not poised.\nMushy(keith) ::: Keith is mushy.\n¬Frank(noel) ::: Noel is not frank.\nFrank(george) ::: George is frank.\nWicked(george) ::: George is wicked.\nFrank(keith) ::: Keith is frank.\n(∀x (Mushy(x) ∨ ¬Poised(x))) → (∀x (Hungry(x) ∧ ¬Wicked(x))) ::: If someone is either mushy or not poised, then he is hungry and not wicked.\n(¬Poised(gregory)) → (Mushy(shane)) ::: If Gregory is not poised, then Shane is mushy.\n(∃x (Wicked(x))) → ((¬Poised(shane) ∧ ¬Frank(george))) ::: If there is at least one people who is wicked, then Shane is not poised and George is not frank.\n((Teak(noel))) ↔ ((¬Poised(noel))) ::: If Noel is teak, then Noel is not poised, and vice versa.\n(¬∃x (¬x)) → ((Teak(shane) ∧ ¬Poised(shane))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised.\n(∀x (Wicked(x) ∧ Mushy(x))) ↔ (∀x (Poised(x))) ::: Someone is wicked and mushy if and only if he is poised.\n(∃x (Poised(x) ∨ ¬Hungry(x))) → ((¬Mushy(george))) ::: If there is at least one people who is poised or not hungry, then George is not mushy.\n(∃x (Wicked(x) ∧ ¬Teak(x))) → ((Poised(crosby))) ::: If there is at least one people who is both wicked and not teak, then Crosby is poised.\n((Teak(keith))) ↔ ((¬Poised(gregory) ∧ ¬Wicked(noel))) ::: Keith is teak if and only if Gregory is not poised and Noel is not wicked.\n((Teak(noel))) ↔ ((Hungry(shane))) ::: Noel is teak if and only if Shane is hungry.\n((¬Teak(gregory) ∧ Wicked(crosby))) → ((¬Mushy(keith))) ::: If Gregory is not teak and Crosby is wicked, then Keith is not mushy.\n(∃x (Hungry(x) ∧ Wicked(x))) → ((Teak(noel))) ::: If there is at least one people who is both hungry and wicked, then Noel is teak.\n",
                "First-Order-Logic Question": "¬Mushy(keith) ::: Keith is not mushy."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "¬Hungry(gregory) ::: Gregory is not hungry.\nMushy(ronald) ::: Ronald is mushy.\nTeak(keith) ::: Keith is teak.\nPoised(crosby) ::: Crosby is poised.\nFrank(shane) ::: Shane is frank.\nPoised(gregory) ::: Gregory is poised.\n¬Poised(shane) ::: Shane is not poised.\nMushy(keith) ::: Keith is mushy.\n¬Frank(noel) ::: Noel is not frank.\nFrank(george) ::: George is frank.\nWicked(george) ::: George is wicked.\nFrank(keith) ::: Keith is frank.\n(∀x (Mushy(x) ∨ ¬Poised(x))) → (∀x (Hungry(x) ∧ ¬Wicked(x))) ::: If someone is either mushy or not poised, then he is hungry and not wicked.\n(¬Poised(gregory)) → (Mushy(shane)) ::: If Gregory is not poised, then Shane is mushy.\n(∃x (Wicked(x))) → ((¬Poised(shane) ∧ ¬Frank(george))) ::: If there is at least one people who is wicked, then Shane is not poised and George is not frank.\n((Teak(noel))) ↔ ((¬Poised(noel))) ::: If Noel is teak, then Noel is not poised, and vice versa.\n¬∃x((¬(¬Frank(x)))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised.\n(∀x (Wicked(x) ∧ Mushy(x))) ↔ (∀x (Poised(x))) ::: Someone is wicked and mushy if and only if he is poised.\n(∃x (Poised(x) ∨ ¬Hungry(x))) → ((¬Mushy(george))) ::: If there is at least one people who is poised or not hungry, then George is not mushy.\n(∃x (Wicked(x) ∧ ¬Teak(x))) → ((Poised(crosby))) ::: If there is at least one people who is both wicked and not teak, then Crosby is poised.\n((Teak(keith))) ↔ ((¬Poised(gregory) ∧ ¬Wicked(noel))) ::: Keith is teak if and only if Gregory is not poised and Noel is not wicked.\n((Teak(noel))) ↔ ((Hungry(shane))) ::: Noel is teak if and only if Shane is hungry.\n((¬Teak(gregory) ∧ Wicked(crosby))) → ((¬Mushy(keith))) ::: If Gregory is not teak and Crosby is wicked, then Keith is not mushy.\n(∃x (Hungry(x) ∧ Wicked(x))) → ((Teak(noel))) ::: If there is at least one people who is both hungry and wicked, then Noel is teak.\n",
                "First-Order-Logic Question": "¬Mushy(keith) ::: Keith is not mushy."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬x)) → ((Teak(shane) ∧ ¬Poised(shane))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised.",
                    "gram": "¬∃x((¬(¬Frank(x)))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised."
                }
            ],
            "answer": "B",
            "grammar_answer": "A",
            "backup_answer": "B"
        },
        {
            "id": 130,
            "raw_prog": {
                "First-Order-Logic Rules": "¬Hungry(gregory) ::: Gregory is not hungry.\nMushy(ronald) ::: Ronald is mushy.\nTeak(keith) ::: Keith is teak.\nPoised(crosby) ::: Crosby is poised.\nFrank(shane) ::: Shane is frank.\nPoised(gregory) ::: Gregory is poised.\n¬Poised(shane) ::: Shane is not poised.\nMushy(keith) ::: Keith is mushy.\n¬Frank(noel) ::: Noel is not frank.\nFrank(george) ::: George is frank.\nWicked(george) ::: George is wicked.\nFrank(keith) ::: Keith is frank.\n(∀x (Mushy(x) ∨ ¬Poised(x))) → (∀x (Hungry(x) ∧ ¬Wicked(x))) ::: If someone is either mushy or not poised, then he is hungry and not wicked.\n(¬Poised(gregory)) → (Mushy(shane)) ::: If Gregory is not poised, then Shane is mushy.\n(∃x (Wicked(x))) → ((¬Poised(shane) ∧ ¬Frank(george))) ::: If there is at least one people who is wicked, then Shane is not poised and George is not frank.\n((Teak(noel))) ↔ ((¬Poised(noel))) ::: If Noel is teak, then Noel is not poised, and vice versa.\n(¬∃x (¬x)) → ((Teak(shane) ∧ ¬Poised(shane))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised.\n(∀x (Wicked(x) ∧ Mushy(x))) ↔ (∀x (Poised(x))) ::: Someone is wicked and mushy if and only if he is poised.\n(∃x (Poised(x) ∨ ¬Hungry(x))) → ((¬Mushy(george))) ::: If there is at least one people who is poised or not hungry, then George is not mushy.\n(∃x (Wicked(x) ∧ ¬Teak(x))) → ((Poised(crosby))) ::: If there is at least one people who is both wicked and not teak, then Crosby is poised.\n((Teak(keith))) ↔ ((¬Poised(gregory) ∧ ¬Wicked(noel))) ::: Keith is teak if and only if Gregory is not poised and Noel is not wicked.\n((Teak(noel))) ↔ ((Hungry(shane))) ::: Noel is teak if and only if Shane is hungry.\n((¬Teak(gregory) ∧ Wicked(crosby))) → ((¬Mushy(keith))) ::: If Gregory is not teak and Crosby is wicked, then Keith is not mushy.\n(∃x (Hungry(x) ∧ Wicked(x))) → ((Teak(noel))) ::: If there is at least one people who is both hungry and wicked, then Noel is teak.\n",
                "First-Order-Logic Question": "Poised(keith) ::: Keith is poised."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "¬Hungry(gregory) ::: Gregory is not hungry.\nMushy(ronald) ::: Ronald is mushy.\nTeak(keith) ::: Keith is teak.\nPoised(crosby) ::: Crosby is poised.\nFrank(shane) ::: Shane is frank.\nPoised(gregory) ::: Gregory is poised.\n¬Poised(shane) ::: Shane is not poised.\nMushy(keith) ::: Keith is mushy.\n¬Frank(noel) ::: Noel is not frank.\nFrank(george) ::: George is frank.\nWicked(george) ::: George is wicked.\nFrank(keith) ::: Keith is frank.\n(∀x (Mushy(x) ∨ ¬Poised(x))) → (∀x (Hungry(x) ∧ ¬Wicked(x))) ::: If someone is either mushy or not poised, then he is hungry and not wicked.\n(¬Poised(gregory)) → (Mushy(shane)) ::: If Gregory is not poised, then Shane is mushy.\n(∃x (Wicked(x))) → ((¬Poised(shane) ∧ ¬Frank(george))) ::: If there is at least one people who is wicked, then Shane is not poised and George is not frank.\n((Teak(noel))) ↔ ((¬Poised(noel))) ::: If Noel is teak, then Noel is not poised, and vice versa.\n¬∃x((¬(¬Frank(x)))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised.\n(∀x (Wicked(x) ∧ Mushy(x))) ↔ (∀x (Poised(x))) ::: Someone is wicked and mushy if and only if he is poised.\n(∃x (Poised(x) ∨ ¬Hungry(x))) → ((¬Mushy(george))) ::: If there is at least one people who is poised or not hungry, then George is not mushy.\n(∃x (Wicked(x) ∧ ¬Teak(x))) → ((Poised(crosby))) ::: If there is at least one people who is both wicked and not teak, then Crosby is poised.\n((Teak(keith))) ↔ ((¬Poised(gregory) ∧ ¬Wicked(noel))) ::: Keith is teak if and only if Gregory is not poised and Noel is not wicked.\n((Teak(noel))) ↔ ((Hungry(shane))) ::: Noel is teak if and only if Shane is hungry.\n((¬Teak(gregory) ∧ Wicked(crosby))) → ((¬Mushy(keith))) ::: If Gregory is not teak and Crosby is wicked, then Keith is not mushy.\n(∃x (Hungry(x) ∧ Wicked(x))) → ((Teak(noel))) ::: If there is at least one people who is both hungry and wicked, then Noel is teak.\n",
                "First-Order-Logic Question": "Poised(keith) ::: Keith is poised."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬x)) → ((Teak(shane) ∧ ¬Poised(shane))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised.",
                    "gram": "¬∃x((¬(¬Frank(x)))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised."
                }
            ],
            "answer": "C",
            "grammar_answer": "A",
            "backup_answer": "C"
        },
        {
            "id": 131,
            "raw_prog": {
                "First-Order-Logic Rules": "¬Hungry(gregory) ::: Gregory is not hungry.\nMushy(ronald) ::: Ronald is mushy.\nTeak(keith) ::: Keith is teak.\nPoised(crosby) ::: Crosby is poised.\nFrank(shane) ::: Shane is frank.\nPoised(gregory) ::: Gregory is poised.\n¬Poised(shane) ::: Shane is not poised.\nMushy(keith) ::: Keith is mushy.\n¬Frank(noel) ::: Noel is not frank.\nFrank(george) ::: George is frank.\nWicked(george) ::: George is wicked.\nFrank(keith) ::: Keith is frank.\n(∀x (Mushy(x) ∨ ¬Poised(x))) → (∀x (Hungry(x) ∧ ¬Wicked(x))) ::: If someone is either mushy or not poised, then he is hungry and not wicked.\n(¬Poised(gregory)) → (Mushy(shane)) ::: If Gregory is not poised, then Shane is mushy.\n(∃x (Wicked(x))) → ((¬Poised(shane) ∧ ¬Frank(george))) ::: If there is at least one people who is wicked, then Shane is not poised and George is not frank.\n((Teak(noel))) ↔ ((¬Poised(noel))) ::: If Noel is teak, then Noel is not poised, and vice versa.\n(¬∃x (¬x)) → ((Teak(shane) ∧ ¬Poised(shane))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised.\n(∀x (Wicked(x) ∧ Mushy(x))) ↔ (∀x (Poised(x))) ::: Someone is wicked and mushy if and only if he is poised.\n(∃x (Poised(x) ∨ ¬Hungry(x))) → ((¬Mushy(george))) ::: If there is at least one people who is poised or not hungry, then George is not mushy.\n(∃x (Wicked(x) ∧ ¬Teak(x))) → ((Poised(crosby))) ::: If there is at least one people who is both wicked and not teak, then Crosby is poised.\n((Teak(keith))) ↔ ((¬Poised(gregory) ∧ ¬Wicked(noel))) ::: Keith is teak if and only if Gregory is not poised and Noel is not wicked.\n((Teak(noel))) ↔ ((Hungry(shane))) ::: Noel is teak if and only if Shane is hungry.\n((¬Teak(gregory) ∧ Wicked(crosby))) → ((¬Mushy(keith))) ::: If Gregory is not teak and Crosby is wicked, then Keith is not mushy.\n(∃x (Hungry(x) ∧ Wicked(x))) → ((Teak(noel))) ::: If there is at least one people who is both hungry and wicked, then Noel is teak.\n",
                "First-Order-Logic Question": "Poised(george) ::: George is poised."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "¬Hungry(gregory) ::: Gregory is not hungry.\nMushy(ronald) ::: Ronald is mushy.\nTeak(keith) ::: Keith is teak.\nPoised(crosby) ::: Crosby is poised.\nFrank(shane) ::: Shane is frank.\nPoised(gregory) ::: Gregory is poised.\n¬Poised(shane) ::: Shane is not poised.\nMushy(keith) ::: Keith is mushy.\n¬Frank(noel) ::: Noel is not frank.\nFrank(george) ::: George is frank.\nWicked(george) ::: George is wicked.\nFrank(keith) ::: Keith is frank.\n(∀x (Mushy(x) ∨ ¬Poised(x))) → (∀x (Hungry(x) ∧ ¬Wicked(x))) ::: If someone is either mushy or not poised, then he is hungry and not wicked.\n(¬Poised(gregory)) → (Mushy(shane)) ::: If Gregory is not poised, then Shane is mushy.\n(∃x (Wicked(x))) → ((¬Poised(shane) ∧ ¬Frank(george))) ::: If there is at least one people who is wicked, then Shane is not poised and George is not frank.\n((Teak(noel))) ↔ ((¬Poised(noel))) ::: If Noel is teak, then Noel is not poised, and vice versa.\n¬∃x((¬(¬Frank(x)))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised.\n(∀x (Wicked(x) ∧ Mushy(x))) ↔ (∀x (Poised(x))) ::: Someone is wicked and mushy if and only if he is poised.\n(∃x (Poised(x) ∨ ¬Hungry(x))) → ((¬Mushy(george))) ::: If there is at least one people who is poised or not hungry, then George is not mushy.\n(∃x (Wicked(x) ∧ ¬Teak(x))) → ((Poised(crosby))) ::: If there is at least one people who is both wicked and not teak, then Crosby is poised.\n((Teak(keith))) ↔ ((¬Poised(gregory) ∧ ¬Wicked(noel))) ::: Keith is teak if and only if Gregory is not poised and Noel is not wicked.\n((Teak(noel))) ↔ ((Hungry(shane))) ::: Noel is teak if and only if Shane is hungry.\n((¬Teak(gregory) ∧ Wicked(crosby))) → ((¬Mushy(keith))) ::: If Gregory is not teak and Crosby is wicked, then Keith is not mushy.\n(∃x (Hungry(x) ∧ Wicked(x))) → ((Teak(noel))) ::: If there is at least one people who is both hungry and wicked, then Noel is teak.\n",
                "First-Order-Logic Question": "Poised(george) ::: George is poised."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬x)) → ((Teak(shane) ∧ ¬Poised(shane))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised.",
                    "gram": "¬∃x((¬(¬Frank(x)))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised."
                }
            ],
            "answer": "C",
            "grammar_answer": "A",
            "backup_answer": "C"
        },
        {
            "id": 132,
            "raw_prog": {
                "First-Order-Logic Rules": "¬Hungry(gregory) ::: Gregory is not hungry.\nMushy(ronald) ::: Ronald is mushy.\nTeak(keith) ::: Keith is teak.\nPoised(crosby) ::: Crosby is poised.\nFrank(shane) ::: Shane is frank.\nPoised(gregory) ::: Gregory is poised.\n¬Poised(shane) ::: Shane is not poised.\nMushy(keith) ::: Keith is mushy.\n¬Frank(noel) ::: Noel is not frank.\nFrank(george) ::: George is frank.\nWicked(george) ::: George is wicked.\nFrank(keith) ::: Keith is frank.\n(∀x (Mushy(x) ∨ ¬Poised(x))) → (∀x (Hungry(x) ∧ ¬Wicked(x))) ::: If someone is either mushy or not poised, then he is hungry and not wicked.\n(¬Poised(gregory)) → (Mushy(shane)) ::: If Gregory is not poised, then Shane is mushy.\n(∃x (Wicked(x))) → ((¬Poised(shane) ∧ ¬Frank(george))) ::: If there is at least one people who is wicked, then Shane is not poised and George is not frank.\n((Teak(noel))) ↔ ((¬Poised(noel))) ::: If Noel is teak, then Noel is not poised, and vice versa.\n(¬∃x (¬x)) → ((Teak(shane) ∧ ¬Poised(shane))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised.\n(∀x (Wicked(x) ∧ Mushy(x))) ↔ (∀x (Poised(x))) ::: Someone is wicked and mushy if and only if he is poised.\n(∃x (Poised(x) ∨ ¬Hungry(x))) → ((¬Mushy(george))) ::: If there is at least one people who is poised or not hungry, then George is not mushy.\n(∃x (Wicked(x) ∧ ¬Teak(x))) → ((Poised(crosby))) ::: If there is at least one people who is both wicked and not teak, then Crosby is poised.\n((Teak(keith))) ↔ ((¬Poised(gregory) ∧ ¬Wicked(noel))) ::: Keith is teak if and only if Gregory is not poised and Noel is not wicked.\n((Teak(noel))) ↔ ((Hungry(shane))) ::: Noel is teak if and only if Shane is hungry.\n((¬Teak(gregory) ∧ Wicked(crosby))) → ((¬Mushy(keith))) ::: If Gregory is not teak and Crosby is wicked, then Keith is not mushy.\n(∃x (Hungry(x) ∧ Wicked(x))) → ((Teak(noel))) ::: If there is at least one people who is both hungry and wicked, then Noel is teak.\n",
                "First-Order-Logic Question": "Poised(noel) ::: Noel is poised."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "¬Hungry(gregory) ::: Gregory is not hungry.\nMushy(ronald) ::: Ronald is mushy.\nTeak(keith) ::: Keith is teak.\nPoised(crosby) ::: Crosby is poised.\nFrank(shane) ::: Shane is frank.\nPoised(gregory) ::: Gregory is poised.\n¬Poised(shane) ::: Shane is not poised.\nMushy(keith) ::: Keith is mushy.\n¬Frank(noel) ::: Noel is not frank.\nFrank(george) ::: George is frank.\nWicked(george) ::: George is wicked.\nFrank(keith) ::: Keith is frank.\n(∀x (Mushy(x) ∨ ¬Poised(x))) → (∀x (Hungry(x) ∧ ¬Wicked(x))) ::: If someone is either mushy or not poised, then he is hungry and not wicked.\n(¬Poised(gregory)) → (Mushy(shane)) ::: If Gregory is not poised, then Shane is mushy.\n(∃x (Wicked(x))) → ((¬Poised(shane) ∧ ¬Frank(george))) ::: If there is at least one people who is wicked, then Shane is not poised and George is not frank.\n((Teak(noel))) ↔ ((¬Poised(noel))) ::: If Noel is teak, then Noel is not poised, and vice versa.\n¬∃x((¬(¬Frank(x)))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised.\n(∀x (Wicked(x) ∧ Mushy(x))) ↔ (∀x (Poised(x))) ::: Someone is wicked and mushy if and only if he is poised.\n(∃x (Poised(x) ∨ ¬Hungry(x))) → ((¬Mushy(george))) ::: If there is at least one people who is poised or not hungry, then George is not mushy.\n(∃x (Wicked(x) ∧ ¬Teak(x))) → ((Poised(crosby))) ::: If there is at least one people who is both wicked and not teak, then Crosby is poised.\n((Teak(keith))) ↔ ((¬Poised(gregory) ∧ ¬Wicked(noel))) ::: Keith is teak if and only if Gregory is not poised and Noel is not wicked.\n((Teak(noel))) ↔ ((Hungry(shane))) ::: Noel is teak if and only if Shane is hungry.\n((¬Teak(gregory) ∧ Wicked(crosby))) → ((¬Mushy(keith))) ::: If Gregory is not teak and Crosby is wicked, then Keith is not mushy.\n(∃x (Hungry(x) ∧ Wicked(x))) → ((Teak(noel))) ::: If there is at least one people who is both hungry and wicked, then Noel is teak.\n",
                "First-Order-Logic Question": "Poised(noel) ::: Noel is poised."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬x)) → ((Teak(shane) ∧ ¬Poised(shane))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised.",
                    "gram": "¬∃x((¬(¬Frank(x)))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised."
                }
            ],
            "answer": "B",
            "grammar_answer": "A",
            "backup_answer": "C"
        },
        {
            "id": 133,
            "raw_prog": {
                "First-Order-Logic Rules": "¬Hungry(gregory) ::: Gregory is not hungry.\nMushy(ronald) ::: Ronald is mushy.\nTeak(keith) ::: Keith is teak.\nPoised(crosby) ::: Crosby is poised.\nFrank(shane) ::: Shane is frank.\nPoised(gregory) ::: Gregory is poised.\n¬Poised(shane) ::: Shane is not poised.\nMushy(keith) ::: Keith is mushy.\n¬Frank(noel) ::: Noel is not frank.\nFrank(george) ::: George is frank.\nWicked(george) ::: George is wicked.\nFrank(keith) ::: Keith is frank.\n(∀x (Mushy(x) ∨ ¬Poised(x))) → (∀x (Hungry(x) ∧ ¬Wicked(x))) ::: If someone is either mushy or not poised, then he is hungry and not wicked.\n(¬Poised(gregory)) → (Mushy(shane)) ::: If Gregory is not poised, then Shane is mushy.\n(∃x (Wicked(x))) → ((¬Poised(shane) ∧ ¬Frank(george))) ::: If there is at least one people who is wicked, then Shane is not poised and George is not frank.\n((Teak(noel))) ↔ ((¬Poised(noel))) ::: If Noel is teak, then Noel is not poised, and vice versa.\n(¬∃x (¬x)) → ((Teak(shane) ∧ ¬Poised(shane))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised.\n(∀x (Wicked(x) ∧ Mushy(x))) ↔ (∀x (Poised(x))) ::: Someone is wicked and mushy if and only if he is poised.\n(∃x (Poised(x) ∨ ¬Hungry(x))) → ((¬Mushy(george))) ::: If there is at least one people who is poised or not hungry, then George is not mushy.\n(∃x (Wicked(x) ∧ ¬Teak(x))) → ((Poised(crosby))) ::: If there is at least one people who is both wicked and not teak, then Crosby is poised.\n((Teak(keith))) ↔ ((¬Poised(gregory) ∧ ¬Wicked(noel))) ::: Keith is teak if and only if Gregory is not poised and Noel is not wicked.\n((Teak(noel))) ↔ ((Hungry(shane))) ::: Noel is teak if and only if Shane is hungry.\n((¬Teak(gregory) ∧ Wicked(crosby))) → ((¬Mushy(keith))) ::: If Gregory is not teak and Crosby is wicked, then Keith is not mushy.\n(∃x (Hungry(x) ∧ Wicked(x))) → ((Teak(noel))) ::: If there is at least one people who is both hungry and wicked, then Noel is teak.\n",
                "First-Order-Logic Question": "Mushy(crosby) ::: Crosby is mushy."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "¬Hungry(gregory) ::: Gregory is not hungry.\nMushy(ronald) ::: Ronald is mushy.\nTeak(keith) ::: Keith is teak.\nPoised(crosby) ::: Crosby is poised.\nFrank(shane) ::: Shane is frank.\nPoised(gregory) ::: Gregory is poised.\n¬Poised(shane) ::: Shane is not poised.\nMushy(keith) ::: Keith is mushy.\n¬Frank(noel) ::: Noel is not frank.\nFrank(george) ::: George is frank.\nWicked(george) ::: George is wicked.\nFrank(keith) ::: Keith is frank.\n(∀x (Mushy(x) ∨ ¬Poised(x))) → (∀x (Hungry(x) ∧ ¬Wicked(x))) ::: If someone is either mushy or not poised, then he is hungry and not wicked.\n(¬Poised(gregory)) → (Mushy(shane)) ::: If Gregory is not poised, then Shane is mushy.\n(∃x (Wicked(x))) → ((¬Poised(shane) ∧ ¬Frank(george))) ::: If there is at least one people who is wicked, then Shane is not poised and George is not frank.\n((Teak(noel))) ↔ ((¬Poised(noel))) ::: If Noel is teak, then Noel is not poised, and vice versa.\n¬∃x((¬(¬Frank(x)))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised.\n(∀x (Wicked(x) ∧ Mushy(x))) ↔ (∀x (Poised(x))) ::: Someone is wicked and mushy if and only if he is poised.\n(∃x (Poised(x) ∨ ¬Hungry(x))) → ((¬Mushy(george))) ::: If there is at least one people who is poised or not hungry, then George is not mushy.\n(∃x (Wicked(x) ∧ ¬Teak(x))) → ((Poised(crosby))) ::: If there is at least one people who is both wicked and not teak, then Crosby is poised.\n((Teak(keith))) ↔ ((¬Poised(gregory) ∧ ¬Wicked(noel))) ::: Keith is teak if and only if Gregory is not poised and Noel is not wicked.\n((Teak(noel))) ↔ ((Hungry(shane))) ::: Noel is teak if and only if Shane is hungry.\n((¬Teak(gregory) ∧ Wicked(crosby))) → ((¬Mushy(keith))) ::: If Gregory is not teak and Crosby is wicked, then Keith is not mushy.\n(∃x (Hungry(x) ∧ Wicked(x))) → ((Teak(noel))) ::: If there is at least one people who is both hungry and wicked, then Noel is teak.\n",
                "First-Order-Logic Question": "Mushy(crosby) ::: Crosby is mushy."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬x)) → ((Teak(shane) ∧ ¬Poised(shane))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised.",
                    "gram": "¬∃x((¬(¬Frank(x)))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised."
                }
            ],
            "answer": "A",
            "grammar_answer": "A",
            "backup_answer": "B"
        },
        {
            "id": 134,
            "raw_prog": {
                "First-Order-Logic Rules": "¬Hungry(gregory) ::: Gregory is not hungry.\nMushy(ronald) ::: Ronald is mushy.\nTeak(keith) ::: Keith is teak.\nPoised(crosby) ::: Crosby is poised.\nFrank(shane) ::: Shane is frank.\nPoised(gregory) ::: Gregory is poised.\n¬Poised(shane) ::: Shane is not poised.\nMushy(keith) ::: Keith is mushy.\n¬Frank(noel) ::: Noel is not frank.\nFrank(george) ::: George is frank.\nWicked(george) ::: George is wicked.\nFrank(keith) ::: Keith is frank.\n(∀x (Mushy(x) ∨ ¬Poised(x))) → (∀x (Hungry(x) ∧ ¬Wicked(x))) ::: If someone is either mushy or not poised, then he is hungry and not wicked.\n(¬Poised(gregory)) → (Mushy(shane)) ::: If Gregory is not poised, then Shane is mushy.\n(∃x (Wicked(x))) → ((¬Poised(shane) ∧ ¬Frank(george))) ::: If there is at least one people who is wicked, then Shane is not poised and George is not frank.\n((Teak(noel))) ↔ ((¬Poised(noel))) ::: If Noel is teak, then Noel is not poised, and vice versa.\n(¬∃x (¬x)) → ((Teak(shane) ∧ ¬Poised(shane))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised.\n(∀x (Wicked(x) ∧ Mushy(x))) ↔ (∀x (Poised(x))) ::: Someone is wicked and mushy if and only if he is poised.\n(∃x (Poised(x) ∨ ¬Hungry(x))) → ((¬Mushy(george))) ::: If there is at least one people who is poised or not hungry, then George is not mushy.\n(∃x (Wicked(x) ∧ ¬Teak(x))) → ((Poised(crosby))) ::: If there is at least one people who is both wicked and not teak, then Crosby is poised.\n((Teak(keith))) ↔ ((¬Poised(gregory) ∧ ¬Wicked(noel))) ::: Keith is teak if and only if Gregory is not poised and Noel is not wicked.\n((Teak(noel))) ↔ ((Hungry(shane))) ::: Noel is teak if and only if Shane is hungry.\n((¬Teak(gregory) ∧ Wicked(crosby))) → ((¬Mushy(keith))) ::: If Gregory is not teak and Crosby is wicked, then Keith is not mushy.\n(∃x (Hungry(x) ∧ Wicked(x))) → ((Teak(noel))) ::: If there is at least one people who is both hungry and wicked, then Noel is teak.\n",
                "First-Order-Logic Question": "Frank(keith) ::: Keith is frank."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "¬Hungry(gregory) ::: Gregory is not hungry.\nMushy(ronald) ::: Ronald is mushy.\nTeak(keith) ::: Keith is teak.\nPoised(crosby) ::: Crosby is poised.\nFrank(shane) ::: Shane is frank.\nPoised(gregory) ::: Gregory is poised.\n¬Poised(shane) ::: Shane is not poised.\nMushy(keith) ::: Keith is mushy.\n¬Frank(noel) ::: Noel is not frank.\nFrank(george) ::: George is frank.\nWicked(george) ::: George is wicked.\nFrank(keith) ::: Keith is frank.\n(∀x (Mushy(x) ∨ ¬Poised(x))) → (∀x (Hungry(x) ∧ ¬Wicked(x))) ::: If someone is either mushy or not poised, then he is hungry and not wicked.\n(¬Poised(gregory)) → (Mushy(shane)) ::: If Gregory is not poised, then Shane is mushy.\n(∃x (Wicked(x))) → ((¬Poised(shane) ∧ ¬Frank(george))) ::: If there is at least one people who is wicked, then Shane is not poised and George is not frank.\n((Teak(noel))) ↔ ((¬Poised(noel))) ::: If Noel is teak, then Noel is not poised, and vice versa.\n¬∃x((¬(¬Frank(x)))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised.\n(∀x (Wicked(x) ∧ Mushy(x))) ↔ (∀x (Poised(x))) ::: Someone is wicked and mushy if and only if he is poised.\n(∃x (Poised(x) ∨ ¬Hungry(x))) → ((¬Mushy(george))) ::: If there is at least one people who is poised or not hungry, then George is not mushy.\n(∃x (Wicked(x) ∧ ¬Teak(x))) → ((Poised(crosby))) ::: If there is at least one people who is both wicked and not teak, then Crosby is poised.\n((Teak(keith))) ↔ ((¬Poised(gregory) ∧ ¬Wicked(noel))) ::: Keith is teak if and only if Gregory is not poised and Noel is not wicked.\n((Teak(noel))) ↔ ((Hungry(shane))) ::: Noel is teak if and only if Shane is hungry.\n((¬Teak(gregory) ∧ Wicked(crosby))) → ((¬Mushy(keith))) ::: If Gregory is not teak and Crosby is wicked, then Keith is not mushy.\n(∃x (Hungry(x) ∧ Wicked(x))) → ((Teak(noel))) ::: If there is at least one people who is both hungry and wicked, then Noel is teak.\n",
                "First-Order-Logic Question": "Frank(keith) ::: Keith is frank."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬x)) → ((Teak(shane) ∧ ¬Poised(shane))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised.",
                    "gram": "¬∃x((¬(¬Frank(x)))) ::: If there is nobody who is not, then Shane is teak and Shane is not poised."
                }
            ],
            "answer": "A",
            "grammar_answer": "A",
            "backup_answer": "A"
        },
        {
            "id": 360,
            "raw_prog": {
                "First-Order-Logic Rules": [
                    "¬Able(jasper) ::: Jasper is not able.",
                    "¬Frank(jack) ::: Jack is not frank.",
                    "Civil(jasper) ::: Jasper is civil.",
                    "¬Civil(george) ::: George is not civil.",
                    "Frank(burgess) ::: Burgess is frank.",
                    "Jolly(roderick) ::: Roderick is jolly.",
                    "¬Civil(myra) ::: Myra is not civil.",
                    "Precious(roderick) ::: Roderick is precious.",
                    "Jolly(jack) ::: Jack is jolly.",
                    "¬Able(burgess) ::: Burgess is not able.",
                    "¬Jolly(miles) ::: Miles is not jolly.",
                    "Jolly(jasper) ::: Jasper is jolly.",
                    "Jolly(burgess) → ¬Able(roderick) ::: It can be concluded that Roderick is not able once knowing that Burgess is jolly.",
                    "(∃x (Able(x) ∧ Jolly(x))) → ¬Frank(jasper) ::: If there is someone who is both able and jolly, then Jasper is not frank.",
                    "(∃x (¬Frank(x) ∨ ¬Civil(x))) → Able(roderick) ::: If there is at least one people who is not frank or not civil, then Roderick is able.",
                    "(∃x (Able(x))) → (¬Frank(george) ∧ ¬Technical(jack)) ::: If there is someone who is able, then George is not frank and Jack is not technical.",
                    "(¬∃x (¬Frank(x))) → ¬Frank(jack) ::: If there is nobody who is not frank, then Jack is not frank.",
                    "(∃x (¬Frank(x) ∨ ¬Precious(x))) → ¬Able(roderick) ::: If there is at least one people who is not frank or not precious, then Roderick is not able.",
                    "(∀x (Frank(x))) → (∀x (¬Precious(x) ∧ ¬Civil(x))) ::: If someone is frank, then he is neither precious nor civil.",
                    "(¬Jolly(burgess) ∨ ¬Civil(roderick)) → ¬Technical(george) ::: It can be concluded that George is not technical once knowing that Burgess is not jolly or Roderick is not civil.",
                    "(∀x (Precious(x))) ↔ (∀x (¬Frank(x))) ::: If someone is precious, then he is not frank, and vice versa.",
                    "(∀x (¬Precious(x) ∨ Technical(x))) → (∀x (¬Jolly(x))) ::: If someone is not precious or technical, then he is not jolly.",
                    "(∀x (¬Civil(x) ∧ ¬Jolly(x))) ↔ (∀x (Able(x))) ::: If someone is not civil and not jolly, then he is able, and vice versa.",
                    "Able(roderick) → (Precious(burgess) ∧ ¬Civil(jack)) ::: Roderick being able implies that Burgess is precious and Jack is not civil."
                ],
                "First-Order-Logic Question": "Civil(myra) ::: Myra is civil."
            },
            "gram_prog": {
                "First-Order-Logic Rules": [
                    "¬Able(jasper) ::: Jasper is not able.",
                    "¬Frank(jack) ::: Jack is not frank.",
                    "Civil(jasper) ::: Jasper is civil.",
                    "¬Civil(george) ::: George is not civil.",
                    "Frank(burgess) ::: Burgess is frank.",
                    "Jolly(roderick) ::: Roderick is jolly.",
                    "¬Civil(myra) ::: Myra is not civil.",
                    "Precious(roderick) ::: Roderick is precious.",
                    "Jolly(jack) ::: Jack is jolly.",
                    "¬Able(burgess) ::: Burgess is not able.",
                    "¬Jolly(miles) ::: Miles is not jolly.",
                    "Jolly(jasper) ::: Jasper is jolly.",
                    "Jolly(burgess) → ¬Able(roderick) ::: It can be concluded that Roderick is not able once knowing that Burgess is jolly.",
                    "(∃x (Able(x) ∧ Jolly(x))) → ¬Frank(jasper) ::: If there is someone who is both able and jolly, then Jasper is not frank.",
                    "(∃x (¬Frank(x) ∨ ¬Civil(x))) → Able(roderick) ::: If there is at least one people who is not frank or not civil, then Roderick is able.",
                    "(∃x (Able(x))) → (¬Frank(george) ∧ ¬Technical(jack)) ::: If there is someone who is able, then George is not frank and Jack is not technical.",
                    "¬∃x(¬Frank(x))→¬Frank(x) ::: If there is nobody who is not frank, then Jack is not frank.",
                    "(∃x (¬Frank(x) ∨ ¬Precious(x))) → ¬Able(roderick) ::: If there is at least one people who is not frank or not precious, then Roderick is not able.",
                    "(∀x (Frank(x))) → (∀x (¬Precious(x) ∧ ¬Civil(x))) ::: If someone is frank, then he is neither precious nor civil.",
                    "(¬Jolly(burgess) ∨ ¬Civil(roderick)) → ¬Technical(george) ::: It can be concluded that George is not technical once knowing that Burgess is not jolly or Roderick is not civil.",
                    "(∀x (Precious(x))) ↔ (∀x (¬Frank(x))) ::: If someone is precious, then he is not frank, and vice versa.",
                    "(∀x (¬Precious(x) ∨ Technical(x))) → (∀x (¬Jolly(x))) ::: If someone is not precious or technical, then he is not jolly.",
                    "(∀x (¬Civil(x) ∧ ¬Jolly(x))) ↔ (∀x (Able(x))) ::: If someone is not civil and not jolly, then he is able, and vice versa.",
                    "Able(roderick) → (Precious(burgess) ∧ ¬Civil(jack)) ::: Roderick being able implies that Burgess is precious and Jack is not civil."
                ],
                "First-Order-Logic Question": "Civil(myra) ::: Myra is civil."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬Frank(x))) → ¬Frank(jack) ::: If there is nobody who is not frank, then Jack is not frank.",
                    "gram": "¬∃x(¬Frank(x))→¬Frank(x) ::: If there is nobody who is not frank, then Jack is not frank."
                }
            ],
            "answer": "B",
            "grammar_answer": "A",
            "backup_answer": "B"
        },
        {
            "id": 361,
            "raw_prog": {
                "First-Order-Logic Rules": "¬Able(jasper) ::: Jasper is not able.\n¬Frank(jack) ::: Jack is not frank.\nCivil(jasper) ::: Jasper is civil.\n¬Civil(george) ::: George is not civil.\nFrank(burgess) ::: Burgess is frank.\nJolly(roderick) ::: Roderick is jolly.\n¬Civil(myra) ::: Myra is not civil.\nPrecious(roderick) ::: Roderick is precious.\nJolly(jack) ::: Jack is jolly.\n¬Able(burgess) ::: Burgess is not able.\n¬Jolly(miles) ::: Miles is not jolly.\nJolly(jasper) ::: Jasper is jolly.\n((Jolly(burgess))) → ((¬Able(roderick))) ::: It can be concluded that Roderick is not able once knowing that Burgess is jolly.\n(∃x (Able(x) ∧ Jolly(x))) → ((¬Frank(jasper))) ::: If there is someone who is both able and jolly, then Jasper is not frank.\n(∃x (¬Frank(x) ∨ ¬Civil(x))) → ((Able(roderick))) ::: If there is at least one people who is not frank or not civil, then Roderick is able.\n(∃x (Able(x))) → ((¬Frank(george) ∧ ¬Technical(jack))) ::: If there is someone who is able, then George is not frank and Jack is not technical.\n(¬∃x (¬x)) → ((¬Frank(jack))) ::: If there is nobody who is not, then Jack is not frank.\n(∃x (¬Frank(x) ∨ ¬Precious(x))) → ((¬Able(roderick))) ::: If there is at least one people who is not frank or not precious, then Roderick is not able.\n(∀x (Frank(x))) → (∀x (¬Precious(x) ∧ ¬Civil(x))) ::: If someone is frank, then he is neither precious nor civil.\n((¬Jolly(burgess) ∨ ¬Civil(roderick))) → ((¬Technical(george))) ::: It can be concluded that George is not technical once knowing that Burgess is not jolly or Roderick is not civil.\n(∀x (Precious(x))) ↔ (∀x (¬Frank(x))) ::: If someone is precious, then he is not frank, and vice versa.\n(∀x (¬Civil(x) ∧ ¬Jolly(x))) ↔ (∀x (Able(x))) ::: If someone is not civil and not jolly, then he is able, and vice versa.\n((Able(roderick))) → ((Precious(burgess) ∧ ¬Civil(jack))) ::: Roderick being able implies that Burgess is precious and Jack is not civil.\n",
                "First-Order-Logic Question": "Civil(jasper) ::: Jasper is civil."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "¬Able(jasper) ::: Jasper is not able.\n¬Frank(jack) ::: Jack is not frank.\nCivil(jasper) ::: Jasper is civil.\n¬Civil(george) ::: George is not civil.\nFrank(burgess) ::: Burgess is frank.\nJolly(roderick) ::: Roderick is jolly.\n¬Civil(myra) ::: Myra is not civil.\nPrecious(roderick) ::: Roderick is precious.\nJolly(jack) ::: Jack is jolly.\n¬Able(burgess) ::: Burgess is not able.\n¬Jolly(miles) ::: Miles is not jolly.\nJolly(jasper) ::: Jasper is jolly.\n((Jolly(burgess))) → ((¬Able(roderick))) ::: It can be concluded that Roderick is not able once knowing that Burgess is jolly.\n(∃x (Able(x) ∧ Jolly(x))) → ((¬Frank(jasper))) ::: If there is someone who is both able and jolly, then Jasper is not frank.\n(∃x (¬Frank(x) ∨ ¬Civil(x))) → ((Able(roderick))) ::: If there is at least one people who is not frank or not civil, then Roderick is able.\n(∃x (Able(x))) → ((¬Frank(george) ∧ ¬Technical(jack))) ::: If there is someone who is able, then George is not frank and Jack is not technical.\n¬∃x((¬Frank(x))→(¬Frank(x))) ::: If there is nobody who is not, then Jack is not frank.\n(∃x (¬Frank(x) ∨ ¬Precious(x))) → ((¬Able(roderick))) ::: If there is at least one people who is not frank or not precious, then Roderick is not able.\n(∀x (Frank(x))) → (∀x (¬Precious(x) ∧ ¬Civil(x))) ::: If someone is frank, then he is neither precious nor civil.\n((¬Jolly(burgess) ∨ ¬Civil(roderick))) → ((¬Technical(george))) ::: It can be concluded that George is not technical once knowing that Burgess is not jolly or Roderick is not civil.\n(∀x (Precious(x))) ↔ (∀x (¬Frank(x))) ::: If someone is precious, then he is not frank, and vice versa.\n(∀x (¬Civil(x) ∧ ¬Jolly(x))) ↔ (∀x (Able(x))) ::: If someone is not civil and not jolly, then he is able, and vice versa.\n((Able(roderick))) → ((Precious(burgess) ∧ ¬Civil(jack))) ::: Roderick being able implies that Burgess is precious and Jack is not civil.\n",
                "First-Order-Logic Question": "Civil(jasper) ::: Jasper is civil."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬x)) → ((¬Frank(jack))) ::: If there is nobody who is not, then Jack is not frank.",
                    "gram": "¬∃x((¬Frank(x))→(¬Frank(x))) ::: If there is nobody who is not, then Jack is not frank."
                }
            ],
            "answer": "A",
            "grammar_answer": "A",
            "backup_answer": "A"
        },
        {
            "id": 362,
            "raw_prog": {
                "First-Order-Logic Rules": [
                    "¬Able(jasper) ::: Jasper is not able.",
                    "¬Frank(jack) ::: Jack is not frank.",
                    "Civil(jasper) ::: Jasper is civil.",
                    "¬Civil(george) ::: George is not civil.",
                    "Frank(burgess) ::: Burgess is frank.",
                    "Jolly(roderick) ::: Roderick is jolly.",
                    "¬Civil(myra) ::: Myra is not civil.",
                    "Precious(roderick) ::: Roderick is precious.",
                    "Jolly(jack) ::: Jack is jolly.",
                    "¬Able(burgess) ::: Burgess is not able.",
                    "¬Jolly(miles) ::: Miles is not jolly.",
                    "Jolly(jasper) ::: Jasper is jolly.",
                    "Jolly(burgess) → ¬Able(roderick) ::: It can be concluded that Roderick is not able once knowing that Burgess is jolly.",
                    "(∃x (Able(x) ∧ Jolly(x))) → ¬Frank(jasper) ::: If there is someone who is both able and jolly, then Jasper is not frank.",
                    "(∃x (¬Frank(x) ∨ ¬Civil(x))) → Able(roderick) ::: If there is at least one people who is not frank or not civil, then Roderick is able.",
                    "(∃x (Able(x))) → (¬Frank(george) ∧ ¬Technical(jack)) ::: If there is someone who is able, then George is not frank and Jack is not technical.",
                    "(¬∃x (¬x)) → ¬Frank(jack) ::: If there is nobody who is not, then Jack is not frank.",
                    "(∃x (¬Frank(x) ∨ ¬Precious(x))) → ¬Able(roderick) ::: If there is at least one people who is not frank or not precious, then Roderick is not able.",
                    "(∀x (Frank(x))) → (∀x (¬Precious(x) ∧ ¬Civil(x))) ::: If someone is frank, then he is neither precious nor civil.",
                    "(¬Jolly(burgess) ∨ ¬Civil(roderick)) → ¬Technical(george) ::: It can be concluded that George is not technical once knowing that Burgess is not jolly or Roderick is not civil.",
                    "(∀x (Precious(x))) ↔ (∀x (¬Frank(x))) ::: If someone is precious, then he is not frank, and vice versa.",
                    "(∀x (x ∨ ¬Precious(x)) → (∀x (¬Jolly(x))) ::: If someone is he or not precious is technical, then he is not jolly.",
                    "(∀x (¬Civil(x) ∧ ¬Jolly(x))) ↔ (∀x (Able(x))) ::: If someone is not civil and not jolly, then he is able, and vice versa.",
                    "Able(roderick) → (Precious(burgess) ∧ ¬Civil(jack)) ::: Roderick being able implies that Burgess is precious and Jack is not civil."
                ],
                "First-Order-Logic Question": "Precious(myra) ::: Myra is precious."
            },
            "gram_prog": {
                "First-Order-Logic Rules": [
                    "¬Able(jasper) ::: Jasper is not able.",
                    "¬Frank(jack) ::: Jack is not frank.",
                    "Civil(jasper) ::: Jasper is civil.",
                    "¬Civil(george) ::: George is not civil.",
                    "Frank(burgess) ::: Burgess is frank.",
                    "Jolly(roderick) ::: Roderick is jolly.",
                    "¬Civil(myra) ::: Myra is not civil.",
                    "Precious(roderick) ::: Roderick is precious.",
                    "Jolly(jack) ::: Jack is jolly.",
                    "¬Able(burgess) ::: Burgess is not able.",
                    "¬Jolly(miles) ::: Miles is not jolly.",
                    "Jolly(jasper) ::: Jasper is jolly.",
                    "Jolly(burgess) → ¬Able(roderick) ::: It can be concluded that Roderick is not able once knowing that Burgess is jolly.",
                    "(∃x (Able(x) ∧ Jolly(x))) → ¬Frank(jasper) ::: If there is someone who is both able and jolly, then Jasper is not frank.",
                    "(∃x (¬Frank(x) ∨ ¬Civil(x))) → Able(roderick) ::: If there is at least one people who is not frank or not civil, then Roderick is able.",
                    "(∃x (Able(x))) → (¬Frank(george) ∧ ¬Technical(jack)) ::: If there is someone who is able, then George is not frank and Jack is not technical.",
                    "¬∃x(¬(Able(x))→Frank(x)) ::: If there is nobody who is not, then Jack is not frank.",
                    "(∃x (¬Frank(x) ∨ ¬Precious(x))) → ¬Able(roderick) ::: If there is at least one people who is not frank or not precious, then Roderick is not able.",
                    "(∀x (Frank(x))) → (∀x (¬Precious(x) ∧ ¬Civil(x))) ::: If someone is frank, then he is neither precious nor civil.",
                    "(¬Jolly(burgess) ∨ ¬Civil(roderick)) → ¬Technical(george) ::: It can be concluded that George is not technical once knowing that Burgess is not jolly or Roderick is not civil.",
                    "(∀x (Precious(x))) ↔ (∀x (¬Frank(x))) ::: If someone is precious, then he is not frank, and vice versa.",
                    "∀x((Able(x)∨¬Precious(x))) ::: If someone is he or not precious is technical, then he is not jolly.",
                    "(∀x (¬Civil(x) ∧ ¬Jolly(x))) ↔ (∀x (Able(x))) ::: If someone is not civil and not jolly, then he is able, and vice versa.",
                    "Able(roderick) → (Precious(burgess) ∧ ¬Civil(jack)) ::: Roderick being able implies that Burgess is precious and Jack is not civil."
                ],
                "First-Order-Logic Question": "Precious(myra) ::: Myra is precious."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬x)) → ¬Frank(jack) ::: If there is nobody who is not, then Jack is not frank.",
                    "gram": "¬∃x(¬(Able(x))→Frank(x)) ::: If there is nobody who is not, then Jack is not frank."
                },
                {
                    "raw": "(∀x (x ∨ ¬Precious(x)) → (∀x (¬Jolly(x))) ::: If someone is he or not precious is technical, then he is not jolly.",
                    "gram": "∀x((Able(x)∨¬Precious(x))) ::: If someone is he or not precious is technical, then he is not jolly."
                }
            ],
            "answer": "C",
            "grammar_answer": "A",
            "backup_answer": "C"
        },
        {
            "id": 363,
            "raw_prog": {
                "First-Order-Logic Rules": "¬Able(jasper) ::: Jasper is not able.\n¬Frank(jack) ::: Jack is not frank.\nCivil(jasper) ::: Jasper is civil.\n¬Civil(george) ::: George is not civil.\nFrank(burgess) ::: Burgess is frank.\nJolly(roderick) ::: Roderick is jolly.\n¬Civil(myra) ::: Myra is not civil.\nPrecious(roderick) ::: Roderick is precious.\nJolly(jack) ::: Jack is jolly.\n¬Able(burgess) ::: Burgess is not able.\n¬Jolly(miles) ::: Miles is not jolly.\nJolly(jasper) ::: Jasper is jolly.\n((Jolly(burgess))) → ((¬Able(roderick))) ::: It can be concluded that Roderick is not able once knowing that Burgess is jolly.\n(∃x (Able(x) ∧ Jolly(x))) → ((¬Frank(jasper))) ::: If there is someone who is both able and jolly, then Jasper is not frank.\n(∃x (¬Frank(x) ∨ ¬Civil(x))) → ((Able(roderick))) ::: If there is at least one people who is not frank or not civil, then Roderick is able.\n(∃x (Able(x))) → ((¬Frank(george) ∧ ¬Technical(jack))) ::: If there is someone who is able, then George is not frank and Jack is not technical.\n(¬∃x (¬x)) → ((¬Frank(jack))) ::: If there is nobody who is not, then Jack is not frank.\n(∃x (¬Frank(x) ∨ ¬Precious(x))) → ((¬Able(roderick))) ::: If there is at least one people who is not frank or not precious, then Roderick is not able.\n(∀x (Frank(x))) → (∀x (¬Precious(x) ∧ ¬Civil(x))) ::: If someone is frank, then he is neither precious nor civil.\n((¬Jolly(burgess) ∨ ¬Civil(roderick))) → ((¬Technical(george))) ::: It can be concluded that George is not technical once knowing that Burgess is not jolly or Roderick is not civil.\n(∀x (Precious(x))) ↔ (∀x (¬Frank(x))) ::: If someone is precious, then he is not frank, and vice versa.\n(∀x (x ∨ ¬Precious(x))) → (∀x (¬Jolly(x))) ::: If someone is he or not precious is technical, then he is not jolly.\n(∀x (¬Civil(x) ∧ ¬Jolly(x))) ↔ (∀x (Able(x))) ::: If someone is not civil and not jolly, then he is able, and vice versa.\n((Able(roderick))) → ((Precious(burgess) ∧ ¬Civil(jack))) ::: Roderick being able implies that Burgess is precious and Jack is not civil.\n",
                "First-Order-Logic Question": "¬Technical(burgess) ::: Burgess is not technical."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "¬Able(jasper) ::: Jasper is not able.\n¬Frank(jack) ::: Jack is not frank.\nCivil(jasper) ::: Jasper is civil.\n¬Civil(george) ::: George is not civil.\nFrank(burgess) ::: Burgess is frank.\nJolly(roderick) ::: Roderick is jolly.\n¬Civil(myra) ::: Myra is not civil.\nPrecious(roderick) ::: Roderick is precious.\nJolly(jack) ::: Jack is jolly.\n¬Able(burgess) ::: Burgess is not able.\n¬Jolly(miles) ::: Miles is not jolly.\nJolly(jasper) ::: Jasper is jolly.\n((Jolly(burgess))) → ((¬Able(roderick))) ::: It can be concluded that Roderick is not able once knowing that Burgess is jolly.\n(∃x (Able(x) ∧ Jolly(x))) → ((¬Frank(jasper))) ::: If there is someone who is both able and jolly, then Jasper is not frank.\n(∃x (¬Frank(x) ∨ ¬Civil(x))) → ((Able(roderick))) ::: If there is at least one people who is not frank or not civil, then Roderick is able.\n(∃x (Able(x))) → ((¬Frank(george) ∧ ¬Technical(jack))) ::: If there is someone who is able, then George is not frank and Jack is not technical.\n¬∃x((¬Frank(x))→(¬Frank(x))) ::: If there is nobody who is not, then Jack is not frank.\n(∃x (¬Frank(x) ∨ ¬Precious(x))) → ((¬Able(roderick))) ::: If there is at least one people who is not frank or not precious, then Roderick is not able.\n(∀x (Frank(x))) → (∀x (¬Precious(x) ∧ ¬Civil(x))) ::: If someone is frank, then he is neither precious nor civil.\n((¬Jolly(burgess) ∨ ¬Civil(roderick))) → ((¬Technical(george))) ::: It can be concluded that George is not technical once knowing that Burgess is not jolly or Roderick is not civil.\n(∀x (Precious(x))) ↔ (∀x (¬Frank(x))) ::: If someone is precious, then he is not frank, and vice versa.\n∀x((Able(x)∨¬Precious(x))) ::: If someone is he or not precious is technical, then he is not jolly.\n(∀x (¬Civil(x) ∧ ¬Jolly(x))) ↔ (∀x (Able(x))) ::: If someone is not civil and not jolly, then he is able, and vice versa.\n((Able(roderick))) → ((Precious(burgess) ∧ ¬Civil(jack))) ::: Roderick being able implies that Burgess is precious and Jack is not civil.\n",
                "First-Order-Logic Question": "¬Technical(burgess) ::: Burgess is not technical."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬x)) → ((¬Frank(jack))) ::: If there is nobody who is not, then Jack is not frank.",
                    "gram": "¬∃x((¬Frank(x))→(¬Frank(x))) ::: If there is nobody who is not, then Jack is not frank."
                },
                {
                    "raw": "(∀x (x ∨ ¬Precious(x))) → (∀x (¬Jolly(x))) ::: If someone is he or not precious is technical, then he is not jolly.",
                    "gram": "∀x((Able(x)∨¬Precious(x))) ::: If someone is he or not precious is technical, then he is not jolly."
                }
            ],
            "answer": "C",
            "grammar_answer": "A",
            "backup_answer": "B"
        },
        {
            "id": 364,
            "raw_prog": {
                "First-Order-Logic Rules": "¬Able(jasper) ::: Jasper is not able.\n¬Frank(jack) ::: Jack is not frank.\nCivil(jasper) ::: Jasper is civil.\n¬Civil(george) ::: George is not civil.\nFrank(burgess) ::: Burgess is frank.\nJolly(roderick) ::: Roderick is jolly.\n¬Civil(myra) ::: Myra is not civil.\nPrecious(roderick) ::: Roderick is precious.\nJolly(jack) ::: Jack is jolly.\n¬Able(burgess) ::: Burgess is not able.\n¬Jolly(miles) ::: Miles is not jolly.\nJolly(jasper) ::: Jasper is jolly.\n((Jolly(burgess))) → ((¬Able(roderick))) ::: It can be concluded that Roderick is not able once knowing that Burgess is jolly.\n(∃x (Able(x) ∧ Jolly(x))) → ((¬Frank(jasper))) ::: If there is someone who is both able and jolly, then Jasper is not frank.\n(∃x (¬Frank(x) ∨ ¬Civil(x))) → ((Able(roderick))) ::: If there is at least one people who is not frank or not civil, then Roderick is able.\n(∃x (Able(x))) → ((¬Frank(george) ∧ ¬Technical(jack))) ::: If there is someone who is able, then George is not frank and Jack is not technical.\n(¬∃x (¬Frank(x))) → ((¬Frank(jack))) ::: If there is nobody who is not, then Jack is not frank.\n(∃x (¬Frank(x) ∨ ¬Precious(x))) → ((¬Able(roderick))) ::: If there is at least one people who is not frank or not precious, then Roderick is not able.\n(∀x (Frank(x))) → (∀x (¬Precious(x) ∧ ¬Civil(x))) ::: If someone is frank, then he is neither precious nor civil.\n((¬Jolly(burgess) ∨ ¬Civil(roderick))) → ((¬Technical(george))) ::: It can be concluded that George is not technical once knowing that Burgess is not jolly or Roderick is not civil.\n(∀x (Precious(x))) ↔ (∀x (¬Frank(x))) ::: If someone is precious, then he is not frank, and vice versa.\n(∀x (¬Precious(x) ∨ Technical(x))) → (∀x (¬Jolly(x))) ::: If someone is he or not precious is technical, then he is not jolly.\n(∀x (¬Civil(x) ∧ ¬Jolly(x))) ↔ (∀x (Able(x))) ::: If someone is not civil and not jolly, then he is able, and vice versa.\n((Able(roderick))) → ((Precious(burgess) ∧ ¬Civil(jack))) ::: Roderick being able implies that Burgess is precious and Jack is not civil.\n",
                "First-Order-Logic Question": "¬Precious(roderick) ::: Roderick is not precious."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "¬Able(jasper) ::: Jasper is not able.\n¬Frank(jack) ::: Jack is not frank.\nCivil(jasper) ::: Jasper is civil.\n¬Civil(george) ::: George is not civil.\nFrank(burgess) ::: Burgess is frank.\nJolly(roderick) ::: Roderick is jolly.\n¬Civil(myra) ::: Myra is not civil.\nPrecious(roderick) ::: Roderick is precious.\nJolly(jack) ::: Jack is jolly.\n¬Able(burgess) ::: Burgess is not able.\n¬Jolly(miles) ::: Miles is not jolly.\nJolly(jasper) ::: Jasper is jolly.\n((Jolly(burgess))) → ((¬Able(roderick))) ::: It can be concluded that Roderick is not able once knowing that Burgess is jolly.\n(∃x (Able(x) ∧ Jolly(x))) → ((¬Frank(jasper))) ::: If there is someone who is both able and jolly, then Jasper is not frank.\n(∃x (¬Frank(x) ∨ ¬Civil(x))) → ((Able(roderick))) ::: If there is at least one people who is not frank or not civil, then Roderick is able.\n(∃x (Able(x))) → ((¬Frank(george) ∧ ¬Technical(jack))) ::: If there is someone who is able, then George is not frank and Jack is not technical.\n¬∃x(¬Frank(x))→((¬Frank(x))) ::: If there is nobody who is not, then Jack is not frank.\n(∃x (¬Frank(x) ∨ ¬Precious(x))) → ((¬Able(roderick))) ::: If there is at least one people who is not frank or not precious, then Roderick is not able.\n(∀x (Frank(x))) → (∀x (¬Precious(x) ∧ ¬Civil(x))) ::: If someone is frank, then he is neither precious nor civil.\n((¬Jolly(burgess) ∨ ¬Civil(roderick))) → ((¬Technical(george))) ::: It can be concluded that George is not technical once knowing that Burgess is not jolly or Roderick is not civil.\n(∀x (Precious(x))) ↔ (∀x (¬Frank(x))) ::: If someone is precious, then he is not frank, and vice versa.\n(∀x (¬Precious(x) ∨ Technical(x))) → (∀x (¬Jolly(x))) ::: If someone is he or not precious is technical, then he is not jolly.\n(∀x (¬Civil(x) ∧ ¬Jolly(x))) ↔ (∀x (Able(x))) ::: If someone is not civil and not jolly, then he is able, and vice versa.\n((Able(roderick))) → ((Precious(burgess) ∧ ¬Civil(jack))) ::: Roderick being able implies that Burgess is precious and Jack is not civil.\n",
                "First-Order-Logic Question": "¬Precious(roderick) ::: Roderick is not precious."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬Frank(x))) → ((¬Frank(jack))) ::: If there is nobody who is not, then Jack is not frank.",
                    "gram": "¬∃x(¬Frank(x))→((¬Frank(x))) ::: If there is nobody who is not, then Jack is not frank."
                }
            ],
            "answer": "B",
            "grammar_answer": "A",
            "backup_answer": "B"
        },
        {
            "id": 365,
            "raw_prog": {
                "First-Order-Logic Rules": "¬Able(jasper) ::: Jasper is not able.\n¬Frank(jack) ::: Jack is not frank.\nCivil(jasper) ::: Jasper is civil.\n¬Civil(george) ::: George is not civil.\nFrank(burgess) ::: Burgess is frank.\nJolly(roderick) ::: Roderick is jolly.\n¬Civil(myra) ::: Myra is not civil.\nPrecious(roderick) ::: Roderick is precious.\nJolly(jack) ::: Jack is jolly.\n¬Able(burgess) ::: Burgess is not able.\n¬Jolly(miles) ::: Miles is not jolly.\nJolly(jasper) ::: Jasper is jolly.\n((Jolly(burgess))) → ((¬Able(roderick))) ::: It can be concluded that Roderick is not able once knowing that Burgess is jolly.\n(∃x (Able(x) ∧ Jolly(x))) → ((¬Frank(jasper))) ::: If there is someone who is both able and jolly, then Jasper is not frank.\n(∃x (¬Frank(x) ∨ ¬Civil(x))) → ((Able(roderick))) ::: If there is at least one people who is not frank or not civil, then Roderick is able.\n(∃x (Able(x))) → ((¬Frank(george) ∧ ¬Technical(jack))) ::: If there is someone who is able, then George is not frank and Jack is not technical.\n(¬∃x (¬x)) → ((¬Frank(jack))) ::: If there is nobody who is not, then Jack is not frank.\n(∃x (¬Frank(x) ∨ ¬Precious(x))) → ((¬Able(roderick))) ::: If there is at least one people who is not frank or not precious, then Roderick is not able.\n(∀x (Frank(x))) → (∀x (¬Precious(x) ∧ ¬Civil(x))) ::: If someone is frank, then he is neither precious nor civil.\n((¬Jolly(burgess) ∨ ¬Civil(roderick))) → ((¬Technical(george))) ::: It can be concluded that George is not technical once knowing that Burgess is not jolly or Roderick is not civil.\n(∀x (Precious(x))) → (∀x (¬Frank(x))) ∧ (∀x (¬Frank(x))) → (∀x (Precious(x))) ::: If someone is precious, then he is not frank, and vice versa.\n(∀x (¬Civil(x) ∧ ¬Jolly(x))) ↔ (∀x (Able(x))) ::: If someone is not civil and not jolly, then he is able, and vice versa.\n((Able(roderick))) → ((Precious(burgess) ∧ ¬Civil(jack))) ::: Roderick being able implies that Burgess is precious and Jack is not civil.\n",
                "First-Order-Logic Question": "Civil(roderick) ::: Roderick is civil."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "¬Able(jasper) ::: Jasper is not able.\n¬Frank(jack) ::: Jack is not frank.\nCivil(jasper) ::: Jasper is civil.\n¬Civil(george) ::: George is not civil.\nFrank(burgess) ::: Burgess is frank.\nJolly(roderick) ::: Roderick is jolly.\n¬Civil(myra) ::: Myra is not civil.\nPrecious(roderick) ::: Roderick is precious.\nJolly(jack) ::: Jack is jolly.\n¬Able(burgess) ::: Burgess is not able.\n¬Jolly(miles) ::: Miles is not jolly.\nJolly(jasper) ::: Jasper is jolly.\n((Jolly(burgess))) → ((¬Able(roderick))) ::: It can be concluded that Roderick is not able once knowing that Burgess is jolly.\n(∃x (Able(x) ∧ Jolly(x))) → ((¬Frank(jasper))) ::: If there is someone who is both able and jolly, then Jasper is not frank.\n(∃x (¬Frank(x) ∨ ¬Civil(x))) → ((Able(roderick))) ::: If there is at least one people who is not frank or not civil, then Roderick is able.\n(∃x (Able(x))) → ((¬Frank(george) ∧ ¬Technical(jack))) ::: If there is someone who is able, then George is not frank and Jack is not technical.\n¬∃x((¬Frank(x))→(¬Frank(x))) ::: If there is nobody who is not, then Jack is not frank.\n(∃x (¬Frank(x) ∨ ¬Precious(x))) → ((¬Able(roderick))) ::: If there is at least one people who is not frank or not precious, then Roderick is not able.\n(∀x (Frank(x))) → (∀x (¬Precious(x) ∧ ¬Civil(x))) ::: If someone is frank, then he is neither precious nor civil.\n((¬Jolly(burgess) ∨ ¬Civil(roderick))) → ((¬Technical(george))) ::: It can be concluded that George is not technical once knowing that Burgess is not jolly or Roderick is not civil.\n(∀x (Precious(x))) → (∀x (¬Frank(x))) ∧ (∀x (¬Frank(x))) → (∀x (Precious(x))) ::: If someone is precious, then he is not frank, and vice versa.\n(∀x (¬Civil(x) ∧ ¬Jolly(x))) ↔ (∀x (Able(x))) ::: If someone is not civil and not jolly, then he is able, and vice versa.\n((Able(roderick))) → ((Precious(burgess) ∧ ¬Civil(jack))) ::: Roderick being able implies that Burgess is precious and Jack is not civil.\n",
                "First-Order-Logic Question": "Civil(roderick) ::: Roderick is civil."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬x)) → ((¬Frank(jack))) ::: If there is nobody who is not, then Jack is not frank.",
                    "gram": "¬∃x((¬Frank(x))→(¬Frank(x))) ::: If there is nobody who is not, then Jack is not frank."
                }
            ],
            "answer": "B",
            "grammar_answer": "A",
            "backup_answer": "C"
        },
        {
            "id": 366,
            "raw_prog": {
                "First-Order-Logic Rules": "¬Able(jasper) ::: Jasper is not able.\n¬Frank(jack) ::: Jack is not frank.\nCivil(jasper) ::: Jasper is civil.\n¬Civil(george) ::: George is not civil.\nFrank(burgess) ::: Burgess is frank.\nJolly(roderick) ::: Roderick is jolly.\n¬Civil(myra) ::: Myra is not civil.\nPrecious(roderick) ::: Roderick is precious.\nJolly(jack) ::: Jack is jolly.\n¬Able(burgess) ::: Burgess is not able.\n¬Jolly(miles) ::: Miles is not jolly.\nJolly(jasper) ::: Jasper is jolly.\n((Jolly(burgess))) → ((¬Able(roderick))) ::: It can be concluded that Roderick is not able once knowing that Burgess is jolly.\n(∃x (Able(x) ∧ Jolly(x))) → ((¬Frank(jasper))) ::: If there is someone who is both able and jolly, then Jasper is not frank.\n(∃x (¬Frank(x) ∨ ¬Civil(x))) → ((Able(roderick))) ::: If there is at least one people who is not frank or not civil, then Roderick is able.\n(∃x (Able(x))) → ((¬Frank(george) ∧ ¬Technical(jack))) ::: If there is someone who is able, then George is not frank and Jack is not technical.\n(¬∃x (¬x)) → ((¬Frank(jack))) ::: If there is nobody who is not, then Jack is not frank.\n(∃x (¬Frank(x) ∨ ¬Precious(x))) → ((¬Able(roderick))) ::: If there is at least one people who is not frank or not precious, then Roderick is not able.\n(∀x (Frank(x))) → (∀x (¬Precious(x) ∧ ¬Civil(x))) ::: If someone is frank, then he is neither precious nor civil.\n((¬Jolly(burgess) ∨ ¬Civil(roderick))) → ((¬Technical(george))) ::: It can be concluded that George is not technical once knowing that Burgess is not jolly or Roderick is not civil.\n(∀x (Precious(x))) ↔ (∀x (¬Frank(x))) ::: If someone is precious, then he is not frank, and vice versa.\n(∀x (x ∨ ¬Precious(x))) → (∀x (¬Jolly(x))) ::: If someone is he or not precious is technical, then he is not jolly.\n(∀x (¬Civil(x) ∧ ¬Jolly(x))) ↔ (∀x (Able(x))) ::: If someone is not civil and not jolly, then he is able, and vice versa.\n((Able(roderick))) → ((Precious(burgess) ∧ ¬Civil(jack))) ::: Roderick being able implies that Burgess is precious and Jack is not civil.\n",
                "First-Order-Logic Question": "¬Technical(george) ::: George is not technical."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "¬Able(jasper) ::: Jasper is not able.\n¬Frank(jack) ::: Jack is not frank.\nCivil(jasper) ::: Jasper is civil.\n¬Civil(george) ::: George is not civil.\nFrank(burgess) ::: Burgess is frank.\nJolly(roderick) ::: Roderick is jolly.\n¬Civil(myra) ::: Myra is not civil.\nPrecious(roderick) ::: Roderick is precious.\nJolly(jack) ::: Jack is jolly.\n¬Able(burgess) ::: Burgess is not able.\n¬Jolly(miles) ::: Miles is not jolly.\nJolly(jasper) ::: Jasper is jolly.\n((Jolly(burgess))) → ((¬Able(roderick))) ::: It can be concluded that Roderick is not able once knowing that Burgess is jolly.\n(∃x (Able(x) ∧ Jolly(x))) → ((¬Frank(jasper))) ::: If there is someone who is both able and jolly, then Jasper is not frank.\n(∃x (¬Frank(x) ∨ ¬Civil(x))) → ((Able(roderick))) ::: If there is at least one people who is not frank or not civil, then Roderick is able.\n(∃x (Able(x))) → ((¬Frank(george) ∧ ¬Technical(jack))) ::: If there is someone who is able, then George is not frank and Jack is not technical.\n¬∃x((¬Frank(x))→(¬Frank(x))) ::: If there is nobody who is not, then Jack is not frank.\n(∃x (¬Frank(x) ∨ ¬Precious(x))) → ((¬Able(roderick))) ::: If there is at least one people who is not frank or not precious, then Roderick is not able.\n(∀x (Frank(x))) → (∀x (¬Precious(x) ∧ ¬Civil(x))) ::: If someone is frank, then he is neither precious nor civil.\n((¬Jolly(burgess) ∨ ¬Civil(roderick))) → ((¬Technical(george))) ::: It can be concluded that George is not technical once knowing that Burgess is not jolly or Roderick is not civil.\n(∀x (Precious(x))) ↔ (∀x (¬Frank(x))) ::: If someone is precious, then he is not frank, and vice versa.\n∀x((Able(x)∨¬Precious(x))) ::: If someone is he or not precious is technical, then he is not jolly.\n(∀x (¬Civil(x) ∧ ¬Jolly(x))) ↔ (∀x (Able(x))) ::: If someone is not civil and not jolly, then he is able, and vice versa.\n((Able(roderick))) → ((Precious(burgess) ∧ ¬Civil(jack))) ::: Roderick being able implies that Burgess is precious and Jack is not civil.\n",
                "First-Order-Logic Question": "¬Technical(george) ::: George is not technical."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬x)) → ((¬Frank(jack))) ::: If there is nobody who is not, then Jack is not frank.",
                    "gram": "¬∃x((¬Frank(x))→(¬Frank(x))) ::: If there is nobody who is not, then Jack is not frank."
                },
                {
                    "raw": "(∀x (x ∨ ¬Precious(x))) → (∀x (¬Jolly(x))) ::: If someone is he or not precious is technical, then he is not jolly.",
                    "gram": "∀x((Able(x)∨¬Precious(x))) ::: If someone is he or not precious is technical, then he is not jolly."
                }
            ],
            "answer": "A",
            "grammar_answer": "A",
            "backup_answer": "A"
        },
        {
            "id": 367,
            "raw_prog": {
                "First-Order-Logic Rules": "¬Able(jasper) ::: Jasper is not able.\n¬Frank(jack) ::: Jack is not frank.\nCivil(jasper) ::: Jasper is civil.\n¬Civil(george) ::: George is not civil.\nFrank(burgess) ::: Burgess is frank.\nJolly(roderick) ::: Roderick is jolly.\n¬Civil(myra) ::: Myra is not civil.\nPrecious(roderick) ::: Roderick is precious.\nJolly(jack) ::: Jack is jolly.\n¬Able(burgess) ::: Burgess is not able.\n¬Jolly(miles) ::: Miles is not jolly.\nJolly(jasper) ::: Jasper is jolly.\n((Jolly(burgess))) → ((¬Able(roderick))) ::: It can be concluded that Roderick is not able once knowing that Burgess is jolly.\n(∃x (Able(x) ∧ Jolly(x))) → ((¬Frank(jasper))) ::: If there is someone who is both able and jolly, then Jasper is not frank.\n(∃x (¬Frank(x) ∨ ¬Civil(x))) → ((Able(roderick))) ::: If there is at least one people who is not frank or not civil, then Roderick is able.\n(∃x (Able(x))) → ((¬Frank(george) ∧ ¬Technical(jack))) ::: If there is someone who is able, then George is not frank and Jack is not technical.\n(¬∃x (¬x)) → ((¬Frank(jack))) ::: If there is nobody who is not, then Jack is not frank.\n(∃x (¬Frank(x) ∨ ¬Precious(x))) → ((¬Able(roderick))) ::: If there is at least one people who is not frank or not precious, then Roderick is not able.\n(∀x (Frank(x))) → (∀x (¬Precious(x) ∧ ¬Civil(x))) ::: If someone is frank, then he is neither precious nor civil.\n((¬Jolly(burgess) ∨ ¬Civil(roderick))) → ((¬Technical(george))) ::: It can be concluded that George is not technical once knowing that Burgess is not jolly or Roderick is not civil.\n(∀x (Precious(x))) ↔ (∀x (¬Frank(x))) ::: If someone is precious, then he is not frank, and vice versa.\n(∀x (x ∨ ¬Precious(x))) → (∀x (¬Jolly(x))) ::: If someone is he or not precious is technical, then he is not jolly.\n(∀x (¬Civil(x) ∧ ¬Jolly(x))) ↔ (∀x (Able(x))) ::: If someone is not civil and not jolly, then he is able, and vice versa.\n((Able(roderick))) → ((Precious(burgess) ∧ ¬Civil(jack))) ::: Roderick being able implies that Burgess is precious and Jack is not civil.\n",
                "First-Order-Logic Question": "¬Jolly(miles) ::: Miles is not jolly."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "¬Able(jasper) ::: Jasper is not able.\n¬Frank(jack) ::: Jack is not frank.\nCivil(jasper) ::: Jasper is civil.\n¬Civil(george) ::: George is not civil.\nFrank(burgess) ::: Burgess is frank.\nJolly(roderick) ::: Roderick is jolly.\n¬Civil(myra) ::: Myra is not civil.\nPrecious(roderick) ::: Roderick is precious.\nJolly(jack) ::: Jack is jolly.\n¬Able(burgess) ::: Burgess is not able.\n¬Jolly(miles) ::: Miles is not jolly.\nJolly(jasper) ::: Jasper is jolly.\n((Jolly(burgess))) → ((¬Able(roderick))) ::: It can be concluded that Roderick is not able once knowing that Burgess is jolly.\n(∃x (Able(x) ∧ Jolly(x))) → ((¬Frank(jasper))) ::: If there is someone who is both able and jolly, then Jasper is not frank.\n(∃x (¬Frank(x) ∨ ¬Civil(x))) → ((Able(roderick))) ::: If there is at least one people who is not frank or not civil, then Roderick is able.\n(∃x (Able(x))) → ((¬Frank(george) ∧ ¬Technical(jack))) ::: If there is someone who is able, then George is not frank and Jack is not technical.\n¬∃x((¬Frank(x))→(¬Frank(x))) ::: If there is nobody who is not, then Jack is not frank.\n(∃x (¬Frank(x) ∨ ¬Precious(x))) → ((¬Able(roderick))) ::: If there is at least one people who is not frank or not precious, then Roderick is not able.\n(∀x (Frank(x))) → (∀x (¬Precious(x) ∧ ¬Civil(x))) ::: If someone is frank, then he is neither precious nor civil.\n((¬Jolly(burgess) ∨ ¬Civil(roderick))) → ((¬Technical(george))) ::: It can be concluded that George is not technical once knowing that Burgess is not jolly or Roderick is not civil.\n(∀x (Precious(x))) ↔ (∀x (¬Frank(x))) ::: If someone is precious, then he is not frank, and vice versa.\n∀x((Able(x)∨¬Precious(x))) ::: If someone is he or not precious is technical, then he is not jolly.\n(∀x (¬Civil(x) ∧ ¬Jolly(x))) ↔ (∀x (Able(x))) ::: If someone is not civil and not jolly, then he is able, and vice versa.\n((Able(roderick))) → ((Precious(burgess) ∧ ¬Civil(jack))) ::: Roderick being able implies that Burgess is precious and Jack is not civil.\n",
                "First-Order-Logic Question": "¬Jolly(miles) ::: Miles is not jolly."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬x)) → ((¬Frank(jack))) ::: If there is nobody who is not, then Jack is not frank.",
                    "gram": "¬∃x((¬Frank(x))→(¬Frank(x))) ::: If there is nobody who is not, then Jack is not frank."
                },
                {
                    "raw": "(∀x (x ∨ ¬Precious(x))) → (∀x (¬Jolly(x))) ::: If someone is he or not precious is technical, then he is not jolly.",
                    "gram": "∀x((Able(x)∨¬Precious(x))) ::: If someone is he or not precious is technical, then he is not jolly."
                }
            ],
            "answer": "A",
            "grammar_answer": "A",
            "backup_answer": "A"
        },
        {
            "id": 368,
            "raw_prog": {
                "First-Order-Logic Rules": "¬Able(jasper) ::: Jasper is not able.\n¬Frank(jack) ::: Jack is not frank.\nCivil(jasper) ::: Jasper is civil.\n¬Civil(george) ::: George is not civil.\nFrank(burgess) ::: Burgess is frank.\nJolly(roderick) ::: Roderick is jolly.\n¬Civil(myra) ::: Myra is not civil.\nPrecious(roderick) ::: Roderick is precious.\nJolly(jack) ::: Jack is jolly.\n¬Able(burgess) ::: Burgess is not able.\n¬Jolly(miles) ::: Miles is not jolly.\nJolly(jasper) ::: Jasper is jolly.\n((Jolly(burgess))) → ((¬Able(roderick))) ::: It can be concluded that Roderick is not able once knowing that Burgess is jolly.\n(∃x (Able(x) ∧ Jolly(x))) → ((¬Frank(jasper))) ::: If there is someone who is both able and jolly, then Jasper is not frank.\n(∃x (¬Frank(x) ∨ ¬Civil(x))) → ((Able(roderick))) ::: If there is at least one people who is not frank or not civil, then Roderick is able.\n(∃x (Able(x))) → ((¬Frank(george) ∧ ¬Technical(jack))) ::: If there is someone who is able, then George is not frank and Jack is not technical.\n(¬∃x (¬x)) → ((¬Frank(jack))) ::: If there is nobody who is not, then Jack is not frank.\n(∃x (¬Frank(x) ∨ ¬Precious(x))) → ((¬Able(roderick))) ::: If there is at least one people who is not frank or not precious, then Roderick is not able.\n(∀x (Frank(x))) → (∀x (¬Precious(x) ∧ ¬Civil(x))) ::: If someone is frank, then he is neither precious nor civil.\n((¬Jolly(burgess) ∨ ¬Civil(roderick))) → ((¬Technical(george))) ::: It can be concluded that George is not technical once knowing that Burgess is not jolly or Roderick is not civil.\n(∀x (Precious(x))) → (∀x (¬Frank(x))) ∧ (∀x (¬Frank(x))) → (∀x (¬Precious(x))) ::: If someone is precious, then he is not frank, and vice versa.\n(∀x (¬Civil(x) ∧ ¬Jolly(x))) ↔ (∀x (Able(x))) ::: If someone is not civil and not jolly, then he is able, and vice versa.\n((Able(roderick))) → ((Precious(burgess) ∧ ¬Civil(jack))) ::: Roderick being able implies that Burgess is precious and Jack is not civil.\n",
                "First-Order-Logic Question": "¬Jolly(george) ::: George is not jolly."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "¬Able(jasper) ::: Jasper is not able.\n¬Frank(jack) ::: Jack is not frank.\nCivil(jasper) ::: Jasper is civil.\n¬Civil(george) ::: George is not civil.\nFrank(burgess) ::: Burgess is frank.\nJolly(roderick) ::: Roderick is jolly.\n¬Civil(myra) ::: Myra is not civil.\nPrecious(roderick) ::: Roderick is precious.\nJolly(jack) ::: Jack is jolly.\n¬Able(burgess) ::: Burgess is not able.\n¬Jolly(miles) ::: Miles is not jolly.\nJolly(jasper) ::: Jasper is jolly.\n((Jolly(burgess))) → ((¬Able(roderick))) ::: It can be concluded that Roderick is not able once knowing that Burgess is jolly.\n(∃x (Able(x) ∧ Jolly(x))) → ((¬Frank(jasper))) ::: If there is someone who is both able and jolly, then Jasper is not frank.\n(∃x (¬Frank(x) ∨ ¬Civil(x))) → ((Able(roderick))) ::: If there is at least one people who is not frank or not civil, then Roderick is able.\n(∃x (Able(x))) → ((¬Frank(george) ∧ ¬Technical(jack))) ::: If there is someone who is able, then George is not frank and Jack is not technical.\n¬∃x((¬Frank(x))→(¬Frank(x))) ::: If there is nobody who is not, then Jack is not frank.\n(∃x (¬Frank(x) ∨ ¬Precious(x))) → ((¬Able(roderick))) ::: If there is at least one people who is not frank or not precious, then Roderick is not able.\n(∀x (Frank(x))) → (∀x (¬Precious(x) ∧ ¬Civil(x))) ::: If someone is frank, then he is neither precious nor civil.\n((¬Jolly(burgess) ∨ ¬Civil(roderick))) → ((¬Technical(george))) ::: It can be concluded that George is not technical once knowing that Burgess is not jolly or Roderick is not civil.\n(∀x (Precious(x))) → (∀x (¬Frank(x))) ∧ (∀x (¬Frank(x))) → (∀x (¬Precious(x))) ::: If someone is precious, then he is not frank, and vice versa.\n(∀x (¬Civil(x) ∧ ¬Jolly(x))) ↔ (∀x (Able(x))) ::: If someone is not civil and not jolly, then he is able, and vice versa.\n((Able(roderick))) → ((Precious(burgess) ∧ ¬Civil(jack))) ::: Roderick being able implies that Burgess is precious and Jack is not civil.\n",
                "First-Order-Logic Question": "¬Jolly(george) ::: George is not jolly."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬x)) → ((¬Frank(jack))) ::: If there is nobody who is not, then Jack is not frank.",
                    "gram": "¬∃x((¬Frank(x))→(¬Frank(x))) ::: If there is nobody who is not, then Jack is not frank."
                }
            ],
            "answer": "C",
            "grammar_answer": "A",
            "backup_answer": "C"
        },
        {
            "id": 369,
            "raw_prog": {
                "First-Order-Logic Rules": "¬Able(jasper) ::: Jasper is not able.\n¬Frank(jack) ::: Jack is not frank.\nCivil(jasper) ::: Jasper is civil.\n¬Civil(george) ::: George is not civil.\nFrank(burgess) ::: Burgess is frank.\nJolly(roderick) ::: Roderick is jolly.\n¬Civil(myra) ::: Myra is not civil.\nPrecious(roderick) ::: Roderick is precious.\nJolly(jack) ::: Jack is jolly.\n¬Able(burgess) ::: Burgess is not able.\n¬Jolly(miles) ::: Miles is not jolly.\nJolly(jasper) ::: Jasper is jolly.\n((Jolly(burgess))) → ((¬Able(roderick))) ::: It can be concluded that Roderick is not able once knowing that Burgess is jolly.\n(∃x (Able(x) ∧ Jolly(x))) → ((¬Frank(jasper))) ::: If there is someone who is both able and jolly, then Jasper is not frank.\n(∃x (¬Frank(x) ∨ ¬Civil(x))) → ((Able(roderick))) ::: If there is at least one people who is not frank or not civil, then Roderick is able.\n(∃x (Able(x))) → ((¬Frank(george) ∧ ¬Technical(jack))) ::: If there is someone who is able, then George is not frank and Jack is not technical.\n(¬∃x (¬x)) → ((¬Frank(jack))) ::: If there is nobody who is not, then Jack is not frank.\n(∃x (¬Frank(x) ∨ ¬Precious(x))) → ((¬Able(roderick))) ::: If there is at least one people who is not frank or not precious, then Roderick is not able.\n(∀x (Frank(x))) → (∀x (¬Precious(x) ∧ ¬Civil(x))) ::: If someone is frank, then he is neither precious nor civil.\n((¬Jolly(burgess) ∨ ¬Civil(roderick))) → ((¬Technical(george))) ::: It can be concluded that George is not technical once knowing that Burgess is not jolly or Roderick is not civil.\n(∀x (Precious(x))) ↔ (∀x (¬Frank(x))) ::: If someone is precious, then he is not frank, and vice versa.\n(∀x (x ∨ ¬Precious(x))) → (∀x (¬Jolly(x))) ::: If someone is he or not precious is technical, then he is not jolly.\n(∀x (¬Civil(x) ∧ ¬Jolly(x))) ↔ (∀x (Able(x))) ::: If someone is not civil and not jolly, then he is able, and vice versa.\n((Able(roderick))) → ((Precious(burgess) ∧ ¬Civil(jack))) ::: Roderick being able implies that Burgess is precious and Jack is not civil.\n",
                "First-Order-Logic Question": "¬Frank(jack) ::: Jack is not frank."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "¬Able(jasper) ::: Jasper is not able.\n¬Frank(jack) ::: Jack is not frank.\nCivil(jasper) ::: Jasper is civil.\n¬Civil(george) ::: George is not civil.\nFrank(burgess) ::: Burgess is frank.\nJolly(roderick) ::: Roderick is jolly.\n¬Civil(myra) ::: Myra is not civil.\nPrecious(roderick) ::: Roderick is precious.\nJolly(jack) ::: Jack is jolly.\n¬Able(burgess) ::: Burgess is not able.\n¬Jolly(miles) ::: Miles is not jolly.\nJolly(jasper) ::: Jasper is jolly.\n((Jolly(burgess))) → ((¬Able(roderick))) ::: It can be concluded that Roderick is not able once knowing that Burgess is jolly.\n(∃x (Able(x) ∧ Jolly(x))) → ((¬Frank(jasper))) ::: If there is someone who is both able and jolly, then Jasper is not frank.\n(∃x (¬Frank(x) ∨ ¬Civil(x))) → ((Able(roderick))) ::: If there is at least one people who is not frank or not civil, then Roderick is able.\n(∃x (Able(x))) → ((¬Frank(george) ∧ ¬Technical(jack))) ::: If there is someone who is able, then George is not frank and Jack is not technical.\n¬∃x((¬Frank(x))→(¬Frank(x))) ::: If there is nobody who is not, then Jack is not frank.\n(∃x (¬Frank(x) ∨ ¬Precious(x))) → ((¬Able(roderick))) ::: If there is at least one people who is not frank or not precious, then Roderick is not able.\n(∀x (Frank(x))) → (∀x (¬Precious(x) ∧ ¬Civil(x))) ::: If someone is frank, then he is neither precious nor civil.\n((¬Jolly(burgess) ∨ ¬Civil(roderick))) → ((¬Technical(george))) ::: It can be concluded that George is not technical once knowing that Burgess is not jolly or Roderick is not civil.\n(∀x (Precious(x))) ↔ (∀x (¬Frank(x))) ::: If someone is precious, then he is not frank, and vice versa.\n∀x((Able(x)∨¬Precious(x))) ::: If someone is he or not precious is technical, then he is not jolly.\n(∀x (¬Civil(x) ∧ ¬Jolly(x))) ↔ (∀x (Able(x))) ::: If someone is not civil and not jolly, then he is able, and vice versa.\n((Able(roderick))) → ((Precious(burgess) ∧ ¬Civil(jack))) ::: Roderick being able implies that Burgess is precious and Jack is not civil.\n",
                "First-Order-Logic Question": "¬Frank(jack) ::: Jack is not frank."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬x)) → ((¬Frank(jack))) ::: If there is nobody who is not, then Jack is not frank.",
                    "gram": "¬∃x((¬Frank(x))→(¬Frank(x))) ::: If there is nobody who is not, then Jack is not frank."
                },
                {
                    "raw": "(∀x (x ∨ ¬Precious(x))) → (∀x (¬Jolly(x))) ::: If someone is he or not precious is technical, then he is not jolly.",
                    "gram": "∀x((Able(x)∨¬Precious(x))) ::: If someone is he or not precious is technical, then he is not jolly."
                }
            ],
            "answer": "A",
            "grammar_answer": "A",
            "backup_answer": "A"
        },
        {
            "id": 370,
            "raw_prog": {
                "First-Order-Logic Rules": "¬Able(jasper) ::: Jasper is not able.\n¬Frank(jack) ::: Jack is not frank.\nCivil(jasper) ::: Jasper is civil.\n¬Civil(george) ::: George is not civil.\nFrank(burgess) ::: Burgess is frank.\nJolly(roderick) ::: Roderick is jolly.\n¬Civil(myra) ::: Myra is not civil.\nPrecious(roderick) ::: Roderick is precious.\nJolly(jack) ::: Jack is jolly.\n¬Able(burgess) ::: Burgess is not able.\n¬Jolly(miles) ::: Miles is not jolly.\nJolly(jasper) ::: Jasper is jolly.\n((Jolly(burgess))) → ((¬Able(roderick))) ::: It can be concluded that Roderick is not able once knowing that Burgess is jolly.\n(∃x (Able(x) ∧ Jolly(x))) → ((¬Frank(jasper))) ::: If there is someone who is both able and jolly, then Jasper is not frank.\n(∃x (¬Frank(x) ∨ ¬Civil(x))) → ((Able(roderick))) ::: If there is at least one people who is not frank or not civil, then Roderick is able.\n(∃x (Able(x))) → ((¬Frank(george) ∧ ¬Technical(jack))) ::: If there is someone who is able, then George is not frank and Jack is not technical.\n(¬∃x (¬x)) → ((¬Frank(jack))) ::: If there is nobody who is not, then Jack is not frank.\n(∃x (¬Frank(x) ∨ ¬Precious(x))) → ((¬Able(roderick))) ::: If there is at least one people who is not frank or not precious, then Roderick is not able.\n(∀x (Frank(x))) → (∀x (¬Precious(x) ∧ ¬Civil(x))) ::: If someone is frank, then he is neither precious nor civil.\n((¬Jolly(burgess) ∨ ¬Civil(roderick))) → ((¬Technical(george))) ::: It can be concluded that George is not technical once knowing that Burgess is not jolly or Roderick is not civil.\n(∀x (Precious(x))) → (∀x (¬Frank(x))) ∧ (∀x (¬Frank(x))) → (∀x (¬Precious(x))) ::: If someone is precious, then he is not frank, and vice versa.\n(∀x (¬Civil(x) ∧ ¬Jolly(x))) ↔ (∀x (Able(x))) ::: If someone is not civil and not jolly, then he is able, and vice versa.\n((Able(roderick))) → ((Precious(burgess) ∧ ¬Civil(jack))) ::: Roderick being able implies that Burgess is precious and Jack is not civil.\n",
                "First-Order-Logic Question": "¬Frank(roderick) ::: Roderick is not frank."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "¬Able(jasper) ::: Jasper is not able.\n¬Frank(jack) ::: Jack is not frank.\nCivil(jasper) ::: Jasper is civil.\n¬Civil(george) ::: George is not civil.\nFrank(burgess) ::: Burgess is frank.\nJolly(roderick) ::: Roderick is jolly.\n¬Civil(myra) ::: Myra is not civil.\nPrecious(roderick) ::: Roderick is precious.\nJolly(jack) ::: Jack is jolly.\n¬Able(burgess) ::: Burgess is not able.\n¬Jolly(miles) ::: Miles is not jolly.\nJolly(jasper) ::: Jasper is jolly.\n((Jolly(burgess))) → ((¬Able(roderick))) ::: It can be concluded that Roderick is not able once knowing that Burgess is jolly.\n(∃x (Able(x) ∧ Jolly(x))) → ((¬Frank(jasper))) ::: If there is someone who is both able and jolly, then Jasper is not frank.\n(∃x (¬Frank(x) ∨ ¬Civil(x))) → ((Able(roderick))) ::: If there is at least one people who is not frank or not civil, then Roderick is able.\n(∃x (Able(x))) → ((¬Frank(george) ∧ ¬Technical(jack))) ::: If there is someone who is able, then George is not frank and Jack is not technical.\n¬∃x((¬Frank(x))→(¬Frank(x))) ::: If there is nobody who is not, then Jack is not frank.\n(∃x (¬Frank(x) ∨ ¬Precious(x))) → ((¬Able(roderick))) ::: If there is at least one people who is not frank or not precious, then Roderick is not able.\n(∀x (Frank(x))) → (∀x (¬Precious(x) ∧ ¬Civil(x))) ::: If someone is frank, then he is neither precious nor civil.\n((¬Jolly(burgess) ∨ ¬Civil(roderick))) → ((¬Technical(george))) ::: It can be concluded that George is not technical once knowing that Burgess is not jolly or Roderick is not civil.\n(∀x (Precious(x))) → (∀x (¬Frank(x))) ∧ (∀x (¬Frank(x))) → (∀x (¬Precious(x))) ::: If someone is precious, then he is not frank, and vice versa.\n(∀x (¬Civil(x) ∧ ¬Jolly(x))) ↔ (∀x (Able(x))) ::: If someone is not civil and not jolly, then he is able, and vice versa.\n((Able(roderick))) → ((Precious(burgess) ∧ ¬Civil(jack))) ::: Roderick being able implies that Burgess is precious and Jack is not civil.\n",
                "First-Order-Logic Question": "¬Frank(roderick) ::: Roderick is not frank."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬x)) → ((¬Frank(jack))) ::: If there is nobody who is not, then Jack is not frank.",
                    "gram": "¬∃x((¬Frank(x))→(¬Frank(x))) ::: If there is nobody who is not, then Jack is not frank."
                }
            ],
            "answer": "A",
            "grammar_answer": "A",
            "backup_answer": "A"
        },
        {
            "id": 371,
            "raw_prog": {
                "First-Order-Logic Rules": "¬Able(jasper) ::: Jasper is not able.\n¬Frank(jack) ::: Jack is not frank.\nCivil(jasper) ::: Jasper is civil.\n¬Civil(george) ::: George is not civil.\nFrank(burgess) ::: Burgess is frank.\nJolly(roderick) ::: Roderick is jolly.\n¬Civil(myra) ::: Myra is not civil.\nPrecious(roderick) ::: Roderick is precious.\nJolly(jack) ::: Jack is jolly.\n¬Able(burgess) ::: Burgess is not able.\n¬Jolly(miles) ::: Miles is not jolly.\nJolly(jasper) ::: Jasper is jolly.\n((Jolly(burgess))) → ((¬Able(roderick))) ::: It can be concluded that Roderick is not able once knowing that Burgess is jolly.\n(∃x (Able(x) ∧ Jolly(x))) → ((¬Frank(jasper))) ::: If there is someone who is both able and jolly, then Jasper is not frank.\n(∃x (¬Frank(x) ∨ ¬Civil(x))) → ((Able(roderick))) ::: If there is at least one people who is not frank or not civil, then Roderick is able.\n(∃x (Able(x))) → ((¬Frank(george) ∧ ¬Technical(jack))) ::: If there is someone who is able, then George is not frank and Jack is not technical.\n(¬∃x (¬Frank(x))) → ((¬Frank(jack))) ::: If there is nobody who is not, then Jack is not frank.\n(∃x (¬Frank(x) ∨ ¬Precious(x))) → ((¬Able(roderick))) ::: If there is at least one people who is not frank or not precious, then Roderick is not able.\n(∀x (Frank(x))) → (∀x (¬Precious(x) ∧ ¬Civil(x))) ::: If someone is frank, then he is neither precious nor civil.\n((¬Jolly(burgess) ∨ ¬Civil(roderick))) → ((¬Technical(george))) ::: It can be concluded that George is not technical once knowing that Burgess is not jolly or Roderick is not civil.\n(∀x (Precious(x))) ↔ (∀x (¬Frank(x))) ::: If someone is precious, then he is not frank, and vice versa.\n(∀x (¬Civil(x) ∧ ¬Jolly(x))) ↔ (∀x (Able(x))) ::: If someone is not civil and not jolly, then he is able, and vice versa.\n((Able(roderick))) → ((Precious(burgess) ∧ ¬Civil(jack))) ::: Roderick being able implies that Burgess is precious and Jack is not civil.\n",
                "First-Order-Logic Question": "¬Able(myra) ::: Myra is not able."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "¬Able(jasper) ::: Jasper is not able.\n¬Frank(jack) ::: Jack is not frank.\nCivil(jasper) ::: Jasper is civil.\n¬Civil(george) ::: George is not civil.\nFrank(burgess) ::: Burgess is frank.\nJolly(roderick) ::: Roderick is jolly.\n¬Civil(myra) ::: Myra is not civil.\nPrecious(roderick) ::: Roderick is precious.\nJolly(jack) ::: Jack is jolly.\n¬Able(burgess) ::: Burgess is not able.\n¬Jolly(miles) ::: Miles is not jolly.\nJolly(jasper) ::: Jasper is jolly.\n((Jolly(burgess))) → ((¬Able(roderick))) ::: It can be concluded that Roderick is not able once knowing that Burgess is jolly.\n(∃x (Able(x) ∧ Jolly(x))) → ((¬Frank(jasper))) ::: If there is someone who is both able and jolly, then Jasper is not frank.\n(∃x (¬Frank(x) ∨ ¬Civil(x))) → ((Able(roderick))) ::: If there is at least one people who is not frank or not civil, then Roderick is able.\n(∃x (Able(x))) → ((¬Frank(george) ∧ ¬Technical(jack))) ::: If there is someone who is able, then George is not frank and Jack is not technical.\n¬∃x(¬Frank(x))→((¬Frank(x))) ::: If there is nobody who is not, then Jack is not frank.\n(∃x (¬Frank(x) ∨ ¬Precious(x))) → ((¬Able(roderick))) ::: If there is at least one people who is not frank or not precious, then Roderick is not able.\n(∀x (Frank(x))) → (∀x (¬Precious(x) ∧ ¬Civil(x))) ::: If someone is frank, then he is neither precious nor civil.\n((¬Jolly(burgess) ∨ ¬Civil(roderick))) → ((¬Technical(george))) ::: It can be concluded that George is not technical once knowing that Burgess is not jolly or Roderick is not civil.\n(∀x (Precious(x))) ↔ (∀x (¬Frank(x))) ::: If someone is precious, then he is not frank, and vice versa.\n(∀x (¬Civil(x) ∧ ¬Jolly(x))) ↔ (∀x (Able(x))) ::: If someone is not civil and not jolly, then he is able, and vice versa.\n((Able(roderick))) → ((Precious(burgess) ∧ ¬Civil(jack))) ::: Roderick being able implies that Burgess is precious and Jack is not civil.\n",
                "First-Order-Logic Question": "¬Able(myra) ::: Myra is not able."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬Frank(x))) → ((¬Frank(jack))) ::: If there is nobody who is not, then Jack is not frank.",
                    "gram": "¬∃x(¬Frank(x))→((¬Frank(x))) ::: If there is nobody who is not, then Jack is not frank."
                }
            ],
            "answer": "C",
            "grammar_answer": "A",
            "backup_answer": "B"
        },
        {
            "id": 372,
            "raw_prog": {
                "First-Order-Logic Rules": "¬Able(jasper) ::: Jasper is not able.\n¬Frank(jack) ::: Jack is not frank.\nCivil(jasper) ::: Jasper is civil.\n¬Civil(george) ::: George is not civil.\nFrank(burgess) ::: Burgess is frank.\nJolly(roderick) ::: Roderick is jolly.\n¬Civil(myra) ::: Myra is not civil.\nPrecious(roderick) ::: Roderick is precious.\nJolly(jack) ::: Jack is jolly.\n¬Able(burgess) ::: Burgess is not able.\n¬Jolly(miles) ::: Miles is not jolly.\nJolly(jasper) ::: Jasper is jolly.\n((Jolly(burgess))) → ((¬Able(roderick))) ::: It can be concluded that Roderick is not able once knowing that Burgess is jolly.\n(∃x (Able(x) ∧ Jolly(x))) → ((¬Frank(jasper))) ::: If there is someone who is both able and jolly, then Jasper is not frank.\n(∃x (¬Frank(x) ∨ ¬Civil(x))) → ((Able(roderick))) ::: If there is at least one people who is not frank or not civil, then Roderick is able.\n(∃x (Able(x))) → ((¬Frank(george) ∧ ¬Technical(jack))) ::: If there is someone who is able, then George is not frank and Jack is not technical.\n(¬∃x (¬x)) → ((¬Frank(jack))) ::: If there is nobody who is not, then Jack is not frank.\n(∃x (¬Frank(x) ∨ ¬Precious(x))) → ((¬Able(roderick))) ::: If there is at least one people who is not frank or not precious, then Roderick is not able.\n(∀x (Frank(x))) → (∀x (¬Precious(x) ∧ ¬Civil(x))) ::: If someone is frank, then he is neither precious nor civil.\n((¬Jolly(burgess) ∨ ¬Civil(roderick))) → ((¬Technical(george))) ::: It can be concluded that George is not technical once knowing that Burgess is not jolly or Roderick is not civil.\n(∀x (Precious(x))) → (∀x (¬Frank(x))) ∧ (∀x (¬Frank(x))) → (∀x (¬Precious(x))) ::: If someone is precious, then he is not frank, and vice versa.\n(∀x (¬Precious(x) ∨ Technical(x))) → (∀x (¬Jolly(x))) ::: If someone is he or not precious is technical, then he is not jolly.\n(∀x (¬Civil(x) ∧ ¬Jolly(x))) ↔ (∀x (Able(x))) ::: If someone is not civil and not jolly, then he is able, and vice versa.\n((Able(roderick))) → ((Precious(burgess) ∧ ¬Civil(jack))) ::: Roderick being able implies that Burgess is precious and Jack is not civil.\n",
                "First-Order-Logic Question": "¬Jolly(jack) ::: Jack is not jolly."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "¬Able(jasper) ::: Jasper is not able.\n¬Frank(jack) ::: Jack is not frank.\nCivil(jasper) ::: Jasper is civil.\n¬Civil(george) ::: George is not civil.\nFrank(burgess) ::: Burgess is frank.\nJolly(roderick) ::: Roderick is jolly.\n¬Civil(myra) ::: Myra is not civil.\nPrecious(roderick) ::: Roderick is precious.\nJolly(jack) ::: Jack is jolly.\n¬Able(burgess) ::: Burgess is not able.\n¬Jolly(miles) ::: Miles is not jolly.\nJolly(jasper) ::: Jasper is jolly.\n((Jolly(burgess))) → ((¬Able(roderick))) ::: It can be concluded that Roderick is not able once knowing that Burgess is jolly.\n(∃x (Able(x) ∧ Jolly(x))) → ((¬Frank(jasper))) ::: If there is someone who is both able and jolly, then Jasper is not frank.\n(∃x (¬Frank(x) ∨ ¬Civil(x))) → ((Able(roderick))) ::: If there is at least one people who is not frank or not civil, then Roderick is able.\n(∃x (Able(x))) → ((¬Frank(george) ∧ ¬Technical(jack))) ::: If there is someone who is able, then George is not frank and Jack is not technical.\n¬∃x((¬Frank(x))→(¬Frank(x))) ::: If there is nobody who is not, then Jack is not frank.\n(∃x (¬Frank(x) ∨ ¬Precious(x))) → ((¬Able(roderick))) ::: If there is at least one people who is not frank or not precious, then Roderick is not able.\n(∀x (Frank(x))) → (∀x (¬Precious(x) ∧ ¬Civil(x))) ::: If someone is frank, then he is neither precious nor civil.\n((¬Jolly(burgess) ∨ ¬Civil(roderick))) → ((¬Technical(george))) ::: It can be concluded that George is not technical once knowing that Burgess is not jolly or Roderick is not civil.\n(∀x (Precious(x))) → (∀x (¬Frank(x))) ∧ (∀x (¬Frank(x))) → (∀x (¬Precious(x))) ::: If someone is precious, then he is not frank, and vice versa.\n(∀x (¬Precious(x) ∨ Technical(x))) → (∀x (¬Jolly(x))) ::: If someone is he or not precious is technical, then he is not jolly.\n(∀x (¬Civil(x) ∧ ¬Jolly(x))) ↔ (∀x (Able(x))) ::: If someone is not civil and not jolly, then he is able, and vice versa.\n((Able(roderick))) → ((Precious(burgess) ∧ ¬Civil(jack))) ::: Roderick being able implies that Burgess is precious and Jack is not civil.\n",
                "First-Order-Logic Question": "¬Jolly(jack) ::: Jack is not jolly."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬x)) → ((¬Frank(jack))) ::: If there is nobody who is not, then Jack is not frank.",
                    "gram": "¬∃x((¬Frank(x))→(¬Frank(x))) ::: If there is nobody who is not, then Jack is not frank."
                }
            ],
            "answer": "B",
            "grammar_answer": "A",
            "backup_answer": "B"
        },
        {
            "id": 373,
            "raw_prog": {
                "First-Order-Logic Rules": "¬Able(jasper) ::: Jasper is not able.\n¬Frank(jack) ::: Jack is not frank.\nCivil(jasper) ::: Jasper is civil.\n¬Civil(george) ::: George is not civil.\nFrank(burgess) ::: Burgess is frank.\nJolly(roderick) ::: Roderick is jolly.\n¬Civil(myra) ::: Myra is not civil.\nPrecious(roderick) ::: Roderick is precious.\nJolly(jack) ::: Jack is jolly.\n¬Able(burgess) ::: Burgess is not able.\n¬Jolly(miles) ::: Miles is not jolly.\nJolly(jasper) ::: Jasper is jolly.\n((Jolly(burgess))) → ((¬Able(roderick))) ::: It can be concluded that Roderick is not able once knowing that Burgess is jolly.\n(∃x (Able(x) ∧ Jolly(x))) → ((¬Frank(jasper))) ::: If there is someone who is both able and jolly, then Jasper is not frank.\n(∃x (¬Frank(x) ∨ ¬Civil(x))) → ((Able(roderick))) ::: If there is at least one people who is not frank or not civil, then Roderick is able.\n(∃x (Able(x))) → ((¬Frank(george) ∧ ¬Technical(jack))) ::: If there is someone who is able, then George is not frank and Jack is not technical.\n(¬∃x (¬Frank(x))) → ((¬Frank(jack))) ::: If there is nobody who is not, then Jack is not frank.\n(∃x (¬Frank(x) ∨ ¬Precious(x))) → ((¬Able(roderick))) ::: If there is at least one people who is not frank or not precious, then Roderick is not able.\n(∀x (Frank(x))) → (∀x (¬Precious(x) ∧ ¬Civil(x))) ::: If someone is frank, then he is neither precious nor civil.\n((¬Jolly(burgess) ∨ ¬Civil(roderick))) → ((¬Technical(george))) ::: It can be concluded that George is not technical once knowing that Burgess is not jolly or Roderick is not civil.\n(∀x (Precious(x))) ↔ (∀x (¬Frank(x))) ::: If someone is precious, then he is not frank, and vice versa.\n(∀x (¬Civil(x) ∧ ¬Jolly(x))) ↔ (∀x (Able(x))) ::: If someone is not civil and not jolly, then he is able, and vice versa.\n((Able(roderick))) → ((Precious(burgess) ∧ ¬Civil(jack))) ::: Roderick being able implies that Burgess is precious and Jack is not civil.\n",
                "First-Order-Logic Question": "Jolly(george) ::: George is jolly."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "¬Able(jasper) ::: Jasper is not able.\n¬Frank(jack) ::: Jack is not frank.\nCivil(jasper) ::: Jasper is civil.\n¬Civil(george) ::: George is not civil.\nFrank(burgess) ::: Burgess is frank.\nJolly(roderick) ::: Roderick is jolly.\n¬Civil(myra) ::: Myra is not civil.\nPrecious(roderick) ::: Roderick is precious.\nJolly(jack) ::: Jack is jolly.\n¬Able(burgess) ::: Burgess is not able.\n¬Jolly(miles) ::: Miles is not jolly.\nJolly(jasper) ::: Jasper is jolly.\n((Jolly(burgess))) → ((¬Able(roderick))) ::: It can be concluded that Roderick is not able once knowing that Burgess is jolly.\n(∃x (Able(x) ∧ Jolly(x))) → ((¬Frank(jasper))) ::: If there is someone who is both able and jolly, then Jasper is not frank.\n(∃x (¬Frank(x) ∨ ¬Civil(x))) → ((Able(roderick))) ::: If there is at least one people who is not frank or not civil, then Roderick is able.\n(∃x (Able(x))) → ((¬Frank(george) ∧ ¬Technical(jack))) ::: If there is someone who is able, then George is not frank and Jack is not technical.\n¬∃x(¬Frank(x))→((¬Frank(x))) ::: If there is nobody who is not, then Jack is not frank.\n(∃x (¬Frank(x) ∨ ¬Precious(x))) → ((¬Able(roderick))) ::: If there is at least one people who is not frank or not precious, then Roderick is not able.\n(∀x (Frank(x))) → (∀x (¬Precious(x) ∧ ¬Civil(x))) ::: If someone is frank, then he is neither precious nor civil.\n((¬Jolly(burgess) ∨ ¬Civil(roderick))) → ((¬Technical(george))) ::: It can be concluded that George is not technical once knowing that Burgess is not jolly or Roderick is not civil.\n(∀x (Precious(x))) ↔ (∀x (¬Frank(x))) ::: If someone is precious, then he is not frank, and vice versa.\n(∀x (¬Civil(x) ∧ ¬Jolly(x))) ↔ (∀x (Able(x))) ::: If someone is not civil and not jolly, then he is able, and vice versa.\n((Able(roderick))) → ((Precious(burgess) ∧ ¬Civil(jack))) ::: Roderick being able implies that Burgess is precious and Jack is not civil.\n",
                "First-Order-Logic Question": "Jolly(george) ::: George is jolly."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬Frank(x))) → ((¬Frank(jack))) ::: If there is nobody who is not, then Jack is not frank.",
                    "gram": "¬∃x(¬Frank(x))→((¬Frank(x))) ::: If there is nobody who is not, then Jack is not frank."
                }
            ],
            "answer": "C",
            "grammar_answer": "A",
            "backup_answer": "C"
        },
        {
            "id": 374,
            "raw_prog": {
                "First-Order-Logic Rules": "¬Able(jasper) ::: Jasper is not able.\n¬Frank(jack) ::: Jack is not frank.\nCivil(jasper) ::: Jasper is civil.\n¬Civil(george) ::: George is not civil.\nFrank(burgess) ::: Burgess is frank.\nJolly(roderick) ::: Roderick is jolly.\n¬Civil(myra) ::: Myra is not civil.\nPrecious(roderick) ::: Roderick is precious.\nJolly(jack) ::: Jack is jolly.\n¬Able(burgess) ::: Burgess is not able.\n¬Jolly(miles) ::: Miles is not jolly.\nJolly(jasper) ::: Jasper is jolly.\n((Jolly(burgess))) → ((¬Able(roderick))) ::: It can be concluded that Roderick is not able once knowing that Burgess is jolly.\n(∃x (Able(x) ∧ Jolly(x))) → ((¬Frank(jasper))) ::: If there is someone who is both able and jolly, then Jasper is not frank.\n(∃x (¬Frank(x) ∨ ¬Civil(x))) → ((Able(roderick))) ::: If there is at least one people who is not frank or not civil, then Roderick is able.\n(∃x (Able(x))) → ((¬Frank(george) ∧ ¬Technical(jack))) ::: If there is someone who is able, then George is not frank and Jack is not technical.\n(¬∃x (¬x)) → ((¬Frank(jack))) ::: If there is nobody who is not, then Jack is not frank.\n(∃x (¬Frank(x) ∨ ¬Precious(x))) → ((¬Able(roderick))) ::: If there is at least one people who is not frank or not precious, then Roderick is not able.\n(∀x (Frank(x))) → (∀x (¬Precious(x) ∧ ¬Civil(x))) ::: If someone is frank, then he is neither precious nor civil.\n((¬Jolly(burgess) ∨ ¬Civil(roderick))) → ((¬Technical(george))) ::: It can be concluded that George is not technical once knowing that Burgess is not jolly or Roderick is not civil.\n(∀x (Precious(x))) → (∀x (¬Frank(x))) ∧ (∀x (¬Frank(x))) → (∀x (¬Precious(x))) ::: If someone is precious, then he is not frank, and vice versa.\n(∀x (¬Civil(x) ∧ ¬Jolly(x))) ↔ (∀x (Able(x))) ::: If someone is not civil and not jolly, then he is able, and vice versa.\n((Able(roderick))) → ((Precious(burgess) ∧ ¬Civil(jack))) ::: Roderick being able implies that Burgess is precious and Jack is not civil.\n",
                "First-Order-Logic Question": "¬Civil(jasper) ::: Jasper is not civil."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "¬Able(jasper) ::: Jasper is not able.\n¬Frank(jack) ::: Jack is not frank.\nCivil(jasper) ::: Jasper is civil.\n¬Civil(george) ::: George is not civil.\nFrank(burgess) ::: Burgess is frank.\nJolly(roderick) ::: Roderick is jolly.\n¬Civil(myra) ::: Myra is not civil.\nPrecious(roderick) ::: Roderick is precious.\nJolly(jack) ::: Jack is jolly.\n¬Able(burgess) ::: Burgess is not able.\n¬Jolly(miles) ::: Miles is not jolly.\nJolly(jasper) ::: Jasper is jolly.\n((Jolly(burgess))) → ((¬Able(roderick))) ::: It can be concluded that Roderick is not able once knowing that Burgess is jolly.\n(∃x (Able(x) ∧ Jolly(x))) → ((¬Frank(jasper))) ::: If there is someone who is both able and jolly, then Jasper is not frank.\n(∃x (¬Frank(x) ∨ ¬Civil(x))) → ((Able(roderick))) ::: If there is at least one people who is not frank or not civil, then Roderick is able.\n(∃x (Able(x))) → ((¬Frank(george) ∧ ¬Technical(jack))) ::: If there is someone who is able, then George is not frank and Jack is not technical.\n¬∃x((¬Frank(x))→(¬Frank(x))) ::: If there is nobody who is not, then Jack is not frank.\n(∃x (¬Frank(x) ∨ ¬Precious(x))) → ((¬Able(roderick))) ::: If there is at least one people who is not frank or not precious, then Roderick is not able.\n(∀x (Frank(x))) → (∀x (¬Precious(x) ∧ ¬Civil(x))) ::: If someone is frank, then he is neither precious nor civil.\n((¬Jolly(burgess) ∨ ¬Civil(roderick))) → ((¬Technical(george))) ::: It can be concluded that George is not technical once knowing that Burgess is not jolly or Roderick is not civil.\n(∀x (Precious(x))) → (∀x (¬Frank(x))) ∧ (∀x (¬Frank(x))) → (∀x (¬Precious(x))) ::: If someone is precious, then he is not frank, and vice versa.\n(∀x (¬Civil(x) ∧ ¬Jolly(x))) ↔ (∀x (Able(x))) ::: If someone is not civil and not jolly, then he is able, and vice versa.\n((Able(roderick))) → ((Precious(burgess) ∧ ¬Civil(jack))) ::: Roderick being able implies that Burgess is precious and Jack is not civil.\n",
                "First-Order-Logic Question": "¬Civil(jasper) ::: Jasper is not civil."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬x)) → ((¬Frank(jack))) ::: If there is nobody who is not, then Jack is not frank.",
                    "gram": "¬∃x((¬Frank(x))→(¬Frank(x))) ::: If there is nobody who is not, then Jack is not frank."
                }
            ],
            "answer": "B",
            "grammar_answer": "A",
            "backup_answer": "B"
        },
        {
            "id": 420,
            "raw_prog": {
                "First-Order-Logic Rules": "Poor(jack) ::: Jack is poor.\n¬Fearless(lesley) ::: Lesley is not fearless.\nWonderful(lamont) ::: Lamont is wonderful.\n¬Poor(lamont) ::: Lamont is not poor.\n¬Combative(lesley) ::: Lesley is not combative.\n¬Bewildered(iver) ::: Iver is not bewildered.\n¬Fearless(blaine) ::: Blaine is not fearless.\nStubborn(lancelot) ::: Lancelot is stubborn.\nStubborn(lamont) ::: Lamont is stubborn.\n¬Bewildered(lancelot) ::: Lancelot is not bewildered.\nWonderful(lancelot) ::: Lancelot is wonderful.\nPoor(lancelot) ::: Lancelot is poor.\n(∀x (x ∨ ¬Wonderful(x) ∧ Combative(x))) → (∀x (¬Poor(x))) ::: If someone is he or not wonderful is combative, then he is not poor.\n(∀x (Poor(x) ∧ Stubborn(x))) → (∀x (Fearless(x))) ::: If someone who is poor is also stubborn, then he is fearless.\n(∃x (Combative(x) ∧ ¬Poor(x))) → ((Bewildered(jack))) ::: If there is someone who is both combative and not poor, then Jack is bewildered.\n(∀x (¬Fearless(x) ∧ ¬Combative(x))) ↔ (∀x (Bewildered(x))) ::: If someone is not fearless and not combative, then he is bewildered, and vice versa.\n(¬Stubborn(lancelot)) ↔ (¬Poor(jack)) ::: Lancelot is not stubborn if and only if Jack is not poor.\n((Fearless(olive))) → ((Bewildered(lamont) ∧ Combative(lancelot))) ::: Olive being fearless implies that Lamont is bewildered and Lancelot is combative.\n(∀x (¬Bewildered(x))) → (∀x (Poor(x) ∧ ¬Stubborn(x))) ::: If someone is not bewildered, then he is both poor and not stubborn.\n(∀x (Stubborn(x))) → (∀x (¬Bewildered(x))) ::: If someone is stubborn, then he is not bewildered.\n((Poor(jack) ∧ ¬Fearless(lamont))) → ((Stubborn(blaine))) ::: It can be concluded that Blaine is stubborn once knowing that Jack is poor and Lamont is not fearless.\n(∃x (¬Fearless(x))) → ((¬Bewildered(iver))) ::: If there is someone who is not fearless, then Iver is not bewildered.\n(∃x (¬Fearless(x) ∨ ¬Stubborn(x))) → ((¬Wonderful(jack))) ::: If there is someone who is either not fearless or not stubborn, then Jack is not wonderful.\n(∀x (Bewildered(olive))) ↔ (∀x (Stubborn(blaine))) ::: Olive being bewildered is equivalent to Blaine being stubborn.\n",
                "First-Order-Logic Question": "Fearless(iver) ::: Iver is fearless."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "Poor(jack) ::: Jack is poor.\n¬Fearless(lesley) ::: Lesley is not fearless.\nWonderful(lamont) ::: Lamont is wonderful.\n¬Poor(lamont) ::: Lamont is not poor.\n¬Combative(lesley) ::: Lesley is not combative.\n¬Bewildered(iver) ::: Iver is not bewildered.\n¬Fearless(blaine) ::: Blaine is not fearless.\nStubborn(lancelot) ::: Lancelot is stubborn.\nStubborn(lamont) ::: Lamont is stubborn.\n¬Bewildered(lancelot) ::: Lancelot is not bewildered.\nWonderful(lancelot) ::: Lancelot is wonderful.\nPoor(lancelot) ::: Lancelot is poor.\n∀x((Wonderful(x)∨Combative(x))) ::: If someone is he or not wonderful is combative, then he is not poor.\n(∀x (Poor(x) ∧ Stubborn(x))) → (∀x (Fearless(x))) ::: If someone who is poor is also stubborn, then he is fearless.\n(∃x (Combative(x) ∧ ¬Poor(x))) → ((Bewildered(jack))) ::: If there is someone who is both combative and not poor, then Jack is bewildered.\n(∀x (¬Fearless(x) ∧ ¬Combative(x))) ↔ (∀x (Bewildered(x))) ::: If someone is not fearless and not combative, then he is bewildered, and vice versa.\n(¬Stubborn(lancelot)) ↔ (¬Poor(jack)) ::: Lancelot is not stubborn if and only if Jack is not poor.\n((Fearless(olive))) → ((Bewildered(lamont) ∧ Combative(lancelot))) ::: Olive being fearless implies that Lamont is bewildered and Lancelot is combative.\n(∀x (¬Bewildered(x))) → (∀x (Poor(x) ∧ ¬Stubborn(x))) ::: If someone is not bewildered, then he is both poor and not stubborn.\n(∀x (Stubborn(x))) → (∀x (¬Bewildered(x))) ::: If someone is stubborn, then he is not bewildered.\n((Poor(jack) ∧ ¬Fearless(lamont))) → ((Stubborn(blaine))) ::: It can be concluded that Blaine is stubborn once knowing that Jack is poor and Lamont is not fearless.\n(∃x (¬Fearless(x))) → ((¬Bewildered(iver))) ::: If there is someone who is not fearless, then Iver is not bewildered.\n(∃x (¬Fearless(x) ∨ ¬Stubborn(x))) → ((¬Wonderful(jack))) ::: If there is someone who is either not fearless or not stubborn, then Jack is not wonderful.\n(∀x (Bewildered(olive))) ↔ (∀x (Stubborn(blaine))) ::: Olive being bewildered is equivalent to Blaine being stubborn.\n",
                "First-Order-Logic Question": "Fearless(iver) ::: Iver is fearless."
            },
            "diff": [
                {
                    "raw": "(∀x (x ∨ ¬Wonderful(x) ∧ Combative(x))) → (∀x (¬Poor(x))) ::: If someone is he or not wonderful is combative, then he is not poor.",
                    "gram": "∀x((Wonderful(x)∨Combative(x))) ::: If someone is he or not wonderful is combative, then he is not poor."
                }
            ],
            "answer": "C",
            "grammar_answer": "C",
            "backup_answer": "A"
        },
        {
            "id": 425,
            "raw_prog": {
                "First-Order-Logic Rules": "Poor(jack) ::: Jack is poor.\n¬Fearless(lesley) ::: Lesley is not fearless.\nWonderful(lamont) ::: Lamont is wonderful.\n¬Poor(lamont) ::: Lamont is not poor.\n¬Combative(lesley) ::: Lesley is not combative.\n¬Bewildered(iver) ::: Iver is not bewildered.\n¬Fearless(blaine) ::: Blaine is not fearless.\nStubborn(lancelot) ::: Lancelot is stubborn.\nStubborn(lamont) ::: Lamont is stubborn.\n¬Bewildered(lancelot) ::: Lancelot is not bewildered.\nWonderful(lancelot) ::: Lancelot is wonderful.\nPoor(lancelot) ::: Lancelot is poor.\n(∀x (x ∨ ¬Wonderful(x) ∧ Combative(x))) → (∀x (¬Poor(x))) ::: If someone is he or not wonderful is combative, then he is not poor.\n(∀x (Poor(x) ∧ Stubborn(x))) → (∀x (Fearless(x))) ::: If someone who is poor is also stubborn, then he is fearless.\n(∃x (Combative(x) ∧ ¬Poor(x))) → ((Bewildered(jack))) ::: If there is someone who is both combative and not poor, then Jack is bewildered.\n(∀x (¬Fearless(x) ∧ ¬Combative(x))) ↔ (∀x (Bewildered(x))) ::: If someone is not fearless and not combative, then he is bewildered, and vice versa.\n(¬Stubborn(lancelot)) ↔ (¬Poor(jack)) ::: Lancelot is not stubborn if and only if Jack is not poor.\n((Fearless(olive))) → ((Bewildered(lamont) ∧ Combative(lancelot))) ::: Olive being fearless implies that Lamont is bewildered and Lancelot is combative.\n(∀x (¬Bewildered(x))) → (∀x (Poor(x) ∧ ¬Stubborn(x))) ::: If someone is not bewildered, then he is both poor and not stubborn.\n(∀x (Stubborn(x))) → (∀x (¬Bewildered(x))) ::: If someone is stubborn, then he is not bewildered.\n((Poor(jack) ∧ ¬Fearless(lamont))) → ((Stubborn(blaine))) ::: It can be concluded that Blaine is stubborn once knowing that Jack is poor and Lamont is not fearless.\n(∃x (¬Fearless(x))) → ((¬Bewildered(iver))) ::: If there is someone who is not fearless, then Iver is not bewildered.\n(∃x (¬Fearless(x) ∨ ¬Stubborn(x))) → ((¬Wonderful(jack))) ::: If there is someone who is either not fearless or not stubborn, then Jack is not wonderful.\n(∀x (Bewildered(olive))) ↔ (∀x (Stubborn(blaine))) ::: Olive being bewildered is equivalent to Blaine being stubborn.\n",
                "First-Order-Logic Question": "Combative(olive) ::: Olive is combative."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "Poor(jack) ::: Jack is poor.\n¬Fearless(lesley) ::: Lesley is not fearless.\nWonderful(lamont) ::: Lamont is wonderful.\n¬Poor(lamont) ::: Lamont is not poor.\n¬Combative(lesley) ::: Lesley is not combative.\n¬Bewildered(iver) ::: Iver is not bewildered.\n¬Fearless(blaine) ::: Blaine is not fearless.\nStubborn(lancelot) ::: Lancelot is stubborn.\nStubborn(lamont) ::: Lamont is stubborn.\n¬Bewildered(lancelot) ::: Lancelot is not bewildered.\nWonderful(lancelot) ::: Lancelot is wonderful.\nPoor(lancelot) ::: Lancelot is poor.\n∀x((Wonderful(x)∨¬Poor(x))) ::: If someone is he or not wonderful is combative, then he is not poor.\n(∀x (Poor(x) ∧ Stubborn(x))) → (∀x (Fearless(x))) ::: If someone who is poor is also stubborn, then he is fearless.\n(∃x (Combative(x) ∧ ¬Poor(x))) → ((Bewildered(jack))) ::: If there is someone who is both combative and not poor, then Jack is bewildered.\n(∀x (¬Fearless(x) ∧ ¬Combative(x))) ↔ (∀x (Bewildered(x))) ::: If someone is not fearless and not combative, then he is bewildered, and vice versa.\n(¬Stubborn(lancelot)) ↔ (¬Poor(jack)) ::: Lancelot is not stubborn if and only if Jack is not poor.\n((Fearless(olive))) → ((Bewildered(lamont) ∧ Combative(lancelot))) ::: Olive being fearless implies that Lamont is bewildered and Lancelot is combative.\n(∀x (¬Bewildered(x))) → (∀x (Poor(x) ∧ ¬Stubborn(x))) ::: If someone is not bewildered, then he is both poor and not stubborn.\n(∀x (Stubborn(x))) → (∀x (¬Bewildered(x))) ::: If someone is stubborn, then he is not bewildered.\n((Poor(jack) ∧ ¬Fearless(lamont))) → ((Stubborn(blaine))) ::: It can be concluded that Blaine is stubborn once knowing that Jack is poor and Lamont is not fearless.\n(∃x (¬Fearless(x))) → ((¬Bewildered(iver))) ::: If there is someone who is not fearless, then Iver is not bewildered.\n(∃x (¬Fearless(x) ∨ ¬Stubborn(x))) → ((¬Wonderful(jack))) ::: If there is someone who is either not fearless or not stubborn, then Jack is not wonderful.\n(∀x (Bewildered(olive))) ↔ (∀x (Stubborn(blaine))) ::: Olive being bewildered is equivalent to Blaine being stubborn.\n",
                "First-Order-Logic Question": "Combative(olive) ::: Olive is combative."
            },
            "diff": [
                {
                    "raw": "(∀x (x ∨ ¬Wonderful(x) ∧ Combative(x))) → (∀x (¬Poor(x))) ::: If someone is he or not wonderful is combative, then he is not poor.",
                    "gram": "∀x((Wonderful(x)∨¬Poor(x))) ::: If someone is he or not wonderful is combative, then he is not poor."
                }
            ],
            "answer": "C",
            "grammar_answer": "A",
            "backup_answer": "C"
        },
        {
            "id": 555,
            "raw_prog": {
                "First-Order-Logic Rules": "Aggressive(montague) ::: Montague is aggressive.\nImpossible(ansel) ::: Ansel is impossible.\n¬Wicked(cyril) ::: Cyril is not wicked.\n¬Wicked(ansel) ::: Ansel is not wicked.\nDrab(katelynn) ::: Katelynn is drab.\n¬Drab(montague) ::: Montague is not drab.\n¬Mushy(ansel) ::: Ansel is not mushy.\n¬Wicked(joseph) ::: Joseph is not wicked.\nBroadMinded(joseph) ::: Joseph is broad-minded.\nDrab(olive) ::: Olive is drab.\n¬Drab(ansel) ::: Ansel is not drab.\n¬Wicked(montague) ::: Montague is not wicked.\n((Mushy(montague) ∧ ¬Wicked(katelynn))) → (¬Aggressive(ansel)) ::: Montague being mushy and Katelynn being not wicked imply that Ansel is not aggressive.\n(BroadMinded(joseph)) ↔ (¬Impossible(joseph)) ::: Joseph is broad-minded if and only if Joseph is not impossible.\n(∃x (¬Mushy(x))) → ((¬Aggressive(whitney) ∧ Impossible(cyril))) ::: If there is at least one people who is not mushy, then Whitney is not aggressive and Cyril is impossible.\n(∃x (BroadMinded(x) ∨ Impossible(x))) → ((Aggressive(olive))) ::: If there is someone who is either broad-minded or impossible, then Olive is aggressive.\n(¬∃x (¬x)) → ((¬BroadMinded(cyril) ∧ Aggressive(ansel))) ::: If there is nobody who is not, then Cyril is not broad-minded and Ansel is aggressive.\n((Wicked(olive) ∧ Drab(katelynn))) ↔ ((Aggressive(joseph) ∧ ¬BroadMinded(montague))) ::: Olive is wicked and Katelynn is drab if and only if Joseph is aggressive and Montague is not broad-minded.\n(∃x (Mushy(x))) → ((BroadMinded(katelynn) ∧ ¬Aggressive(joseph))) ::: If there is at least one people who is mushy, then Katelynn is broad-minded and Joseph is not aggressive.\n((Wicked(olive) ∨ BroadMinded(cyril))) → ((Aggressive(katelynn))) ::: Olive being wicked or Cyril being broad-minded implies that Katelynn is aggressive.\n(∃x (Wicked(x) ∧ ¬Mushy(x))) → ((¬Drab(montague))) ::: If there is someone who is both wicked and not mushy, then Montague is not drab.\n(¬Impossible(whitney)) → ((¬Mushy(cyril) ∧ BroadMinded(joseph))) ::: Whitney being not impossible implies that Cyril is not mushy and Joseph is broad-minded.\n(∀x (¬Aggressive(x))) ↔ (∀x (¬Impossible(x))) ::: Someone is not aggressive if and only if he is not impossible.\n(∀x (Aggressive(x) ∧ ¬Drab(x))) ↔ (∀x (¬Impossible(x))) ::: Someone is aggressive and not drab if and only if he is not impossible.\n",
                "First-Order-Logic Question": "¬Mushy(joseph) ::: Joseph is not mushy."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "Aggressive(montague) ::: Montague is aggressive.\nImpossible(ansel) ::: Ansel is impossible.\n¬Wicked(cyril) ::: Cyril is not wicked.\n¬Wicked(ansel) ::: Ansel is not wicked.\nDrab(katelynn) ::: Katelynn is drab.\n¬Drab(montague) ::: Montague is not drab.\n¬Mushy(ansel) ::: Ansel is not mushy.\n¬Wicked(joseph) ::: Joseph is not wicked.\nBroadMinded(joseph) ::: Joseph is broad-minded.\nDrab(olive) ::: Olive is drab.\n¬Drab(ansel) ::: Ansel is not drab.\n¬Wicked(montague) ::: Montague is not wicked.\n((Mushy(montague) ∧ ¬Wicked(katelynn))) → (¬Aggressive(ansel)) ::: Montague being mushy and Katelynn being not wicked imply that Ansel is not aggressive.\n(BroadMinded(joseph)) ↔ (¬Impossible(joseph)) ::: Joseph is broad-minded if and only if Joseph is not impossible.\n(∃x (¬Mushy(x))) → ((¬Aggressive(whitney) ∧ Impossible(cyril))) ::: If there is at least one people who is not mushy, then Whitney is not aggressive and Cyril is impossible.\n(∃x (BroadMinded(x) ∨ Impossible(x))) → ((Aggressive(olive))) ::: If there is someone who is either broad-minded or impossible, then Olive is aggressive.\n¬∃x((¬BroadMinded(x)∧Aggressive(x))) ::: If there is nobody who is not, then Cyril is not broad-minded and Ansel is aggressive.\n((Wicked(olive) ∧ Drab(katelynn))) ↔ ((Aggressive(joseph) ∧ ¬BroadMinded(montague))) ::: Olive is wicked and Katelynn is drab if and only if Joseph is aggressive and Montague is not broad-minded.\n(∃x (Mushy(x))) → ((BroadMinded(katelynn) ∧ ¬Aggressive(joseph))) ::: If there is at least one people who is mushy, then Katelynn is broad-minded and Joseph is not aggressive.\n((Wicked(olive) ∨ BroadMinded(cyril))) → ((Aggressive(katelynn))) ::: Olive being wicked or Cyril being broad-minded implies that Katelynn is aggressive.\n(∃x (Wicked(x) ∧ ¬Mushy(x))) → ((¬Drab(montague))) ::: If there is someone who is both wicked and not mushy, then Montague is not drab.\n(¬Impossible(whitney)) → ((¬Mushy(cyril) ∧ BroadMinded(joseph))) ::: Whitney being not impossible implies that Cyril is not mushy and Joseph is broad-minded.\n(∀x (¬Aggressive(x))) ↔ (∀x (¬Impossible(x))) ::: Someone is not aggressive if and only if he is not impossible.\n(∀x (Aggressive(x) ∧ ¬Drab(x))) ↔ (∀x (¬Impossible(x))) ::: Someone is aggressive and not drab if and only if he is not impossible.\n",
                "First-Order-Logic Question": "¬Mushy(joseph) ::: Joseph is not mushy."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬x)) → ((¬BroadMinded(cyril) ∧ Aggressive(ansel))) ::: If there is nobody who is not, then Cyril is not broad-minded and Ansel is aggressive.",
                    "gram": "¬∃x((¬BroadMinded(x)∧Aggressive(x))) ::: If there is nobody who is not, then Cyril is not broad-minded and Ansel is aggressive."
                }
            ],
            "answer": "C",
            "grammar_answer": "C",
            "backup_answer": "C"
        },
        {
            "id": 556,
            "raw_prog": {
                "First-Order-Logic Rules": "Aggressive(montague) ::: Montague is aggressive.\nImpossible(ansel) ::: Ansel is impossible.\n¬Wicked(cyril) ::: Cyril is not wicked.\n¬Wicked(ansel) ::: Ansel is not wicked.\nDrab(katelynn) ::: Katelynn is drab.\n¬Drab(montague) ::: Montague is not drab.\n¬Mushy(ansel) ::: Ansel is not mushy.\n¬Wicked(joseph) ::: Joseph is not wicked.\nBroadMinded(joseph) ::: Joseph is broad-minded.\nDrab(olive) ::: Olive is drab.\n¬Drab(ansel) ::: Ansel is not drab.\n¬Wicked(montague) ::: Montague is not wicked.\n((Mushy(montague) ∧ ¬Wicked(katelynn))) → (¬Aggressive(ansel)) ::: Montague being mushy and Katelynn being not wicked imply that Ansel is not aggressive.\n(BroadMinded(joseph)) ↔ (¬Impossible(joseph)) ::: Joseph is broad-minded if and only if Joseph is not impossible.\n(∃x (¬Mushy(x))) → ((¬Aggressive(whitney) ∧ Impossible(cyril))) ::: If there is at least one people who is not mushy, then Whitney is not aggressive and Cyril is impossible.\n(∃x (BroadMinded(x) ∨ Impossible(x))) → ((Aggressive(olive))) ::: If there is someone who is either broad-minded or impossible, then Olive is aggressive.\n(¬∃x (¬x)) → ((¬BroadMinded(cyril) ∧ Aggressive(ansel))) ::: If there is nobody who is not, then Cyril is not broad-minded and Ansel is aggressive.\n((Wicked(olive) ∧ Drab(katelynn))) ↔ ((Aggressive(joseph) ∧ ¬BroadMinded(montague))) ::: Olive is wicked and Katelynn is drab if and only if Joseph is aggressive and Montague is not broad-minded.\n(∃x (Mushy(x))) → ((BroadMinded(katelynn) ∧ ¬Aggressive(joseph))) ::: If there is at least one people who is mushy, then Katelynn is broad-minded and Joseph is not aggressive.\n((Wicked(olive) ∨ BroadMinded(cyril))) → ((Aggressive(katelynn))) ::: Olive being wicked or Cyril being broad-minded implies that Katelynn is aggressive.\n(∃x (Wicked(x) ∧ ¬Mushy(x))) → ((¬Drab(montague))) ::: If there is someone who is both wicked and not mushy, then Montague is not drab.\n(¬Impossible(whitney)) → ((¬Mushy(cyril) ∧ BroadMinded(joseph))) ::: Whitney being not impossible implies that Cyril is not mushy and Joseph is broad-minded.\n(∀x (¬Aggressive(x))) ↔ (∀x (¬Impossible(x))) ::: Someone is not aggressive if and only if he is not impossible.\n(∀x (Aggressive(x) ∧ ¬Drab(x))) ↔ (∀x (¬Impossible(x))) ::: Someone is aggressive and not drab if and only if he is not impossible.\n",
                "First-Order-Logic Question": "Impossible(olive) ::: Olive is impossible."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "Aggressive(montague) ::: Montague is aggressive.\nImpossible(ansel) ::: Ansel is impossible.\n¬Wicked(cyril) ::: Cyril is not wicked.\n¬Wicked(ansel) ::: Ansel is not wicked.\nDrab(katelynn) ::: Katelynn is drab.\n¬Drab(montague) ::: Montague is not drab.\n¬Mushy(ansel) ::: Ansel is not mushy.\n¬Wicked(joseph) ::: Joseph is not wicked.\nBroadMinded(joseph) ::: Joseph is broad-minded.\nDrab(olive) ::: Olive is drab.\n¬Drab(ansel) ::: Ansel is not drab.\n¬Wicked(montague) ::: Montague is not wicked.\n((Mushy(montague) ∧ ¬Wicked(katelynn))) → (¬Aggressive(ansel)) ::: Montague being mushy and Katelynn being not wicked imply that Ansel is not aggressive.\n(BroadMinded(joseph)) ↔ (¬Impossible(joseph)) ::: Joseph is broad-minded if and only if Joseph is not impossible.\n(∃x (¬Mushy(x))) → ((¬Aggressive(whitney) ∧ Impossible(cyril))) ::: If there is at least one people who is not mushy, then Whitney is not aggressive and Cyril is impossible.\n(∃x (BroadMinded(x) ∨ Impossible(x))) → ((Aggressive(olive))) ::: If there is someone who is either broad-minded or impossible, then Olive is aggressive.\n¬∃x(¬(¬(BroadMinded(x)))) ::: If there is nobody who is not, then Cyril is not broad-minded and Ansel is aggressive.\n((Wicked(olive) ∧ Drab(katelynn))) ↔ ((Aggressive(joseph) ∧ ¬BroadMinded(montague))) ::: Olive is wicked and Katelynn is drab if and only if Joseph is aggressive and Montague is not broad-minded.\n(∃x (Mushy(x))) → ((BroadMinded(katelynn) ∧ ¬Aggressive(joseph))) ::: If there is at least one people who is mushy, then Katelynn is broad-minded and Joseph is not aggressive.\n((Wicked(olive) ∨ BroadMinded(cyril))) → ((Aggressive(katelynn))) ::: Olive being wicked or Cyril being broad-minded implies that Katelynn is aggressive.\n(∃x (Wicked(x) ∧ ¬Mushy(x))) → ((¬Drab(montague))) ::: If there is someone who is both wicked and not mushy, then Montague is not drab.\n(¬Impossible(whitney)) → ((¬Mushy(cyril) ∧ BroadMinded(joseph))) ::: Whitney being not impossible implies that Cyril is not mushy and Joseph is broad-minded.\n(∀x (¬Aggressive(x))) ↔ (∀x (¬Impossible(x))) ::: Someone is not aggressive if and only if he is not impossible.\n(∀x (Aggressive(x) ∧ ¬Drab(x))) ↔ (∀x (¬Impossible(x))) ::: Someone is aggressive and not drab if and only if he is not impossible.\n",
                "First-Order-Logic Question": "Impossible(olive) ::: Olive is impossible."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬x)) → ((¬BroadMinded(cyril) ∧ Aggressive(ansel))) ::: If there is nobody who is not, then Cyril is not broad-minded and Ansel is aggressive.",
                    "gram": "¬∃x(¬(¬(BroadMinded(x)))) ::: If there is nobody who is not, then Cyril is not broad-minded and Ansel is aggressive."
                }
            ],
            "answer": "C",
            "grammar_answer": "A",
            "backup_answer": "C"
        },
        {
            "id": 557,
            "raw_prog": {
                "First-Order-Logic Rules": "Aggressive(montague) ::: Montague is aggressive.\nImpossible(ansel) ::: Ansel is impossible.\n¬Wicked(cyril) ::: Cyril is not wicked.\n¬Wicked(ansel) ::: Ansel is not wicked.\nDrab(katelynn) ::: Katelynn is drab.\n¬Drab(montague) ::: Montague is not drab.\n¬Mushy(ansel) ::: Ansel is not mushy.\n¬Wicked(joseph) ::: Joseph is not wicked.\nBroadMinded(joseph) ::: Joseph is broad-minded.\n¬Drab(ansel) ::: Ansel is not drab.\n¬Wicked(montague) ::: Montague is not wicked.\n((Mushy(montague) ∧ ¬Wicked(katelynn))) → (¬Aggressive(ansel)) ::: Montague being mushy and Katelynn being not wicked imply that Ansel is not aggressive.\n(BroadMinded(joseph)) ↔ (¬Impossible(joseph)) ::: Joseph is broad-minded if and only if Joseph is not impossible.\n(∃x (¬Mushy(x))) → ((¬Aggressive(whitney) ∧ Impossible(cyril))) ::: If there is at least one people who is not mushy, then Whitney is not aggressive and Cyril is impossible.\n(∃x (BroadMinded(x) ∨ Impossible(x))) → ((Aggressive(olive))) ::: If there is someone who is either broad-minded or impossible, then Olive is aggressive.\n(¬∃x (¬x)) → ((¬BroadMinded(cyril) ∧ Aggressive(ansel))) ::: If there is nobody who is not, then Cyril is not broad-minded and Ansel is aggressive.\n((Wicked(olive) ∧ Drab(katelynn))) ↔ ((Aggressive(joseph) ∧ ¬BroadMinded(montague))) ::: Olive is wicked and Katelynn is drab if and only if Joseph is aggressive and Montague is not broad-minded.\n(∃x (Mushy(x))) → ((BroadMinded(katelynn) ∧ ¬Aggressive(joseph))) ::: If there is at least one people who is mushy, then Katelynn is broad-minded and Joseph is not aggressive.\n((Wicked(olive) ∨ BroadMinded(cyril))) → ((Aggressive(katelynn))) ::: Olive being wicked or Cyril being broad-minded implies that Katelynn is aggressive.\n(∃x (Wicked(x) ∧ ¬Mushy(x))) → ((¬Drab(montague))) ::: If there is someone who is both wicked and not mushy, then Montague is not drab.\n(¬Impossible(whitney)) → ((¬Mushy(cyril) ∧ BroadMinded(joseph))) ::: Whitney being not impossible implies that Cyril is not mushy and Joseph is broad-minded.\n(∀x (¬Aggressive(x))) ↔ (∀x (¬Impossible(x))) ::: Someone is not aggressive if and only if he is not impossible.\n(∀x (Aggressive(x) ∧ ¬Drab(x))) ↔ (∀x (¬Impossible(x))) ::: Someone is aggressive and not drab if and only if he is not impossible.\n",
                "First-Order-Logic Question": "BroadMinded(whitney) ::: Whitney is broad-minded."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "Aggressive(montague) ::: Montague is aggressive.\nImpossible(ansel) ::: Ansel is impossible.\n¬Wicked(cyril) ::: Cyril is not wicked.\n¬Wicked(ansel) ::: Ansel is not wicked.\nDrab(katelynn) ::: Katelynn is drab.\n¬Drab(montague) ::: Montague is not drab.\n¬Mushy(ansel) ::: Ansel is not mushy.\n¬Wicked(joseph) ::: Joseph is not wicked.\nBroadMinded(joseph) ::: Joseph is broad-minded.\n¬Drab(ansel) ::: Ansel is not drab.\n¬Wicked(montague) ::: Montague is not wicked.\n((Mushy(montague) ∧ ¬Wicked(katelynn))) → (¬Aggressive(ansel)) ::: Montague being mushy and Katelynn being not wicked imply that Ansel is not aggressive.\n(BroadMinded(joseph)) ↔ (¬Impossible(joseph)) ::: Joseph is broad-minded if and only if Joseph is not impossible.\n(∃x (¬Mushy(x))) → ((¬Aggressive(whitney) ∧ Impossible(cyril))) ::: If there is at least one people who is not mushy, then Whitney is not aggressive and Cyril is impossible.\n(∃x (BroadMinded(x) ∨ Impossible(x))) → ((Aggressive(olive))) ::: If there is someone who is either broad-minded or impossible, then Olive is aggressive.\n¬∃x(¬(¬(BroadMinded(x)))) ::: If there is nobody who is not, then Cyril is not broad-minded and Ansel is aggressive.\n((Wicked(olive) ∧ Drab(katelynn))) ↔ ((Aggressive(joseph) ∧ ¬BroadMinded(montague))) ::: Olive is wicked and Katelynn is drab if and only if Joseph is aggressive and Montague is not broad-minded.\n(∃x (Mushy(x))) → ((BroadMinded(katelynn) ∧ ¬Aggressive(joseph))) ::: If there is at least one people who is mushy, then Katelynn is broad-minded and Joseph is not aggressive.\n((Wicked(olive) ∨ BroadMinded(cyril))) → ((Aggressive(katelynn))) ::: Olive being wicked or Cyril being broad-minded implies that Katelynn is aggressive.\n(∃x (Wicked(x) ∧ ¬Mushy(x))) → ((¬Drab(montague))) ::: If there is someone who is both wicked and not mushy, then Montague is not drab.\n(¬Impossible(whitney)) → ((¬Mushy(cyril) ∧ BroadMinded(joseph))) ::: Whitney being not impossible implies that Cyril is not mushy and Joseph is broad-minded.\n(∀x (¬Aggressive(x))) ↔ (∀x (¬Impossible(x))) ::: Someone is not aggressive if and only if he is not impossible.\n(∀x (Aggressive(x) ∧ ¬Drab(x))) ↔ (∀x (¬Impossible(x))) ::: Someone is aggressive and not drab if and only if he is not impossible.\n",
                "First-Order-Logic Question": "BroadMinded(whitney) ::: Whitney is broad-minded."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬x)) → ((¬BroadMinded(cyril) ∧ Aggressive(ansel))) ::: If there is nobody who is not, then Cyril is not broad-minded and Ansel is aggressive.",
                    "gram": "¬∃x(¬(¬(BroadMinded(x)))) ::: If there is nobody who is not, then Cyril is not broad-minded and Ansel is aggressive."
                }
            ],
            "answer": "C",
            "grammar_answer": "A",
            "backup_answer": "C"
        },
        {
            "id": 558,
            "raw_prog": {
                "First-Order-Logic Rules": "Aggressive(montague) ::: Montague is aggressive.\nImpossible(ansel) ::: Ansel is impossible.\n¬Wicked(cyril) ::: Cyril is not wicked.\n¬Wicked(ansel) ::: Ansel is not wicked.\nDrab(katelynn) ::: Katelynn is drab.\n¬Drab(montague) ::: Montague is not drab.\n¬Mushy(ansel) ::: Ansel is not mushy.\n¬Wicked(joseph) ::: Joseph is not wicked.\nBroadMinded(joseph) ::: Joseph is broad-minded.\nDrab(olive) ::: Olive is drab.\n¬Drab(ansel) ::: Ansel is not drab.\n¬Wicked(montague) ::: Montague is not wicked.\n((Mushy(montague) ∧ ¬Wicked(katelynn))) → (¬Aggressive(ansel)) ::: Montague being mushy and Katelynn being not wicked imply that Ansel is not aggressive.\n(BroadMinded(joseph)) ↔ (¬Impossible(joseph)) ::: Joseph is broad-minded if and only if Joseph is not impossible.\n(∃x (¬Mushy(x))) → ((¬Aggressive(whitney) ∧ Impossible(cyril))) ::: If there is at least one people who is not mushy, then Whitney is not aggressive and Cyril is impossible.\n(∃x (BroadMinded(x) ∨ Impossible(x))) → (Aggressive(olive)) ::: If there is someone who is either broad-minded or impossible, then Olive is aggressive.\n(∀x (¬x)) → ((¬BroadMinded(cyril) ∧ Aggressive(ansel))) ::: If there is nobody who is not, then Cyril is not broad-minded and Ansel is aggressive.\n((Wicked(olive) ∧ Drab(katelynn))) ↔ ((Aggressive(joseph) ∧ ¬BroadMinded(montague))) ::: Olive is wicked and Katelynn is drab if and only if Joseph is aggressive and Montague is not broad-minded.\n(∃x (Mushy(x))) → ((BroadMinded(katelynn) ∧ ¬Aggressive(joseph))) ::: If there is at least one people who is mushy, then Katelynn is broad-minded and Joseph is not aggressive.\n((Wicked(olive) ∨ BroadMinded(cyril))) → (Aggressive(katelynn)) ::: Olive being wicked or Cyril being broad-minded implies that Katelynn is aggressive.\n(∃x (Wicked(x) ∧ ¬Mushy(x))) → (¬Drab(montague)) ::: If there is someone who is both wicked and not mushy, then Montague is not drab.\n(¬Impossible(whitney)) → ((¬Mushy(cyril) ∧ BroadMinded(joseph))) ::: Whitney being not impossible implies that Cyril is not mushy and Joseph is broad-minded.\n(∀x (¬Aggressive(x))) ↔ (∀x (¬Impossible(x))) ::: Someone is not aggressive if and only if he is not impossible.\n(∀x (Aggressive(x) ∧ ¬Drab(x))) ↔ (∀x (¬Impossible(x))) ::: Someone is aggressive and not drab if and only if he is not impossible.\n",
                "First-Order-Logic Question": "Mushy(ansel) ::: Ansel is mushy."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "Aggressive(montague) ::: Montague is aggressive.\nImpossible(ansel) ::: Ansel is impossible.\n¬Wicked(cyril) ::: Cyril is not wicked.\n¬Wicked(ansel) ::: Ansel is not wicked.\nDrab(katelynn) ::: Katelynn is drab.\n¬Drab(montague) ::: Montague is not drab.\n¬Mushy(ansel) ::: Ansel is not mushy.\n¬Wicked(joseph) ::: Joseph is not wicked.\nBroadMinded(joseph) ::: Joseph is broad-minded.\nDrab(olive) ::: Olive is drab.\n¬Drab(ansel) ::: Ansel is not drab.\n¬Wicked(montague) ::: Montague is not wicked.\n((Mushy(montague) ∧ ¬Wicked(katelynn))) → (¬Aggressive(ansel)) ::: Montague being mushy and Katelynn being not wicked imply that Ansel is not aggressive.\n(BroadMinded(joseph)) ↔ (¬Impossible(joseph)) ::: Joseph is broad-minded if and only if Joseph is not impossible.\n(∃x (¬Mushy(x))) → ((¬Aggressive(whitney) ∧ Impossible(cyril))) ::: If there is at least one people who is not mushy, then Whitney is not aggressive and Cyril is impossible.\n(∃x (BroadMinded(x) ∨ Impossible(x))) → (Aggressive(olive)) ::: If there is someone who is either broad-minded or impossible, then Olive is aggressive.\n¬(¬BroadMinded(x))→((¬Aggressive(x))) ::: If there is nobody who is not, then Cyril is not broad-minded and Ansel is aggressive.\n((Wicked(olive) ∧ Drab(katelynn))) ↔ ((Aggressive(joseph) ∧ ¬BroadMinded(montague))) ::: Olive is wicked and Katelynn is drab if and only if Joseph is aggressive and Montague is not broad-minded.\n(∃x (Mushy(x))) → ((BroadMinded(katelynn) ∧ ¬Aggressive(joseph))) ::: If there is at least one people who is mushy, then Katelynn is broad-minded and Joseph is not aggressive.\n((Wicked(olive) ∨ BroadMinded(cyril))) → (Aggressive(katelynn)) ::: Olive being wicked or Cyril being broad-minded implies that Katelynn is aggressive.\n(∃x (Wicked(x) ∧ ¬Mushy(x))) → (¬Drab(montague)) ::: If there is someone who is both wicked and not mushy, then Montague is not drab.\n(¬Impossible(whitney)) → ((¬Mushy(cyril) ∧ BroadMinded(joseph))) ::: Whitney being not impossible implies that Cyril is not mushy and Joseph is broad-minded.\n(∀x (¬Aggressive(x))) ↔ (∀x (¬Impossible(x))) ::: Someone is not aggressive if and only if he is not impossible.\n(∀x (Aggressive(x) ∧ ¬Drab(x))) ↔ (∀x (¬Impossible(x))) ::: Someone is aggressive and not drab if and only if he is not impossible.\n",
                "First-Order-Logic Question": "Mushy(ansel) ::: Ansel is mushy."
            },
            "diff": [
                {
                    "raw": "(∀x (¬x)) → ((¬BroadMinded(cyril) ∧ Aggressive(ansel))) ::: If there is nobody who is not, then Cyril is not broad-minded and Ansel is aggressive.",
                    "gram": "¬(¬BroadMinded(x))→((¬Aggressive(x))) ::: If there is nobody who is not, then Cyril is not broad-minded and Ansel is aggressive."
                }
            ],
            "answer": "B",
            "grammar_answer": "B",
            "backup_answer": "B"
        },
        {
            "id": 559,
            "raw_prog": {
                "First-Order-Logic Rules": "Aggressive(montague) ::: Montague is aggressive.\nImpossible(ansel) ::: Ansel is impossible.\n¬Wicked(cyril) ::: Cyril is not wicked.\n¬Wicked(ansel) ::: Ansel is not wicked.\nDrab(katelynn) ::: Katelynn is drab.\n¬Drab(montague) ::: Montague is not drab.\n¬Mushy(ansel) ::: Ansel is not mushy.\n¬Wicked(joseph) ::: Joseph is not wicked.\nBroadMinded(joseph) ::: Joseph is broad-minded.\nDrab(olive) ::: Olive is drab.\n¬Drab(ansel) ::: Ansel is not drab.\n¬Wicked(montague) ::: Montague is not wicked.\n((Mushy(montague) ∧ ¬Wicked(katelynn))) → (¬Aggressive(ansel)) ::: Montague being mushy and Katelynn being not wicked imply that Ansel is not aggressive.\n(BroadMinded(joseph)) ↔ (¬Impossible(joseph)) ::: Joseph is broad-minded if and only if Joseph is not impossible.\n(∃x (¬Mushy(x))) → ((¬Aggressive(whitney) ∧ Impossible(cyril))) ::: If there is at least one people who is not mushy, then Whitney is not aggressive and Cyril is impossible.\n(∃x (BroadMinded(x) ∨ Impossible(x))) → ((Aggressive(olive))) ::: If there is someone who is either broad-minded or impossible, then Olive is aggressive.\n(¬∃x (¬x)) → ((¬BroadMinded(cyril) ∧ Aggressive(ansel))) ::: If there is nobody who is not, then Cyril is not broad-minded and Ansel is aggressive.\n((Wicked(olive) ∧ Drab(katelynn))) ↔ ((Aggressive(joseph) ∧ ¬BroadMinded(montague))) ::: Olive is wicked and Katelynn is drab if and only if Joseph is aggressive and Montague is not broad-minded.\n(∃x (Mushy(x))) → ((BroadMinded(katelynn) ∧ ¬Aggressive(joseph))) ::: If there is at least one people who is mushy, then Katelynn is broad-minded and Joseph is not aggressive.\n((Wicked(olive) ∨ BroadMinded(cyril))) → ((Aggressive(katelynn))) ::: Olive being wicked or Cyril being broad-minded implies that Katelynn is aggressive.\n(∃x (Wicked(x) ∧ ¬Mushy(x))) → ((¬Drab(montague))) ::: If there is someone who is both wicked and not mushy, then Montague is not drab.\n(¬Impossible(whitney)) → ((¬Mushy(cyril) ∧ BroadMinded(joseph))) ::: Whitney being not impossible implies that Cyril is not mushy and Joseph is broad-minded.\n(∀x (¬Aggressive(x))) ↔ (∀x (¬Impossible(x))) ::: Someone is not aggressive if and only if he is not impossible.\n(∀x (Aggressive(x) ∧ ¬Drab(x))) ↔ (∀x (¬Impossible(x))) ::: Someone is aggressive and not drab if and only if he is not impossible.\n",
                "First-Order-Logic Question": "¬Drab(ansel) ::: Ansel is not drab."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "Aggressive(montague) ::: Montague is aggressive.\nImpossible(ansel) ::: Ansel is impossible.\n¬Wicked(cyril) ::: Cyril is not wicked.\n¬Wicked(ansel) ::: Ansel is not wicked.\nDrab(katelynn) ::: Katelynn is drab.\n¬Drab(montague) ::: Montague is not drab.\n¬Mushy(ansel) ::: Ansel is not mushy.\n¬Wicked(joseph) ::: Joseph is not wicked.\nBroadMinded(joseph) ::: Joseph is broad-minded.\nDrab(olive) ::: Olive is drab.\n¬Drab(ansel) ::: Ansel is not drab.\n¬Wicked(montague) ::: Montague is not wicked.\n((Mushy(montague) ∧ ¬Wicked(katelynn))) → (¬Aggressive(ansel)) ::: Montague being mushy and Katelynn being not wicked imply that Ansel is not aggressive.\n(BroadMinded(joseph)) ↔ (¬Impossible(joseph)) ::: Joseph is broad-minded if and only if Joseph is not impossible.\n(∃x (¬Mushy(x))) → ((¬Aggressive(whitney) ∧ Impossible(cyril))) ::: If there is at least one people who is not mushy, then Whitney is not aggressive and Cyril is impossible.\n(∃x (BroadMinded(x) ∨ Impossible(x))) → ((Aggressive(olive))) ::: If there is someone who is either broad-minded or impossible, then Olive is aggressive.\n¬∃x((¬BroadMinded(x)∧Aggressive(x))) ::: If there is nobody who is not, then Cyril is not broad-minded and Ansel is aggressive.\n((Wicked(olive) ∧ Drab(katelynn))) ↔ ((Aggressive(joseph) ∧ ¬BroadMinded(montague))) ::: Olive is wicked and Katelynn is drab if and only if Joseph is aggressive and Montague is not broad-minded.\n(∃x (Mushy(x))) → ((BroadMinded(katelynn) ∧ ¬Aggressive(joseph))) ::: If there is at least one people who is mushy, then Katelynn is broad-minded and Joseph is not aggressive.\n((Wicked(olive) ∨ BroadMinded(cyril))) → ((Aggressive(katelynn))) ::: Olive being wicked or Cyril being broad-minded implies that Katelynn is aggressive.\n(∃x (Wicked(x) ∧ ¬Mushy(x))) → ((¬Drab(montague))) ::: If there is someone who is both wicked and not mushy, then Montague is not drab.\n(¬Impossible(whitney)) → ((¬Mushy(cyril) ∧ BroadMinded(joseph))) ::: Whitney being not impossible implies that Cyril is not mushy and Joseph is broad-minded.\n(∀x (¬Aggressive(x))) ↔ (∀x (¬Impossible(x))) ::: Someone is not aggressive if and only if he is not impossible.\n(∀x (Aggressive(x) ∧ ¬Drab(x))) ↔ (∀x (¬Impossible(x))) ::: Someone is aggressive and not drab if and only if he is not impossible.\n",
                "First-Order-Logic Question": "¬Drab(ansel) ::: Ansel is not drab."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬x)) → ((¬BroadMinded(cyril) ∧ Aggressive(ansel))) ::: If there is nobody who is not, then Cyril is not broad-minded and Ansel is aggressive.",
                    "gram": "¬∃x((¬BroadMinded(x)∧Aggressive(x))) ::: If there is nobody who is not, then Cyril is not broad-minded and Ansel is aggressive."
                }
            ],
            "answer": "A",
            "grammar_answer": "A",
            "backup_answer": "A"
        },
        {
            "id": 560,
            "raw_prog": {
                "First-Order-Logic Rules": "Aggressive(montague) ::: Montague is aggressive.\nImpossible(ansel) ::: Ansel is impossible.\n¬Wicked(cyril) ::: Cyril is not wicked.\n¬Wicked(ansel) ::: Ansel is not wicked.\nDrab(katelynn) ::: Katelynn is drab.\n¬Drab(montague) ::: Montague is not drab.\n¬Mushy(ansel) ::: Ansel is not mushy.\n¬Wicked(joseph) ::: Joseph is not wicked.\nDrab(olive) ::: Olive is drab.\nBroadMinded(joseph) ::: Joseph is broad-minded.\n¬Drab(ansel) ::: Ansel is not drab.\n¬Wicked(montague) ::: Montague is not wicked.\n((Mushy(montague) ∧ ¬Wicked(katelynn))) → (¬Aggressive(ansel)) ::: Montague being mushy and Katelynn being not wicked imply that Ansel is not aggressive.\n(BroadMinded(joseph)) ↔ (¬Impossible(joseph)) ::: Joseph is broad-minded if and only if Joseph is not impossible.\n(∃x (¬Mushy(x))) → ((¬Aggressive(whitney) ∧ Impossible(cyril))) ::: If there is at least one people who is not mushy, then Whitney is not aggressive and Cyril is impossible.\n(∃x (BroadMinded(x) ∨ Impossible(x))) → ((Aggressive(olive))) ::: If there is someone who is either broad-minded or impossible, then Olive is aggressive.\n(¬∃x (¬x)) → ((¬BroadMinded(cyril) ∧ Aggressive(ansel))) ::: If there is nobody who is not, then Cyril is not broad-minded and Ansel is aggressive.\n((Wicked(olive) ∧ Drab(katelynn))) ↔ ((Aggressive(joseph) ∧ ¬BroadMinded(montague))) ::: Olive is wicked and Katelynn is drab if and only if Joseph is aggressive and Montague is not broad-minded.\n(∃x (Mushy(x))) → ((BroadMinded(katelynn) ∧ ¬Aggressive(joseph))) ::: If there is at least one people who is mushy, then Katelynn is broad-minded and Joseph is not aggressive.\n((Wicked(olive) ∨ BroadMinded(cyril))) → ((Aggressive(katelynn))) ::: Olive being wicked or Cyril being broad-minded implies that Katelynn is aggressive.\n(∃x (Wicked(x) ∧ ¬Mushy(x))) → ((¬Drab(montague))) ::: If there is someone who is both wicked and not mushy, then Montague is not drab.\n((¬Impossible(whitney))) → ((¬Mushy(cyril) ∧ BroadMinded(joseph))) ::: Whitney being not impossible implies that Cyril is not mushy and Joseph is broad-minded.\n(∀x (¬Aggressive(x))) ↔ (∀x (¬Impossible(x))) ::: Someone is not aggressive if and only if he is not impossible.\n(∀x (Aggressive(x) ∧ ¬Drab(x))) ↔ (∀x (¬Impossible(x))) ::: Someone is aggressive and not drab if and only if he is not impossible.\n",
                "First-Order-Logic Question": "Impossible(katelynn) ::: Katelynn is impossible."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "Aggressive(montague) ::: Montague is aggressive.\nImpossible(ansel) ::: Ansel is impossible.\n¬Wicked(cyril) ::: Cyril is not wicked.\n¬Wicked(ansel) ::: Ansel is not wicked.\nDrab(katelynn) ::: Katelynn is drab.\n¬Drab(montague) ::: Montague is not drab.\n¬Mushy(ansel) ::: Ansel is not mushy.\n¬Wicked(joseph) ::: Joseph is not wicked.\nDrab(olive) ::: Olive is drab.\nBroadMinded(joseph) ::: Joseph is broad-minded.\n¬Drab(ansel) ::: Ansel is not drab.\n¬Wicked(montague) ::: Montague is not wicked.\n((Mushy(montague) ∧ ¬Wicked(katelynn))) → (¬Aggressive(ansel)) ::: Montague being mushy and Katelynn being not wicked imply that Ansel is not aggressive.\n(BroadMinded(joseph)) ↔ (¬Impossible(joseph)) ::: Joseph is broad-minded if and only if Joseph is not impossible.\n(∃x (¬Mushy(x))) → ((¬Aggressive(whitney) ∧ Impossible(cyril))) ::: If there is at least one people who is not mushy, then Whitney is not aggressive and Cyril is impossible.\n(∃x (BroadMinded(x) ∨ Impossible(x))) → ((Aggressive(olive))) ::: If there is someone who is either broad-minded or impossible, then Olive is aggressive.\n¬∃x((¬BroadMinded(x)∧Aggressive(x))) ::: If there is nobody who is not, then Cyril is not broad-minded and Ansel is aggressive.\n((Wicked(olive) ∧ Drab(katelynn))) ↔ ((Aggressive(joseph) ∧ ¬BroadMinded(montague))) ::: Olive is wicked and Katelynn is drab if and only if Joseph is aggressive and Montague is not broad-minded.\n(∃x (Mushy(x))) → ((BroadMinded(katelynn) ∧ ¬Aggressive(joseph))) ::: If there is at least one people who is mushy, then Katelynn is broad-minded and Joseph is not aggressive.\n((Wicked(olive) ∨ BroadMinded(cyril))) → ((Aggressive(katelynn))) ::: Olive being wicked or Cyril being broad-minded implies that Katelynn is aggressive.\n(∃x (Wicked(x) ∧ ¬Mushy(x))) → ((¬Drab(montague))) ::: If there is someone who is both wicked and not mushy, then Montague is not drab.\n((¬Impossible(whitney))) → ((¬Mushy(cyril) ∧ BroadMinded(joseph))) ::: Whitney being not impossible implies that Cyril is not mushy and Joseph is broad-minded.\n(∀x (¬Aggressive(x))) ↔ (∀x (¬Impossible(x))) ::: Someone is not aggressive if and only if he is not impossible.\n(∀x (Aggressive(x) ∧ ¬Drab(x))) ↔ (∀x (¬Impossible(x))) ::: Someone is aggressive and not drab if and only if he is not impossible.\n",
                "First-Order-Logic Question": "Impossible(katelynn) ::: Katelynn is impossible."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬x)) → ((¬BroadMinded(cyril) ∧ Aggressive(ansel))) ::: If there is nobody who is not, then Cyril is not broad-minded and Ansel is aggressive.",
                    "gram": "¬∃x((¬BroadMinded(x)∧Aggressive(x))) ::: If there is nobody who is not, then Cyril is not broad-minded and Ansel is aggressive."
                }
            ],
            "answer": "C",
            "grammar_answer": "C",
            "backup_answer": "A"
        },
        {
            "id": 562,
            "raw_prog": {
                "First-Order-Logic Rules": "Aggressive(montague) ::: Montague is aggressive.\nImpossible(ansel) ::: Ansel is impossible.\n¬Wicked(cyril) ::: Cyril is not wicked.\n¬Wicked(ansel) ::: Ansel is not wicked.\nDrab(katelynn) ::: Katelynn is drab.\n¬Drab(montague) ::: Montague is not drab.\n¬Mushy(ansel) ::: Ansel is not mushy.\n¬Wicked(joseph) ::: Joseph is not wicked.\nBroadMinded(joseph) ::: Joseph is broad-minded.\nDrab(olive) ::: Olive is drab.\n¬Drab(ansel) ::: Ansel is not drab.\n¬Wicked(montague) ::: Montague is not wicked.\n((Mushy(montague) ∧ ¬Wicked(katelynn))) → ((¬Aggressive(ansel))) ::: Montague being mushy and Katelynn being not wicked imply that Ansel is not aggressive.\n((BroadMinded(joseph))) ↔ ((¬Impossible(joseph))) ::: Joseph is broad-minded if and only if Joseph is not impossible.\n(∃x (¬Mushy(x))) → ((¬Aggressive(whitney) ∧ Impossible(cyril))) ::: If there is at least one people who is not mushy, then Whitney is not aggressive and Cyril is impossible.\n(∃x (BroadMinded(x) ∨ Impossible(x))) → ((Aggressive(olive))) ::: If there is someone who is either broad-minded or impossible, then Olive is aggressive.\n(∀x (¬x)) → ((¬BroadMinded(cyril) ∧ Aggressive(ansel))) ::: If there is nobody who is not, then Cyril is not broad-minded and Ansel is aggressive.\n((Wicked(olive) ∧ Drab(katelynn))) ↔ ((Aggressive(joseph) ∧ ¬BroadMinded(montague))) ::: Olive is wicked and Katelynn is drab if and only if Joseph is aggressive and Montague is not broad-minded.\n(∃x (Mushy(x))) → ((BroadMinded(katelynn) ∧ ¬Aggressive(joseph))) ::: If there is at least one people who is mushy, then Katelynn is broad-minded and Joseph is not aggressive.\n((Wicked(olive) ∨ BroadMinded(cyril))) → ((Aggressive(katelynn))) ::: Olive being wicked or Cyril being broad-minded implies that Katelynn is aggressive.\n(∃x (Wicked(x) ∧ ¬Mushy(x))) → ((¬Drab(montague))) ::: If there is someone who is both wicked and not mushy, then Montague is not drab.\n((¬Impossible(whitney))) → ((¬Mushy(cyril) ∧ BroadMinded(joseph))) ::: Whitney being not impossible implies that Cyril is not mushy and Joseph is broad-minded.\n(∀x (¬Aggressive(x))) ↔ (∀x (¬Impossible(x))) ::: Someone is not aggressive if and only if he is not impossible.\n(∀x (Aggressive(x) ∧ ¬Drab(x))) ↔ (∀x (¬Impossible(x))) ::: Someone is aggressive and not drab if and only if he is not impossible.\n",
                "First-Order-Logic Question": "Impossible(cyril) ::: Cyril is impossible."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "Aggressive(montague) ::: Montague is aggressive.\nImpossible(ansel) ::: Ansel is impossible.\n¬Wicked(cyril) ::: Cyril is not wicked.\n¬Wicked(ansel) ::: Ansel is not wicked.\nDrab(katelynn) ::: Katelynn is drab.\n¬Drab(montague) ::: Montague is not drab.\n¬Mushy(ansel) ::: Ansel is not mushy.\n¬Wicked(joseph) ::: Joseph is not wicked.\nBroadMinded(joseph) ::: Joseph is broad-minded.\nDrab(olive) ::: Olive is drab.\n¬Drab(ansel) ::: Ansel is not drab.\n¬Wicked(montague) ::: Montague is not wicked.\n((Mushy(montague) ∧ ¬Wicked(katelynn))) → ((¬Aggressive(ansel))) ::: Montague being mushy and Katelynn being not wicked imply that Ansel is not aggressive.\n((BroadMinded(joseph))) ↔ ((¬Impossible(joseph))) ::: Joseph is broad-minded if and only if Joseph is not impossible.\n(∃x (¬Mushy(x))) → ((¬Aggressive(whitney) ∧ Impossible(cyril))) ::: If there is at least one people who is not mushy, then Whitney is not aggressive and Cyril is impossible.\n(∃x (BroadMinded(x) ∨ Impossible(x))) → ((Aggressive(olive))) ::: If there is someone who is either broad-minded or impossible, then Olive is aggressive.\n¬(¬BroadMinded(x))→((¬Aggressive(x))) ::: If there is nobody who is not, then Cyril is not broad-minded and Ansel is aggressive.\n((Wicked(olive) ∧ Drab(katelynn))) ↔ ((Aggressive(joseph) ∧ ¬BroadMinded(montague))) ::: Olive is wicked and Katelynn is drab if and only if Joseph is aggressive and Montague is not broad-minded.\n(∃x (Mushy(x))) → ((BroadMinded(katelynn) ∧ ¬Aggressive(joseph))) ::: If there is at least one people who is mushy, then Katelynn is broad-minded and Joseph is not aggressive.\n((Wicked(olive) ∨ BroadMinded(cyril))) → ((Aggressive(katelynn))) ::: Olive being wicked or Cyril being broad-minded implies that Katelynn is aggressive.\n(∃x (Wicked(x) ∧ ¬Mushy(x))) → ((¬Drab(montague))) ::: If there is someone who is both wicked and not mushy, then Montague is not drab.\n((¬Impossible(whitney))) → ((¬Mushy(cyril) ∧ BroadMinded(joseph))) ::: Whitney being not impossible implies that Cyril is not mushy and Joseph is broad-minded.\n(∀x (¬Aggressive(x))) ↔ (∀x (¬Impossible(x))) ::: Someone is not aggressive if and only if he is not impossible.\n(∀x (Aggressive(x) ∧ ¬Drab(x))) ↔ (∀x (¬Impossible(x))) ::: Someone is aggressive and not drab if and only if he is not impossible.\n",
                "First-Order-Logic Question": "Impossible(cyril) ::: Cyril is impossible."
            },
            "diff": [
                {
                    "raw": "(∀x (¬x)) → ((¬BroadMinded(cyril) ∧ Aggressive(ansel))) ::: If there is nobody who is not, then Cyril is not broad-minded and Ansel is aggressive.",
                    "gram": "¬(¬BroadMinded(x))→((¬Aggressive(x))) ::: If there is nobody who is not, then Cyril is not broad-minded and Ansel is aggressive."
                }
            ],
            "answer": "A",
            "grammar_answer": "A",
            "backup_answer": "A"
        },
        {
            "id": 563,
            "raw_prog": {
                "First-Order-Logic Rules": "Aggressive(montague) ::: Montague is aggressive.\nImpossible(ansel) ::: Ansel is impossible.\n¬Wicked(cyril) ::: Cyril is not wicked.\n¬Wicked(ansel) ::: Ansel is not wicked.\nDrab(katelynn) ::: Katelynn is drab.\n¬Drab(montague) ::: Montague is not drab.\n¬Mushy(ansel) ::: Ansel is not mushy.\n¬Wicked(joseph) ::: Joseph is not wicked.\nBroadMinded(joseph) ::: Joseph is broad-minded.\nDrab(olive) ::: Olive is drab.\n¬Drab(ansel) ::: Ansel is not drab.\n¬Wicked(montague) ::: Montague is not wicked.\n((Mushy(montague) ∧ ¬Wicked(katelynn))) → (¬Aggressive(ansel)) ::: Montague being mushy and Katelynn being not wicked imply that Ansel is not aggressive.\n(BroadMinded(joseph)) ↔ (¬Impossible(joseph)) ::: Joseph is broad-minded if and only if Joseph is not impossible.\n(∃x (¬Mushy(x))) → ((¬Aggressive(whitney) ∧ Impossible(cyril))) ::: If there is at least one people who is not mushy, then Whitney is not aggressive and Cyril is impossible.\n(∃x (BroadMinded(x) ∨ Impossible(x))) → (Aggressive(olive)) ::: If there is someone who is either broad-minded or impossible, then Olive is aggressive.\n(¬∃x (¬x)) → ((¬BroadMinded(cyril) ∧ Aggressive(ansel))) ::: If there is nobody who is not, then Cyril is not broad-minded and Ansel is aggressive.\n((Wicked(olive) ∧ Drab(katelynn))) ↔ ((Aggressive(joseph) ∧ ¬BroadMinded(montague))) ::: Olive is wicked and Katelynn is drab if and only if Joseph is aggressive and Montague is not broad-minded.\n(∃x (Mushy(x))) → ((BroadMinded(katelynn) ∧ ¬Aggressive(joseph))) ::: If there is at least one people who is mushy, then Katelynn is broad-minded and Joseph is not aggressive.\n((Wicked(olive) ∨ BroadMinded(cyril))) → (Aggressive(katelynn)) ::: Olive being wicked or Cyril being broad-minded implies that Katelynn is aggressive.\n(∃x (Wicked(x) ∧ ¬Mushy(x))) → (¬Drab(montague)) ::: If there is someone who is both wicked and not mushy, then Montague is not drab.\n(¬Impossible(whitney)) → ((¬Mushy(cyril) ∧ BroadMinded(joseph))) ::: Whitney being not impossible implies that Cyril is not mushy and Joseph is broad-minded.\n(∀x (¬Aggressive(x))) ↔ (∀x (¬Impossible(x))) ::: Someone is not aggressive if and only if he is not impossible.\n(∀x (Aggressive(x) ∧ ¬Drab(x))) ↔ (∀x (¬Impossible(x))) ::: Someone is aggressive and not drab if and only if he is not impossible.\n",
                "First-Order-Logic Question": "Wicked(ansel) ::: Ansel is wicked."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "Aggressive(montague) ::: Montague is aggressive.\nImpossible(ansel) ::: Ansel is impossible.\n¬Wicked(cyril) ::: Cyril is not wicked.\n¬Wicked(ansel) ::: Ansel is not wicked.\nDrab(katelynn) ::: Katelynn is drab.\n¬Drab(montague) ::: Montague is not drab.\n¬Mushy(ansel) ::: Ansel is not mushy.\n¬Wicked(joseph) ::: Joseph is not wicked.\nBroadMinded(joseph) ::: Joseph is broad-minded.\nDrab(olive) ::: Olive is drab.\n¬Drab(ansel) ::: Ansel is not drab.\n¬Wicked(montague) ::: Montague is not wicked.\n((Mushy(montague) ∧ ¬Wicked(katelynn))) → (¬Aggressive(ansel)) ::: Montague being mushy and Katelynn being not wicked imply that Ansel is not aggressive.\n(BroadMinded(joseph)) ↔ (¬Impossible(joseph)) ::: Joseph is broad-minded if and only if Joseph is not impossible.\n(∃x (¬Mushy(x))) → ((¬Aggressive(whitney) ∧ Impossible(cyril))) ::: If there is at least one people who is not mushy, then Whitney is not aggressive and Cyril is impossible.\n(∃x (BroadMinded(x) ∨ Impossible(x))) → (Aggressive(olive)) ::: If there is someone who is either broad-minded or impossible, then Olive is aggressive.\n¬∃x((¬BroadMinded(x)∧Aggressive(x))) ::: If there is nobody who is not, then Cyril is not broad-minded and Ansel is aggressive.\n((Wicked(olive) ∧ Drab(katelynn))) ↔ ((Aggressive(joseph) ∧ ¬BroadMinded(montague))) ::: Olive is wicked and Katelynn is drab if and only if Joseph is aggressive and Montague is not broad-minded.\n(∃x (Mushy(x))) → ((BroadMinded(katelynn) ∧ ¬Aggressive(joseph))) ::: If there is at least one people who is mushy, then Katelynn is broad-minded and Joseph is not aggressive.\n((Wicked(olive) ∨ BroadMinded(cyril))) → (Aggressive(katelynn)) ::: Olive being wicked or Cyril being broad-minded implies that Katelynn is aggressive.\n(∃x (Wicked(x) ∧ ¬Mushy(x))) → (¬Drab(montague)) ::: If there is someone who is both wicked and not mushy, then Montague is not drab.\n(¬Impossible(whitney)) → ((¬Mushy(cyril) ∧ BroadMinded(joseph))) ::: Whitney being not impossible implies that Cyril is not mushy and Joseph is broad-minded.\n(∀x (¬Aggressive(x))) ↔ (∀x (¬Impossible(x))) ::: Someone is not aggressive if and only if he is not impossible.\n(∀x (Aggressive(x) ∧ ¬Drab(x))) ↔ (∀x (¬Impossible(x))) ::: Someone is aggressive and not drab if and only if he is not impossible.\n",
                "First-Order-Logic Question": "Wicked(ansel) ::: Ansel is wicked."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬x)) → ((¬BroadMinded(cyril) ∧ Aggressive(ansel))) ::: If there is nobody who is not, then Cyril is not broad-minded and Ansel is aggressive.",
                    "gram": "¬∃x((¬BroadMinded(x)∧Aggressive(x))) ::: If there is nobody who is not, then Cyril is not broad-minded and Ansel is aggressive."
                }
            ],
            "answer": "B",
            "grammar_answer": "B",
            "backup_answer": "B"
        },
        {
            "id": 564,
            "raw_prog": {
                "First-Order-Logic Rules": "Aggressive(montague) ::: Montague is aggressive.\nImpossible(ansel) ::: Ansel is impossible.\n¬Wicked(cyril) ::: Cyril is not wicked.\n¬Wicked(ansel) ::: Ansel is not wicked.\nDrab(katelynn) ::: Katelynn is drab.\n¬Drab(montague) ::: Montague is not drab.\n¬Mushy(ansel) ::: Ansel is not mushy.\n¬Wicked(joseph) ::: Joseph is not wicked.\nDrab(olive) ::: Olive is drab.\nBroadMinded(joseph) ::: Joseph is broad-minded.\n¬Drab(ansel) ::: Ansel is not drab.\n¬Wicked(montague) ::: Montague is not wicked.\n((Mushy(montague) ∧ ¬Wicked(katelynn))) → (¬Aggressive(ansel)) ::: Montague being mushy and Katelynn being not wicked imply that Ansel is not aggressive.\n(BroadMinded(joseph)) ↔ (¬Impossible(joseph)) ::: Joseph is broad-minded if and only if Joseph is not impossible.\n(∃x (¬Mushy(x))) → ((¬Aggressive(whitney) ∧ Impossible(cyril))) ::: If there is at least one people who is not mushy, then Whitney is not aggressive and Cyril is impossible.\n(∃x (BroadMinded(x) ∨ Impossible(x))) → (Aggressive(olive)) ::: If there is someone who is either broad-minded or impossible, then Olive is aggressive.\n(¬∃x (¬x)) → ((¬BroadMinded(cyril) ∧ Aggressive(ansel))) ::: If there is nobody who is not, then Cyril is not broad-minded and Ansel is aggressive.\n((Wicked(olive) ∧ Drab(katelynn))) ↔ ((Aggressive(joseph) ∧ ¬BroadMinded(montague))) ::: Olive is wicked and Katelynn is drab if and only if Joseph is aggressive and Montague is not broad-minded.\n(∃x (Mushy(x))) → ((BroadMinded(katelynn) ∧ ¬Aggressive(joseph))) ::: If there is at least one people who is mushy, then Katelynn is broad-minded and Joseph is not aggressive.\n((Wicked(olive) ∨ BroadMinded(cyril))) → (Aggressive(katelynn)) ::: Olive being wicked or Cyril being broad-minded implies that Katelynn is aggressive.\n(∃x (Wicked(x) ∧ ¬Mushy(x))) → (¬Drab(montague)) ::: If there is someone who is both wicked and not mushy, then Montague is not drab.\n(¬Impossible(whitney)) → ((¬Mushy(cyril) ∧ BroadMinded(joseph))) ::: Whitney being not impossible implies that Cyril is not mushy and Joseph is broad-minded.\n(∀x (¬Aggressive(x))) ↔ (∀x (¬Impossible(x))) ::: Someone is not aggressive if and only if he is not impossible.\n(∀x (Aggressive(x) ∧ ¬Drab(x))) ↔ (∀x (¬Impossible(x))) ::: Someone is aggressive and not drab if and only if he is not impossible.\n",
                "First-Order-Logic Question": "¬Mushy(ansel) ::: Ansel is not mushy."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "Aggressive(montague) ::: Montague is aggressive.\nImpossible(ansel) ::: Ansel is impossible.\n¬Wicked(cyril) ::: Cyril is not wicked.\n¬Wicked(ansel) ::: Ansel is not wicked.\nDrab(katelynn) ::: Katelynn is drab.\n¬Drab(montague) ::: Montague is not drab.\n¬Mushy(ansel) ::: Ansel is not mushy.\n¬Wicked(joseph) ::: Joseph is not wicked.\nDrab(olive) ::: Olive is drab.\nBroadMinded(joseph) ::: Joseph is broad-minded.\n¬Drab(ansel) ::: Ansel is not drab.\n¬Wicked(montague) ::: Montague is not wicked.\n((Mushy(montague) ∧ ¬Wicked(katelynn))) → (¬Aggressive(ansel)) ::: Montague being mushy and Katelynn being not wicked imply that Ansel is not aggressive.\n(BroadMinded(joseph)) ↔ (¬Impossible(joseph)) ::: Joseph is broad-minded if and only if Joseph is not impossible.\n(∃x (¬Mushy(x))) → ((¬Aggressive(whitney) ∧ Impossible(cyril))) ::: If there is at least one people who is not mushy, then Whitney is not aggressive and Cyril is impossible.\n(∃x (BroadMinded(x) ∨ Impossible(x))) → (Aggressive(olive)) ::: If there is someone who is either broad-minded or impossible, then Olive is aggressive.\n¬∃x(¬(¬(BroadMinded(x)))) ::: If there is nobody who is not, then Cyril is not broad-minded and Ansel is aggressive.\n((Wicked(olive) ∧ Drab(katelynn))) ↔ ((Aggressive(joseph) ∧ ¬BroadMinded(montague))) ::: Olive is wicked and Katelynn is drab if and only if Joseph is aggressive and Montague is not broad-minded.\n(∃x (Mushy(x))) → ((BroadMinded(katelynn) ∧ ¬Aggressive(joseph))) ::: If there is at least one people who is mushy, then Katelynn is broad-minded and Joseph is not aggressive.\n((Wicked(olive) ∨ BroadMinded(cyril))) → (Aggressive(katelynn)) ::: Olive being wicked or Cyril being broad-minded implies that Katelynn is aggressive.\n(∃x (Wicked(x) ∧ ¬Mushy(x))) → (¬Drab(montague)) ::: If there is someone who is both wicked and not mushy, then Montague is not drab.\n(¬Impossible(whitney)) → ((¬Mushy(cyril) ∧ BroadMinded(joseph))) ::: Whitney being not impossible implies that Cyril is not mushy and Joseph is broad-minded.\n(∀x (¬Aggressive(x))) ↔ (∀x (¬Impossible(x))) ::: Someone is not aggressive if and only if he is not impossible.\n(∀x (Aggressive(x) ∧ ¬Drab(x))) ↔ (∀x (¬Impossible(x))) ::: Someone is aggressive and not drab if and only if he is not impossible.\n",
                "First-Order-Logic Question": "¬Mushy(ansel) ::: Ansel is not mushy."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬x)) → ((¬BroadMinded(cyril) ∧ Aggressive(ansel))) ::: If there is nobody who is not, then Cyril is not broad-minded and Ansel is aggressive.",
                    "gram": "¬∃x(¬(¬(BroadMinded(x)))) ::: If there is nobody who is not, then Cyril is not broad-minded and Ansel is aggressive."
                }
            ],
            "answer": "A",
            "grammar_answer": "A",
            "backup_answer": "A"
        },
        {
            "id": 565,
            "raw_prog": {
                "First-Order-Logic Rules": "Aggressive(montague) ::: Montague is aggressive.\nImpossible(ansel) ::: Ansel is impossible.\n¬Wicked(cyril) ::: Cyril is not wicked.\n¬Wicked(ansel) ::: Ansel is not wicked.\nDrab(katelynn) ::: Katelynn is drab.\n¬Drab(montague) ::: Montague is not drab.\n¬Mushy(ansel) ::: Ansel is not mushy.\n¬Wicked(joseph) ::: Joseph is not wicked.\nBroadMinded(joseph) ::: Joseph is broad-minded.\nDrab(olive) ::: Olive is drab.\n¬Drab(ansel) ::: Ansel is not drab.\n¬Wicked(montague) ::: Montague is not wicked.\n((Mushy(montague) ∧ ¬Wicked(katelynn))) → ((¬Aggressive(ansel))) ::: Montague being mushy and Katelynn being not wicked imply that Ansel is not aggressive.\n((BroadMinded(joseph))) ↔ ((¬Impossible(joseph))) ::: Joseph is broad-minded if and only if Joseph is not impossible.\n(∃x (¬Mushy(x))) → ((¬Aggressive(whitney) ∧ Impossible(cyril))) ::: If there is at least one people who is not mushy, then Whitney is not aggressive and Cyril is impossible.\n(∃x (BroadMinded(x) ∨ Impossible(x))) → ((Aggressive(olive))) ::: If there is someone who is either broad-minded or impossible, then Olive is aggressive.\n(∀x (¬x)) → ((¬BroadMinded(cyril) ∧ Aggressive(ansel))) ::: If there is nobody who is not, then Cyril is not broad-minded and Ansel is aggressive.\n((Wicked(olive) ∧ Drab(katelynn))) ↔ ((Aggressive(joseph) ∧ ¬BroadMinded(montague))) ::: Olive is wicked and Katelynn is drab if and only if Joseph is aggressive and Montague is not broad-minded.\n(∃x (Mushy(x))) → ((BroadMinded(katelynn) ∧ ¬Aggressive(joseph))) ::: If there is at least one people who is mushy, then Katelynn is broad-minded and Joseph is not aggressive.\n((Wicked(olive) ∨ BroadMinded(cyril))) → ((Aggressive(katelynn))) ::: Olive being wicked or Cyril being broad-minded implies that Katelynn is aggressive.\n(∃x (Wicked(x) ∧ ¬Mushy(x))) → ((¬Drab(montague))) ::: If there is someone who is both wicked and not mushy, then Montague is not drab.\n((¬Impossible(whitney))) → ((¬Mushy(cyril) ∧ BroadMinded(joseph))) ::: Whitney being not impossible implies that Cyril is not mushy and Joseph is broad-minded.\n(∀x (¬Aggressive(x))) ↔ (∀x (¬Impossible(x))) ::: Someone is not aggressive if and only if he is not impossible.\n(∀x (Aggressive(x) ∧ ¬Drab(x))) ↔ (∀x (¬Impossible(x))) ::: Someone is aggressive and not drab if and only if he is not impossible.\n",
                "First-Order-Logic Question": "Impossible(ansel) ::: Ansel is impossible."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "Aggressive(montague) ::: Montague is aggressive.\nImpossible(ansel) ::: Ansel is impossible.\n¬Wicked(cyril) ::: Cyril is not wicked.\n¬Wicked(ansel) ::: Ansel is not wicked.\nDrab(katelynn) ::: Katelynn is drab.\n¬Drab(montague) ::: Montague is not drab.\n¬Mushy(ansel) ::: Ansel is not mushy.\n¬Wicked(joseph) ::: Joseph is not wicked.\nBroadMinded(joseph) ::: Joseph is broad-minded.\nDrab(olive) ::: Olive is drab.\n¬Drab(ansel) ::: Ansel is not drab.\n¬Wicked(montague) ::: Montague is not wicked.\n((Mushy(montague) ∧ ¬Wicked(katelynn))) → ((¬Aggressive(ansel))) ::: Montague being mushy and Katelynn being not wicked imply that Ansel is not aggressive.\n((BroadMinded(joseph))) ↔ ((¬Impossible(joseph))) ::: Joseph is broad-minded if and only if Joseph is not impossible.\n(∃x (¬Mushy(x))) → ((¬Aggressive(whitney) ∧ Impossible(cyril))) ::: If there is at least one people who is not mushy, then Whitney is not aggressive and Cyril is impossible.\n(∃x (BroadMinded(x) ∨ Impossible(x))) → ((Aggressive(olive))) ::: If there is someone who is either broad-minded or impossible, then Olive is aggressive.\n¬(¬BroadMinded(x))→((¬Aggressive(x))) ::: If there is nobody who is not, then Cyril is not broad-minded and Ansel is aggressive.\n((Wicked(olive) ∧ Drab(katelynn))) ↔ ((Aggressive(joseph) ∧ ¬BroadMinded(montague))) ::: Olive is wicked and Katelynn is drab if and only if Joseph is aggressive and Montague is not broad-minded.\n(∃x (Mushy(x))) → ((BroadMinded(katelynn) ∧ ¬Aggressive(joseph))) ::: If there is at least one people who is mushy, then Katelynn is broad-minded and Joseph is not aggressive.\n((Wicked(olive) ∨ BroadMinded(cyril))) → ((Aggressive(katelynn))) ::: Olive being wicked or Cyril being broad-minded implies that Katelynn is aggressive.\n(∃x (Wicked(x) ∧ ¬Mushy(x))) → ((¬Drab(montague))) ::: If there is someone who is both wicked and not mushy, then Montague is not drab.\n((¬Impossible(whitney))) → ((¬Mushy(cyril) ∧ BroadMinded(joseph))) ::: Whitney being not impossible implies that Cyril is not mushy and Joseph is broad-minded.\n(∀x (¬Aggressive(x))) ↔ (∀x (¬Impossible(x))) ::: Someone is not aggressive if and only if he is not impossible.\n(∀x (Aggressive(x) ∧ ¬Drab(x))) ↔ (∀x (¬Impossible(x))) ::: Someone is aggressive and not drab if and only if he is not impossible.\n",
                "First-Order-Logic Question": "Impossible(ansel) ::: Ansel is impossible."
            },
            "diff": [
                {
                    "raw": "(∀x (¬x)) → ((¬BroadMinded(cyril) ∧ Aggressive(ansel))) ::: If there is nobody who is not, then Cyril is not broad-minded and Ansel is aggressive.",
                    "gram": "¬(¬BroadMinded(x))→((¬Aggressive(x))) ::: If there is nobody who is not, then Cyril is not broad-minded and Ansel is aggressive."
                }
            ],
            "answer": "A",
            "grammar_answer": "A",
            "backup_answer": "B"
        },
        {
            "id": 567,
            "raw_prog": {
                "First-Order-Logic Rules": "Aggressive(montague) ::: Montague is aggressive.\nImpossible(ansel) ::: Ansel is impossible.\n¬Wicked(cyril) ::: Cyril is not wicked.\n¬Wicked(ansel) ::: Ansel is not wicked.\nDrab(katelynn) ::: Katelynn is drab.\n¬Drab(montague) ::: Montague is not drab.\n¬Mushy(ansel) ::: Ansel is not mushy.\n¬Wicked(joseph) ::: Joseph is not wicked.\nBroadMinded(joseph) ::: Joseph is broad-minded.\nDrab(olive) ::: Olive is drab.\n¬Drab(ansel) ::: Ansel is not drab.\n¬Wicked(montague) ::: Montague is not wicked.\n((Mushy(montague) ∧ ¬Wicked(katelynn))) → (¬Aggressive(ansel)) ::: Montague being mushy and Katelynn being not wicked imply that Ansel is not aggressive.\n(BroadMinded(joseph)) ↔ (¬Impossible(joseph)) ::: Joseph is broad-minded if and only if Joseph is not impossible.\n(∃x (¬Mushy(x))) → ((¬Aggressive(whitney) ∧ Impossible(cyril))) ::: If there is at least one people who is not mushy, then Whitney is not aggressive and Cyril is impossible.\n(∃x (BroadMinded(x) ∨ Impossible(x))) → ((Aggressive(olive))) ::: If there is someone who is either broad-minded or impossible, then Olive is aggressive.\n(¬∃x (¬x)) → ((¬BroadMinded(cyril) ∧ Aggressive(ansel))) ::: If there is nobody who is not, then Cyril is not broad-minded and Ansel is aggressive.\n((Wicked(olive) ∧ Drab(katelynn))) ↔ ((Aggressive(joseph) ∧ ¬BroadMinded(montague))) ::: Olive is wicked and Katelynn is drab if and only if Joseph is aggressive and Montague is not broad-minded.\n(∃x (Mushy(x))) → ((BroadMinded(katelynn) ∧ ¬Aggressive(joseph))) ::: If there is at least one people who is mushy, then Katelynn is broad-minded and Joseph is not aggressive.\n((Wicked(olive) ∨ BroadMinded(cyril))) → ((Aggressive(katelynn))) ::: Olive being wicked or Cyril being broad-minded implies that Katelynn is aggressive.\n(∃x (Wicked(x) ∧ ¬Mushy(x))) → ((¬Drab(montague))) ::: If there is someone who is both wicked and not mushy, then Montague is not drab.\n(¬Impossible(whitney)) → ((¬Mushy(cyril) ∧ BroadMinded(joseph))) ::: Whitney being not impossible implies that Cyril is not mushy and Joseph is broad-minded.\n(∀x (¬Aggressive(x))) ↔ (∀x (¬Impossible(x))) ::: Someone is not aggressive if and only if he is not impossible.\n(∀x (Aggressive(x) ∧ ¬Drab(x))) ↔ (∀x (¬Impossible(x))) ::: Someone is aggressive and not drab if and only if he is not impossible.\n",
                "First-Order-Logic Question": "¬BroadMinded(olive) ::: Olive is not broad-minded."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "Aggressive(montague) ::: Montague is aggressive.\nImpossible(ansel) ::: Ansel is impossible.\n¬Wicked(cyril) ::: Cyril is not wicked.\n¬Wicked(ansel) ::: Ansel is not wicked.\nDrab(katelynn) ::: Katelynn is drab.\n¬Drab(montague) ::: Montague is not drab.\n¬Mushy(ansel) ::: Ansel is not mushy.\n¬Wicked(joseph) ::: Joseph is not wicked.\nBroadMinded(joseph) ::: Joseph is broad-minded.\nDrab(olive) ::: Olive is drab.\n¬Drab(ansel) ::: Ansel is not drab.\n¬Wicked(montague) ::: Montague is not wicked.\n((Mushy(montague) ∧ ¬Wicked(katelynn))) → (¬Aggressive(ansel)) ::: Montague being mushy and Katelynn being not wicked imply that Ansel is not aggressive.\n(BroadMinded(joseph)) ↔ (¬Impossible(joseph)) ::: Joseph is broad-minded if and only if Joseph is not impossible.\n(∃x (¬Mushy(x))) → ((¬Aggressive(whitney) ∧ Impossible(cyril))) ::: If there is at least one people who is not mushy, then Whitney is not aggressive and Cyril is impossible.\n(∃x (BroadMinded(x) ∨ Impossible(x))) → ((Aggressive(olive))) ::: If there is someone who is either broad-minded or impossible, then Olive is aggressive.\n¬∃x((¬BroadMinded(x)∧Aggressive(x))) ::: If there is nobody who is not, then Cyril is not broad-minded and Ansel is aggressive.\n((Wicked(olive) ∧ Drab(katelynn))) ↔ ((Aggressive(joseph) ∧ ¬BroadMinded(montague))) ::: Olive is wicked and Katelynn is drab if and only if Joseph is aggressive and Montague is not broad-minded.\n(∃x (Mushy(x))) → ((BroadMinded(katelynn) ∧ ¬Aggressive(joseph))) ::: If there is at least one people who is mushy, then Katelynn is broad-minded and Joseph is not aggressive.\n((Wicked(olive) ∨ BroadMinded(cyril))) → ((Aggressive(katelynn))) ::: Olive being wicked or Cyril being broad-minded implies that Katelynn is aggressive.\n(∃x (Wicked(x) ∧ ¬Mushy(x))) → ((¬Drab(montague))) ::: If there is someone who is both wicked and not mushy, then Montague is not drab.\n(¬Impossible(whitney)) → ((¬Mushy(cyril) ∧ BroadMinded(joseph))) ::: Whitney being not impossible implies that Cyril is not mushy and Joseph is broad-minded.\n(∀x (¬Aggressive(x))) ↔ (∀x (¬Impossible(x))) ::: Someone is not aggressive if and only if he is not impossible.\n(∀x (Aggressive(x) ∧ ¬Drab(x))) ↔ (∀x (¬Impossible(x))) ::: Someone is aggressive and not drab if and only if he is not impossible.\n",
                "First-Order-Logic Question": "¬BroadMinded(olive) ::: Olive is not broad-minded."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬x)) → ((¬BroadMinded(cyril) ∧ Aggressive(ansel))) ::: If there is nobody who is not, then Cyril is not broad-minded and Ansel is aggressive.",
                    "gram": "¬∃x((¬BroadMinded(x)∧Aggressive(x))) ::: If there is nobody who is not, then Cyril is not broad-minded and Ansel is aggressive."
                }
            ],
            "answer": "C",
            "grammar_answer": "B",
            "backup_answer": "C"
        },
        {
            "id": 568,
            "raw_prog": {
                "First-Order-Logic Rules": "Aggressive(montague) ::: Montague is aggressive.\nImpossible(ansel) ::: Ansel is impossible.\n¬Wicked(cyril) ::: Cyril is not wicked.\n¬Wicked(ansel) ::: Ansel is not wicked.\nDrab(katelynn) ::: Katelynn is drab.\n¬Drab(montague) ::: Montague is not drab.\n¬Mushy(ansel) ::: Ansel is not mushy.\n¬Wicked(joseph) ::: Joseph is not wicked.\nDrab(olive) ::: Olive is drab.\nBroadMinded(joseph) ::: Joseph is broad-minded.\n¬Drab(ansel) ::: Ansel is not drab.\n¬Wicked(montague) ::: Montague is not wicked.\n((Mushy(montague) ∧ ¬Wicked(katelynn))) → (¬Aggressive(ansel)) ::: Montague being mushy and Katelynn being not wicked imply that Ansel is not aggressive.\n(BroadMinded(joseph)) ↔ (¬Impossible(joseph)) ::: Joseph is broad-minded if and only if Joseph is not impossible.\n(∃x (¬Mushy(x))) → ((¬Aggressive(whitney) ∧ Impossible(cyril))) ::: If there is at least one people who is not mushy, then Whitney is not aggressive and Cyril is impossible.\n(∃x (BroadMinded(x) ∨ Impossible(x))) → (Aggressive(olive)) ::: If there is someone who is either broad-minded or impossible, then Olive is aggressive.\n(∀x (¬x)) → ((¬BroadMinded(cyril) ∧ Aggressive(ansel))) ::: If there is nobody who is not, then Cyril is not broad-minded and Ansel is aggressive.\n((Wicked(olive) ∧ Drab(katelynn))) ↔ ((Aggressive(joseph) ∧ ¬BroadMinded(montague))) ::: Olive is wicked and Katelynn is drab if and only if Joseph is aggressive and Montague is not broad-minded.\n(∃x (Mushy(x))) → ((BroadMinded(katelynn) ∧ ¬Aggressive(joseph))) ::: If there is at least one people who is mushy, then Katelynn is broad-minded and Joseph is not aggressive.\n((Wicked(olive) ∨ BroadMinded(cyril))) → (Aggressive(katelynn)) ::: Olive being wicked or Cyril being broad-minded implies that Katelynn is aggressive.\n(∃x (Wicked(x) ∧ ¬Mushy(x))) → (¬Drab(montague)) ::: If there is someone who is both wicked and not mushy, then Montague is not drab.\n(¬Impossible(whitney)) → ((¬Mushy(cyril) ∧ BroadMinded(joseph))) ::: Whitney being not impossible implies that Cyril is not mushy and Joseph is broad-minded.\n(∀x (¬Aggressive(x))) ↔ (∀x (¬Impossible(x))) ::: Someone is not aggressive if and only if he is not impossible.\n(∀x (Aggressive(x) ∧ ¬Drab(x))) ↔ (∀x (¬Impossible(x))) ::: Someone is aggressive and not drab if and only if he is not impossible.\n",
                "First-Order-Logic Question": "¬Wicked(montague) ::: Montague is not wicked."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "Aggressive(montague) ::: Montague is aggressive.\nImpossible(ansel) ::: Ansel is impossible.\n¬Wicked(cyril) ::: Cyril is not wicked.\n¬Wicked(ansel) ::: Ansel is not wicked.\nDrab(katelynn) ::: Katelynn is drab.\n¬Drab(montague) ::: Montague is not drab.\n¬Mushy(ansel) ::: Ansel is not mushy.\n¬Wicked(joseph) ::: Joseph is not wicked.\nDrab(olive) ::: Olive is drab.\nBroadMinded(joseph) ::: Joseph is broad-minded.\n¬Drab(ansel) ::: Ansel is not drab.\n¬Wicked(montague) ::: Montague is not wicked.\n((Mushy(montague) ∧ ¬Wicked(katelynn))) → (¬Aggressive(ansel)) ::: Montague being mushy and Katelynn being not wicked imply that Ansel is not aggressive.\n(BroadMinded(joseph)) ↔ (¬Impossible(joseph)) ::: Joseph is broad-minded if and only if Joseph is not impossible.\n(∃x (¬Mushy(x))) → ((¬Aggressive(whitney) ∧ Impossible(cyril))) ::: If there is at least one people who is not mushy, then Whitney is not aggressive and Cyril is impossible.\n(∃x (BroadMinded(x) ∨ Impossible(x))) → (Aggressive(olive)) ::: If there is someone who is either broad-minded or impossible, then Olive is aggressive.\n¬(¬BroadMinded(x))→((¬Aggressive(x))) ::: If there is nobody who is not, then Cyril is not broad-minded and Ansel is aggressive.\n((Wicked(olive) ∧ Drab(katelynn))) ↔ ((Aggressive(joseph) ∧ ¬BroadMinded(montague))) ::: Olive is wicked and Katelynn is drab if and only if Joseph is aggressive and Montague is not broad-minded.\n(∃x (Mushy(x))) → ((BroadMinded(katelynn) ∧ ¬Aggressive(joseph))) ::: If there is at least one people who is mushy, then Katelynn is broad-minded and Joseph is not aggressive.\n((Wicked(olive) ∨ BroadMinded(cyril))) → (Aggressive(katelynn)) ::: Olive being wicked or Cyril being broad-minded implies that Katelynn is aggressive.\n(∃x (Wicked(x) ∧ ¬Mushy(x))) → (¬Drab(montague)) ::: If there is someone who is both wicked and not mushy, then Montague is not drab.\n(¬Impossible(whitney)) → ((¬Mushy(cyril) ∧ BroadMinded(joseph))) ::: Whitney being not impossible implies that Cyril is not mushy and Joseph is broad-minded.\n(∀x (¬Aggressive(x))) ↔ (∀x (¬Impossible(x))) ::: Someone is not aggressive if and only if he is not impossible.\n(∀x (Aggressive(x) ∧ ¬Drab(x))) ↔ (∀x (¬Impossible(x))) ::: Someone is aggressive and not drab if and only if he is not impossible.\n",
                "First-Order-Logic Question": "¬Wicked(montague) ::: Montague is not wicked."
            },
            "diff": [
                {
                    "raw": "(∀x (¬x)) → ((¬BroadMinded(cyril) ∧ Aggressive(ansel))) ::: If there is nobody who is not, then Cyril is not broad-minded and Ansel is aggressive.",
                    "gram": "¬(¬BroadMinded(x))→((¬Aggressive(x))) ::: If there is nobody who is not, then Cyril is not broad-minded and Ansel is aggressive."
                }
            ],
            "answer": "A",
            "grammar_answer": "A",
            "backup_answer": "A"
        },
        {
            "id": 569,
            "raw_prog": {
                "First-Order-Logic Rules": "Aggressive(montague) ::: Montague is aggressive.\nImpossible(ansel) ::: Ansel is impossible.\n¬Wicked(cyril) ::: Cyril is not wicked.\n¬Wicked(ansel) ::: Ansel is not wicked.\nDrab(katelynn) ::: Katelynn is drab.\n¬Drab(montague) ::: Montague is not drab.\n¬Mushy(ansel) ::: Ansel is not mushy.\n¬Wicked(joseph) ::: Joseph is not wicked.\nBroadMinded(joseph) ::: Joseph is broad-minded.\nDrab(olive) ::: Olive is drab.\n¬Drab(ansel) ::: Ansel is not drab.\n¬Wicked(montague) ::: Montague is not wicked.\n((Mushy(montague) ∧ ¬Wicked(katelynn))) → (¬Aggressive(ansel)) ::: Montague being mushy and Katelynn being not wicked imply that Ansel is not aggressive.\n(BroadMinded(joseph)) ↔ (¬Impossible(joseph)) ::: Joseph is broad-minded if and only if Joseph is not impossible.\n(∃x (¬Mushy(x))) → ((¬Aggressive(whitney) ∧ Impossible(cyril))) ::: If there is at least one people who is not mushy, then Whitney is not aggressive and Cyril is impossible.\n(∃x (BroadMinded(x) ∨ Impossible(x))) → (Aggressive(olive)) ::: If there is someone who is either broad-minded or impossible, then Olive is aggressive.\n(∀x (¬x)) → ((¬BroadMinded(cyril) ∧ Aggressive(ansel))) ::: If there is nobody who is not, then Cyril is not broad-minded and Ansel is aggressive.\n((Wicked(olive) ∧ Drab(katelynn))) ↔ ((Aggressive(joseph) ∧ ¬BroadMinded(montague))) ::: Olive is wicked and Katelynn is drab if and only if Joseph is aggressive and Montague is not broad-minded.\n(∃x (Mushy(x))) → ((BroadMinded(katelynn) ∧ ¬Aggressive(joseph))) ::: If there is at least one people who is mushy, then Katelynn is broad-minded and Joseph is not aggressive.\n((Wicked(olive) ∨ BroadMinded(cyril))) → (Aggressive(katelynn)) ::: Olive being wicked or Cyril being broad-minded implies that Katelynn is aggressive.\n(∃x (Wicked(x) ∧ ¬Mushy(x))) → (¬Drab(montague)) ::: If there is someone who is both wicked and not mushy, then Montague is not drab.\n(¬Impossible(whitney)) → ((¬Mushy(cyril) ∧ BroadMinded(joseph))) ::: Whitney being not impossible implies that Cyril is not mushy and Joseph is broad-minded.\n(∀x (¬Aggressive(x))) ↔ (∀x (¬Impossible(x))) ::: Someone is not aggressive if and only if he is not impossible.\n(∀x (Aggressive(x) ∧ ¬Drab(x))) ↔ (∀x (¬Impossible(x))) ::: Someone is aggressive and not drab if and only if he is not impossible.\n",
                "First-Order-Logic Question": "Wicked(joseph) ::: Joseph is wicked."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "Aggressive(montague) ::: Montague is aggressive.\nImpossible(ansel) ::: Ansel is impossible.\n¬Wicked(cyril) ::: Cyril is not wicked.\n¬Wicked(ansel) ::: Ansel is not wicked.\nDrab(katelynn) ::: Katelynn is drab.\n¬Drab(montague) ::: Montague is not drab.\n¬Mushy(ansel) ::: Ansel is not mushy.\n¬Wicked(joseph) ::: Joseph is not wicked.\nBroadMinded(joseph) ::: Joseph is broad-minded.\nDrab(olive) ::: Olive is drab.\n¬Drab(ansel) ::: Ansel is not drab.\n¬Wicked(montague) ::: Montague is not wicked.\n((Mushy(montague) ∧ ¬Wicked(katelynn))) → (¬Aggressive(ansel)) ::: Montague being mushy and Katelynn being not wicked imply that Ansel is not aggressive.\n(BroadMinded(joseph)) ↔ (¬Impossible(joseph)) ::: Joseph is broad-minded if and only if Joseph is not impossible.\n(∃x (¬Mushy(x))) → ((¬Aggressive(whitney) ∧ Impossible(cyril))) ::: If there is at least one people who is not mushy, then Whitney is not aggressive and Cyril is impossible.\n(∃x (BroadMinded(x) ∨ Impossible(x))) → (Aggressive(olive)) ::: If there is someone who is either broad-minded or impossible, then Olive is aggressive.\n¬(¬BroadMinded(x))→((¬Aggressive(x))) ::: If there is nobody who is not, then Cyril is not broad-minded and Ansel is aggressive.\n((Wicked(olive) ∧ Drab(katelynn))) ↔ ((Aggressive(joseph) ∧ ¬BroadMinded(montague))) ::: Olive is wicked and Katelynn is drab if and only if Joseph is aggressive and Montague is not broad-minded.\n(∃x (Mushy(x))) → ((BroadMinded(katelynn) ∧ ¬Aggressive(joseph))) ::: If there is at least one people who is mushy, then Katelynn is broad-minded and Joseph is not aggressive.\n((Wicked(olive) ∨ BroadMinded(cyril))) → (Aggressive(katelynn)) ::: Olive being wicked or Cyril being broad-minded implies that Katelynn is aggressive.\n(∃x (Wicked(x) ∧ ¬Mushy(x))) → (¬Drab(montague)) ::: If there is someone who is both wicked and not mushy, then Montague is not drab.\n(¬Impossible(whitney)) → ((¬Mushy(cyril) ∧ BroadMinded(joseph))) ::: Whitney being not impossible implies that Cyril is not mushy and Joseph is broad-minded.\n(∀x (¬Aggressive(x))) ↔ (∀x (¬Impossible(x))) ::: Someone is not aggressive if and only if he is not impossible.\n(∀x (Aggressive(x) ∧ ¬Drab(x))) ↔ (∀x (¬Impossible(x))) ::: Someone is aggressive and not drab if and only if he is not impossible.\n",
                "First-Order-Logic Question": "Wicked(joseph) ::: Joseph is wicked."
            },
            "diff": [
                {
                    "raw": "(∀x (¬x)) → ((¬BroadMinded(cyril) ∧ Aggressive(ansel))) ::: If there is nobody who is not, then Cyril is not broad-minded and Ansel is aggressive.",
                    "gram": "¬(¬BroadMinded(x))→((¬Aggressive(x))) ::: If there is nobody who is not, then Cyril is not broad-minded and Ansel is aggressive."
                }
            ],
            "answer": "B",
            "grammar_answer": "B",
            "backup_answer": "B"
        },
        {
            "id": 780,
            "raw_prog": {
                "First-Order-Logic Rules": "Octagonal(owen) ::: Owen is octagonal.\n¬Sour(molly) ::: Molly is not sour.\n¬Significant(owen) ::: Owen is not significant.\n¬Wild(tristan) ::: Tristan is not wild.\nSignificant(luther) ::: Luther is significant.\n¬Wild(adam) ::: Adam is not wild.\n¬Wonderful(adam) ::: Adam is not wonderful.\nSour(morgan) ::: Morgan is sour.\nSour(tristan) ::: Tristan is sour.\nSour(godwin) ::: Godwin is sour.\nWonderful(owen) ::: Owen is wonderful.\n¬Wild(molly) ::: Molly is not wild.\n(∀x (Putrid(x) ∧ ¬Sour(x))) ↔ (∀x (Octagonal(x) ∧ ¬Wonderful(x))) ::: Someone is putrid and not sour if and only if he is octagonal and not wonderful.\n(¬∃x (¬Significant(x))) → (Significant(owen)) ::: If there is nobody who is not significant, then Owen is significant.\n(∀x (Significant(x))) ↔ (∀x (¬Wonderful(x))) ::: Someone is significant if and only if he is not wonderful.\n(∃x (¬Significant(x))) → ((¬Putrid(godwin) ∧ Wild(molly))) ::: If there is at least one people who is not significant, then Godwin is not putrid and Molly is wild.\n(∀x (Wonderful(x) ∨ Sour(x))) → (∀x (Wild(x))) ::: If someone is wonderful or he is sour, then he is wild.\n((Putrid(owen))) → ((¬Octagonal(molly) ∧ ¬Wonderful(adam))) ::: Owen being putrid implies that Molly is not octagonal and Adam is not wonderful.\n(∀x (¬Sour(x))) → (∀x (¬Significant(x))) ::: All not sour people are not significant.\n(∀x (¬Significant(x))) → ((Wonderful(godwin) ∧ ¬Octagonal(luther))) ::: If everyone is not significant, then Godwin is wonderful and Luther is not octagonal.\n(∀x (Wild(x))) → (∀x (Wonderful(x))) ::: If someone is wild, then he is wonderful.\n(∃x (Wild(x))) → ((Octagonal(godwin) ∧ Sour(morgan))) ::: If there is someone who is wild, then Godwin is octagonal and Morgan is sour.\n(∀x (¬Wonderful(x) ∧ ¬Putrid(x))) ↔ (∀x (Wild(x))) ::: Someone is not wonderful and not putrid if and only if he is wild.\n((Sour(molly) ∧ ¬Wild(molly))) → (¬Wonderful(owen)) ::: It can be concluded that Owen is not wonderful once knowing that Molly is sour and Molly is not wild.\n",
                "First-Order-Logic Question": "¬Wonderful(luther) ::: Luther is not wonderful."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "Octagonal(owen) ::: Owen is octagonal.\n¬Sour(molly) ::: Molly is not sour.\n¬Significant(owen) ::: Owen is not significant.\n¬Wild(tristan) ::: Tristan is not wild.\nSignificant(luther) ::: Luther is significant.\n¬Wild(adam) ::: Adam is not wild.\n¬Wonderful(adam) ::: Adam is not wonderful.\nSour(morgan) ::: Morgan is sour.\nSour(tristan) ::: Tristan is sour.\nSour(godwin) ::: Godwin is sour.\nWonderful(owen) ::: Owen is wonderful.\n¬Wild(molly) ::: Molly is not wild.\n(∀x (Putrid(x) ∧ ¬Sour(x))) ↔ (∀x (Octagonal(x) ∧ ¬Wonderful(x))) ::: Someone is putrid and not sour if and only if he is octagonal and not wonderful.\n¬∃x(¬Significant(x))→Significant(x) ::: If there is nobody who is not significant, then Owen is significant.\n(∀x (Significant(x))) ↔ (∀x (¬Wonderful(x))) ::: Someone is significant if and only if he is not wonderful.\n(∃x (¬Significant(x))) → ((¬Putrid(godwin) ∧ Wild(molly))) ::: If there is at least one people who is not significant, then Godwin is not putrid and Molly is wild.\n(∀x (Wonderful(x) ∨ Sour(x))) → (∀x (Wild(x))) ::: If someone is wonderful or he is sour, then he is wild.\n((Putrid(owen))) → ((¬Octagonal(molly) ∧ ¬Wonderful(adam))) ::: Owen being putrid implies that Molly is not octagonal and Adam is not wonderful.\n(∀x (¬Sour(x))) → (∀x (¬Significant(x))) ::: All not sour people are not significant.\n(∀x (¬Significant(x))) → ((Wonderful(godwin) ∧ ¬Octagonal(luther))) ::: If everyone is not significant, then Godwin is wonderful and Luther is not octagonal.\n(∀x (Wild(x))) → (∀x (Wonderful(x))) ::: If someone is wild, then he is wonderful.\n(∃x (Wild(x))) → ((Octagonal(godwin) ∧ Sour(morgan))) ::: If there is someone who is wild, then Godwin is octagonal and Morgan is sour.\n(∀x (¬Wonderful(x) ∧ ¬Putrid(x))) ↔ (∀x (Wild(x))) ::: Someone is not wonderful and not putrid if and only if he is wild.\n((Sour(molly) ∧ ¬Wild(molly))) → (¬Wonderful(owen)) ::: It can be concluded that Owen is not wonderful once knowing that Molly is sour and Molly is not wild.\n",
                "First-Order-Logic Question": "¬Wonderful(luther) ::: Luther is not wonderful."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬Significant(x))) → (Significant(owen)) ::: If there is nobody who is not significant, then Owen is significant.",
                    "gram": "¬∃x(¬Significant(x))→Significant(x) ::: If there is nobody who is not significant, then Owen is significant."
                }
            ],
            "answer": "A",
            "grammar_answer": "A",
            "backup_answer": "A"
        },
        {
            "id": 781,
            "raw_prog": {
                "First-Order-Logic Rules": [
                    "Octagonal(owen) ::: Owen is octagonal.",
                    "¬Sour(molly) ::: Molly is not sour.",
                    "¬Significant(owen) ::: Owen is not significant.",
                    "¬Wild(tristan) ::: Tristan is not wild.",
                    "Significant(luther) ::: Luther is significant.",
                    "¬Wild(adam) ::: Adam is not wild.",
                    "¬Wonderful(adam) ::: Adam is not wonderful.",
                    "Sour(morgan) ::: Morgan is sour.",
                    "Sour(tristan) ::: Tristan is sour.",
                    "Sour(godwin) ::: Godwin is sour.",
                    "Wonderful(owen) ::: Owen is wonderful.",
                    "¬Wild(molly) ::: Molly is not wild.",
                    "(∀x (Putrid(x) ∧ ¬Sour(x))) ↔ (∀x (Octagonal(x) ∧ ¬Wonderful(x))) ::: Someone is putrid and not sour if and only if he is octagonal and not wonderful.",
                    "(¬∃x (¬Significant(x))) → (Significant(owen)) ::: If there is nobody who is not significant, then Owen is significant.",
                    "(∀x (Significant(x))) ↔ (∀x (¬Wonderful(x))) ::: Someone is significant if and only if he is not wonderful.",
                    "(∃x (¬Significant(x))) → ((¬Putrid(godwin) ∧ Wild(molly))) ::: If there is at least one people who is not significant, then Godwin is not putrid and Molly is wild.",
                    "(∀x (Wonderful(x) ∨ Sour(x))) → (∀x (Wild(x))) ::: If someone is wonderful or he is sour, then he is wild.",
                    "(Putrid(owen)) → ((¬Octagonal(molly) ∧ ¬Wonderful(adam))) ::: Owen being putrid implies that Molly is not octagonal and Adam is not wonderful.",
                    "(∀x (¬Sour(x))) → (∀x (¬Significant(x))) ::: All not sour people are not significant.",
                    "(∀x (¬Significant(x))) → ((Wonderful(godwin) ∧ ¬Octagonal(luther))) ::: If everyone is not significant, then Godwin is wonderful and Luther is not octagonal.",
                    "(∀x (Wild(x))) → (∀x (Wonderful(x))) ::: If someone is wild, then he is wonderful.",
                    "(∃x (Wild(x))) → ((Octagonal(godwin) ∧ Sour(morgan))) ::: If there is someone who is wild, then Godwin is octagonal and Morgan is sour.",
                    "(∀x (¬Wonderful(x) ∧ ¬Putrid(x))) ↔ (∀x (Wild(x))) ::: Someone is not wonderful and not putrid if and only if he is wild.",
                    "((Sour(molly) ∧ ¬Wild(molly))) → (¬Wonderful(owen)) ::: It can be concluded that Owen is not wonderful once knowing that Molly is sour and Molly is not wild."
                ],
                "First-Order-Logic Question": "¬Wonderful(adam) ::: Adam is not wonderful."
            },
            "gram_prog": {
                "First-Order-Logic Rules": [
                    "Octagonal(owen) ::: Owen is octagonal.",
                    "¬Sour(molly) ::: Molly is not sour.",
                    "¬Significant(owen) ::: Owen is not significant.",
                    "¬Wild(tristan) ::: Tristan is not wild.",
                    "Significant(luther) ::: Luther is significant.",
                    "¬Wild(adam) ::: Adam is not wild.",
                    "¬Wonderful(adam) ::: Adam is not wonderful.",
                    "Sour(morgan) ::: Morgan is sour.",
                    "Sour(tristan) ::: Tristan is sour.",
                    "Sour(godwin) ::: Godwin is sour.",
                    "Wonderful(owen) ::: Owen is wonderful.",
                    "¬Wild(molly) ::: Molly is not wild.",
                    "(∀x (Putrid(x) ∧ ¬Sour(x))) ↔ (∀x (Octagonal(x) ∧ ¬Wonderful(x))) ::: Someone is putrid and not sour if and only if he is octagonal and not wonderful.",
                    "¬∃x(¬Significant(x))→Significant(x) ::: If there is nobody who is not significant, then Owen is significant.",
                    "(∀x (Significant(x))) ↔ (∀x (¬Wonderful(x))) ::: Someone is significant if and only if he is not wonderful.",
                    "(∃x (¬Significant(x))) → ((¬Putrid(godwin) ∧ Wild(molly))) ::: If there is at least one people who is not significant, then Godwin is not putrid and Molly is wild.",
                    "(∀x (Wonderful(x) ∨ Sour(x))) → (∀x (Wild(x))) ::: If someone is wonderful or he is sour, then he is wild.",
                    "(Putrid(owen)) → ((¬Octagonal(molly) ∧ ¬Wonderful(adam))) ::: Owen being putrid implies that Molly is not octagonal and Adam is not wonderful.",
                    "(∀x (¬Sour(x))) → (∀x (¬Significant(x))) ::: All not sour people are not significant.",
                    "(∀x (¬Significant(x))) → ((Wonderful(godwin) ∧ ¬Octagonal(luther))) ::: If everyone is not significant, then Godwin is wonderful and Luther is not octagonal.",
                    "(∀x (Wild(x))) → (∀x (Wonderful(x))) ::: If someone is wild, then he is wonderful.",
                    "(∃x (Wild(x))) → ((Octagonal(godwin) ∧ Sour(morgan))) ::: If there is someone who is wild, then Godwin is octagonal and Morgan is sour.",
                    "(∀x (¬Wonderful(x) ∧ ¬Putrid(x))) ↔ (∀x (Wild(x))) ::: Someone is not wonderful and not putrid if and only if he is wild.",
                    "((Sour(molly) ∧ ¬Wild(molly))) → (¬Wonderful(owen)) ::: It can be concluded that Owen is not wonderful once knowing that Molly is sour and Molly is not wild."
                ],
                "First-Order-Logic Question": "¬Wonderful(adam) ::: Adam is not wonderful."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬Significant(x))) → (Significant(owen)) ::: If there is nobody who is not significant, then Owen is significant.",
                    "gram": "¬∃x(¬Significant(x))→Significant(x) ::: If there is nobody who is not significant, then Owen is significant."
                }
            ],
            "answer": "A",
            "grammar_answer": "A",
            "backup_answer": "A"
        },
        {
            "id": 782,
            "raw_prog": {
                "First-Order-Logic Rules": "Octagonal(owen) ::: Owen is octagonal.\n¬Sour(molly) ::: Molly is not sour.\n¬Significant(owen) ::: Owen is not significant.\n¬Wild(tristan) ::: Tristan is not wild.\nSignificant(luther) ::: Luther is significant.\n¬Wild(adam) ::: Adam is not wild.\n¬Wonderful(adam) ::: Adam is not wonderful.\nSour(morgan) ::: Morgan is sour.\nSour(tristan) ::: Tristan is sour.\nSour(godwin) ::: Godwin is sour.\nWonderful(owen) ::: Owen is wonderful.\n¬Wild(molly) ::: Molly is not wild.\n(∀x (Putrid(x) ∧ ¬Sour(x))) ↔ (∀x (Octagonal(x) ∧ ¬Wonderful(x))) ::: Someone is putrid and not sour if and only if he is octagonal and not wonderful.\n(¬∃x (¬x)) → (Significant(owen)) ::: If there is nobody who is not, then Owen is significant.\n(∀x (Significant(x))) ↔ (∀x (¬Wonderful(x))) ::: Someone is significant if and only if he is not wonderful.\n(∃x (¬Significant(x))) → ((¬Putrid(godwin) ∧ Wild(molly))) ::: If there is at least one people who is not significant, then Godwin is not putrid and Molly is wild.\n(∀x (Wonderful(x) ∨ Sour(x))) → (∀x (Wild(x))) ::: If someone is wonderful or he is sour, then he is wild.\n((Putrid(owen))) → ((¬Octagonal(molly) ∧ ¬Wonderful(adam))) ::: Owen being putrid implies that Molly is not octagonal and Adam is not wonderful.\n(∀x (¬Sour(x))) → (∀x (¬Significant(x))) ::: All not sour people are not significant.\n(∀x (¬Significant(x))) → ((Wonderful(godwin) ∧ ¬Octagonal(luther))) ::: If everyone is not significant, then Godwin is wonderful and Luther is not octagonal.\n(∀x (Wild(x))) → (∀x (Wonderful(x))) ::: If someone is wild, then he is wonderful.\n(∃x (Wild(x))) → ((Octagonal(godwin) ∧ Sour(morgan))) ::: If there is someone who is wild, then Godwin is octagonal and Morgan is sour.\n(∀x (¬Wonderful(x) ∧ ¬Putrid(x))) ↔ (∀x (Wild(x))) ::: Someone is not wonderful and not putrid if and only if he is wild.\n((Sour(molly) ∧ ¬Wild(molly))) → ((¬Wonderful(owen))) ::: It can be concluded that Owen is not wonderful once knowing that Molly is sour and Molly is not wild.\n",
                "First-Order-Logic Question": "Wild(morgan) ::: Morgan is wild."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "Octagonal(owen) ::: Owen is octagonal.\n¬Sour(molly) ::: Molly is not sour.\n¬Significant(owen) ::: Owen is not significant.\n¬Wild(tristan) ::: Tristan is not wild.\nSignificant(luther) ::: Luther is significant.\n¬Wild(adam) ::: Adam is not wild.\n¬Wonderful(adam) ::: Adam is not wonderful.\nSour(morgan) ::: Morgan is sour.\nSour(tristan) ::: Tristan is sour.\nSour(godwin) ::: Godwin is sour.\nWonderful(owen) ::: Owen is wonderful.\n¬Wild(molly) ::: Molly is not wild.\n(∀x (Putrid(x) ∧ ¬Sour(x))) ↔ (∀x (Octagonal(x) ∧ ¬Wonderful(x))) ::: Someone is putrid and not sour if and only if he is octagonal and not wonderful.\n¬∃x(¬(¬(Octagonal(x)))) ::: If there is nobody who is not, then Owen is significant.\n(∀x (Significant(x))) ↔ (∀x (¬Wonderful(x))) ::: Someone is significant if and only if he is not wonderful.\n(∃x (¬Significant(x))) → ((¬Putrid(godwin) ∧ Wild(molly))) ::: If there is at least one people who is not significant, then Godwin is not putrid and Molly is wild.\n(∀x (Wonderful(x) ∨ Sour(x))) → (∀x (Wild(x))) ::: If someone is wonderful or he is sour, then he is wild.\n((Putrid(owen))) → ((¬Octagonal(molly) ∧ ¬Wonderful(adam))) ::: Owen being putrid implies that Molly is not octagonal and Adam is not wonderful.\n(∀x (¬Sour(x))) → (∀x (¬Significant(x))) ::: All not sour people are not significant.\n(∀x (¬Significant(x))) → ((Wonderful(godwin) ∧ ¬Octagonal(luther))) ::: If everyone is not significant, then Godwin is wonderful and Luther is not octagonal.\n(∀x (Wild(x))) → (∀x (Wonderful(x))) ::: If someone is wild, then he is wonderful.\n(∃x (Wild(x))) → ((Octagonal(godwin) ∧ Sour(morgan))) ::: If there is someone who is wild, then Godwin is octagonal and Morgan is sour.\n(∀x (¬Wonderful(x) ∧ ¬Putrid(x))) ↔ (∀x (Wild(x))) ::: Someone is not wonderful and not putrid if and only if he is wild.\n((Sour(molly) ∧ ¬Wild(molly))) → ((¬Wonderful(owen))) ::: It can be concluded that Owen is not wonderful once knowing that Molly is sour and Molly is not wild.\n",
                "First-Order-Logic Question": "Wild(morgan) ::: Morgan is wild."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬x)) → (Significant(owen)) ::: If there is nobody who is not, then Owen is significant.",
                    "gram": "¬∃x(¬(¬(Octagonal(x)))) ::: If there is nobody who is not, then Owen is significant."
                }
            ],
            "answer": "A",
            "grammar_answer": "A",
            "backup_answer": "A"
        },
        {
            "id": 783,
            "raw_prog": {
                "First-Order-Logic Rules": "Octagonal(owen) ::: Owen is octagonal.\n¬Sour(molly) ::: Molly is not sour.\n¬Significant(owen) ::: Owen is not significant.\n¬Wild(tristan) ::: Tristan is not wild.\nSignificant(luther) ::: Luther is significant.\n¬Wild(adam) ::: Adam is not wild.\n¬Wonderful(adam) ::: Adam is not wonderful.\nSour(morgan) ::: Morgan is sour.\nSour(tristan) ::: Tristan is sour.\nSour(godwin) ::: Godwin is sour.\nWonderful(owen) ::: Owen is wonderful.\n¬Wild(molly) ::: Molly is not wild.\n(∀x (Putrid(x) ∧ ¬Sour(x))) ↔ (∀x (Octagonal(x) ∧ ¬Wonderful(x))) ::: Someone is putrid and not sour if and only if he is octagonal and not wonderful.\n(¬∃x (¬Significant(x))) → (Significant(owen)) ::: If there is nobody who is not significant, then Owen is significant.\n(∀x (Significant(x))) ↔ (∀x (¬Wonderful(x))) ::: Someone is significant if and only if he is not wonderful.\n(∃x (¬Significant(x))) → ((¬Putrid(godwin) ∧ Wild(molly))) ::: If there is at least one people who is not significant, then Godwin is not putrid and Molly is wild.\n(∀x (Wonderful(x) ∨ Sour(x))) → (∀x (Wild(x))) ::: If someone is wonderful or he is sour, then he is wild.\n((Putrid(owen))) → ((¬Octagonal(molly) ∧ ¬Wonderful(adam))) ::: Owen being putrid implies that Molly is not octagonal and Adam is not wonderful.\n(∀x (¬Sour(x))) → (∀x (¬Significant(x))) ::: All not sour people are not significant.\n(∀x (¬Significant(x))) → ((Wonderful(godwin) ∧ ¬Octagonal(luther))) ::: If everyone is not significant, then Godwin is wonderful and Luther is not octagonal.\n(∀x (Wild(x))) → (∀x (Wonderful(x))) ::: If someone is wild, then he is wonderful.\n(∃x (Wild(x))) → ((Octagonal(godwin) ∧ Sour(morgan))) ::: If there is someone who is wild, then Godwin is octagonal and Morgan is sour.\n(∀x (¬Wonderful(x) ∧ ¬Putrid(x))) ↔ (∀x (Wild(x))) ::: Someone is not wonderful and not putrid if and only if he is wild.\n((Sour(molly) ∧ ¬Wild(molly))) → (¬Wonderful(owen)) ::: It can be concluded that Owen is not wonderful once knowing that Molly is sour and Molly is not wild.\n",
                "First-Order-Logic Question": "¬Sour(luther) ::: Luther is not sour."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "Octagonal(owen) ::: Owen is octagonal.\n¬Sour(molly) ::: Molly is not sour.\n¬Significant(owen) ::: Owen is not significant.\n¬Wild(tristan) ::: Tristan is not wild.\nSignificant(luther) ::: Luther is significant.\n¬Wild(adam) ::: Adam is not wild.\n¬Wonderful(adam) ::: Adam is not wonderful.\nSour(morgan) ::: Morgan is sour.\nSour(tristan) ::: Tristan is sour.\nSour(godwin) ::: Godwin is sour.\nWonderful(owen) ::: Owen is wonderful.\n¬Wild(molly) ::: Molly is not wild.\n(∀x (Putrid(x) ∧ ¬Sour(x))) ↔ (∀x (Octagonal(x) ∧ ¬Wonderful(x))) ::: Someone is putrid and not sour if and only if he is octagonal and not wonderful.\n¬∃x(¬Significant(x))→Significant(x) ::: If there is nobody who is not significant, then Owen is significant.\n(∀x (Significant(x))) ↔ (∀x (¬Wonderful(x))) ::: Someone is significant if and only if he is not wonderful.\n(∃x (¬Significant(x))) → ((¬Putrid(godwin) ∧ Wild(molly))) ::: If there is at least one people who is not significant, then Godwin is not putrid and Molly is wild.\n(∀x (Wonderful(x) ∨ Sour(x))) → (∀x (Wild(x))) ::: If someone is wonderful or he is sour, then he is wild.\n((Putrid(owen))) → ((¬Octagonal(molly) ∧ ¬Wonderful(adam))) ::: Owen being putrid implies that Molly is not octagonal and Adam is not wonderful.\n(∀x (¬Sour(x))) → (∀x (¬Significant(x))) ::: All not sour people are not significant.\n(∀x (¬Significant(x))) → ((Wonderful(godwin) ∧ ¬Octagonal(luther))) ::: If everyone is not significant, then Godwin is wonderful and Luther is not octagonal.\n(∀x (Wild(x))) → (∀x (Wonderful(x))) ::: If someone is wild, then he is wonderful.\n(∃x (Wild(x))) → ((Octagonal(godwin) ∧ Sour(morgan))) ::: If there is someone who is wild, then Godwin is octagonal and Morgan is sour.\n(∀x (¬Wonderful(x) ∧ ¬Putrid(x))) ↔ (∀x (Wild(x))) ::: Someone is not wonderful and not putrid if and only if he is wild.\n((Sour(molly) ∧ ¬Wild(molly))) → (¬Wonderful(owen)) ::: It can be concluded that Owen is not wonderful once knowing that Molly is sour and Molly is not wild.\n",
                "First-Order-Logic Question": "¬Sour(luther) ::: Luther is not sour."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬Significant(x))) → (Significant(owen)) ::: If there is nobody who is not significant, then Owen is significant.",
                    "gram": "¬∃x(¬Significant(x))→Significant(x) ::: If there is nobody who is not significant, then Owen is significant."
                }
            ],
            "answer": "C",
            "grammar_answer": "A",
            "backup_answer": "B"
        },
        {
            "id": 784,
            "raw_prog": {
                "First-Order-Logic Rules": "Octagonal(owen) ::: Owen is octagonal.\n¬Sour(molly) ::: Molly is not sour.\n¬Significant(owen) ::: Owen is not significant.\n¬Wild(tristan) ::: Tristan is not wild.\nSignificant(luther) ::: Luther is significant.\n¬Wild(adam) ::: Adam is not wild.\n¬Wonderful(adam) ::: Adam is not wonderful.\nSour(morgan) ::: Morgan is sour.\nSour(tristan) ::: Tristan is sour.\nSour(godwin) ::: Godwin is sour.\nWonderful(owen) ::: Owen is wonderful.\n¬Wild(molly) ::: Molly is not wild.\n(∀x (Putrid(x) ∧ ¬Sour(x))) ↔ (∀x (Octagonal(x) ∧ ¬Wonderful(x))) ::: Someone is putrid and not sour if and only if he is octagonal and not wonderful.\n(¬∃x (¬Significant(x))) → (Significant(owen)) ::: If there is nobody who is not significant, then Owen is significant.\n(∀x (Significant(x))) ↔ (∀x (¬Wonderful(x))) ::: Someone is significant if and only if he is not wonderful.\n(∃x (¬Significant(x))) → ((¬Putrid(godwin) ∧ Wild(molly))) ::: If there is at least one people who is not significant, then Godwin is not putrid and Molly is wild.\n(∀x (Wonderful(x) ∨ Sour(x))) → (∀x (Wild(x))) ::: If someone is wonderful or he is sour, then he is wild.\n((Putrid(owen))) → ((¬Octagonal(molly) ∧ ¬Wonderful(adam))) ::: Owen being putrid implies that Molly is not octagonal and Adam is not wonderful.\n(∀x (¬Sour(x))) → (∀x (¬Significant(x))) ::: All not sour people are not significant.\n(∀x (¬Significant(x))) → ((Wonderful(godwin) ∧ ¬Octagonal(luther))) ::: If everyone is not significant, then Godwin is wonderful and Luther is not octagonal.\n(∀x (Wild(x))) → (∀x (Wonderful(x))) ::: If someone is wild, then he is wonderful.\n(∃x (Wild(x))) → ((Octagonal(godwin) ∧ Sour(morgan))) ::: If there is someone who is wild, then Godwin is octagonal and Morgan is sour.\n(∀x (¬Wonderful(x) ∧ ¬Putrid(x))) ↔ (∀x (Wild(x))) ::: Someone is not wonderful and not putrid if and only if he is wild.\n((Sour(molly) ∧ ¬Wild(molly))) → (¬Wonderful(owen)) ::: It can be concluded that Owen is not wonderful once knowing that Molly is sour and Molly is not wild.\n",
                "First-Order-Logic Question": "Sour(luther) ::: Luther is sour."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "Octagonal(owen) ::: Owen is octagonal.\n¬Sour(molly) ::: Molly is not sour.\n¬Significant(owen) ::: Owen is not significant.\n¬Wild(tristan) ::: Tristan is not wild.\nSignificant(luther) ::: Luther is significant.\n¬Wild(adam) ::: Adam is not wild.\n¬Wonderful(adam) ::: Adam is not wonderful.\nSour(morgan) ::: Morgan is sour.\nSour(tristan) ::: Tristan is sour.\nSour(godwin) ::: Godwin is sour.\nWonderful(owen) ::: Owen is wonderful.\n¬Wild(molly) ::: Molly is not wild.\n(∀x (Putrid(x) ∧ ¬Sour(x))) ↔ (∀x (Octagonal(x) ∧ ¬Wonderful(x))) ::: Someone is putrid and not sour if and only if he is octagonal and not wonderful.\n¬∃x(¬Significant(x))→Significant(x) ::: If there is nobody who is not significant, then Owen is significant.\n(∀x (Significant(x))) ↔ (∀x (¬Wonderful(x))) ::: Someone is significant if and only if he is not wonderful.\n(∃x (¬Significant(x))) → ((¬Putrid(godwin) ∧ Wild(molly))) ::: If there is at least one people who is not significant, then Godwin is not putrid and Molly is wild.\n(∀x (Wonderful(x) ∨ Sour(x))) → (∀x (Wild(x))) ::: If someone is wonderful or he is sour, then he is wild.\n((Putrid(owen))) → ((¬Octagonal(molly) ∧ ¬Wonderful(adam))) ::: Owen being putrid implies that Molly is not octagonal and Adam is not wonderful.\n(∀x (¬Sour(x))) → (∀x (¬Significant(x))) ::: All not sour people are not significant.\n(∀x (¬Significant(x))) → ((Wonderful(godwin) ∧ ¬Octagonal(luther))) ::: If everyone is not significant, then Godwin is wonderful and Luther is not octagonal.\n(∀x (Wild(x))) → (∀x (Wonderful(x))) ::: If someone is wild, then he is wonderful.\n(∃x (Wild(x))) → ((Octagonal(godwin) ∧ Sour(morgan))) ::: If there is someone who is wild, then Godwin is octagonal and Morgan is sour.\n(∀x (¬Wonderful(x) ∧ ¬Putrid(x))) ↔ (∀x (Wild(x))) ::: Someone is not wonderful and not putrid if and only if he is wild.\n((Sour(molly) ∧ ¬Wild(molly))) → (¬Wonderful(owen)) ::: It can be concluded that Owen is not wonderful once knowing that Molly is sour and Molly is not wild.\n",
                "First-Order-Logic Question": "Sour(luther) ::: Luther is sour."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬Significant(x))) → (Significant(owen)) ::: If there is nobody who is not significant, then Owen is significant.",
                    "gram": "¬∃x(¬Significant(x))→Significant(x) ::: If there is nobody who is not significant, then Owen is significant."
                }
            ],
            "answer": "C",
            "grammar_answer": "A",
            "backup_answer": "A"
        },
        {
            "id": 785,
            "raw_prog": {
                "First-Order-Logic Rules": "Octagonal(owen) ::: Owen is octagonal.\n¬Sour(molly) ::: Molly is not sour.\n¬Significant(owen) ::: Owen is not significant.\n¬Wild(tristan) ::: Tristan is not wild.\nSignificant(luther) ::: Luther is significant.\n¬Wild(adam) ::: Adam is not wild.\n¬Wonderful(adam) ::: Adam is not wonderful.\nSour(morgan) ::: Morgan is sour.\nSour(tristan) ::: Tristan is sour.\nSour(godwin) ::: Godwin is sour.\nWonderful(owen) ::: Owen is wonderful.\n¬Wild(molly) ::: Molly is not wild.\n(∀x (Putrid(x) ∧ ¬Sour(x))) ↔ (∀x (Octagonal(x) ∧ ¬Wonderful(x))) ::: Someone is putrid and not sour if and only if he is octagonal and not wonderful.\n(¬∃x (¬Significant(x))) → (Significant(owen)) ::: If there is nobody who is not significant, then Owen is significant.\n(∀x (Significant(x))) ↔ (∀x (¬Wonderful(x))) ::: Someone is significant if and only if he is not wonderful.\n(∃x (¬Significant(x))) → ((¬Putrid(godwin) ∧ Wild(molly))) ::: If there is at least one people who is not significant, then Godwin is not putrid and Molly is wild.\n(∀x (Wonderful(x) ∨ Sour(x))) → (∀x (Wild(x))) ::: If someone is wonderful or he is sour, then he is wild.\n((Putrid(owen))) → ((¬Octagonal(molly) ∧ ¬Wonderful(adam))) ::: Owen being putrid implies that Molly is not octagonal and Adam is not wonderful.\n(∀x (¬Sour(x))) → (∀x (¬Significant(x))) ::: All not sour people are not significant.\n(∀x (¬Significant(x))) → ((Wonderful(godwin) ∧ ¬Octagonal(luther))) ::: If everyone is not significant, then Godwin is wonderful and Luther is not octagonal.\n(∀x (Wild(x))) → (∀x (Wonderful(x))) ::: If someone is wild, then he is wonderful.\n(∃x (Wild(x))) → ((Octagonal(godwin) ∧ Sour(morgan))) ::: If there is someone who is wild, then Godwin is octagonal and Morgan is sour.\n(∀x (¬Wonderful(x) ∧ ¬Putrid(x))) ↔ (∀x (Wild(x))) ::: Someone is not wonderful and not putrid if and only if he is wild.\n((Sour(molly) ∧ ¬Wild(molly))) → (¬Wonderful(owen)) ::: It can be concluded that Owen is not wonderful once knowing that Molly is sour and Molly is not wild.\n",
                "First-Order-Logic Question": "¬Sour(morgan) ::: Morgan is not sour."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "Octagonal(owen) ::: Owen is octagonal.\n¬Sour(molly) ::: Molly is not sour.\n¬Significant(owen) ::: Owen is not significant.\n¬Wild(tristan) ::: Tristan is not wild.\nSignificant(luther) ::: Luther is significant.\n¬Wild(adam) ::: Adam is not wild.\n¬Wonderful(adam) ::: Adam is not wonderful.\nSour(morgan) ::: Morgan is sour.\nSour(tristan) ::: Tristan is sour.\nSour(godwin) ::: Godwin is sour.\nWonderful(owen) ::: Owen is wonderful.\n¬Wild(molly) ::: Molly is not wild.\n(∀x (Putrid(x) ∧ ¬Sour(x))) ↔ (∀x (Octagonal(x) ∧ ¬Wonderful(x))) ::: Someone is putrid and not sour if and only if he is octagonal and not wonderful.\n¬∃x(¬Significant(x))→Significant(x) ::: If there is nobody who is not significant, then Owen is significant.\n(∀x (Significant(x))) ↔ (∀x (¬Wonderful(x))) ::: Someone is significant if and only if he is not wonderful.\n(∃x (¬Significant(x))) → ((¬Putrid(godwin) ∧ Wild(molly))) ::: If there is at least one people who is not significant, then Godwin is not putrid and Molly is wild.\n(∀x (Wonderful(x) ∨ Sour(x))) → (∀x (Wild(x))) ::: If someone is wonderful or he is sour, then he is wild.\n((Putrid(owen))) → ((¬Octagonal(molly) ∧ ¬Wonderful(adam))) ::: Owen being putrid implies that Molly is not octagonal and Adam is not wonderful.\n(∀x (¬Sour(x))) → (∀x (¬Significant(x))) ::: All not sour people are not significant.\n(∀x (¬Significant(x))) → ((Wonderful(godwin) ∧ ¬Octagonal(luther))) ::: If everyone is not significant, then Godwin is wonderful and Luther is not octagonal.\n(∀x (Wild(x))) → (∀x (Wonderful(x))) ::: If someone is wild, then he is wonderful.\n(∃x (Wild(x))) → ((Octagonal(godwin) ∧ Sour(morgan))) ::: If there is someone who is wild, then Godwin is octagonal and Morgan is sour.\n(∀x (¬Wonderful(x) ∧ ¬Putrid(x))) ↔ (∀x (Wild(x))) ::: Someone is not wonderful and not putrid if and only if he is wild.\n((Sour(molly) ∧ ¬Wild(molly))) → (¬Wonderful(owen)) ::: It can be concluded that Owen is not wonderful once knowing that Molly is sour and Molly is not wild.\n",
                "First-Order-Logic Question": "¬Sour(morgan) ::: Morgan is not sour."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬Significant(x))) → (Significant(owen)) ::: If there is nobody who is not significant, then Owen is significant.",
                    "gram": "¬∃x(¬Significant(x))→Significant(x) ::: If there is nobody who is not significant, then Owen is significant."
                }
            ],
            "answer": "B",
            "grammar_answer": "A",
            "backup_answer": "B"
        },
        {
            "id": 786,
            "raw_prog": {
                "First-Order-Logic Rules": "Octagonal(owen) ::: Owen is octagonal.\n¬Sour(molly) ::: Molly is not sour.\n¬Significant(owen) ::: Owen is not significant.\n¬Wild(tristan) ::: Tristan is not wild.\nSignificant(luther) ::: Luther is significant.\n¬Wild(adam) ::: Adam is not wild.\n¬Wonderful(adam) ::: Adam is not wonderful.\nSour(morgan) ::: Morgan is sour.\nSour(tristan) ::: Tristan is sour.\nSour(godwin) ::: Godwin is sour.\nWonderful(owen) ::: Owen is wonderful.\n¬Wild(molly) ::: Molly is not wild.\n(∀x (Putrid(x) ∧ ¬Sour(x))) ↔ (∀x (Octagonal(x) ∧ ¬Wonderful(x))) ::: Someone is putrid and not sour if and only if he is octagonal and not wonderful.\n(¬∃x (¬Significant(x))) → (Significant(owen)) ::: If there is nobody who is not significant, then Owen is significant.\n(∀x (Significant(x))) ↔ (∀x (¬Wonderful(x))) ::: Someone is significant if and only if he is not wonderful.\n(∃x (¬Significant(x))) → ((¬Putrid(godwin) ∧ Wild(molly))) ::: If there is at least one people who is not significant, then Godwin is not putrid and Molly is wild.\n(∀x (Wonderful(x) ∨ Sour(x))) → (∀x (Wild(x))) ::: If someone is wonderful or he is sour, then he is wild.\n((Putrid(owen))) → ((¬Octagonal(molly) ∧ ¬Wonderful(adam))) ::: Owen being putrid implies that Molly is not octagonal and Adam is not wonderful.\n(∀x (¬Sour(x))) → (∀x (¬Significant(x))) ::: All not sour people are not significant.\n(∀x (¬Significant(x))) → ((Wonderful(godwin) ∧ ¬Octagonal(luther))) ::: If everyone is not significant, then Godwin is wonderful and Luther is not octagonal.\n(∀x (Wild(x))) → (∀x (Wonderful(x))) ::: If someone is wild, then he is wonderful.\n(∃x (Wild(x))) → ((Octagonal(godwin) ∧ Sour(morgan))) ::: If there is someone who is wild, then Godwin is octagonal and Morgan is sour.\n(∀x (¬Wonderful(x) ∧ ¬Putrid(x))) ↔ (∀x (Wild(x))) ::: Someone is not wonderful and not putrid if and only if he is wild.\n((Sour(molly) ∧ ¬Wild(molly))) → ((¬Wonderful(owen))) ::: It can be concluded that Owen is not wonderful once knowing that Molly is sour and Molly is not wild.\n",
                "First-Order-Logic Question": "¬Sour(adam) ::: Adam is not sour."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "Octagonal(owen) ::: Owen is octagonal.\n¬Sour(molly) ::: Molly is not sour.\n¬Significant(owen) ::: Owen is not significant.\n¬Wild(tristan) ::: Tristan is not wild.\nSignificant(luther) ::: Luther is significant.\n¬Wild(adam) ::: Adam is not wild.\n¬Wonderful(adam) ::: Adam is not wonderful.\nSour(morgan) ::: Morgan is sour.\nSour(tristan) ::: Tristan is sour.\nSour(godwin) ::: Godwin is sour.\nWonderful(owen) ::: Owen is wonderful.\n¬Wild(molly) ::: Molly is not wild.\n(∀x (Putrid(x) ∧ ¬Sour(x))) ↔ (∀x (Octagonal(x) ∧ ¬Wonderful(x))) ::: Someone is putrid and not sour if and only if he is octagonal and not wonderful.\n¬∃x(¬Significant(x))→Significant(x) ::: If there is nobody who is not significant, then Owen is significant.\n(∀x (Significant(x))) ↔ (∀x (¬Wonderful(x))) ::: Someone is significant if and only if he is not wonderful.\n(∃x (¬Significant(x))) → ((¬Putrid(godwin) ∧ Wild(molly))) ::: If there is at least one people who is not significant, then Godwin is not putrid and Molly is wild.\n(∀x (Wonderful(x) ∨ Sour(x))) → (∀x (Wild(x))) ::: If someone is wonderful or he is sour, then he is wild.\n((Putrid(owen))) → ((¬Octagonal(molly) ∧ ¬Wonderful(adam))) ::: Owen being putrid implies that Molly is not octagonal and Adam is not wonderful.\n(∀x (¬Sour(x))) → (∀x (¬Significant(x))) ::: All not sour people are not significant.\n(∀x (¬Significant(x))) → ((Wonderful(godwin) ∧ ¬Octagonal(luther))) ::: If everyone is not significant, then Godwin is wonderful and Luther is not octagonal.\n(∀x (Wild(x))) → (∀x (Wonderful(x))) ::: If someone is wild, then he is wonderful.\n(∃x (Wild(x))) → ((Octagonal(godwin) ∧ Sour(morgan))) ::: If there is someone who is wild, then Godwin is octagonal and Morgan is sour.\n(∀x (¬Wonderful(x) ∧ ¬Putrid(x))) ↔ (∀x (Wild(x))) ::: Someone is not wonderful and not putrid if and only if he is wild.\n((Sour(molly) ∧ ¬Wild(molly))) → ((¬Wonderful(owen))) ::: It can be concluded that Owen is not wonderful once knowing that Molly is sour and Molly is not wild.\n",
                "First-Order-Logic Question": "¬Sour(adam) ::: Adam is not sour."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬Significant(x))) → (Significant(owen)) ::: If there is nobody who is not significant, then Owen is significant.",
                    "gram": "¬∃x(¬Significant(x))→Significant(x) ::: If there is nobody who is not significant, then Owen is significant."
                }
            ],
            "answer": "C",
            "grammar_answer": "A",
            "backup_answer": "C"
        },
        {
            "id": 787,
            "raw_prog": {
                "First-Order-Logic Rules": "Octagonal(owen) ::: Owen is octagonal.\n¬Sour(molly) ::: Molly is not sour.\n¬Significant(owen) ::: Owen is not significant.\n¬Wild(tristan) ::: Tristan is not wild.\nSignificant(luther) ::: Luther is significant.\n¬Wild(adam) ::: Adam is not wild.\n¬Wonderful(adam) ::: Adam is not wonderful.\nSour(morgan) ::: Morgan is sour.\nSour(tristan) ::: Tristan is sour.\nSour(godwin) ::: Godwin is sour.\nWonderful(owen) ::: Owen is wonderful.\n¬Wild(molly) ::: Molly is not wild.\n(∀x (Putrid(x) ∧ ¬Sour(x))) ↔ (∀x (Octagonal(x) ∧ ¬Wonderful(x))) ::: Someone is putrid and not sour if and only if he is octagonal and not wonderful.\n(¬∃x (¬Significant(x))) → (Significant(owen)) ::: If there is nobody who is not significant, then Owen is significant.\n(∀x (Significant(x))) ↔ (∀x (¬Wonderful(x))) ::: Someone is significant if and only if he is not wonderful.\n(∃x (¬Significant(x))) → ((¬Putrid(godwin) ∧ Wild(molly))) ::: If there is at least one people who is not significant, then Godwin is not putrid and Molly is wild.\n(∀x (Wonderful(x) ∨ Sour(x))) → (∀x (Wild(x))) ::: If someone is wonderful or he is sour, then he is wild.\n((Putrid(owen))) → ((¬Octagonal(molly) ∧ ¬Wonderful(adam))) ::: Owen being putrid implies that Molly is not octagonal and Adam is not wonderful.\n(∀x (¬Sour(x))) → (∀x (¬Significant(x))) ::: All not sour people are not significant.\n(∀x (¬Significant(x))) → ((Wonderful(godwin) ∧ ¬Octagonal(luther))) ::: If everyone is not significant, then Godwin is wonderful and Luther is not octagonal.\n(∀x (Wild(x))) → (∀x (Wonderful(x))) ::: If someone is wild, then he is wonderful.\n(∃x (Wild(x))) → ((Octagonal(godwin) ∧ Sour(morgan))) ::: If there is someone who is wild, then Godwin is octagonal and Morgan is sour.\n(∀x (¬Wonderful(x) ∧ ¬Putrid(x))) ↔ (∀x (Wild(x))) ::: Someone is not wonderful and not putrid if and only if he is wild.\n((Sour(molly) ∧ ¬Wild(molly))) → (¬Wonderful(owen)) ::: It can be concluded that Owen is not wonderful once knowing that Molly is sour and Molly is not wild.\n",
                "First-Order-Logic Question": "Octagonal(morgan) ::: Morgan is octagonal."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "Octagonal(owen) ::: Owen is octagonal.\n¬Sour(molly) ::: Molly is not sour.\n¬Significant(owen) ::: Owen is not significant.\n¬Wild(tristan) ::: Tristan is not wild.\nSignificant(luther) ::: Luther is significant.\n¬Wild(adam) ::: Adam is not wild.\n¬Wonderful(adam) ::: Adam is not wonderful.\nSour(morgan) ::: Morgan is sour.\nSour(tristan) ::: Tristan is sour.\nSour(godwin) ::: Godwin is sour.\nWonderful(owen) ::: Owen is wonderful.\n¬Wild(molly) ::: Molly is not wild.\n(∀x (Putrid(x) ∧ ¬Sour(x))) ↔ (∀x (Octagonal(x) ∧ ¬Wonderful(x))) ::: Someone is putrid and not sour if and only if he is octagonal and not wonderful.\n¬∃x(¬Significant(x))→Significant(x) ::: If there is nobody who is not significant, then Owen is significant.\n(∀x (Significant(x))) ↔ (∀x (¬Wonderful(x))) ::: Someone is significant if and only if he is not wonderful.\n(∃x (¬Significant(x))) → ((¬Putrid(godwin) ∧ Wild(molly))) ::: If there is at least one people who is not significant, then Godwin is not putrid and Molly is wild.\n(∀x (Wonderful(x) ∨ Sour(x))) → (∀x (Wild(x))) ::: If someone is wonderful or he is sour, then he is wild.\n((Putrid(owen))) → ((¬Octagonal(molly) ∧ ¬Wonderful(adam))) ::: Owen being putrid implies that Molly is not octagonal and Adam is not wonderful.\n(∀x (¬Sour(x))) → (∀x (¬Significant(x))) ::: All not sour people are not significant.\n(∀x (¬Significant(x))) → ((Wonderful(godwin) ∧ ¬Octagonal(luther))) ::: If everyone is not significant, then Godwin is wonderful and Luther is not octagonal.\n(∀x (Wild(x))) → (∀x (Wonderful(x))) ::: If someone is wild, then he is wonderful.\n(∃x (Wild(x))) → ((Octagonal(godwin) ∧ Sour(morgan))) ::: If there is someone who is wild, then Godwin is octagonal and Morgan is sour.\n(∀x (¬Wonderful(x) ∧ ¬Putrid(x))) ↔ (∀x (Wild(x))) ::: Someone is not wonderful and not putrid if and only if he is wild.\n((Sour(molly) ∧ ¬Wild(molly))) → (¬Wonderful(owen)) ::: It can be concluded that Owen is not wonderful once knowing that Molly is sour and Molly is not wild.\n",
                "First-Order-Logic Question": "Octagonal(morgan) ::: Morgan is octagonal."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬Significant(x))) → (Significant(owen)) ::: If there is nobody who is not significant, then Owen is significant.",
                    "gram": "¬∃x(¬Significant(x))→Significant(x) ::: If there is nobody who is not significant, then Owen is significant."
                }
            ],
            "answer": "C",
            "grammar_answer": "A",
            "backup_answer": "C"
        },
        {
            "id": 788,
            "raw_prog": {
                "First-Order-Logic Rules": "Octagonal(owen) ::: Owen is octagonal.\n¬Sour(molly) ::: Molly is not sour.\n¬Significant(owen) ::: Owen is not significant.\n¬Wild(tristan) ::: Tristan is not wild.\nSignificant(luther) ::: Luther is significant.\n¬Wild(adam) ::: Adam is not wild.\n¬Wonderful(adam) ::: Adam is not wonderful.\nSour(morgan) ::: Morgan is sour.\nSour(tristan) ::: Tristan is sour.\nSour(godwin) ::: Godwin is sour.\nWonderful(owen) ::: Owen is wonderful.\n¬Wild(molly) ::: Molly is not wild.\n(∀x (Putrid(x) ∧ ¬Sour(x))) ↔ (∀x (Octagonal(x) ∧ ¬Wonderful(x))) ::: Someone is putrid and not sour if and only if he is octagonal and not wonderful.\n(¬∃x (¬x)) → (Significant(owen)) ::: If there is nobody who is not, then Owen is significant.\n(∀x (Significant(x))) ↔ (∀x (¬Wonderful(x))) ::: Someone is significant if and only if he is not wonderful.\n(∃x (¬Significant(x))) → ((¬Putrid(godwin) ∧ Wild(molly))) ::: If there is at least one people who is not significant, then Godwin is not putrid and Molly is wild.\n(∀x (Wonderful(x) ∨ Sour(x))) → (∀x (Wild(x))) ::: If someone is wonderful or he is sour, then he is wild.\n((Putrid(owen))) → ((¬Octagonal(molly) ∧ ¬Wonderful(adam))) ::: Owen being putrid implies that Molly is not octagonal and Adam is not wonderful.\n(∀x (¬Sour(x))) → (∀x (¬Significant(x))) ::: All not sour people are not significant.\n(∀x (¬Significant(x))) → ((Wonderful(godwin) ∧ ¬Octagonal(luther))) ::: If everyone is not significant, then Godwin is wonderful and Luther is not octagonal.\n(∀x (Wild(x))) → (∀x (Wonderful(x))) ::: If someone is wild, then he is wonderful.\n(∃x (Wild(x))) → ((Octagonal(godwin) ∧ Sour(morgan))) ::: If there is someone who is wild, then Godwin is octagonal and Morgan is sour.\n(∀x (¬Wonderful(x) ∧ ¬Putrid(x))) ↔ (∀x (Wild(x))) ::: Someone is not wonderful and not putrid if and only if he is wild.\n((Sour(molly) ∧ ¬Wild(molly))) → ((¬Wonderful(owen))) ::: It can be concluded that Owen is not wonderful once knowing that Molly is sour and Molly is not wild.\n",
                "First-Order-Logic Question": "Octagonal(tristan) ::: Tristan is octagonal."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "Octagonal(owen) ::: Owen is octagonal.\n¬Sour(molly) ::: Molly is not sour.\n¬Significant(owen) ::: Owen is not significant.\n¬Wild(tristan) ::: Tristan is not wild.\nSignificant(luther) ::: Luther is significant.\n¬Wild(adam) ::: Adam is not wild.\n¬Wonderful(adam) ::: Adam is not wonderful.\nSour(morgan) ::: Morgan is sour.\nSour(tristan) ::: Tristan is sour.\nSour(godwin) ::: Godwin is sour.\nWonderful(owen) ::: Owen is wonderful.\n¬Wild(molly) ::: Molly is not wild.\n(∀x (Putrid(x) ∧ ¬Sour(x))) ↔ (∀x (Octagonal(x) ∧ ¬Wonderful(x))) ::: Someone is putrid and not sour if and only if he is octagonal and not wonderful.\n¬∃x(¬(¬(Octagonal(x)))) ::: If there is nobody who is not, then Owen is significant.\n(∀x (Significant(x))) ↔ (∀x (¬Wonderful(x))) ::: Someone is significant if and only if he is not wonderful.\n(∃x (¬Significant(x))) → ((¬Putrid(godwin) ∧ Wild(molly))) ::: If there is at least one people who is not significant, then Godwin is not putrid and Molly is wild.\n(∀x (Wonderful(x) ∨ Sour(x))) → (∀x (Wild(x))) ::: If someone is wonderful or he is sour, then he is wild.\n((Putrid(owen))) → ((¬Octagonal(molly) ∧ ¬Wonderful(adam))) ::: Owen being putrid implies that Molly is not octagonal and Adam is not wonderful.\n(∀x (¬Sour(x))) → (∀x (¬Significant(x))) ::: All not sour people are not significant.\n(∀x (¬Significant(x))) → ((Wonderful(godwin) ∧ ¬Octagonal(luther))) ::: If everyone is not significant, then Godwin is wonderful and Luther is not octagonal.\n(∀x (Wild(x))) → (∀x (Wonderful(x))) ::: If someone is wild, then he is wonderful.\n(∃x (Wild(x))) → ((Octagonal(godwin) ∧ Sour(morgan))) ::: If there is someone who is wild, then Godwin is octagonal and Morgan is sour.\n(∀x (¬Wonderful(x) ∧ ¬Putrid(x))) ↔ (∀x (Wild(x))) ::: Someone is not wonderful and not putrid if and only if he is wild.\n((Sour(molly) ∧ ¬Wild(molly))) → ((¬Wonderful(owen))) ::: It can be concluded that Owen is not wonderful once knowing that Molly is sour and Molly is not wild.\n",
                "First-Order-Logic Question": "Octagonal(tristan) ::: Tristan is octagonal."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬x)) → (Significant(owen)) ::: If there is nobody who is not, then Owen is significant.",
                    "gram": "¬∃x(¬(¬(Octagonal(x)))) ::: If there is nobody who is not, then Owen is significant."
                }
            ],
            "answer": "C",
            "grammar_answer": "A",
            "backup_answer": "C"
        },
        {
            "id": 789,
            "raw_prog": {
                "First-Order-Logic Rules": "Octagonal(owen) ::: Owen is octagonal.\n¬Sour(molly) ::: Molly is not sour.\n¬Significant(owen) ::: Owen is not significant.\n¬Wild(tristan) ::: Tristan is not wild.\nSignificant(luther) ::: Luther is significant.\n¬Wild(adam) ::: Adam is not wild.\n¬Wonderful(adam) ::: Adam is not wonderful.\nSour(morgan) ::: Morgan is sour.\nSour(tristan) ::: Tristan is sour.\nSour(godwin) ::: Godwin is sour.\nWonderful(owen) ::: Owen is wonderful.\n¬Wild(molly) ::: Molly is not wild.\n(∀x (Putrid(x) ∧ ¬Sour(x))) ↔ (∀x (Octagonal(x) ∧ ¬Wonderful(x))) ::: Someone is putrid and not sour if and only if he is octagonal and not wonderful.\n(¬∃x (¬Significant(x))) → (Significant(owen)) ::: If there is nobody who is not significant, then Owen is significant.\n(∀x (Significant(x))) ↔ (∀x (¬Wonderful(x))) ::: Someone is significant if and only if he is not wonderful.\n(∃x (¬Significant(x))) → ((¬Putrid(godwin) ∧ Wild(molly))) ::: If there is at least one people who is not significant, then Godwin is not putrid and Molly is wild.\n((Wonderful(x) ∨ Sour(x))) → (Wild(x)) ::: If someone is wonderful or he is sour, then he is wild.\n((Putrid(owen))) → ((¬Octagonal(molly) ∧ ¬Wonderful(adam))) ::: Owen being putrid implies that Molly is not octagonal and Adam is not wonderful.\n(∀x (¬Sour(x))) → (∀x (¬Significant(x))) ::: All not sour people are not significant.\n(∀x (¬Significant(x))) → ((Wonderful(godwin) ∧ ¬Octagonal(luther))) ::: If everyone is not significant, then Godwin is wonderful and Luther is not octagonal.\n(∀x (Wild(x))) → (∀x (Wonderful(x))) ::: If someone is wild, then he is wonderful.\n(∃x (Wild(x))) → ((Octagonal(godwin) ∧ Sour(morgan))) ::: If there is someone who is wild, then Godwin is octagonal and Morgan is sour.\n(∀x (¬Wonderful(x) ∧ ¬Putrid(x))) ↔ (∀x (Wild(x))) ::: Someone is not wonderful and not putrid if and only if he is wild.\n((Sour(molly) ∧ ¬Wild(molly))) → (¬Wonderful(owen)) ::: It can be concluded that Owen is not wonderful once knowing that Molly is sour and Molly is not wild.\n",
                "First-Order-Logic Question": "¬Significant(morgan) ::: Morgan is not significant."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "Octagonal(owen) ::: Owen is octagonal.\n¬Sour(molly) ::: Molly is not sour.\n¬Significant(owen) ::: Owen is not significant.\n¬Wild(tristan) ::: Tristan is not wild.\nSignificant(luther) ::: Luther is significant.\n¬Wild(adam) ::: Adam is not wild.\n¬Wonderful(adam) ::: Adam is not wonderful.\nSour(morgan) ::: Morgan is sour.\nSour(tristan) ::: Tristan is sour.\nSour(godwin) ::: Godwin is sour.\nWonderful(owen) ::: Owen is wonderful.\n¬Wild(molly) ::: Molly is not wild.\n(∀x (Putrid(x) ∧ ¬Sour(x))) ↔ (∀x (Octagonal(x) ∧ ¬Wonderful(x))) ::: Someone is putrid and not sour if and only if he is octagonal and not wonderful.\n¬∃x(¬Significant(x))→Significant(x) ::: If there is nobody who is not significant, then Owen is significant.\n(∀x (Significant(x))) ↔ (∀x (¬Wonderful(x))) ::: Someone is significant if and only if he is not wonderful.\n(∃x (¬Significant(x))) → ((¬Putrid(godwin) ∧ Wild(molly))) ::: If there is at least one people who is not significant, then Godwin is not putrid and Molly is wild.\n((Wonderful(x) ∨ Sour(x))) → (Wild(x)) ::: If someone is wonderful or he is sour, then he is wild.\n((Putrid(owen))) → ((¬Octagonal(molly) ∧ ¬Wonderful(adam))) ::: Owen being putrid implies that Molly is not octagonal and Adam is not wonderful.\n(∀x (¬Sour(x))) → (∀x (¬Significant(x))) ::: All not sour people are not significant.\n(∀x (¬Significant(x))) → ((Wonderful(godwin) ∧ ¬Octagonal(luther))) ::: If everyone is not significant, then Godwin is wonderful and Luther is not octagonal.\n(∀x (Wild(x))) → (∀x (Wonderful(x))) ::: If someone is wild, then he is wonderful.\n(∃x (Wild(x))) → ((Octagonal(godwin) ∧ Sour(morgan))) ::: If there is someone who is wild, then Godwin is octagonal and Morgan is sour.\n(∀x (¬Wonderful(x) ∧ ¬Putrid(x))) ↔ (∀x (Wild(x))) ::: Someone is not wonderful and not putrid if and only if he is wild.\n((Sour(molly) ∧ ¬Wild(molly))) → (¬Wonderful(owen)) ::: It can be concluded that Owen is not wonderful once knowing that Molly is sour and Molly is not wild.\n",
                "First-Order-Logic Question": "¬Significant(morgan) ::: Morgan is not significant."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬Significant(x))) → (Significant(owen)) ::: If there is nobody who is not significant, then Owen is significant.",
                    "gram": "¬∃x(¬Significant(x))→Significant(x) ::: If there is nobody who is not significant, then Owen is significant."
                }
            ],
            "answer": "B",
            "grammar_answer": "A",
            "backup_answer": "C"
        },
        {
            "id": 790,
            "raw_prog": {
                "First-Order-Logic Rules": [
                    "Octagonal(owen) ::: Owen is octagonal.",
                    "¬Sour(molly) ::: Molly is not sour.",
                    "¬Significant(owen) ::: Owen is not significant.",
                    "¬Wild(tristan) ::: Tristan is not wild.",
                    "Significant(luther) ::: Luther is significant.",
                    "¬Wild(adam) ::: Adam is not wild.",
                    "¬Wonderful(adam) ::: Adam is not wonderful.",
                    "Sour(morgan) ::: Morgan is sour.",
                    "Sour(tristan) ::: Tristan is sour.",
                    "Sour(godwin) ::: Godwin is sour.",
                    "Wonderful(owen) ::: Owen is wonderful.",
                    "¬Wild(molly) ::: Molly is not wild.",
                    "(∀x (Putrid(x) ∧ ¬Sour(x))) ↔ (∀x (Octagonal(x) ∧ ¬Wonderful(x))) ::: Someone is putrid and not sour if and only if he is octagonal and not wonderful.",
                    "(¬∃x (¬Significant(x))) → (Significant(owen)) ::: If there is nobody who is not significant, then Owen is significant.",
                    "(∀x (Significant(x))) ↔ (∀x (¬Wonderful(x))) ::: Someone is significant if and only if he is not wonderful.",
                    "(∃x (¬Significant(x))) → ((¬Putrid(godwin) ∧ Wild(molly))) ::: If there is at least one people who is not significant, then Godwin is not putrid and Molly is wild.",
                    "(∀x (Wonderful(x) ∨ Sour(x))) → (∀x (Wild(x))) ::: If someone is wonderful or he is sour, then he is wild.",
                    "(Putrid(owen)) → ((¬Octagonal(molly) ∧ ¬Wonderful(adam))) ::: Owen being putrid implies that Molly is not octagonal and Adam is not wonderful.",
                    "(∀x (¬Sour(x))) → (∀x (¬Significant(x))) ::: All not sour people are not significant.",
                    "(∀x (¬Significant(x))) → ((Wonderful(godwin) ∧ ¬Octagonal(luther))) ::: If everyone is not significant, then Godwin is wonderful and Luther is not octagonal.",
                    "(∀x (Wild(x))) → (∀x (Wonderful(x))) ::: If someone is wild, then he is wonderful.",
                    "(∃x (Wild(x))) → ((Octagonal(godwin) ∧ Sour(morgan))) ::: If there is someone who is wild, then Godwin is octagonal and Morgan is sour.",
                    "(∀x (¬Wonderful(x) ∧ ¬Putrid(x))) ↔ (∀x (Wild(x))) ::: Someone is not wonderful and not putrid if and only if he is wild.",
                    "((Sour(molly) ∧ ¬Wild(molly))) → (¬Wonderful(owen)) ::: It can be concluded that Owen is not wonderful once knowing that Molly is sour and Molly is not wild."
                ],
                "First-Order-Logic Question": "¬Octagonal(owen) ::: Owen is not octagonal."
            },
            "gram_prog": {
                "First-Order-Logic Rules": [
                    "Octagonal(owen) ::: Owen is octagonal.",
                    "¬Sour(molly) ::: Molly is not sour.",
                    "¬Significant(owen) ::: Owen is not significant.",
                    "¬Wild(tristan) ::: Tristan is not wild.",
                    "Significant(luther) ::: Luther is significant.",
                    "¬Wild(adam) ::: Adam is not wild.",
                    "¬Wonderful(adam) ::: Adam is not wonderful.",
                    "Sour(morgan) ::: Morgan is sour.",
                    "Sour(tristan) ::: Tristan is sour.",
                    "Sour(godwin) ::: Godwin is sour.",
                    "Wonderful(owen) ::: Owen is wonderful.",
                    "¬Wild(molly) ::: Molly is not wild.",
                    "(∀x (Putrid(x) ∧ ¬Sour(x))) ↔ (∀x (Octagonal(x) ∧ ¬Wonderful(x))) ::: Someone is putrid and not sour if and only if he is octagonal and not wonderful.",
                    "¬∃x(¬Significant(x))→Significant(x) ::: If there is nobody who is not significant, then Owen is significant.",
                    "(∀x (Significant(x))) ↔ (∀x (¬Wonderful(x))) ::: Someone is significant if and only if he is not wonderful.",
                    "(∃x (¬Significant(x))) → ((¬Putrid(godwin) ∧ Wild(molly))) ::: If there is at least one people who is not significant, then Godwin is not putrid and Molly is wild.",
                    "(∀x (Wonderful(x) ∨ Sour(x))) → (∀x (Wild(x))) ::: If someone is wonderful or he is sour, then he is wild.",
                    "(Putrid(owen)) → ((¬Octagonal(molly) ∧ ¬Wonderful(adam))) ::: Owen being putrid implies that Molly is not octagonal and Adam is not wonderful.",
                    "(∀x (¬Sour(x))) → (∀x (¬Significant(x))) ::: All not sour people are not significant.",
                    "(∀x (¬Significant(x))) → ((Wonderful(godwin) ∧ ¬Octagonal(luther))) ::: If everyone is not significant, then Godwin is wonderful and Luther is not octagonal.",
                    "(∀x (Wild(x))) → (∀x (Wonderful(x))) ::: If someone is wild, then he is wonderful.",
                    "(∃x (Wild(x))) → ((Octagonal(godwin) ∧ Sour(morgan))) ::: If there is someone who is wild, then Godwin is octagonal and Morgan is sour.",
                    "(∀x (¬Wonderful(x) ∧ ¬Putrid(x))) ↔ (∀x (Wild(x))) ::: Someone is not wonderful and not putrid if and only if he is wild.",
                    "((Sour(molly) ∧ ¬Wild(molly))) → (¬Wonderful(owen)) ::: It can be concluded that Owen is not wonderful once knowing that Molly is sour and Molly is not wild."
                ],
                "First-Order-Logic Question": "¬Octagonal(owen) ::: Owen is not octagonal."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬Significant(x))) → (Significant(owen)) ::: If there is nobody who is not significant, then Owen is significant.",
                    "gram": "¬∃x(¬Significant(x))→Significant(x) ::: If there is nobody who is not significant, then Owen is significant."
                }
            ],
            "answer": "B",
            "grammar_answer": "A",
            "backup_answer": "B"
        },
        {
            "id": 791,
            "raw_prog": {
                "First-Order-Logic Rules": "Octagonal(owen) ::: Owen is octagonal.\n¬Sour(molly) ::: Molly is not sour.\n¬Significant(owen) ::: Owen is not significant.\n¬Wild(tristan) ::: Tristan is not wild.\nSignificant(luther) ::: Luther is significant.\n¬Wild(adam) ::: Adam is not wild.\n¬Wonderful(adam) ::: Adam is not wonderful.\nSour(morgan) ::: Morgan is sour.\nSour(tristan) ::: Tristan is sour.\nSour(godwin) ::: Godwin is sour.\nWonderful(owen) ::: Owen is wonderful.\n¬Wild(molly) ::: Molly is not wild.\n(∀x (Putrid(x) ∧ ¬Sour(x))) ↔ (∀x (Octagonal(x) ∧ ¬Wonderful(x))) ::: Someone is putrid and not sour if and only if he is octagonal and not wonderful.\n(¬∃x (¬x)) → (Significant(owen)) ::: If there is nobody who is not, then Owen is significant.\n(∀x (Significant(x))) ↔ (∀x (¬Wonderful(x))) ::: Someone is significant if and only if he is not wonderful.\n(∃x (¬Significant(x))) → ((¬Putrid(godwin) ∧ Wild(molly))) ::: If there is at least one people who is not significant, then Godwin is not putrid and Molly is wild.\n(∀x (Wonderful(x) ∨ Sour(x))) → (∀x (Wild(x))) ::: If someone is wonderful or he is sour, then he is wild.\n((Putrid(owen))) → ((¬Octagonal(molly) ∧ ¬Wonderful(adam))) ::: Owen being putrid implies that Molly is not octagonal and Adam is not wonderful.\n(∀x (¬Sour(x))) → (∀x (¬Significant(x))) ::: All not sour people are not significant.\n(∀x (¬Significant(x))) → ((Wonderful(godwin) ∧ ¬Octagonal(luther))) ::: If everyone is not significant, then Godwin is wonderful and Luther is not octagonal.\n(∀x (Wild(x))) → (∀x (Wonderful(x))) ::: If someone is wild, then he is wonderful.\n(∃x (Wild(x))) → ((Octagonal(godwin) ∧ Sour(morgan))) ::: If there is someone who is wild, then Godwin is octagonal and Morgan is sour.\n(∀x (¬Wonderful(x) ∧ ¬Putrid(x))) ↔ (∀x (Wild(x))) ::: Someone is not wonderful and not putrid if and only if he is wild.\n((Sour(molly) ∧ ¬Wild(molly))) → ((¬Wonderful(owen))) ::: It can be concluded that Owen is not wonderful once knowing that Molly is sour and Molly is not wild.\n",
                "First-Order-Logic Question": "Putrid(tristan) ::: Tristan is putrid."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "Octagonal(owen) ::: Owen is octagonal.\n¬Sour(molly) ::: Molly is not sour.\n¬Significant(owen) ::: Owen is not significant.\n¬Wild(tristan) ::: Tristan is not wild.\nSignificant(luther) ::: Luther is significant.\n¬Wild(adam) ::: Adam is not wild.\n¬Wonderful(adam) ::: Adam is not wonderful.\nSour(morgan) ::: Morgan is sour.\nSour(tristan) ::: Tristan is sour.\nSour(godwin) ::: Godwin is sour.\nWonderful(owen) ::: Owen is wonderful.\n¬Wild(molly) ::: Molly is not wild.\n(∀x (Putrid(x) ∧ ¬Sour(x))) ↔ (∀x (Octagonal(x) ∧ ¬Wonderful(x))) ::: Someone is putrid and not sour if and only if he is octagonal and not wonderful.\n¬∃x(¬(¬(Octagonal(x)))) ::: If there is nobody who is not, then Owen is significant.\n(∀x (Significant(x))) ↔ (∀x (¬Wonderful(x))) ::: Someone is significant if and only if he is not wonderful.\n(∃x (¬Significant(x))) → ((¬Putrid(godwin) ∧ Wild(molly))) ::: If there is at least one people who is not significant, then Godwin is not putrid and Molly is wild.\n(∀x (Wonderful(x) ∨ Sour(x))) → (∀x (Wild(x))) ::: If someone is wonderful or he is sour, then he is wild.\n((Putrid(owen))) → ((¬Octagonal(molly) ∧ ¬Wonderful(adam))) ::: Owen being putrid implies that Molly is not octagonal and Adam is not wonderful.\n(∀x (¬Sour(x))) → (∀x (¬Significant(x))) ::: All not sour people are not significant.\n(∀x (¬Significant(x))) → ((Wonderful(godwin) ∧ ¬Octagonal(luther))) ::: If everyone is not significant, then Godwin is wonderful and Luther is not octagonal.\n(∀x (Wild(x))) → (∀x (Wonderful(x))) ::: If someone is wild, then he is wonderful.\n(∃x (Wild(x))) → ((Octagonal(godwin) ∧ Sour(morgan))) ::: If there is someone who is wild, then Godwin is octagonal and Morgan is sour.\n(∀x (¬Wonderful(x) ∧ ¬Putrid(x))) ↔ (∀x (Wild(x))) ::: Someone is not wonderful and not putrid if and only if he is wild.\n((Sour(molly) ∧ ¬Wild(molly))) → ((¬Wonderful(owen))) ::: It can be concluded that Owen is not wonderful once knowing that Molly is sour and Molly is not wild.\n",
                "First-Order-Logic Question": "Putrid(tristan) ::: Tristan is putrid."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬x)) → (Significant(owen)) ::: If there is nobody who is not, then Owen is significant.",
                    "gram": "¬∃x(¬(¬(Octagonal(x)))) ::: If there is nobody who is not, then Owen is significant."
                }
            ],
            "answer": "B",
            "grammar_answer": "A",
            "backup_answer": "C"
        },
        {
            "id": 792,
            "raw_prog": {
                "First-Order-Logic Rules": "Octagonal(owen) ::: Owen is octagonal.\n¬Sour(molly) ::: Molly is not sour.\n¬Significant(owen) ::: Owen is not significant.\n¬Wild(tristan) ::: Tristan is not wild.\nSignificant(luther) ::: Luther is significant.\n¬Wild(adam) ::: Adam is not wild.\n¬Wonderful(adam) ::: Adam is not wonderful.\nSour(morgan) ::: Morgan is sour.\nSour(tristan) ::: Tristan is sour.\nSour(godwin) ::: Godwin is sour.\nWonderful(owen) ::: Owen is wonderful.\n¬Wild(molly) ::: Molly is not wild.\n(∀x (Putrid(x) ∧ ¬Sour(x))) ↔ (∀x (Octagonal(x) ∧ ¬Wonderful(x))) ::: Someone is putrid and not sour if and only if he is octagonal and not wonderful.\n(¬∃x (¬Significant(x))) → (Significant(owen)) ::: If there is nobody who is not significant, then Owen is significant.\n(∀x (Significant(x))) ↔ (∀x (¬Wonderful(x))) ::: Someone is significant if and only if he is not wonderful.\n(∃x (¬Significant(x))) → ((¬Putrid(godwin) ∧ Wild(molly))) ::: If there is at least one people who is not significant, then Godwin is not putrid and Molly is wild.\n((Wonderful(x) ∨ Sour(x))) → (Wild(x)) ::: If someone is wonderful or he is sour, then he is wild.\n((Putrid(owen))) → ((¬Octagonal(molly) ∧ ¬Wonderful(adam))) ::: Owen being putrid implies that Molly is not octagonal and Adam is not wonderful.\n(∀x (¬Sour(x))) → (∀x (¬Significant(x))) ::: All not sour people are not significant.\n(∀x (¬Significant(x))) → ((Wonderful(godwin) ∧ ¬Octagonal(luther))) ::: If everyone is not significant, then Godwin is wonderful and Luther is not octagonal.\n(∀x (Wild(x))) → (∀x (Wonderful(x))) ::: If someone is wild, then he is wonderful.\n(∃x (Wild(x))) → ((Octagonal(godwin) ∧ Sour(morgan))) ::: If there is someone who is wild, then Godwin is octagonal and Morgan is sour.\n(∀x (¬Wonderful(x) ∧ ¬Putrid(x))) ↔ (∀x (Wild(x))) ::: Someone is not wonderful and not putrid if and only if he is wild.\n((Sour(molly) ∧ ¬Wild(molly))) → (¬Wonderful(owen)) ::: It can be concluded that Owen is not wonderful once knowing that Molly is sour and Molly is not wild.\n",
                "First-Order-Logic Question": "¬Sour(owen) ::: Owen is not sour."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "Octagonal(owen) ::: Owen is octagonal.\n¬Sour(molly) ::: Molly is not sour.\n¬Significant(owen) ::: Owen is not significant.\n¬Wild(tristan) ::: Tristan is not wild.\nSignificant(luther) ::: Luther is significant.\n¬Wild(adam) ::: Adam is not wild.\n¬Wonderful(adam) ::: Adam is not wonderful.\nSour(morgan) ::: Morgan is sour.\nSour(tristan) ::: Tristan is sour.\nSour(godwin) ::: Godwin is sour.\nWonderful(owen) ::: Owen is wonderful.\n¬Wild(molly) ::: Molly is not wild.\n(∀x (Putrid(x) ∧ ¬Sour(x))) ↔ (∀x (Octagonal(x) ∧ ¬Wonderful(x))) ::: Someone is putrid and not sour if and only if he is octagonal and not wonderful.\n¬∃x(¬Significant(x))→Significant(x) ::: If there is nobody who is not significant, then Owen is significant.\n(∀x (Significant(x))) ↔ (∀x (¬Wonderful(x))) ::: Someone is significant if and only if he is not wonderful.\n(∃x (¬Significant(x))) → ((¬Putrid(godwin) ∧ Wild(molly))) ::: If there is at least one people who is not significant, then Godwin is not putrid and Molly is wild.\n((Wonderful(x) ∨ Sour(x))) → (Wild(x)) ::: If someone is wonderful or he is sour, then he is wild.\n((Putrid(owen))) → ((¬Octagonal(molly) ∧ ¬Wonderful(adam))) ::: Owen being putrid implies that Molly is not octagonal and Adam is not wonderful.\n(∀x (¬Sour(x))) → (∀x (¬Significant(x))) ::: All not sour people are not significant.\n(∀x (¬Significant(x))) → ((Wonderful(godwin) ∧ ¬Octagonal(luther))) ::: If everyone is not significant, then Godwin is wonderful and Luther is not octagonal.\n(∀x (Wild(x))) → (∀x (Wonderful(x))) ::: If someone is wild, then he is wonderful.\n(∃x (Wild(x))) → ((Octagonal(godwin) ∧ Sour(morgan))) ::: If there is someone who is wild, then Godwin is octagonal and Morgan is sour.\n(∀x (¬Wonderful(x) ∧ ¬Putrid(x))) ↔ (∀x (Wild(x))) ::: Someone is not wonderful and not putrid if and only if he is wild.\n((Sour(molly) ∧ ¬Wild(molly))) → (¬Wonderful(owen)) ::: It can be concluded that Owen is not wonderful once knowing that Molly is sour and Molly is not wild.\n",
                "First-Order-Logic Question": "¬Sour(owen) ::: Owen is not sour."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬Significant(x))) → (Significant(owen)) ::: If there is nobody who is not significant, then Owen is significant.",
                    "gram": "¬∃x(¬Significant(x))→Significant(x) ::: If there is nobody who is not significant, then Owen is significant."
                }
            ],
            "answer": "A",
            "grammar_answer": "A",
            "backup_answer": "B"
        },
        {
            "id": 793,
            "raw_prog": {
                "First-Order-Logic Rules": "Octagonal(owen) ::: Owen is octagonal.\n¬Sour(molly) ::: Molly is not sour.\n¬Significant(owen) ::: Owen is not significant.\n¬Wild(tristan) ::: Tristan is not wild.\nSignificant(luther) ::: Luther is significant.\n¬Wild(adam) ::: Adam is not wild.\n¬Wonderful(adam) ::: Adam is not wonderful.\nSour(morgan) ::: Morgan is sour.\nSour(tristan) ::: Tristan is sour.\nSour(godwin) ::: Godwin is sour.\nWonderful(owen) ::: Owen is wonderful.\n¬Wild(molly) ::: Molly is not wild.\n(∀x (Putrid(x) ∧ ¬Sour(x))) ↔ (∀x (Octagonal(x) ∧ ¬Wonderful(x))) ::: Someone is putrid and not sour if and only if he is octagonal and not wonderful.\n(¬∃x (¬Significant(x))) → (Significant(owen)) ::: If there is nobody who is not significant, then Owen is significant.\n(∀x (Significant(x))) ↔ (∀x (¬Wonderful(x))) ::: Someone is significant if and only if he is not wonderful.\n(∃x (¬Significant(x))) → ((¬Putrid(godwin) ∧ Wild(molly))) ::: If there is at least one people who is not significant, then Godwin is not putrid and Molly is wild.\n(∀x (Wonderful(x) ∨ Sour(x))) → (∀x (Wild(x))) ::: If someone is wonderful or he is sour, then he is wild.\n((Putrid(owen))) → ((¬Octagonal(molly) ∧ ¬Wonderful(adam))) ::: Owen being putrid implies that Molly is not octagonal and Adam is not wonderful.\n(∀x (¬Sour(x))) → (∀x (¬Significant(x))) ::: All not sour people are not significant.\n(∀x (¬Significant(x))) → ((Wonderful(godwin) ∧ ¬Octagonal(luther))) ::: If everyone is not significant, then Godwin is wonderful and Luther is not octagonal.\n(∀x (Wild(x))) → (∀x (Wonderful(x))) ::: If someone is wild, then he is wonderful.\n(∃x (Wild(x))) → ((Octagonal(godwin) ∧ Sour(morgan))) ::: If there is someone who is wild, then Godwin is octagonal and Morgan is sour.\n(∀x (¬Wonderful(x) ∧ ¬Putrid(x))) ↔ (∀x (Wild(x))) ::: Someone is not wonderful and not putrid if and only if he is wild.\n((Sour(molly) ∧ ¬Wild(molly))) → (¬Wonderful(owen)) ::: It can be concluded that Owen is not wonderful once knowing that Molly is sour and Molly is not wild.\n",
                "First-Order-Logic Question": "¬Sour(tristan) ::: Tristan is not sour."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "Octagonal(owen) ::: Owen is octagonal.\n¬Sour(molly) ::: Molly is not sour.\n¬Significant(owen) ::: Owen is not significant.\n¬Wild(tristan) ::: Tristan is not wild.\nSignificant(luther) ::: Luther is significant.\n¬Wild(adam) ::: Adam is not wild.\n¬Wonderful(adam) ::: Adam is not wonderful.\nSour(morgan) ::: Morgan is sour.\nSour(tristan) ::: Tristan is sour.\nSour(godwin) ::: Godwin is sour.\nWonderful(owen) ::: Owen is wonderful.\n¬Wild(molly) ::: Molly is not wild.\n(∀x (Putrid(x) ∧ ¬Sour(x))) ↔ (∀x (Octagonal(x) ∧ ¬Wonderful(x))) ::: Someone is putrid and not sour if and only if he is octagonal and not wonderful.\n¬∃x(¬Significant(x))→Significant(x) ::: If there is nobody who is not significant, then Owen is significant.\n(∀x (Significant(x))) ↔ (∀x (¬Wonderful(x))) ::: Someone is significant if and only if he is not wonderful.\n(∃x (¬Significant(x))) → ((¬Putrid(godwin) ∧ Wild(molly))) ::: If there is at least one people who is not significant, then Godwin is not putrid and Molly is wild.\n(∀x (Wonderful(x) ∨ Sour(x))) → (∀x (Wild(x))) ::: If someone is wonderful or he is sour, then he is wild.\n((Putrid(owen))) → ((¬Octagonal(molly) ∧ ¬Wonderful(adam))) ::: Owen being putrid implies that Molly is not octagonal and Adam is not wonderful.\n(∀x (¬Sour(x))) → (∀x (¬Significant(x))) ::: All not sour people are not significant.\n(∀x (¬Significant(x))) → ((Wonderful(godwin) ∧ ¬Octagonal(luther))) ::: If everyone is not significant, then Godwin is wonderful and Luther is not octagonal.\n(∀x (Wild(x))) → (∀x (Wonderful(x))) ::: If someone is wild, then he is wonderful.\n(∃x (Wild(x))) → ((Octagonal(godwin) ∧ Sour(morgan))) ::: If there is someone who is wild, then Godwin is octagonal and Morgan is sour.\n(∀x (¬Wonderful(x) ∧ ¬Putrid(x))) ↔ (∀x (Wild(x))) ::: Someone is not wonderful and not putrid if and only if he is wild.\n((Sour(molly) ∧ ¬Wild(molly))) → (¬Wonderful(owen)) ::: It can be concluded that Owen is not wonderful once knowing that Molly is sour and Molly is not wild.\n",
                "First-Order-Logic Question": "¬Sour(tristan) ::: Tristan is not sour."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬Significant(x))) → (Significant(owen)) ::: If there is nobody who is not significant, then Owen is significant.",
                    "gram": "¬∃x(¬Significant(x))→Significant(x) ::: If there is nobody who is not significant, then Owen is significant."
                }
            ],
            "answer": "B",
            "grammar_answer": "A",
            "backup_answer": "B"
        },
        {
            "id": 794,
            "raw_prog": {
                "First-Order-Logic Rules": [
                    "Octagonal(owen) ::: Owen is octagonal.",
                    "¬Sour(molly) ::: Molly is not sour.",
                    "¬Significant(owen) ::: Owen is not significant.",
                    "¬Wild(tristan) ::: Tristan is not wild.",
                    "Significant(luther) ::: Luther is significant.",
                    "¬Wild(adam) ::: Adam is not wild.",
                    "¬Wonderful(adam) ::: Adam is not wonderful.",
                    "Sour(morgan) ::: Morgan is sour.",
                    "Sour(tristan) ::: Tristan is sour.",
                    "Sour(godwin) ::: Godwin is sour.",
                    "Wonderful(owen) ::: Owen is wonderful.",
                    "¬Wild(molly) ::: Molly is not wild.",
                    "(∀x (Putrid(x) ∧ ¬Sour(x))) ↔ (∀x (Octagonal(x) ∧ ¬Wonderful(x))) ::: Someone is putrid and not sour if and only if he is octagonal and not wonderful.",
                    "(¬∃x (¬x)) → (Significant(owen)) ::: If there is nobody who is not, then Owen is significant.",
                    "(∀x (Significant(x))) ↔ (∀x (¬Wonderful(x))) ::: Someone is significant if and only if he is not wonderful.",
                    "(∃x (¬Significant(x))) → ((¬Putrid(godwin) ∧ Wild(molly))) ::: If there is at least one people who is not significant, then Godwin is not putrid and Molly is wild.",
                    "(∀x (Wonderful(x) ∨ Sour(x))) → (∀x (Wild(x))) ::: If someone is wonderful or he is sour, then he is wild.",
                    "(Putrid(owen)) → ((¬Octagonal(molly) ∧ ¬Wonderful(adam))) ::: Owen being putrid implies that Molly is not octagonal and Adam is not wonderful.",
                    "(∀x (¬Sour(x))) → (∀x (¬Significant(x))) ::: All not sour people are not significant.",
                    "(∀x (¬Significant(x))) → ((Wonderful(godwin) ∧ ¬Octagonal(luther))) ::: If everyone is not significant, then Godwin is wonderful and Luther is not octagonal.",
                    "(∀x (Wild(x))) → (∀x (Wonderful(x))) ::: If someone is wild, then he is wonderful.",
                    "(∃x (Wild(x))) → ((Octagonal(godwin) ∧ Sour(morgan))) ::: If there is someone who is wild, then Godwin is octagonal and Morgan is sour.",
                    "(∀x (¬Wonderful(x) ∧ ¬Putrid(x))) ↔ (∀x (Wild(x))) ::: Someone is not wonderful and not putrid if and only if he is wild.",
                    "((Sour(molly) ∧ ¬Wild(molly))) → (¬Wonderful(owen)) ::: It can be concluded that Owen is not wonderful once knowing that Molly is sour and Molly is not wild."
                ],
                "First-Order-Logic Question": "Octagonal(godwin) ::: Godwin is octagonal."
            },
            "gram_prog": {
                "First-Order-Logic Rules": [
                    "Octagonal(owen) ::: Owen is octagonal.",
                    "¬Sour(molly) ::: Molly is not sour.",
                    "¬Significant(owen) ::: Owen is not significant.",
                    "¬Wild(tristan) ::: Tristan is not wild.",
                    "Significant(luther) ::: Luther is significant.",
                    "¬Wild(adam) ::: Adam is not wild.",
                    "¬Wonderful(adam) ::: Adam is not wonderful.",
                    "Sour(morgan) ::: Morgan is sour.",
                    "Sour(tristan) ::: Tristan is sour.",
                    "Sour(godwin) ::: Godwin is sour.",
                    "Wonderful(owen) ::: Owen is wonderful.",
                    "¬Wild(molly) ::: Molly is not wild.",
                    "(∀x (Putrid(x) ∧ ¬Sour(x))) ↔ (∀x (Octagonal(x) ∧ ¬Wonderful(x))) ::: Someone is putrid and not sour if and only if he is octagonal and not wonderful.",
                    "¬∃x(¬(¬(Octagonal(x)))) ::: If there is nobody who is not, then Owen is significant.",
                    "(∀x (Significant(x))) ↔ (∀x (¬Wonderful(x))) ::: Someone is significant if and only if he is not wonderful.",
                    "(∃x (¬Significant(x))) → ((¬Putrid(godwin) ∧ Wild(molly))) ::: If there is at least one people who is not significant, then Godwin is not putrid and Molly is wild.",
                    "(∀x (Wonderful(x) ∨ Sour(x))) → (∀x (Wild(x))) ::: If someone is wonderful or he is sour, then he is wild.",
                    "(Putrid(owen)) → ((¬Octagonal(molly) ∧ ¬Wonderful(adam))) ::: Owen being putrid implies that Molly is not octagonal and Adam is not wonderful.",
                    "(∀x (¬Sour(x))) → (∀x (¬Significant(x))) ::: All not sour people are not significant.",
                    "(∀x (¬Significant(x))) → ((Wonderful(godwin) ∧ ¬Octagonal(luther))) ::: If everyone is not significant, then Godwin is wonderful and Luther is not octagonal.",
                    "(∀x (Wild(x))) → (∀x (Wonderful(x))) ::: If someone is wild, then he is wonderful.",
                    "(∃x (Wild(x))) → ((Octagonal(godwin) ∧ Sour(morgan))) ::: If there is someone who is wild, then Godwin is octagonal and Morgan is sour.",
                    "(∀x (¬Wonderful(x) ∧ ¬Putrid(x))) ↔ (∀x (Wild(x))) ::: Someone is not wonderful and not putrid if and only if he is wild.",
                    "((Sour(molly) ∧ ¬Wild(molly))) → (¬Wonderful(owen)) ::: It can be concluded that Owen is not wonderful once knowing that Molly is sour and Molly is not wild."
                ],
                "First-Order-Logic Question": "Octagonal(godwin) ::: Godwin is octagonal."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬x)) → (Significant(owen)) ::: If there is nobody who is not, then Owen is significant.",
                    "gram": "¬∃x(¬(¬(Octagonal(x)))) ::: If there is nobody who is not, then Owen is significant."
                }
            ],
            "answer": "A",
            "grammar_answer": "A",
            "backup_answer": "C"
        },
        {
            "id": 1127,
            "raw_prog": {
                "First-Order-Logic Rules": "¬Different(brandi) ::: Brandi is not different.\nAlert(julie) ::: Julie is alert.\nLong(leroy) ::: Leroy is long.\n¬Poised(leroy) ::: Leroy is not poised.\nLong(julie) ::: Julie is long.\nPoised(tristan) ::: Tristan is poised.\n¬Faithful(cyril) ::: Cyril is not faithful.\n¬Different(tristan) ::: Tristan is not different.\n¬Different(cyril) ::: Cyril is not different.\nLong(cyril) ::: Cyril is long.\nLong(brandi) ::: Brandi is long.\nPoised(shane) ::: Shane is poised.\n(∀x (Faithful(x) ∨ ¬Poised(x))) → (∀x (¬Short(x))) ::: Someone who is either faithful or not poised is always not short.\n(∀x (¬Faithful(x))) ↔ (∀x (¬Different(x))) ::: If someone is not faithful, then he is not different, and vice versa.\n(∃x (Short(x) ∨ ¬Different(x))) → ((Alert(julie) ∧ Faithful(cyril))) ::: If there is at least one people who is either short or not different, then Julie is alert and Cyril is faithful.\n(∀x (Alert(x))) ↔ (∀x (Poised(x))) ::: Someone is alert if and only if he is poised.\n((¬Poised(julie) ∨ Different(tristan))) → ((Long(leroy))) ::: If Julie is not poised or Tristan is different, then Leroy is long.\n(∀x (Short(x))) ↔ (∀x (Faithful(x))) ::: If someone is short, then he is faithful, and vice versa.\n((Alert(brandi) ∨ Short(cyril))) → ((¬Poised(cyril))) ::: If Brandi is alert or Cyril is short, then Cyril is not poised.\n(∃x (Alert(x) ∨ ¬Poised(x))) → ((¬Long(shane))) ::: If there is at least one people who is alert or not poised, then Shane is not long.\n(∀x (¬Poised(x) ∧ ¬Short(x))) → (∀x (¬Alert(x))) ::: If someone is neither poised nor short, then he is not alert.\n(∀x (Alert(x))) → ((¬Different(neal) ∧ Faithful(julie))) ::: If everyone is alert, then Neal is not different and Julie is faithful.\n(∀x (¬Faithful(x))) → (∀x (Alert(x))) ::: If someone is not faithful, then he is alert.\n(∀x (x ∨ ¬Long(x) ∧ ¬Different(x))) → (∀x (Alert(x))) ::: If someone is he or not long is not different, then he is alert.\n",
                "First-Order-Logic Question": "Faithful(leroy) ::: Leroy is faithful."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "¬Different(brandi) ::: Brandi is not different.\nAlert(julie) ::: Julie is alert.\nLong(leroy) ::: Leroy is long.\n¬Poised(leroy) ::: Leroy is not poised.\nLong(julie) ::: Julie is long.\nPoised(tristan) ::: Tristan is poised.\n¬Faithful(cyril) ::: Cyril is not faithful.\n¬Different(tristan) ::: Tristan is not different.\n¬Different(cyril) ::: Cyril is not different.\nLong(cyril) ::: Cyril is long.\nLong(brandi) ::: Brandi is long.\nPoised(shane) ::: Shane is poised.\n(∀x (Faithful(x) ∨ ¬Poised(x))) → (∀x (¬Short(x))) ::: Someone who is either faithful or not poised is always not short.\n(∀x (¬Faithful(x))) ↔ (∀x (¬Different(x))) ::: If someone is not faithful, then he is not different, and vice versa.\n(∃x (Short(x) ∨ ¬Different(x))) → ((Alert(julie) ∧ Faithful(cyril))) ::: If there is at least one people who is either short or not different, then Julie is alert and Cyril is faithful.\n(∀x (Alert(x))) ↔ (∀x (Poised(x))) ::: Someone is alert if and only if he is poised.\n((¬Poised(julie) ∨ Different(tristan))) → ((Long(leroy))) ::: If Julie is not poised or Tristan is different, then Leroy is long.\n(∀x (Short(x))) ↔ (∀x (Faithful(x))) ::: If someone is short, then he is faithful, and vice versa.\n((Alert(brandi) ∨ Short(cyril))) → ((¬Poised(cyril))) ::: If Brandi is alert or Cyril is short, then Cyril is not poised.\n(∃x (Alert(x) ∨ ¬Poised(x))) → ((¬Long(shane))) ::: If there is at least one people who is alert or not poised, then Shane is not long.\n(∀x (¬Poised(x) ∧ ¬Short(x))) → (∀x (¬Alert(x))) ::: If someone is neither poised nor short, then he is not alert.\n(∀x (Alert(x))) → ((¬Different(neal) ∧ Faithful(julie))) ::: If everyone is alert, then Neal is not different and Julie is faithful.\n(∀x (¬Faithful(x))) → (∀x (Alert(x))) ::: If someone is not faithful, then he is alert.\n∀x((¬Long(x)∨¬Different(x))) ::: If someone is he or not long is not different, then he is alert.\n",
                "First-Order-Logic Question": "Faithful(leroy) ::: Leroy is faithful."
            },
            "diff": [
                {
                    "raw": "(∀x (x ∨ ¬Long(x) ∧ ¬Different(x))) → (∀x (Alert(x))) ::: If someone is he or not long is not different, then he is alert.",
                    "gram": "∀x((¬Long(x)∨¬Different(x))) ::: If someone is he or not long is not different, then he is alert."
                }
            ],
            "answer": "C",
            "grammar_answer": "A",
            "backup_answer": "C"
        },
        {
            "id": 1133,
            "raw_prog": {
                "First-Order-Logic Rules": "¬Different(brandi) ::: Brandi is not different.\nAlert(julie) ::: Julie is alert.\nLong(leroy) ::: Leroy is long.\n¬Poised(leroy) ::: Leroy is not poised.\nLong(julie) ::: Julie is long.\nPoised(tristan) ::: Tristan is poised.\n¬Faithful(cyril) ::: Cyril is not faithful.\n¬Different(tristan) ::: Tristan is not different.\n¬Different(cyril) ::: Cyril is not different.\nLong(cyril) ::: Cyril is long.\nLong(brandi) ::: Brandi is long.\nPoised(shane) ::: Shane is poised.\n(∀x (Faithful(x) ∨ ¬Poised(x))) → (∀x (¬Short(x))) ::: Someone who is either faithful or not poised is always not short.\n(∀x (¬Faithful(x))) ↔ (∀x (¬Different(x))) ::: If someone is not faithful, then he is not different, and vice versa.\n(∃x (Short(x) ∨ ¬Different(x))) → ((Alert(julie) ∧ Faithful(cyril))) ::: If there is at least one people who is either short or not different, then Julie is alert and Cyril is faithful.\n(∀x (Alert(x))) ↔ (∀x (Poised(x))) ::: Someone is alert if and only if he is poised.\n((¬Poised(julie) ∨ Different(tristan))) → ((Long(leroy))) ::: If Julie is not poised or Tristan is different, then Leroy is long.\n(∀x (Short(x))) ↔ (∀x (Faithful(x))) ::: If someone is short, then he is faithful, and vice versa.\n((Alert(brandi) ∨ Short(cyril))) → ((¬Poised(cyril))) ::: If Brandi is alert or Cyril is short, then Cyril is not poised.\n(∃x (Alert(x) ∨ ¬Poised(x))) → ((¬Long(shane))) ::: If there is at least one people who is alert or not poised, then Shane is not long.\n(∀x (¬Poised(x) ∧ ¬Short(x))) → (∀x (¬Alert(x))) ::: If someone is neither poised nor short, then he is not alert.\n(∀x (Alert(x))) → ((¬Different(neal) ∧ Faithful(julie))) ::: If everyone is alert, then Neal is not different and Julie is faithful.\n(∀x (¬Faithful(x))) → (∀x (Alert(x))) ::: If someone is not faithful, then he is alert.\n(∀x (x ∨ ¬Long(x) ∧ ¬Different(x))) → (∀x (Alert(x))) ::: If someone is he or not long is not different, then he is alert.\n",
                "First-Order-Logic Question": "¬Alert(leroy) ::: Leroy is not alert."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "¬Different(brandi) ::: Brandi is not different.\nAlert(julie) ::: Julie is alert.\nLong(leroy) ::: Leroy is long.\n¬Poised(leroy) ::: Leroy is not poised.\nLong(julie) ::: Julie is long.\nPoised(tristan) ::: Tristan is poised.\n¬Faithful(cyril) ::: Cyril is not faithful.\n¬Different(tristan) ::: Tristan is not different.\n¬Different(cyril) ::: Cyril is not different.\nLong(cyril) ::: Cyril is long.\nLong(brandi) ::: Brandi is long.\nPoised(shane) ::: Shane is poised.\n(∀x (Faithful(x) ∨ ¬Poised(x))) → (∀x (¬Short(x))) ::: Someone who is either faithful or not poised is always not short.\n(∀x (¬Faithful(x))) ↔ (∀x (¬Different(x))) ::: If someone is not faithful, then he is not different, and vice versa.\n(∃x (Short(x) ∨ ¬Different(x))) → ((Alert(julie) ∧ Faithful(cyril))) ::: If there is at least one people who is either short or not different, then Julie is alert and Cyril is faithful.\n(∀x (Alert(x))) ↔ (∀x (Poised(x))) ::: Someone is alert if and only if he is poised.\n((¬Poised(julie) ∨ Different(tristan))) → ((Long(leroy))) ::: If Julie is not poised or Tristan is different, then Leroy is long.\n(∀x (Short(x))) ↔ (∀x (Faithful(x))) ::: If someone is short, then he is faithful, and vice versa.\n((Alert(brandi) ∨ Short(cyril))) → ((¬Poised(cyril))) ::: If Brandi is alert or Cyril is short, then Cyril is not poised.\n(∃x (Alert(x) ∨ ¬Poised(x))) → ((¬Long(shane))) ::: If there is at least one people who is alert or not poised, then Shane is not long.\n(∀x (¬Poised(x) ∧ ¬Short(x))) → (∀x (¬Alert(x))) ::: If someone is neither poised nor short, then he is not alert.\n(∀x (Alert(x))) → ((¬Different(neal) ∧ Faithful(julie))) ::: If everyone is alert, then Neal is not different and Julie is faithful.\n(∀x (¬Faithful(x))) → (∀x (Alert(x))) ::: If someone is not faithful, then he is alert.\n∀x((¬Long(x)∨¬Different(x))) ::: If someone is he or not long is not different, then he is alert.\n",
                "First-Order-Logic Question": "¬Alert(leroy) ::: Leroy is not alert."
            },
            "diff": [
                {
                    "raw": "(∀x (x ∨ ¬Long(x) ∧ ¬Different(x))) → (∀x (Alert(x))) ::: If someone is he or not long is not different, then he is alert.",
                    "gram": "∀x((¬Long(x)∨¬Different(x))) ::: If someone is he or not long is not different, then he is alert."
                }
            ],
            "answer": "A",
            "grammar_answer": "A",
            "backup_answer": "A"
        },
        {
            "id": 1135,
            "raw_prog": {
                "First-Order-Logic Rules": "¬Different(brandi) ::: Brandi is not different.\nAlert(julie) ::: Julie is alert.\nLong(leroy) ::: Leroy is long.\n¬Poised(leroy) ::: Leroy is not poised.\nLong(julie) ::: Julie is long.\nPoised(tristan) ::: Tristan is poised.\n¬Faithful(cyril) ::: Cyril is not faithful.\n¬Different(tristan) ::: Tristan is not different.\n¬Different(cyril) ::: Cyril is not different.\nLong(cyril) ::: Cyril is long.\nLong(brandi) ::: Brandi is long.\nPoised(shane) ::: Shane is poised.\n(∀x (Faithful(x) ∨ ¬Poised(x))) → (∀x (¬Short(x))) ::: Someone who is either faithful or not poised is always not short.\n(∀x (¬Faithful(x))) ↔ (∀x (¬Different(x))) ::: If someone is not faithful, then he is not different, and vice versa.\n(∃x (Short(x) ∨ ¬Different(x))) → ((Alert(julie) ∧ Faithful(cyril))) ::: If there is at least one people who is either short or not different, then Julie is alert and Cyril is faithful.\n(∀x (Alert(x))) ↔ (∀x (Poised(x))) ::: Someone is alert if and only if he is poised.\n((¬Poised(julie) ∨ Different(tristan))) → ((Long(leroy))) ::: If Julie is not poised or Tristan is different, then Leroy is long.\n(∀x (Short(x))) ↔ (∀x (Faithful(x))) ::: If someone is short, then he is faithful, and vice versa.\n((Alert(brandi) ∨ Short(cyril))) → ((¬Poised(cyril))) ::: If Brandi is alert or Cyril is short, then Cyril is not poised.\n(∃x (Alert(x) ∨ ¬Poised(x))) → ((¬Long(shane))) ::: If there is at least one people who is alert or not poised, then Shane is not long.\n(∀x (¬Poised(x) ∧ ¬Short(x))) → (∀x (¬Alert(x))) ::: If someone is neither poised nor short, then he is not alert.\n(∀x (Alert(x))) → ((¬Different(neal) ∧ Faithful(julie))) ::: If everyone is alert, then Neal is not different and Julie is faithful.\n(∀x (¬Faithful(x))) → (∀x (Alert(x))) ::: If someone is not faithful, then he is alert.\n(∀x (x ∨ ¬Long(x) ∧ ¬Different(x))) → (∀x (Alert(x))) ::: If someone is he or not long is not different, then he is alert.\n",
                "First-Order-Logic Question": "Alert(shane) ::: Shane is alert."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "¬Different(brandi) ::: Brandi is not different.\nAlert(julie) ::: Julie is alert.\nLong(leroy) ::: Leroy is long.\n¬Poised(leroy) ::: Leroy is not poised.\nLong(julie) ::: Julie is long.\nPoised(tristan) ::: Tristan is poised.\n¬Faithful(cyril) ::: Cyril is not faithful.\n¬Different(tristan) ::: Tristan is not different.\n¬Different(cyril) ::: Cyril is not different.\nLong(cyril) ::: Cyril is long.\nLong(brandi) ::: Brandi is long.\nPoised(shane) ::: Shane is poised.\n(∀x (Faithful(x) ∨ ¬Poised(x))) → (∀x (¬Short(x))) ::: Someone who is either faithful or not poised is always not short.\n(∀x (¬Faithful(x))) ↔ (∀x (¬Different(x))) ::: If someone is not faithful, then he is not different, and vice versa.\n(∃x (Short(x) ∨ ¬Different(x))) → ((Alert(julie) ∧ Faithful(cyril))) ::: If there is at least one people who is either short or not different, then Julie is alert and Cyril is faithful.\n(∀x (Alert(x))) ↔ (∀x (Poised(x))) ::: Someone is alert if and only if he is poised.\n((¬Poised(julie) ∨ Different(tristan))) → ((Long(leroy))) ::: If Julie is not poised or Tristan is different, then Leroy is long.\n(∀x (Short(x))) ↔ (∀x (Faithful(x))) ::: If someone is short, then he is faithful, and vice versa.\n((Alert(brandi) ∨ Short(cyril))) → ((¬Poised(cyril))) ::: If Brandi is alert or Cyril is short, then Cyril is not poised.\n(∃x (Alert(x) ∨ ¬Poised(x))) → ((¬Long(shane))) ::: If there is at least one people who is alert or not poised, then Shane is not long.\n(∀x (¬Poised(x) ∧ ¬Short(x))) → (∀x (¬Alert(x))) ::: If someone is neither poised nor short, then he is not alert.\n(∀x (Alert(x))) → ((¬Different(neal) ∧ Faithful(julie))) ::: If everyone is alert, then Neal is not different and Julie is faithful.\n(∀x (¬Faithful(x))) → (∀x (Alert(x))) ::: If someone is not faithful, then he is alert.\n∀x((¬Long(x)∨¬Different(x))) ::: If someone is he or not long is not different, then he is alert.\n",
                "First-Order-Logic Question": "Alert(shane) ::: Shane is alert."
            },
            "diff": [
                {
                    "raw": "(∀x (x ∨ ¬Long(x) ∧ ¬Different(x))) → (∀x (Alert(x))) ::: If someone is he or not long is not different, then he is alert.",
                    "gram": "∀x((¬Long(x)∨¬Different(x))) ::: If someone is he or not long is not different, then he is alert."
                }
            ],
            "answer": "A",
            "grammar_answer": "A",
            "backup_answer": "A"
        },
        {
            "id": 1136,
            "raw_prog": {
                "First-Order-Logic Rules": "¬Different(brandi) ::: Brandi is not different.\nAlert(julie) ::: Julie is alert.\nLong(leroy) ::: Leroy is long.\n¬Poised(leroy) ::: Leroy is not poised.\nLong(julie) ::: Julie is long.\nPoised(tristan) ::: Tristan is poised.\n¬Faithful(cyril) ::: Cyril is not faithful.\n¬Different(tristan) ::: Tristan is not different.\n¬Different(cyril) ::: Cyril is not different.\nLong(cyril) ::: Cyril is long.\nLong(brandi) ::: Brandi is long.\nPoised(shane) ::: Shane is poised.\n(∀x (Faithful(x) ∨ ¬Poised(x))) → (∀x (¬Short(x))) ::: Someone who is either faithful or not poised is always not short.\n(∀x (¬Faithful(x))) ↔ (∀x (¬Different(x))) ::: If someone is not faithful, then he is not different, and vice versa.\n(∃x (Short(x) ∨ ¬Different(x))) → ((Alert(julie) ∧ Faithful(cyril))) ::: If there is at least one people who is either short or not different, then Julie is alert and Cyril is faithful.\n(∀x (Alert(x))) ↔ (∀x (Poised(x))) ::: Someone is alert if and only if he is poised.\n((¬Poised(julie) ∨ Different(tristan))) → ((Long(leroy))) ::: If Julie is not poised or Tristan is different, then Leroy is long.\n(∀x (Short(x))) ↔ (∀x (Faithful(x))) ::: If someone is short, then he is faithful, and vice versa.\n((Alert(brandi) ∨ Short(cyril))) → ((¬Poised(cyril))) ::: If Brandi is alert or Cyril is short, then Cyril is not poised.\n(∃x (Alert(x) ∨ ¬Poised(x))) → ((¬Long(shane))) ::: If there is at least one people who is alert or not poised, then Shane is not long.\n(∀x (¬Poised(x) ∧ ¬Short(x))) → (∀x (¬Alert(x))) ::: If someone is neither poised nor short, then he is not alert.\n(∀x (Alert(x))) → ((¬Different(neal) ∧ Faithful(julie))) ::: If everyone is alert, then Neal is not different and Julie is faithful.\n(∀x (¬Faithful(x))) → (∀x (Alert(x))) ::: If someone is not faithful, then he is alert.\n(∀x (x ∨ ¬Long(x) ∧ ¬Different(x))) → (∀x (Alert(x))) ::: If someone is he or not long is not different, then he is alert.\n",
                "First-Order-Logic Question": "Faithful(tristan) ::: Tristan is faithful."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "¬Different(brandi) ::: Brandi is not different.\nAlert(julie) ::: Julie is alert.\nLong(leroy) ::: Leroy is long.\n¬Poised(leroy) ::: Leroy is not poised.\nLong(julie) ::: Julie is long.\nPoised(tristan) ::: Tristan is poised.\n¬Faithful(cyril) ::: Cyril is not faithful.\n¬Different(tristan) ::: Tristan is not different.\n¬Different(cyril) ::: Cyril is not different.\nLong(cyril) ::: Cyril is long.\nLong(brandi) ::: Brandi is long.\nPoised(shane) ::: Shane is poised.\n(∀x (Faithful(x) ∨ ¬Poised(x))) → (∀x (¬Short(x))) ::: Someone who is either faithful or not poised is always not short.\n(∀x (¬Faithful(x))) ↔ (∀x (¬Different(x))) ::: If someone is not faithful, then he is not different, and vice versa.\n(∃x (Short(x) ∨ ¬Different(x))) → ((Alert(julie) ∧ Faithful(cyril))) ::: If there is at least one people who is either short or not different, then Julie is alert and Cyril is faithful.\n(∀x (Alert(x))) ↔ (∀x (Poised(x))) ::: Someone is alert if and only if he is poised.\n((¬Poised(julie) ∨ Different(tristan))) → ((Long(leroy))) ::: If Julie is not poised or Tristan is different, then Leroy is long.\n(∀x (Short(x))) ↔ (∀x (Faithful(x))) ::: If someone is short, then he is faithful, and vice versa.\n((Alert(brandi) ∨ Short(cyril))) → ((¬Poised(cyril))) ::: If Brandi is alert or Cyril is short, then Cyril is not poised.\n(∃x (Alert(x) ∨ ¬Poised(x))) → ((¬Long(shane))) ::: If there is at least one people who is alert or not poised, then Shane is not long.\n(∀x (¬Poised(x) ∧ ¬Short(x))) → (∀x (¬Alert(x))) ::: If someone is neither poised nor short, then he is not alert.\n(∀x (Alert(x))) → ((¬Different(neal) ∧ Faithful(julie))) ::: If everyone is alert, then Neal is not different and Julie is faithful.\n(∀x (¬Faithful(x))) → (∀x (Alert(x))) ::: If someone is not faithful, then he is alert.\n∀x((¬Long(x)∨¬Different(x))) ::: If someone is he or not long is not different, then he is alert.\n",
                "First-Order-Logic Question": "Faithful(tristan) ::: Tristan is faithful."
            },
            "diff": [
                {
                    "raw": "(∀x (x ∨ ¬Long(x) ∧ ¬Different(x))) → (∀x (Alert(x))) ::: If someone is he or not long is not different, then he is alert.",
                    "gram": "∀x((¬Long(x)∨¬Different(x))) ::: If someone is he or not long is not different, then he is alert."
                }
            ],
            "answer": "B",
            "grammar_answer": "A",
            "backup_answer": "A"
        },
        {
            "id": 1200,
            "raw_prog": {
                "First-Order-Logic Rules": "¬Several(rolf) ::: Rolf is not several.\n¬Precious(sigmund) ::: Sigmund is not precious.\nPrecious(godwin) ::: Godwin is precious.\nFearless(sigmund) ::: Sigmund is fearless.\nPrecious(rolf) ::: Rolf is precious.\n¬Stubborn(rose) ::: Rose is not stubborn.\nJittery(conrad) ::: Conrad is jittery.\n¬Fearless(brandi) ::: Brandi is not fearless.\n¬Sour(brandi) ::: Brandi is not sour.\nJittery(rolf) ::: Rolf is jittery.\nStubborn(owen) ::: Owen is stubborn.\n¬Fearless(godwin) ::: Godwin is not fearless.\n(¬∃x (¬x)) → (¬Jittery(godwin)) ::: If there is nobody who is not, then Godwin is not jittery.\n(∃x (Several(x) ∨ ¬Sour(x))) → (¬Stubborn(brandi)) ::: If there is someone who is either several or not sour, then Brandi is not stubborn.\n(∃x (¬Sour(x))) → ((¬Stubborn(owen) ∧ ¬Several(conrad))) ::: If there is at least one people who is not sour, then Owen is not stubborn and Conrad is not several.\n(∀x (Several(x) → ¬Sour(x))) → (∀x (Stubborn(x))) ::: If someone who is several is also not sour, then he is stubborn.\n(∃x (Sour(x) ∨ Jittery(x))) → ((¬Several(brandi) ∧ Stubborn(conrad))) ::: If there is at least one people who is either sour or jittery, then Brandi is not several and Conrad is stubborn.\n(¬Fearless(rolf)) → (¬Jittery(conrad)) ::: If Rolf is not fearless, then Conrad is not jittery.\n(¬Precious(godwin)) → ((Jittery(godwin) ∧ ¬Fearless(owen))) ::: It can be concluded that Godwin is jittery and Owen is not fearless once knowing that Godwin is not precious.\n((¬Jittery(godwin) ∧ ¬Several(sigmund))) → (Precious(sigmund)) ::: It can be concluded that Sigmund is precious once knowing that Godwin is not jittery and Sigmund is not several.\n((Several(rolf) ∨ Fearless(brandi))) → (¬Precious(brandi)) ::: If Rolf is several or Brandi is fearless, then Brandi is not precious.\n((¬Jittery(godwin) ∧ Several(conrad))) → (Sour(owen)) ::: If Godwin is not jittery and Conrad is several, then Owen is sour.\n(∀x (Precious(x))) → (∀x (¬Several(x))) ::: Someone who is precious is always not several.\n(¬Fearless(godwin)) ↔ (Several(brandi)) ::: If Godwin is not fearless, then Brandi is several, and vice versa.\n",
                "First-Order-Logic Question": "Sour(brandi) ::: Brandi is sour."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "¬Several(rolf) ::: Rolf is not several.\n¬Precious(sigmund) ::: Sigmund is not precious.\nPrecious(godwin) ::: Godwin is precious.\nFearless(sigmund) ::: Sigmund is fearless.\nPrecious(rolf) ::: Rolf is precious.\n¬Stubborn(rose) ::: Rose is not stubborn.\nJittery(conrad) ::: Conrad is jittery.\n¬Fearless(brandi) ::: Brandi is not fearless.\n¬Sour(brandi) ::: Brandi is not sour.\nJittery(rolf) ::: Rolf is jittery.\nStubborn(owen) ::: Owen is stubborn.\n¬Fearless(godwin) ::: Godwin is not fearless.\n¬∃x(¬(¬(Several(x)))) ::: If there is nobody who is not, then Godwin is not jittery.\n(∃x (Several(x) ∨ ¬Sour(x))) → (¬Stubborn(brandi)) ::: If there is someone who is either several or not sour, then Brandi is not stubborn.\n(∃x (¬Sour(x))) → ((¬Stubborn(owen) ∧ ¬Several(conrad))) ::: If there is at least one people who is not sour, then Owen is not stubborn and Conrad is not several.\n(∀x (Several(x) → ¬Sour(x))) → (∀x (Stubborn(x))) ::: If someone who is several is also not sour, then he is stubborn.\n(∃x (Sour(x) ∨ Jittery(x))) → ((¬Several(brandi) ∧ Stubborn(conrad))) ::: If there is at least one people who is either sour or jittery, then Brandi is not several and Conrad is stubborn.\n(¬Fearless(rolf)) → (¬Jittery(conrad)) ::: If Rolf is not fearless, then Conrad is not jittery.\n(¬Precious(godwin)) → ((Jittery(godwin) ∧ ¬Fearless(owen))) ::: It can be concluded that Godwin is jittery and Owen is not fearless once knowing that Godwin is not precious.\n((¬Jittery(godwin) ∧ ¬Several(sigmund))) → (Precious(sigmund)) ::: It can be concluded that Sigmund is precious once knowing that Godwin is not jittery and Sigmund is not several.\n((Several(rolf) ∨ Fearless(brandi))) → (¬Precious(brandi)) ::: If Rolf is several or Brandi is fearless, then Brandi is not precious.\n((¬Jittery(godwin) ∧ Several(conrad))) → (Sour(owen)) ::: If Godwin is not jittery and Conrad is several, then Owen is sour.\n(∀x (Precious(x))) → (∀x (¬Several(x))) ::: Someone who is precious is always not several.\n(¬Fearless(godwin)) ↔ (Several(brandi)) ::: If Godwin is not fearless, then Brandi is several, and vice versa.\n",
                "First-Order-Logic Question": "Sour(brandi) ::: Brandi is sour."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬x)) → (¬Jittery(godwin)) ::: If there is nobody who is not, then Godwin is not jittery.",
                    "gram": "¬∃x(¬(¬(Several(x)))) ::: If there is nobody who is not, then Godwin is not jittery."
                }
            ],
            "answer": "B",
            "grammar_answer": "A",
            "backup_answer": "B"
        },
        {
            "id": 1201,
            "raw_prog": {
                "First-Order-Logic Rules": "¬Several(rolf) ::: Rolf is not several.\n¬Precious(sigmund) ::: Sigmund is not precious.\nPrecious(godwin) ::: Godwin is precious.\nFearless(sigmund) ::: Sigmund is fearless.\nPrecious(rolf) ::: Rolf is precious.\n¬Stubborn(rose) ::: Rose is not stubborn.\nJittery(conrad) ::: Conrad is jittery.\n¬Fearless(brandi) ::: Brandi is not fearless.\n¬Sour(brandi) ::: Brandi is not sour.\nJittery(rolf) ::: Rolf is jittery.\nStubborn(owen) ::: Owen is stubborn.\n¬Fearless(godwin) ::: Godwin is not fearless.\n(¬∃x (¬x)) → (¬Jittery(godwin)) ::: If there is nobody who is not, then Godwin is not jittery.\n(∃x (Several(x) ∨ ¬Sour(x))) → (¬Stubborn(brandi)) ::: If there is someone who is either several or not sour, then Brandi is not stubborn.\n(∃x (¬Sour(x))) → (¬Stubborn(owen) ∧ ¬Several(conrad)) ::: If there is at least one people who is not sour, then Owen is not stubborn and Conrad is not several.\n(∀x (Several(x) → ¬Sour(x))) → (∀x (Stubborn(x))) ::: If someone who is several is also not sour, then he is stubborn.\n(∃x (Sour(x) ∨ Jittery(x))) → (¬Several(brandi) ∧ Stubborn(conrad)) ::: If there is at least one people who is either sour or jittery, then Brandi is not several and Conrad is stubborn.\n(¬Fearless(rolf)) → (¬Jittery(conrad)) ::: If Rolf is not fearless, then Conrad is not jittery.\n(¬Precious(godwin)) → (Jittery(godwin) ∧ ¬Fearless(owen)) ::: It can be concluded that Godwin is jittery and Owen is not fearless once knowing that Godwin is not precious.\n(¬Jittery(godwin) ∧ ¬Several(sigmund)) → (Precious(sigmund)) ::: It can be concluded that Sigmund is precious once knowing that Godwin is not jittery and Sigmund is not several.\n(Several(rolf) ∨ Fearless(brandi)) → (¬Precious(brandi)) ::: If Rolf is several or Brandi is fearless, then Brandi is not precious.\n(¬Jittery(godwin) ∧ Several(conrad)) → (Sour(owen)) ::: If Godwin is not jittery and Conrad is several, then Owen is sour.\n(∀x (Precious(x))) → (∀x (¬Several(x))) ::: Someone who is precious is always not several.\n(¬Fearless(godwin)) ↔ (Several(brandi)) ::: If Godwin is not fearless, then Brandi is several, and vice versa.\n",
                "First-Order-Logic Question": "¬Fearless(rose) ::: Rose is not fearless."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "¬Several(rolf) ::: Rolf is not several.\n¬Precious(sigmund) ::: Sigmund is not precious.\nPrecious(godwin) ::: Godwin is precious.\nFearless(sigmund) ::: Sigmund is fearless.\nPrecious(rolf) ::: Rolf is precious.\n¬Stubborn(rose) ::: Rose is not stubborn.\nJittery(conrad) ::: Conrad is jittery.\n¬Fearless(brandi) ::: Brandi is not fearless.\n¬Sour(brandi) ::: Brandi is not sour.\nJittery(rolf) ::: Rolf is jittery.\nStubborn(owen) ::: Owen is stubborn.\n¬Fearless(godwin) ::: Godwin is not fearless.\n¬∃x(¬(¬(Several(x)))) ::: If there is nobody who is not, then Godwin is not jittery.\n(∃x (Several(x) ∨ ¬Sour(x))) → (¬Stubborn(brandi)) ::: If there is someone who is either several or not sour, then Brandi is not stubborn.\n(∃x (¬Sour(x))) → (¬Stubborn(owen) ∧ ¬Several(conrad)) ::: If there is at least one people who is not sour, then Owen is not stubborn and Conrad is not several.\n(∀x (Several(x) → ¬Sour(x))) → (∀x (Stubborn(x))) ::: If someone who is several is also not sour, then he is stubborn.\n(∃x (Sour(x) ∨ Jittery(x))) → (¬Several(brandi) ∧ Stubborn(conrad)) ::: If there is at least one people who is either sour or jittery, then Brandi is not several and Conrad is stubborn.\n(¬Fearless(rolf)) → (¬Jittery(conrad)) ::: If Rolf is not fearless, then Conrad is not jittery.\n(¬Precious(godwin)) → (Jittery(godwin) ∧ ¬Fearless(owen)) ::: It can be concluded that Godwin is jittery and Owen is not fearless once knowing that Godwin is not precious.\n(¬Jittery(godwin) ∧ ¬Several(sigmund)) → (Precious(sigmund)) ::: It can be concluded that Sigmund is precious once knowing that Godwin is not jittery and Sigmund is not several.\n(Several(rolf) ∨ Fearless(brandi)) → (¬Precious(brandi)) ::: If Rolf is several or Brandi is fearless, then Brandi is not precious.\n(¬Jittery(godwin) ∧ Several(conrad)) → (Sour(owen)) ::: If Godwin is not jittery and Conrad is several, then Owen is sour.\n(∀x (Precious(x))) → (∀x (¬Several(x))) ::: Someone who is precious is always not several.\n(¬Fearless(godwin)) ↔ (Several(brandi)) ::: If Godwin is not fearless, then Brandi is several, and vice versa.\n",
                "First-Order-Logic Question": "¬Fearless(rose) ::: Rose is not fearless."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬x)) → (¬Jittery(godwin)) ::: If there is nobody who is not, then Godwin is not jittery.",
                    "gram": "¬∃x(¬(¬(Several(x)))) ::: If there is nobody who is not, then Godwin is not jittery."
                }
            ],
            "answer": "C",
            "grammar_answer": "A",
            "backup_answer": "C"
        },
        {
            "id": 1202,
            "raw_prog": {
                "First-Order-Logic Rules": "¬Several(rolf) ::: Rolf is not several.\n¬Precious(sigmund) ::: Sigmund is not precious.\nPrecious(godwin) ::: Godwin is precious.\nFearless(sigmund) ::: Sigmund is fearless.\nPrecious(rolf) ::: Rolf is precious.\n¬Stubborn(rose) ::: Rose is not stubborn.\nJittery(conrad) ::: Conrad is jittery.\n¬Fearless(brandi) ::: Brandi is not fearless.\n¬Sour(brandi) ::: Brandi is not sour.\nJittery(rolf) ::: Rolf is jittery.\nStubborn(owen) ::: Owen is stubborn.\n¬Fearless(godwin) ::: Godwin is not fearless.\n(¬∃x (¬x)) → (¬Jittery(godwin)) ::: If there is nobody who is not, then Godwin is not jittery.\n(∃x (Several(x) ∨ ¬Sour(x))) → (¬Stubborn(brandi)) ::: If there is someone who is either several or not sour, then Brandi is not stubborn.\n(∃x (¬Sour(x))) → ((¬Stubborn(owen) ∧ ¬Several(conrad))) ::: If there is at least one people who is not sour, then Owen is not stubborn and Conrad is not several.\n(∀x (Several(x) ∧ ¬Sour(x))) → (∀x (Stubborn(x))) ::: If someone who is several is also not sour, then he is stubborn.\n(∃x (Sour(x) ∨ Jittery(x))) → ((¬Several(brandi) ∧ Stubborn(conrad))) ::: If there is at least one people who is either sour or jittery, then Brandi is not several and Conrad is stubborn.\n(¬Fearless(rolf)) → (¬Jittery(conrad)) ::: If Rolf is not fearless, then Conrad is not jittery.\n((¬Precious(godwin))) → ((Jittery(godwin) ∧ ¬Fearless(owen))) ::: It can be concluded that Godwin is jittery and Owen is not fearless once knowing that Godwin is not precious.\n((¬Jittery(godwin) ∧ ¬Several(sigmund))) → ((Precious(sigmund))) ::: It can be concluded that Sigmund is precious once knowing that Godwin is not jittery and Sigmund is not several.\n((Several(rolf) ∨ Fearless(brandi))) → (¬Precious(brandi)) ::: If Rolf is several or Brandi is fearless, then Brandi is not precious.\n((¬Jittery(godwin) ∧ Several(conrad))) → ((Sour(owen))) ::: If Godwin is not jittery and Conrad is several, then Owen is sour.\n(∀x (Precious(x))) → (∀x (¬Several(x))) ::: Someone who is precious is always not several.\n((¬Fearless(godwin))) ↔ ((Several(brandi))) ::: If Godwin is not fearless, then Brandi is several, and vice versa.\n",
                "First-Order-Logic Question": "Several(owen) ::: Owen is several."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "¬Several(rolf) ::: Rolf is not several.\n¬Precious(sigmund) ::: Sigmund is not precious.\nPrecious(godwin) ::: Godwin is precious.\nFearless(sigmund) ::: Sigmund is fearless.\nPrecious(rolf) ::: Rolf is precious.\n¬Stubborn(rose) ::: Rose is not stubborn.\nJittery(conrad) ::: Conrad is jittery.\n¬Fearless(brandi) ::: Brandi is not fearless.\n¬Sour(brandi) ::: Brandi is not sour.\nJittery(rolf) ::: Rolf is jittery.\nStubborn(owen) ::: Owen is stubborn.\n¬Fearless(godwin) ::: Godwin is not fearless.\n¬∃x(¬(¬(Several(x)))) ::: If there is nobody who is not, then Godwin is not jittery.\n(∃x (Several(x) ∨ ¬Sour(x))) → (¬Stubborn(brandi)) ::: If there is someone who is either several or not sour, then Brandi is not stubborn.\n(∃x (¬Sour(x))) → ((¬Stubborn(owen) ∧ ¬Several(conrad))) ::: If there is at least one people who is not sour, then Owen is not stubborn and Conrad is not several.\n(∀x (Several(x) ∧ ¬Sour(x))) → (∀x (Stubborn(x))) ::: If someone who is several is also not sour, then he is stubborn.\n(∃x (Sour(x) ∨ Jittery(x))) → ((¬Several(brandi) ∧ Stubborn(conrad))) ::: If there is at least one people who is either sour or jittery, then Brandi is not several and Conrad is stubborn.\n(¬Fearless(rolf)) → (¬Jittery(conrad)) ::: If Rolf is not fearless, then Conrad is not jittery.\n((¬Precious(godwin))) → ((Jittery(godwin) ∧ ¬Fearless(owen))) ::: It can be concluded that Godwin is jittery and Owen is not fearless once knowing that Godwin is not precious.\n((¬Jittery(godwin) ∧ ¬Several(sigmund))) → ((Precious(sigmund))) ::: It can be concluded that Sigmund is precious once knowing that Godwin is not jittery and Sigmund is not several.\n((Several(rolf) ∨ Fearless(brandi))) → (¬Precious(brandi)) ::: If Rolf is several or Brandi is fearless, then Brandi is not precious.\n((¬Jittery(godwin) ∧ Several(conrad))) → ((Sour(owen))) ::: If Godwin is not jittery and Conrad is several, then Owen is sour.\n(∀x (Precious(x))) → (∀x (¬Several(x))) ::: Someone who is precious is always not several.\n((¬Fearless(godwin))) ↔ ((Several(brandi))) ::: If Godwin is not fearless, then Brandi is several, and vice versa.\n",
                "First-Order-Logic Question": "Several(owen) ::: Owen is several."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬x)) → (¬Jittery(godwin)) ::: If there is nobody who is not, then Godwin is not jittery.",
                    "gram": "¬∃x(¬(¬(Several(x)))) ::: If there is nobody who is not, then Godwin is not jittery."
                }
            ],
            "answer": "C",
            "grammar_answer": "A",
            "backup_answer": "C"
        },
        {
            "id": 1203,
            "raw_prog": {
                "First-Order-Logic Rules": "¬Several(rolf) ::: Rolf is not several.\n¬Precious(sigmund) ::: Sigmund is not precious.\nPrecious(godwin) ::: Godwin is precious.\nFearless(sigmund) ::: Sigmund is fearless.\nPrecious(rolf) ::: Rolf is precious.\n¬Stubborn(rose) ::: Rose is not stubborn.\nJittery(conrad) ::: Conrad is jittery.\n¬Fearless(brandi) ::: Brandi is not fearless.\n¬Sour(brandi) ::: Brandi is not sour.\nJittery(rolf) ::: Rolf is jittery.\nStubborn(owen) ::: Owen is stubborn.\n¬Fearless(godwin) ::: Godwin is not fearless.\n(¬∃x (¬x)) → (¬Jittery(godwin)) ::: If there is nobody who is not, then Godwin is not jittery.\n(∃x (Several(x) ∨ ¬Sour(x))) → (¬Stubborn(brandi)) ::: If there is someone who is either several or not sour, then Brandi is not stubborn.\n(∃x (¬Sour(x))) → ((¬Stubborn(owen) ∧ ¬Several(conrad))) ::: If there is at least one people who is not sour, then Owen is not stubborn and Conrad is not several.\n(∀x (Several(x) ∧ ¬Sour(x))) → (∀x (Stubborn(x))) ::: If someone who is several is also not sour, then he is stubborn.\n(∃x (Sour(x) ∨ Jittery(x))) → ((¬Several(brandi) ∧ Stubborn(conrad))) ::: If there is at least one people who is either sour or jittery, then Brandi is not several and Conrad is stubborn.\n(¬Fearless(rolf)) → (¬Jittery(conrad)) ::: If Rolf is not fearless, then Conrad is not jittery.\n(¬Precious(godwin)) → ((Jittery(godwin) ∧ ¬Fearless(owen))) ::: It can be concluded that Godwin is jittery and Owen is not fearless once knowing that Godwin is not precious.\n((¬Jittery(godwin) ∧ ¬Several(sigmund))) → (Precious(sigmund)) ::: It can be concluded that Sigmund is precious once knowing that Godwin is not jittery and Sigmund is not several.\n((Several(rolf) ∨ Fearless(brandi))) → (¬Precious(brandi)) ::: If Rolf is several or Brandi is fearless, then Brandi is not precious.\n((¬Jittery(godwin) ∧ Several(conrad))) → (Sour(owen)) ::: If Godwin is not jittery and Conrad is several, then Owen is sour.\n(∀x (Precious(x))) → (∀x (¬Several(x))) ::: Someone who is precious is always not several.\n((¬Fearless(godwin))) ↔ ((Several(brandi))) ::: If Godwin is not fearless, then Brandi is several, and vice versa.\n",
                "First-Order-Logic Question": "¬Fearless(sigmund) ::: Sigmund is not fearless."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "¬Several(rolf) ::: Rolf is not several.\n¬Precious(sigmund) ::: Sigmund is not precious.\nPrecious(godwin) ::: Godwin is precious.\nFearless(sigmund) ::: Sigmund is fearless.\nPrecious(rolf) ::: Rolf is precious.\n¬Stubborn(rose) ::: Rose is not stubborn.\nJittery(conrad) ::: Conrad is jittery.\n¬Fearless(brandi) ::: Brandi is not fearless.\n¬Sour(brandi) ::: Brandi is not sour.\nJittery(rolf) ::: Rolf is jittery.\nStubborn(owen) ::: Owen is stubborn.\n¬Fearless(godwin) ::: Godwin is not fearless.\n¬∃x(¬(¬(Several(x)))) ::: If there is nobody who is not, then Godwin is not jittery.\n(∃x (Several(x) ∨ ¬Sour(x))) → (¬Stubborn(brandi)) ::: If there is someone who is either several or not sour, then Brandi is not stubborn.\n(∃x (¬Sour(x))) → ((¬Stubborn(owen) ∧ ¬Several(conrad))) ::: If there is at least one people who is not sour, then Owen is not stubborn and Conrad is not several.\n(∀x (Several(x) ∧ ¬Sour(x))) → (∀x (Stubborn(x))) ::: If someone who is several is also not sour, then he is stubborn.\n(∃x (Sour(x) ∨ Jittery(x))) → ((¬Several(brandi) ∧ Stubborn(conrad))) ::: If there is at least one people who is either sour or jittery, then Brandi is not several and Conrad is stubborn.\n(¬Fearless(rolf)) → (¬Jittery(conrad)) ::: If Rolf is not fearless, then Conrad is not jittery.\n(¬Precious(godwin)) → ((Jittery(godwin) ∧ ¬Fearless(owen))) ::: It can be concluded that Godwin is jittery and Owen is not fearless once knowing that Godwin is not precious.\n((¬Jittery(godwin) ∧ ¬Several(sigmund))) → (Precious(sigmund)) ::: It can be concluded that Sigmund is precious once knowing that Godwin is not jittery and Sigmund is not several.\n((Several(rolf) ∨ Fearless(brandi))) → (¬Precious(brandi)) ::: If Rolf is several or Brandi is fearless, then Brandi is not precious.\n((¬Jittery(godwin) ∧ Several(conrad))) → (Sour(owen)) ::: If Godwin is not jittery and Conrad is several, then Owen is sour.\n(∀x (Precious(x))) → (∀x (¬Several(x))) ::: Someone who is precious is always not several.\n((¬Fearless(godwin))) ↔ ((Several(brandi))) ::: If Godwin is not fearless, then Brandi is several, and vice versa.\n",
                "First-Order-Logic Question": "¬Fearless(sigmund) ::: Sigmund is not fearless."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬x)) → (¬Jittery(godwin)) ::: If there is nobody who is not, then Godwin is not jittery.",
                    "gram": "¬∃x(¬(¬(Several(x)))) ::: If there is nobody who is not, then Godwin is not jittery."
                }
            ],
            "answer": "B",
            "grammar_answer": "A",
            "backup_answer": "B"
        },
        {
            "id": 1204,
            "raw_prog": {
                "First-Order-Logic Rules": "¬Several(rolf) ::: Rolf is not several.\n¬Precious(sigmund) ::: Sigmund is not precious.\nPrecious(godwin) ::: Godwin is precious.\nFearless(sigmund) ::: Sigmund is fearless.\nPrecious(rolf) ::: Rolf is precious.\n¬Stubborn(rose) ::: Rose is not stubborn.\nJittery(conrad) ::: Conrad is jittery.\n¬Fearless(brandi) ::: Brandi is not fearless.\n¬Sour(brandi) ::: Brandi is not sour.\nJittery(rolf) ::: Rolf is jittery.\nStubborn(owen) ::: Owen is stubborn.\n¬Fearless(godwin) ::: Godwin is not fearless.\n(¬∃x (¬x)) → (¬Jittery(godwin)) ::: If there is nobody who is not, then Godwin is not jittery.\n(∃x (Several(x) ∨ ¬Sour(x))) → (¬Stubborn(brandi)) ::: If there is someone who is either several or not sour, then Brandi is not stubborn.\n(∃x (¬Sour(x))) → (¬Stubborn(owen) ∧ ¬Several(conrad)) ::: If there is at least one people who is not sour, then Owen is not stubborn and Conrad is not several.\n(∀x (Several(x) → ¬Sour(x))) → (∀x (Stubborn(x))) ::: If someone who is several is also not sour, then he is stubborn.\n(∃x (Sour(x) ∨ Jittery(x))) → (¬Several(brandi) ∧ Stubborn(conrad)) ::: If there is at least one people who is either sour or jittery, then Brandi is not several and Conrad is stubborn.\n(¬Fearless(rolf)) → (¬Jittery(conrad)) ::: If Rolf is not fearless, then Conrad is not jittery.\n(¬Precious(godwin)) → (Jittery(godwin) ∧ ¬Fearless(owen)) ::: It can be concluded that Godwin is jittery and Owen is not fearless once knowing that Godwin is not precious.\n(¬Jittery(godwin) ∧ ¬Several(sigmund)) → (Precious(sigmund)) ::: It can be concluded that Sigmund is precious once knowing that Godwin is not jittery and Sigmund is not several.\n(Several(rolf) ∨ Fearless(brandi)) → (¬Precious(brandi)) ::: If Rolf is several or Brandi is fearless, then Brandi is not precious.\n(¬Jittery(godwin) ∧ Several(conrad)) → (Sour(owen)) ::: If Godwin is not jittery and Conrad is several, then Owen is sour.\n(∀x (Precious(x))) → (∀x (¬Several(x))) ::: Someone who is precious is always not several.\n(¬Fearless(godwin)) ↔ (Several(brandi)) ::: If Godwin is not fearless, then Brandi is several, and vice versa.\n",
                "First-Order-Logic Question": "Jittery(conrad) ::: Conrad is jittery."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "¬Several(rolf) ::: Rolf is not several.\n¬Precious(sigmund) ::: Sigmund is not precious.\nPrecious(godwin) ::: Godwin is precious.\nFearless(sigmund) ::: Sigmund is fearless.\nPrecious(rolf) ::: Rolf is precious.\n¬Stubborn(rose) ::: Rose is not stubborn.\nJittery(conrad) ::: Conrad is jittery.\n¬Fearless(brandi) ::: Brandi is not fearless.\n¬Sour(brandi) ::: Brandi is not sour.\nJittery(rolf) ::: Rolf is jittery.\nStubborn(owen) ::: Owen is stubborn.\n¬Fearless(godwin) ::: Godwin is not fearless.\n¬∃x(¬(¬(Several(x)))) ::: If there is nobody who is not, then Godwin is not jittery.\n(∃x (Several(x) ∨ ¬Sour(x))) → (¬Stubborn(brandi)) ::: If there is someone who is either several or not sour, then Brandi is not stubborn.\n(∃x (¬Sour(x))) → (¬Stubborn(owen) ∧ ¬Several(conrad)) ::: If there is at least one people who is not sour, then Owen is not stubborn and Conrad is not several.\n(∀x (Several(x) → ¬Sour(x))) → (∀x (Stubborn(x))) ::: If someone who is several is also not sour, then he is stubborn.\n(∃x (Sour(x) ∨ Jittery(x))) → (¬Several(brandi) ∧ Stubborn(conrad)) ::: If there is at least one people who is either sour or jittery, then Brandi is not several and Conrad is stubborn.\n(¬Fearless(rolf)) → (¬Jittery(conrad)) ::: If Rolf is not fearless, then Conrad is not jittery.\n(¬Precious(godwin)) → (Jittery(godwin) ∧ ¬Fearless(owen)) ::: It can be concluded that Godwin is jittery and Owen is not fearless once knowing that Godwin is not precious.\n(¬Jittery(godwin) ∧ ¬Several(sigmund)) → (Precious(sigmund)) ::: It can be concluded that Sigmund is precious once knowing that Godwin is not jittery and Sigmund is not several.\n(Several(rolf) ∨ Fearless(brandi)) → (¬Precious(brandi)) ::: If Rolf is several or Brandi is fearless, then Brandi is not precious.\n(¬Jittery(godwin) ∧ Several(conrad)) → (Sour(owen)) ::: If Godwin is not jittery and Conrad is several, then Owen is sour.\n(∀x (Precious(x))) → (∀x (¬Several(x))) ::: Someone who is precious is always not several.\n(¬Fearless(godwin)) ↔ (Several(brandi)) ::: If Godwin is not fearless, then Brandi is several, and vice versa.\n",
                "First-Order-Logic Question": "Jittery(conrad) ::: Conrad is jittery."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬x)) → (¬Jittery(godwin)) ::: If there is nobody who is not, then Godwin is not jittery.",
                    "gram": "¬∃x(¬(¬(Several(x)))) ::: If there is nobody who is not, then Godwin is not jittery."
                }
            ],
            "answer": "A",
            "grammar_answer": "A",
            "backup_answer": "A"
        },
        {
            "id": 1205,
            "raw_prog": {
                "First-Order-Logic Rules": "¬Several(rolf) ::: Rolf is not several.\n¬Precious(sigmund) ::: Sigmund is not precious.\nPrecious(godwin) ::: Godwin is precious.\nFearless(sigmund) ::: Sigmund is fearless.\nPrecious(rolf) ::: Rolf is precious.\n¬Stubborn(rose) ::: Rose is not stubborn.\nJittery(conrad) ::: Conrad is jittery.\n¬Fearless(brandi) ::: Brandi is not fearless.\n¬Sour(brandi) ::: Brandi is not sour.\nJittery(rolf) ::: Rolf is jittery.\nStubborn(owen) ::: Owen is stubborn.\n¬Fearless(godwin) ::: Godwin is not fearless.\n(¬∃x (¬x)) → (¬Jittery(godwin)) ::: If there is nobody who is not, then Godwin is not jittery.\n(∃x (Several(x) ∨ ¬Sour(x))) → (¬Stubborn(brandi)) ::: If there is someone who is either several or not sour, then Brandi is not stubborn.\n(∃x (¬Sour(x))) → ((¬Stubborn(owen) ∧ ¬Several(conrad))) ::: If there is at least one people who is not sour, then Owen is not stubborn and Conrad is not several.\n(∀x (Several(x) ∧ ¬Sour(x))) → (∀x (Stubborn(x))) ::: If someone who is several is also not sour, then he is stubborn.\n(∃x (Sour(x) ∨ Jittery(x))) → ((¬Several(brandi) ∧ Stubborn(conrad))) ::: If there is at least one people who is either sour or jittery, then Brandi is not several and Conrad is stubborn.\n(¬Fearless(rolf)) → (¬Jittery(conrad)) ::: If Rolf is not fearless, then Conrad is not jittery.\n(¬Precious(godwin)) → ((Jittery(godwin) ∧ ¬Fearless(owen))) ::: It can be concluded that Godwin is jittery and Owen is not fearless once knowing that Godwin is not precious.\n((¬Jittery(godwin) ∧ ¬Several(sigmund))) → (Precious(sigmund)) ::: It can be concluded that Sigmund is precious once knowing that Godwin is not jittery and Sigmund is not several.\n((Several(rolf) ∨ Fearless(brandi))) → (¬Precious(brandi)) ::: If Rolf is several or Brandi is fearless, then Brandi is not precious.\n((¬Jittery(godwin) ∧ Several(conrad))) → (Sour(owen)) ::: If Godwin is not jittery and Conrad is several, then Owen is sour.\n(∀x (Precious(x))) → (∀x (¬Several(x))) ::: Someone who is precious is always not several.\n(¬Fearless(godwin)) ↔ (Several(brandi)) ::: If Godwin is not fearless, then Brandi is several, and vice versa.\n",
                "First-Order-Logic Question": "Fearless(owen) ::: Owen is fearless."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "¬Several(rolf) ::: Rolf is not several.\n¬Precious(sigmund) ::: Sigmund is not precious.\nPrecious(godwin) ::: Godwin is precious.\nFearless(sigmund) ::: Sigmund is fearless.\nPrecious(rolf) ::: Rolf is precious.\n¬Stubborn(rose) ::: Rose is not stubborn.\nJittery(conrad) ::: Conrad is jittery.\n¬Fearless(brandi) ::: Brandi is not fearless.\n¬Sour(brandi) ::: Brandi is not sour.\nJittery(rolf) ::: Rolf is jittery.\nStubborn(owen) ::: Owen is stubborn.\n¬Fearless(godwin) ::: Godwin is not fearless.\n¬∃x(¬(¬(Several(x)))) ::: If there is nobody who is not, then Godwin is not jittery.\n(∃x (Several(x) ∨ ¬Sour(x))) → (¬Stubborn(brandi)) ::: If there is someone who is either several or not sour, then Brandi is not stubborn.\n(∃x (¬Sour(x))) → ((¬Stubborn(owen) ∧ ¬Several(conrad))) ::: If there is at least one people who is not sour, then Owen is not stubborn and Conrad is not several.\n(∀x (Several(x) ∧ ¬Sour(x))) → (∀x (Stubborn(x))) ::: If someone who is several is also not sour, then he is stubborn.\n(∃x (Sour(x) ∨ Jittery(x))) → ((¬Several(brandi) ∧ Stubborn(conrad))) ::: If there is at least one people who is either sour or jittery, then Brandi is not several and Conrad is stubborn.\n(¬Fearless(rolf)) → (¬Jittery(conrad)) ::: If Rolf is not fearless, then Conrad is not jittery.\n(¬Precious(godwin)) → ((Jittery(godwin) ∧ ¬Fearless(owen))) ::: It can be concluded that Godwin is jittery and Owen is not fearless once knowing that Godwin is not precious.\n((¬Jittery(godwin) ∧ ¬Several(sigmund))) → (Precious(sigmund)) ::: It can be concluded that Sigmund is precious once knowing that Godwin is not jittery and Sigmund is not several.\n((Several(rolf) ∨ Fearless(brandi))) → (¬Precious(brandi)) ::: If Rolf is several or Brandi is fearless, then Brandi is not precious.\n((¬Jittery(godwin) ∧ Several(conrad))) → (Sour(owen)) ::: If Godwin is not jittery and Conrad is several, then Owen is sour.\n(∀x (Precious(x))) → (∀x (¬Several(x))) ::: Someone who is precious is always not several.\n(¬Fearless(godwin)) ↔ (Several(brandi)) ::: If Godwin is not fearless, then Brandi is several, and vice versa.\n",
                "First-Order-Logic Question": "Fearless(owen) ::: Owen is fearless."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬x)) → (¬Jittery(godwin)) ::: If there is nobody who is not, then Godwin is not jittery.",
                    "gram": "¬∃x(¬(¬(Several(x)))) ::: If there is nobody who is not, then Godwin is not jittery."
                }
            ],
            "answer": "C",
            "grammar_answer": "A",
            "backup_answer": "C"
        },
        {
            "id": 1206,
            "raw_prog": {
                "First-Order-Logic Rules": "¬Several(rolf) ::: Rolf is not several.\n¬Precious(sigmund) ::: Sigmund is not precious.\nPrecious(godwin) ::: Godwin is precious.\nFearless(sigmund) ::: Sigmund is fearless.\nPrecious(rolf) ::: Rolf is precious.\n¬Stubborn(rose) ::: Rose is not stubborn.\nJittery(conrad) ::: Conrad is jittery.\n¬Fearless(brandi) ::: Brandi is not fearless.\n¬Sour(brandi) ::: Brandi is not sour.\nJittery(rolf) ::: Rolf is jittery.\nStubborn(owen) ::: Owen is stubborn.\n¬Fearless(godwin) ::: Godwin is not fearless.\n(¬∃x (¬x)) → (¬Jittery(godwin)) ::: If there is nobody who is not, then Godwin is not jittery.\n(∃x (Several(x) ∨ ¬Sour(x))) → (¬Stubborn(brandi)) ::: If there is someone who is either several or not sour, then Brandi is not stubborn.\n(∃x (¬Sour(x))) → ((¬Stubborn(owen) ∧ ¬Several(conrad))) ::: If there is at least one people who is not sour, then Owen is not stubborn and Conrad is not several.\n(∀x (Several(x) ∧ ¬Sour(x))) → (∀x (Stubborn(x))) ::: If someone who is several is also not sour, then he is stubborn.\n(∃x (Sour(x) ∨ Jittery(x))) → ((¬Several(brandi) ∧ Stubborn(conrad))) ::: If there is at least one people who is either sour or jittery, then Brandi is not several and Conrad is stubborn.\n(¬Fearless(rolf)) → (¬Jittery(conrad)) ::: If Rolf is not fearless, then Conrad is not jittery.\n((¬Precious(godwin))) → ((Jittery(godwin) ∧ ¬Fearless(owen))) ::: It can be concluded that Godwin is jittery and Owen is not fearless once knowing that Godwin is not precious.\n((¬Jittery(godwin) ∧ ¬Several(sigmund))) → (Precious(sigmund)) ::: It can be concluded that Sigmund is precious once knowing that Godwin is not jittery and Sigmund is not several.\n((Several(rolf) ∨ Fearless(brandi))) → (¬Precious(brandi)) ::: If Rolf is several or Brandi is fearless, then Brandi is not precious.\n((¬Jittery(godwin) ∧ Several(conrad))) → (Sour(owen)) ::: If Godwin is not jittery and Conrad is several, then Owen is sour.\n(∀x (Precious(x))) → (∀x (¬Several(x))) ::: Someone who is precious is always not several.\n((¬Fearless(godwin))) ↔ ((Several(brandi))) ::: If Godwin is not fearless, then Brandi is several, and vice versa.\n",
                "First-Order-Logic Question": "Fearless(sigmund) ::: Sigmund is fearless."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "¬Several(rolf) ::: Rolf is not several.\n¬Precious(sigmund) ::: Sigmund is not precious.\nPrecious(godwin) ::: Godwin is precious.\nFearless(sigmund) ::: Sigmund is fearless.\nPrecious(rolf) ::: Rolf is precious.\n¬Stubborn(rose) ::: Rose is not stubborn.\nJittery(conrad) ::: Conrad is jittery.\n¬Fearless(brandi) ::: Brandi is not fearless.\n¬Sour(brandi) ::: Brandi is not sour.\nJittery(rolf) ::: Rolf is jittery.\nStubborn(owen) ::: Owen is stubborn.\n¬Fearless(godwin) ::: Godwin is not fearless.\n¬∃x(¬(¬(Several(x)))) ::: If there is nobody who is not, then Godwin is not jittery.\n(∃x (Several(x) ∨ ¬Sour(x))) → (¬Stubborn(brandi)) ::: If there is someone who is either several or not sour, then Brandi is not stubborn.\n(∃x (¬Sour(x))) → ((¬Stubborn(owen) ∧ ¬Several(conrad))) ::: If there is at least one people who is not sour, then Owen is not stubborn and Conrad is not several.\n(∀x (Several(x) ∧ ¬Sour(x))) → (∀x (Stubborn(x))) ::: If someone who is several is also not sour, then he is stubborn.\n(∃x (Sour(x) ∨ Jittery(x))) → ((¬Several(brandi) ∧ Stubborn(conrad))) ::: If there is at least one people who is either sour or jittery, then Brandi is not several and Conrad is stubborn.\n(¬Fearless(rolf)) → (¬Jittery(conrad)) ::: If Rolf is not fearless, then Conrad is not jittery.\n((¬Precious(godwin))) → ((Jittery(godwin) ∧ ¬Fearless(owen))) ::: It can be concluded that Godwin is jittery and Owen is not fearless once knowing that Godwin is not precious.\n((¬Jittery(godwin) ∧ ¬Several(sigmund))) → (Precious(sigmund)) ::: It can be concluded that Sigmund is precious once knowing that Godwin is not jittery and Sigmund is not several.\n((Several(rolf) ∨ Fearless(brandi))) → (¬Precious(brandi)) ::: If Rolf is several or Brandi is fearless, then Brandi is not precious.\n((¬Jittery(godwin) ∧ Several(conrad))) → (Sour(owen)) ::: If Godwin is not jittery and Conrad is several, then Owen is sour.\n(∀x (Precious(x))) → (∀x (¬Several(x))) ::: Someone who is precious is always not several.\n((¬Fearless(godwin))) ↔ ((Several(brandi))) ::: If Godwin is not fearless, then Brandi is several, and vice versa.\n",
                "First-Order-Logic Question": "Fearless(sigmund) ::: Sigmund is fearless."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬x)) → (¬Jittery(godwin)) ::: If there is nobody who is not, then Godwin is not jittery.",
                    "gram": "¬∃x(¬(¬(Several(x)))) ::: If there is nobody who is not, then Godwin is not jittery."
                }
            ],
            "answer": "A",
            "grammar_answer": "A",
            "backup_answer": "A"
        },
        {
            "id": 1207,
            "raw_prog": {
                "First-Order-Logic Rules": "¬Several(rolf) ::: Rolf is not several.\n¬Precious(sigmund) ::: Sigmund is not precious.\nPrecious(godwin) ::: Godwin is precious.\nFearless(sigmund) ::: Sigmund is fearless.\nPrecious(rolf) ::: Rolf is precious.\n¬Stubborn(rose) ::: Rose is not stubborn.\nJittery(conrad) ::: Conrad is jittery.\n¬Fearless(brandi) ::: Brandi is not fearless.\n¬Sour(brandi) ::: Brandi is not sour.\nJittery(rolf) ::: Rolf is jittery.\nStubborn(owen) ::: Owen is stubborn.\n¬Fearless(godwin) ::: Godwin is not fearless.\n(¬∃x (¬x)) → (¬Jittery(godwin)) ::: If there is nobody who is not, then Godwin is not jittery.\n(∃x (Several(x) ∨ ¬Sour(x))) → (¬Stubborn(brandi)) ::: If there is someone who is either several or not sour, then Brandi is not stubborn.\n(∃x (¬Sour(x))) → ((¬Stubborn(owen) ∧ ¬Several(conrad))) ::: If there is at least one people who is not sour, then Owen is not stubborn and Conrad is not several.\n(∀x (Several(x) ∧ ¬Sour(x))) → (∀x (Stubborn(x))) ::: If someone who is several is also not sour, then he is stubborn.\n(∃x (Sour(x) ∨ Jittery(x))) → ((¬Several(brandi) ∧ Stubborn(conrad))) ::: If there is at least one people who is either sour or jittery, then Brandi is not several and Conrad is stubborn.\n(¬Fearless(rolf)) → (¬Jittery(conrad)) ::: If Rolf is not fearless, then Conrad is not jittery.\n(¬Precious(godwin)) → ((Jittery(godwin) ∧ ¬Fearless(owen))) ::: It can be concluded that Godwin is jittery and Owen is not fearless once knowing that Godwin is not precious.\n((¬Jittery(godwin) ∧ ¬Several(sigmund))) → (Precious(sigmund)) ::: It can be concluded that Sigmund is precious once knowing that Godwin is not jittery and Sigmund is not several.\n((Several(rolf) ∨ Fearless(brandi))) → (¬Precious(brandi)) ::: If Rolf is several or Brandi is fearless, then Brandi is not precious.\n((¬Jittery(godwin) ∧ Several(conrad))) → (Sour(owen)) ::: If Godwin is not jittery and Conrad is several, then Owen is sour.\n(∀x (Precious(x))) → (∀x (¬Several(x))) ::: Someone who is precious is always not several.\n((¬Fearless(godwin))) ↔ ((Several(brandi))) ::: If Godwin is not fearless, then Brandi is several, and vice versa.\n",
                "First-Order-Logic Question": "Precious(conrad) ::: Conrad is precious."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "¬Several(rolf) ::: Rolf is not several.\n¬Precious(sigmund) ::: Sigmund is not precious.\nPrecious(godwin) ::: Godwin is precious.\nFearless(sigmund) ::: Sigmund is fearless.\nPrecious(rolf) ::: Rolf is precious.\n¬Stubborn(rose) ::: Rose is not stubborn.\nJittery(conrad) ::: Conrad is jittery.\n¬Fearless(brandi) ::: Brandi is not fearless.\n¬Sour(brandi) ::: Brandi is not sour.\nJittery(rolf) ::: Rolf is jittery.\nStubborn(owen) ::: Owen is stubborn.\n¬Fearless(godwin) ::: Godwin is not fearless.\n¬∃x(¬(¬(Several(x)))) ::: If there is nobody who is not, then Godwin is not jittery.\n(∃x (Several(x) ∨ ¬Sour(x))) → (¬Stubborn(brandi)) ::: If there is someone who is either several or not sour, then Brandi is not stubborn.\n(∃x (¬Sour(x))) → ((¬Stubborn(owen) ∧ ¬Several(conrad))) ::: If there is at least one people who is not sour, then Owen is not stubborn and Conrad is not several.\n(∀x (Several(x) ∧ ¬Sour(x))) → (∀x (Stubborn(x))) ::: If someone who is several is also not sour, then he is stubborn.\n(∃x (Sour(x) ∨ Jittery(x))) → ((¬Several(brandi) ∧ Stubborn(conrad))) ::: If there is at least one people who is either sour or jittery, then Brandi is not several and Conrad is stubborn.\n(¬Fearless(rolf)) → (¬Jittery(conrad)) ::: If Rolf is not fearless, then Conrad is not jittery.\n(¬Precious(godwin)) → ((Jittery(godwin) ∧ ¬Fearless(owen))) ::: It can be concluded that Godwin is jittery and Owen is not fearless once knowing that Godwin is not precious.\n((¬Jittery(godwin) ∧ ¬Several(sigmund))) → (Precious(sigmund)) ::: It can be concluded that Sigmund is precious once knowing that Godwin is not jittery and Sigmund is not several.\n((Several(rolf) ∨ Fearless(brandi))) → (¬Precious(brandi)) ::: If Rolf is several or Brandi is fearless, then Brandi is not precious.\n((¬Jittery(godwin) ∧ Several(conrad))) → (Sour(owen)) ::: If Godwin is not jittery and Conrad is several, then Owen is sour.\n(∀x (Precious(x))) → (∀x (¬Several(x))) ::: Someone who is precious is always not several.\n((¬Fearless(godwin))) ↔ ((Several(brandi))) ::: If Godwin is not fearless, then Brandi is several, and vice versa.\n",
                "First-Order-Logic Question": "Precious(conrad) ::: Conrad is precious."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬x)) → (¬Jittery(godwin)) ::: If there is nobody who is not, then Godwin is not jittery.",
                    "gram": "¬∃x(¬(¬(Several(x)))) ::: If there is nobody who is not, then Godwin is not jittery."
                }
            ],
            "answer": "C",
            "grammar_answer": "A",
            "backup_answer": "C"
        },
        {
            "id": 1208,
            "raw_prog": {
                "First-Order-Logic Rules": "¬Several(rolf) ::: Rolf is not several.\n¬Precious(sigmund) ::: Sigmund is not precious.\nPrecious(godwin) ::: Godwin is precious.\nFearless(sigmund) ::: Sigmund is fearless.\nPrecious(rolf) ::: Rolf is precious.\n¬Stubborn(rose) ::: Rose is not stubborn.\nJittery(conrad) ::: Conrad is jittery.\n¬Fearless(brandi) ::: Brandi is not fearless.\n¬Sour(brandi) ::: Brandi is not sour.\nJittery(rolf) ::: Rolf is jittery.\nStubborn(owen) ::: Owen is stubborn.\n¬Fearless(godwin) ::: Godwin is not fearless.\n(¬∃x (¬x)) → (¬Jittery(godwin)) ::: If there is nobody who is not, then Godwin is not jittery.\n(∃x (Several(x) ∨ ¬Sour(x))) → (¬Stubborn(brandi)) ::: If there is someone who is either several or not sour, then Brandi is not stubborn.\n(∃x (¬Sour(x))) → ((¬Stubborn(owen) ∧ ¬Several(conrad))) ::: If there is at least one people who is not sour, then Owen is not stubborn and Conrad is not several.\n(∀x (Several(x) ∧ ¬Sour(x))) → (∀x (Stubborn(x))) ::: If someone who is several is also not sour, then he is stubborn.\n(∃x (Sour(x) ∨ Jittery(x))) → ((¬Several(brandi) ∧ Stubborn(conrad))) ::: If there is at least one people who is either sour or jittery, then Brandi is not several and Conrad is stubborn.\n(¬Fearless(rolf)) → (¬Jittery(conrad)) ::: If Rolf is not fearless, then Conrad is not jittery.\n((¬Precious(godwin))) → ((Jittery(godwin) ∧ ¬Fearless(owen))) ::: It can be concluded that Godwin is jittery and Owen is not fearless once knowing that Godwin is not precious.\n((¬Jittery(godwin) ∧ ¬Several(sigmund))) → (Precious(sigmund)) ::: It can be concluded that Sigmund is precious once knowing that Godwin is not jittery and Sigmund is not several.\n((Several(rolf) ∨ Fearless(brandi))) → (¬Precious(brandi)) ::: If Rolf is several or Brandi is fearless, then Brandi is not precious.\n((¬Jittery(godwin) ∧ Several(conrad))) → (Sour(owen)) ::: If Godwin is not jittery and Conrad is several, then Owen is sour.\n(∀x (Precious(x))) → (∀x (¬Several(x))) ::: Someone who is precious is always not several.\n((¬Fearless(godwin))) ↔ ((Several(brandi))) ::: If Godwin is not fearless, then Brandi is several, and vice versa.\n",
                "First-Order-Logic Question": "Several(rolf) ::: Rolf is several."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "¬Several(rolf) ::: Rolf is not several.\n¬Precious(sigmund) ::: Sigmund is not precious.\nPrecious(godwin) ::: Godwin is precious.\nFearless(sigmund) ::: Sigmund is fearless.\nPrecious(rolf) ::: Rolf is precious.\n¬Stubborn(rose) ::: Rose is not stubborn.\nJittery(conrad) ::: Conrad is jittery.\n¬Fearless(brandi) ::: Brandi is not fearless.\n¬Sour(brandi) ::: Brandi is not sour.\nJittery(rolf) ::: Rolf is jittery.\nStubborn(owen) ::: Owen is stubborn.\n¬Fearless(godwin) ::: Godwin is not fearless.\n¬∃x(¬(¬(Several(x)))) ::: If there is nobody who is not, then Godwin is not jittery.\n(∃x (Several(x) ∨ ¬Sour(x))) → (¬Stubborn(brandi)) ::: If there is someone who is either several or not sour, then Brandi is not stubborn.\n(∃x (¬Sour(x))) → ((¬Stubborn(owen) ∧ ¬Several(conrad))) ::: If there is at least one people who is not sour, then Owen is not stubborn and Conrad is not several.\n(∀x (Several(x) ∧ ¬Sour(x))) → (∀x (Stubborn(x))) ::: If someone who is several is also not sour, then he is stubborn.\n(∃x (Sour(x) ∨ Jittery(x))) → ((¬Several(brandi) ∧ Stubborn(conrad))) ::: If there is at least one people who is either sour or jittery, then Brandi is not several and Conrad is stubborn.\n(¬Fearless(rolf)) → (¬Jittery(conrad)) ::: If Rolf is not fearless, then Conrad is not jittery.\n((¬Precious(godwin))) → ((Jittery(godwin) ∧ ¬Fearless(owen))) ::: It can be concluded that Godwin is jittery and Owen is not fearless once knowing that Godwin is not precious.\n((¬Jittery(godwin) ∧ ¬Several(sigmund))) → (Precious(sigmund)) ::: It can be concluded that Sigmund is precious once knowing that Godwin is not jittery and Sigmund is not several.\n((Several(rolf) ∨ Fearless(brandi))) → (¬Precious(brandi)) ::: If Rolf is several or Brandi is fearless, then Brandi is not precious.\n((¬Jittery(godwin) ∧ Several(conrad))) → (Sour(owen)) ::: If Godwin is not jittery and Conrad is several, then Owen is sour.\n(∀x (Precious(x))) → (∀x (¬Several(x))) ::: Someone who is precious is always not several.\n((¬Fearless(godwin))) ↔ ((Several(brandi))) ::: If Godwin is not fearless, then Brandi is several, and vice versa.\n",
                "First-Order-Logic Question": "Several(rolf) ::: Rolf is several."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬x)) → (¬Jittery(godwin)) ::: If there is nobody who is not, then Godwin is not jittery.",
                    "gram": "¬∃x(¬(¬(Several(x)))) ::: If there is nobody who is not, then Godwin is not jittery."
                }
            ],
            "answer": "B",
            "grammar_answer": "A",
            "backup_answer": "B"
        },
        {
            "id": 1209,
            "raw_prog": {
                "First-Order-Logic Rules": "¬Several(rolf) ::: Rolf is not several.\n¬Precious(sigmund) ::: Sigmund is not precious.\nPrecious(godwin) ::: Godwin is precious.\nFearless(sigmund) ::: Sigmund is fearless.\nPrecious(rolf) ::: Rolf is precious.\n¬Stubborn(rose) ::: Rose is not stubborn.\nJittery(conrad) ::: Conrad is jittery.\n¬Fearless(brandi) ::: Brandi is not fearless.\n¬Sour(brandi) ::: Brandi is not sour.\nJittery(rolf) ::: Rolf is jittery.\nStubborn(owen) ::: Owen is stubborn.\n¬Fearless(godwin) ::: Godwin is not fearless.\n(¬∃x (¬x)) → (¬Jittery(godwin)) ::: If there is nobody who is not, then Godwin is not jittery.\n(∃x (Several(x) ∨ ¬Sour(x))) → (¬Stubborn(brandi)) ::: If there is someone who is either several or not sour, then Brandi is not stubborn.\n(∃x (¬Sour(x))) → ((¬Stubborn(owen) ∧ ¬Several(conrad))) ::: If there is at least one people who is not sour, then Owen is not stubborn and Conrad is not several.\n(∀x (Several(x) → ¬Sour(x))) → (∀x (Stubborn(x))) ::: If someone who is several is also not sour, then he is stubborn.\n(∃x (Sour(x) ∨ Jittery(x))) → ((¬Several(brandi) ∧ Stubborn(conrad))) ::: If there is at least one people who is either sour or jittery, then Brandi is not several and Conrad is stubborn.\n(¬Fearless(rolf)) → (¬Jittery(conrad)) ::: If Rolf is not fearless, then Conrad is not jittery.\n(¬Precious(godwin)) → ((Jittery(godwin) ∧ ¬Fearless(owen))) ::: It can be concluded that Godwin is jittery and Owen is not fearless once knowing that Godwin is not precious.\n((¬Jittery(godwin) ∧ ¬Several(sigmund))) → (Precious(sigmund)) ::: It can be concluded that Sigmund is precious once knowing that Godwin is not jittery and Sigmund is not several.\n((Several(rolf) ∨ Fearless(brandi))) → (¬Precious(brandi)) ::: If Rolf is several or Brandi is fearless, then Brandi is not precious.\n((¬Jittery(godwin) ∧ Several(conrad))) → (Sour(owen)) ::: If Godwin is not jittery and Conrad is several, then Owen is sour.\n(∀x (Precious(x))) → (∀x (¬Several(x))) ::: Someone who is precious is always not several.\n(¬Fearless(godwin)) ↔ (Several(brandi)) ::: If Godwin is not fearless, then Brandi is several, and vice versa.\n",
                "First-Order-Logic Question": "¬Sour(brandi) ::: Brandi is not sour."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "¬Several(rolf) ::: Rolf is not several.\n¬Precious(sigmund) ::: Sigmund is not precious.\nPrecious(godwin) ::: Godwin is precious.\nFearless(sigmund) ::: Sigmund is fearless.\nPrecious(rolf) ::: Rolf is precious.\n¬Stubborn(rose) ::: Rose is not stubborn.\nJittery(conrad) ::: Conrad is jittery.\n¬Fearless(brandi) ::: Brandi is not fearless.\n¬Sour(brandi) ::: Brandi is not sour.\nJittery(rolf) ::: Rolf is jittery.\nStubborn(owen) ::: Owen is stubborn.\n¬Fearless(godwin) ::: Godwin is not fearless.\n¬∃x(¬(¬(Several(x)))) ::: If there is nobody who is not, then Godwin is not jittery.\n(∃x (Several(x) ∨ ¬Sour(x))) → (¬Stubborn(brandi)) ::: If there is someone who is either several or not sour, then Brandi is not stubborn.\n(∃x (¬Sour(x))) → ((¬Stubborn(owen) ∧ ¬Several(conrad))) ::: If there is at least one people who is not sour, then Owen is not stubborn and Conrad is not several.\n(∀x (Several(x) → ¬Sour(x))) → (∀x (Stubborn(x))) ::: If someone who is several is also not sour, then he is stubborn.\n(∃x (Sour(x) ∨ Jittery(x))) → ((¬Several(brandi) ∧ Stubborn(conrad))) ::: If there is at least one people who is either sour or jittery, then Brandi is not several and Conrad is stubborn.\n(¬Fearless(rolf)) → (¬Jittery(conrad)) ::: If Rolf is not fearless, then Conrad is not jittery.\n(¬Precious(godwin)) → ((Jittery(godwin) ∧ ¬Fearless(owen))) ::: It can be concluded that Godwin is jittery and Owen is not fearless once knowing that Godwin is not precious.\n((¬Jittery(godwin) ∧ ¬Several(sigmund))) → (Precious(sigmund)) ::: It can be concluded that Sigmund is precious once knowing that Godwin is not jittery and Sigmund is not several.\n((Several(rolf) ∨ Fearless(brandi))) → (¬Precious(brandi)) ::: If Rolf is several or Brandi is fearless, then Brandi is not precious.\n((¬Jittery(godwin) ∧ Several(conrad))) → (Sour(owen)) ::: If Godwin is not jittery and Conrad is several, then Owen is sour.\n(∀x (Precious(x))) → (∀x (¬Several(x))) ::: Someone who is precious is always not several.\n(¬Fearless(godwin)) ↔ (Several(brandi)) ::: If Godwin is not fearless, then Brandi is several, and vice versa.\n",
                "First-Order-Logic Question": "¬Sour(brandi) ::: Brandi is not sour."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬x)) → (¬Jittery(godwin)) ::: If there is nobody who is not, then Godwin is not jittery.",
                    "gram": "¬∃x(¬(¬(Several(x)))) ::: If there is nobody who is not, then Godwin is not jittery."
                }
            ],
            "answer": "A",
            "grammar_answer": "A",
            "backup_answer": "A"
        },
        {
            "id": 1210,
            "raw_prog": {
                "First-Order-Logic Rules": "¬Several(rolf) ::: Rolf is not several.\n¬Precious(sigmund) ::: Sigmund is not precious.\nPrecious(godwin) ::: Godwin is precious.\nFearless(sigmund) ::: Sigmund is fearless.\nPrecious(rolf) ::: Rolf is precious.\n¬Stubborn(rose) ::: Rose is not stubborn.\nJittery(conrad) ::: Conrad is jittery.\n¬Fearless(brandi) ::: Brandi is not fearless.\n¬Sour(brandi) ::: Brandi is not sour.\nJittery(rolf) ::: Rolf is jittery.\nStubborn(owen) ::: Owen is stubborn.\n¬Fearless(godwin) ::: Godwin is not fearless.\n(¬∃x (¬x)) → (¬Jittery(godwin)) ::: If there is nobody who is not, then Godwin is not jittery.\n(∃x (Several(x) ∨ ¬Sour(x))) → (¬Stubborn(brandi)) ::: If there is someone who is either several or not sour, then Brandi is not stubborn.\n(∃x (¬Sour(x))) → ((¬Stubborn(owen) ∧ ¬Several(conrad))) ::: If there is at least one people who is not sour, then Owen is not stubborn and Conrad is not several.\n(∀x (Several(x) ∧ ¬Sour(x))) → (∀x (Stubborn(x))) ::: If someone who is several is also not sour, then he is stubborn.\n(∃x (Sour(x) ∨ Jittery(x))) → ((¬Several(brandi) ∧ Stubborn(conrad))) ::: If there is at least one people who is either sour or jittery, then Brandi is not several and Conrad is stubborn.\n(¬Fearless(rolf)) → (¬Jittery(conrad)) ::: If Rolf is not fearless, then Conrad is not jittery.\n(¬Precious(godwin)) → ((Jittery(godwin) ∧ ¬Fearless(owen))) ::: It can be concluded that Godwin is jittery and Owen is not fearless once knowing that Godwin is not precious.\n((¬Jittery(godwin) ∧ ¬Several(sigmund))) → (Precious(sigmund)) ::: It can be concluded that Sigmund is precious once knowing that Godwin is not jittery and Sigmund is not several.\n((Several(rolf) ∨ Fearless(brandi))) → (¬Precious(brandi)) ::: If Rolf is several or Brandi is fearless, then Brandi is not precious.\n((¬Jittery(godwin) ∧ Several(conrad))) → (Sour(owen)) ::: If Godwin is not jittery and Conrad is several, then Owen is sour.\n(∀x (Precious(x))) → (∀x (¬Several(x))) ::: Someone who is precious is always not several.\n(¬Fearless(godwin)) ↔ (Several(brandi)) ::: If Godwin is not fearless, then Brandi is several, and vice versa.\n",
                "First-Order-Logic Question": "¬Precious(rolf) ::: Rolf is not precious."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "¬Several(rolf) ::: Rolf is not several.\n¬Precious(sigmund) ::: Sigmund is not precious.\nPrecious(godwin) ::: Godwin is precious.\nFearless(sigmund) ::: Sigmund is fearless.\nPrecious(rolf) ::: Rolf is precious.\n¬Stubborn(rose) ::: Rose is not stubborn.\nJittery(conrad) ::: Conrad is jittery.\n¬Fearless(brandi) ::: Brandi is not fearless.\n¬Sour(brandi) ::: Brandi is not sour.\nJittery(rolf) ::: Rolf is jittery.\nStubborn(owen) ::: Owen is stubborn.\n¬Fearless(godwin) ::: Godwin is not fearless.\n¬∃x(¬(¬(Several(x)))) ::: If there is nobody who is not, then Godwin is not jittery.\n(∃x (Several(x) ∨ ¬Sour(x))) → (¬Stubborn(brandi)) ::: If there is someone who is either several or not sour, then Brandi is not stubborn.\n(∃x (¬Sour(x))) → ((¬Stubborn(owen) ∧ ¬Several(conrad))) ::: If there is at least one people who is not sour, then Owen is not stubborn and Conrad is not several.\n(∀x (Several(x) ∧ ¬Sour(x))) → (∀x (Stubborn(x))) ::: If someone who is several is also not sour, then he is stubborn.\n(∃x (Sour(x) ∨ Jittery(x))) → ((¬Several(brandi) ∧ Stubborn(conrad))) ::: If there is at least one people who is either sour or jittery, then Brandi is not several and Conrad is stubborn.\n(¬Fearless(rolf)) → (¬Jittery(conrad)) ::: If Rolf is not fearless, then Conrad is not jittery.\n(¬Precious(godwin)) → ((Jittery(godwin) ∧ ¬Fearless(owen))) ::: It can be concluded that Godwin is jittery and Owen is not fearless once knowing that Godwin is not precious.\n((¬Jittery(godwin) ∧ ¬Several(sigmund))) → (Precious(sigmund)) ::: It can be concluded that Sigmund is precious once knowing that Godwin is not jittery and Sigmund is not several.\n((Several(rolf) ∨ Fearless(brandi))) → (¬Precious(brandi)) ::: If Rolf is several or Brandi is fearless, then Brandi is not precious.\n((¬Jittery(godwin) ∧ Several(conrad))) → (Sour(owen)) ::: If Godwin is not jittery and Conrad is several, then Owen is sour.\n(∀x (Precious(x))) → (∀x (¬Several(x))) ::: Someone who is precious is always not several.\n(¬Fearless(godwin)) ↔ (Several(brandi)) ::: If Godwin is not fearless, then Brandi is several, and vice versa.\n",
                "First-Order-Logic Question": "¬Precious(rolf) ::: Rolf is not precious."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬x)) → (¬Jittery(godwin)) ::: If there is nobody who is not, then Godwin is not jittery.",
                    "gram": "¬∃x(¬(¬(Several(x)))) ::: If there is nobody who is not, then Godwin is not jittery."
                }
            ],
            "answer": "B",
            "grammar_answer": "A",
            "backup_answer": "B"
        },
        {
            "id": 1211,
            "raw_prog": {
                "First-Order-Logic Rules": "¬Several(rolf) ::: Rolf is not several.\n¬Precious(sigmund) ::: Sigmund is not precious.\nPrecious(godwin) ::: Godwin is precious.\nFearless(sigmund) ::: Sigmund is fearless.\nPrecious(rolf) ::: Rolf is precious.\n¬Stubborn(rose) ::: Rose is not stubborn.\nJittery(conrad) ::: Conrad is jittery.\n¬Fearless(brandi) ::: Brandi is not fearless.\n¬Sour(brandi) ::: Brandi is not sour.\nJittery(rolf) ::: Rolf is jittery.\nStubborn(owen) ::: Owen is stubborn.\n¬Fearless(godwin) ::: Godwin is not fearless.\n(¬∃x (¬x)) → (¬Jittery(godwin)) ::: If there is nobody who is not, then Godwin is not jittery.\n(∃x (Several(x) ∨ ¬Sour(x))) → (¬Stubborn(brandi)) ::: If there is someone who is either several or not sour, then Brandi is not stubborn.\n(∃x (¬Sour(x))) → ((¬Stubborn(owen) ∧ ¬Several(conrad))) ::: If there is at least one people who is not sour, then Owen is not stubborn and Conrad is not several.\n(∀x (Several(x) ∧ ¬Sour(x))) → (∀x (Stubborn(x))) ::: If someone who is several is also not sour, then he is stubborn.\n(∃x (Sour(x) ∨ Jittery(x))) → ((¬Several(brandi) ∧ Stubborn(conrad))) ::: If there is at least one people who is either sour or jittery, then Brandi is not several and Conrad is stubborn.\n(¬Fearless(rolf)) → (¬Jittery(conrad)) ::: If Rolf is not fearless, then Conrad is not jittery.\n(¬Precious(godwin)) → ((Jittery(godwin) ∧ ¬Fearless(owen))) ::: It can be concluded that Godwin is jittery and Owen is not fearless once knowing that Godwin is not precious.\n((¬Jittery(godwin) ∧ ¬Several(sigmund))) → (Precious(sigmund)) ::: It can be concluded that Sigmund is precious once knowing that Godwin is not jittery and Sigmund is not several.\n((Several(rolf) ∨ Fearless(brandi))) → (¬Precious(brandi)) ::: If Rolf is several or Brandi is fearless, then Brandi is not precious.\n((¬Jittery(godwin) ∧ Several(conrad))) → (Sour(owen)) ::: If Godwin is not jittery and Conrad is several, then Owen is sour.\n(∀x (Precious(x))) → (∀x (¬Several(x))) ::: Someone who is precious is always not several.\n(¬Fearless(godwin)) ↔ (Several(brandi)) ::: If Godwin is not fearless, then Brandi is several, and vice versa.\n",
                "First-Order-Logic Question": "¬Fearless(godwin) ::: Godwin is not fearless."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "¬Several(rolf) ::: Rolf is not several.\n¬Precious(sigmund) ::: Sigmund is not precious.\nPrecious(godwin) ::: Godwin is precious.\nFearless(sigmund) ::: Sigmund is fearless.\nPrecious(rolf) ::: Rolf is precious.\n¬Stubborn(rose) ::: Rose is not stubborn.\nJittery(conrad) ::: Conrad is jittery.\n¬Fearless(brandi) ::: Brandi is not fearless.\n¬Sour(brandi) ::: Brandi is not sour.\nJittery(rolf) ::: Rolf is jittery.\nStubborn(owen) ::: Owen is stubborn.\n¬Fearless(godwin) ::: Godwin is not fearless.\n¬∃x(¬(¬(Several(x)))) ::: If there is nobody who is not, then Godwin is not jittery.\n(∃x (Several(x) ∨ ¬Sour(x))) → (¬Stubborn(brandi)) ::: If there is someone who is either several or not sour, then Brandi is not stubborn.\n(∃x (¬Sour(x))) → ((¬Stubborn(owen) ∧ ¬Several(conrad))) ::: If there is at least one people who is not sour, then Owen is not stubborn and Conrad is not several.\n(∀x (Several(x) ∧ ¬Sour(x))) → (∀x (Stubborn(x))) ::: If someone who is several is also not sour, then he is stubborn.\n(∃x (Sour(x) ∨ Jittery(x))) → ((¬Several(brandi) ∧ Stubborn(conrad))) ::: If there is at least one people who is either sour or jittery, then Brandi is not several and Conrad is stubborn.\n(¬Fearless(rolf)) → (¬Jittery(conrad)) ::: If Rolf is not fearless, then Conrad is not jittery.\n(¬Precious(godwin)) → ((Jittery(godwin) ∧ ¬Fearless(owen))) ::: It can be concluded that Godwin is jittery and Owen is not fearless once knowing that Godwin is not precious.\n((¬Jittery(godwin) ∧ ¬Several(sigmund))) → (Precious(sigmund)) ::: It can be concluded that Sigmund is precious once knowing that Godwin is not jittery and Sigmund is not several.\n((Several(rolf) ∨ Fearless(brandi))) → (¬Precious(brandi)) ::: If Rolf is several or Brandi is fearless, then Brandi is not precious.\n((¬Jittery(godwin) ∧ Several(conrad))) → (Sour(owen)) ::: If Godwin is not jittery and Conrad is several, then Owen is sour.\n(∀x (Precious(x))) → (∀x (¬Several(x))) ::: Someone who is precious is always not several.\n(¬Fearless(godwin)) ↔ (Several(brandi)) ::: If Godwin is not fearless, then Brandi is several, and vice versa.\n",
                "First-Order-Logic Question": "¬Fearless(godwin) ::: Godwin is not fearless."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬x)) → (¬Jittery(godwin)) ::: If there is nobody who is not, then Godwin is not jittery.",
                    "gram": "¬∃x(¬(¬(Several(x)))) ::: If there is nobody who is not, then Godwin is not jittery."
                }
            ],
            "answer": "A",
            "grammar_answer": "A",
            "backup_answer": "A"
        },
        {
            "id": 1212,
            "raw_prog": {
                "First-Order-Logic Rules": "¬Several(rolf) ::: Rolf is not several.\n¬Precious(sigmund) ::: Sigmund is not precious.\nPrecious(godwin) ::: Godwin is precious.\nFearless(sigmund) ::: Sigmund is fearless.\nPrecious(rolf) ::: Rolf is precious.\n¬Stubborn(rose) ::: Rose is not stubborn.\nJittery(conrad) ::: Conrad is jittery.\n¬Fearless(brandi) ::: Brandi is not fearless.\n¬Sour(brandi) ::: Brandi is not sour.\nJittery(rolf) ::: Rolf is jittery.\nStubborn(owen) ::: Owen is stubborn.\n¬Fearless(godwin) ::: Godwin is not fearless.\n(¬∃x (¬x)) → (¬Jittery(godwin)) ::: If there is nobody who is not, then Godwin is not jittery.\n(∃x (Several(x) ∨ ¬Sour(x))) → (¬Stubborn(brandi)) ::: If there is someone who is either several or not sour, then Brandi is not stubborn.\n(∃x (¬Sour(x))) → ((¬Stubborn(owen) ∧ ¬Several(conrad))) ::: If there is at least one people who is not sour, then Owen is not stubborn and Conrad is not several.\n(∀x (Several(x) → ¬Sour(x))) → (∀x (Stubborn(x))) ::: If someone who is several is also not sour, then he is stubborn.\n(∃x (Sour(x) ∨ Jittery(x))) → ((¬Several(brandi) ∧ Stubborn(conrad))) ::: If there is at least one people who is either sour or jittery, then Brandi is not several and Conrad is stubborn.\n(¬Fearless(rolf)) → (¬Jittery(conrad)) ::: If Rolf is not fearless, then Conrad is not jittery.\n((¬Precious(godwin))) → ((Jittery(godwin) ∧ ¬Fearless(owen))) ::: It can be concluded that Godwin is jittery and Owen is not fearless once knowing that Godwin is not precious.\n((¬Jittery(godwin) ∧ ¬Several(sigmund))) → ((Precious(sigmund))) ::: It can be concluded that Sigmund is precious once knowing that Godwin is not jittery and Sigmund is not several.\n((Several(rolf) ∨ Fearless(brandi))) → (¬Precious(brandi)) ::: If Rolf is several or Brandi is fearless, then Brandi is not precious.\n((¬Jittery(godwin) ∧ Several(conrad))) → ((Sour(owen))) ::: If Godwin is not jittery and Conrad is several, then Owen is sour.\n(∀x (Precious(x))) → (∀x (¬Several(x))) ::: Someone who is precious is always not several.\n(¬Fearless(godwin)) ↔ (Several(brandi)) ::: If Godwin is not fearless, then Brandi is several, and vice versa.\n",
                "First-Order-Logic Question": "Jittery(brandi) ::: Brandi is jittery."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "¬Several(rolf) ::: Rolf is not several.\n¬Precious(sigmund) ::: Sigmund is not precious.\nPrecious(godwin) ::: Godwin is precious.\nFearless(sigmund) ::: Sigmund is fearless.\nPrecious(rolf) ::: Rolf is precious.\n¬Stubborn(rose) ::: Rose is not stubborn.\nJittery(conrad) ::: Conrad is jittery.\n¬Fearless(brandi) ::: Brandi is not fearless.\n¬Sour(brandi) ::: Brandi is not sour.\nJittery(rolf) ::: Rolf is jittery.\nStubborn(owen) ::: Owen is stubborn.\n¬Fearless(godwin) ::: Godwin is not fearless.\n¬∃x(¬(¬(Several(x)))) ::: If there is nobody who is not, then Godwin is not jittery.\n(∃x (Several(x) ∨ ¬Sour(x))) → (¬Stubborn(brandi)) ::: If there is someone who is either several or not sour, then Brandi is not stubborn.\n(∃x (¬Sour(x))) → ((¬Stubborn(owen) ∧ ¬Several(conrad))) ::: If there is at least one people who is not sour, then Owen is not stubborn and Conrad is not several.\n(∀x (Several(x) → ¬Sour(x))) → (∀x (Stubborn(x))) ::: If someone who is several is also not sour, then he is stubborn.\n(∃x (Sour(x) ∨ Jittery(x))) → ((¬Several(brandi) ∧ Stubborn(conrad))) ::: If there is at least one people who is either sour or jittery, then Brandi is not several and Conrad is stubborn.\n(¬Fearless(rolf)) → (¬Jittery(conrad)) ::: If Rolf is not fearless, then Conrad is not jittery.\n((¬Precious(godwin))) → ((Jittery(godwin) ∧ ¬Fearless(owen))) ::: It can be concluded that Godwin is jittery and Owen is not fearless once knowing that Godwin is not precious.\n((¬Jittery(godwin) ∧ ¬Several(sigmund))) → ((Precious(sigmund))) ::: It can be concluded that Sigmund is precious once knowing that Godwin is not jittery and Sigmund is not several.\n((Several(rolf) ∨ Fearless(brandi))) → (¬Precious(brandi)) ::: If Rolf is several or Brandi is fearless, then Brandi is not precious.\n((¬Jittery(godwin) ∧ Several(conrad))) → ((Sour(owen))) ::: If Godwin is not jittery and Conrad is several, then Owen is sour.\n(∀x (Precious(x))) → (∀x (¬Several(x))) ::: Someone who is precious is always not several.\n(¬Fearless(godwin)) ↔ (Several(brandi)) ::: If Godwin is not fearless, then Brandi is several, and vice versa.\n",
                "First-Order-Logic Question": "Jittery(brandi) ::: Brandi is jittery."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬x)) → (¬Jittery(godwin)) ::: If there is nobody who is not, then Godwin is not jittery.",
                    "gram": "¬∃x(¬(¬(Several(x)))) ::: If there is nobody who is not, then Godwin is not jittery."
                }
            ],
            "answer": "C",
            "grammar_answer": "A",
            "backup_answer": "C"
        },
        {
            "id": 1213,
            "raw_prog": {
                "First-Order-Logic Rules": "¬Several(rolf) ::: Rolf is not several.\n¬Precious(sigmund) ::: Sigmund is not precious.\nPrecious(godwin) ::: Godwin is precious.\nFearless(sigmund) ::: Sigmund is fearless.\nPrecious(rolf) ::: Rolf is precious.\n¬Stubborn(rose) ::: Rose is not stubborn.\nJittery(conrad) ::: Conrad is jittery.\n¬Fearless(brandi) ::: Brandi is not fearless.\n¬Sour(brandi) ::: Brandi is not sour.\nJittery(rolf) ::: Rolf is jittery.\nStubborn(owen) ::: Owen is stubborn.\n¬Fearless(godwin) ::: Godwin is not fearless.\n(¬∃x (¬x)) → (¬Jittery(godwin)) ::: If there is nobody who is not, then Godwin is not jittery.\n(∃x (Several(x) ∨ ¬Sour(x))) → (¬Stubborn(brandi)) ::: If there is someone who is either several or not sour, then Brandi is not stubborn.\n(∃x (¬Sour(x))) → ((¬Stubborn(owen) ∧ ¬Several(conrad))) ::: If there is at least one people who is not sour, then Owen is not stubborn and Conrad is not several.\n(∀x (Several(x) ∧ ¬Sour(x))) → (∀x (Stubborn(x))) ::: If someone who is several is also not sour, then he is stubborn.\n(∃x (Sour(x) ∨ Jittery(x))) → ((¬Several(brandi) ∧ Stubborn(conrad))) ::: If there is at least one people who is either sour or jittery, then Brandi is not several and Conrad is stubborn.\n(¬Fearless(rolf)) → (¬Jittery(conrad)) ::: If Rolf is not fearless, then Conrad is not jittery.\n(¬Precious(godwin)) → ((Jittery(godwin) ∧ ¬Fearless(owen))) ::: It can be concluded that Godwin is jittery and Owen is not fearless once knowing that Godwin is not precious.\n((¬Jittery(godwin) ∧ ¬Several(sigmund))) → (Precious(sigmund)) ::: It can be concluded that Sigmund is precious once knowing that Godwin is not jittery and Sigmund is not several.\n((Several(rolf) ∨ Fearless(brandi))) → (¬Precious(brandi)) ::: If Rolf is several or Brandi is fearless, then Brandi is not precious.\n((¬Jittery(godwin) ∧ Several(conrad))) → (Sour(owen)) ::: If Godwin is not jittery and Conrad is several, then Owen is sour.\n(∀x (Precious(x))) → (∀x (¬Several(x))) ::: Someone who is precious is always not several.\n(¬Fearless(godwin)) ↔ (Several(brandi)) ::: If Godwin is not fearless, then Brandi is several, and vice versa.\n",
                "First-Order-Logic Question": "¬Precious(godwin) ::: Godwin is not precious."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "¬Several(rolf) ::: Rolf is not several.\n¬Precious(sigmund) ::: Sigmund is not precious.\nPrecious(godwin) ::: Godwin is precious.\nFearless(sigmund) ::: Sigmund is fearless.\nPrecious(rolf) ::: Rolf is precious.\n¬Stubborn(rose) ::: Rose is not stubborn.\nJittery(conrad) ::: Conrad is jittery.\n¬Fearless(brandi) ::: Brandi is not fearless.\n¬Sour(brandi) ::: Brandi is not sour.\nJittery(rolf) ::: Rolf is jittery.\nStubborn(owen) ::: Owen is stubborn.\n¬Fearless(godwin) ::: Godwin is not fearless.\n¬∃x(¬(¬(Several(x)))) ::: If there is nobody who is not, then Godwin is not jittery.\n(∃x (Several(x) ∨ ¬Sour(x))) → (¬Stubborn(brandi)) ::: If there is someone who is either several or not sour, then Brandi is not stubborn.\n(∃x (¬Sour(x))) → ((¬Stubborn(owen) ∧ ¬Several(conrad))) ::: If there is at least one people who is not sour, then Owen is not stubborn and Conrad is not several.\n(∀x (Several(x) ∧ ¬Sour(x))) → (∀x (Stubborn(x))) ::: If someone who is several is also not sour, then he is stubborn.\n(∃x (Sour(x) ∨ Jittery(x))) → ((¬Several(brandi) ∧ Stubborn(conrad))) ::: If there is at least one people who is either sour or jittery, then Brandi is not several and Conrad is stubborn.\n(¬Fearless(rolf)) → (¬Jittery(conrad)) ::: If Rolf is not fearless, then Conrad is not jittery.\n(¬Precious(godwin)) → ((Jittery(godwin) ∧ ¬Fearless(owen))) ::: It can be concluded that Godwin is jittery and Owen is not fearless once knowing that Godwin is not precious.\n((¬Jittery(godwin) ∧ ¬Several(sigmund))) → (Precious(sigmund)) ::: It can be concluded that Sigmund is precious once knowing that Godwin is not jittery and Sigmund is not several.\n((Several(rolf) ∨ Fearless(brandi))) → (¬Precious(brandi)) ::: If Rolf is several or Brandi is fearless, then Brandi is not precious.\n((¬Jittery(godwin) ∧ Several(conrad))) → (Sour(owen)) ::: If Godwin is not jittery and Conrad is several, then Owen is sour.\n(∀x (Precious(x))) → (∀x (¬Several(x))) ::: Someone who is precious is always not several.\n(¬Fearless(godwin)) ↔ (Several(brandi)) ::: If Godwin is not fearless, then Brandi is several, and vice versa.\n",
                "First-Order-Logic Question": "¬Precious(godwin) ::: Godwin is not precious."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬x)) → (¬Jittery(godwin)) ::: If there is nobody who is not, then Godwin is not jittery.",
                    "gram": "¬∃x(¬(¬(Several(x)))) ::: If there is nobody who is not, then Godwin is not jittery."
                }
            ],
            "answer": "B",
            "grammar_answer": "A",
            "backup_answer": "B"
        },
        {
            "id": 1214,
            "raw_prog": {
                "First-Order-Logic Rules": "¬Several(rolf) ::: Rolf is not several.\n¬Precious(sigmund) ::: Sigmund is not precious.\nPrecious(godwin) ::: Godwin is precious.\nFearless(sigmund) ::: Sigmund is fearless.\nPrecious(rolf) ::: Rolf is precious.\n¬Stubborn(rose) ::: Rose is not stubborn.\nJittery(conrad) ::: Conrad is jittery.\n¬Fearless(brandi) ::: Brandi is not fearless.\n¬Sour(brandi) ::: Brandi is not sour.\nJittery(rolf) ::: Rolf is jittery.\nStubborn(owen) ::: Owen is stubborn.\n¬Fearless(godwin) ::: Godwin is not fearless.\n(¬∃x (¬x)) → (¬Jittery(godwin)) ::: If there is nobody who is not, then Godwin is not jittery.\n(∃x (Several(x) ∨ ¬Sour(x))) → (¬Stubborn(brandi)) ::: If there is someone who is either several or not sour, then Brandi is not stubborn.\n(∃x (¬Sour(x))) → ((¬Stubborn(owen) ∧ ¬Several(conrad))) ::: If there is at least one people who is not sour, then Owen is not stubborn and Conrad is not several.\n(∀x (Several(x) ∧ ¬Sour(x))) → (∀x (Stubborn(x))) ::: If someone who is several is also not sour, then he is stubborn.\n(∃x (Sour(x) ∨ Jittery(x))) → ((¬Several(brandi) ∧ Stubborn(conrad))) ::: If there is at least one people who is either sour or jittery, then Brandi is not several and Conrad is stubborn.\n(¬Fearless(rolf)) → (¬Jittery(conrad)) ::: If Rolf is not fearless, then Conrad is not jittery.\n(¬Precious(godwin)) → ((Jittery(godwin) ∧ ¬Fearless(owen))) ::: It can be concluded that Godwin is jittery and Owen is not fearless once knowing that Godwin is not precious.\n((¬Jittery(godwin) ∧ ¬Several(sigmund))) → (Precious(sigmund)) ::: It can be concluded that Sigmund is precious once knowing that Godwin is not jittery and Sigmund is not several.\n((Several(rolf) ∨ Fearless(brandi))) → (¬Precious(brandi)) ::: If Rolf is several or Brandi is fearless, then Brandi is not precious.\n((¬Jittery(godwin) ∧ Several(conrad))) → (Sour(owen)) ::: If Godwin is not jittery and Conrad is several, then Owen is sour.\n(∀x (Precious(x))) → (∀x (¬Several(x))) ::: Someone who is precious is always not several.\n((¬Fearless(godwin))) ↔ ((Several(brandi))) ::: If Godwin is not fearless, then Brandi is several, and vice versa.\n",
                "First-Order-Logic Question": "¬Several(rolf) ::: Rolf is not several."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "¬Several(rolf) ::: Rolf is not several.\n¬Precious(sigmund) ::: Sigmund is not precious.\nPrecious(godwin) ::: Godwin is precious.\nFearless(sigmund) ::: Sigmund is fearless.\nPrecious(rolf) ::: Rolf is precious.\n¬Stubborn(rose) ::: Rose is not stubborn.\nJittery(conrad) ::: Conrad is jittery.\n¬Fearless(brandi) ::: Brandi is not fearless.\n¬Sour(brandi) ::: Brandi is not sour.\nJittery(rolf) ::: Rolf is jittery.\nStubborn(owen) ::: Owen is stubborn.\n¬Fearless(godwin) ::: Godwin is not fearless.\n¬∃x(¬(¬(Several(x)))) ::: If there is nobody who is not, then Godwin is not jittery.\n(∃x (Several(x) ∨ ¬Sour(x))) → (¬Stubborn(brandi)) ::: If there is someone who is either several or not sour, then Brandi is not stubborn.\n(∃x (¬Sour(x))) → ((¬Stubborn(owen) ∧ ¬Several(conrad))) ::: If there is at least one people who is not sour, then Owen is not stubborn and Conrad is not several.\n(∀x (Several(x) ∧ ¬Sour(x))) → (∀x (Stubborn(x))) ::: If someone who is several is also not sour, then he is stubborn.\n(∃x (Sour(x) ∨ Jittery(x))) → ((¬Several(brandi) ∧ Stubborn(conrad))) ::: If there is at least one people who is either sour or jittery, then Brandi is not several and Conrad is stubborn.\n(¬Fearless(rolf)) → (¬Jittery(conrad)) ::: If Rolf is not fearless, then Conrad is not jittery.\n(¬Precious(godwin)) → ((Jittery(godwin) ∧ ¬Fearless(owen))) ::: It can be concluded that Godwin is jittery and Owen is not fearless once knowing that Godwin is not precious.\n((¬Jittery(godwin) ∧ ¬Several(sigmund))) → (Precious(sigmund)) ::: It can be concluded that Sigmund is precious once knowing that Godwin is not jittery and Sigmund is not several.\n((Several(rolf) ∨ Fearless(brandi))) → (¬Precious(brandi)) ::: If Rolf is several or Brandi is fearless, then Brandi is not precious.\n((¬Jittery(godwin) ∧ Several(conrad))) → (Sour(owen)) ::: If Godwin is not jittery and Conrad is several, then Owen is sour.\n(∀x (Precious(x))) → (∀x (¬Several(x))) ::: Someone who is precious is always not several.\n((¬Fearless(godwin))) ↔ ((Several(brandi))) ::: If Godwin is not fearless, then Brandi is several, and vice versa.\n",
                "First-Order-Logic Question": "¬Several(rolf) ::: Rolf is not several."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬x)) → (¬Jittery(godwin)) ::: If there is nobody who is not, then Godwin is not jittery.",
                    "gram": "¬∃x(¬(¬(Several(x)))) ::: If there is nobody who is not, then Godwin is not jittery."
                }
            ],
            "answer": "A",
            "grammar_answer": "A",
            "backup_answer": "A"
        },
        {
            "id": 1245,
            "raw_prog": {
                "First-Order-Logic Rules": "¬Fat(barry) ::: Barry is not fat.\n¬Scared(barry) ::: Barry is not scared.\nFat(roderick) ::: Roderick is fat.\n¬Attractive(rolf) ::: Rolf is not attractive.\n¬Drab(udolf) ::: Udolf is not drab.\n¬Scared(rolf) ::: Rolf is not scared.\n¬Hungry(udolf) ::: Udolf is not hungry.\n¬Wicked(udolf) ::: Udolf is not wicked.\n¬Scared(udolf) ::: Udolf is not scared.\n¬Scared(owen) ::: Owen is not scared.\n¬Hungry(joey) ::: Joey is not hungry.\nWicked(joey) ::: Joey is wicked.\n(∃x (Hungry(x) ∨ ¬Scared(x))) → ((¬Wicked(roderick) ∧ ¬Drab(rolf))) ::: If there is at least one people who is either hungry or not scared, then Roderick is not wicked and Rolf is not drab.\n(¬Scared(barry)) ↔ (¬Attractive(rolf)) ::: Barry being not scared is equivalent to Rolf being not attractive.\n(∃x (¬Drab(x))) → (¬Fat(roderick)) ::: If there is at least one people who is not drab, then Roderick is not fat.\n(¬Wicked(barry)) ↔ ((Fat(christina) ∧ Drab(roderick))) ::: Barry being not wicked is equivalent to Christina being fat and Roderick being drab.\n(∀x (¬Attractive(x) ∧ Fat(x))) → (∀x (Hungry(x))) ::: If someone who is not attractive is also fat, then he is hungry.\n(∀x (¬Hungry(x) ∧ ¬Scared(x))) ↔ (∀x (Attractive(x) ∧ ¬Fat(x))) ::: If someone is not hungry and not scared, then he is both attractive and not fat, and vice versa.\n(∀x (¬Attractive(x))) → (∀x (Hungry(x) ∧ ¬Drab(x))) ::: As long as someone is not attractive, he is hungry and not drab.\n(∀x (Drab(x) ∧ Attractive(x))) ↔ (∀x (Wicked(x) ∧ Hungry(x))) ::: If someone is drab and attractive, then he is both wicked and hungry, and vice versa.\n(¬∃x (¬Hungry(x))) → ((Attractive(udolf) ∧ ¬Wicked(joey))) ::: If there is nobody who is not hungry, then Udolf is attractive and Joey is not wicked.\n(∀x (¬Hungry(x))) → (∀x (¬Attractive(x))) ::: If someone is not hungry, then he is not attractive, and vice versa.\n(∃x (Scared(x) ∧ ¬Fat(x))) → (¬Wicked(christina)) ::: If there is at least one people who is both scared and not fat, then Christina is not wicked.\n(∃x (Fat(x) ∨ ¬Scared(x))) → (¬Wicked(roderick)) ::: If there is someone who is either fat or not scared, then Roderick is not wicked.\n",
                "First-Order-Logic Question": "¬Wicked(joey) ::: Joey is not wicked."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "¬Fat(barry) ::: Barry is not fat.\n¬Scared(barry) ::: Barry is not scared.\nFat(roderick) ::: Roderick is fat.\n¬Attractive(rolf) ::: Rolf is not attractive.\n¬Drab(udolf) ::: Udolf is not drab.\n¬Scared(rolf) ::: Rolf is not scared.\n¬Hungry(udolf) ::: Udolf is not hungry.\n¬Wicked(udolf) ::: Udolf is not wicked.\n¬Scared(udolf) ::: Udolf is not scared.\n¬Scared(owen) ::: Owen is not scared.\n¬Hungry(joey) ::: Joey is not hungry.\nWicked(joey) ::: Joey is wicked.\n(∃x (Hungry(x) ∨ ¬Scared(x))) → ((¬Wicked(roderick) ∧ ¬Drab(rolf))) ::: If there is at least one people who is either hungry or not scared, then Roderick is not wicked and Rolf is not drab.\n(¬Scared(barry)) ↔ (¬Attractive(rolf)) ::: Barry being not scared is equivalent to Rolf being not attractive.\n(∃x (¬Drab(x))) → (¬Fat(roderick)) ::: If there is at least one people who is not drab, then Roderick is not fat.\n(¬Wicked(barry)) ↔ ((Fat(christina) ∧ Drab(roderick))) ::: Barry being not wicked is equivalent to Christina being fat and Roderick being drab.\n(∀x (¬Attractive(x) ∧ Fat(x))) → (∀x (Hungry(x))) ::: If someone who is not attractive is also fat, then he is hungry.\n(∀x (¬Hungry(x) ∧ ¬Scared(x))) ↔ (∀x (Attractive(x) ∧ ¬Fat(x))) ::: If someone is not hungry and not scared, then he is both attractive and not fat, and vice versa.\n(∀x (¬Attractive(x))) → (∀x (Hungry(x) ∧ ¬Drab(x))) ::: As long as someone is not attractive, he is hungry and not drab.\n(∀x (Drab(x) ∧ Attractive(x))) ↔ (∀x (Wicked(x) ∧ Hungry(x))) ::: If someone is drab and attractive, then he is both wicked and hungry, and vice versa.\n¬∃x(¬Hungry(x))→((Attractive(x))) ::: If there is nobody who is not hungry, then Udolf is attractive and Joey is not wicked.\n(∀x (¬Hungry(x))) → (∀x (¬Attractive(x))) ::: If someone is not hungry, then he is not attractive, and vice versa.\n(∃x (Scared(x) ∧ ¬Fat(x))) → (¬Wicked(christina)) ::: If there is at least one people who is both scared and not fat, then Christina is not wicked.\n(∃x (Fat(x) ∨ ¬Scared(x))) → (¬Wicked(roderick)) ::: If there is someone who is either fat or not scared, then Roderick is not wicked.\n",
                "First-Order-Logic Question": "¬Wicked(joey) ::: Joey is not wicked."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬Hungry(x))) → ((Attractive(udolf) ∧ ¬Wicked(joey))) ::: If there is nobody who is not hungry, then Udolf is attractive and Joey is not wicked.",
                    "gram": "¬∃x(¬Hungry(x))→((Attractive(x))) ::: If there is nobody who is not hungry, then Udolf is attractive and Joey is not wicked."
                }
            ],
            "answer": "B",
            "grammar_answer": "A",
            "backup_answer": "B"
        },
        {
            "id": 1246,
            "raw_prog": {
                "First-Order-Logic Rules": "¬Fat(barry) ::: Barry is not fat.\n¬Scared(barry) ::: Barry is not scared.\nFat(roderick) ::: Roderick is fat.\n¬Attractive(rolf) ::: Rolf is not attractive.\n¬Drab(udolf) ::: Udolf is not drab.\n¬Scared(rolf) ::: Rolf is not scared.\n¬Hungry(udolf) ::: Udolf is not hungry.\n¬Wicked(udolf) ::: Udolf is not wicked.\n¬Scared(udolf) ::: Udolf is not scared.\n¬Scared(owen) ::: Owen is not scared.\n¬Hungry(joey) ::: Joey is not hungry.\nWicked(joey) ::: Joey is wicked.\n(∃x (Hungry(x) ∨ ¬Scared(x))) → ((¬Wicked(roderick) ∧ ¬Drab(rolf))) ::: If there is at least one people who is either hungry or not scared, then Roderick is not wicked and Rolf is not drab.\n((¬Scared(barry))) ↔ ((¬Attractive(rolf))) ::: Barry being not scared is equivalent to Rolf being not attractive.\n(∃x (¬Drab(x))) → ((¬Fat(roderick))) ::: If there is at least one people who is not drab, then Roderick is not fat.\n((¬Wicked(barry))) ↔ ((Fat(christina) ∧ Drab(roderick))) ::: Barry being not wicked is equivalent to Christina being fat and Roderick being drab.\n(∀x (¬Attractive(x) ∧ Fat(x))) → (∀x (Hungry(x))) ::: If someone who is not attractive is also fat, then he is hungry.\n(∀x (¬Hungry(x) ∧ ¬Scared(x))) ↔ (∀x (Attractive(x) ∧ ¬Fat(x))) ::: If someone is not hungry and not scared, then he is both attractive and not fat, and vice versa.\n(∀x (¬Attractive(x))) → (∀x (Hungry(x) ∧ ¬Drab(x))) ::: As long as someone is not attractive, he is hungry and not drab.\n(∀x (Drab(x) ∧ Attractive(x))) ↔ (∀x (Wicked(x) ∧ Hungry(x))) ::: If someone is drab and attractive, then he is both wicked and hungry, and vice versa.\n(¬∃x (¬Hungry(x))) → ((Attractive(udolf) ∧ ¬Wicked(joey))) ::: If there is nobody who is not hungry, then Udolf is attractive and Joey is not wicked.\n(∀x (¬Hungry(x))) → (∀x (¬Attractive(x))) ::: If someone is not hungry, then he is not attractive, and vice versa.\n(∃x (Scared(x) ∧ ¬Fat(x))) → ((¬Wicked(christina))) ::: If there is at least one people who is both scared and not fat, then Christina is not wicked.\n(∃x (Fat(x) ∨ ¬Scared(x))) → ((¬Wicked(roderick))) ::: If there is someone who is either fat or not scared, then Roderick is not wicked.\n",
                "First-Order-Logic Question": "Wicked(roderick) ::: Roderick is wicked."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "¬Fat(barry) ::: Barry is not fat.\n¬Scared(barry) ::: Barry is not scared.\nFat(roderick) ::: Roderick is fat.\n¬Attractive(rolf) ::: Rolf is not attractive.\n¬Drab(udolf) ::: Udolf is not drab.\n¬Scared(rolf) ::: Rolf is not scared.\n¬Hungry(udolf) ::: Udolf is not hungry.\n¬Wicked(udolf) ::: Udolf is not wicked.\n¬Scared(udolf) ::: Udolf is not scared.\n¬Scared(owen) ::: Owen is not scared.\n¬Hungry(joey) ::: Joey is not hungry.\nWicked(joey) ::: Joey is wicked.\n(∃x (Hungry(x) ∨ ¬Scared(x))) → ((¬Wicked(roderick) ∧ ¬Drab(rolf))) ::: If there is at least one people who is either hungry or not scared, then Roderick is not wicked and Rolf is not drab.\n((¬Scared(barry))) ↔ ((¬Attractive(rolf))) ::: Barry being not scared is equivalent to Rolf being not attractive.\n(∃x (¬Drab(x))) → ((¬Fat(roderick))) ::: If there is at least one people who is not drab, then Roderick is not fat.\n((¬Wicked(barry))) ↔ ((Fat(christina) ∧ Drab(roderick))) ::: Barry being not wicked is equivalent to Christina being fat and Roderick being drab.\n(∀x (¬Attractive(x) ∧ Fat(x))) → (∀x (Hungry(x))) ::: If someone who is not attractive is also fat, then he is hungry.\n(∀x (¬Hungry(x) ∧ ¬Scared(x))) ↔ (∀x (Attractive(x) ∧ ¬Fat(x))) ::: If someone is not hungry and not scared, then he is both attractive and not fat, and vice versa.\n(∀x (¬Attractive(x))) → (∀x (Hungry(x) ∧ ¬Drab(x))) ::: As long as someone is not attractive, he is hungry and not drab.\n(∀x (Drab(x) ∧ Attractive(x))) ↔ (∀x (Wicked(x) ∧ Hungry(x))) ::: If someone is drab and attractive, then he is both wicked and hungry, and vice versa.\n¬∃x(¬Hungry(x))→((Attractive(x))) ::: If there is nobody who is not hungry, then Udolf is attractive and Joey is not wicked.\n(∀x (¬Hungry(x))) → (∀x (¬Attractive(x))) ::: If someone is not hungry, then he is not attractive, and vice versa.\n(∃x (Scared(x) ∧ ¬Fat(x))) → ((¬Wicked(christina))) ::: If there is at least one people who is both scared and not fat, then Christina is not wicked.\n(∃x (Fat(x) ∨ ¬Scared(x))) → ((¬Wicked(roderick))) ::: If there is someone who is either fat or not scared, then Roderick is not wicked.\n",
                "First-Order-Logic Question": "Wicked(roderick) ::: Roderick is wicked."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬Hungry(x))) → ((Attractive(udolf) ∧ ¬Wicked(joey))) ::: If there is nobody who is not hungry, then Udolf is attractive and Joey is not wicked.",
                    "gram": "¬∃x(¬Hungry(x))→((Attractive(x))) ::: If there is nobody who is not hungry, then Udolf is attractive and Joey is not wicked."
                }
            ],
            "answer": "B",
            "grammar_answer": "A",
            "backup_answer": "B"
        },
        {
            "id": 1247,
            "raw_prog": {
                "First-Order-Logic Rules": "¬Fat(barry) ::: Barry is not fat.\n¬Scared(barry) ::: Barry is not scared.\nFat(roderick) ::: Roderick is fat.\n¬Attractive(rolf) ::: Rolf is not attractive.\n¬Drab(udolf) ::: Udolf is not drab.\n¬Scared(rolf) ::: Rolf is not scared.\n¬Hungry(udolf) ::: Udolf is not hungry.\n¬Wicked(udolf) ::: Udolf is not wicked.\n¬Scared(udolf) ::: Udolf is not scared.\n¬Scared(owen) ::: Owen is not scared.\n¬Hungry(joey) ::: Joey is not hungry.\nWicked(joey) ::: Joey is wicked.\n(∃x (Hungry(x) ∨ ¬Scared(x))) → ((¬Wicked(roderick) ∧ ¬Drab(rolf))) ::: If there is at least one people who is either hungry or not scared, then Roderick is not wicked and Rolf is not drab.\n((¬Scared(barry))) ↔ ((¬Attractive(rolf))) ::: Barry being not scared is equivalent to Rolf being not attractive.\n(∃x (¬Drab(x))) → ((¬Fat(roderick))) ::: If there is at least one people who is not drab, then Roderick is not fat.\n((¬Wicked(barry))) ↔ ((Fat(christina) ∧ Drab(roderick))) ::: Barry being not wicked is equivalent to Christina being fat and Roderick being drab.\n(∀x (¬Attractive(x) ∧ Fat(x))) → (∀x (Hungry(x))) ::: If someone who is not attractive is also fat, then he is hungry.\n(∀x (¬Hungry(x) ∧ ¬Scared(x))) ↔ (∀x (Attractive(x) ∧ ¬Fat(x))) ::: If someone is not hungry and not scared, then he is both attractive and not fat, and vice versa.\n(∀x (¬Attractive(x))) → (∀x (Hungry(x) ∧ ¬Drab(x))) ::: As long as someone is not attractive, he is hungry and not drab.\n(∀x (Drab(x) ∧ Attractive(x))) ↔ (∀x (Wicked(x) ∧ Hungry(x))) ::: If someone is drab and attractive, then he is both wicked and hungry, and vice versa.\n(¬∃x (¬Hungry(x))) → ((Attractive(udolf) ∧ ¬Wicked(joey))) ::: If there is nobody who is not hungry, then Udolf is attractive and Joey is not wicked.\n(∀x (¬Hungry(x))) → (∀x (¬Attractive(x))) ::: If someone is not hungry, then he is not attractive, and vice versa.\n(∃x (Scared(x) ∧ ¬Fat(x))) → ((¬Wicked(christina))) ::: If there is at least one people who is both scared and not fat, then Christina is not wicked.\n(∃x (Fat(x) ∨ ¬Scared(x))) → ((¬Wicked(roderick))) ::: If there is someone who is either fat or not scared, then Roderick is not wicked.\n",
                "First-Order-Logic Question": "¬Scared(udolf) ::: Udolf is not scared."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "¬Fat(barry) ::: Barry is not fat.\n¬Scared(barry) ::: Barry is not scared.\nFat(roderick) ::: Roderick is fat.\n¬Attractive(rolf) ::: Rolf is not attractive.\n¬Drab(udolf) ::: Udolf is not drab.\n¬Scared(rolf) ::: Rolf is not scared.\n¬Hungry(udolf) ::: Udolf is not hungry.\n¬Wicked(udolf) ::: Udolf is not wicked.\n¬Scared(udolf) ::: Udolf is not scared.\n¬Scared(owen) ::: Owen is not scared.\n¬Hungry(joey) ::: Joey is not hungry.\nWicked(joey) ::: Joey is wicked.\n(∃x (Hungry(x) ∨ ¬Scared(x))) → ((¬Wicked(roderick) ∧ ¬Drab(rolf))) ::: If there is at least one people who is either hungry or not scared, then Roderick is not wicked and Rolf is not drab.\n((¬Scared(barry))) ↔ ((¬Attractive(rolf))) ::: Barry being not scared is equivalent to Rolf being not attractive.\n(∃x (¬Drab(x))) → ((¬Fat(roderick))) ::: If there is at least one people who is not drab, then Roderick is not fat.\n((¬Wicked(barry))) ↔ ((Fat(christina) ∧ Drab(roderick))) ::: Barry being not wicked is equivalent to Christina being fat and Roderick being drab.\n(∀x (¬Attractive(x) ∧ Fat(x))) → (∀x (Hungry(x))) ::: If someone who is not attractive is also fat, then he is hungry.\n(∀x (¬Hungry(x) ∧ ¬Scared(x))) ↔ (∀x (Attractive(x) ∧ ¬Fat(x))) ::: If someone is not hungry and not scared, then he is both attractive and not fat, and vice versa.\n(∀x (¬Attractive(x))) → (∀x (Hungry(x) ∧ ¬Drab(x))) ::: As long as someone is not attractive, he is hungry and not drab.\n(∀x (Drab(x) ∧ Attractive(x))) ↔ (∀x (Wicked(x) ∧ Hungry(x))) ::: If someone is drab and attractive, then he is both wicked and hungry, and vice versa.\n¬∃x(¬Hungry(x))→((Attractive(x))) ::: If there is nobody who is not hungry, then Udolf is attractive and Joey is not wicked.\n(∀x (¬Hungry(x))) → (∀x (¬Attractive(x))) ::: If someone is not hungry, then he is not attractive, and vice versa.\n(∃x (Scared(x) ∧ ¬Fat(x))) → ((¬Wicked(christina))) ::: If there is at least one people who is both scared and not fat, then Christina is not wicked.\n(∃x (Fat(x) ∨ ¬Scared(x))) → ((¬Wicked(roderick))) ::: If there is someone who is either fat or not scared, then Roderick is not wicked.\n",
                "First-Order-Logic Question": "¬Scared(udolf) ::: Udolf is not scared."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬Hungry(x))) → ((Attractive(udolf) ∧ ¬Wicked(joey))) ::: If there is nobody who is not hungry, then Udolf is attractive and Joey is not wicked.",
                    "gram": "¬∃x(¬Hungry(x))→((Attractive(x))) ::: If there is nobody who is not hungry, then Udolf is attractive and Joey is not wicked."
                }
            ],
            "answer": "A",
            "grammar_answer": "A",
            "backup_answer": "A"
        },
        {
            "id": 1248,
            "raw_prog": {
                "First-Order-Logic Rules": "¬Fat(barry) ::: Barry is not fat.\n¬Scared(barry) ::: Barry is not scared.\nFat(roderick) ::: Roderick is fat.\n¬Attractive(rolf) ::: Rolf is not attractive.\n¬Drab(udolf) ::: Udolf is not drab.\n¬Scared(rolf) ::: Rolf is not scared.\n¬Hungry(udolf) ::: Udolf is not hungry.\n¬Wicked(udolf) ::: Udolf is not wicked.\n¬Scared(udolf) ::: Udolf is not scared.\n¬Scared(owen) ::: Owen is not scared.\n¬Hungry(joey) ::: Joey is not hungry.\nWicked(joey) ::: Joey is wicked.\n(∃x (Hungry(x) ∨ ¬Scared(x))) → ((¬Wicked(roderick) ∧ ¬Drab(rolf))) ::: If there is at least one people who is either hungry or not scared, then Roderick is not wicked and Rolf is not drab.\n((¬Scared(barry))) ↔ ((¬Attractive(rolf))) ::: Barry being not scared is equivalent to Rolf being not attractive.\n(∃x (¬Drab(x))) → ((¬Fat(roderick))) ::: If there is at least one people who is not drab, then Roderick is not fat.\n((¬Wicked(barry))) ↔ ((Fat(christina) ∧ Drab(roderick))) ::: Barry being not wicked is equivalent to Christina being fat and Roderick being drab.\n(∀x (¬Attractive(x) ∧ Fat(x))) → (∀x (Hungry(x))) ::: If someone who is not attractive is also fat, then he is hungry.\n(∀x (¬Hungry(x) ∧ ¬Scared(x))) ↔ (∀x (Attractive(x) ∧ ¬Fat(x))) ::: If someone is not hungry and not scared, then he is both attractive and not fat, and vice versa.\n(∀x (¬Attractive(x))) → (∀x (Hungry(x) ∧ ¬Drab(x))) ::: As long as someone is not attractive, he is hungry and not drab.\n(∀x (Drab(x) ∧ Attractive(x))) ↔ (∀x (Wicked(x) ∧ Hungry(x))) ::: If someone is drab and attractive, then he is both wicked and hungry, and vice versa.\n(¬∃x (¬Hungry(x))) → ((Attractive(udolf) ∧ ¬Wicked(joey))) ::: If there is nobody who is not hungry, then Udolf is attractive and Joey is not wicked.\n(∀x (¬Hungry(x))) → (∀x (¬Attractive(x))) ::: If someone is not hungry, then he is not attractive, and vice versa.\n(∃x (Scared(x) ∧ ¬Fat(x))) → ((¬Wicked(christina))) ::: If there is at least one people who is both scared and not fat, then Christina is not wicked.\n(∃x (Fat(x) ∨ ¬Scared(x))) → ((¬Wicked(roderick))) ::: If there is someone who is either fat or not scared, then Roderick is not wicked.\n",
                "First-Order-Logic Question": "Fat(udolf) ::: Udolf is fat."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "¬Fat(barry) ::: Barry is not fat.\n¬Scared(barry) ::: Barry is not scared.\nFat(roderick) ::: Roderick is fat.\n¬Attractive(rolf) ::: Rolf is not attractive.\n¬Drab(udolf) ::: Udolf is not drab.\n¬Scared(rolf) ::: Rolf is not scared.\n¬Hungry(udolf) ::: Udolf is not hungry.\n¬Wicked(udolf) ::: Udolf is not wicked.\n¬Scared(udolf) ::: Udolf is not scared.\n¬Scared(owen) ::: Owen is not scared.\n¬Hungry(joey) ::: Joey is not hungry.\nWicked(joey) ::: Joey is wicked.\n(∃x (Hungry(x) ∨ ¬Scared(x))) → ((¬Wicked(roderick) ∧ ¬Drab(rolf))) ::: If there is at least one people who is either hungry or not scared, then Roderick is not wicked and Rolf is not drab.\n((¬Scared(barry))) ↔ ((¬Attractive(rolf))) ::: Barry being not scared is equivalent to Rolf being not attractive.\n(∃x (¬Drab(x))) → ((¬Fat(roderick))) ::: If there is at least one people who is not drab, then Roderick is not fat.\n((¬Wicked(barry))) ↔ ((Fat(christina) ∧ Drab(roderick))) ::: Barry being not wicked is equivalent to Christina being fat and Roderick being drab.\n(∀x (¬Attractive(x) ∧ Fat(x))) → (∀x (Hungry(x))) ::: If someone who is not attractive is also fat, then he is hungry.\n(∀x (¬Hungry(x) ∧ ¬Scared(x))) ↔ (∀x (Attractive(x) ∧ ¬Fat(x))) ::: If someone is not hungry and not scared, then he is both attractive and not fat, and vice versa.\n(∀x (¬Attractive(x))) → (∀x (Hungry(x) ∧ ¬Drab(x))) ::: As long as someone is not attractive, he is hungry and not drab.\n(∀x (Drab(x) ∧ Attractive(x))) ↔ (∀x (Wicked(x) ∧ Hungry(x))) ::: If someone is drab and attractive, then he is both wicked and hungry, and vice versa.\n¬∃x(¬Hungry(x))→((Attractive(x))) ::: If there is nobody who is not hungry, then Udolf is attractive and Joey is not wicked.\n(∀x (¬Hungry(x))) → (∀x (¬Attractive(x))) ::: If someone is not hungry, then he is not attractive, and vice versa.\n(∃x (Scared(x) ∧ ¬Fat(x))) → ((¬Wicked(christina))) ::: If there is at least one people who is both scared and not fat, then Christina is not wicked.\n(∃x (Fat(x) ∨ ¬Scared(x))) → ((¬Wicked(roderick))) ::: If there is someone who is either fat or not scared, then Roderick is not wicked.\n",
                "First-Order-Logic Question": "Fat(udolf) ::: Udolf is fat."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬Hungry(x))) → ((Attractive(udolf) ∧ ¬Wicked(joey))) ::: If there is nobody who is not hungry, then Udolf is attractive and Joey is not wicked.",
                    "gram": "¬∃x(¬Hungry(x))→((Attractive(x))) ::: If there is nobody who is not hungry, then Udolf is attractive and Joey is not wicked."
                }
            ],
            "answer": "B",
            "grammar_answer": "A",
            "backup_answer": "C"
        },
        {
            "id": 1249,
            "raw_prog": {
                "First-Order-Logic Rules": "¬Fat(barry) ::: Barry is not fat.\n¬Scared(barry) ::: Barry is not scared.\nFat(roderick) ::: Roderick is fat.\n¬Attractive(rolf) ::: Rolf is not attractive.\n¬Drab(udolf) ::: Udolf is not drab.\n¬Scared(rolf) ::: Rolf is not scared.\n¬Hungry(udolf) ::: Udolf is not hungry.\n¬Wicked(udolf) ::: Udolf is not wicked.\n¬Scared(udolf) ::: Udolf is not scared.\n¬Scared(owen) ::: Owen is not scared.\n¬Hungry(joey) ::: Joey is not hungry.\nWicked(joey) ::: Joey is wicked.\n(∃x (Hungry(x) ∨ ¬Scared(x))) → ((¬Wicked(roderick) ∧ ¬Drab(rolf))) ::: If there is at least one people who is either hungry or not scared, then Roderick is not wicked and Rolf is not drab.\n(¬Scared(barry)) ↔ (¬Attractive(rolf)) ::: Barry being not scared is equivalent to Rolf being not attractive.\n(∃x (¬Drab(x))) → (¬Fat(roderick)) ::: If there is at least one people who is not drab, then Roderick is not fat.\n(¬Wicked(barry)) ↔ ((Fat(christina) ∧ Drab(roderick))) ::: Barry being not wicked is equivalent to Christina being fat and Roderick being drab.\n(∀x (¬Attractive(x) ∧ Fat(x))) → (∀x (Hungry(x))) ::: If someone who is not attractive is also fat, then he is hungry.\n(∀x (¬Hungry(x) ∧ ¬Scared(x))) ↔ (∀x (Attractive(x) ∧ ¬Fat(x))) ::: If someone is not hungry and not scared, then he is both attractive and not fat, and vice versa.\n(∀x (¬Attractive(x))) → (∀x (Hungry(x) ∧ ¬Drab(x))) ::: As long as someone is not attractive, he is hungry and not drab.\n(∀x (Drab(x) ∧ Attractive(x))) ↔ (∀x (Wicked(x) ∧ Hungry(x))) ::: If someone is drab and attractive, then he is both wicked and hungry, and vice versa.\n(¬∃x (¬Hungry(x))) → ((Attractive(udolf) ∧ ¬Wicked(joey))) ::: If there is nobody who is not hungry, then Udolf is attractive and Joey is not wicked.\n(∀x (¬Hungry(x))) → (∀x (¬Attractive(x))) ::: If someone is not hungry, then he is not attractive, and vice versa.\n(∃x (Scared(x) ∧ ¬Fat(x))) → (¬Wicked(christina)) ::: If there is at least one people who is both scared and not fat, then Christina is not wicked.\n(∃x (Fat(x) ∨ ¬Scared(x))) → (¬Wicked(roderick)) ::: If there is someone who is either fat or not scared, then Roderick is not wicked.\n",
                "First-Order-Logic Question": "¬Wicked(roderick) ::: Roderick is not wicked."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "¬Fat(barry) ::: Barry is not fat.\n¬Scared(barry) ::: Barry is not scared.\nFat(roderick) ::: Roderick is fat.\n¬Attractive(rolf) ::: Rolf is not attractive.\n¬Drab(udolf) ::: Udolf is not drab.\n¬Scared(rolf) ::: Rolf is not scared.\n¬Hungry(udolf) ::: Udolf is not hungry.\n¬Wicked(udolf) ::: Udolf is not wicked.\n¬Scared(udolf) ::: Udolf is not scared.\n¬Scared(owen) ::: Owen is not scared.\n¬Hungry(joey) ::: Joey is not hungry.\nWicked(joey) ::: Joey is wicked.\n(∃x (Hungry(x) ∨ ¬Scared(x))) → ((¬Wicked(roderick) ∧ ¬Drab(rolf))) ::: If there is at least one people who is either hungry or not scared, then Roderick is not wicked and Rolf is not drab.\n(¬Scared(barry)) ↔ (¬Attractive(rolf)) ::: Barry being not scared is equivalent to Rolf being not attractive.\n(∃x (¬Drab(x))) → (¬Fat(roderick)) ::: If there is at least one people who is not drab, then Roderick is not fat.\n(¬Wicked(barry)) ↔ ((Fat(christina) ∧ Drab(roderick))) ::: Barry being not wicked is equivalent to Christina being fat and Roderick being drab.\n(∀x (¬Attractive(x) ∧ Fat(x))) → (∀x (Hungry(x))) ::: If someone who is not attractive is also fat, then he is hungry.\n(∀x (¬Hungry(x) ∧ ¬Scared(x))) ↔ (∀x (Attractive(x) ∧ ¬Fat(x))) ::: If someone is not hungry and not scared, then he is both attractive and not fat, and vice versa.\n(∀x (¬Attractive(x))) → (∀x (Hungry(x) ∧ ¬Drab(x))) ::: As long as someone is not attractive, he is hungry and not drab.\n(∀x (Drab(x) ∧ Attractive(x))) ↔ (∀x (Wicked(x) ∧ Hungry(x))) ::: If someone is drab and attractive, then he is both wicked and hungry, and vice versa.\n¬∃x(¬Hungry(x))→((Attractive(x))) ::: If there is nobody who is not hungry, then Udolf is attractive and Joey is not wicked.\n(∀x (¬Hungry(x))) → (∀x (¬Attractive(x))) ::: If someone is not hungry, then he is not attractive, and vice versa.\n(∃x (Scared(x) ∧ ¬Fat(x))) → (¬Wicked(christina)) ::: If there is at least one people who is both scared and not fat, then Christina is not wicked.\n(∃x (Fat(x) ∨ ¬Scared(x))) → (¬Wicked(roderick)) ::: If there is someone who is either fat or not scared, then Roderick is not wicked.\n",
                "First-Order-Logic Question": "¬Wicked(roderick) ::: Roderick is not wicked."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬Hungry(x))) → ((Attractive(udolf) ∧ ¬Wicked(joey))) ::: If there is nobody who is not hungry, then Udolf is attractive and Joey is not wicked.",
                    "gram": "¬∃x(¬Hungry(x))→((Attractive(x))) ::: If there is nobody who is not hungry, then Udolf is attractive and Joey is not wicked."
                }
            ],
            "answer": "A",
            "grammar_answer": "A",
            "backup_answer": "A"
        },
        {
            "id": 1250,
            "raw_prog": {
                "First-Order-Logic Rules": "¬Fat(barry) ::: Barry is not fat.\n¬Scared(barry) ::: Barry is not scared.\nFat(roderick) ::: Roderick is fat.\n¬Attractive(rolf) ::: Rolf is not attractive.\n¬Drab(udolf) ::: Udolf is not drab.\n¬Scared(rolf) ::: Rolf is not scared.\n¬Hungry(udolf) ::: Udolf is not hungry.\n¬Wicked(udolf) ::: Udolf is not wicked.\n¬Scared(udolf) ::: Udolf is not scared.\n¬Scared(owen) ::: Owen is not scared.\n¬Hungry(joey) ::: Joey is not hungry.\nWicked(joey) ::: Joey is wicked.\n(∃x (Hungry(x) ∨ ¬Scared(x))) → ((¬Wicked(roderick) ∧ ¬Drab(rolf))) ::: If there is at least one people who is either hungry or not scared, then Roderick is not wicked and Rolf is not drab.\n((¬Scared(barry))) ↔ ((¬Attractive(rolf))) ::: Barry being not scared is equivalent to Rolf being not attractive.\n(∃x (¬Drab(x))) → ((¬Fat(roderick))) ::: If there is at least one people who is not drab, then Roderick is not fat.\n((¬Wicked(barry))) ↔ ((Fat(christina) ∧ Drab(roderick))) ::: Barry being not wicked is equivalent to Christina being fat and Roderick being drab.\n(∀x (¬Attractive(x) ∧ Fat(x))) → (∀x (Hungry(x))) ::: If someone who is not attractive is also fat, then he is hungry.\n(∀x (¬Hungry(x) ∧ ¬Scared(x))) ↔ (∀x (Attractive(x) ∧ ¬Fat(x))) ::: If someone is not hungry and not scared, then he is both attractive and not fat, and vice versa.\n(∀x (¬Attractive(x))) → (∀x (Hungry(x) ∧ ¬Drab(x))) ::: As long as someone is not attractive, he is hungry and not drab.\n(∀x (Drab(x) ∧ Attractive(x))) ↔ (∀x (Wicked(x) ∧ Hungry(x))) ::: If someone is drab and attractive, then he is both wicked and hungry, and vice versa.\n(¬∃x (¬Hungry(x))) → ((Attractive(udolf) ∧ ¬Wicked(joey))) ::: If there is nobody who is not hungry, then Udolf is attractive and Joey is not wicked.\n(∀x (¬Hungry(x))) → (∀x (¬Attractive(x))) ::: If someone is not hungry, then he is not attractive, and vice versa.\n(∃x (Scared(x) ∧ ¬Fat(x))) → ((¬Wicked(christina))) ::: If there is at least one people who is both scared and not fat, then Christina is not wicked.\n(∃x (Fat(x) ∨ ¬Scared(x))) → ((¬Wicked(roderick))) ::: If there is someone who is either fat or not scared, then Roderick is not wicked.\n",
                "First-Order-Logic Question": "¬Fat(joey) ::: Joey is not fat."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "¬Fat(barry) ::: Barry is not fat.\n¬Scared(barry) ::: Barry is not scared.\nFat(roderick) ::: Roderick is fat.\n¬Attractive(rolf) ::: Rolf is not attractive.\n¬Drab(udolf) ::: Udolf is not drab.\n¬Scared(rolf) ::: Rolf is not scared.\n¬Hungry(udolf) ::: Udolf is not hungry.\n¬Wicked(udolf) ::: Udolf is not wicked.\n¬Scared(udolf) ::: Udolf is not scared.\n¬Scared(owen) ::: Owen is not scared.\n¬Hungry(joey) ::: Joey is not hungry.\nWicked(joey) ::: Joey is wicked.\n(∃x (Hungry(x) ∨ ¬Scared(x))) → ((¬Wicked(roderick) ∧ ¬Drab(rolf))) ::: If there is at least one people who is either hungry or not scared, then Roderick is not wicked and Rolf is not drab.\n((¬Scared(barry))) ↔ ((¬Attractive(rolf))) ::: Barry being not scared is equivalent to Rolf being not attractive.\n(∃x (¬Drab(x))) → ((¬Fat(roderick))) ::: If there is at least one people who is not drab, then Roderick is not fat.\n((¬Wicked(barry))) ↔ ((Fat(christina) ∧ Drab(roderick))) ::: Barry being not wicked is equivalent to Christina being fat and Roderick being drab.\n(∀x (¬Attractive(x) ∧ Fat(x))) → (∀x (Hungry(x))) ::: If someone who is not attractive is also fat, then he is hungry.\n(∀x (¬Hungry(x) ∧ ¬Scared(x))) ↔ (∀x (Attractive(x) ∧ ¬Fat(x))) ::: If someone is not hungry and not scared, then he is both attractive and not fat, and vice versa.\n(∀x (¬Attractive(x))) → (∀x (Hungry(x) ∧ ¬Drab(x))) ::: As long as someone is not attractive, he is hungry and not drab.\n(∀x (Drab(x) ∧ Attractive(x))) ↔ (∀x (Wicked(x) ∧ Hungry(x))) ::: If someone is drab and attractive, then he is both wicked and hungry, and vice versa.\n¬∃x(¬Hungry(x))→((Attractive(x))) ::: If there is nobody who is not hungry, then Udolf is attractive and Joey is not wicked.\n(∀x (¬Hungry(x))) → (∀x (¬Attractive(x))) ::: If someone is not hungry, then he is not attractive, and vice versa.\n(∃x (Scared(x) ∧ ¬Fat(x))) → ((¬Wicked(christina))) ::: If there is at least one people who is both scared and not fat, then Christina is not wicked.\n(∃x (Fat(x) ∨ ¬Scared(x))) → ((¬Wicked(roderick))) ::: If there is someone who is either fat or not scared, then Roderick is not wicked.\n",
                "First-Order-Logic Question": "¬Fat(joey) ::: Joey is not fat."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬Hungry(x))) → ((Attractive(udolf) ∧ ¬Wicked(joey))) ::: If there is nobody who is not hungry, then Udolf is attractive and Joey is not wicked.",
                    "gram": "¬∃x(¬Hungry(x))→((Attractive(x))) ::: If there is nobody who is not hungry, then Udolf is attractive and Joey is not wicked."
                }
            ],
            "answer": "C",
            "grammar_answer": "A",
            "backup_answer": "A"
        },
        {
            "id": 1251,
            "raw_prog": {
                "First-Order-Logic Rules": "¬Fat(barry) ::: Barry is not fat.\n¬Scared(barry) ::: Barry is not scared.\nFat(roderick) ::: Roderick is fat.\n¬Attractive(rolf) ::: Rolf is not attractive.\n¬Drab(udolf) ::: Udolf is not drab.\n¬Scared(rolf) ::: Rolf is not scared.\n¬Hungry(udolf) ::: Udolf is not hungry.\n¬Wicked(udolf) ::: Udolf is not wicked.\n¬Scared(udolf) ::: Udolf is not scared.\n¬Scared(owen) ::: Owen is not scared.\n¬Hungry(joey) ::: Joey is not hungry.\nWicked(joey) ::: Joey is wicked.\n(∃x (Hungry(x) ∨ ¬Scared(x))) → ((¬Wicked(roderick) ∧ ¬Drab(rolf))) ::: If there is at least one people who is either hungry or not scared, then Roderick is not wicked and Rolf is not drab.\n(¬Scared(barry)) ↔ (¬Attractive(rolf)) ::: Barry being not scared is equivalent to Rolf being not attractive.\n(∃x (¬Drab(x))) → (¬Fat(roderick)) ::: If there is at least one people who is not drab, then Roderick is not fat.\n(¬Wicked(barry)) ↔ ((Fat(christina) ∧ Drab(roderick))) ::: Barry being not wicked is equivalent to Christina being fat and Roderick being drab.\n(∀x (¬Attractive(x) ∧ Fat(x))) → (∀x (Hungry(x))) ::: If someone who is not attractive is also fat, then he is hungry.\n(∀x (¬Hungry(x) ∧ ¬Scared(x))) ↔ (∀x (Attractive(x) ∧ ¬Fat(x))) ::: If someone is not hungry and not scared, then he is both attractive and not fat, and vice versa.\n(∀x (¬Attractive(x))) → (∀x (Hungry(x) ∧ ¬Drab(x))) ::: As long as someone is not attractive, he is hungry and not drab.\n(∀x (Drab(x) ∧ Attractive(x))) ↔ (∀x (Wicked(x) ∧ Hungry(x))) ::: If someone is drab and attractive, then he is both wicked and hungry, and vice versa.\n(¬∃x (¬Hungry(x))) → ((Attractive(udolf) ∧ ¬Wicked(joey))) ::: If there is nobody who is not hungry, then Udolf is attractive and Joey is not wicked.\n(∀x (¬Hungry(x))) → (∀x (¬Attractive(x))) ::: If someone is not hungry, then he is not attractive, and vice versa.\n(∃x (Scared(x) ∧ ¬Fat(x))) → (¬Wicked(christina)) ::: If there is at least one people who is both scared and not fat, then Christina is not wicked.\n(∃x (Fat(x) ∨ ¬Scared(x))) → (¬Wicked(roderick)) ::: If there is someone who is either fat or not scared, then Roderick is not wicked.\n",
                "First-Order-Logic Question": "¬Scared(barry) ::: Barry is not scared."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "¬Fat(barry) ::: Barry is not fat.\n¬Scared(barry) ::: Barry is not scared.\nFat(roderick) ::: Roderick is fat.\n¬Attractive(rolf) ::: Rolf is not attractive.\n¬Drab(udolf) ::: Udolf is not drab.\n¬Scared(rolf) ::: Rolf is not scared.\n¬Hungry(udolf) ::: Udolf is not hungry.\n¬Wicked(udolf) ::: Udolf is not wicked.\n¬Scared(udolf) ::: Udolf is not scared.\n¬Scared(owen) ::: Owen is not scared.\n¬Hungry(joey) ::: Joey is not hungry.\nWicked(joey) ::: Joey is wicked.\n(∃x (Hungry(x) ∨ ¬Scared(x))) → ((¬Wicked(roderick) ∧ ¬Drab(rolf))) ::: If there is at least one people who is either hungry or not scared, then Roderick is not wicked and Rolf is not drab.\n(¬Scared(barry)) ↔ (¬Attractive(rolf)) ::: Barry being not scared is equivalent to Rolf being not attractive.\n(∃x (¬Drab(x))) → (¬Fat(roderick)) ::: If there is at least one people who is not drab, then Roderick is not fat.\n(¬Wicked(barry)) ↔ ((Fat(christina) ∧ Drab(roderick))) ::: Barry being not wicked is equivalent to Christina being fat and Roderick being drab.\n(∀x (¬Attractive(x) ∧ Fat(x))) → (∀x (Hungry(x))) ::: If someone who is not attractive is also fat, then he is hungry.\n(∀x (¬Hungry(x) ∧ ¬Scared(x))) ↔ (∀x (Attractive(x) ∧ ¬Fat(x))) ::: If someone is not hungry and not scared, then he is both attractive and not fat, and vice versa.\n(∀x (¬Attractive(x))) → (∀x (Hungry(x) ∧ ¬Drab(x))) ::: As long as someone is not attractive, he is hungry and not drab.\n(∀x (Drab(x) ∧ Attractive(x))) ↔ (∀x (Wicked(x) ∧ Hungry(x))) ::: If someone is drab and attractive, then he is both wicked and hungry, and vice versa.\n¬∃x(¬Hungry(x))→((Attractive(x))) ::: If there is nobody who is not hungry, then Udolf is attractive and Joey is not wicked.\n(∀x (¬Hungry(x))) → (∀x (¬Attractive(x))) ::: If someone is not hungry, then he is not attractive, and vice versa.\n(∃x (Scared(x) ∧ ¬Fat(x))) → (¬Wicked(christina)) ::: If there is at least one people who is both scared and not fat, then Christina is not wicked.\n(∃x (Fat(x) ∨ ¬Scared(x))) → (¬Wicked(roderick)) ::: If there is someone who is either fat or not scared, then Roderick is not wicked.\n",
                "First-Order-Logic Question": "¬Scared(barry) ::: Barry is not scared."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬Hungry(x))) → ((Attractive(udolf) ∧ ¬Wicked(joey))) ::: If there is nobody who is not hungry, then Udolf is attractive and Joey is not wicked.",
                    "gram": "¬∃x(¬Hungry(x))→((Attractive(x))) ::: If there is nobody who is not hungry, then Udolf is attractive and Joey is not wicked."
                }
            ],
            "answer": "A",
            "grammar_answer": "A",
            "backup_answer": "A"
        },
        {
            "id": 1252,
            "raw_prog": {
                "First-Order-Logic Rules": "¬Fat(barry) ::: Barry is not fat.\n¬Scared(barry) ::: Barry is not scared.\nFat(roderick) ::: Roderick is fat.\n¬Attractive(rolf) ::: Rolf is not attractive.\n¬Drab(udolf) ::: Udolf is not drab.\n¬Scared(rolf) ::: Rolf is not scared.\n¬Hungry(udolf) ::: Udolf is not hungry.\n¬Wicked(udolf) ::: Udolf is not wicked.\n¬Scared(udolf) ::: Udolf is not scared.\n¬Scared(owen) ::: Owen is not scared.\n¬Hungry(joey) ::: Joey is not hungry.\nWicked(joey) ::: Joey is wicked.\n(∃x (Hungry(x) ∨ ¬Scared(x))) → ((¬Wicked(roderick) ∧ ¬Drab(rolf))) ::: If there is at least one people who is either hungry or not scared, then Roderick is not wicked and Rolf is not drab.\n(¬Scared(barry)) ↔ (¬Attractive(rolf)) ::: Barry being not scared is equivalent to Rolf being not attractive.\n(∃x (¬Drab(x))) → (¬Fat(roderick)) ::: If there is at least one people who is not drab, then Roderick is not fat.\n(¬Wicked(barry)) ↔ ((Fat(christina) ∧ Drab(roderick))) ::: Barry being not wicked is equivalent to Christina being fat and Roderick being drab.\n(∀x (¬Attractive(x) ∧ Fat(x))) → (∀x (Hungry(x))) ::: If someone who is not attractive is also fat, then he is hungry.\n(∀x (¬Hungry(x) ∧ ¬Scared(x))) ↔ (∀x (Attractive(x) ∧ ¬Fat(x))) ::: If someone is not hungry and not scared, then he is both attractive and not fat, and vice versa.\n(∀x (¬Attractive(x))) → (∀x (Hungry(x) ∧ ¬Drab(x))) ::: As long as someone is not attractive, he is hungry and not drab.\n(∀x (Drab(x) ∧ Attractive(x))) ↔ (∀x (Wicked(x) ∧ Hungry(x))) ::: If someone is drab and attractive, then he is both wicked and hungry, and vice versa.\n(¬∃x (¬Hungry(x))) → ((Attractive(udolf) ∧ ¬Wicked(joey))) ::: If there is nobody who is not hungry, then Udolf is attractive and Joey is not wicked.\n(∀x (¬Hungry(x))) → (∀x (¬Attractive(x))) ::: If someone is not hungry, then he is not attractive, and vice versa.\n(∃x (Scared(x) ∧ ¬Fat(x))) → (¬Wicked(christina)) ::: If there is at least one people who is both scared and not fat, then Christina is not wicked.\n(∃x (Fat(x) ∨ ¬Scared(x))) → (¬Wicked(roderick)) ::: If there is someone who is either fat or not scared, then Roderick is not wicked.\n",
                "First-Order-Logic Question": "Fat(barry) ::: Barry is fat."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "¬Fat(barry) ::: Barry is not fat.\n¬Scared(barry) ::: Barry is not scared.\nFat(roderick) ::: Roderick is fat.\n¬Attractive(rolf) ::: Rolf is not attractive.\n¬Drab(udolf) ::: Udolf is not drab.\n¬Scared(rolf) ::: Rolf is not scared.\n¬Hungry(udolf) ::: Udolf is not hungry.\n¬Wicked(udolf) ::: Udolf is not wicked.\n¬Scared(udolf) ::: Udolf is not scared.\n¬Scared(owen) ::: Owen is not scared.\n¬Hungry(joey) ::: Joey is not hungry.\nWicked(joey) ::: Joey is wicked.\n(∃x (Hungry(x) ∨ ¬Scared(x))) → ((¬Wicked(roderick) ∧ ¬Drab(rolf))) ::: If there is at least one people who is either hungry or not scared, then Roderick is not wicked and Rolf is not drab.\n(¬Scared(barry)) ↔ (¬Attractive(rolf)) ::: Barry being not scared is equivalent to Rolf being not attractive.\n(∃x (¬Drab(x))) → (¬Fat(roderick)) ::: If there is at least one people who is not drab, then Roderick is not fat.\n(¬Wicked(barry)) ↔ ((Fat(christina) ∧ Drab(roderick))) ::: Barry being not wicked is equivalent to Christina being fat and Roderick being drab.\n(∀x (¬Attractive(x) ∧ Fat(x))) → (∀x (Hungry(x))) ::: If someone who is not attractive is also fat, then he is hungry.\n(∀x (¬Hungry(x) ∧ ¬Scared(x))) ↔ (∀x (Attractive(x) ∧ ¬Fat(x))) ::: If someone is not hungry and not scared, then he is both attractive and not fat, and vice versa.\n(∀x (¬Attractive(x))) → (∀x (Hungry(x) ∧ ¬Drab(x))) ::: As long as someone is not attractive, he is hungry and not drab.\n(∀x (Drab(x) ∧ Attractive(x))) ↔ (∀x (Wicked(x) ∧ Hungry(x))) ::: If someone is drab and attractive, then he is both wicked and hungry, and vice versa.\n¬∃x(¬Hungry(x))→((Attractive(x))) ::: If there is nobody who is not hungry, then Udolf is attractive and Joey is not wicked.\n(∀x (¬Hungry(x))) → (∀x (¬Attractive(x))) ::: If someone is not hungry, then he is not attractive, and vice versa.\n(∃x (Scared(x) ∧ ¬Fat(x))) → (¬Wicked(christina)) ::: If there is at least one people who is both scared and not fat, then Christina is not wicked.\n(∃x (Fat(x) ∨ ¬Scared(x))) → (¬Wicked(roderick)) ::: If there is someone who is either fat or not scared, then Roderick is not wicked.\n",
                "First-Order-Logic Question": "Fat(barry) ::: Barry is fat."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬Hungry(x))) → ((Attractive(udolf) ∧ ¬Wicked(joey))) ::: If there is nobody who is not hungry, then Udolf is attractive and Joey is not wicked.",
                    "gram": "¬∃x(¬Hungry(x))→((Attractive(x))) ::: If there is nobody who is not hungry, then Udolf is attractive and Joey is not wicked."
                }
            ],
            "answer": "B",
            "grammar_answer": "A",
            "backup_answer": "B"
        },
        {
            "id": 1253,
            "raw_prog": {
                "First-Order-Logic Rules": [
                    "¬Fat(barry) ::: Barry is not fat.",
                    "¬Scared(barry) ::: Barry is not scared.",
                    "Fat(roderick) ::: Roderick is fat.",
                    "¬Attractive(rolf) ::: Rolf is not attractive.",
                    "¬Drab(udolf) ::: Udolf is not drab.",
                    "¬Scared(rolf) ::: Rolf is not scared.",
                    "¬Hungry(udolf) ::: Udolf is not hungry.",
                    "¬Wicked(udolf) ::: Udolf is not wicked.",
                    "¬Scared(udolf) ::: Udolf is not scared.",
                    "¬Scared(owen) ::: Owen is not scared.",
                    "¬Hungry(joey) ::: Joey is not hungry.",
                    "Wicked(joey) ::: Joey is wicked.",
                    "(∃x (Hungry(x) ∨ ¬Scared(x))) → (¬Wicked(roderick) ∧ ¬Drab(rolf)) ::: If there is at least one people who is either hungry or not scared, then Roderick is not wicked and Rolf is not drab.",
                    "(¬Scared(barry)) ↔ (¬Attractive(rolf)) ::: Barry being not scared is equivalent to Rolf being not attractive.",
                    "(∃x (¬Drab(x))) → (¬Fat(roderick)) ::: If there is at least one people who is not drab, then Roderick is not fat.",
                    "(¬Wicked(barry)) ↔ (Fat(christina) ∧ Drab(roderick)) ::: Barry being not wicked is equivalent to Christina being fat and Roderick being drab.",
                    "(∀x (¬Attractive(x) ∧ Fat(x))) → (∀x (Hungry(x))) ::: If someone who is not attractive is also fat, then he is hungry.",
                    "(∀x (¬Hungry(x) ∧ ¬Scared(x))) ↔ (∀x (Attractive(x) ∧ ¬Fat(x))) ::: If someone is not hungry and not scared, then he is both attractive and not fat, and vice versa.",
                    "(∀x (¬Attractive(x))) → (∀x (Hungry(x) ∧ ¬Drab(x))) ::: As long as someone is not attractive, he is hungry and not drab.",
                    "(∀x (Drab(x) ∧ Attractive(x))) ↔ (∀x (Wicked(x) ∧ Hungry(x))) ::: If someone is drab and attractive, then he is both wicked and hungry, and vice versa.",
                    "(¬∃x (¬Hungry(x))) → (Attractive(udolf) ∧ ¬Wicked(joey)) ::: If there is nobody who is not hungry, then Udolf is attractive and Joey is not wicked.",
                    "(∀x (¬Hungry(x))) → (∀x (¬Attractive(x))) ::: If someone is not hungry, then he is not attractive, and vice versa.",
                    "(∃x (Scared(x) ∧ ¬Fat(x))) → (¬Wicked(christina)) ::: If there is at least one people who is both scared and not fat, then Christina is not wicked.",
                    "(∃x (Fat(x) ∨ ¬Scared(x))) → (¬Wicked(roderick)) ::: If there is someone who is either fat or not scared, then Roderick is not wicked."
                ],
                "First-Order-Logic Question": "¬Fat(udolf) ::: Udolf is not fat."
            },
            "gram_prog": {
                "First-Order-Logic Rules": [
                    "¬Fat(barry) ::: Barry is not fat.",
                    "¬Scared(barry) ::: Barry is not scared.",
                    "Fat(roderick) ::: Roderick is fat.",
                    "¬Attractive(rolf) ::: Rolf is not attractive.",
                    "¬Drab(udolf) ::: Udolf is not drab.",
                    "¬Scared(rolf) ::: Rolf is not scared.",
                    "¬Hungry(udolf) ::: Udolf is not hungry.",
                    "¬Wicked(udolf) ::: Udolf is not wicked.",
                    "¬Scared(udolf) ::: Udolf is not scared.",
                    "¬Scared(owen) ::: Owen is not scared.",
                    "¬Hungry(joey) ::: Joey is not hungry.",
                    "Wicked(joey) ::: Joey is wicked.",
                    "(∃x (Hungry(x) ∨ ¬Scared(x))) → (¬Wicked(roderick) ∧ ¬Drab(rolf)) ::: If there is at least one people who is either hungry or not scared, then Roderick is not wicked and Rolf is not drab.",
                    "(¬Scared(barry)) ↔ (¬Attractive(rolf)) ::: Barry being not scared is equivalent to Rolf being not attractive.",
                    "(∃x (¬Drab(x))) → (¬Fat(roderick)) ::: If there is at least one people who is not drab, then Roderick is not fat.",
                    "(¬Wicked(barry)) ↔ (Fat(christina) ∧ Drab(roderick)) ::: Barry being not wicked is equivalent to Christina being fat and Roderick being drab.",
                    "(∀x (¬Attractive(x) ∧ Fat(x))) → (∀x (Hungry(x))) ::: If someone who is not attractive is also fat, then he is hungry.",
                    "(∀x (¬Hungry(x) ∧ ¬Scared(x))) ↔ (∀x (Attractive(x) ∧ ¬Fat(x))) ::: If someone is not hungry and not scared, then he is both attractive and not fat, and vice versa.",
                    "(∀x (¬Attractive(x))) → (∀x (Hungry(x) ∧ ¬Drab(x))) ::: As long as someone is not attractive, he is hungry and not drab.",
                    "(∀x (Drab(x) ∧ Attractive(x))) ↔ (∀x (Wicked(x) ∧ Hungry(x))) ::: If someone is drab and attractive, then he is both wicked and hungry, and vice versa.",
                    "¬∃x(¬Hungry(x))→(Attractive(x)∧¬Wicked(x)) ::: If there is nobody who is not hungry, then Udolf is attractive and Joey is not wicked.",
                    "(∀x (¬Hungry(x))) → (∀x (¬Attractive(x))) ::: If someone is not hungry, then he is not attractive, and vice versa.",
                    "(∃x (Scared(x) ∧ ¬Fat(x))) → (¬Wicked(christina)) ::: If there is at least one people who is both scared and not fat, then Christina is not wicked.",
                    "(∃x (Fat(x) ∨ ¬Scared(x))) → (¬Wicked(roderick)) ::: If there is someone who is either fat or not scared, then Roderick is not wicked."
                ],
                "First-Order-Logic Question": "¬Fat(udolf) ::: Udolf is not fat."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬Hungry(x))) → (Attractive(udolf) ∧ ¬Wicked(joey)) ::: If there is nobody who is not hungry, then Udolf is attractive and Joey is not wicked.",
                    "gram": "¬∃x(¬Hungry(x))→(Attractive(x)∧¬Wicked(x)) ::: If there is nobody who is not hungry, then Udolf is attractive and Joey is not wicked."
                }
            ],
            "answer": "A",
            "grammar_answer": "A",
            "backup_answer": "A"
        },
        {
            "id": 1254,
            "raw_prog": {
                "First-Order-Logic Rules": [
                    "¬Fat(barry) ::: Barry is not fat.",
                    "¬Scared(barry) ::: Barry is not scared.",
                    "Fat(roderick) ::: Roderick is fat.",
                    "¬Attractive(rolf) ::: Rolf is not attractive.",
                    "¬Drab(udolf) ::: Udolf is not drab.",
                    "¬Scared(rolf) ::: Rolf is not scared.",
                    "¬Hungry(udolf) ::: Udolf is not hungry.",
                    "¬Wicked(udolf) ::: Udolf is not wicked.",
                    "¬Scared(udolf) ::: Udolf is not scared.",
                    "¬Scared(owen) ::: Owen is not scared.",
                    "¬Hungry(joey) ::: Joey is not hungry.",
                    "Wicked(joey) ::: Joey is wicked.",
                    "(∃x (Hungry(x) ∨ ¬Scared(x))) → (¬Wicked(roderick) ∧ ¬Drab(rolf)) ::: If there is at least one people who is either hungry or not scared, then Roderick is not wicked and Rolf is not drab.",
                    "¬Scared(barry) ↔ ¬Attractive(rolf) ::: Barry being not scared is equivalent to Rolf being not attractive.",
                    "(∃x (¬Drab(x))) → (¬Fat(roderick)) ::: If there is at least one people who is not drab, then Roderick is not fat.",
                    "¬Wicked(barry) ↔ (Fat(christina) ∧ Drab(roderick)) ::: Barry being not wicked is equivalent to Christina being fat and Roderick being drab.",
                    "(∀x (¬Attractive(x) ∧ Fat(x))) → (∀x (Hungry(x))) ::: If someone who is not attractive is also fat, then he is hungry.",
                    "(∀x (¬Hungry(x) ∧ ¬Scared(x))) ↔ (∀x (Attractive(x) ∧ ¬Fat(x))) ::: If someone is not hungry and not scared, then he is both attractive and not fat, and vice versa.",
                    "(∀x (¬Attractive(x))) → (∀x (Hungry(x) ∧ ¬Drab(x))) ::: As long as someone is not attractive, he is hungry and not drab.",
                    "(∀x (Drab(x) ∧ Attractive(x))) ↔ (∀x (Wicked(x) ∧ Hungry(x))) ::: If someone is drab and attractive, then he is both wicked and hungry, and vice versa.",
                    "(¬∃x (¬Hungry(x))) → (Attractive(udolf) ∧ ¬Wicked(joey)) ::: If there is nobody who is not hungry, then Udolf is attractive and Joey is not wicked.",
                    "(∀x (¬Hungry(x))) → (∀x (¬Attractive(x))) ::: If someone is not hungry, then he is not attractive, and vice versa.",
                    "(∃x (Scared(x) ∧ ¬Fat(x))) → (¬Wicked(christina)) ::: If there is at least one people who is both scared and not fat, then Christina is not wicked.",
                    "(∃x (Fat(x) ∨ ¬Scared(x))) → (¬Wicked(roderick)) ::: If there is someone who is either fat or not scared, then Roderick is not wicked."
                ],
                "First-Order-Logic Question": "¬Hungry(barry) ::: Barry is not hungry."
            },
            "gram_prog": {
                "First-Order-Logic Rules": [
                    "¬Fat(barry) ::: Barry is not fat.",
                    "¬Scared(barry) ::: Barry is not scared.",
                    "Fat(roderick) ::: Roderick is fat.",
                    "¬Attractive(rolf) ::: Rolf is not attractive.",
                    "¬Drab(udolf) ::: Udolf is not drab.",
                    "¬Scared(rolf) ::: Rolf is not scared.",
                    "¬Hungry(udolf) ::: Udolf is not hungry.",
                    "¬Wicked(udolf) ::: Udolf is not wicked.",
                    "¬Scared(udolf) ::: Udolf is not scared.",
                    "¬Scared(owen) ::: Owen is not scared.",
                    "¬Hungry(joey) ::: Joey is not hungry.",
                    "Wicked(joey) ::: Joey is wicked.",
                    "(∃x (Hungry(x) ∨ ¬Scared(x))) → (¬Wicked(roderick) ∧ ¬Drab(rolf)) ::: If there is at least one people who is either hungry or not scared, then Roderick is not wicked and Rolf is not drab.",
                    "¬Scared(barry) ↔ ¬Attractive(rolf) ::: Barry being not scared is equivalent to Rolf being not attractive.",
                    "(∃x (¬Drab(x))) → (¬Fat(roderick)) ::: If there is at least one people who is not drab, then Roderick is not fat.",
                    "¬Wicked(barry) ↔ (Fat(christina) ∧ Drab(roderick)) ::: Barry being not wicked is equivalent to Christina being fat and Roderick being drab.",
                    "(∀x (¬Attractive(x) ∧ Fat(x))) → (∀x (Hungry(x))) ::: If someone who is not attractive is also fat, then he is hungry.",
                    "(∀x (¬Hungry(x) ∧ ¬Scared(x))) ↔ (∀x (Attractive(x) ∧ ¬Fat(x))) ::: If someone is not hungry and not scared, then he is both attractive and not fat, and vice versa.",
                    "(∀x (¬Attractive(x))) → (∀x (Hungry(x) ∧ ¬Drab(x))) ::: As long as someone is not attractive, he is hungry and not drab.",
                    "(∀x (Drab(x) ∧ Attractive(x))) ↔ (∀x (Wicked(x) ∧ Hungry(x))) ::: If someone is drab and attractive, then he is both wicked and hungry, and vice versa.",
                    "¬∃x(¬Hungry(x))→(Attractive(x)∧¬Wicked(x)) ::: If there is nobody who is not hungry, then Udolf is attractive and Joey is not wicked.",
                    "(∀x (¬Hungry(x))) → (∀x (¬Attractive(x))) ::: If someone is not hungry, then he is not attractive, and vice versa.",
                    "(∃x (Scared(x) ∧ ¬Fat(x))) → (¬Wicked(christina)) ::: If there is at least one people who is both scared and not fat, then Christina is not wicked.",
                    "(∃x (Fat(x) ∨ ¬Scared(x))) → (¬Wicked(roderick)) ::: If there is someone who is either fat or not scared, then Roderick is not wicked."
                ],
                "First-Order-Logic Question": "¬Hungry(barry) ::: Barry is not hungry."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬Hungry(x))) → (Attractive(udolf) ∧ ¬Wicked(joey)) ::: If there is nobody who is not hungry, then Udolf is attractive and Joey is not wicked.",
                    "gram": "¬∃x(¬Hungry(x))→(Attractive(x)∧¬Wicked(x)) ::: If there is nobody who is not hungry, then Udolf is attractive and Joey is not wicked."
                }
            ],
            "answer": "C",
            "grammar_answer": "A",
            "backup_answer": "A"
        },
        {
            "id": 1255,
            "raw_prog": {
                "First-Order-Logic Rules": "¬Fat(barry) ::: Barry is not fat.\n¬Scared(barry) ::: Barry is not scared.\nFat(roderick) ::: Roderick is fat.\n¬Attractive(rolf) ::: Rolf is not attractive.\n¬Drab(udolf) ::: Udolf is not drab.\n¬Scared(rolf) ::: Rolf is not scared.\n¬Hungry(udolf) ::: Udolf is not hungry.\n¬Wicked(udolf) ::: Udolf is not wicked.\n¬Scared(udolf) ::: Udolf is not scared.\n¬Scared(owen) ::: Owen is not scared.\n¬Hungry(joey) ::: Joey is not hungry.\nWicked(joey) ::: Joey is wicked.\n(∃x (Hungry(x) ∨ ¬Scared(x))) → ((¬Wicked(roderick) ∧ ¬Drab(rolf))) ::: If there is at least one people who is either hungry or not scared, then Roderick is not wicked and Rolf is not drab.\n(¬Scared(barry)) ↔ (¬Attractive(rolf)) ::: Barry being not scared is equivalent to Rolf being not attractive.\n(∃x (¬Drab(x))) → (¬Fat(roderick)) ::: If there is at least one people who is not drab, then Roderick is not fat.\n(¬Wicked(barry)) ↔ ((Fat(christina) ∧ Drab(roderick))) ::: Barry being not wicked is equivalent to Christina being fat and Roderick being drab.\n(∀x (¬Attractive(x) ∧ Fat(x))) → (∀x (Hungry(x))) ::: If someone who is not attractive is also fat, then he is hungry.\n(∀x (¬Hungry(x) ∧ ¬Scared(x))) ↔ (∀x (Attractive(x) ∧ ¬Fat(x))) ::: If someone is not hungry and not scared, then he is both attractive and not fat, and vice versa.\n(∀x (¬Attractive(x))) → (∀x (Hungry(x) ∧ ¬Drab(x))) ::: As long as someone is not attractive, he is hungry and not drab.\n(∀x (Drab(x) ∧ Attractive(x))) ↔ (∀x (Wicked(x) ∧ Hungry(x))) ::: If someone is drab and attractive, then he is both wicked and hungry, and vice versa.\n(¬∃x (¬Hungry(x))) → ((Attractive(udolf) ∧ ¬Wicked(joey))) ::: If there is nobody who is not hungry, then Udolf is attractive and Joey is not wicked.\n(∀x (¬Hungry(x))) → (∀x (¬Attractive(x))) ::: If someone is not hungry, then he is not attractive, and vice versa.\n(∃x (Scared(x) ∧ ¬Fat(x))) → (¬Wicked(christina)) ::: If there is at least one people who is both scared and not fat, then Christina is not wicked.\n(∃x (Fat(x) ∨ ¬Scared(x))) → (¬Wicked(roderick)) ::: If there is someone who is either fat or not scared, then Roderick is not wicked.\n",
                "First-Order-Logic Question": "¬Fat(rolf) ::: Rolf is not fat."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "¬Fat(barry) ::: Barry is not fat.\n¬Scared(barry) ::: Barry is not scared.\nFat(roderick) ::: Roderick is fat.\n¬Attractive(rolf) ::: Rolf is not attractive.\n¬Drab(udolf) ::: Udolf is not drab.\n¬Scared(rolf) ::: Rolf is not scared.\n¬Hungry(udolf) ::: Udolf is not hungry.\n¬Wicked(udolf) ::: Udolf is not wicked.\n¬Scared(udolf) ::: Udolf is not scared.\n¬Scared(owen) ::: Owen is not scared.\n¬Hungry(joey) ::: Joey is not hungry.\nWicked(joey) ::: Joey is wicked.\n(∃x (Hungry(x) ∨ ¬Scared(x))) → ((¬Wicked(roderick) ∧ ¬Drab(rolf))) ::: If there is at least one people who is either hungry or not scared, then Roderick is not wicked and Rolf is not drab.\n(¬Scared(barry)) ↔ (¬Attractive(rolf)) ::: Barry being not scared is equivalent to Rolf being not attractive.\n(∃x (¬Drab(x))) → (¬Fat(roderick)) ::: If there is at least one people who is not drab, then Roderick is not fat.\n(¬Wicked(barry)) ↔ ((Fat(christina) ∧ Drab(roderick))) ::: Barry being not wicked is equivalent to Christina being fat and Roderick being drab.\n(∀x (¬Attractive(x) ∧ Fat(x))) → (∀x (Hungry(x))) ::: If someone who is not attractive is also fat, then he is hungry.\n(∀x (¬Hungry(x) ∧ ¬Scared(x))) ↔ (∀x (Attractive(x) ∧ ¬Fat(x))) ::: If someone is not hungry and not scared, then he is both attractive and not fat, and vice versa.\n(∀x (¬Attractive(x))) → (∀x (Hungry(x) ∧ ¬Drab(x))) ::: As long as someone is not attractive, he is hungry and not drab.\n(∀x (Drab(x) ∧ Attractive(x))) ↔ (∀x (Wicked(x) ∧ Hungry(x))) ::: If someone is drab and attractive, then he is both wicked and hungry, and vice versa.\n¬∃x(¬Hungry(x))→((Attractive(x))) ::: If there is nobody who is not hungry, then Udolf is attractive and Joey is not wicked.\n(∀x (¬Hungry(x))) → (∀x (¬Attractive(x))) ::: If someone is not hungry, then he is not attractive, and vice versa.\n(∃x (Scared(x) ∧ ¬Fat(x))) → (¬Wicked(christina)) ::: If there is at least one people who is both scared and not fat, then Christina is not wicked.\n(∃x (Fat(x) ∨ ¬Scared(x))) → (¬Wicked(roderick)) ::: If there is someone who is either fat or not scared, then Roderick is not wicked.\n",
                "First-Order-Logic Question": "¬Fat(rolf) ::: Rolf is not fat."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬Hungry(x))) → ((Attractive(udolf) ∧ ¬Wicked(joey))) ::: If there is nobody who is not hungry, then Udolf is attractive and Joey is not wicked.",
                    "gram": "¬∃x(¬Hungry(x))→((Attractive(x))) ::: If there is nobody who is not hungry, then Udolf is attractive and Joey is not wicked."
                }
            ],
            "answer": "A",
            "grammar_answer": "A",
            "backup_answer": "C"
        },
        {
            "id": 1256,
            "raw_prog": {
                "First-Order-Logic Rules": "¬Fat(barry) ::: Barry is not fat.\n¬Scared(barry) ::: Barry is not scared.\nFat(roderick) ::: Roderick is fat.\n¬Attractive(rolf) ::: Rolf is not attractive.\n¬Drab(udolf) ::: Udolf is not drab.\n¬Scared(rolf) ::: Rolf is not scared.\n¬Hungry(udolf) ::: Udolf is not hungry.\n¬Wicked(udolf) ::: Udolf is not wicked.\n¬Scared(udolf) ::: Udolf is not scared.\n¬Scared(owen) ::: Owen is not scared.\n¬Hungry(joey) ::: Joey is not hungry.\nWicked(joey) ::: Joey is wicked.\n(∃x (Hungry(x) ∨ ¬Scared(x))) → ((¬Wicked(roderick) ∧ ¬Drab(rolf))) ::: If there is at least one people who is either hungry or not scared, then Roderick is not wicked and Rolf is not drab.\n(¬Scared(barry)) ↔ (¬Attractive(rolf)) ::: Barry being not scared is equivalent to Rolf being not attractive.\n(∃x (¬Drab(x))) → (¬Fat(roderick)) ::: If there is at least one people who is not drab, then Roderick is not fat.\n(¬Wicked(barry)) ↔ ((Fat(christina) ∧ Drab(roderick))) ::: Barry being not wicked is equivalent to Christina being fat and Roderick being drab.\n(∀x (¬Attractive(x) ∧ Fat(x))) → (∀x (Hungry(x))) ::: If someone who is not attractive is also fat, then he is hungry.\n(∀x (¬Hungry(x) ∧ ¬Scared(x))) ↔ (∀x (Attractive(x) ∧ ¬Fat(x))) ::: If someone is not hungry and not scared, then he is both attractive and not fat, and vice versa.\n(∀x (¬Attractive(x))) → (∀x (Hungry(x) ∧ ¬Drab(x))) ::: As long as someone is not attractive, he is hungry and not drab.\n(∀x (Drab(x) ∧ Attractive(x))) ↔ (∀x (Wicked(x) ∧ Hungry(x))) ::: If someone is drab and attractive, then he is both wicked and hungry, and vice versa.\n(¬∃x (¬Hungry(x))) → ((Attractive(udolf) ∧ ¬Wicked(joey))) ::: If there is nobody who is not hungry, then Udolf is attractive and Joey is not wicked.\n(∀x (¬Hungry(x))) → (∀x (¬Attractive(x))) ::: If someone is not hungry, then he is not attractive, and vice versa.\n(∃x (Scared(x) ∧ ¬Fat(x))) → (¬Wicked(christina)) ::: If there is at least one people who is both scared and not fat, then Christina is not wicked.\n(∃x (Fat(x) ∨ ¬Scared(x))) → (¬Wicked(roderick)) ::: If there is someone who is either fat or not scared, then Roderick is not wicked.\n",
                "First-Order-Logic Question": "Scared(rolf) ::: Rolf is scared."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "¬Fat(barry) ::: Barry is not fat.\n¬Scared(barry) ::: Barry is not scared.\nFat(roderick) ::: Roderick is fat.\n¬Attractive(rolf) ::: Rolf is not attractive.\n¬Drab(udolf) ::: Udolf is not drab.\n¬Scared(rolf) ::: Rolf is not scared.\n¬Hungry(udolf) ::: Udolf is not hungry.\n¬Wicked(udolf) ::: Udolf is not wicked.\n¬Scared(udolf) ::: Udolf is not scared.\n¬Scared(owen) ::: Owen is not scared.\n¬Hungry(joey) ::: Joey is not hungry.\nWicked(joey) ::: Joey is wicked.\n(∃x (Hungry(x) ∨ ¬Scared(x))) → ((¬Wicked(roderick) ∧ ¬Drab(rolf))) ::: If there is at least one people who is either hungry or not scared, then Roderick is not wicked and Rolf is not drab.\n(¬Scared(barry)) ↔ (¬Attractive(rolf)) ::: Barry being not scared is equivalent to Rolf being not attractive.\n(∃x (¬Drab(x))) → (¬Fat(roderick)) ::: If there is at least one people who is not drab, then Roderick is not fat.\n(¬Wicked(barry)) ↔ ((Fat(christina) ∧ Drab(roderick))) ::: Barry being not wicked is equivalent to Christina being fat and Roderick being drab.\n(∀x (¬Attractive(x) ∧ Fat(x))) → (∀x (Hungry(x))) ::: If someone who is not attractive is also fat, then he is hungry.\n(∀x (¬Hungry(x) ∧ ¬Scared(x))) ↔ (∀x (Attractive(x) ∧ ¬Fat(x))) ::: If someone is not hungry and not scared, then he is both attractive and not fat, and vice versa.\n(∀x (¬Attractive(x))) → (∀x (Hungry(x) ∧ ¬Drab(x))) ::: As long as someone is not attractive, he is hungry and not drab.\n(∀x (Drab(x) ∧ Attractive(x))) ↔ (∀x (Wicked(x) ∧ Hungry(x))) ::: If someone is drab and attractive, then he is both wicked and hungry, and vice versa.\n¬∃x(¬Hungry(x))→((Attractive(x))) ::: If there is nobody who is not hungry, then Udolf is attractive and Joey is not wicked.\n(∀x (¬Hungry(x))) → (∀x (¬Attractive(x))) ::: If someone is not hungry, then he is not attractive, and vice versa.\n(∃x (Scared(x) ∧ ¬Fat(x))) → (¬Wicked(christina)) ::: If there is at least one people who is both scared and not fat, then Christina is not wicked.\n(∃x (Fat(x) ∨ ¬Scared(x))) → (¬Wicked(roderick)) ::: If there is someone who is either fat or not scared, then Roderick is not wicked.\n",
                "First-Order-Logic Question": "Scared(rolf) ::: Rolf is scared."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬Hungry(x))) → ((Attractive(udolf) ∧ ¬Wicked(joey))) ::: If there is nobody who is not hungry, then Udolf is attractive and Joey is not wicked.",
                    "gram": "¬∃x(¬Hungry(x))→((Attractive(x))) ::: If there is nobody who is not hungry, then Udolf is attractive and Joey is not wicked."
                }
            ],
            "answer": "B",
            "grammar_answer": "A",
            "backup_answer": "B"
        },
        {
            "id": 1257,
            "raw_prog": {
                "First-Order-Logic Rules": "¬Fat(barry) ::: Barry is not fat.\n¬Scared(barry) ::: Barry is not scared.\nFat(roderick) ::: Roderick is fat.\n¬Attractive(rolf) ::: Rolf is not attractive.\n¬Drab(udolf) ::: Udolf is not drab.\n¬Scared(rolf) ::: Rolf is not scared.\n¬Hungry(udolf) ::: Udolf is not hungry.\n¬Wicked(udolf) ::: Udolf is not wicked.\n¬Scared(udolf) ::: Udolf is not scared.\n¬Scared(owen) ::: Owen is not scared.\n¬Hungry(joey) ::: Joey is not hungry.\nWicked(joey) ::: Joey is wicked.\n(∃x (Hungry(x) ∨ ¬Scared(x))) → ((¬Wicked(roderick) ∧ ¬Drab(rolf))) ::: If there is at least one people who is either hungry or not scared, then Roderick is not wicked and Rolf is not drab.\n((¬Scared(barry))) ↔ ((¬Attractive(rolf))) ::: Barry being not scared is equivalent to Rolf being not attractive.\n(∃x (¬Drab(x))) → ((¬Fat(roderick))) ::: If there is at least one people who is not drab, then Roderick is not fat.\n((¬Wicked(barry))) ↔ ((Fat(christina) ∧ Drab(roderick))) ::: Barry being not wicked is equivalent to Christina being fat and Roderick being drab.\n(∀x (¬Attractive(x) ∧ Fat(x))) → (∀x (Hungry(x))) ::: If someone who is not attractive is also fat, then he is hungry.\n(∀x (¬Hungry(x) ∧ ¬Scared(x))) ↔ (∀x (Attractive(x) ∧ ¬Fat(x))) ::: If someone is not hungry and not scared, then he is both attractive and not fat, and vice versa.\n(∀x (¬Attractive(x))) → (∀x (Hungry(x) ∧ ¬Drab(x))) ::: As long as someone is not attractive, he is hungry and not drab.\n(∀x (Drab(x) ∧ Attractive(x))) ↔ (∀x (Wicked(x) ∧ Hungry(x))) ::: If someone is drab and attractive, then he is both wicked and hungry, and vice versa.\n(¬∃x (¬Hungry(x))) → ((Attractive(udolf) ∧ ¬Wicked(joey))) ::: If there is nobody who is not hungry, then Udolf is attractive and Joey is not wicked.\n(∀x (¬Hungry(x))) → (∀x (¬Attractive(x))) ::: If someone is not hungry, then he is not attractive, and vice versa.\n(∃x (Scared(x) ∧ ¬Fat(x))) → ((¬Wicked(christina))) ::: If there is at least one people who is both scared and not fat, then Christina is not wicked.\n(∃x (Fat(x) ∨ ¬Scared(x))) → ((¬Wicked(roderick))) ::: If there is someone who is either fat or not scared, then Roderick is not wicked.\n",
                "First-Order-Logic Question": "¬Fat(christina) ::: Christina is not fat."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "¬Fat(barry) ::: Barry is not fat.\n¬Scared(barry) ::: Barry is not scared.\nFat(roderick) ::: Roderick is fat.\n¬Attractive(rolf) ::: Rolf is not attractive.\n¬Drab(udolf) ::: Udolf is not drab.\n¬Scared(rolf) ::: Rolf is not scared.\n¬Hungry(udolf) ::: Udolf is not hungry.\n¬Wicked(udolf) ::: Udolf is not wicked.\n¬Scared(udolf) ::: Udolf is not scared.\n¬Scared(owen) ::: Owen is not scared.\n¬Hungry(joey) ::: Joey is not hungry.\nWicked(joey) ::: Joey is wicked.\n(∃x (Hungry(x) ∨ ¬Scared(x))) → ((¬Wicked(roderick) ∧ ¬Drab(rolf))) ::: If there is at least one people who is either hungry or not scared, then Roderick is not wicked and Rolf is not drab.\n((¬Scared(barry))) ↔ ((¬Attractive(rolf))) ::: Barry being not scared is equivalent to Rolf being not attractive.\n(∃x (¬Drab(x))) → ((¬Fat(roderick))) ::: If there is at least one people who is not drab, then Roderick is not fat.\n((¬Wicked(barry))) ↔ ((Fat(christina) ∧ Drab(roderick))) ::: Barry being not wicked is equivalent to Christina being fat and Roderick being drab.\n(∀x (¬Attractive(x) ∧ Fat(x))) → (∀x (Hungry(x))) ::: If someone who is not attractive is also fat, then he is hungry.\n(∀x (¬Hungry(x) ∧ ¬Scared(x))) ↔ (∀x (Attractive(x) ∧ ¬Fat(x))) ::: If someone is not hungry and not scared, then he is both attractive and not fat, and vice versa.\n(∀x (¬Attractive(x))) → (∀x (Hungry(x) ∧ ¬Drab(x))) ::: As long as someone is not attractive, he is hungry and not drab.\n(∀x (Drab(x) ∧ Attractive(x))) ↔ (∀x (Wicked(x) ∧ Hungry(x))) ::: If someone is drab and attractive, then he is both wicked and hungry, and vice versa.\n¬∃x(¬Hungry(x))→((Attractive(x))) ::: If there is nobody who is not hungry, then Udolf is attractive and Joey is not wicked.\n(∀x (¬Hungry(x))) → (∀x (¬Attractive(x))) ::: If someone is not hungry, then he is not attractive, and vice versa.\n(∃x (Scared(x) ∧ ¬Fat(x))) → ((¬Wicked(christina))) ::: If there is at least one people who is both scared and not fat, then Christina is not wicked.\n(∃x (Fat(x) ∨ ¬Scared(x))) → ((¬Wicked(roderick))) ::: If there is someone who is either fat or not scared, then Roderick is not wicked.\n",
                "First-Order-Logic Question": "¬Fat(christina) ::: Christina is not fat."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬Hungry(x))) → ((Attractive(udolf) ∧ ¬Wicked(joey))) ::: If there is nobody who is not hungry, then Udolf is attractive and Joey is not wicked.",
                    "gram": "¬∃x(¬Hungry(x))→((Attractive(x))) ::: If there is nobody who is not hungry, then Udolf is attractive and Joey is not wicked."
                }
            ],
            "answer": "C",
            "grammar_answer": "A",
            "backup_answer": "B"
        },
        {
            "id": 1258,
            "raw_prog": {
                "First-Order-Logic Rules": "¬Fat(barry) ::: Barry is not fat.\n¬Scared(barry) ::: Barry is not scared.\nFat(roderick) ::: Roderick is fat.\n¬Attractive(rolf) ::: Rolf is not attractive.\n¬Drab(udolf) ::: Udolf is not drab.\n¬Scared(rolf) ::: Rolf is not scared.\n¬Hungry(udolf) ::: Udolf is not hungry.\n¬Wicked(udolf) ::: Udolf is not wicked.\n¬Scared(udolf) ::: Udolf is not scared.\n¬Scared(owen) ::: Owen is not scared.\n¬Hungry(joey) ::: Joey is not hungry.\nWicked(joey) ::: Joey is wicked.\n(∃x (Hungry(x) ∨ ¬Scared(x))) → ((¬Wicked(roderick) ∧ ¬Drab(rolf))) ::: If there is at least one people who is either hungry or not scared, then Roderick is not wicked and Rolf is not drab.\n((¬Scared(barry))) ↔ ((¬Attractive(rolf))) ::: Barry being not scared is equivalent to Rolf being not attractive.\n(∃x (¬Drab(x))) → ((¬Fat(roderick))) ::: If there is at least one people who is not drab, then Roderick is not fat.\n((¬Wicked(barry))) ↔ ((Fat(christina) ∧ Drab(roderick))) ::: Barry being not wicked is equivalent to Christina being fat and Roderick being drab.\n(∀x (¬Attractive(x) ∧ Fat(x))) → (∀x (Hungry(x))) ::: If someone who is not attractive is also fat, then he is hungry.\n(∀x (¬Hungry(x) ∧ ¬Scared(x))) ↔ (∀x (Attractive(x) ∧ ¬Fat(x))) ::: If someone is not hungry and not scared, then he is both attractive and not fat, and vice versa.\n(∀x (¬Attractive(x))) → (∀x (Hungry(x) ∧ ¬Drab(x))) ::: As long as someone is not attractive, he is hungry and not drab.\n(∀x (Drab(x) ∧ Attractive(x))) ↔ (∀x (Wicked(x) ∧ Hungry(x))) ::: If someone is drab and attractive, then he is both wicked and hungry, and vice versa.\n(¬∃x (¬Hungry(x))) → ((Attractive(udolf) ∧ ¬Wicked(joey))) ::: If there is nobody who is not hungry, then Udolf is attractive and Joey is not wicked.\n(∀x (¬Hungry(x))) → (∀x (¬Attractive(x))) ::: If someone is not hungry, then he is not attractive, and vice versa.\n(∃x (Scared(x) ∧ ¬Fat(x))) → ((¬Wicked(christina))) ::: If there is at least one people who is both scared and not fat, then Christina is not wicked.\n(∃x (Fat(x) ∨ ¬Scared(x))) → ((¬Wicked(roderick))) ::: If there is someone who is either fat or not scared, then Roderick is not wicked.\n",
                "First-Order-Logic Question": "¬Attractive(christina) ::: Christina is not attractive."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "¬Fat(barry) ::: Barry is not fat.\n¬Scared(barry) ::: Barry is not scared.\nFat(roderick) ::: Roderick is fat.\n¬Attractive(rolf) ::: Rolf is not attractive.\n¬Drab(udolf) ::: Udolf is not drab.\n¬Scared(rolf) ::: Rolf is not scared.\n¬Hungry(udolf) ::: Udolf is not hungry.\n¬Wicked(udolf) ::: Udolf is not wicked.\n¬Scared(udolf) ::: Udolf is not scared.\n¬Scared(owen) ::: Owen is not scared.\n¬Hungry(joey) ::: Joey is not hungry.\nWicked(joey) ::: Joey is wicked.\n(∃x (Hungry(x) ∨ ¬Scared(x))) → ((¬Wicked(roderick) ∧ ¬Drab(rolf))) ::: If there is at least one people who is either hungry or not scared, then Roderick is not wicked and Rolf is not drab.\n((¬Scared(barry))) ↔ ((¬Attractive(rolf))) ::: Barry being not scared is equivalent to Rolf being not attractive.\n(∃x (¬Drab(x))) → ((¬Fat(roderick))) ::: If there is at least one people who is not drab, then Roderick is not fat.\n((¬Wicked(barry))) ↔ ((Fat(christina) ∧ Drab(roderick))) ::: Barry being not wicked is equivalent to Christina being fat and Roderick being drab.\n(∀x (¬Attractive(x) ∧ Fat(x))) → (∀x (Hungry(x))) ::: If someone who is not attractive is also fat, then he is hungry.\n(∀x (¬Hungry(x) ∧ ¬Scared(x))) ↔ (∀x (Attractive(x) ∧ ¬Fat(x))) ::: If someone is not hungry and not scared, then he is both attractive and not fat, and vice versa.\n(∀x (¬Attractive(x))) → (∀x (Hungry(x) ∧ ¬Drab(x))) ::: As long as someone is not attractive, he is hungry and not drab.\n(∀x (Drab(x) ∧ Attractive(x))) ↔ (∀x (Wicked(x) ∧ Hungry(x))) ::: If someone is drab and attractive, then he is both wicked and hungry, and vice versa.\n¬∃x(¬Hungry(x))→((Attractive(x))) ::: If there is nobody who is not hungry, then Udolf is attractive and Joey is not wicked.\n(∀x (¬Hungry(x))) → (∀x (¬Attractive(x))) ::: If someone is not hungry, then he is not attractive, and vice versa.\n(∃x (Scared(x) ∧ ¬Fat(x))) → ((¬Wicked(christina))) ::: If there is at least one people who is both scared and not fat, then Christina is not wicked.\n(∃x (Fat(x) ∨ ¬Scared(x))) → ((¬Wicked(roderick))) ::: If there is someone who is either fat or not scared, then Roderick is not wicked.\n",
                "First-Order-Logic Question": "¬Attractive(christina) ::: Christina is not attractive."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬Hungry(x))) → ((Attractive(udolf) ∧ ¬Wicked(joey))) ::: If there is nobody who is not hungry, then Udolf is attractive and Joey is not wicked.",
                    "gram": "¬∃x(¬Hungry(x))→((Attractive(x))) ::: If there is nobody who is not hungry, then Udolf is attractive and Joey is not wicked."
                }
            ],
            "answer": "C",
            "grammar_answer": "A",
            "backup_answer": "C"
        },
        {
            "id": 1259,
            "raw_prog": {
                "First-Order-Logic Rules": "¬Fat(barry) ::: Barry is not fat.\n¬Scared(barry) ::: Barry is not scared.\nFat(roderick) ::: Roderick is fat.\n¬Attractive(rolf) ::: Rolf is not attractive.\n¬Drab(udolf) ::: Udolf is not drab.\n¬Scared(rolf) ::: Rolf is not scared.\n¬Hungry(udolf) ::: Udolf is not hungry.\n¬Wicked(udolf) ::: Udolf is not wicked.\n¬Scared(udolf) ::: Udolf is not scared.\n¬Scared(owen) ::: Owen is not scared.\n¬Hungry(joey) ::: Joey is not hungry.\nWicked(joey) ::: Joey is wicked.\n(∃x (Hungry(x) ∨ ¬Scared(x))) → ((¬Wicked(roderick) ∧ ¬Drab(rolf))) ::: If there is at least one people who is either hungry or not scared, then Roderick is not wicked and Rolf is not drab.\n(¬Scared(barry)) ↔ (¬Attractive(rolf)) ::: Barry being not scared is equivalent to Rolf being not attractive.\n(∃x (¬Drab(x))) → (¬Fat(roderick)) ::: If there is at least one people who is not drab, then Roderick is not fat.\n(¬Wicked(barry)) ↔ ((Fat(christina) ∧ Drab(roderick))) ::: Barry being not wicked is equivalent to Christina being fat and Roderick being drab.\n(∀x (¬Attractive(x) ∧ Fat(x))) → (∀x (Hungry(x))) ::: If someone who is not attractive is also fat, then he is hungry.\n(∀x (¬Hungry(x) ∧ ¬Scared(x))) ↔ (∀x (Attractive(x) ∧ ¬Fat(x))) ::: If someone is not hungry and not scared, then he is both attractive and not fat, and vice versa.\n(∀x (¬Attractive(x))) → (∀x (Hungry(x) ∧ ¬Drab(x))) ::: As long as someone is not attractive, he is hungry and not drab.\n(∀x (Drab(x) ∧ Attractive(x))) ↔ (∀x (Wicked(x) ∧ Hungry(x))) ::: If someone is drab and attractive, then he is both wicked and hungry, and vice versa.\n(¬∃x (¬Hungry(x))) → ((Attractive(udolf) ∧ ¬Wicked(joey))) ::: If there is nobody who is not hungry, then Udolf is attractive and Joey is not wicked.\n(∀x (¬Hungry(x))) → (∀x (¬Attractive(x))) ::: If someone is not hungry, then he is not attractive, and vice versa.\n(∃x (Scared(x) ∧ ¬Fat(x))) → (¬Wicked(christina)) ::: If there is at least one people who is both scared and not fat, then Christina is not wicked.\n(∃x (Fat(x) ∨ ¬Scared(x))) → (¬Wicked(roderick)) ::: If there is someone who is either fat or not scared, then Roderick is not wicked.\n",
                "First-Order-Logic Question": "¬Scared(christina) ::: Christina is not scared."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "¬Fat(barry) ::: Barry is not fat.\n¬Scared(barry) ::: Barry is not scared.\nFat(roderick) ::: Roderick is fat.\n¬Attractive(rolf) ::: Rolf is not attractive.\n¬Drab(udolf) ::: Udolf is not drab.\n¬Scared(rolf) ::: Rolf is not scared.\n¬Hungry(udolf) ::: Udolf is not hungry.\n¬Wicked(udolf) ::: Udolf is not wicked.\n¬Scared(udolf) ::: Udolf is not scared.\n¬Scared(owen) ::: Owen is not scared.\n¬Hungry(joey) ::: Joey is not hungry.\nWicked(joey) ::: Joey is wicked.\n(∃x (Hungry(x) ∨ ¬Scared(x))) → ((¬Wicked(roderick) ∧ ¬Drab(rolf))) ::: If there is at least one people who is either hungry or not scared, then Roderick is not wicked and Rolf is not drab.\n(¬Scared(barry)) ↔ (¬Attractive(rolf)) ::: Barry being not scared is equivalent to Rolf being not attractive.\n(∃x (¬Drab(x))) → (¬Fat(roderick)) ::: If there is at least one people who is not drab, then Roderick is not fat.\n(¬Wicked(barry)) ↔ ((Fat(christina) ∧ Drab(roderick))) ::: Barry being not wicked is equivalent to Christina being fat and Roderick being drab.\n(∀x (¬Attractive(x) ∧ Fat(x))) → (∀x (Hungry(x))) ::: If someone who is not attractive is also fat, then he is hungry.\n(∀x (¬Hungry(x) ∧ ¬Scared(x))) ↔ (∀x (Attractive(x) ∧ ¬Fat(x))) ::: If someone is not hungry and not scared, then he is both attractive and not fat, and vice versa.\n(∀x (¬Attractive(x))) → (∀x (Hungry(x) ∧ ¬Drab(x))) ::: As long as someone is not attractive, he is hungry and not drab.\n(∀x (Drab(x) ∧ Attractive(x))) ↔ (∀x (Wicked(x) ∧ Hungry(x))) ::: If someone is drab and attractive, then he is both wicked and hungry, and vice versa.\n¬∃x(¬Hungry(x))→((Attractive(x))) ::: If there is nobody who is not hungry, then Udolf is attractive and Joey is not wicked.\n(∀x (¬Hungry(x))) → (∀x (¬Attractive(x))) ::: If someone is not hungry, then he is not attractive, and vice versa.\n(∃x (Scared(x) ∧ ¬Fat(x))) → (¬Wicked(christina)) ::: If there is at least one people who is both scared and not fat, then Christina is not wicked.\n(∃x (Fat(x) ∨ ¬Scared(x))) → (¬Wicked(roderick)) ::: If there is someone who is either fat or not scared, then Roderick is not wicked.\n",
                "First-Order-Logic Question": "¬Scared(christina) ::: Christina is not scared."
            },
            "diff": [
                {
                    "raw": "(¬∃x (¬Hungry(x))) → ((Attractive(udolf) ∧ ¬Wicked(joey))) ::: If there is nobody who is not hungry, then Udolf is attractive and Joey is not wicked.",
                    "gram": "¬∃x(¬Hungry(x))→((Attractive(x))) ::: If there is nobody who is not hungry, then Udolf is attractive and Joey is not wicked."
                }
            ],
            "answer": "C",
            "grammar_answer": "A",
            "backup_answer": "C"
        }
    ]
}