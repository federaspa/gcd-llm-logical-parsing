{
    "gcd_llama-2-7b_3.5": [
        {
            "id": 2,
            "raw_prog": {
                "First-Order-Logic Rules": "∀x (Perform(x) → (Attend(x) ∧ Engaged(x))) ::: If people perform in school talent shows often, then they attend and are very engaged with school events.\n∀x ((Perform(x) ∨ (Inactive(x) ∧ Disinterested(x))) ::: People either perform in school talent shows often or are inactive and disinterested members of their community.\n∀x (Chaperone(x) → ¬Student(x)) ::: If people chaperone high school dances, then they are not students who attend the school.\n∀x ((Inactive(x) ∧ Disinterested(x)) → Chaperone(x)) ::: All people who are inactive and disinterested members of their community chaperone high school dances.\n∀x ((Young(x) ∨ Teenager(x)) ∧ Wish(x) → Student(x)) ::: All young children and teenagers who wish to further their academic careers and educational opportunities are students who attend the school.\n¬((Attend(Bonnie) ∧ Engaged(Bonnie)) ⊕ Student(Bonnie)) ::: Bonnie either both attends and is very engaged with school events and is a student who attends the school, or she neither attends and is very engaged with school events nor is a student who attends the school.\n",
                "First-Order-Logic Question": "((Chaperone(Bonnie) ∨ ¬Chaperone(Bonnie) ∧ Perform(Bonnie)) → ((Young(Bonnie) ∨ Teenager(Bonnie)) ∧ Wish(Bonnie) ∧ Inactive(Bonnie) ∧ Disinterested(Bonnie))) ::: If Bonnie either chaperones high school dances or, if she does not, she performs in school talent shows often, then Bonnie is both a young child or teenager who wishes to further her academic career and educational opportunities and an inactive and disinterested member of the community."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∀x (Perform(x) → (Attend(x) ∧ Engaged(x))) ::: If people perform in school talent shows often, then they attend and are very engaged with school events.\n∀x((Perform(x)∨Inactive(x))) ::: People either perform in school talent shows often or are inactive and disinterested members of their community.\n∀x (Chaperone(x) → ¬Student(x)) ::: If people chaperone high school dances, then they are not students who attend the school.\n∀x ((Inactive(x) ∧ Disinterested(x)) → Chaperone(x)) ::: All people who are inactive and disinterested members of their community chaperone high school dances.\n∀x ((Young(x) ∨ Teenager(x)) ∧ Wish(x) → Student(x)) ::: All young children and teenagers who wish to further their academic careers and educational opportunities are students who attend the school.\n¬((Attend(Bonnie) ∧ Engaged(Bonnie)) ⊕ Student(Bonnie)) ::: Bonnie either both attends and is very engaged with school events and is a student who attends the school, or she neither attends and is very engaged with school events nor is a student who attends the school.\n",
                "First-Order-Logic Question": "((Chaperone(Bonnie) ∨ ¬Chaperone(Bonnie) ∧ Perform(Bonnie)) → ((Young(Bonnie) ∨ Teenager(Bonnie)) ∧ Wish(Bonnie) ∧ Inactive(Bonnie) ∧ Disinterested(Bonnie))) ::: If Bonnie either chaperones high school dances or, if she does not, she performs in school talent shows often, then Bonnie is both a young child or teenager who wishes to further her academic career and educational opportunities and an inactive and disinterested member of the community."
            },
            "diff": [
                {
                    "raw": "∀x ((Perform(x) ∨ (Inactive(x) ∧ Disinterested(x))) ::: People either perform in school talent shows often or are inactive and disinterested members of their community.",
                    "gram": "∀x((Perform(x)∨Inactive(x))) ::: People either perform in school talent shows often or are inactive and disinterested members of their community."
                }
            ],
            "answer": "B",
            "grammar_answer": "C"
        },
        {
            "id": 52,
            "raw_prog": {
                "First-Order-Logic Rules": "∀x (Romance(x) → IndoEuropean(x)) ::: All Romance languages are Indo-European languages.\nLanguageFamily(romance) ::: The Romance languages are a language family.\n∀x ∀y (LanguageFamily(x) ∧ LanguageFamily(y) → Related(x, y)) ::: All languages within a language family are related to each other.\nRomance(french) ∧ Romance(spanish) ::: French and Spanish are both Romance languages.\nRelated(german, spanish) ::: German is related to Spanish.\nBasque ::: Basque is not related to any other language.",
                "First-Order-Logic Question": "Romance(basque) ::: Basque is a Romance language."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∀x (RomanceLanguage(x) → IndoEuropeanLanguage(x)) ::: All Romance languages are Indo-European languages.\nLanguageFamily(romance) ::: The Romance languages are a language family.\n∀x ∀y (LanguageFamily(x) ∧ LanguageFamily(y) → RelatedLanguages(x, y)) ::: All languages within a language family are related to each other.\nRomanceLanguage(french) ∧ RomanceLanguage(spanish) ::: French and Spanish are both Romance languages.\nRelatedLanguages(german, spanish) ::: German is related to Spanish.\nBasqueLanguage(x) → ¬RelatedLanguages(x,y) ::: Basque language is not related to any other language.",
                "First-Order-Logic Question": "RomanceLanguage(basque) ::: Basque language is a Romance language."
            },
            "diff": [
                {
                    "raw": "∀x (Romance(x) → IndoEuropean(x)) ::: All Romance languages are Indo-European languages.",
                    "gram": "∀x (RomanceLanguage(x) → IndoEuropeanLanguage(x)) ::: All Romance languages are Indo-European languages."
                },
                {
                    "raw": "Romance(french) ∧ Romance(spanish) ::: French and Spanish are both Romance languages.",
                    "gram": "RomanceLanguage(french) ∧ RomanceLanguage(spanish) ::: French and Spanish are both Romance languages."
                },
                {
                    "raw": "Related(german, spanish) ::: German is related to Spanish.",
                    "gram": "RelatedLanguages(german, spanish) ::: German is related to Spanish."
                },
                {
                    "raw": "Basque ::: Basque is not related to any other language.",
                    "gram": "BasqueLanguage(x) → ¬RelatedLanguages(x,y) ::: Basque language is not related to any other language."
                }
            ],
            "answer": "B",
            "grammar_answer": "C"
        },
        {
            "id": 58,
            "raw_prog": {
                "First-Order-Logic Rules": "City(billings) ∧ City(butte) ∧ City(helena) ∧ City(missoula) ∧ City(whiteSulphurSprings) ∧ City(pierre) ∧ State(montana) ∧ State(southDakota) ∧ State(x) ∧ In(billings, montana) ∧ In(butte, montana) ∧ In(helena, montana) ∧ In(missoula, montana) ∧ In(whiteSulphurSprings, montana) ∧ In(butte, x) ∧ ¬In(pierre, southDakota) ∧ ∀x (In(x, butte) → ¬In(x, pierre)) ::: Billings is a city in Montana. Montana includes the cities of Butte, Helena, and Missoula. White Sulphur Springs and Butte are cities in the same state. The city of Pierre is not in Montana. Any city in Butte is not in Pierre.",
                "First-Order-Logic Question": "SameState(butte, pierre) ::: Butte and Pierre are in the same state."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "City(x)→¬In(x,y)→¬In(y,z)→¬In(x,z) ::: Billings is a city in Montana. Montana includes the cities of Butte, Helena, and Missoula. White Sulphur Springs and Butte are cities in the same state. The city of Pierre is not in Montana. Any city in Butte is not in Pierre.",
                "First-Order-Logic Question": "SameState(butte, pierre) ::: Butte and Pierre are in the same state."
            },
            "diff": [
                {
                    "raw": "City(billings) ∧ City(butte) ∧ City(helena) ∧ City(missoula) ∧ City(whiteSulphurSprings) ∧ City(pierre) ∧ State(montana) ∧ State(southDakota) ∧ State(x) ∧ In(billings, montana) ∧ In(butte, montana) ∧ In(helena, montana) ∧ In(missoula, montana) ∧ In(whiteSulphurSprings, montana) ∧ In(butte, x) ∧ ¬In(pierre, southDakota) ∧ ∀x (In(x, butte) → ¬In(x, pierre)) ::: Billings is a city in Montana. Montana includes the cities of Butte, Helena, and Missoula. White Sulphur Springs and Butte are cities in the same state. The city of Pierre is not in Montana. Any city in Butte is not in Pierre.",
                    "gram": "City(x)→¬In(x,y)→¬In(y,z)→¬In(x,z) ::: Billings is a city in Montana. Montana includes the cities of Butte, Helena, and Missoula. White Sulphur Springs and Butte are cities in the same state. The city of Pierre is not in Montana. Any city in Butte is not in Pierre."
                }
            ],
            "answer": "B",
            "grammar_answer": "C"
        },
        {
            "id": 93,
            "raw_prog": {
                "First-Order-Logic Rules": "∃x (Pet(x) ∧ AllowedIn(x, y)) ::: Pets are allowed in some managed buildings.\n∀x (RequireDeposit(x) → ∃y (RentApartment(z, y) ∧ SecurityDeposit(x) ∧ (Equal(SecurityDeposit(x), RentAmount(y)) ∨ MoreThan(SecurityDeposit(x), RentAmount(y))))) ::: A deposit is required to rent an apartment in a managed building. The security deposit can be either equal to one month's rent or more.\nCat(fluffy) ∧ Pet(fluffy) ∧ Owner(tom, fluffy) ::: Fluffy is Tom's cat.\nCat(x) → Pet(x) ::: Cats are pets.\nManagedBuilding(olivegarden) ::: The Olive Garden is a managed building.\nRentAmount(2000, olivegarden) ::: The monthly rent at the Olive Garden is $2000.\nRentApartment(tom, olivegarden) ↔ (AllowedIn(tom, olivegarden) ∧ SecurityDeposit(olivegarden) ∧ (Equal(SecurityDeposit(olivegarden), 1500) ∨ ¬MoreThan(SecurityDeposit(olivegarden), 1500))) ::: Tom will rent an apartment in a managed building if and only if he is allowed to move in with Fluffy, and the security deposit is no more than $1500.\nMoreThan(2000, 1500) ::: 2000$ is more than $1500.",
                "First-Order-Logic Question": "RentApartment(tom, olivegarden) ::: Tom will rent an apartment in The Olive Garden."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∃x (Pet(x) ∧ AllowedIn(x, y)) ::: Pets are allowed in some managed buildings.\nRequireDeposit(x)→¬(AllowedIn(x,y)∧ManagedBuilding(x)) ::: A deposit is required to rent an apartment in a managed building. The security deposit can be either equal to one month's rent or more.\nCat(fluffy) ∧ Pet(fluffy) ∧ Owner(tom, fluffy) ::: Fluffy is Tom's cat.\nCat(x) → Pet(x) ::: Cats are pets.\nManagedBuilding(olivegarden) ::: The Olive Garden is a managed building.\nRentAmount(2000, olivegarden) ::: The monthly rent at the Olive Garden is $2000.\nRentApartment(x,y)↔(AllowedIn(x,y)∧SecurityDeposit(y)) ::: Tom will rent an apartment in a managed building if and only if he is allowed to move in with Fluffy, and the security deposit is no more than $1500.\nMoreThan(2000, 1500) ::: 2000$ is more than $1500.",
                "First-Order-Logic Question": "RentApartment(tom, olivegarden) ::: Tom will rent an apartment in The Olive Garden."
            },
            "diff": [
                {
                    "raw": "∀x (RequireDeposit(x) → ∃y (RentApartment(z, y) ∧ SecurityDeposit(x) ∧ (Equal(SecurityDeposit(x), RentAmount(y)) ∨ MoreThan(SecurityDeposit(x), RentAmount(y))))) ::: A deposit is required to rent an apartment in a managed building. The security deposit can be either equal to one month's rent or more.",
                    "gram": "RequireDeposit(x)→¬(AllowedIn(x,y)∧ManagedBuilding(x)) ::: A deposit is required to rent an apartment in a managed building. The security deposit can be either equal to one month's rent or more."
                },
                {
                    "raw": "RentApartment(tom, olivegarden) ↔ (AllowedIn(tom, olivegarden) ∧ SecurityDeposit(olivegarden) ∧ (Equal(SecurityDeposit(olivegarden), 1500) ∨ ¬MoreThan(SecurityDeposit(olivegarden), 1500))) ::: Tom will rent an apartment in a managed building if and only if he is allowed to move in with Fluffy, and the security deposit is no more than $1500.",
                    "gram": "RentApartment(x,y)↔(AllowedIn(x,y)∧SecurityDeposit(y)) ::: Tom will rent an apartment in a managed building if and only if he is allowed to move in with Fluffy, and the security deposit is no more than $1500."
                }
            ],
            "answer": "B",
            "grammar_answer": "C"
        },
        {
            "id": 104,
            "raw_prog": {
                "First-Order-Logic Rules": "∀x (Twins(x) ∨ Triplets(x) → SpendTimeWith(x, x)) ::: If people are twins or triplets, then they spend a lot of time hanging out with and playing with their siblings.\n∀x (Siblings(x, y) → Twins(x) ∨ Triplets(x)) ::: If people have siblings who are the same age, then they are twins or triplets.\n∀x (Complain(x) → Siblings(x, y)) ::: If people complain often about annoying siblings, then they have siblings who are the same age.\n∀x (¬LiveAtHome(x) → ¬DevelopBonds(x, y)) ::: If people do not live at home regularly, then they do not develop strong bonds with their family members.\n∀x (SpendTimeWith(x, y) → ¬LiveAtHome(x)) ::: If people spend a lot of time hanging out with and playing with their siblings, then they often did not live at home regularly.\n(Twins(luke) ∧ DevelopBonds(luke, luke)) ⊕ (¬Twins(luke) ∧ ¬DevelopBonds(luke, luke)) ::: Luke is either both a twin or triplet and develops strong bonds with his family members, or he neither is a twin or triplet nor develops strong bonds with his family members.\n",
                "First-Order-Logic Question": "¬(Twins(luke) ∨ Triplets(luke) ∨ Complain(luke)) ::: Luke is neither a twin nor triplet nor complains often about annoying siblings."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∀x (Twins(x) ∨ Triplets(x) → SpendTimeWith(x, x)) ::: If people are twins or triplets, then they spend a lot of time hanging out with and playing with their siblings.\n∀x (Siblings(x, y) → Twins(x) ∨ Triplets(x)) ::: If people have siblings who are the same age, then they are twins or triplets.\n∀x (Complain(x) → Siblings(x, y)) ::: If people complain often about annoying siblings, then they have siblings who are the same age.\n∀x (¬LiveAtHome(x) → ¬DevelopBonds(x, y)) ::: If people do not live at home regularly, then they do not develop strong bonds with their family members.\n∀x (SpendTimeWith(x, y) → ¬LiveAtHome(x)) ::: If people spend a lot of time hanging out with and playing with their siblings, then they often did not live at home regularly.\n(Twins(luke) ∧ DevelopBonds(luke, luke)) ⊕ (¬Twins(luke) ∧ ¬DevelopBonds(luke, luke)) ::: Luke is either both a twin or triplet and develops strong bonds with his family members, or he neither is a twin or triplet nor develops strong bonds with his family members.\n",
                "First-Order-Logic Question": "¬(Twins(luke) ∨ Triplets(luke) ∨ Complain(luke)) ::: Luke is neither a twin nor triplet nor complains often about annoying siblings."
            },
            "diff": [],
            "answer": "A",
            "grammar_answer": "C"
        },
        {
            "id": 124,
            "raw_prog": {
                "First-Order-Logic Rules": "∀x (Transport(x) → ¬Empty(x)) ::: If something can transport multiple passengers, then they are not empty. \n∀x (Airline(x) → Transport(x)) ::: All airlines can transport multiple passengers. \n∀x (Plane(x) → Empty(x)) ::: All planes are empty. \n∀x (Boeing707(x) → Plane(x)) ::: All Boeing 707s are planes. \nAirline(Greyhound) → ¬∃x (Greyhound(x) ∧ Plane(x)) ::: If Greyhound is not an airline, then there are no Greyhound planes.\n",
                "First-Order-Logic Question": "¬(Greyhound(x) ∧ Boeing707(x)) ::: A Greyhound is not a Boeing 707."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∀x (Transport(x) → ¬Empty(x)) ::: If something can transport multiple passengers, then they are not empty. \n∀x (Airline(x) → Transport(x)) ::: All airlines can transport multiple passengers. \n∀x (Plane(x) → Empty(x)) ::: All planes are empty. \n∀x (Boeing707(x) → Plane(x)) ::: All Boeing 707s are planes. \nAirline(x)→¬(Greyhound(x)∧Plane(x)) ::: If Greyhound is not an airline, then there are no Greyhound planes.\n",
                "First-Order-Logic Question": "¬(Greyhound(x) ∧ Boeing707(x)) ::: A Greyhound is not a Boeing 707."
            },
            "diff": [
                {
                    "raw": "Airline(Greyhound) → ¬∃x (Greyhound(x) ∧ Plane(x)) ::: If Greyhound is not an airline, then there are no Greyhound planes.",
                    "gram": "Airline(x)→¬(Greyhound(x)∧Plane(x)) ::: If Greyhound is not an airline, then there are no Greyhound planes."
                }
            ],
            "answer": "A",
            "grammar_answer": "C"
        },
        {
            "id": 128,
            "raw_prog": {
                "First-Order-Logic Rules": "∀x (HaveWedding(x) → HaveChild(x)) ::: All people who have a wedding are people who have at least one child.\n∀x (TravelToParis(x) → HaveWedding(x)) ::: All people who travel to Paris for their honeymoon are people who have a wedding.\n∀x (OccurIn(x, July) ∧ HaveWedding(x) → TravelToParis(x)) ::: All weddings that occur in July belong to people who travel to Paris for their honeymoon.\n∃x (OccurIn(x, July) ∧ WellAttended(x)) ::: Some weddings in July are well-attended.\nHaveChild(John) → (¬TravelToParis(John) ∧ ¬HaveWedding(John)) ::: If John has at least one child, then John does not travel to Paris for his honeymoon and does not have a wedding.\nHaveWedding(John) ∧ WellAttended(John) → (OccurIn(John, July) ∨ (¬OccurIn(John, July) → TravelToParis(John))) ::: If John has a wedding that is well-attended, then John has a wedding in July or, if not, then John travels to Paris for their honeymoon.",
                "First-Order-Logic Question": "WellAttended(John) ::: John has a wedding that is well-attended."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∀x (HaveWedding(x) → HaveChild(x)) ::: All people who have a wedding are people who have at least one child.\n∀x (TravelToParis(x) → HaveWedding(x)) ::: All people who travel to Paris for their honeymoon are people who have a wedding.\n∀x (OccurIn(x, July) ∧ HaveWedding(x) → TravelToParis(x)) ::: All weddings that occur in July belong to people who travel to Paris for their honeymoon.\n∃x (OccurIn(x, July) ∧ WellAttended(x)) ::: Some weddings in July are well-attended.\nHaveChild(John) → (¬TravelToParis(John) ∧ ¬HaveWedding(John)) ::: If John has at least one child, then John does not travel to Paris for his honeymoon and does not have a wedding.\nHaveWedding(John) ∧ WellAttended(John) → (OccurIn(John, July) ∨ (¬OccurIn(John, July) → TravelToParis(John))) ::: If John has a wedding that is well-attended, then John has a wedding in July or, if not, then John travels to Paris for their honeymoon.",
                "First-Order-Logic Question": "WellAttended(John) ::: John has a wedding that is well-attended."
            },
            "diff": [],
            "answer": "B",
            "grammar_answer": "C"
        },
        {
            "id": 138,
            "raw_prog": {
                "First-Order-Logic Rules": "∀x (Algorithm(x) → (SupervisedLearning(x) ∨ UnsupervisedLearning(x) ∨ ReinforcementLearning(x))) ::: Machine Learning algorithms can be categorized as supervised learning, unsupervised learning, and reinforcement learning.\n∀x (UnsupervisedLearning(x) → ¬RequireLabelledData(x)) ::: Unsupervised learning doesn't require labelled data.\nStateOfTheArtModel(model) ∧ Algorithm(algo) ∧ TrainedWith(model, algo) ::: The state-of-the-art text summarization model is trained with machine learning algorithms.\nReinforcementLearning(rl) → ¬TrainedWith(StateOfTheArtModel(model), rl) ::: Reinforcement learning is not used to train the state-of-the-art text summarization model.\n∀x (Algorithm(x) ∧ TrainedWith(StateOfTheArtModel(model), x) → RequireLabelledData(x)) ::: The Machine Learning algorithm for training text summarization model requires labelled data.\n",
                "First-Order-Logic Question": "SupervisedLearning(supervised) ∧ TrainedWith(StateOfTheArtModel(model), supervised) ::: Supervised learning is used to train the state-of-the-art text summarization model."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∀x (Algorithm(x) → (SupervisedLearning(x) ∨ UnsupervisedLearning(x) ∨ ReinforcementLearning(x))) ::: Machine Learning algorithms can be categorized as supervised learning, unsupervised learning, and reinforcement learning.\n∀x (UnsupervisedLearning(x) → ¬RequireLabelledData(x)) ::: Unsupervised learning doesn't require labelled data.\nStateOfTheArtModel(model) ∧ Algorithm(algo) ∧ TrainedWith(model, algo) ::: The state-of-the-art text summarization model is trained with machine learning algorithms.\nReinforcementLearning(x)→¬TrainedWith(x,y) ::: Reinforcement learning is not used to train the state-of-the-art text summarization model.\nAlgorithm(x)∧TrainedWith(x,y)→RequireLabelledData(x) ::: The Machine Learning algorithm for training text summarization model requires labelled data.\n",
                "First-Order-Logic Question": "SupervisedLearning(x)→TrainedWith(x,y) ::: Supervised learning is used to train the state-of-the-art text summarization model."
            },
            "diff": [
                {
                    "raw": "ReinforcementLearning(rl) → ¬TrainedWith(StateOfTheArtModel(model), rl) ::: Reinforcement learning is not used to train the state-of-the-art text summarization model.",
                    "gram": "ReinforcementLearning(x)→¬TrainedWith(x,y) ::: Reinforcement learning is not used to train the state-of-the-art text summarization model."
                },
                {
                    "raw": "∀x (Algorithm(x) ∧ TrainedWith(StateOfTheArtModel(model), x) → RequireLabelledData(x)) ::: The Machine Learning algorithm for training text summarization model requires labelled data.",
                    "gram": "Algorithm(x)∧TrainedWith(x,y)→RequireLabelledData(x) ::: The Machine Learning algorithm for training text summarization model requires labelled data."
                }
            ],
            "answer": "A",
            "grammar_answer": "C"
        },
        {
            "id": 155,
            "raw_prog": {
                "First-Order-Logic Rules": "∀x,y (Owns(x, y) → (WorkRegularly(x) ∧ WorkOften(x))) ::: If people own a large desktop monitor at their home, then they work regularly and often at home.\n∀x (FullyStocked(x) → Owns(x, largeDesktopMonitor) ∧ Impressive(x)) ::: All people who have a fully stocked and impressive home office are people who own a large desktop monitor at their home.\n∀x (WorkRegularly(x) ∧ WorkOften(x) → Tidy(x)) ::: All people who work regularly and often at home spend their free time tidying and organizing the spaces in their homes.\n∀x (WorkRegularly(x) ∧ WorkOften(x) → VisitStore(x)) ::: All people who work regularly and often at home visit the office supply store regularly.\n∀x (Tidy(x) → (¬Late(x) ∧ ¬WakeLate(x))) ::: If people spend their free time tidying and organizing the spaces in their home, then they do not go to bed late and wake up every day after noon.\n(Tidy(remy) ∧ Late(remy) ∧ WakeLate(remy)) ⊕ (¬Late(remy) ∧ ¬WakeLate(remy) ∧ ¬Tidy(remy)) ::: Remy either both goes to bed late and wakes up every day after noon and spends their free time tidying and organizing the spaces in their home, or they do not go to bed late and wake up every day after noon nor spend their free time tidying and organizing the spaces in their home.\n",
                "First-Order-Logic Question": "((Late(remy) ∧ WakeLate(remy)) ∨ VisitStore(remy)) → (¬Tidy(remy) ∧ ¬FullyStocked(remy)) ::: If Remy either goes to bed late and wakes up every day after noon or visits the office supply store regularly, then Remy neither spends their free time tidying and organizing the spaces in their home nor has a fully stocked and impressive home office."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∀x(Owns(x,y)→(WorkRegularly(x))) ::: If people own a large desktop monitor at their home, then they work regularly and often at home.\n∀x (FullyStocked(x) → Owns(x, largeDesktopMonitor) ∧ Impressive(x)) ::: All people who have a fully stocked and impressive home office are people who own a large desktop monitor at their home.\n∀x (WorkRegularly(x) ∧ WorkOften(x) → Tidy(x)) ::: All people who work regularly and often at home spend their free time tidying and organizing the spaces in their homes.\n∀x (WorkRegularly(x) ∧ WorkOften(x) → VisitStore(x)) ::: All people who work regularly and often at home visit the office supply store regularly.\n∀x (Tidy(x) → (¬Late(x) ∧ ¬WakeLate(x))) ::: If people spend their free time tidying and organizing the spaces in their home, then they do not go to bed late and wake up every day after noon.\n(Tidy(remy) ∧ Late(remy) ∧ WakeLate(remy)) ⊕ (¬Late(remy) ∧ ¬WakeLate(remy) ∧ ¬Tidy(remy)) ::: Remy either both goes to bed late and wakes up every day after noon and spends their free time tidying and organizing the spaces in their home, or they do not go to bed late and wake up every day after noon nor spend their free time tidying and organizing the spaces in their home.\n",
                "First-Order-Logic Question": "((Late(remy) ∧ WakeLate(remy)) ∨ VisitStore(remy)) → (¬Tidy(remy) ∧ ¬FullyStocked(remy)) ::: If Remy either goes to bed late and wakes up every day after noon or visits the office supply store regularly, then Remy neither spends their free time tidying and organizing the spaces in their home nor has a fully stocked and impressive home office."
            },
            "diff": [
                {
                    "raw": "∀x,y (Owns(x, y) → (WorkRegularly(x) ∧ WorkOften(x))) ::: If people own a large desktop monitor at their home, then they work regularly and often at home.",
                    "gram": "∀x(Owns(x,y)→(WorkRegularly(x))) ::: If people own a large desktop monitor at their home, then they work regularly and often at home."
                }
            ],
            "answer": "A",
            "grammar_answer": "C"
        },
        {
            "id": 166,
            "raw_prog": {
                "First-Order-Logic Rules": "∃x ∃y (Monday(y) ∧ Time(y) ∧ Roses(x) ∧ GivenOut(x, y)) ::: On some Mondays at 8 pm, roses are given out on TV.\n∀x (Roses(x) → On(x, Bachelor)) ::: Every rose given out on TV is on the Bachelor.\n∀x (On(x, Bachelor) → Portray(x, RealPeople)) ::: Everything on the Bachelor portrays the lives of real people.\n∀x (Portray(x, RealPeople) → RealityTVShow(x)) ::: All shows portraying the lives of real people are reality TV shows.\n¬RealityTVShow(BreakingBad) ::: Breaking Bad is not a reality TV show.\n",
                "First-Order-Logic Question": "∀x (Roses(x) ∧ GivenOut(x, Monday(8pm))) → On(BreakingBad, Monday(8pm)) ::: If roses are given out during Breaking Bad, then it is on Monday at 8 pm."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∃x ∃y (Monday(y) ∧ Time(y) ∧ Roses(x) ∧ GivenOut(x, y)) ::: On some Mondays at 8 pm, roses are given out on TV.\n∀x (Roses(x) → On(x, Bachelor)) ::: Every rose given out on TV is on the Bachelor.\n∀x (On(x, Bachelor) → Portray(x, RealPeople)) ::: Everything on the Bachelor portrays the lives of real people.\n∀x (Portray(x, RealPeople) → RealityTVShow(x)) ::: All shows portraying the lives of real people are reality TV shows.\n¬RealityTVShow(BreakingBad) ::: Breaking Bad is not a reality TV show.\n",
                "First-Order-Logic Question": "∀x(Roses(x)∧GivenOut(x,y)→On(x,y)) ::: If roses are given out during Breaking Bad, then it is on Monday at 8 pm."
            },
            "diff": [],
            "answer": "A",
            "grammar_answer": "C"
        },
        {
            "id": 181,
            "raw_prog": {
                "First-Order-Logic Rules": "Flies(susan, LGA) ::: Susan flies to LGA airport.\n∀x (Airport(x) ∧ Flies(john, x) ∧ ¬(DepartsFrom(john, x) ∧ ArrivesAt(john, x))) ::: The departure and arrival can not be the same airport.\n",
                "First-Order-Logic Question": "Flies(john, LGA) ::: John flies to LGA airport."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "Flies(susan, LGA) ::: Susan flies to LGA airport.\n∀x (Airport(x) ∧ Flies(john, x) ∧ ¬(DepartsFrom(john, x) ∧ ArrivesAt(john, x))) ::: The departure and arrival can not be the same airport.\n",
                "First-Order-Logic Question": "Flies(john, LGA) ::: John flies to LGA airport."
            },
            "diff": [],
            "answer": "B",
            "grammar_answer": "A"
        },
        {
            "id": 1,
            "raw_prog": {
                "First-Order-Logic Rules": "∀x (Perform(x) → (Attend(x) ∧ Engaged(x))) ::: If people perform in school talent shows often, then they attend and are very engaged with school events.\n∀x ((Perform(x) ∨ (Inactive(x) ∧ Disinterested(x))) ::: People either perform in school talent shows often or are inactive and disinterested members of their community.\n∀x (Chaperone(x) → ¬Student(x)) ::: If people chaperone high school dances, then they are not students who attend the school.\n∀x ((Inactive(x) ∧ Disinterested(x)) → Chaperone(x)) ::: All people who are inactive and disinterested members of their community chaperone high school dances.\n∀x ((Young(x) ∨ Teenager(x)) ∧ Wish(x) → Student(x)) ::: All young children and teenagers who wish to further their academic careers and educational opportunities are students who attend the school.\n¬((Attend(Bonnie) ∧ Engaged(Bonnie)) ⊕ Student(Bonnie)) ::: Bonnie either both attends and is very engaged with school events and is a student who attends the school, or she neither attends and is very engaged with school events nor is a student who attends the school.",
                "First-Order-Logic Question": "((Young(Bonnie) ∨ Teenager(Bonnie)) ∧ Wish(Bonnie) ∧ Chaperone(Bonnie)) ∨ ¬((Young(Bonnie) ∨ Teenager(Bonnie)) ∧ ¬Wish(Bonnie)) → (Student(Bonnie) ∨ (Inactive(Bonnie) ∧ Disinterested(Bonnie)))"
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∀x (Perform(x) → (Attend(x) ∧ Engaged(x))) ::: If people perform in school talent shows often, then they attend and are very engaged with school events.\n∀x((Perform(x)∨Inactive(x))) ::: People either perform in school talent shows often or are inactive and disinterested members of their community.\n∀x (Chaperone(x) → ¬Student(x)) ::: If people chaperone high school dances, then they are not students who attend the school.\n∀x ((Inactive(x) ∧ Disinterested(x)) → Chaperone(x)) ::: All people who are inactive and disinterested members of their community chaperone high school dances.\n∀x ((Young(x) ∨ Teenager(x)) ∧ Wish(x) → Student(x)) ::: All young children and teenagers who wish to further their academic careers and educational opportunities are students who attend the school.\n¬((Attend(Bonnie) ∧ Engaged(Bonnie)) ⊕ Student(Bonnie)) ::: Bonnie either both attends and is very engaged with school events and is a student who attends the school, or she neither attends and is very engaged with school events nor is a student who attends the school.",
                "First-Order-Logic Question": "((Young(Bonnie) ∨ Teenager(Bonnie)) ∧ Wish(Bonnie) ∧ Chaperone(Bonnie)) ∨ ¬((Young(Bonnie) ∨ Teenager(Bonnie)) ∧ ¬Wish(Bonnie)) → (Student(Bonnie) ∨ (Inactive(Bonnie) ∧ Disinterested(Bonnie)))"
            },
            "diff": [
                {
                    "raw": "∀x ((Perform(x) ∨ (Inactive(x) ∧ Disinterested(x))) ::: People either perform in school talent shows often or are inactive and disinterested members of their community.",
                    "gram": "∀x((Perform(x)∨Inactive(x))) ::: People either perform in school talent shows often or are inactive and disinterested members of their community."
                }
            ],
            "answer": "A",
            "grammar_answer": "C"
        },
        {
            "id": 13,
            "raw_prog": {
                "First-Order-Logic Rules": "Create(japaneseGameCompany, legendOfZelda) ::: A Japanese game company created the game the Legend of Zelda.\n∀x (Game(x) ∧ Sell(x, moreThanOneMillion) → Select(x, Top10(x))) ::: If a game sells more than one million copies, then it will be selected into the Top 10 list.\nSelect(legendOfZelda, Top10) ::: The Legend of Zelda sold more than one million copies and is selected into the Top 10 list.\n",
                "First-Order-Logic Question": "Create(japaneseVideoGameCompany, FIFA22) ::: FIFA 22 is made by a Japanese video game company."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "Create(japaneseGameCompany, legendOfZelda) ::: A Japanese game company created the game the Legend of Zelda.\n∀x(Game(x)→Select(x,y))∧¬(Create(x,y)→Sell(x,y)) ::: If a game sells more than one million copies, then it will be selected into the Top 10 list.\nSelect(legendOfZelda, Top10) ::: The Legend of Zelda sold more than one million copies and is selected into the Top 10 list.\n",
                "First-Order-Logic Question": "Create(japaneseVideoGameCompany, FIFA22) ::: FIFA 22 is made by a Japanese video game company."
            },
            "diff": [
                {
                    "raw": "∀x (Game(x) ∧ Sell(x, moreThanOneMillion) → Select(x, Top10(x))) ::: If a game sells more than one million copies, then it will be selected into the Top 10 list.",
                    "gram": "∀x(Game(x)→Select(x,y))∧¬(Create(x,y)→Sell(x,y)) ::: If a game sells more than one million copies, then it will be selected into the Top 10 list."
                }
            ],
            "answer": "C",
            "grammar_answer": "A"
        },
        {
            "id": 46,
            "raw_prog": {
                "First-Order-Logic Rules": "∀x (Season(x) → (Spring(x) ∨ Summer(x) ∨ Fall(x) ∨ Winter(x))) ::: There are four seasons in a year: Spring, Summer, Fall, and Winter. \n∀x (Student(x) ∧ WantLongVacation(x) → Love(x, Summer)) ::: All students who want to have a long vacation love summer the most. \nFavoriteSeason(emma, Summer) ::: Emma's favorite season is summer. \n∀x (Student(mia) ∧ NotSame(FavoriteSeason(mia, emma), emma)) ::: Mia's favorite season is not the same as Emma's. \nWantLongVacation(james) ::: James wants to have a long vacation.",
                "First-Order-Logic Question": "FavoriteSeason(james, Summer) ::: James's favorite season is summer."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∀x (Season(x) → (Spring(x) ∨ SeasonSummer(x) ∨ Fall(x) ∨ Winter(x))) ::: There are four seasons in a year: Spring, Summer, Fall, and Winter. \n∀x (Student(x) ∧ WantLongVacation(x) → Love(x, SeasonSummer)) ::: All students who want to have a long vacation love summer the most. \nFavoriteSeason(emma, SeasonSummer) ::: Emma's favorite season is summer. \nStudent(x) ∧ NotSame(x,y) → FavoriteSeason(x,y) ::: Mia's favorite season is not the same as Emma's. \nWantLongVacation(james) ::: James wants to have a long vacation.",
                "First-Order-Logic Question": "FavoriteSeason(james, SeasonSummer) ::: James's favorite season is summer."
            },
            "diff": [
                {
                    "raw": "∀x (Student(mia) ∧ NotSame(FavoriteSeason(mia, emma), emma)) ::: Mia's favorite season is not the same as Emma's. ",
                    "gram": "Student(x) ∧ NotSame(x,y) → FavoriteSeason(x,y) ::: Mia's favorite season is not the same as Emma's. "
                }
            ],
            "answer": "A",
            "grammar_answer": "C"
        },
        {
            "id": 68,
            "raw_prog": {
                "First-Order-Logic Rules": "PrivateUniversity(yaleuniversity) ∧ IvyLeagueUniversity(yaleuniversity) ∧ ResearchUniversity(yaleuniversity) ::: Yale University is a private Ivy League research university.\nMove(yaleuniversity, newhaven, 1716) ::: Yale University moved to New Haven in 1716.\nEndowment(yaleuniversity, 42.3billion) ::: Yale university's endowment was valued at $42.3 billion.\nOrganize(yaleuniversity, List([residentialcolleges, yalegraduate, professionalschools])) ∧ List(residentialcolleges, [benjaminfranklin, berkeley, branford, davenport, ezrastiles, gracehopper, jonathanedwards, morse, paulimurray, pierson, saybrook, silliman, timothydwight, trumbull]) ::: Yale University has been organized into 27 constituent colleges and schools: the residential colleges, the Yale Graduate School of Arts and Sciences, and twelve professional schools.\n",
                "First-Order-Logic Question": "ResidentialCollege(pierson) ∧ College(pierson) ∧ YaleUniversity ::: Pierson College is a residential college at Yale."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "PrivateUniversity(yaleuniversity) ∧ IvyLeagueUniversity(yaleuniversity) ∧ ResearchUniversity(yaleuniversity) ::: Yale University is a private Ivy League research university.\nMove(yaleuniversity, newhaven, 1716) ::: Yale University moved to New Haven in 1716.\nEndowment(yaleuniversity, billion42_3) ::: Yale university's endowment was valued at $42.3 billion.\nOrganize(y,y)→List(y,y) ::: Yale University has been organized into 27 constituent colleges and schools: the residential colleges, the Yale Graduate School of Arts and Sciences, and twelve professional schools.",
                "First-Order-Logic Question": "ResidentialCollege(x)→College(x)→YaleUniversity(x) ::: Pierson College is a residential college at Yale."
            },
            "diff": [],
            "answer": "A",
            "grammar_answer": "C"
        },
        {
            "id": 103,
            "raw_prog": {
                "First-Order-Logic Rules": "∀x (Twins(x) ∨ Triplets(x) → SpendTimeWith(x, Siblings(x))) ::: If people are twins or triplets, then they spend a lot of time hanging out with and playing with their siblings.\n∀x (Siblings(x, y) → Twins(x) ∨ Triplets(x)) ::: If people have siblings who are the same age, then they are twins or triplets.\n∀x (Complain(x) → Siblings(x, y)) ::: If people complain often about annoying siblings, then they have siblings who are the same age.\n∀x (¬LiveAtHomeRegularly(x) → ¬DevelopBonds(x, y)) ::: If people do not live at home regularly, then they do not develop strong bonds with their family members.\n∀x (SpendTimeWith(x, Siblings(x)) → ¬LiveAtHomeRegularly(x)) ::: If people spend a lot of time hanging out with and playing with their siblings, then they often did not live at home regularly.\n(Twins(luke) ∧ DevelopBonds(luke, FamilyMembers)) ∨ (¬Twins(luke) ∧ ¬DevelopBonds(luke, FamilyMembers)) ::: Luke is either both a twin or triplet and develops strong bonds with his family members, or he neither is a twin or triplet nor develops strong bonds with his family members.\n",
                "First-Order-Logic Question": "Complain(luke) ::: Luke complains often about annoying siblings."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∀x(Twins(x)∨Triplets(x))→SpendTimeWith(x,y)∧Siblings(x,y)∧Complain(x)∧LiveAtHomeRegularly(x) ::: If people are twins or triplets, then they spend a lot of time hanging out with and playing with their siblings.\n∀x (Siblings(x, y) → Twins(x) ∨ Triplets(x)) ::: If people have siblings who are the same age, then they are twins or triplets.\n∀x (Complain(x) → Siblings(x, y)) ::: If people complain often about annoying siblings, then they have siblings who are the same age.\n∀x (¬LiveAtHomeRegularly(x) → ¬DevelopBonds(x, y)) ::: If people do not live at home regularly, then they do not develop strong bonds with their family members.\n∀x(SpendTimeWith(x,y)→¬LiveAtHomeRegularly(x)) ::: If people spend a lot of time hanging out with and playing with their siblings, then they often did not live at home regularly.\n(Twins(luke) ∧ DevelopBonds(luke, FamilyMembers)) ∨ (¬Twins(luke) ∧ ¬DevelopBonds(luke, FamilyMembers)) ::: Luke is either both a twin or triplet and develops strong bonds with his family members, or he neither is a twin or triplet nor develops strong bonds with his family members.\n",
                "First-Order-Logic Question": "Complain(luke) ::: Luke complains often about annoying siblings."
            },
            "diff": [
                {
                    "raw": "∀x (Twins(x) ∨ Triplets(x) → SpendTimeWith(x, Siblings(x))) ::: If people are twins or triplets, then they spend a lot of time hanging out with and playing with their siblings.",
                    "gram": "∀x(Twins(x)∨Triplets(x))→SpendTimeWith(x,y)∧Siblings(x,y)∧Complain(x)∧LiveAtHomeRegularly(x) ::: If people are twins or triplets, then they spend a lot of time hanging out with and playing with their siblings."
                }
            ],
            "answer": "B",
            "grammar_answer": "A"
        },
        {
            "id": 105,
            "raw_prog": {
                "First-Order-Logic Rules": "Cost(gre_test, 205) ::: It costs US $205 to take the GRE test.\n∀x ∀y (Prove(x, EconomicHardship(y)) → ProvideAid(ETS, y)) ::: ETS provides financial aid to those GRE applicants who prove economic hardship.\n∀x (EconomicHardship(x) ↔ (Difficulty(x, money) ∨ Difficulty(x, resources))) ::: Economic hardship refers to difficulty caused by having too little money or too few resources.\nSingleParent(tom) ::: Tom lives in a single-parent family.\nOutOfWork(tom_dad, more_than_1_year) ::: His dad has been out of work for more than a year.\n",
                "First-Order-Logic Question": "ApplyFor(tom, ETS, gre_test) ::: Tom can apply for financial aid from ETS to take the GRE test."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "Cost(gre_test, 205) ::: It costs US $205 to take the GRE test.\nProvideAid(x,y)→Prove(x,y)∧EconomicHardship(y) ::: ETS provides financial aid to those GRE applicants who prove economic hardship.\n∀x (EconomicHardship(x) ↔ (Difficulty(x, money) ∨ Difficulty(x, resources))) ::: Economic hardship refers to difficulty caused by having too little money or too few resources.\nSingleParent(tom) ::: Tom lives in a single-parent family.\nOutOfWork(tom_dad, more_than_1_year) ::: His dad has been out of work for more than a year.\n",
                "First-Order-Logic Question": "ApplyFor(tom, ETS, gre_test) ::: Tom can apply for financial aid from ETS to take the GRE test."
            },
            "diff": [
                {
                    "raw": "∀x ∀y (Prove(x, EconomicHardship(y)) → ProvideAid(ETS, y)) ::: ETS provides financial aid to those GRE applicants who prove economic hardship.",
                    "gram": "ProvideAid(x,y)→Prove(x,y)∧EconomicHardship(y) ::: ETS provides financial aid to those GRE applicants who prove economic hardship."
                }
            ],
            "answer": "A",
            "grammar_answer": "C"
        },
        {
            "id": 115,
            "raw_prog": {
                "First-Order-Logic Rules": "∀x ∀y (Man(x) ∧ Man(y) ∧ Taller(x, y) → Block(x, y)) ::: If a man is taller than another man, the taller one can block the other's shooting.\nMan(michael) ∧ ∀x (Man(x) ∧ x ≠ michael → Taller(michael, x)) ::: Michael is a man who is taller than everyone else in his class.\n∀x ∀y ∀z (Taller(x, y) ∧ Taller(y, z) → Taller(x, z)) ::: If person x is taller than person y, and person y is taller than person z, than x is taller than z\nMan(peter) ∧ Taller(peter, michael) ::: Peter is a man who is taller than Michael.\n∀x (Shooter(x) ∧ ¬Jump(x) → Block(michael, x)) ::: Michael can block any shooting from a person as long as the person does not jump when shooting.\n¬Block(michael, windy) ::: Michael cannot block Windy's shooting.\n∀x (Shooter(x) ∧ Jump(x) → GreatShooter(x)) ::: Every shooter who can jump when shooting is a great shooter.",
                "First-Order-Logic Question": "∃x (Man(x) ∧ Classmate(x, michael) ∧ Taller(x, peter)) ::: Peter is shorter than a man in Michael's class."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∀x ∀y (Man(x) ∧ Man(y) ∧ Taller(x, y) → Block(x, y)) ::: If a man is taller than another man, the taller one can block the other's shooting.\nMan(x)∧¬(Man(x)→Taller(x,y)) ::: Michael is a man who is taller than everyone else in his class.\n∀x ∀y ∀z (Taller(x, y) ∧ Taller(y, z) → Taller(x, z)) ::: If person x is taller than person y, and person y is taller than person z, than x is taller than z\nMan(peter) ∧ Taller(peter, michael) ::: Peter is a man who is taller than Michael.\n∀x (Shooter(x) ∧ ¬Jump(x) → Block(michael, x)) ::: Michael can block any shooting from a person as long as the person does not jump when shooting.\n¬Block(michael, windy) ::: Michael cannot block Windy's shooting.\n∀x (Shooter(x) ∧ Jump(x) → GreatShooter(x)) ::: Every shooter who can jump when shooting is a great shooter.",
                "First-Order-Logic Question": "∃x (Man(x) ∧ Classmate(x, michael) ∧ Taller(x, peter)) ::: Peter is shorter than a man in Michael's class."
            },
            "diff": [
                {
                    "raw": "Man(michael) ∧ ∀x (Man(x) ∧ x ≠ michael → Taller(michael, x)) ::: Michael is a man who is taller than everyone else in his class.",
                    "gram": "Man(x)∧¬(Man(x)→Taller(x,y)) ::: Michael is a man who is taller than everyone else in his class."
                }
            ],
            "answer": "B",
            "grammar_answer": "A"
        },
        {
            "id": 117,
            "raw_prog": {
                "First-Order-Logic Rules": "∀x ∀y (Man(x) ∧ Man(y) ∧ Taller(x, y) → Block(x, y)) ::: If a man is taller than another man, the taller one can block the other's shooting.\nMan(michael) ∧ ∀x (Classmate(x, michael) ∧ x ≠ michael → Taller(michael, x)) ::: Michael is a man who is taller than everyone else in his class.\n∀x ∀y ∀z (Taller(x, y) ∧ Taller(y, z) → Taller(x, z)) ::: If person x is taller than person y, and person y is taller than person z, than x is taller than z\nMan(peter) ∧ Taller(peter, michael) ::: Peter is a man who is taller than Michael.\n∀x (Shoot(x) ∧ ¬Jump(x) → Block(michael, x)) ::: Michael can block any shooting from a person as long as the person does not jump when shooting.\n¬Block(michael, windy) ::: Michael cannot block Windy's shooting.\n∀x (Jump(x) → GreatShooter(x)) ::: Every shooter who can jump when shooting is a great shooter.",
                "First-Order-Logic Question": "Block(peter, windy) ::: Peter can block Windy's shooting."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∀x ∀y (Man(x) ∧ Man(y) ∧ Taller(x, y) → Block(x, y)) ::: If a man is taller than another man, the taller one can block the other's shooting.\nMan(x)→Taller(x,y)∧¬(Classmate(x,y))∧¬(Block(x,y))∧¬(Shoot(x)) ::: Michael is a man who is taller than everyone else in his class.\n∀x ∀y ∀z (Taller(x, y) ∧ Taller(y, z) → Taller(x, z)) ::: If person x is taller than person y, and person y is taller than person z, than x is taller than z\nMan(peter) ∧ Taller(peter, michael) ::: Peter is a man who is taller than Michael.\n∀x (Shoot(x) ∧ ¬Jump(x) → Block(michael, x)) ::: Michael can block any shooting from a person as long as the person does not jump when shooting.\n¬Block(michael, windy) ::: Michael cannot block Windy's shooting.\n∀x (Jump(x) → GreatShooter(x)) ::: Every shooter who can jump when shooting is a great shooter.",
                "First-Order-Logic Question": "Block(peter, windy) ::: Peter can block Windy's shooting."
            },
            "diff": [
                {
                    "raw": "Man(michael) ∧ ∀x (Classmate(x, michael) ∧ x ≠ michael → Taller(michael, x)) ::: Michael is a man who is taller than everyone else in his class.",
                    "gram": "Man(x)→Taller(x,y)∧¬(Classmate(x,y))∧¬(Block(x,y))∧¬(Shoot(x)) ::: Michael is a man who is taller than everyone else in his class."
                }
            ],
            "answer": "C",
            "grammar_answer": "A"
        },
        {
            "id": 129,
            "raw_prog": {
                "First-Order-Logic Rules": "∀x (HaveWedding(x) → HaveChild(x)) ::: All people who have a wedding are people who have at least one child.\n∀x (TravelToParisForHoneymoon(x) → HaveWedding(x)) ::: All people who travel to Paris for their honeymoon are people who have a wedding.\n∀x (Weddings(x) ∧ July(x) → BelongTo(x, TravelToParisForHoneymoon(x))) ::: All weddings that occur in July belong to people who travel to Paris for their honeymoon.\n∃x (Weddings(x) ∧ July(x) ∧ WellAttended(x)) ::: Some weddings in July are well-attended.\nHaveChild(John) → (¬TravelToParisForHoneymoon(John) ∧ ¬HaveWedding(John)) ::: If John has at least one child, then John does not travel to Paris for his honeymoon and does not have a wedding.\nHaveWedding(John) ∧ WellAttended(John) → (July(John) ∨ (¬July(John) ∧ TravelToParisForHoneymoon(John))) ::: If John has a wedding that is well-attended, then John has a wedding in July or, if not, then John travels to Paris for their honeymoon.",
                "First-Order-Logic Question": "¬WellAttended(John) ::: John does not have a wedding that is well-attended."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∀x (HaveWedding(x) → HaveChild(x)) ::: All people who have a wedding are people who have at least one child.\n∀x (TravelToParisForHoneymoon(x) → HaveWedding(x)) ::: All people who travel to Paris for their honeymoon are people who have a wedding.\n∀x(WellAttended(x)→BelongTo(x,x)) ::: All weddings that occur in July belong to people who travel to Paris for their honeymoon.\n∃x (Weddings(x) ∧ July(x) ∧ WellAttended(x)) ::: Some weddings in July are well-attended.\nHaveChild(John) → (¬TravelToParisForHoneymoon(John) ∧ ¬HaveWedding(John)) ::: If John has at least one child, then John does not travel to Paris for his honeymoon and does not have a wedding.\nHaveWedding(John) ∧ WellAttended(John) → (July(John) ∨ (¬July(John) ∧ TravelToParisForHoneymoon(John))) ::: If John has a wedding that is well-attended, then John has a wedding in July or, if not, then John travels to Paris for their honeymoon.",
                "First-Order-Logic Question": "¬WellAttended(John) ::: John does not have a wedding that is well-attended."
            },
            "diff": [
                {
                    "raw": "∀x (Weddings(x) ∧ July(x) → BelongTo(x, TravelToParisForHoneymoon(x))) ::: All weddings that occur in July belong to people who travel to Paris for their honeymoon.",
                    "gram": "∀x(WellAttended(x)→BelongTo(x,x)) ::: All weddings that occur in July belong to people who travel to Paris for their honeymoon."
                }
            ],
            "answer": "A",
            "grammar_answer": "C"
        },
        {
            "id": 131,
            "raw_prog": {
                "First-Order-Logic Rules": "∀x HaveWedding(x) → HaveChild(x) ::: All people who have a wedding are people who have at least one child.\n∀x (TravelToParisForHoneymoon(x) → HaveWedding(x)) ::: All people who travel to Paris for their honeymoon are people who have a wedding.\n∀x (Weddings(x) ∧ July(x) → BelongTo(x, TravelToParisForHoneymoon(x))) ::: All weddings that occur in July belong to people who travel to Paris for their honeymoon.\n∃x (Weddings(x) ∧ July(x) ∧ WellAttended(x)) ::: Some weddings in July are well-attended.\nHaveChild(John) → ¬(TravelToParisForHoneymoon(John) ∧ HaveWedding(John)) ::: If John has at least one child, then John does not travel to Paris for his honeymoon and does not have a wedding.\nHaveWedding(John) ∧ WellAttended(John) → (July(John) ∨ (¬July(John) ∧ TravelToParisForHoneymoon(John))) ::: If John has a wedding that is well-attended, then John has a wedding in July or, if not, then John travels to Paris for their honeymoon.",
                "First-Order-Logic Question": "¬(WellAttended(John) ∨ TravelToParisForHoneymoon(John)) ::: John has neither a wedding that is well-attended nor does he travel to Paris for his honeymoon."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∀x HaveWedding(x) → HaveChild(x) ::: All people who have a wedding are people who have at least one child.\n∀x (TravelToParisForHoneymoon(x) → HaveWedding(x)) ::: All people who travel to Paris for their honeymoon are people who have a wedding.\n∀x(WellAttended(x)→BelongTo(x,x)) ::: All weddings that occur in July belong to people who travel to Paris for their honeymoon.\n∃x (Weddings(x) ∧ July(x) ∧ WellAttended(x)) ::: Some weddings in July are well-attended.\nHaveChild(John) → ¬(TravelToParisForHoneymoon(John) ∧ HaveWedding(John)) ::: If John has at least one child, then John does not travel to Paris for his honeymoon and does not have a wedding.\nHaveWedding(John) ∧ WellAttended(John) → (July(John) ∨ (¬July(John) ∧ TravelToParisForHoneymoon(John))) ::: If John has a wedding that is well-attended, then John has a wedding in July or, if not, then John travels to Paris for their honeymoon.",
                "First-Order-Logic Question": "¬(WellAttended(John) ∨ TravelToParisForHoneymoon(John)) ::: John has neither a wedding that is well-attended nor does he travel to Paris for his honeymoon."
            },
            "diff": [
                {
                    "raw": "∀x (Weddings(x) ∧ July(x) → BelongTo(x, TravelToParisForHoneymoon(x))) ::: All weddings that occur in July belong to people who travel to Paris for their honeymoon.",
                    "gram": "∀x(WellAttended(x)→BelongTo(x,x)) ::: All weddings that occur in July belong to people who travel to Paris for their honeymoon."
                }
            ],
            "answer": "A",
            "grammar_answer": "C"
        },
        {
            "id": 154,
            "raw_prog": {
                "First-Order-Logic Rules": "∀x,y (Owns(x, y) → (WorkRegularlyAtHome(x) ∧ TidyOrganize(x))) ::: If people own a large desktop monitor at their home, then they work regularly and often at home.\n∀x,y (FullyStockedImpressiveHomeOffice(x) → LargeDesktopMonitor(x, y)) ::: All people who have a fully stocked and impressive home office are people who own a large desktop monitor at their home.\n∀x (WorkRegularlyAtHome(x) → TidyOrganize(x)) ::: All people who work regularly and often at home spend their free time tidying and organizing the spaces in their homes.\n∀x (WorkRegularlyAtHome(x) → VisitOfficeStore(x)) ::: All people who work regularly and often at home visit the office supply store regularly.\n∀x (TidyOrganize(x) → (¬GoToBedLate(x) ∧ ¬WakeUpAfterNoon(x))) ::: If people spend their free time tidying and organizing the spaces in their home, then they do not go to bed late and wake up every day after noon.\n(TidyOrganize(remy) ∧ (GoToBedLate(remy) ∧ WakeUpAfterNoon(remy))) ⊕ (¬GoToBedLate(remy) ∧ ¬WakeUpAfterNoon(remy) ∧ ¬TidyOrganize(remy)) ::: Remy either both goes to bed late and wakes up every day after noon and spends their free time tidying and organizing the spaces in their home, or they do not go to bed late and wake up every day after noon nor spend their free time tidying and organizing the spaces in their home.\n",
                "First-Order-Logic Question": "FullyStockedImpressiveHomeOffice(remy) ∧ VisitOfficeStore(remy) ::: Remy has a fully stocked and impressive home office and also visits the office supply store regularly."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∀x(Owns(x,y)→(WorkRegularlyAtHome(x))) ::: If people own a large desktop monitor at their home, then they work regularly and often at home.\n∀x(Owns(x,y)→LargeDesktopMonitor(x,y)) ::: All people who have a fully stocked and impressive home office are people who own a large desktop monitor at their home.\n∀x (WorkRegularlyAtHome(x) → TidyOrganize(x)) ::: All people who work regularly and often at home spend their free time tidying and organizing the spaces in their homes.\n∀x (WorkRegularlyAtHome(x) → VisitOfficeStore(x)) ::: All people who work regularly and often at home visit the office supply store regularly.\n∀x (TidyOrganize(x) → (¬GoToBedLate(x) ∧ ¬WakeUpAfterNoon(x))) ::: If people spend their free time tidying and organizing the spaces in their home, then they do not go to bed late and wake up every day after noon.\n(TidyOrganize(remy) ∧ (GoToBedLate(remy) ∧ WakeUpAfterNoon(remy))) ⊕ (¬GoToBedLate(remy) ∧ ¬WakeUpAfterNoon(remy) ∧ ¬TidyOrganize(remy)) ::: Remy either both goes to bed late and wakes up every day after noon and spends their free time tidying and organizing the spaces in their home, or they do not go to bed late and wake up every day after noon nor spend their free time tidying and organizing the spaces in their home.\n",
                "First-Order-Logic Question": "FullyStockedImpressiveHomeOffice(remy) ∧ VisitOfficeStore(remy) ::: Remy has a fully stocked and impressive home office and also visits the office supply store regularly."
            },
            "diff": [
                {
                    "raw": "∀x,y (Owns(x, y) → (WorkRegularlyAtHome(x) ∧ TidyOrganize(x))) ::: If people own a large desktop monitor at their home, then they work regularly and often at home.",
                    "gram": "∀x(Owns(x,y)→(WorkRegularlyAtHome(x))) ::: If people own a large desktop monitor at their home, then they work regularly and often at home."
                },
                {
                    "raw": "∀x,y (FullyStockedImpressiveHomeOffice(x) → LargeDesktopMonitor(x, y)) ::: All people who have a fully stocked and impressive home office are people who own a large desktop monitor at their home.",
                    "gram": "∀x(Owns(x,y)→LargeDesktopMonitor(x,y)) ::: All people who have a fully stocked and impressive home office are people who own a large desktop monitor at their home."
                }
            ],
            "answer": "B",
            "grammar_answer": "C"
        },
        {
            "id": 180,
            "raw_prog": {
                "First-Order-Logic Rules": "Flies(susan, lga) ::: Susan flies to LGA airport.\nDeparture(x, y) ∧ Arrival(x, y) ⊕ ¬(x = y) ::: The departure and arrival can not be the same airport.\nFrom(john, lga) ::: John flies from LGA airport.",
                "First-Order-Logic Question": "From(susan, lga) ::: Susan flies from LGA airport."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "Flies(susan, lga) ::: Susan flies to LGA airport.\nDeparture(x,y)∧¬(From(x,y))∨Arrival(x,y)⊕¬(From(x,y)) ::: The departure and arrival can not be the same airport.\nFrom(john, lga) ::: John flies from LGA airport.",
                "First-Order-Logic Question": "From(susan, lga) ::: Susan flies from LGA airport."
            },
            "diff": [
                {
                    "raw": "Departure(x, y) ∧ Arrival(x, y) ⊕ ¬(x = y) ::: The departure and arrival can not be the same airport.",
                    "gram": "Departure(x,y)∧¬(From(x,y))∨Arrival(x,y)⊕¬(From(x,y)) ::: The departure and arrival can not be the same airport."
                }
            ],
            "answer": "B",
            "grammar_answer": "C"
        },
        {
            "id": 199,
            "raw_prog": {
                "First-Order-Logic Rules": "Person(ailtonSilva) ∧ Born(ailtonSilva, 1995) ∧ KnownAs(ailtonSilva, ailton) ∧ FootballPlayer(ailton) ∧ Loan(ailton, braga) ∧ Brazilian(ailtonSilva) ∧ PlaysFor(ailtonSilva, nautico) ∧ Club(nautico) ∧ Club(braga) ∧ Club(fluminense) ::: Ailton Silva, born in 1995, is commonly known as Ailton. Ailton is a football player who was loaned out to Braga. Ailton Silva is a Brazillian footballer who plays for Nautico. Nautico is a football club along with Braga. Fluminense is a football club.",
                "First-Order-Logic Question": "¬∃x (PlaysFor(x, nautico) ∧ Brazilian(x)) ::: No one playing for Nautico is Brazilian."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "Person(x)→KnownAs(x,x)→FootballPlayer(x)→Loan(x,y)→Club(y)→PlaysFor(x,y)→Brazilian(x) ::: Ailton Silva, born in 1995, is commonly known as Ailton. Ailton is a football player who was loaned out to Braga. Ailton Silva is a Brazillian footballer who plays for Nautico. Nautico is a football club along with Braga. Fluminense is a football club.",
                "First-Order-Logic Question": "¬∃x (PlaysFor(x, nautico) ∧ Brazilian(x)) ::: No one playing for Nautico is Brazilian."
            },
            "diff": [
                {
                    "raw": "Person(ailtonSilva) ∧ Born(ailtonSilva, 1995) ∧ KnownAs(ailtonSilva, ailton) ∧ FootballPlayer(ailton) ∧ Loan(ailton, braga) ∧ Brazilian(ailtonSilva) ∧ PlaysFor(ailtonSilva, nautico) ∧ Club(nautico) ∧ Club(braga) ∧ Club(fluminense) ::: Ailton Silva, born in 1995, is commonly known as Ailton. Ailton is a football player who was loaned out to Braga. Ailton Silva is a Brazillian footballer who plays for Nautico. Nautico is a football club along with Braga. Fluminense is a football club.",
                    "gram": "Person(x)→KnownAs(x,x)→FootballPlayer(x)→Loan(x,y)→Club(y)→PlaysFor(x,y)→Brazilian(x) ::: Ailton Silva, born in 1995, is commonly known as Ailton. Ailton is a football player who was loaned out to Braga. Ailton Silva is a Brazillian footballer who plays for Nautico. Nautico is a football club along with Braga. Fluminense is a football club."
                }
            ],
            "answer": "B",
            "grammar_answer": "C"
        },
        {
            "id": 201,
            "raw_prog": {
                "First-Order-Logic Rules": "Person(ailtonSilva) ∧ Born(ailtonSilva, 1995) ∧ KnownAs(ailtonSilva, ailton) ::: Ailton Silva, born in 1995, is commonly known as Ailton.\nFootballPlayer(ailton) ∧ Loan(ailton, braga) ::: Ailton is a football player who was loaned out to Braga.\nBrazilian(ailtonSilva) ∧ FootballPlayer(ailtonSilva) ∧ PlaysFor(ailtonSilva, nautico) ::: Ailton Silva is a Brazillian footballer who plays for Nautico.\nClub(nautico) ∧ Club(braga) ∧ Team(nautico, braga) ::: Nautico is a football club along with Braga.\nClub(fluminense) ::: Fluminense is a football club.\n",
                "First-Order-Logic Question": "¬(∃x Loan(ailton, Club(x))) ::: Ailton was not loaned out to a football club."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "Person(ailtonSilva) ∧ Born(ailtonSilva, 1995) ∧ KnownAs(ailtonSilva, ailton) ::: Ailton Silva, born in 1995, is commonly known as Ailton.\nFootballPlayer(ailton) ∧ Loan(ailton, braga) ::: Ailton is a football player who was loaned out to Braga.\nBrazilian(ailtonSilva) ∧ FootballPlayer(ailtonSilva) ∧ PlaysFor(ailtonSilva, nautico) ::: Ailton Silva is a Brazillian footballer who plays for Nautico.\nClub(nautico) ∧ Club(braga) ∧ Team(nautico, braga) ::: Nautico is a football club along with Braga.\nClub(fluminense) ::: Fluminense is a football club.\n",
                "First-Order-Logic Question": "¬(Loan(x,y)) ::: Ailton was not loaned out to a football club."
            },
            "diff": [],
            "answer": "B",
            "grammar_answer": "C"
        },
        {
            "id": 11,
            "raw_prog": {
                "First-Order-Logic Rules": "WildTurkey(tom) ::: Tom is a wild turkey.\n∀x (WildTurkey(x) → (x = EasternWildTurkey ∨ x = OsceolaWildTurkey ∨ x = GouldsWildTurkey ∨ x = MerriamsWildTurkey ∨ x = RioGrandeWildTurkey ∨ x = OcellatedWildTurkey)) ::: There are six types of wild turkeys: Eastern wild turkey, Osceola wild turkey, Gould’s wild turkey, Merriam’s wild turkey, Rio Grande wild turkey, and Ocellated wild turkey.\n¬EasternWildTurkey(tom) ∧ ¬OsceolaWildTurkey(tom) ∧ ¬GouldsWildTurkey(tom) ∧ ¬MerriamsWildTurkey(tom) ∧ ¬RioGrandeWildTurkey(tom) ::: Tom is not an Eastern wild turkey, Osceola wild turkey, Gould's wild turkey, Merriam's wild turkey, or Rio Grande wild turkey.\n",
                "First-Order-Logic Question": "WildTurkey(joey) ::: Joey is a wild turkey."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "WildTurkey(tom) ::: Tom is a wild turkey.\n∀x(WildTurkey(x)→(EasternWildTurkey(x))) ::: There are six types of wild turkeys: Eastern wild turkey, Osceola wild turkey, Gould’s wild turkey, Merriam’s wild turkey, Rio Grande wild turkey, and Ocellated wild turkey.\n¬EasternWildTurkey(tom) ∧ ¬OsceolaWildTurkey(tom) ∧ ¬GouldsWildTurkey(tom) ∧ ¬MerriamsWildTurkey(tom) ∧ ¬RioGrandeWildTurkey(tom) ::: Tom is not an Eastern wild turkey, Osceola wild turkey, Gould's wild turkey, Merriam's wild turkey, or Rio Grande wild turkey.\n",
                "First-Order-Logic Question": "WildTurkey(joey) ::: Joey is a wild turkey."
            },
            "diff": [
                {
                    "raw": "∀x (WildTurkey(x) → (x = EasternWildTurkey ∨ x = OsceolaWildTurkey ∨ x = GouldsWildTurkey ∨ x = MerriamsWildTurkey ∨ x = RioGrandeWildTurkey ∨ x = OcellatedWildTurkey)) ::: There are six types of wild turkeys: Eastern wild turkey, Osceola wild turkey, Gould’s wild turkey, Merriam’s wild turkey, Rio Grande wild turkey, and Ocellated wild turkey.",
                    "gram": "∀x(WildTurkey(x)→(EasternWildTurkey(x))) ::: There are six types of wild turkeys: Eastern wild turkey, Osceola wild turkey, Gould’s wild turkey, Merriam’s wild turkey, Rio Grande wild turkey, and Ocellated wild turkey."
                }
            ],
            "answer": "C",
            "grammar_answer": "A"
        },
        {
            "id": 41,
            "raw_prog": {
                "First-Order-Logic Rules": "∀x (DesignStyle(x, ZahaHadid) → Timeless(x)) ::: All of Zaha Hadid's design styles are timeless.\n∀x (MassProductDesign(x) → ¬Timeless(x)) ::: No mass product design is timeless.\nDesignStyle(ZahaHadid, y) ∨ DesignStyle(KellyWearstler, y) ::: Either Zaha Hadid's design style or Kelly Wearstler's design style.\n∀x (DesignStyle(x, KellyWearstler) → Evocative(x)) ::: All of Kelly Wearstler's design styles are evocative.\n∀x (DesignStyle(x, KellyWearstler) → Dreamy(x)) ::: All of Kelly Wearstler's design styles are dreamy.\n∀x (Timeless(DesignBy(x, Max)) → (MassProductDesign(DesignBy(x, Max)) ∧ Evocative(DesignBy(x, Max)))) ::: If a design by Max is timeless, then a design by Max is a mass product design and evocative.\n",
                "First-Order-Logic Question": "Evocative(DesignBy(Max, Max)) ∨ Dreamy(DesignBy(Max, Max)) ::: A design by Max is either evocative or dreamy."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∀x (DesignStyle(x, ZahaHadid) → Timeless(x)) ::: All of Zaha Hadid's design styles are timeless.\n∀x (MassProductDesign(x) → ¬Timeless(x)) ::: No mass product design is timeless.\nDesignStyle(ZahaHadid, y) ∨ DesignStyle(KellyWearstler, y) ::: Either Zaha Hadid's design style or Kelly Wearstler's design style.\n∀x (DesignStyle(x, KellyWearstler) → Evocative(x)) ::: All of Kelly Wearstler's design styles are evocative.\n∀x (DesignStyle(x, KellyWearstler) → Dreamy(x)) ::: All of Kelly Wearstler's design styles are dreamy.\n∀x(Timeless(x)→(MassProductDesign(x))) ::: If a design by Max is timeless, then a design by Max is a mass product design and evocative.\n",
                "First-Order-Logic Question": "Evocative(x)∨Dreamy(x) ::: A design by Max is either evocative or dreamy."
            },
            "diff": [
                {
                    "raw": "∀x (Timeless(DesignBy(x, Max)) → (MassProductDesign(DesignBy(x, Max)) ∧ Evocative(DesignBy(x, Max)))) ::: If a design by Max is timeless, then a design by Max is a mass product design and evocative.",
                    "gram": "∀x(Timeless(x)→(MassProductDesign(x))) ::: If a design by Max is timeless, then a design by Max is a mass product design and evocative."
                }
            ],
            "answer": "B",
            "grammar_answer": "A"
        },
        {
            "id": 85,
            "raw_prog": {
                "First-Order-Logic Rules": "∀x (Listed(x) → ¬NotNegative(x)) ::: If the restaurant is listed in Yelp’s recommendations, then the restaurant does not receive many negative reviews.\n∀x (Rating(x, y) ∧ y > 9 → Listed(x)) ::: All restaurants with a rating greater than 9 are listed in Yelp’s recommendations.\n∃x (Restaurant(x) ∧ ¬Provide(x, takeout) → NotNegative(x)) ::: Some restaurants that do not provide take-out service receive many negative reviews.\n∀x (Popular(x) → Rating(x, y) ∧ y > 9) ::: All restaurants that are popular among local residents have ratings greater than 9.\nRating(subway, y) ∨ Popular(subway) ::: Subway has a rating greater than 9 or is popular among local residents.\n",
                "First-Order-Logic Question": "TakeOut(subway) ∧ ¬NotNegative(subway) ::: Subway provides take-out service and does not receive many negative reviews."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∀x (Listed(x) → ¬NotNegative(x)) ::: If the restaurant is listed in Yelp’s recommendations, then the restaurant does not receive many negative reviews.\n∀x(Rating(x,y)∧(NotNegative(x))) ::: All restaurants with a rating greater than 9 are listed in Yelp’s recommendations.\n∃x (Restaurant(x) ∧ ¬Provide(x, takeout) → NotNegative(x)) ::: Some restaurants that do not provide take-out service receive many negative reviews.\n∀x(Popular(x)→Rating(x,y)∧(Rating(x,y))) ::: All restaurants that are popular among local residents have ratings greater than 9.\nRating(subway, y) ∨ Popular(subway) ::: Subway has a rating greater than 9 or is popular among local residents.\n",
                "First-Order-Logic Question": "TakeOut(subway) ∧ ¬NotNegative(subway) ::: Subway provides take-out service and does not receive many negative reviews."
            },
            "diff": [
                {
                    "raw": "∀x (Rating(x, y) ∧ y > 9 → Listed(x)) ::: All restaurants with a rating greater than 9 are listed in Yelp’s recommendations.",
                    "gram": "∀x(Rating(x,y)∧(NotNegative(x))) ::: All restaurants with a rating greater than 9 are listed in Yelp’s recommendations."
                },
                {
                    "raw": "∀x (Popular(x) → Rating(x, y) ∧ y > 9) ::: All restaurants that are popular among local residents have ratings greater than 9.",
                    "gram": "∀x(Popular(x)→Rating(x,y)∧(Rating(x,y))) ::: All restaurants that are popular among local residents have ratings greater than 9."
                }
            ],
            "answer": "A",
            "grammar_answer": "B"
        },
        {
            "id": 95,
            "raw_prog": {
                "First-Order-Logic Rules": "∃x (Pet(x) ∧ AllowedIn(x, y)) ::: Pets are allowed in some managed buildings.\n∀x (RequireDeposit(x) → (Equal(x, RentAmount(y, z)) ∨ MoreThan(x, RentAmount(y, z)))) ::: A deposit is required to rent an apartment in a managed building.\nCat(fluffy) ∧ Pet(fluffy) ∧ Owner(tom, fluffy) ::: Fluffy is Tom's cat.\nCat(x) → Pet(x) ::: Cats are pets.\nManaged(olivegarden) ∧ Building(olivegarden) ::: The Olive Garden is a managed building.\nRentAmount(olivegarden, 2000) ::: The monthly rent at the Olive Garden is $2000.\nRentApartment(tom, olivegarden) ↔ (MoveInWith(tom, fluffy) ∧ ¬MoreThan(deposit, 1500)) ::: Tom will rent an apartment in a managed building if and only if he is allowed to move in with Fluffy, and the security deposit is no more than $1500.\nMoreThan(2000, 1500) ::: 2000$ is more than $1500.\n",
                "First-Order-Logic Question": "Equal(deposit, 2000) ∨ MoreThan(deposit, 2000) ::: The security deposit at the Olive Garden is either $2000 or more."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∃x (Pet(x) ∧ AllowedIn(x, y)) ::: Pets are allowed in some managed buildings.\n∀x(RequireDeposit(x)→(Equal(x,y))) ::: A deposit is required to rent an apartment in a managed building.\nCat(fluffy) ∧ Pet(fluffy) ∧ Owner(tom, fluffy) ::: Fluffy is Tom's cat.\nCat(x) → Pet(x) ::: Cats are pets.\nManaged(olivegarden) ∧ Building(olivegarden) ::: The Olive Garden is a managed building.\nRentAmount(olivegarden, 2000) ::: The monthly rent at the Olive Garden is $2000.\nRentApartment(tom, olivegarden) ↔ (MoveInWith(tom, fluffy) ∧ ¬MoreThan(deposit, 1500)) ::: Tom will rent an apartment in a managed building if and only if he is allowed to move in with Fluffy, and the security deposit is no more than $1500.\nMoreThan(2000, 1500) ::: 2000$ is more than $1500.\n",
                "First-Order-Logic Question": "Equal(deposit, 2000) ∨ MoreThan(deposit, 2000) ::: The security deposit at the Olive Garden is either $2000 or more."
            },
            "diff": [
                {
                    "raw": "∀x (RequireDeposit(x) → (Equal(x, RentAmount(y, z)) ∨ MoreThan(x, RentAmount(y, z)))) ::: A deposit is required to rent an apartment in a managed building.",
                    "gram": "∀x(RequireDeposit(x)→(Equal(x,y))) ::: A deposit is required to rent an apartment in a managed building."
                }
            ],
            "answer": "A",
            "grammar_answer": "C"
        },
        {
            "id": 106,
            "raw_prog": {
                "First-Order-Logic Rules": "Cost(gre, 205) ::: It costs US $205 to take the GRE test.\n∀x ∀y (TakeTest(x, gre) ∧ EconomicHardship(y) ∧ Difficulty(y, money) → ProvideAid(ets, x)) ::: ETS provides financial aid to those GRE applicants who prove economic hardship.\n∀x (EconomicHardship(x) ↔ (Difficulty(x, money) ∨ Difficulty(x, resources))) ::: Economic hardship refers to difficulty caused by having too little money or too few resources.\nSingleParentFamily(tom) ::: Tom lives in a single-parent family.\nOutOfWork(tom's dad, more than a year) ::: His dad has been out of work for more than a year.\n",
                "First-Order-Logic Question": "∃x (Cost(gre, x) ∧ x < 300) ::: It cost below US $300 to take the GRE test."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "Cost(gre, 205) ::: It costs US $205 to take the GRE test.\n∀x ∀y (TakeTest(x, gre) ∧ EconomicHardship(y) ∧ Difficulty(y, money) → ProvideAid(ets, x)) ::: ETS provides financial aid to those GRE applicants who prove economic hardship.\n∀x (EconomicHardship(x) ↔ (Difficulty(x, money) ∨ Difficulty(x, resources))) ::: Economic hardship refers to difficulty caused by having too little money or too few resources.\nSingleParentFamily(tom) ::: Tom lives in a single-parent family.\nHave(x,y)→ProvideAid(x,y) ::: His dad has been out of work for more than a year.\n",
                "First-Order-Logic Question": "∃x(Cost(x,y)∧(Cost(x,y))) ::: It cost below US $300 to take the GRE test."
            },
            "diff": [
                {
                    "raw": "OutOfWork(tom's dad, more than a year) ::: His dad has been out of work for more than a year.",
                    "gram": "Have(x,y)→ProvideAid(x,y) ::: His dad has been out of work for more than a year."
                }
            ],
            "answer": "A",
            "grammar_answer": "C"
        },
        {
            "id": 107,
            "raw_prog": {
                "First-Order-Logic Rules": "Costs(gre, 205) ::: It costs US $205 to take the GRE test.\n∀x ∀y (Prove(x, EconomicHardship(y)) → ProvidesAid(ETS, y)) ::: ETS provides financial aid to those GRE applicants who prove economic hardship.\n∀x (EconomicHardship(x) ↔ (TooLittleMoney(x) ∨ TooFewResources(x))) ::: Economic hardship refers to difficulty caused by having too little money or too few resources.\nSingleParent(tom) ::: Tom lives in a single-parent family.\nOutOfWork(dad, moreThanAYear) ::: His dad has been out of work for more than a year.\n",
                "First-Order-Logic Question": "¬∃x ∀y (Costs(gre, y) ∧ ProvidesAid(ETS, x)) ::: There is no financial aid available for the GRE test."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "Costs(gre, 205) ::: It costs US $205 to take the GRE test.\nProvidesAid(x,y)→Prove(x,y)∧EconomicHardship(y) ::: ETS provides financial aid to those GRE applicants who prove economic hardship.\n∀x (EconomicHardship(x) ↔ (TooLittleMoney(x) ∨ TooFewResources(x))) ::: Economic hardship refers to difficulty caused by having too little money or too few resources.\nSingleParent(tom) ::: Tom lives in a single-parent family.\nOutOfWork(dad, moreThanAYear) ::: His dad has been out of work for more than a year.\n",
                "First-Order-Logic Question": "¬∃x ∀y (Costs(gre, y) ∧ ProvidesAid(ETS, x)) ::: There is no financial aid available for the GRE test."
            },
            "diff": [
                {
                    "raw": "∀x ∀y (Prove(x, EconomicHardship(y)) → ProvidesAid(ETS, y)) ::: ETS provides financial aid to those GRE applicants who prove economic hardship.",
                    "gram": "ProvidesAid(x,y)→Prove(x,y)∧EconomicHardship(y) ::: ETS provides financial aid to those GRE applicants who prove economic hardship."
                }
            ],
            "answer": "B",
            "grammar_answer": "C"
        },
        {
            "id": 114,
            "raw_prog": {
                "First-Order-Logic Rules": "MountainRange(picurismountains) ∨ MountainRange(picurismountains) ::: The Picuris Mountains are a mountain range in New Mexico or Texas.\nVisited(juandeonate, picurismountains) ::: Juan de Onate visited the Picuris Mountains.\nLocatedIn(hardingpegmatitemine, picurismountains) ∧ Donated(hardingpegmatitemine) ::: The Harding Pegmatite Mine, located in the Picuris Mountains, was donated.\n∀x (MountainRange(x) ∧ In(x, texas) → ¬∃y (Mine(y) ∧ Has(y, donated) ∧ LocatedIn(y, x))) ::: There are no mountain ranges in Texas that have mines which have been donated.\n",
                "First-Order-Logic Question": "NotLocatedIn(hardingpegmatitemine, newmexico) ::: The Harding Pegmatite Mine is not located in a mountain range in New Mexico."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "MountainRange(picurismountains) ∨ MountainRange(picurismountains) ::: The Picuris Mountains are a mountain range in New Mexico or Texas.\nVisited(juandeonate, picurismountains) ::: Juan de Onate visited the Picuris Mountains.\nLocatedIn(hardingpegmatitemine, picurismountains) ∧ Donated(hardingpegmatitemine) ::: The Harding Pegmatite Mine, located in the Picuris Mountains, was donated.\n¬∃y(Mine(y)∧Has(y,x)∧LocatedIn(y,x)) ::: There are no mountain ranges in Texas that have mines which have been donated.\n",
                "First-Order-Logic Question": "NotLocatedIn(hardingpegmatitemine, newmexico) ::: The Harding Pegmatite Mine is not located in a mountain range in New Mexico."
            },
            "diff": [
                {
                    "raw": "∀x (MountainRange(x) ∧ In(x, texas) → ¬∃y (Mine(y) ∧ Has(y, donated) ∧ LocatedIn(y, x))) ::: There are no mountain ranges in Texas that have mines which have been donated.",
                    "gram": "¬∃y(Mine(y)∧Has(y,x)∧LocatedIn(y,x)) ::: There are no mountain ranges in Texas that have mines which have been donated."
                }
            ],
            "answer": "B",
            "grammar_answer": "C"
        }
    ],
    "gcd_llama-2-7b_4": [
        {
            "id": 41,
            "raw_prog": {
                "First-Order-Logic Rules": [
                    "∀x (ZahaHadid(x) → Timeless(x)) ::: All of Zaha Hadid's design styles are timeless.",
                    "∀x (MassProduct(x) → ¬Timeless(x)) ::: No mass product design is timeless.",
                    "∀x (ZahaHadid(x) ∨ KellyWearstler(x)) ::: Either Zaha Hadid's design style or Kelly Wearstler's design style.",
                    "∀x (KellyWearstler(x) → Evocative(x)) ::: All of Kelly Wearstler's design styles are evocative.",
                    "∀x (KellyWearstler(x) → Dreamy(x)) ::: All of Kelly Wearstler's design styles are dreamy.",
                    "∀x (Timeless(Max(x)) → (MassProduct(Max(x)) ∧ Evocative(Max(x)))) ::: If a design by Max is timeless, then a design by Max is a mass product design and evocative."
                ],
                "First-Order-Logic Question": [
                    "Evocative(Max(x)) ∨ Dreamy(Max(x)) ::: A design by Max is either evocative or dreamy."
                ]
            },
            "gram_prog": {
                "First-Order-Logic Rules": [
                    "∀x (ZahaHadid(x) → Timeless(x)) ::: All of Zaha Hadid's design styles are timeless.",
                    "∀x (MassProduct(x) → ¬Timeless(x)) ::: No mass product design is timeless.",
                    "∀x (ZahaHadid(x) ∨ KellyWearstler(x)) ::: Either Zaha Hadid's design style or Kelly Wearstler's design style.",
                    "∀x (KellyWearstler(x) → Evocative(x)) ::: All of Kelly Wearstler's design styles are evocative.",
                    "∀x (KellyWearstler(x) → Dreamy(x)) ::: All of Kelly Wearstler's design styles are dreamy.",
                    "∀x(Timeless(x)→(MassProduct(x))) ::: If a design by Max is timeless, then a design by Max is a mass product design and evocative."
                ],
                "First-Order-Logic Question": [
                    "Evocative(x)∨Dreamy(x) ::: A design by Max is either evocative or dreamy."
                ]
            },
            "diff": [
                {
                    "raw": "∀x (Timeless(Max(x)) → (MassProduct(Max(x)) ∧ Evocative(Max(x)))) ::: If a design by Max is timeless, then a design by Max is a mass product design and evocative.",
                    "gram": "∀x(Timeless(x)→(MassProduct(x))) ::: If a design by Max is timeless, then a design by Max is a mass product design and evocative."
                }
            ],
            "answer": "B",
            "grammar_answer": "A"
        },
        {
            "id": 70,
            "raw_prog": {
                "First-Order-Logic Rules": [
                    "British(badults) ∧ Sitcom(badults) ∧ ∀x (MemberOf(x, pappys) → Star(x, badults)) ::: Badults is a British Sitcom series, starring members of Pappy's.",
                    "Pilot(badults, 2013) ∧ Network(badults, bbcthree) ::: Badults piloted in July 2013 on BBC Three.",
                    "WorkingTitle(badults, thesecretdudesociety) ::: The Working title 'The Secret Dude Society' was used for Badults.",
                    "ScriptEditor(andrewcollins, badults) ::: Andrew Collins was the script editor for Badults."
                ],
                "First-Order-Logic Question": [
                    "∀x (MemberOf(x, pappys) → ¬∃y (Star(x, y) ∧ (Network(y, bbctwo) ∨ Network(y, bbcthree)))) ::: No members of Pappy's have starred for a show piloting on BBC Two or BBC Three."
                ]
            },
            "gram_prog": {
                "First-Order-Logic Rules": [
                    "British(badults) ∧ Sitcom(badults) ∧ ∀x (MemberOf(x, pappys) → Star(x, badults)) ::: Badults is a British Sitcom series, starring members of Pappy's.",
                    "Pilot(badults, 2013) ∧ Network(badults, bbcthree) ::: Badults piloted in July 2013 on BBC Three.",
                    "WorkingTitle(badults, thesecretdudesociety) ::: The Working title 'The Secret Dude Society' was used for Badults.",
                    "ScriptEditor(andrewcollins, badults) ::: Andrew Collins was the script editor for Badults."
                ],
                "First-Order-Logic Question": [
                    "∀x(MemberOf(x,y)→¬(Star(x,y))) ::: No members of Pappy's have starred for a show piloting on BBC Two or BBC Three."
                ]
            },
            "diff": [],
            "answer": "B",
            "grammar_answer": "C"
        },
        {
            "id": 93,
            "raw_prog": {
                "First-Order-Logic Rules": [
                    "∃x (Pet(x) ∧ ManagedBuilding(y) ∧ AllowedIn(x, y)) ::: Pets are allowed in some managed buildings.",
                    "∀x (ManagedBuilding(x) → DepositRequired(x)) ::: A deposit is required to rent an apartment in a managed building.",
                    "∀x ∀y (SecurityDeposit(x, y) → EqualOrMore(y, MonthlyRent(x, 1))) ::: The security deposit can be either equal to one month's rent or more.",
                    "Cat(fluffy) ∧ Owner(tom, fluffy) ::: Fluffy is Tom's cat.",
                    "∀x (Cat(x) → Pet(x)) ::: Cats are pets.",
                    "ManagedBuilding(olivegarden) ::: The Olive Garden is a managed building.",
                    "MonthlyRent(olivegarden, 2000) ::: The monthly rent at the Olive Garden is $2000.",
                    "∀x ∀y (Owner(x, y) ∧ Pet(y) ∧ ManagedBuilding(z) ∧ AllowedIn(y, z) ∧ SecurityDeposit(z, d) ∧ d ≤ 1500 ↔ Rent(x, z)) ::: Tom will rent an apartment in a managed building if and only if he is allowed to move in with Fluffy, and the security deposit is no more than $1500.",
                    "EqualOrMore(2000, 1500) ::: 2000$ is more than $1500."
                ],
                "First-Order-Logic Question": [
                    "Rent(tom, olivegarden) ::: Tom will rent an apartment in The Olive Garden."
                ]
            },
            "gram_prog": {
                "First-Order-Logic Rules": [
                    "∃x (Pet(x) ∧ ManagedBuilding(y) ∧ AllowedIn(x, y)) ::: Pets are allowed in some managed buildings.",
                    "∀x (ManagedBuilding(x) → DepositRequired(x)) ::: A deposit is required to rent an apartment in a managed building.",
                    "DepositRequired(x)→SecurityDeposit(x,y)→EqualOrMore(y,x) ::: The security deposit can be either equal to one month's rent or more.",
                    "Cat(fluffy) ∧ Owner(tom, fluffy) ::: Fluffy is Tom's cat.",
                    "∀x (Cat(x) → Pet(x)) ::: Cats are pets.",
                    "ManagedBuilding(olivegarden) ::: The Olive Garden is a managed building.",
                    "MonthlyRent(olivegarden, 2000) ::: The monthly rent at the Olive Garden is $2000.",
                    "∀x∀y(Owner(x,y)∧Pet(y)∧ManagedBuilding(z)∧AllowedIn(y,z)) ::: Tom will rent an apartment in a managed building if and only if he is allowed to move in with Fluffy, and the security deposit is no more than $1500.",
                    "EqualOrMore(2000, 1500) ::: 2000$ is more than $1500."
                ],
                "First-Order-Logic Question": [
                    "Rent(tom, olivegarden) ::: Tom will rent an apartment in The Olive Garden."
                ]
            },
            "diff": [
                {
                    "raw": "∀x ∀y (SecurityDeposit(x, y) → EqualOrMore(y, MonthlyRent(x, 1))) ::: The security deposit can be either equal to one month's rent or more.",
                    "gram": "DepositRequired(x)→SecurityDeposit(x,y)→EqualOrMore(y,x) ::: The security deposit can be either equal to one month's rent or more."
                },
                {
                    "raw": "∀x ∀y (Owner(x, y) ∧ Pet(y) ∧ ManagedBuilding(z) ∧ AllowedIn(y, z) ∧ SecurityDeposit(z, d) ∧ d ≤ 1500 ↔ Rent(x, z)) ::: Tom will rent an apartment in a managed building if and only if he is allowed to move in with Fluffy, and the security deposit is no more than $1500.",
                    "gram": "∀x∀y(Owner(x,y)∧Pet(y)∧ManagedBuilding(z)∧AllowedIn(y,z)) ::: Tom will rent an apartment in a managed building if and only if he is allowed to move in with Fluffy, and the security deposit is no more than $1500."
                }
            ],
            "answer": "B",
            "grammar_answer": "C"
        },
        {
            "id": 95,
            "raw_prog": {
                "First-Order-Logic Rules": [
                    "∃x (ManagedBuilding(x) ∧ Pet(y) ∧ AllowedIn(y, x)) ::: Pets are allowed in some managed buildings.",
                    "∀x (ManagedBuilding(x) → DepositRequired(x)) ::: A deposit is required to rent an apartment in a managed building.",
                    "∀x ∀y (SecurityDeposit(x, y) → (EqualOrMore(y, MonthlyRent(x, 1)) ∨ EqualOrMore(y, MonthlyRent(x, 2)))) ::: The security deposit can be either equal to one month's rent or more.",
                    "Cat(fluffy) ∧ Owner(tom, fluffy) ::: Fluffy is Tom's cat.",
                    "∀x (Cat(x) → Pet(x)) ::: Cats are pets.",
                    "ManagedBuilding(olivegarden) ::: The Olive Garden is a managed building.",
                    "MonthlyRent(olivegarden, 2000) ::: The monthly rent at the Olive Garden is $2000.",
                    "∀x ∀y (Owner(tom, fluffy) ∧ ManagedBuilding(x) ∧ (AllowedIn(fluffy, x) ∧ SecurityDeposit(x, y) ∧ EqualOrMore(1500, y)) ↔ Rent(tom, x)) ::: Tom will rent an apartment in a managed building if and only if he is allowed to move in with Fluffy, and the security deposit is no more than $1500.",
                    "EqualOrMore(2000, 1500) ::: 2000$ is more than $1500."
                ],
                "First-Order-Logic Question": [
                    "SecurityDeposit(olivegarden, 2000) ∨ ∃y (SecurityDeposit(olivegarden, y) ∧ EqualOrMore(y, 2000)) ::: The security deposit at the Olive Garden is either $2000 or more."
                ]
            },
            "gram_prog": {
                "First-Order-Logic Rules": [
                    "∃x (ManagedBuilding(x) ∧ Pet(y) ∧ AllowedIn(y, x)) ::: Pets are allowed in some managed buildings.",
                    "∀x (ManagedBuilding(x) → DepositRequired(x)) ::: A deposit is required to rent an apartment in a managed building.",
                    "∀x∀y(SecurityDeposit(x,y)→(EqualOrMore(y,x))) ::: The security deposit can be either equal to one month's rent or more.",
                    "Cat(fluffy) ∧ Owner(tom, fluffy) ::: Fluffy is Tom's cat.",
                    "∀x (Cat(x) → Pet(x)) ::: Cats are pets.",
                    "ManagedBuilding(olivegarden) ::: The Olive Garden is a managed building.",
                    "MonthlyRent(olivegarden, 2000) ::: The monthly rent at the Olive Garden is $2000.",
                    "∀x ∀y (Owner(tom, fluffy) ∧ ManagedBuilding(x) ∧ (AllowedIn(fluffy, x) ∧ SecurityDeposit(x, y) ∧ EqualOrMore(1500, y)) ↔ Rent(tom, x)) ::: Tom will rent an apartment in a managed building if and only if he is allowed to move in with Fluffy, and the security deposit is no more than $1500.",
                    "EqualOrMore(2000, 1500) ::: 2000$ is more than $1500."
                ],
                "First-Order-Logic Question": [
                    "SecurityDeposit(olivegarden, 2000) ∨ ∃y (SecurityDeposit(olivegarden, y) ∧ EqualOrMore(y, 2000)) ::: The security deposit at the Olive Garden is either $2000 or more."
                ]
            },
            "diff": [
                {
                    "raw": "∀x ∀y (SecurityDeposit(x, y) → (EqualOrMore(y, MonthlyRent(x, 1)) ∨ EqualOrMore(y, MonthlyRent(x, 2)))) ::: The security deposit can be either equal to one month's rent or more.",
                    "gram": "∀x∀y(SecurityDeposit(x,y)→(EqualOrMore(y,x))) ::: The security deposit can be either equal to one month's rent or more."
                }
            ],
            "answer": "A",
            "grammar_answer": "C"
        },
        {
            "id": 113,
            "raw_prog": {
                "First-Order-Logic Rules": [
                    "MountainRange(picurismountains) ∧ (In(picurismountains, newmexico) ⊕ In(picurismountains, texas)) ::: The Picuris Mountains are a mountain range in New Mexico or Texas.",
                    "Visit(juandeonate, picurismountains) ::: Juan de Onate visited the Picuris Mountains.",
                    "Mine(hardingpegmatitemine) ∧ LocatedIn(hardingpegmatitemine, picurismountains) ∧ Donate(hardingpegmatitemine) ::: The Harding Pegmatite Mine, located in the Picuris Mountains, was donated.",
                    "∀x (MountainRange(x) ∧ In(x, texas) → ¬∃y (Mine(y) ∧ LocatedIn(y, x) ∧ Donate(y))) ::: There are no mountain ranges in Texas that have mines which have been donated."
                ],
                "First-Order-Logic Question": "∃x (MountainRange(x) ∧ In(x, texas) ∧ Visit(juandeonate, x)) ::: Juan de Onate visited a mountain range in Texas."
            },
            "gram_prog": {
                "First-Order-Logic Rules": [
                    "MountainRange(picurismountains) ∧ (In(picurismountains, newmexico) ⊕ In(picurismountains, texas)) ::: The Picuris Mountains are a mountain range in New Mexico or Texas.",
                    "Visit(juandeonate, picurismountains) ::: Juan de Onate visited the Picuris Mountains.",
                    "Mine(hardingpegmatitemine) ∧ LocatedIn(hardingpegmatitemine, picurismountains) ∧ Donate(hardingpegmatitemine) ::: The Harding Pegmatite Mine, located in the Picuris Mountains, was donated.",
                    "∀x(MountainRange(x)→¬(In(x,y))) ::: There are no mountain ranges in Texas that have mines which have been donated."
                ],
                "First-Order-Logic Question": "∃x (MountainRange(x) ∧ In(x, texas) ∧ Visit(juandeonate, x)) ::: Juan de Onate visited a mountain range in Texas."
            },
            "diff": [
                {
                    "raw": "∀x (MountainRange(x) ∧ In(x, texas) → ¬∃y (Mine(y) ∧ LocatedIn(y, x) ∧ Donate(y))) ::: There are no mountain ranges in Texas that have mines which have been donated.",
                    "gram": "∀x(MountainRange(x)→¬(In(x,y))) ::: There are no mountain ranges in Texas that have mines which have been donated."
                }
            ],
            "answer": "C",
            "grammar_answer": "A"
        },
        {
            "id": 124,
            "raw_prog": {
                "First-Order-Logic Rules": "∀x (TransportMultiplePassengers(x) → ¬Empty(x)) ::: If something can transport multiple passengers, then they are not empty.\n∀x (Airline(x) → TransportMultiplePassengers(x)) ::: All airlines can transport multiple passengers.\n∀x (Plane(x) → Empty(x)) ::: All planes are empty.\n∀x (Boeing707(x) → Plane(x)) ::: All Boeing 707s are planes.\n¬Airline(greyhound) → ¬∃y (Greyhound(y) ∧ Plane(y)) ::: If Greyhound is not an airline, then there are no Greyhound planes.\n",
                "First-Order-Logic Question": "¬Greyhound(boeing707) ::: A Greyhound is not a Boeing 707."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∀x (TransportMultiplePassengers(x) → ¬Empty(x)) ::: If something can transport multiple passengers, then they are not empty.\n∀x (Airline(x) → TransportMultiplePassengers(x)) ::: All airlines can transport multiple passengers.\n∀x (Plane(x) → Empty(x)) ::: All planes are empty.\nPlane(boeing707) ::: Boeing 707 is a plane.\n¬Airline(greyhound) → ¬Plane(greyhound) ::: If Greyhound is not an airline, then there are no Greyhound planes.",
                "First-Order-Logic Question": "¬IsGreyhound(boeing707) ::: A Greyhound is not a Boeing 707."
            },
            "diff": [],
            "answer": "A",
            "grammar_answer": "C"
        },
        {
            "id": 143,
            "raw_prog": {
                "First-Order-Logic Rules": "∀x (BreedingBack(x) → ArtificiallySelected(x)) ::: Breeding back is a form of artificial selection by the deliberate selective breeding of domestic animals.\nBredBack(heck_cattle, aurochs) ∧ Resemble(heck_cattle, aurochs) ::: Heck cattle were bred-back in the 1920s to resemble the aurochs.\nAnimal(heck_cattle) ::: Heck cattle are animals.\nAnimal(aurochs) ::: Aurochs are animals.\n∃x ∃y (Animal(x) ∧ Animal(y) ∧ BredBack(x, y) ∧ Resemble(x, y) ∧ Extinct(y)) ::: Some animals to be bred-back resemble animals that are extinct.\n",
                "First-Order-Logic Question": "∃x (Animal(x) ∧ ArtificiallySelected(x) ∧ x = heck_cattle) ::: Some Heck cattle are artificially selected."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∀x (BreedingBack(x) → ArtificiallySelected(x)) ::: Breeding back is a form of artificial selection by the deliberate selective breeding of domestic animals.\nBredBack(heck_cattle, aurochs) ∧ Resemble(heck_cattle, aurochs) ::: Heck cattle were bred-back in the 1920s to resemble the aurochs.\nAnimal(heck_cattle) ::: Heck cattle are animals.\nAnimal(aurochs) ::: Aurochs are animals.\n∃x ∃y (Animal(x) ∧ Animal(y) ∧ BredBack(x, y) ∧ Resemble(x, y) ∧ Extinct(y)) ::: Some animals to be bred-back resemble animals that are extinct.\n",
                "First-Order-Logic Question": "∃x(Animal(x)∧ArtificiallySelected(x)∧Resemble(x,x)) ::: Some Heck cattle are artificially selected."
            },
            "diff": [],
            "answer": "A",
            "grammar_answer": "C"
        },
        {
            "id": 10,
            "raw_prog": {
                "First-Order-Logic Rules": "∀x (WildTurkey(x) → (EasternWildTurkey(x) ∨ OsceolaWildTurkey(x) ∨ GouldsWildTurkey(x) ∨ MerriamsWildTurkey(x) ∨ RioGrandeWildTurkey(x) ∨ OcellatedWildTurkey(x))) ::: There are six types of wild turkeys: Eastern wild turkey, Osceola wild turkey, Gould’s wild turkey, Merriam’s wild turkey, Rio Grande wild turkey, and Ocellated wild turkey.\nNot(tom, EasternWildTurkey(tom)) ::: Tom is not an Eastern wild turkey.\nNot(tom, OsceolaWildTurkey(tom)) ::: Tom is not an Osceola wild turkey.\nNot(tom, GouldsWildTurkey(tom)) ∧ Not(tom, MerriamsWildTurkey(tom)) ∧ Not(tom, RioGrandeWildTurkey(tom)) ::: Tom is also not a Gould's wild turkey, or a Merriam's wild turkey, or a Rio Grande wild turkey.\nWildTurkey(tom) ::: Tom is a wild turkey.\n",
                "First-Order-Logic Question": "EasternWildTurkey(tom) ::: Tom is an Eastern wild turkey."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∀x (WildTurkey(x) → (EasternWildTurkey(x) ∨ OsceolaWildTurkey(x) ∨ GouldsWildTurkey(x) ∨ MerriamsWildTurkey(x) ∨ RioGrandeWildTurkey(x) ∨ OcellatedWildTurkey(x))) ::: There are six types of wild turkeys: Eastern wild turkey, Osceola wild turkey, Gould’s wild turkey, Merriam’s wild turkey, Rio Grande wild turkey, and Ocellated wild turkey.\nNot(x,y)→(EasternWildTurkey(x)→¬OsceolaWildTurkey(x)) ::: Tom is not an Eastern wild turkey.\nNot(x,y)→OsceolaWildTurkey(x) ::: Tom is not an Osceola wild turkey.\nNot(x,y)→(WildTurkey(x)∧¬EasternWildTurkey(x)) ::: Tom is also not a Gould's wild turkey, or a Merriam's wild turkey, or a Rio Grande wild turkey.\nWildTurkey(tom) ::: Tom is a wild turkey.\n",
                "First-Order-Logic Question": "EasternWildTurkey(tom) ::: Tom is an Eastern wild turkey."
            },
            "diff": [
                {
                    "raw": "Not(tom, EasternWildTurkey(tom)) ::: Tom is not an Eastern wild turkey.",
                    "gram": "Not(x,y)→(EasternWildTurkey(x)→¬OsceolaWildTurkey(x)) ::: Tom is not an Eastern wild turkey."
                },
                {
                    "raw": "Not(tom, OsceolaWildTurkey(tom)) ::: Tom is not an Osceola wild turkey.",
                    "gram": "Not(x,y)→OsceolaWildTurkey(x) ::: Tom is not an Osceola wild turkey."
                },
                {
                    "raw": "Not(tom, GouldsWildTurkey(tom)) ∧ Not(tom, MerriamsWildTurkey(tom)) ∧ Not(tom, RioGrandeWildTurkey(tom)) ::: Tom is also not a Gould's wild turkey, or a Merriam's wild turkey, or a Rio Grande wild turkey.",
                    "gram": "Not(x,y)→(WildTurkey(x)∧¬EasternWildTurkey(x)) ::: Tom is also not a Gould's wild turkey, or a Merriam's wild turkey, or a Rio Grande wild turkey."
                }
            ],
            "answer": "B",
            "grammar_answer": "C"
        },
        {
            "id": 114,
            "raw_prog": {
                "First-Order-Logic Rules": [
                    "MountainRange(picurismountains) ∧ (In(picurismountains, newmexico) ⊕ In(picurismountains, texas)) ::: The Picuris Mountains are a mountain range in New Mexico or Texas.",
                    "Visit(juandeonate, picurismountains) ::: Juan de Onate visited the Picuris Mountains.",
                    "Mine(hardingpegmatitemine) ∧ In(hardingpegmatitemine, picurismountains) ∧ Donate(hardingpegmatitemine) ::: The Harding Pegmatite Mine, located in the Picuris Mountains, was donated.",
                    "∀x (MountainRange(x) ∧ In(x, texas) → ¬∃y (Mine(y) ∧ In(y, x) ∧ Donate(y))) ::: There are no mountain ranges in Texas that have mines which have been donated."
                ],
                "First-Order-Logic Question": [
                    "¬In(hardingpegmatitemine, newmexico) ::: The Harding Pegmatite Mine is not located in a mountain range in New Mexico."
                ]
            },
            "gram_prog": {
                "First-Order-Logic Rules": [
                    "MountainRange(picurismountains) ∧ (In(picurismountains, newmexico) ⊕ In(picurismountains, texas)) ::: The Picuris Mountains are a mountain range in New Mexico or Texas.",
                    "Visit(juandeonate, picurismountains) ::: Juan de Onate visited the Picuris Mountains.",
                    "Mine(hardingpegmatitemine) ∧ In(hardingpegmatitemine, picurismountains) ∧ Donate(hardingpegmatitemine) ::: The Harding Pegmatite Mine, located in the Picuris Mountains, was donated.",
                    "∀x(MountainRange(x)→¬In(x,y))∧¬In(x,y)→Donate(x) ::: There are no mountain ranges in Texas that have mines which have been donated."
                ],
                "First-Order-Logic Question": [
                    "¬In(hardingpegmatitemine, newmexico) ::: The Harding Pegmatite Mine is not located in a mountain range in New Mexico."
                ]
            },
            "diff": [
                {
                    "raw": "∀x (MountainRange(x) ∧ In(x, texas) → ¬∃y (Mine(y) ∧ In(y, x) ∧ Donate(y))) ::: There are no mountain ranges in Texas that have mines which have been donated.",
                    "gram": "∀x(MountainRange(x)→¬In(x,y))∧¬In(x,y)→Donate(x) ::: There are no mountain ranges in Texas that have mines which have been donated."
                }
            ],
            "answer": "B",
            "grammar_answer": "C"
        },
        {
            "id": 38,
            "raw_prog": {
                "First-Order-Logic Rules": [
                    "MusicPiece(symphonyNo9) ::: Symphony No. 9 is a music piece.",
                    "∀x (Composer(x) → ∃y (Write(x, y) ∧ MusicPiece(y))) ::: Composers write music pieces.",
                    "Write(beethoven, symphonyNo9) ∧ Composer(beethoven) ::: Beethoven wrote Symphony No. 9.",
                    "Premiere(viennaMusicSociety, symphonyNo9) ::: Vienna Music Society premiered Symphony No. 9.",
                    "Orchestra(viennaMusicSociety) ::: Vienna Music Society is an orchestra.",
                    "Lead(beethoven, viennaMusicSociety) ::: Beethoven leads the Vienna Music Society.",
                    "∀x (Orchestra(x) → ∃y (Lead(y, x) ∧ Conductor(y))) ::: Orchestras are led by conductors."
                ],
                "First-Order-Logic Question": "Not(Conductor(beethoven)) ::: Beethoven is not a conductor."
            },
            "gram_prog": {
                "First-Order-Logic Rules": [
                    "MusicPiece(symphonyNo9) ::: Symphony No. 9 is a music piece.",
                    "∀x (Composer(x) → ∃y (Write(x, y) ∧ MusicPiece(y))) ::: Composers write music pieces.",
                    "Write(beethoven, symphonyNo9) ∧ Composer(beethoven) ::: Beethoven wrote Symphony No. 9.",
                    "Premiere(viennaMusicSociety, symphonyNo9) ::: Vienna Music Society premiered Symphony No. 9.",
                    "Orchestra(viennaMusicSociety) ::: Vienna Music Society is an orchestra.",
                    "Lead(beethoven, viennaMusicSociety) ::: Beethoven leads the Vienna Music Society.",
                    "∀x (Orchestra(x) → ∃y (Lead(y, x) ∧ Conductor(y))) ::: Orchestras are led by conductors."
                ],
                "First-Order-Logic Question": "Not(x)→Composer(x)∨Write(x,y)∨Premiere(x,y)∨Orchestra(x)∨Lead(x,y)∨Conductor(x) ::: Beethoven is not a conductor."
            },
            "diff": [],
            "answer": "B",
            "grammar_answer": "C"
        }
    ],
    "gcd_llama-2-13b_3.5": [
        {
            "id": 2,
            "raw_prog": {
                "First-Order-Logic Rules": "∀x (Perform(x) → (Attend(x) ∧ Engaged(x))) ::: If people perform in school talent shows often, then they attend and are very engaged with school events.\n∀x ((Perform(x) ∨ (Inactive(x) ∧ Disinterested(x))) ::: People either perform in school talent shows often or are inactive and disinterested members of their community.\n∀x (Chaperone(x) → ¬Student(x)) ::: If people chaperone high school dances, then they are not students who attend the school.\n∀x ((Inactive(x) ∧ Disinterested(x)) → Chaperone(x)) ::: All people who are inactive and disinterested members of their community chaperone high school dances.\n∀x ((Young(x) ∨ Teenager(x)) ∧ Wish(x) → Student(x)) ::: All young children and teenagers who wish to further their academic careers and educational opportunities are students who attend the school.\n¬((Attend(Bonnie) ∧ Engaged(Bonnie)) ⊕ Student(Bonnie)) ::: Bonnie either both attends and is very engaged with school events and is a student who attends the school, or she neither attends and is very engaged with school events nor is a student who attends the school.\n",
                "First-Order-Logic Question": "((Chaperone(Bonnie) ∨ ¬Chaperone(Bonnie) ∧ Perform(Bonnie)) → ((Young(Bonnie) ∨ Teenager(Bonnie)) ∧ Wish(Bonnie) ∧ Inactive(Bonnie) ∧ Disinterested(Bonnie))) ::: If Bonnie either chaperones high school dances or, if she does not, she performs in school talent shows often, then Bonnie is both a young child or teenager who wishes to further her academic career and educational opportunities and an inactive and disinterested member of the community."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∀x (Perform(x) → (Attend(x) ∧ Engaged(x))) ::: If people perform in school talent shows often, then they attend and are very engaged with school events.\n∀x((Perform(x)∨Inactive(x))) ::: People either perform in school talent shows often or are inactive and disinterested members of their community.\n∀x (Chaperone(x) → ¬Student(x)) ::: If people chaperone high school dances, then they are not students who attend the school.\n∀x ((Inactive(x) ∧ Disinterested(x)) → Chaperone(x)) ::: All people who are inactive and disinterested members of their community chaperone high school dances.\n∀x ((Young(x) ∨ Teenager(x)) ∧ Wish(x) → Student(x)) ::: All young children and teenagers who wish to further their academic careers and educational opportunities are students who attend the school.\n¬((Attend(Bonnie) ∧ Engaged(Bonnie)) ⊕ Student(Bonnie)) ::: Bonnie either both attends and is very engaged with school events and is a student who attends the school, or she neither attends and is very engaged with school events nor is a student who attends the school.\n",
                "First-Order-Logic Question": "((Chaperone(Bonnie) ∨ ¬Chaperone(Bonnie) ∧ Perform(Bonnie)) → ((Young(Bonnie) ∨ Teenager(Bonnie)) ∧ Wish(Bonnie) ∧ Inactive(Bonnie) ∧ Disinterested(Bonnie))) ::: If Bonnie either chaperones high school dances or, if she does not, she performs in school talent shows often, then Bonnie is both a young child or teenager who wishes to further her academic career and educational opportunities and an inactive and disinterested member of the community."
            },
            "diff": [
                {
                    "raw": "∀x ((Perform(x) ∨ (Inactive(x) ∧ Disinterested(x))) ::: People either perform in school talent shows often or are inactive and disinterested members of their community.",
                    "gram": "∀x((Perform(x)∨Inactive(x))) ::: People either perform in school talent shows often or are inactive and disinterested members of their community."
                }
            ],
            "answer": "B",
            "grammar_answer": "C"
        },
        {
            "id": 93,
            "raw_prog": {
                "First-Order-Logic Rules": "∃x (Pet(x) ∧ AllowedIn(x, y)) ::: Pets are allowed in some managed buildings.\n∀x (RequireDeposit(x) → ∃y (RentApartment(z, y) ∧ SecurityDeposit(x) ∧ (Equal(SecurityDeposit(x), RentAmount(y)) ∨ MoreThan(SecurityDeposit(x), RentAmount(y))))) ::: A deposit is required to rent an apartment in a managed building. The security deposit can be either equal to one month's rent or more.\nCat(fluffy) ∧ Pet(fluffy) ∧ Owner(tom, fluffy) ::: Fluffy is Tom's cat.\nCat(x) → Pet(x) ::: Cats are pets.\nManagedBuilding(olivegarden) ::: The Olive Garden is a managed building.\nRentAmount(2000, olivegarden) ::: The monthly rent at the Olive Garden is $2000.\nRentApartment(tom, olivegarden) ↔ (AllowedIn(tom, olivegarden) ∧ SecurityDeposit(olivegarden) ∧ (Equal(SecurityDeposit(olivegarden), 1500) ∨ ¬MoreThan(SecurityDeposit(olivegarden), 1500))) ::: Tom will rent an apartment in a managed building if and only if he is allowed to move in with Fluffy, and the security deposit is no more than $1500.\nMoreThan(2000, 1500) ::: 2000$ is more than $1500.",
                "First-Order-Logic Question": "RentApartment(tom, olivegarden) ::: Tom will rent an apartment in The Olive Garden."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∃x (Pet(x) ∧ AllowedIn(x, y)) ::: Pets are allowed in some managed buildings.\nRequireDeposit(x)→(RentApartment(z,y)∧SecurityDeposit(x)) ::: A deposit is required to rent an apartment in a managed building. The security deposit can be either equal to one month's rent or more.\nCat(fluffy) ∧ Pet(fluffy) ∧ Owner(tom, fluffy) ::: Fluffy is Tom's cat.\nCat(x) → Pet(x) ::: Cats are pets.\nManagedBuilding(olivegarden) ::: The Olive Garden is a managed building.\nRentAmount(2000, olivegarden) ::: The monthly rent at the Olive Garden is $2000.\nRentApartment(x,y)↔(AllowedIn(x,y)∧SecurityDeposit(y)) ::: Tom will rent an apartment in a managed building if and only if he is allowed to move in with Fluffy, and the security deposit is no more than $1500.\nMoreThan(2000, 1500) ::: 2000$ is more than $1500.",
                "First-Order-Logic Question": "RentApartment(tom, olivegarden) ::: Tom will rent an apartment in The Olive Garden."
            },
            "diff": [
                {
                    "raw": "∀x (RequireDeposit(x) → ∃y (RentApartment(z, y) ∧ SecurityDeposit(x) ∧ (Equal(SecurityDeposit(x), RentAmount(y)) ∨ MoreThan(SecurityDeposit(x), RentAmount(y))))) ::: A deposit is required to rent an apartment in a managed building. The security deposit can be either equal to one month's rent or more.",
                    "gram": "RequireDeposit(x)→(RentApartment(z,y)∧SecurityDeposit(x)) ::: A deposit is required to rent an apartment in a managed building. The security deposit can be either equal to one month's rent or more."
                },
                {
                    "raw": "RentApartment(tom, olivegarden) ↔ (AllowedIn(tom, olivegarden) ∧ SecurityDeposit(olivegarden) ∧ (Equal(SecurityDeposit(olivegarden), 1500) ∨ ¬MoreThan(SecurityDeposit(olivegarden), 1500))) ::: Tom will rent an apartment in a managed building if and only if he is allowed to move in with Fluffy, and the security deposit is no more than $1500.",
                    "gram": "RentApartment(x,y)↔(AllowedIn(x,y)∧SecurityDeposit(y)) ::: Tom will rent an apartment in a managed building if and only if he is allowed to move in with Fluffy, and the security deposit is no more than $1500."
                }
            ],
            "answer": "B",
            "grammar_answer": "C"
        },
        {
            "id": 104,
            "raw_prog": {
                "First-Order-Logic Rules": "∀x (Twins(x) ∨ Triplets(x) → SpendTimeWith(x, x)) ::: If people are twins or triplets, then they spend a lot of time hanging out with and playing with their siblings.\n∀x (Siblings(x, y) → Twins(x) ∨ Triplets(x)) ::: If people have siblings who are the same age, then they are twins or triplets.\n∀x (Complain(x) → Siblings(x, y)) ::: If people complain often about annoying siblings, then they have siblings who are the same age.\n∀x (¬LiveAtHome(x) → ¬DevelopBonds(x, y)) ::: If people do not live at home regularly, then they do not develop strong bonds with their family members.\n∀x (SpendTimeWith(x, y) → ¬LiveAtHome(x)) ::: If people spend a lot of time hanging out with and playing with their siblings, then they often did not live at home regularly.\n(Twins(luke) ∧ DevelopBonds(luke, luke)) ⊕ (¬Twins(luke) ∧ ¬DevelopBonds(luke, luke)) ::: Luke is either both a twin or triplet and develops strong bonds with his family members, or he neither is a twin or triplet nor develops strong bonds with his family members.\n",
                "First-Order-Logic Question": "¬(Twins(luke) ∨ Triplets(luke) ∨ Complain(luke)) ::: Luke is neither a twin nor triplet nor complains often about annoying siblings."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∀x (Twins(x) ∨ Triplets(x) → SpendTimeWith(x, x)) ::: If people are twins or triplets, then they spend a lot of time hanging out with and playing with their siblings.\n∀x (Siblings(x, y) → Twins(x) ∨ Triplets(x)) ::: If people have siblings who are the same age, then they are twins or triplets.\n∀x (Complain(x) → Siblings(x, y)) ::: If people complain often about annoying siblings, then they have siblings who are the same age.\n∀x (¬LiveAtHome(x) → ¬DevelopBonds(x, y)) ::: If people do not live at home regularly, then they do not develop strong bonds with their family members.\n∀x (SpendTimeWith(x, y) → ¬LiveAtHome(x)) ::: If people spend a lot of time hanging out with and playing with their siblings, then they often did not live at home regularly.\n(Twins(luke) ∧ DevelopBonds(luke, luke)) ⊕ (¬Twins(luke) ∧ ¬DevelopBonds(luke, luke)) ::: Luke is either both a twin or triplet and develops strong bonds with his family members, or he neither is a twin or triplet nor develops strong bonds with his family members.\n",
                "First-Order-Logic Question": "¬(Twins(luke) ∨ Triplets(luke) ∨ Complain(luke)) ::: Luke is neither a twin nor triplet nor complains often about annoying siblings."
            },
            "diff": [],
            "answer": "A",
            "grammar_answer": "C"
        },
        {
            "id": 123,
            "raw_prog": {
                "First-Order-Logic Rules": "∀x (Transport(x) → ¬Empty(x)) ::: If something can transport multiple passengers, then they are not empty. \n∀x (Airline(x) → Transport(x)) ::: All airlines can transport multiple passengers. \n∀x (Plane(x) → Empty(x)) ::: All planes are empty. \n∀x (Boeing707(x) → Plane(x)) ::: All Boeing 707s are planes. \nAirline(Greyhound) → ¬∃x (Greyhound(x) ∧ Plane(x)) ::: If Greyhound is not an airline, then there are no Greyhound planes.\n",
                "First-Order-Logic Question": "Boeing707(Greyhound) ::: A Greyhound is a Boeing 707."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∀x (Transport(x) → ¬Empty(x)) ::: If something can transport multiple passengers, then they are not empty. \n∀x (Airline(x) → Transport(x)) ::: All airlines can transport multiple passengers. \n∀x (Plane(x) → Empty(x)) ::: All planes are empty. \n∀x (Boeing707(x) → Plane(x)) ::: All Boeing 707s are planes. \nAirline(x)→¬(Plane(x)) ::: If Greyhound is not an airline, then there are no Greyhound planes.\n",
                "First-Order-Logic Question": "Boeing707(Greyhound) ::: A Greyhound is a Boeing 707."
            },
            "diff": [
                {
                    "raw": "Airline(Greyhound) → ¬∃x (Greyhound(x) ∧ Plane(x)) ::: If Greyhound is not an airline, then there are no Greyhound planes.",
                    "gram": "Airline(x)→¬(Plane(x)) ::: If Greyhound is not an airline, then there are no Greyhound planes."
                }
            ],
            "answer": "B",
            "grammar_answer": "C"
        },
        {
            "id": 124,
            "raw_prog": {
                "First-Order-Logic Rules": "∀x (Transport(x) → ¬Empty(x)) ::: If something can transport multiple passengers, then they are not empty. \n∀x (Airline(x) → Transport(x)) ::: All airlines can transport multiple passengers. \n∀x (Plane(x) → Empty(x)) ::: All planes are empty. \n∀x (Boeing707(x) → Plane(x)) ::: All Boeing 707s are planes. \nAirline(Greyhound) → ¬∃x (Greyhound(x) ∧ Plane(x)) ::: If Greyhound is not an airline, then there are no Greyhound planes.\n",
                "First-Order-Logic Question": "¬(Greyhound(x) ∧ Boeing707(x)) ::: A Greyhound is not a Boeing 707."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∀x (Transport(x) → ¬Empty(x)) ::: If something can transport multiple passengers, then they are not empty. \n∀x (Airline(x) → Transport(x)) ::: All airlines can transport multiple passengers. \n∀x (Plane(x) → Empty(x)) ::: All planes are empty. \n∀x (Boeing707(x) → Plane(x)) ::: All Boeing 707s are planes. \nAirline(x)→¬(Plane(x)) ::: If Greyhound is not an airline, then there are no Greyhound planes.\n",
                "First-Order-Logic Question": "¬(Greyhound(x) ∧ Boeing707(x)) ::: A Greyhound is not a Boeing 707."
            },
            "diff": [
                {
                    "raw": "Airline(Greyhound) → ¬∃x (Greyhound(x) ∧ Plane(x)) ::: If Greyhound is not an airline, then there are no Greyhound planes.",
                    "gram": "Airline(x)→¬(Plane(x)) ::: If Greyhound is not an airline, then there are no Greyhound planes."
                }
            ],
            "answer": "A",
            "grammar_answer": "C"
        },
        {
            "id": 128,
            "raw_prog": {
                "First-Order-Logic Rules": "∀x (HaveWedding(x) → HaveChild(x)) ::: All people who have a wedding are people who have at least one child.\n∀x (TravelToParis(x) → HaveWedding(x)) ::: All people who travel to Paris for their honeymoon are people who have a wedding.\n∀x (OccurIn(x, July) ∧ HaveWedding(x) → TravelToParis(x)) ::: All weddings that occur in July belong to people who travel to Paris for their honeymoon.\n∃x (OccurIn(x, July) ∧ WellAttended(x)) ::: Some weddings in July are well-attended.\nHaveChild(John) → (¬TravelToParis(John) ∧ ¬HaveWedding(John)) ::: If John has at least one child, then John does not travel to Paris for his honeymoon and does not have a wedding.\nHaveWedding(John) ∧ WellAttended(John) → (OccurIn(John, July) ∨ (¬OccurIn(John, July) → TravelToParis(John))) ::: If John has a wedding that is well-attended, then John has a wedding in July or, if not, then John travels to Paris for their honeymoon.",
                "First-Order-Logic Question": "WellAttended(John) ::: John has a wedding that is well-attended."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∀x (HaveWedding(x) → HaveChild(x)) ::: All people who have a wedding are people who have at least one child.\n∀x (TravelToParis(x) → HaveWedding(x)) ::: All people who travel to Paris for their honeymoon are people who have a wedding.\n∀x (OccurIn(x, July) ∧ HaveWedding(x) → TravelToParis(x)) ::: All weddings that occur in July belong to people who travel to Paris for their honeymoon.\n∃x (OccurIn(x, July) ∧ WellAttended(x)) ::: Some weddings in July are well-attended.\nHaveChild(John) → (¬TravelToParis(John) ∧ ¬HaveWedding(John)) ::: If John has at least one child, then John does not travel to Paris for his honeymoon and does not have a wedding.\nHaveWedding(John) ∧ WellAttended(John) → (OccurIn(John, July) ∨ (¬OccurIn(John, July) → TravelToParis(John))) ::: If John has a wedding that is well-attended, then John has a wedding in July or, if not, then John travels to Paris for their honeymoon.",
                "First-Order-Logic Question": "WellAttended(John) ::: John has a wedding that is well-attended."
            },
            "diff": [],
            "answer": "B",
            "grammar_answer": "C"
        },
        {
            "id": 138,
            "raw_prog": {
                "First-Order-Logic Rules": "∀x (Algorithm(x) → (SupervisedLearning(x) ∨ UnsupervisedLearning(x) ∨ ReinforcementLearning(x))) ::: Machine Learning algorithms can be categorized as supervised learning, unsupervised learning, and reinforcement learning.\n∀x (UnsupervisedLearning(x) → ¬RequireLabelledData(x)) ::: Unsupervised learning doesn't require labelled data.\nStateOfTheArtModel(model) ∧ Algorithm(algo) ∧ TrainedWith(model, algo) ::: The state-of-the-art text summarization model is trained with machine learning algorithms.\nReinforcementLearning(rl) → ¬TrainedWith(StateOfTheArtModel(model), rl) ::: Reinforcement learning is not used to train the state-of-the-art text summarization model.\n∀x (Algorithm(x) ∧ TrainedWith(StateOfTheArtModel(model), x) → RequireLabelledData(x)) ::: The Machine Learning algorithm for training text summarization model requires labelled data.\n",
                "First-Order-Logic Question": "SupervisedLearning(supervised) ∧ TrainedWith(StateOfTheArtModel(model), supervised) ::: Supervised learning is used to train the state-of-the-art text summarization model."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∀x (Algorithm(x) → (SupervisedLearning(x) ∨ UnsupervisedLearning(x) ∨ ReinforcementLearning(x))) ::: Machine Learning algorithms can be categorized as supervised learning, unsupervised learning, and reinforcement learning.\n∀x (UnsupervisedLearning(x) → ¬RequireLabelledData(x)) ::: Unsupervised learning doesn't require labelled data.\nStateOfTheArtModel(model) ∧ Algorithm(algo) ∧ TrainedWith(model, algo) ::: The state-of-the-art text summarization model is trained with machine learning algorithms.\nReinforcementLearning(x)→¬TrainedWith(x,y) ::: Reinforcement learning is not used to train the state-of-the-art text summarization model.\n∀x(Algorithm(x)∧TrainedWith(x,y)→RequireLabelledData(x)) ::: The Machine Learning algorithm for training text summarization model requires labelled data.\n",
                "First-Order-Logic Question": "SupervisedLearning(x)∧TrainedWith(x,y) ::: Supervised learning is used to train the state-of-the-art text summarization model."
            },
            "diff": [
                {
                    "raw": "ReinforcementLearning(rl) → ¬TrainedWith(StateOfTheArtModel(model), rl) ::: Reinforcement learning is not used to train the state-of-the-art text summarization model.",
                    "gram": "ReinforcementLearning(x)→¬TrainedWith(x,y) ::: Reinforcement learning is not used to train the state-of-the-art text summarization model."
                },
                {
                    "raw": "∀x (Algorithm(x) ∧ TrainedWith(StateOfTheArtModel(model), x) → RequireLabelledData(x)) ::: The Machine Learning algorithm for training text summarization model requires labelled data.",
                    "gram": "∀x(Algorithm(x)∧TrainedWith(x,y)→RequireLabelledData(x)) ::: The Machine Learning algorithm for training text summarization model requires labelled data."
                }
            ],
            "answer": "A",
            "grammar_answer": "C"
        },
        {
            "id": 139,
            "raw_prog": {
                "First-Order-Logic Rules": "∀x (SupervisedLearning(x) ∨ UnsupervisedLearning(x) ∨ ReinforcementLearning(x)) ::: Machine Learning algorithms can be categorized as supervised learning, unsupervised learning, and reinforcement learning.\nUnsupervisedLearning(x) → ¬RequireLabelledData(x) ::: Unsupervised learning doesn't require labelled data.\nTrainedWith(StateOfTheArtModel(textsummarization), MachineLearningAlgorithm(x)) ::: The state-of-the-art text summarization model is trained with machine learning algorithms.\nReinforcementLearning(x) → ¬TrainedWith(StateOfTheArtModel(textsummarization), x) ::: Reinforcement learning is not used to train the state-of-the-art text summarization model.\nRequireLabelledData(x) → MachineLearningAlgorithm(x) ::: The Machine Learning algorithm for training text summarization model requires labelled data.\n",
                "First-Order-Logic Question": "¬UsedToTrain(UnsupervisedLearning, StateOfTheArtModel(textsummarization)) ::: Unsupervised learning is used to train the state-of-the-art text summarization model."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∀x (SupervisedLearning(x) ∨ UnsupervisedLearning(x) ∨ ReinforcementLearning(x)) ::: Machine Learning algorithms can be categorized as supervised learning, unsupervised learning, and reinforcement learning.\nUnsupervisedLearning(x) → ¬RequireLabelledData(x) ::: Unsupervised learning doesn't require labelled data.\nTrainedWith(x,y) ::: The state-of-the-art text summarization model is trained with machine learning algorithms.\nReinforcementLearning(x)→¬TrainedWith(x,x) ::: Reinforcement learning is not used to train the state-of-the-art text summarization model.\nRequireLabelledData(x) → MachineLearningAlgorithm(x) ::: The Machine Learning algorithm for training text summarization model requires labelled data.\n",
                "First-Order-Logic Question": "¬UsedToTrain(x,y) ::: Unsupervised learning is used to train the state-of-the-art text summarization model."
            },
            "diff": [
                {
                    "raw": "TrainedWith(StateOfTheArtModel(textsummarization), MachineLearningAlgorithm(x)) ::: The state-of-the-art text summarization model is trained with machine learning algorithms.",
                    "gram": "TrainedWith(x,y) ::: The state-of-the-art text summarization model is trained with machine learning algorithms."
                },
                {
                    "raw": "ReinforcementLearning(x) → ¬TrainedWith(StateOfTheArtModel(textsummarization), x) ::: Reinforcement learning is not used to train the state-of-the-art text summarization model.",
                    "gram": "ReinforcementLearning(x)→¬TrainedWith(x,x) ::: Reinforcement learning is not used to train the state-of-the-art text summarization model."
                }
            ],
            "answer": "B",
            "grammar_answer": "C"
        },
        {
            "id": 153,
            "raw_prog": {
                "First-Order-Logic Rules": "∀x,y (Owns(x, y) → (WorkRegularlyAtHome(x) ∧ TidyOrganize(x))) ::: If people own a large desktop monitor at their home, then they work regularly and often at home.\n∀x (HasHomeOffice(x) → Owns(x, largeDesktopMonitor)) ::: All people who have a fully stocked and impressive home office are people who own a large desktop monitor at their home.\n∀x (WorkRegularlyAtHome(x) → TidyOrganize(x)) ::: All people who work regularly and often at home spend their free time tidying and organizing the spaces in their homes.\n∀x (WorkRegularlyAtHome(x) → VisitStore(x)) ::: All people who work regularly and often at home visit the office supply store regularly.\n∀x (TidyOrganize(x) → (¬GoToBedLate(x) ∧ WakeUpLate(x))) ::: If people spend their free time tidying and organizing the spaces in their home, then they do not go to bed late and wake up every day after noon.\n(TidyOrganize(remy) ∧ (GoToBedLate(remy) ∧ WakeUpLate(remy))) ⊕ (¬GoToBedLate(remy) ∧ ¬WakeUpLate(remy) ∧ ¬TidyOrganize(remy)) ::: Remy either both goes to bed late and wakes up every day after noon and spends their free time tidying and organizing the spaces in their home, or they do not go to bed late and wake up every day after noon nor spend their free time tidying and organizing the spaces in their home.\n",
                "First-Order-Logic Question": "VisitStore(remy) ::: Remy visits the office supply store regularly."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "GoToBedLate(x)→WorkRegularlyAtHome(x)∧TidyOrganize(x) ::: If people own a large desktop monitor at their home, then they work regularly and often at home.\n∀x (HasHomeOffice(x) → Owns(x, largeDesktopMonitor)) ::: All people who have a fully stocked and impressive home office are people who own a large desktop monitor at their home.\n∀x (WorkRegularlyAtHome(x) → TidyOrganize(x)) ::: All people who work regularly and often at home spend their free time tidying and organizing the spaces in their homes.\n∀x (WorkRegularlyAtHome(x) → VisitStore(x)) ::: All people who work regularly and often at home visit the office supply store regularly.\n∀x (TidyOrganize(x) → (¬GoToBedLate(x) ∧ WakeUpLate(x))) ::: If people spend their free time tidying and organizing the spaces in their home, then they do not go to bed late and wake up every day after noon.\n(TidyOrganize(remy) ∧ (GoToBedLate(remy) ∧ WakeUpLate(remy))) ⊕ (¬GoToBedLate(remy) ∧ ¬WakeUpLate(remy) ∧ ¬TidyOrganize(remy)) ::: Remy either both goes to bed late and wakes up every day after noon and spends their free time tidying and organizing the spaces in their home, or they do not go to bed late and wake up every day after noon nor spend their free time tidying and organizing the spaces in their home.\n",
                "First-Order-Logic Question": "VisitStore(remy) ::: Remy visits the office supply store regularly."
            },
            "diff": [
                {
                    "raw": "∀x,y (Owns(x, y) → (WorkRegularlyAtHome(x) ∧ TidyOrganize(x))) ::: If people own a large desktop monitor at their home, then they work regularly and often at home.",
                    "gram": "GoToBedLate(x)→WorkRegularlyAtHome(x)∧TidyOrganize(x) ::: If people own a large desktop monitor at their home, then they work regularly and often at home."
                }
            ],
            "answer": "C",
            "grammar_answer": "A"
        },
        {
            "id": 155,
            "raw_prog": {
                "First-Order-Logic Rules": "∀x,y (Owns(x, y) → (WorkRegularly(x) ∧ WorkOften(x))) ::: If people own a large desktop monitor at their home, then they work regularly and often at home.\n∀x (FullyStocked(x) → Owns(x, largeDesktopMonitor) ∧ Impressive(x)) ::: All people who have a fully stocked and impressive home office are people who own a large desktop monitor at their home.\n∀x (WorkRegularly(x) ∧ WorkOften(x) → Tidy(x)) ::: All people who work regularly and often at home spend their free time tidying and organizing the spaces in their homes.\n∀x (WorkRegularly(x) ∧ WorkOften(x) → VisitStore(x)) ::: All people who work regularly and often at home visit the office supply store regularly.\n∀x (Tidy(x) → (¬Late(x) ∧ ¬WakeLate(x))) ::: If people spend their free time tidying and organizing the spaces in their home, then they do not go to bed late and wake up every day after noon.\n(Tidy(remy) ∧ Late(remy) ∧ WakeLate(remy)) ⊕ (¬Late(remy) ∧ ¬WakeLate(remy) ∧ ¬Tidy(remy)) ::: Remy either both goes to bed late and wakes up every day after noon and spends their free time tidying and organizing the spaces in their home, or they do not go to bed late and wake up every day after noon nor spend their free time tidying and organizing the spaces in their home.\n",
                "First-Order-Logic Question": "((Late(remy) ∧ WakeLate(remy)) ∨ VisitStore(remy)) → (¬Tidy(remy) ∧ ¬FullyStocked(remy)) ::: If Remy either goes to bed late and wakes up every day after noon or visits the office supply store regularly, then Remy neither spends their free time tidying and organizing the spaces in their home nor has a fully stocked and impressive home office."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∀x(Owns(x,y)→(WorkRegularly(x))) ::: If people own a large desktop monitor at their home, then they work regularly and often at home.\n∀x (FullyStocked(x) → Owns(x, largeDesktopMonitor) ∧ Impressive(x)) ::: All people who have a fully stocked and impressive home office are people who own a large desktop monitor at their home.\n∀x (WorkRegularly(x) ∧ WorkOften(x) → Tidy(x)) ::: All people who work regularly and often at home spend their free time tidying and organizing the spaces in their homes.\n∀x (WorkRegularly(x) ∧ WorkOften(x) → VisitStore(x)) ::: All people who work regularly and often at home visit the office supply store regularly.\n∀x (Tidy(x) → (¬Late(x) ∧ ¬WakeLate(x))) ::: If people spend their free time tidying and organizing the spaces in their home, then they do not go to bed late and wake up every day after noon.\n(Tidy(remy) ∧ Late(remy) ∧ WakeLate(remy)) ⊕ (¬Late(remy) ∧ ¬WakeLate(remy) ∧ ¬Tidy(remy)) ::: Remy either both goes to bed late and wakes up every day after noon and spends their free time tidying and organizing the spaces in their home, or they do not go to bed late and wake up every day after noon nor spend their free time tidying and organizing the spaces in their home.\n",
                "First-Order-Logic Question": "((Late(remy) ∧ WakeLate(remy)) ∨ VisitStore(remy)) → (¬Tidy(remy) ∧ ¬FullyStocked(remy)) ::: If Remy either goes to bed late and wakes up every day after noon or visits the office supply store regularly, then Remy neither spends their free time tidying and organizing the spaces in their home nor has a fully stocked and impressive home office."
            },
            "diff": [
                {
                    "raw": "∀x,y (Owns(x, y) → (WorkRegularly(x) ∧ WorkOften(x))) ::: If people own a large desktop monitor at their home, then they work regularly and often at home.",
                    "gram": "∀x(Owns(x,y)→(WorkRegularly(x))) ::: If people own a large desktop monitor at their home, then they work regularly and often at home."
                }
            ],
            "answer": "A",
            "grammar_answer": "C"
        },
        {
            "id": 166,
            "raw_prog": {
                "First-Order-Logic Rules": "∃x ∃y (Monday(y) ∧ Time(y) ∧ Roses(x) ∧ GivenOut(x, y)) ::: On some Mondays at 8 pm, roses are given out on TV.\n∀x (Roses(x) → On(x, Bachelor)) ::: Every rose given out on TV is on the Bachelor.\n∀x (On(x, Bachelor) → Portray(x, RealPeople)) ::: Everything on the Bachelor portrays the lives of real people.\n∀x (Portray(x, RealPeople) → RealityTVShow(x)) ::: All shows portraying the lives of real people are reality TV shows.\n¬RealityTVShow(BreakingBad) ::: Breaking Bad is not a reality TV show.\n",
                "First-Order-Logic Question": "∀x (Roses(x) ∧ GivenOut(x, Monday(8pm))) → On(BreakingBad, Monday(8pm)) ::: If roses are given out during Breaking Bad, then it is on Monday at 8 pm."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∃x ∃y (Monday(y) ∧ Time(y) ∧ Roses(x) ∧ GivenOut(x, y)) ::: On some Mondays at 8 pm, roses are given out on TV.\n∀x (Roses(x) → On(x, Bachelor)) ::: Every rose given out on TV is on the Bachelor.\n∀x (On(x, Bachelor) → Portray(x, RealPeople)) ::: Everything on the Bachelor portrays the lives of real people.\n∀x (Portray(x, RealPeople) → RealityTVShow(x)) ::: All shows portraying the lives of real people are reality TV shows.\n¬RealityTVShow(BreakingBad) ::: Breaking Bad is not a reality TV show.\n",
                "First-Order-Logic Question": "GivenOut(x,y)→On(x,y) ::: If roses are given out during Breaking Bad, then it is on Monday at 8 pm."
            },
            "diff": [],
            "answer": "A",
            "grammar_answer": "C"
        },
        {
            "id": 181,
            "raw_prog": {
                "First-Order-Logic Rules": "Flies(susan, LGA) ::: Susan flies to LGA airport.\n∀x (Airport(x) ∧ Flies(john, x) ∧ ¬(DepartsFrom(john, x) ∧ ArrivesAt(john, x))) ::: The departure and arrival can not be the same airport.\n",
                "First-Order-Logic Question": "Flies(john, LGA) ::: John flies to LGA airport."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "Flies(susan, LGA) ::: Susan flies to LGA airport.\n∀x (Airport(x) ∧ Flies(john, x) ∧ ¬(DepartsFrom(john, x) ∧ ArrivesAt(john, x))) ::: The departure and arrival can not be the same airport.\n",
                "First-Order-Logic Question": "Flies(john, LGA) ::: John flies to LGA airport."
            },
            "diff": [],
            "answer": "B",
            "grammar_answer": "A"
        },
        {
            "id": 1,
            "raw_prog": {
                "First-Order-Logic Rules": "∀x (Perform(x) → (Attend(x) ∧ Engaged(x))) ::: If people perform in school talent shows often, then they attend and are very engaged with school events.\n∀x ((Perform(x) ∨ (Inactive(x) ∧ Disinterested(x))) ::: People either perform in school talent shows often or are inactive and disinterested members of their community.\n∀x (Chaperone(x) → ¬Student(x)) ::: If people chaperone high school dances, then they are not students who attend the school.\n∀x ((Inactive(x) ∧ Disinterested(x)) → Chaperone(x)) ::: All people who are inactive and disinterested members of their community chaperone high school dances.\n∀x ((Young(x) ∨ Teenager(x)) ∧ Wish(x) → Student(x)) ::: All young children and teenagers who wish to further their academic careers and educational opportunities are students who attend the school.\n¬((Attend(Bonnie) ∧ Engaged(Bonnie)) ⊕ Student(Bonnie)) ::: Bonnie either both attends and is very engaged with school events and is a student who attends the school, or she neither attends and is very engaged with school events nor is a student who attends the school.",
                "First-Order-Logic Question": "((Young(Bonnie) ∨ Teenager(Bonnie)) ∧ Wish(Bonnie) ∧ Chaperone(Bonnie)) ∨ ¬((Young(Bonnie) ∨ Teenager(Bonnie)) ∧ ¬Wish(Bonnie)) → (Student(Bonnie) ∨ (Inactive(Bonnie) ∧ Disinterested(Bonnie)))"
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∀x (Perform(x) → (Attend(x) ∧ Engaged(x))) ::: If people perform in school talent shows often, then they attend and are very engaged with school events.\n∀x((Perform(x)∨Inactive(x))) ::: People either perform in school talent shows often or are inactive and disinterested members of their community.\n∀x (Chaperone(x) → ¬Student(x)) ::: If people chaperone high school dances, then they are not students who attend the school.\n∀x ((Inactive(x) ∧ Disinterested(x)) → Chaperone(x)) ::: All people who are inactive and disinterested members of their community chaperone high school dances.\n∀x ((Young(x) ∨ Teenager(x)) ∧ Wish(x) → Student(x)) ::: All young children and teenagers who wish to further their academic careers and educational opportunities are students who attend the school.\n¬((Attend(Bonnie) ∧ Engaged(Bonnie)) ⊕ Student(Bonnie)) ::: Bonnie either both attends and is very engaged with school events and is a student who attends the school, or she neither attends and is very engaged with school events nor is a student who attends the school.",
                "First-Order-Logic Question": "((Young(Bonnie) ∨ Teenager(Bonnie)) ∧ Wish(Bonnie) ∧ Chaperone(Bonnie)) ∨ ¬((Young(Bonnie) ∨ Teenager(Bonnie)) ∧ ¬Wish(Bonnie)) → (Student(Bonnie) ∨ (Inactive(Bonnie) ∧ Disinterested(Bonnie)))"
            },
            "diff": [
                {
                    "raw": "∀x ((Perform(x) ∨ (Inactive(x) ∧ Disinterested(x))) ::: People either perform in school talent shows often or are inactive and disinterested members of their community.",
                    "gram": "∀x((Perform(x)∨Inactive(x))) ::: People either perform in school talent shows often or are inactive and disinterested members of their community."
                }
            ],
            "answer": "A",
            "grammar_answer": "C"
        },
        {
            "id": 95,
            "raw_prog": {
                "First-Order-Logic Rules": "∃x ∃y (Pet(x) ∧ ManagedBuilding(y) ∧ AllowedIn(x, y)) ::: Pets are allowed in some managed buildings.\n∀x (RequireDeposit(x) → ∃y (RentApartment(y) ∧ Equal(SecurityDeposit(x), MonthlyRent(y, olivegarden)) ∨ MoreThan(SecurityDeposit(x), 1500))) ::: A deposit is required to rent an apartment in a managed building. The security deposit can be either equal to one month's rent or more.\nCat(fluffy) ∧ Pet(fluffy) ∧ Owner(tom, fluffy) ::: Fluffy is Tom's cat.\nCat(x) → Pet(x) ::: Cats are pets.\nManagedBuilding(olivegarden) ::: The Olive Garden is a managed building.\nMonthlyRent(2000, olivegarden) ::: The monthly rent at the Olive Garden is $2000.\nRentApartment(tom) ↔ (AllowedIn(tom, fluffy) ∧ ¬MoreThan(SecurityDeposit(olivegarden), 1500)) ::: Tom will rent an apartment in a managed building if and only if he is allowed to move in with Fluffy, and the security deposit is no more than $1500.\nMoreThan(2000, 1500) ::: 2000$ is more than $1500.",
                "First-Order-Logic Question": "Equal(SecurityDeposit(olivegarden), 2000) ∨ MoreThan(SecurityDeposit(olivegarden), 2000) ::: The security deposit at the Olive Garden is either $2000 or more."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∃x ∃y (Pet(x) ∧ ManagedBuilding(y) ∧ AllowedIn(x, y)) ::: Pets are allowed in some managed buildings.\n∀x(RequireDeposit(x)→(RentApartment(y))) ::: A deposit is required to rent an apartment in a managed building. The security deposit can be either equal to one month's rent or more.\nCat(fluffy) ∧ Pet(fluffy) ∧ Owner(tom, fluffy) ::: Fluffy is Tom's cat.\nCat(x) → Pet(x) ::: Cats are pets.\nManagedBuilding(olivegarden) ::: The Olive Garden is a managed building.\nMonthlyRent(2000, olivegarden) ::: The monthly rent at the Olive Garden is $2000.\nRentApartment(x)↔(AllowedIn(x,y)∧¬MoreThan(x,y)) ::: Tom will rent an apartment in a managed building if and only if he is allowed to move in with Fluffy, and the security deposit is no more than $1500.\nMoreThan(2000, 1500) ::: 2000$ is more than $1500.",
                "First-Order-Logic Question": "MoreThan(x,y)→Equal(x,y) ::: The security deposit at the Olive Garden is either $2000 or more."
            },
            "diff": [
                {
                    "raw": "∀x (RequireDeposit(x) → ∃y (RentApartment(y) ∧ Equal(SecurityDeposit(x), MonthlyRent(y, olivegarden)) ∨ MoreThan(SecurityDeposit(x), 1500))) ::: A deposit is required to rent an apartment in a managed building. The security deposit can be either equal to one month's rent or more.",
                    "gram": "∀x(RequireDeposit(x)→(RentApartment(y))) ::: A deposit is required to rent an apartment in a managed building. The security deposit can be either equal to one month's rent or more."
                },
                {
                    "raw": "RentApartment(tom) ↔ (AllowedIn(tom, fluffy) ∧ ¬MoreThan(SecurityDeposit(olivegarden), 1500)) ::: Tom will rent an apartment in a managed building if and only if he is allowed to move in with Fluffy, and the security deposit is no more than $1500.",
                    "gram": "RentApartment(x)↔(AllowedIn(x,y)∧¬MoreThan(x,y)) ::: Tom will rent an apartment in a managed building if and only if he is allowed to move in with Fluffy, and the security deposit is no more than $1500."
                }
            ],
            "answer": "A",
            "grammar_answer": "C"
        },
        {
            "id": 103,
            "raw_prog": {
                "First-Order-Logic Rules": "∀x (Twins(x) ∨ Triplets(x) → SpendTimeWith(x, Siblings(x))) ::: If people are twins or triplets, then they spend a lot of time hanging out with and playing with their siblings.\n∀x (Siblings(x, y) → Twins(x) ∨ Triplets(x)) ::: If people have siblings who are the same age, then they are twins or triplets.\n∀x (Complain(x) → Siblings(x, y)) ::: If people complain often about annoying siblings, then they have siblings who are the same age.\n∀x (¬LiveAtHomeRegularly(x) → ¬DevelopBonds(x, y)) ::: If people do not live at home regularly, then they do not develop strong bonds with their family members.\n∀x (SpendTimeWith(x, Siblings(x)) → ¬LiveAtHomeRegularly(x)) ::: If people spend a lot of time hanging out with and playing with their siblings, then they often did not live at home regularly.\n(Twins(luke) ∧ DevelopBonds(luke, FamilyMembers)) ∨ (¬Twins(luke) ∧ ¬DevelopBonds(luke, FamilyMembers)) ::: Luke is either both a twin or triplet and develops strong bonds with his family members, or he neither is a twin or triplet nor develops strong bonds with his family members.\n",
                "First-Order-Logic Question": "Complain(luke) ::: Luke complains often about annoying siblings."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∀x(Twins(x)∨Triplets(x)→SpendTimeWith(x,x)) ::: If people are twins or triplets, then they spend a lot of time hanging out with and playing with their siblings.\n∀x (Siblings(x, y) → Twins(x) ∨ Triplets(x)) ::: If people have siblings who are the same age, then they are twins or triplets.\n∀x (Complain(x) → Siblings(x, y)) ::: If people complain often about annoying siblings, then they have siblings who are the same age.\n∀x (¬LiveAtHomeRegularly(x) → ¬DevelopBonds(x, y)) ::: If people do not live at home regularly, then they do not develop strong bonds with their family members.\n∀x(SpendTimeWith(x,y)→¬LiveAtHomeRegularly(x)) ::: If people spend a lot of time hanging out with and playing with their siblings, then they often did not live at home regularly.\n(Twins(luke) ∧ DevelopBonds(luke, FamilyMembers)) ∨ (¬Twins(luke) ∧ ¬DevelopBonds(luke, FamilyMembers)) ::: Luke is either both a twin or triplet and develops strong bonds with his family members, or he neither is a twin or triplet nor develops strong bonds with his family members.\n",
                "First-Order-Logic Question": "Complain(luke) ::: Luke complains often about annoying siblings."
            },
            "diff": [],
            "answer": "B",
            "grammar_answer": "C"
        },
        {
            "id": 106,
            "raw_prog": {
                "First-Order-Logic Rules": "Cost(gre_test, 205) ::: It costs US $205 to take the GRE test.\n∀x (Take(gre_test, x) ∧ EconomicHardship(x) → Provide(ets, financial_aid, x)) ::: ETS provides financial aid to those GRE applicants who prove economic hardship.\n∀x (EconomicHardship(x) ↔ (Cause(Difficulty(x), TooLittleMoney) ∨ Cause(Difficulty(x), TooFewResources))) ::: Economic hardship refers to difficulty caused by having too little money or too few resources.\nSingleParent(tom) ::: Tom lives in a single-parent family.\nUnemployed(dad) ∧ ∃y (y > 1 ∧ Time(y, year) ∧ Cause(Difficulty(dad), Unemployed(dad))) ::: His dad has been out of work for more than a year.",
                "First-Order-Logic Question": "∃x (Cost(gre_test, x) ∧ x < 300) ::: It cost below US $300 to take the GRE test."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "Cost(gre_test, 205) ::: It costs US $205 to take the GRE test.\n∀x (Take(gre_test, x) ∧ EconomicHardship(x) → Provide(ets, financial_aid, x)) ::: ETS provides financial aid to those GRE applicants who prove economic hardship.\nEconomicHardship(x)↔((Cause(x,y))) ::: Economic hardship refers to difficulty caused by having too little money or too few resources.\nSingleParent(tom) ::: Tom lives in a single-parent family.\nUnemployed(x)∧(Cause(x,y)∧CostBelow(y,z)) ::: His dad has been out of work for more than a year.",
                "First-Order-Logic Question": "∃x(CostBelow(x,y)∧Take(x,y)) ::: It cost below US $300 to take the GRE test."
            },
            "diff": [
                {
                    "raw": "∀x (EconomicHardship(x) ↔ (Cause(Difficulty(x), TooLittleMoney) ∨ Cause(Difficulty(x), TooFewResources))) ::: Economic hardship refers to difficulty caused by having too little money or too few resources.",
                    "gram": "EconomicHardship(x)↔((Cause(x,y))) ::: Economic hardship refers to difficulty caused by having too little money or too few resources."
                },
                {
                    "raw": "Unemployed(dad) ∧ ∃y (y > 1 ∧ Time(y, year) ∧ Cause(Difficulty(dad), Unemployed(dad))) ::: His dad has been out of work for more than a year.",
                    "gram": "Unemployed(x)∧(Cause(x,y)∧CostBelow(y,z)) ::: His dad has been out of work for more than a year."
                }
            ],
            "answer": "A",
            "grammar_answer": "C"
        },
        {
            "id": 129,
            "raw_prog": {
                "First-Order-Logic Rules": "∀x (HaveWedding(x) → HaveChild(x)) ::: All people who have a wedding are people who have at least one child.\n∀x (TravelToParisForHoneymoon(x) → HaveWedding(x)) ::: All people who travel to Paris for their honeymoon are people who have a wedding.\n∀x (Weddings(x) ∧ July(x) → BelongTo(x, TravelToParisForHoneymoon(x))) ::: All weddings that occur in July belong to people who travel to Paris for their honeymoon.\n∃x (Weddings(x) ∧ July(x) ∧ WellAttended(x)) ::: Some weddings in July are well-attended.\nHaveChild(John) → (¬TravelToParisForHoneymoon(John) ∧ ¬HaveWedding(John)) ::: If John has at least one child, then John does not travel to Paris for his honeymoon and does not have a wedding.\nHaveWedding(John) ∧ WellAttended(John) → (July(John) ∨ (¬July(John) ∧ TravelToParisForHoneymoon(John))) ::: If John has a wedding that is well-attended, then John has a wedding in July or, if not, then John travels to Paris for their honeymoon.",
                "First-Order-Logic Question": "¬WellAttended(John) ::: John does not have a wedding that is well-attended."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∀x (HaveWedding(x) → HaveChild(x)) ::: All people who have a wedding are people who have at least one child.\n∀x (TravelToParisForHoneymoon(x) → HaveWedding(x)) ::: All people who travel to Paris for their honeymoon are people who have a wedding.\n∀x(WellAttended(x)→BelongTo(x,x)) ::: All weddings that occur in July belong to people who travel to Paris for their honeymoon.\n∃x (Weddings(x) ∧ July(x) ∧ WellAttended(x)) ::: Some weddings in July are well-attended.\nHaveChild(John) → (¬TravelToParisForHoneymoon(John) ∧ ¬HaveWedding(John)) ::: If John has at least one child, then John does not travel to Paris for his honeymoon and does not have a wedding.\nHaveWedding(John) ∧ WellAttended(John) → (July(John) ∨ (¬July(John) ∧ TravelToParisForHoneymoon(John))) ::: If John has a wedding that is well-attended, then John has a wedding in July or, if not, then John travels to Paris for their honeymoon.",
                "First-Order-Logic Question": "¬WellAttended(John) ::: John does not have a wedding that is well-attended."
            },
            "diff": [
                {
                    "raw": "∀x (Weddings(x) ∧ July(x) → BelongTo(x, TravelToParisForHoneymoon(x))) ::: All weddings that occur in July belong to people who travel to Paris for their honeymoon.",
                    "gram": "∀x(WellAttended(x)→BelongTo(x,x)) ::: All weddings that occur in July belong to people who travel to Paris for their honeymoon."
                }
            ],
            "answer": "A",
            "grammar_answer": "C"
        },
        {
            "id": 131,
            "raw_prog": {
                "First-Order-Logic Rules": "∀x HaveWedding(x) → HaveChild(x) ::: All people who have a wedding are people who have at least one child.\n∀x (TravelToParisForHoneymoon(x) → HaveWedding(x)) ::: All people who travel to Paris for their honeymoon are people who have a wedding.\n∀x (Weddings(x) ∧ July(x) → BelongTo(x, TravelToParisForHoneymoon(x))) ::: All weddings that occur in July belong to people who travel to Paris for their honeymoon.\n∃x (Weddings(x) ∧ July(x) ∧ WellAttended(x)) ::: Some weddings in July are well-attended.\nHaveChild(John) → ¬(TravelToParisForHoneymoon(John) ∧ HaveWedding(John)) ::: If John has at least one child, then John does not travel to Paris for his honeymoon and does not have a wedding.\nHaveWedding(John) ∧ WellAttended(John) → (July(John) ∨ (¬July(John) ∧ TravelToParisForHoneymoon(John))) ::: If John has a wedding that is well-attended, then John has a wedding in July or, if not, then John travels to Paris for their honeymoon.",
                "First-Order-Logic Question": "¬(WellAttended(John) ∨ TravelToParisForHoneymoon(John)) ::: John has neither a wedding that is well-attended nor does he travel to Paris for his honeymoon."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∀x HaveWedding(x) → HaveChild(x) ::: All people who have a wedding are people who have at least one child.\n∀x (TravelToParisForHoneymoon(x) → HaveWedding(x)) ::: All people who travel to Paris for their honeymoon are people who have a wedding.\n∀x(WellAttended(x)→BelongTo(x,x)) ::: All weddings that occur in July belong to people who travel to Paris for their honeymoon.\n∃x (Weddings(x) ∧ July(x) ∧ WellAttended(x)) ::: Some weddings in July are well-attended.\nHaveChild(John) → ¬(TravelToParisForHoneymoon(John) ∧ HaveWedding(John)) ::: If John has at least one child, then John does not travel to Paris for his honeymoon and does not have a wedding.\nHaveWedding(John) ∧ WellAttended(John) → (July(John) ∨ (¬July(John) ∧ TravelToParisForHoneymoon(John))) ::: If John has a wedding that is well-attended, then John has a wedding in July or, if not, then John travels to Paris for their honeymoon.",
                "First-Order-Logic Question": "¬(WellAttended(John) ∨ TravelToParisForHoneymoon(John)) ::: John has neither a wedding that is well-attended nor does he travel to Paris for his honeymoon."
            },
            "diff": [
                {
                    "raw": "∀x (Weddings(x) ∧ July(x) → BelongTo(x, TravelToParisForHoneymoon(x))) ::: All weddings that occur in July belong to people who travel to Paris for their honeymoon.",
                    "gram": "∀x(WellAttended(x)→BelongTo(x,x)) ::: All weddings that occur in July belong to people who travel to Paris for their honeymoon."
                }
            ],
            "answer": "A",
            "grammar_answer": "C"
        },
        {
            "id": 154,
            "raw_prog": {
                "First-Order-Logic Rules": "∀x,y (Owns(x, y) → (WorkRegularlyAtHome(x) ∧ TidyOrganize(x))) ::: If people own a large desktop monitor at their home, then they work regularly and often at home.\n∀x,y (FullyStockedImpressiveHomeOffice(x) → LargeDesktopMonitor(x, y)) ::: All people who have a fully stocked and impressive home office are people who own a large desktop monitor at their home.\n∀x (WorkRegularlyAtHome(x) → TidyOrganize(x)) ::: All people who work regularly and often at home spend their free time tidying and organizing the spaces in their homes.\n∀x (WorkRegularlyAtHome(x) → VisitOfficeStore(x)) ::: All people who work regularly and often at home visit the office supply store regularly.\n∀x (TidyOrganize(x) → (¬GoToBedLate(x) ∧ ¬WakeUpAfterNoon(x))) ::: If people spend their free time tidying and organizing the spaces in their home, then they do not go to bed late and wake up every day after noon.\n(TidyOrganize(remy) ∧ (GoToBedLate(remy) ∧ WakeUpAfterNoon(remy))) ⊕ (¬GoToBedLate(remy) ∧ ¬WakeUpAfterNoon(remy) ∧ ¬TidyOrganize(remy)) ::: Remy either both goes to bed late and wakes up every day after noon and spends their free time tidying and organizing the spaces in their home, or they do not go to bed late and wake up every day after noon nor spend their free time tidying and organizing the spaces in their home.\n",
                "First-Order-Logic Question": "FullyStockedImpressiveHomeOffice(remy) ∧ VisitOfficeStore(remy) ::: Remy has a fully stocked and impressive home office and also visits the office supply store regularly."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "GoToBedLate(x)→WorkRegularlyAtHome(x)∧TidyOrganize(x) ::: If people own a large desktop monitor at their home, then they work regularly and often at home.\nGoToBedLate(x)→LargeDesktopMonitor(x,y) ::: All people who have a fully stocked and impressive home office are people who own a large desktop monitor at their home.\n∀x (WorkRegularlyAtHome(x) → TidyOrganize(x)) ::: All people who work regularly and often at home spend their free time tidying and organizing the spaces in their homes.\n∀x (WorkRegularlyAtHome(x) → VisitOfficeStore(x)) ::: All people who work regularly and often at home visit the office supply store regularly.\n∀x (TidyOrganize(x) → (¬GoToBedLate(x) ∧ ¬WakeUpAfterNoon(x))) ::: If people spend their free time tidying and organizing the spaces in their home, then they do not go to bed late and wake up every day after noon.\n(TidyOrganize(remy) ∧ (GoToBedLate(remy) ∧ WakeUpAfterNoon(remy))) ⊕ (¬GoToBedLate(remy) ∧ ¬WakeUpAfterNoon(remy) ∧ ¬TidyOrganize(remy)) ::: Remy either both goes to bed late and wakes up every day after noon and spends their free time tidying and organizing the spaces in their home, or they do not go to bed late and wake up every day after noon nor spend their free time tidying and organizing the spaces in their home.\n",
                "First-Order-Logic Question": "FullyStockedImpressiveHomeOffice(remy) ∧ VisitOfficeStore(remy) ::: Remy has a fully stocked and impressive home office and also visits the office supply store regularly."
            },
            "diff": [
                {
                    "raw": "∀x,y (Owns(x, y) → (WorkRegularlyAtHome(x) ∧ TidyOrganize(x))) ::: If people own a large desktop monitor at their home, then they work regularly and often at home.",
                    "gram": "GoToBedLate(x)→WorkRegularlyAtHome(x)∧TidyOrganize(x) ::: If people own a large desktop monitor at their home, then they work regularly and often at home."
                },
                {
                    "raw": "∀x,y (FullyStockedImpressiveHomeOffice(x) → LargeDesktopMonitor(x, y)) ::: All people who have a fully stocked and impressive home office are people who own a large desktop monitor at their home.",
                    "gram": "GoToBedLate(x)→LargeDesktopMonitor(x,y) ::: All people who have a fully stocked and impressive home office are people who own a large desktop monitor at their home."
                }
            ],
            "answer": "B",
            "grammar_answer": "A"
        },
        {
            "id": 180,
            "raw_prog": {
                "First-Order-Logic Rules": "Flies(susan, lga) ::: Susan flies to LGA airport.\nDeparture(x, y) ∧ Arrival(x, y) ⊕ ¬(x = y) ::: The departure and arrival can not be the same airport.\nFrom(john, lga) ::: John flies from LGA airport.",
                "First-Order-Logic Question": "From(susan, lga) ::: Susan flies from LGA airport."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "Flies(susan, lga) ::: Susan flies to LGA airport.\nDeparture(x,y)∧Arrival(x,y)⊕¬(From(x,y)) ::: The departure and arrival can not be the same airport.\nFrom(john, lga) ::: John flies from LGA airport.",
                "First-Order-Logic Question": "From(susan, lga) ::: Susan flies from LGA airport."
            },
            "diff": [
                {
                    "raw": "Departure(x, y) ∧ Arrival(x, y) ⊕ ¬(x = y) ::: The departure and arrival can not be the same airport.",
                    "gram": "Departure(x,y)∧Arrival(x,y)⊕¬(From(x,y)) ::: The departure and arrival can not be the same airport."
                }
            ],
            "answer": "B",
            "grammar_answer": "C"
        },
        {
            "id": 201,
            "raw_prog": {
                "First-Order-Logic Rules": "Person(ailtonSilva) ∧ Born(ailtonSilva, 1995) ∧ KnownAs(ailtonSilva, ailton) ::: Ailton Silva, born in 1995, is commonly known as Ailton.\nFootballPlayer(ailton) ∧ Loan(ailton, braga) ::: Ailton is a football player who was loaned out to Braga.\nBrazilian(ailtonSilva) ∧ FootballPlayer(ailtonSilva) ∧ PlaysFor(ailtonSilva, nautico) ::: Ailton Silva is a Brazillian footballer who plays for Nautico.\nClub(nautico) ∧ Club(braga) ∧ Team(nautico, braga) ::: Nautico is a football club along with Braga.\nClub(fluminense) ::: Fluminense is a football club.\n",
                "First-Order-Logic Question": "¬(∃x Loan(ailton, Club(x))) ::: Ailton was not loaned out to a football club."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "Person(ailtonSilva) ∧ Born(ailtonSilva, 1995) ∧ KnownAs(ailtonSilva, ailton) ::: Ailton Silva, born in 1995, is commonly known as Ailton.\nFootballPlayer(ailton) ∧ Loan(ailton, braga) ::: Ailton is a football player who was loaned out to Braga.\nBrazilian(ailtonSilva) ∧ FootballPlayer(ailtonSilva) ∧ PlaysFor(ailtonSilva, nautico) ::: Ailton Silva is a Brazillian footballer who plays for Nautico.\nClub(nautico) ∧ Club(braga) ∧ Team(nautico, braga) ::: Nautico is a football club along with Braga.\nClub(fluminense) ::: Fluminense is a football club.\n",
                "First-Order-Logic Question": "¬(Loan(x,y)) ::: Ailton was not loaned out to a football club."
            },
            "diff": [],
            "answer": "B",
            "grammar_answer": "C"
        },
        {
            "id": 14,
            "raw_prog": {
                "First-Order-Logic Rules": "Create(japaneseGameCompany, legendOfZelda) ::: A Japanese game company created the game the Legend of Zelda.\n∀x (Game(x) ∧ MoreThanOneMillion(x) → Select(x, Top10(x))) ::: If a game sells more than one million copies, then it will be selected into the Top 10 list.\n∀x (Top10(x) → Japanese(Create(japanese, x))) ::: All games in the Top 10 list are made by Japanese game companies.\nMoreThanOneMillion(legendOfZelda) ::: The Legend of Zelda sold more than one million copies.",
                "First-Order-Logic Question": "¬Top10(legendOfZelda) ::: The Legend of Zelda is not in the Top 10 list."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "Create(japaneseGameCompany, legendOfZelda) ::: A Japanese game company created the game the Legend of Zelda.\nGame(x,y)∧Sell(x,z)∧MoreThanOneMillion(x)→Select(x,y) ::: If a game sells more than one million copies, then it will be selected into the Top 10 list.\n∀x(Top10(x)→Japanese(x)) ::: All games in the Top 10 list are made by Japanese game companies.\nMoreThanOneMillion(legendOfZelda) ::: The Legend of Zelda sold more than one million copies.",
                "First-Order-Logic Question": "¬Top10(legendOfZelda) ::: The Legend of Zelda is not in the Top 10 list."
            },
            "diff": [
                {
                    "raw": "∀x (Game(x) ∧ MoreThanOneMillion(x) → Select(x, Top10(x))) ::: If a game sells more than one million copies, then it will be selected into the Top 10 list.",
                    "gram": "Game(x,y)∧Sell(x,z)∧MoreThanOneMillion(x)→Select(x,y) ::: If a game sells more than one million copies, then it will be selected into the Top 10 list."
                },
                {
                    "raw": "∀x (Top10(x) → Japanese(Create(japanese, x))) ::: All games in the Top 10 list are made by Japanese game companies.",
                    "gram": "∀x(Top10(x)→Japanese(x)) ::: All games in the Top 10 list are made by Japanese game companies."
                }
            ],
            "answer": "B",
            "grammar_answer": "C"
        },
        {
            "id": 39,
            "raw_prog": {
                "First-Order-Logic Rules": "∀x (DesignStyle(x, ZahaHadid) → Timeless(x)) ::: All of Zaha Hadid's design styles are timeless. \n∀x (MassProductDesign(x) → ¬Timeless(x)) ::: No mass product design is timeless. \n(DesignStyle(ZahaHadid, y) ∨ DesignStyle(KellyWearstler, y)) ::: Either Zaha Hadid's design style or Kelly Wearstler's design style. \n∀x (DesignStyle(x, KellyWearstler) → Evocative(x)) ::: All of Kelly Wearstler's design styles are evocative. \n∀x (DesignStyle(x, KellyWearstler) → Dreamy(x)) ::: All of Kelly Wearstler's design styles are dreamy. \n∀x (Timeless(DesignBy(x, Max)) → (MassProductDesign(DesignBy(x, Max)) ∧ Evocative(DesignBy(x, Max)))) ::: If a design by Max is timeless, then a design by Max is a mass product design and evocative.\n",
                "First-Order-Logic Question": "MassProductDesign(DesignBy(Max, Max)) ::: A design by Max is a mass product design."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∀x (DesignStyle(x, ZahaHadid) → Timeless(x)) ::: All of Zaha Hadid's design styles are timeless. \n∀x (MassProductDesign(x) → ¬Timeless(x)) ::: No mass product design is timeless. \n(DesignStyle(ZahaHadid, y) ∨ DesignStyle(KellyWearstler, y)) ::: Either Zaha Hadid's design style or Kelly Wearstler's design style. \n∀x (DesignStyle(x, KellyWearstler) → Evocative(x)) ::: All of Kelly Wearstler's design styles are evocative. \n∀x (DesignStyle(x, KellyWearstler) → Dreamy(x)) ::: All of Kelly Wearstler's design styles are dreamy. \n∀x(Timeless(x)→(MassProductDesign(x))) ::: If a design by Max is timeless, then a design by Max is a mass product design and evocative.\n",
                "First-Order-Logic Question": "MassProductDesign(x)→DesignBy(x,x) ::: A design by Max is a mass product design."
            },
            "diff": [
                {
                    "raw": "∀x (Timeless(DesignBy(x, Max)) → (MassProductDesign(DesignBy(x, Max)) ∧ Evocative(DesignBy(x, Max)))) ::: If a design by Max is timeless, then a design by Max is a mass product design and evocative.",
                    "gram": "∀x(Timeless(x)→(MassProductDesign(x))) ::: If a design by Max is timeless, then a design by Max is a mass product design and evocative."
                }
            ],
            "answer": "C",
            "grammar_answer": "A"
        },
        {
            "id": 41,
            "raw_prog": {
                "First-Order-Logic Rules": "∀x (DesignStyle(x, ZahaHadid) → Timeless(x)) ::: All of Zaha Hadid's design styles are timeless.\n∀x (MassProductDesign(x) → ¬Timeless(x)) ::: No mass product design is timeless.\nDesignStyle(ZahaHadid, y) ∨ DesignStyle(KellyWearstler, y) ::: Either Zaha Hadid's design style or Kelly Wearstler's design style.\n∀x (DesignStyle(x, KellyWearstler) → Evocative(x)) ::: All of Kelly Wearstler's design styles are evocative.\n∀x (DesignStyle(x, KellyWearstler) → Dreamy(x)) ::: All of Kelly Wearstler's design styles are dreamy.\n∀x (Timeless(DesignBy(x, Max)) → (MassProductDesign(DesignBy(x, Max)) ∧ Evocative(DesignBy(x, Max)))) ::: If a design by Max is timeless, then a design by Max is a mass product design and evocative.\n",
                "First-Order-Logic Question": "Evocative(DesignBy(Max, Max)) ∨ Dreamy(DesignBy(Max, Max)) ::: A design by Max is either evocative or dreamy."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∀x (DesignStyle(x, ZahaHadid) → Timeless(x)) ::: All of Zaha Hadid's design styles are timeless.\n∀x (MassProductDesign(x) → ¬Timeless(x)) ::: No mass product design is timeless.\nDesignStyle(ZahaHadid, y) ∨ DesignStyle(KellyWearstler, y) ::: Either Zaha Hadid's design style or Kelly Wearstler's design style.\n∀x (DesignStyle(x, KellyWearstler) → Evocative(x)) ::: All of Kelly Wearstler's design styles are evocative.\n∀x (DesignStyle(x, KellyWearstler) → Dreamy(x)) ::: All of Kelly Wearstler's design styles are dreamy.\n∀x(Timeless(x)→(MassProductDesign(x))) ::: If a design by Max is timeless, then a design by Max is a mass product design and evocative.\n",
                "First-Order-Logic Question": "Evocative(x)→DesignBy(x,x)∨Dreamy(x)→DesignBy(x,x) ::: A design by Max is either evocative or dreamy."
            },
            "diff": [
                {
                    "raw": "∀x (Timeless(DesignBy(x, Max)) → (MassProductDesign(DesignBy(x, Max)) ∧ Evocative(DesignBy(x, Max)))) ::: If a design by Max is timeless, then a design by Max is a mass product design and evocative.",
                    "gram": "∀x(Timeless(x)→(MassProductDesign(x))) ::: If a design by Max is timeless, then a design by Max is a mass product design and evocative."
                }
            ],
            "answer": "B",
            "grammar_answer": "A"
        },
        {
            "id": 85,
            "raw_prog": {
                "First-Order-Logic Rules": "∀x (Listed(x) → ¬NotNegative(x)) ::: If the restaurant is listed in Yelp’s recommendations, then the restaurant does not receive many negative reviews.\n∀x (Rating(x, y) ∧ y > 9 → Listed(x)) ::: All restaurants with a rating greater than 9 are listed in Yelp’s recommendations.\n∃x (Restaurant(x) ∧ ¬Provide(x, takeout) → NotNegative(x)) ::: Some restaurants that do not provide take-out service receive many negative reviews.\n∀x (Popular(x) → Rating(x, y) ∧ y > 9) ::: All restaurants that are popular among local residents have ratings greater than 9.\nRating(subway, y) ∨ Popular(subway) ::: Subway has a rating greater than 9 or is popular among local residents.\n",
                "First-Order-Logic Question": "TakeOut(subway) ∧ ¬NotNegative(subway) ::: Subway provides take-out service and does not receive many negative reviews."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∀x (Listed(x) → ¬NotNegative(x)) ::: If the restaurant is listed in Yelp’s recommendations, then the restaurant does not receive many negative reviews.\n∀x(Rating(x,y)∧(NotNegative(x))) ::: All restaurants with a rating greater than 9 are listed in Yelp’s recommendations.\n∃x (Restaurant(x) ∧ ¬Provide(x, takeout) → NotNegative(x)) ::: Some restaurants that do not provide take-out service receive many negative reviews.\n∀x(Popular(x)→Rating(x,y)∧(Rating(x,y))) ::: All restaurants that are popular among local residents have ratings greater than 9.\nRating(subway, y) ∨ Popular(subway) ::: Subway has a rating greater than 9 or is popular among local residents.\n",
                "First-Order-Logic Question": "TakeOut(subway) ∧ ¬NotNegative(subway) ::: Subway provides take-out service and does not receive many negative reviews."
            },
            "diff": [
                {
                    "raw": "∀x (Rating(x, y) ∧ y > 9 → Listed(x)) ::: All restaurants with a rating greater than 9 are listed in Yelp’s recommendations.",
                    "gram": "∀x(Rating(x,y)∧(NotNegative(x))) ::: All restaurants with a rating greater than 9 are listed in Yelp’s recommendations."
                },
                {
                    "raw": "∀x (Popular(x) → Rating(x, y) ∧ y > 9) ::: All restaurants that are popular among local residents have ratings greater than 9.",
                    "gram": "∀x(Popular(x)→Rating(x,y)∧(Rating(x,y))) ::: All restaurants that are popular among local residents have ratings greater than 9."
                }
            ],
            "answer": "A",
            "grammar_answer": "B"
        },
        {
            "id": 114,
            "raw_prog": {
                "First-Order-Logic Rules": "MountainRange(picurismountains) ∨ MountainRange(picurismountains) ::: The Picuris Mountains are a mountain range in New Mexico or Texas.\nVisited(juandeonate, picurismountains) ::: Juan de Onate visited the Picuris Mountains.\nLocatedIn(hardingpegmatitemine, picurismountains) ∧ Donated(hardingpegmatitemine) ::: The Harding Pegmatite Mine, located in the Picuris Mountains, was donated.\n∀x (MountainRange(x) ∧ In(x, texas) → ¬∃y (Mine(y) ∧ Has(y, donated) ∧ LocatedIn(y, x))) ::: There are no mountain ranges in Texas that have mines which have been donated.\n",
                "First-Order-Logic Question": "NotLocatedIn(hardingpegmatitemine, newmexico) ::: The Harding Pegmatite Mine is not located in a mountain range in New Mexico."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "MountainRange(picurismountains) ∨ MountainRange(picurismountains) ::: The Picuris Mountains are a mountain range in New Mexico or Texas.\nVisited(juandeonate, picurismountains) ::: Juan de Onate visited the Picuris Mountains.\nLocatedIn(hardingpegmatitemine, picurismountains) ∧ Donated(hardingpegmatitemine) ::: The Harding Pegmatite Mine, located in the Picuris Mountains, was donated.\n∀x(MountainRange(x)∧In(x,y)→¬(Mine(y))) ::: There are no mountain ranges in Texas that have mines which have been donated.\n",
                "First-Order-Logic Question": "NotLocatedIn(hardingpegmatitemine, newmexico) ::: The Harding Pegmatite Mine is not located in a mountain range in New Mexico."
            },
            "diff": [
                {
                    "raw": "∀x (MountainRange(x) ∧ In(x, texas) → ¬∃y (Mine(y) ∧ Has(y, donated) ∧ LocatedIn(y, x))) ::: There are no mountain ranges in Texas that have mines which have been donated.",
                    "gram": "∀x(MountainRange(x)∧In(x,y)→¬(Mine(y))) ::: There are no mountain ranges in Texas that have mines which have been donated."
                }
            ],
            "answer": "B",
            "grammar_answer": "C"
        }
    ],
    "gcd_llama-2-13b_4": [
        {
            "id": 41,
            "raw_prog": {
                "First-Order-Logic Rules": [
                    "∀x (ZahaHadid(x) → Timeless(x)) ::: All of Zaha Hadid's design styles are timeless.",
                    "∀x (MassProduct(x) → ¬Timeless(x)) ::: No mass product design is timeless.",
                    "∀x (ZahaHadid(x) ∨ KellyWearstler(x)) ::: Either Zaha Hadid's design style or Kelly Wearstler's design style.",
                    "∀x (KellyWearstler(x) → Evocative(x)) ::: All of Kelly Wearstler's design styles are evocative.",
                    "∀x (KellyWearstler(x) → Dreamy(x)) ::: All of Kelly Wearstler's design styles are dreamy.",
                    "∀x (Timeless(Max(x)) → (MassProduct(Max(x)) ∧ Evocative(Max(x)))) ::: If a design by Max is timeless, then a design by Max is a mass product design and evocative."
                ],
                "First-Order-Logic Question": [
                    "Evocative(Max(x)) ∨ Dreamy(Max(x)) ::: A design by Max is either evocative or dreamy."
                ]
            },
            "gram_prog": {
                "First-Order-Logic Rules": [
                    "∀x (ZahaHadid(x) → Timeless(x)) ::: All of Zaha Hadid's design styles are timeless.",
                    "∀x (MassProduct(x) → ¬Timeless(x)) ::: No mass product design is timeless.",
                    "∀x (ZahaHadid(x) ∨ KellyWearstler(x)) ::: Either Zaha Hadid's design style or Kelly Wearstler's design style.",
                    "∀x (KellyWearstler(x) → Evocative(x)) ::: All of Kelly Wearstler's design styles are evocative.",
                    "∀x (KellyWearstler(x) → Dreamy(x)) ::: All of Kelly Wearstler's design styles are dreamy.",
                    "∀x(Timeless(x)→(MassProduct(x))) ::: If a design by Max is timeless, then a design by Max is a mass product design and evocative."
                ],
                "First-Order-Logic Question": [
                    "Evocative(x)∨Dreamy(x) ::: A design by Max is either evocative or dreamy."
                ]
            },
            "diff": [
                {
                    "raw": "∀x (Timeless(Max(x)) → (MassProduct(Max(x)) ∧ Evocative(Max(x)))) ::: If a design by Max is timeless, then a design by Max is a mass product design and evocative.",
                    "gram": "∀x(Timeless(x)→(MassProduct(x))) ::: If a design by Max is timeless, then a design by Max is a mass product design and evocative."
                }
            ],
            "answer": "B",
            "grammar_answer": "A"
        },
        {
            "id": 46,
            "raw_prog": {
                "First-Order-Logic Rules": "∀x (Season(Spring(x)) ∧ Season(Summer(x)) ∧ Season(Fall(x)) ∧ Season(Winter(x))) ::: There are four seasons in a year: Spring, Summer, Fall, and Winter.\n∀x (WantLongVacation(x) → LoveMost(x, Summer)) ::: All students who want to have a long vacation love summer the most.\nFavoriteSeason(emma, Summer) ::: Emma's favorite season is summer.\n∀x (FavoriteSeason(mia, y) → ¬FavoriteSeason(mia, Summer)) ::: Mia's favorite season is not the same as Emma's.\nWantLongVacation(james) ::: James wants to have a long vacation.\n",
                "First-Order-Logic Question": "FavoriteSeason(james, Summer) ::: James's favorite season is summer."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∀x(Season(x)∧(Spring(x))) ::: There are four seasons in a year: Spring, Summer, Fall, and Winter.\n∀x (WantLongVacation(x) → LoveMost(x, Summer)) ::: All students who want to have a long vacation love summer the most.\nFavoriteSeason(emma, Summer) ::: Emma's favorite season is summer.\n∀x (FavoriteSeason(mia, y) → ¬FavoriteSeason(mia, Summer)) ::: Mia's favorite season is not the same as Emma's.\nWantLongVacation(james) ::: James wants to have a long vacation.\n",
                "First-Order-Logic Question": "FavoriteSeason(james, Summer) ::: James's favorite season is summer."
            },
            "diff": [
                {
                    "raw": "∀x (Season(Spring(x)) ∧ Season(Summer(x)) ∧ Season(Fall(x)) ∧ Season(Winter(x))) ::: There are four seasons in a year: Spring, Summer, Fall, and Winter.",
                    "gram": "∀x(Season(x)∧(Spring(x))) ::: There are four seasons in a year: Spring, Summer, Fall, and Winter."
                }
            ],
            "answer": "A",
            "grammar_answer": "C"
        },
        {
            "id": 70,
            "raw_prog": {
                "First-Order-Logic Rules": [
                    "British(badults) ∧ Sitcom(badults) ∧ ∀x (MemberOf(x, pappys) → Star(x, badults)) ::: Badults is a British Sitcom series, starring members of Pappy's.",
                    "Pilot(badults, 2013) ∧ Network(badults, bbcthree) ::: Badults piloted in July 2013 on BBC Three.",
                    "WorkingTitle(badults, thesecretdudesociety) ::: The Working title 'The Secret Dude Society' was used for Badults.",
                    "ScriptEditor(andrewcollins, badults) ::: Andrew Collins was the script editor for Badults."
                ],
                "First-Order-Logic Question": [
                    "∀x (MemberOf(x, pappys) → ¬∃y (Star(x, y) ∧ (Network(y, bbctwo) ∨ Network(y, bbcthree)))) ::: No members of Pappy's have starred for a show piloting on BBC Two or BBC Three."
                ]
            },
            "gram_prog": {
                "First-Order-Logic Rules": [
                    "British(badults) ∧ Sitcom(badults) ∧ ∀x (MemberOf(x, pappys) → Star(x, badults)) ::: Badults is a British Sitcom series, starring members of Pappy's.",
                    "Pilot(badults, 2013) ∧ Network(badults, bbcthree) ::: Badults piloted in July 2013 on BBC Three.",
                    "WorkingTitle(badults, thesecretdudesociety) ::: The Working title 'The Secret Dude Society' was used for Badults.",
                    "ScriptEditor(andrewcollins, badults) ::: Andrew Collins was the script editor for Badults."
                ],
                "First-Order-Logic Question": [
                    "∀x(MemberOf(x,y)→¬(Star(x,y))) ::: No members of Pappy's have starred for a show piloting on BBC Two or BBC Three."
                ]
            },
            "diff": [],
            "answer": "B",
            "grammar_answer": "C"
        },
        {
            "id": 93,
            "raw_prog": {
                "First-Order-Logic Rules": [
                    "∃x (Pet(x) ∧ ManagedBuilding(y) ∧ AllowedIn(x, y)) ::: Pets are allowed in some managed buildings.",
                    "∀x (ManagedBuilding(x) → DepositRequired(x)) ::: A deposit is required to rent an apartment in a managed building.",
                    "∀x ∀y (SecurityDeposit(x, y) → EqualOrMore(y, MonthlyRent(x, 1))) ::: The security deposit can be either equal to one month's rent or more.",
                    "Cat(fluffy) ∧ Owner(tom, fluffy) ::: Fluffy is Tom's cat.",
                    "∀x (Cat(x) → Pet(x)) ::: Cats are pets.",
                    "ManagedBuilding(olivegarden) ::: The Olive Garden is a managed building.",
                    "MonthlyRent(olivegarden, 2000) ::: The monthly rent at the Olive Garden is $2000.",
                    "∀x ∀y (Owner(x, y) ∧ Pet(y) ∧ ManagedBuilding(z) ∧ AllowedIn(y, z) ∧ SecurityDeposit(z, d) ∧ d ≤ 1500 ↔ Rent(x, z)) ::: Tom will rent an apartment in a managed building if and only if he is allowed to move in with Fluffy, and the security deposit is no more than $1500.",
                    "EqualOrMore(2000, 1500) ::: 2000$ is more than $1500."
                ],
                "First-Order-Logic Question": [
                    "Rent(tom, olivegarden) ::: Tom will rent an apartment in The Olive Garden."
                ]
            },
            "gram_prog": {
                "First-Order-Logic Rules": [
                    "∃x (Pet(x) ∧ ManagedBuilding(y) ∧ AllowedIn(x, y)) ::: Pets are allowed in some managed buildings.",
                    "∀x (ManagedBuilding(x) → DepositRequired(x)) ::: A deposit is required to rent an apartment in a managed building.",
                    "∀x∀y(SecurityDeposit(x,y)→EqualOrMore(y,x)) ::: The security deposit can be either equal to one month's rent or more.",
                    "Cat(fluffy) ∧ Owner(tom, fluffy) ::: Fluffy is Tom's cat.",
                    "∀x (Cat(x) → Pet(x)) ::: Cats are pets.",
                    "ManagedBuilding(olivegarden) ::: The Olive Garden is a managed building.",
                    "MonthlyRent(olivegarden, 2000) ::: The monthly rent at the Olive Garden is $2000.",
                    "∀x∀y(Owner(x,y)∧Pet(y)∧ManagedBuilding(z)∧AllowedIn(y,z)) ::: Tom will rent an apartment in a managed building if and only if he is allowed to move in with Fluffy, and the security deposit is no more than $1500.",
                    "EqualOrMore(2000, 1500) ::: 2000$ is more than $1500."
                ],
                "First-Order-Logic Question": [
                    "Rent(tom, olivegarden) ::: Tom will rent an apartment in The Olive Garden."
                ]
            },
            "diff": [
                {
                    "raw": "∀x ∀y (SecurityDeposit(x, y) → EqualOrMore(y, MonthlyRent(x, 1))) ::: The security deposit can be either equal to one month's rent or more.",
                    "gram": "∀x∀y(SecurityDeposit(x,y)→EqualOrMore(y,x)) ::: The security deposit can be either equal to one month's rent or more."
                },
                {
                    "raw": "∀x ∀y (Owner(x, y) ∧ Pet(y) ∧ ManagedBuilding(z) ∧ AllowedIn(y, z) ∧ SecurityDeposit(z, d) ∧ d ≤ 1500 ↔ Rent(x, z)) ::: Tom will rent an apartment in a managed building if and only if he is allowed to move in with Fluffy, and the security deposit is no more than $1500.",
                    "gram": "∀x∀y(Owner(x,y)∧Pet(y)∧ManagedBuilding(z)∧AllowedIn(y,z)) ::: Tom will rent an apartment in a managed building if and only if he is allowed to move in with Fluffy, and the security deposit is no more than $1500."
                }
            ],
            "answer": "B",
            "grammar_answer": "C"
        },
        {
            "id": 95,
            "raw_prog": {
                "First-Order-Logic Rules": [
                    "∃x (ManagedBuilding(x) ∧ Pet(y) ∧ AllowedIn(y, x)) ::: Pets are allowed in some managed buildings.",
                    "∀x (ManagedBuilding(x) → DepositRequired(x)) ::: A deposit is required to rent an apartment in a managed building.",
                    "∀x ∀y (SecurityDeposit(x, y) → (EqualOrMore(y, MonthlyRent(x, 1)) ∨ EqualOrMore(y, MonthlyRent(x, 2)))) ::: The security deposit can be either equal to one month's rent or more.",
                    "Cat(fluffy) ∧ Owner(tom, fluffy) ::: Fluffy is Tom's cat.",
                    "∀x (Cat(x) → Pet(x)) ::: Cats are pets.",
                    "ManagedBuilding(olivegarden) ::: The Olive Garden is a managed building.",
                    "MonthlyRent(olivegarden, 2000) ::: The monthly rent at the Olive Garden is $2000.",
                    "∀x ∀y (Owner(tom, fluffy) ∧ ManagedBuilding(x) ∧ (AllowedIn(fluffy, x) ∧ SecurityDeposit(x, y) ∧ EqualOrMore(1500, y)) ↔ Rent(tom, x)) ::: Tom will rent an apartment in a managed building if and only if he is allowed to move in with Fluffy, and the security deposit is no more than $1500.",
                    "EqualOrMore(2000, 1500) ::: 2000$ is more than $1500."
                ],
                "First-Order-Logic Question": [
                    "SecurityDeposit(olivegarden, 2000) ∨ ∃y (SecurityDeposit(olivegarden, y) ∧ EqualOrMore(y, 2000)) ::: The security deposit at the Olive Garden is either $2000 or more."
                ]
            },
            "gram_prog": {
                "First-Order-Logic Rules": [
                    "∃x (ManagedBuilding(x) ∧ Pet(y) ∧ AllowedIn(y, x)) ::: Pets are allowed in some managed buildings.",
                    "∀x (ManagedBuilding(x) → DepositRequired(x)) ::: A deposit is required to rent an apartment in a managed building.",
                    "∀x∀y(SecurityDeposit(x,y)→(EqualOrMore(y,x))) ::: The security deposit can be either equal to one month's rent or more.",
                    "Cat(fluffy) ∧ Owner(tom, fluffy) ::: Fluffy is Tom's cat.",
                    "∀x (Cat(x) → Pet(x)) ::: Cats are pets.",
                    "ManagedBuilding(olivegarden) ::: The Olive Garden is a managed building.",
                    "MonthlyRent(olivegarden, 2000) ::: The monthly rent at the Olive Garden is $2000.",
                    "∀x ∀y (Owner(tom, fluffy) ∧ ManagedBuilding(x) ∧ (AllowedIn(fluffy, x) ∧ SecurityDeposit(x, y) ∧ EqualOrMore(1500, y)) ↔ Rent(tom, x)) ::: Tom will rent an apartment in a managed building if and only if he is allowed to move in with Fluffy, and the security deposit is no more than $1500.",
                    "EqualOrMore(2000, 1500) ::: 2000$ is more than $1500."
                ],
                "First-Order-Logic Question": [
                    "SecurityDeposit(olivegarden, 2000) ∨ ∃y (SecurityDeposit(olivegarden, y) ∧ EqualOrMore(y, 2000)) ::: The security deposit at the Olive Garden is either $2000 or more."
                ]
            },
            "diff": [
                {
                    "raw": "∀x ∀y (SecurityDeposit(x, y) → (EqualOrMore(y, MonthlyRent(x, 1)) ∨ EqualOrMore(y, MonthlyRent(x, 2)))) ::: The security deposit can be either equal to one month's rent or more.",
                    "gram": "∀x∀y(SecurityDeposit(x,y)→(EqualOrMore(y,x))) ::: The security deposit can be either equal to one month's rent or more."
                }
            ],
            "answer": "A",
            "grammar_answer": "C"
        },
        {
            "id": 123,
            "raw_prog": {
                "First-Order-Logic Rules": "∀x (TransportMultiplePassengers(x) → ¬Empty(x)) ::: If something can transport multiple passengers, then they are not empty.\n∀x (Airline(x) → TransportMultiplePassengers(x)) ::: All airlines can transport multiple passengers.\n∀x (Plane(x) → Empty(x)) ::: All planes are empty.\n∀x (Boeing707(x) → Plane(x)) ::: All Boeing 707s are planes.\n¬Airline(greyhound) → ¬∃y (Greyhound(y) ∧ Plane(y)) ::: If Greyhound is not an airline, then there are no Greyhound planes.\n",
                "First-Order-Logic Question": "Boeing707(greyhound) ::: A Greyhound is a Boeing 707."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∀x (TransportMultiplePassengers(x) → ¬Empty(x)) ::: If something can transport multiple passengers, then they are not empty.\n∀x (Airline(x) → TransportMultiplePassengers(x)) ::: All airlines can transport multiple passengers.\n∀x (Plane(x) → Empty(x)) ::: All planes are empty.\n∀x (Boeing707(x) → Plane(x)) ::: All Boeing 707s are planes.\n¬Airline(greyhound) → ¬(Plane(y) ∧ GreyhoundPlane(y)) ::: If Greyhound is not an airline, then there are no Greyhound planes.",
                "First-Order-Logic Question": "Boeing707(greyhound) ::: A Greyhound is a Boeing 707."
            },
            "diff": [],
            "answer": "B",
            "grammar_answer": "C"
        },
        {
            "id": 143,
            "raw_prog": {
                "First-Order-Logic Rules": "∀x (BreedingBack(x) → ArtificiallySelected(x)) ::: Breeding back is a form of artificial selection by the deliberate selective breeding of domestic animals.\nBredBack(heck_cattle, aurochs) ∧ Resemble(heck_cattle, aurochs) ::: Heck cattle were bred-back in the 1920s to resemble the aurochs.\nAnimal(heck_cattle) ::: Heck cattle are animals.\nAnimal(aurochs) ::: Aurochs are animals.\n∃x ∃y (Animal(x) ∧ Animal(y) ∧ BredBack(x, y) ∧ Resemble(x, y) ∧ Extinct(y)) ::: Some animals to be bred-back resemble animals that are extinct.\n",
                "First-Order-Logic Question": "∃x (Animal(x) ∧ ArtificiallySelected(x) ∧ x = heck_cattle) ::: Some Heck cattle are artificially selected."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∀x (BreedingBack(x) → ArtificiallySelected(x)) ::: Breeding back is a form of artificial selection by the deliberate selective breeding of domestic animals.\nBredBack(heck_cattle, aurochs) ∧ Resemble(heck_cattle, aurochs) ::: Heck cattle were bred-back in the 1920s to resemble the aurochs.\nAnimal(heck_cattle) ::: Heck cattle are animals.\nAnimal(aurochs) ::: Aurochs are animals.\n∃x ∃y (Animal(x) ∧ Animal(y) ∧ BredBack(x, y) ∧ Resemble(x, y) ∧ Extinct(y)) ::: Some animals to be bred-back resemble animals that are extinct.\n",
                "First-Order-Logic Question": "∃x(Animal(x)∧BreedingBack(x)∧Resemble(x,y)∧Extinct(y)) ::: Some Heck cattle are artificially selected."
            },
            "diff": [],
            "answer": "A",
            "grammar_answer": "C"
        },
        {
            "id": 10,
            "raw_prog": {
                "First-Order-Logic Rules": "∀x (WildTurkey(x) → (EasternWildTurkey(x) ∨ OsceolaWildTurkey(x) ∨ GouldsWildTurkey(x) ∨ MerriamsWildTurkey(x) ∨ RioGrandeWildTurkey(x) ∨ OcellatedWildTurkey(x))) ::: There are six types of wild turkeys: Eastern wild turkey, Osceola wild turkey, Gould’s wild turkey, Merriam’s wild turkey, Rio Grande wild turkey, and Ocellated wild turkey.\nNot(tom, EasternWildTurkey(tom)) ::: Tom is not an Eastern wild turkey.\nNot(tom, OsceolaWildTurkey(tom)) ::: Tom is not an Osceola wild turkey.\nNot(tom, GouldsWildTurkey(tom)) ∧ Not(tom, MerriamsWildTurkey(tom)) ∧ Not(tom, RioGrandeWildTurkey(tom)) ::: Tom is also not a Gould's wild turkey, or a Merriam's wild turkey, or a Rio Grande wild turkey.\nWildTurkey(tom) ::: Tom is a wild turkey.\n",
                "First-Order-Logic Question": "EasternWildTurkey(tom) ::: Tom is an Eastern wild turkey."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∀x (WildTurkey(x) → (EasternWildTurkey(x) ∨ OsceolaWildTurkey(x) ∨ GouldsWildTurkey(x) ∨ MerriamsWildTurkey(x) ∨ RioGrandeWildTurkey(x) ∨ OcellatedWildTurkey(x))) ::: There are six types of wild turkeys: Eastern wild turkey, Osceola wild turkey, Gould’s wild turkey, Merriam’s wild turkey, Rio Grande wild turkey, and Ocellated wild turkey.\nNot(x,y) ::: Tom is not an Eastern wild turkey.\nNot(x,y) ::: Tom is not an Osceola wild turkey.\nNot(x,y) ::: Tom is also not a Gould's wild turkey, or a Merriam's wild turkey, or a Rio Grande wild turkey.\nWildTurkey(tom) ::: Tom is a wild turkey.\n",
                "First-Order-Logic Question": "EasternWildTurkey(tom) ::: Tom is an Eastern wild turkey."
            },
            "diff": [
                {
                    "raw": "Not(tom, EasternWildTurkey(tom)) ::: Tom is not an Eastern wild turkey.",
                    "gram": "Not(x,y) ::: Tom is not an Eastern wild turkey."
                },
                {
                    "raw": "Not(tom, OsceolaWildTurkey(tom)) ::: Tom is not an Osceola wild turkey.",
                    "gram": "Not(x,y) ::: Tom is not an Osceola wild turkey."
                },
                {
                    "raw": "Not(tom, GouldsWildTurkey(tom)) ∧ Not(tom, MerriamsWildTurkey(tom)) ∧ Not(tom, RioGrandeWildTurkey(tom)) ::: Tom is also not a Gould's wild turkey, or a Merriam's wild turkey, or a Rio Grande wild turkey.",
                    "gram": "Not(x,y) ::: Tom is also not a Gould's wild turkey, or a Merriam's wild turkey, or a Rio Grande wild turkey."
                }
            ],
            "answer": "B",
            "grammar_answer": "C"
        },
        {
            "id": 105,
            "raw_prog": {
                "First-Order-Logic Rules": "Cost(gre, 205) ::: It costs US $205 to take the GRE test.\n∀x (Applicant(x) ∧ Prove(x, EconomicHardship(x)) → Provide(ets, FinancialAid, x)) ::: ETS provides financial aid to those GRE applicants who prove economic hardship.\n∀x (EconomicHardship(x) ↔ (Difficulty(x) ∧ (¬Money(x) ∨ ¬Resources(x)))) ::: Economic hardship refers to difficulty caused by having too little money or too few resources.\nLive(tom, singleparentfamily) ::: Tom lives in a single-parent family.\nOutOfWork(tom_dad) ∧ Year(1) ::: His dad has been out of work for more than a year.\n",
                "First-Order-Logic Question": "Apply(tom, FinancialAid) ::: Tom can apply for financial aid from ETS to take the GRE test."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "Cost(gre, 205) ::: It costs US $205 to take the GRE test.\nProvide(x,y,z)→Applicant(x)∧Prove(x,y)∧EconomicHardship(x) ::: ETS provides financial aid to those GRE applicants who prove economic hardship.\n∀x (EconomicHardship(x) ↔ (Difficulty(x) ∧ (¬Money(x) ∨ ¬Resources(x)))) ::: Economic hardship refers to difficulty caused by having too little money or too few resources.\nLive(tom, singleparentfamily) ::: Tom lives in a single-parent family.\nOutOfWork(tom_dad) ∧ Year(1) ::: His dad has been out of work for more than a year.\n",
                "First-Order-Logic Question": "Apply(tom, FinancialAid) ::: Tom can apply for financial aid from ETS to take the GRE test."
            },
            "diff": [
                {
                    "raw": "∀x (Applicant(x) ∧ Prove(x, EconomicHardship(x)) → Provide(ets, FinancialAid, x)) ::: ETS provides financial aid to those GRE applicants who prove economic hardship.",
                    "gram": "Provide(x,y,z)→Applicant(x)∧Prove(x,y)∧EconomicHardship(x) ::: ETS provides financial aid to those GRE applicants who prove economic hardship."
                }
            ],
            "answer": "A",
            "grammar_answer": "C"
        },
        {
            "id": 114,
            "raw_prog": {
                "First-Order-Logic Rules": [
                    "MountainRange(picurismountains) ∧ (In(picurismountains, newmexico) ⊕ In(picurismountains, texas)) ::: The Picuris Mountains are a mountain range in New Mexico or Texas.",
                    "Visit(juandeonate, picurismountains) ::: Juan de Onate visited the Picuris Mountains.",
                    "Mine(hardingpegmatitemine) ∧ In(hardingpegmatitemine, picurismountains) ∧ Donate(hardingpegmatitemine) ::: The Harding Pegmatite Mine, located in the Picuris Mountains, was donated.",
                    "∀x (MountainRange(x) ∧ In(x, texas) → ¬∃y (Mine(y) ∧ In(y, x) ∧ Donate(y))) ::: There are no mountain ranges in Texas that have mines which have been donated."
                ],
                "First-Order-Logic Question": [
                    "¬In(hardingpegmatitemine, newmexico) ::: The Harding Pegmatite Mine is not located in a mountain range in New Mexico."
                ]
            },
            "gram_prog": {
                "First-Order-Logic Rules": [
                    "MountainRange(picurismountains) ∧ (In(picurismountains, newmexico) ⊕ In(picurismountains, texas)) ::: The Picuris Mountains are a mountain range in New Mexico or Texas.",
                    "Visit(juandeonate, picurismountains) ::: Juan de Onate visited the Picuris Mountains.",
                    "Mine(hardingpegmatitemine) ∧ In(hardingpegmatitemine, picurismountains) ∧ Donate(hardingpegmatitemine) ::: The Harding Pegmatite Mine, located in the Picuris Mountains, was donated.",
                    "∀x(MountainRange(x)∧In(x,y)→¬(HasMine(x,y))) ::: There are no mountain ranges in Texas that have mines which have been donated."
                ],
                "First-Order-Logic Question": [
                    "¬In(hardingpegmatitemine, newmexico) ::: The Harding Pegmatite Mine is not located in a mountain range in New Mexico."
                ]
            },
            "diff": [
                {
                    "raw": "∀x (MountainRange(x) ∧ In(x, texas) → ¬∃y (Mine(y) ∧ In(y, x) ∧ Donate(y))) ::: There are no mountain ranges in Texas that have mines which have been donated.",
                    "gram": "∀x(MountainRange(x)∧In(x,y)→¬(HasMine(x,y))) ::: There are no mountain ranges in Texas that have mines which have been donated."
                }
            ],
            "answer": "B",
            "grammar_answer": "C"
        },
        {
            "id": 38,
            "raw_prog": {
                "First-Order-Logic Rules": [
                    "MusicPiece(symphonyNo9) ::: Symphony No. 9 is a music piece.",
                    "∀x (Composer(x) → ∃y (Write(x, y) ∧ MusicPiece(y))) ::: Composers write music pieces.",
                    "Write(beethoven, symphonyNo9) ∧ Composer(beethoven) ::: Beethoven wrote Symphony No. 9.",
                    "Premiere(viennaMusicSociety, symphonyNo9) ::: Vienna Music Society premiered Symphony No. 9.",
                    "Orchestra(viennaMusicSociety) ::: Vienna Music Society is an orchestra.",
                    "Lead(beethoven, viennaMusicSociety) ::: Beethoven leads the Vienna Music Society.",
                    "∀x (Orchestra(x) → ∃y (Lead(y, x) ∧ Conductor(y))) ::: Orchestras are led by conductors."
                ],
                "First-Order-Logic Question": "Not(Conductor(beethoven)) ::: Beethoven is not a conductor."
            },
            "gram_prog": {
                "First-Order-Logic Rules": [
                    "MusicPiece(symphonyNo9) ::: Symphony No. 9 is a music piece.",
                    "∀x (Composer(x) → ∃y (Write(x, y) ∧ MusicPiece(y))) ::: Composers write music pieces.",
                    "Write(beethoven, symphonyNo9) ∧ Composer(beethoven) ::: Beethoven wrote Symphony No. 9.",
                    "Premiere(viennaMusicSociety, symphonyNo9) ::: Vienna Music Society premiered Symphony No. 9.",
                    "Orchestra(viennaMusicSociety) ::: Vienna Music Society is an orchestra.",
                    "Lead(beethoven, viennaMusicSociety) ::: Beethoven leads the Vienna Music Society.",
                    "∀x (Orchestra(x) → ∃y (Lead(y, x) ∧ Conductor(y))) ::: Orchestras are led by conductors."
                ],
                "First-Order-Logic Question": "Not(x) ::: Beethoven is not a conductor."
            },
            "diff": [],
            "answer": "B",
            "grammar_answer": "C"
        }
    ],
    "gcd_llama-3-8b_3.5": [
        {
            "id": 2,
            "raw_prog": {
                "First-Order-Logic Rules": "∀x (Perform(x) → (Attend(x) ∧ Engaged(x))) ::: If people perform in school talent shows often, then they attend and are very engaged with school events.\n∀x ((Perform(x) ∨ (Inactive(x) ∧ Disinterested(x))) ::: People either perform in school talent shows often or are inactive and disinterested members of their community.\n∀x (Chaperone(x) → ¬Student(x)) ::: If people chaperone high school dances, then they are not students who attend the school.\n∀x ((Inactive(x) ∧ Disinterested(x)) → Chaperone(x)) ::: All people who are inactive and disinterested members of their community chaperone high school dances.\n∀x ((Young(x) ∨ Teenager(x)) ∧ Wish(x) → Student(x)) ::: All young children and teenagers who wish to further their academic careers and educational opportunities are students who attend the school.\n¬((Attend(Bonnie) ∧ Engaged(Bonnie)) ⊕ Student(Bonnie)) ::: Bonnie either both attends and is very engaged with school events and is a student who attends the school, or she neither attends and is very engaged with school events nor is a student who attends the school.\n",
                "First-Order-Logic Question": "((Chaperone(Bonnie) ∨ ¬Chaperone(Bonnie) ∧ Perform(Bonnie)) → ((Young(Bonnie) ∨ Teenager(Bonnie)) ∧ Wish(Bonnie) ∧ Inactive(Bonnie) ∧ Disinterested(Bonnie))) ::: If Bonnie either chaperones high school dances or, if she does not, she performs in school talent shows often, then Bonnie is both a young child or teenager who wishes to further her academic career and educational opportunities and an inactive and disinterested member of the community."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∀x (Perform(x) → (Attend(x) ∧ Engaged(x))) ::: If people perform in school talent shows often, then they attend and are very engaged with school events.\nInactive(x)∧Disinterested(x)∨Perform(x) ::: People either perform in school talent shows often or are inactive and disinterested members of their community.\n∀x (Chaperone(x) → ¬Student(x)) ::: If people chaperone high school dances, then they are not students who attend the school.\n∀x ((Inactive(x) ∧ Disinterested(x)) → Chaperone(x)) ::: All people who are inactive and disinterested members of their community chaperone high school dances.\n∀x ((Young(x) ∨ Teenager(x)) ∧ Wish(x) → Student(x)) ::: All young children and teenagers who wish to further their academic careers and educational opportunities are students who attend the school.\n¬((Attend(Bonnie) ∧ Engaged(Bonnie)) ⊕ Student(Bonnie)) ::: Bonnie either both attends and is very engaged with school events and is a student who attends the school, or she neither attends and is very engaged with school events nor is a student who attends the school.\n",
                "First-Order-Logic Question": "((Chaperone(Bonnie) ∨ ¬Chaperone(Bonnie) ∧ Perform(Bonnie)) → ((Young(Bonnie) ∨ Teenager(Bonnie)) ∧ Wish(Bonnie) ∧ Inactive(Bonnie) ∧ Disinterested(Bonnie))) ::: If Bonnie either chaperones high school dances or, if she does not, she performs in school talent shows often, then Bonnie is both a young child or teenager who wishes to further her academic career and educational opportunities and an inactive and disinterested member of the community."
            },
            "diff": [
                {
                    "raw": "∀x ((Perform(x) ∨ (Inactive(x) ∧ Disinterested(x))) ::: People either perform in school talent shows often or are inactive and disinterested members of their community.",
                    "gram": "Inactive(x)∧Disinterested(x)∨Perform(x) ::: People either perform in school talent shows often or are inactive and disinterested members of their community."
                }
            ],
            "answer": "B",
            "grammar_answer": "C"
        },
        {
            "id": 52,
            "raw_prog": {
                "First-Order-Logic Rules": "∀x (Romance(x) → IndoEuropean(x)) ::: All Romance languages are Indo-European languages.\nLanguageFamily(romance) ::: The Romance languages are a language family.\n∀x ∀y (LanguageFamily(x) ∧ LanguageFamily(y) → Related(x, y)) ::: All languages within a language family are related to each other.\nRomance(french) ∧ Romance(spanish) ::: French and Spanish are both Romance languages.\nRelated(german, spanish) ::: German is related to Spanish.\nBasque ::: Basque is not related to any other language.",
                "First-Order-Logic Question": "Romance(basque) ::: Basque is a Romance language."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∀x (RomanceLanguage(x) → IndoEuropean(x)) ::: All Romance languages are Indo-European languages.\nLanguageFamily(romance) ::: The Romance languages are a language family.\n∀x ∀y (LanguageFamily(x) ∧ LanguageFamily(y) → Related(x, y)) ::: All languages within a language family are related to each other.\nIsRomance(french) ∧ IsRomance(spanish) ::: French and Spanish are both Romance languages.\nRelated(german, spanish) ::: German is related to Spanish.\nIndoEuropean(x)∧¬Related(x,y) ::: Indo-European languages not related to any other language.",
                "First-Order-Logic Question": "IsRomance(basque) ::: Basque is a Romance language."
            },
            "diff": [
                {
                    "raw": "Basque ::: Basque is not related to any other language.",
                    "gram": "IndoEuropean(x)∧¬Related(x,y) ::: Indo-European languages not related to any other language."
                }
            ],
            "answer": "B",
            "grammar_answer": "A"
        },
        {
            "id": 58,
            "raw_prog": {
                "First-Order-Logic Rules": "City(billings) ∧ City(butte) ∧ City(helena) ∧ City(missoula) ∧ City(whiteSulphurSprings) ∧ City(pierre) ∧ State(montana) ∧ State(southDakota) ∧ State(x) ∧ In(billings, montana) ∧ In(butte, montana) ∧ In(helena, montana) ∧ In(missoula, montana) ∧ In(whiteSulphurSprings, montana) ∧ In(butte, x) ∧ ¬In(pierre, southDakota) ∧ ∀x (In(x, butte) → ¬In(x, pierre)) ::: Billings is a city in Montana. Montana includes the cities of Butte, Helena, and Missoula. White Sulphur Springs and Butte are cities in the same state. The city of Pierre is not in Montana. Any city in Butte is not in Pierre.",
                "First-Order-Logic Question": "SameState(butte, pierre) ::: Butte and Pierre are in the same state."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "In(x,y)∨(City(x)∧State(y)) ::: Billings is a city in Montana. Montana includes the cities of Butte, Helena, and Missoula. White Sulphur Springs and Butte are cities in the same state. The city of Pierre is not in Montana. Any city in Butte is not in Pierre.",
                "First-Order-Logic Question": "SameState(butte, pierre) ::: Butte and Pierre are in the same state."
            },
            "diff": [
                {
                    "raw": "City(billings) ∧ City(butte) ∧ City(helena) ∧ City(missoula) ∧ City(whiteSulphurSprings) ∧ City(pierre) ∧ State(montana) ∧ State(southDakota) ∧ State(x) ∧ In(billings, montana) ∧ In(butte, montana) ∧ In(helena, montana) ∧ In(missoula, montana) ∧ In(whiteSulphurSprings, montana) ∧ In(butte, x) ∧ ¬In(pierre, southDakota) ∧ ∀x (In(x, butte) → ¬In(x, pierre)) ::: Billings is a city in Montana. Montana includes the cities of Butte, Helena, and Missoula. White Sulphur Springs and Butte are cities in the same state. The city of Pierre is not in Montana. Any city in Butte is not in Pierre.",
                    "gram": "In(x,y)∨(City(x)∧State(y)) ::: Billings is a city in Montana. Montana includes the cities of Butte, Helena, and Missoula. White Sulphur Springs and Butte are cities in the same state. The city of Pierre is not in Montana. Any city in Butte is not in Pierre."
                }
            ],
            "answer": "B",
            "grammar_answer": "C"
        },
        {
            "id": 93,
            "raw_prog": {
                "First-Order-Logic Rules": "∃x (Pet(x) ∧ AllowedIn(x, y)) ::: Pets are allowed in some managed buildings.\n∀x (RequireDeposit(x) → ∃y (RentApartment(z, y) ∧ SecurityDeposit(x) ∧ (Equal(SecurityDeposit(x), RentAmount(y)) ∨ MoreThan(SecurityDeposit(x), RentAmount(y))))) ::: A deposit is required to rent an apartment in a managed building. The security deposit can be either equal to one month's rent or more.\nCat(fluffy) ∧ Pet(fluffy) ∧ Owner(tom, fluffy) ::: Fluffy is Tom's cat.\nCat(x) → Pet(x) ::: Cats are pets.\nManagedBuilding(olivegarden) ::: The Olive Garden is a managed building.\nRentAmount(2000, olivegarden) ::: The monthly rent at the Olive Garden is $2000.\nRentApartment(tom, olivegarden) ↔ (AllowedIn(tom, olivegarden) ∧ SecurityDeposit(olivegarden) ∧ (Equal(SecurityDeposit(olivegarden), 1500) ∨ ¬MoreThan(SecurityDeposit(olivegarden), 1500))) ::: Tom will rent an apartment in a managed building if and only if he is allowed to move in with Fluffy, and the security deposit is no more than $1500.\nMoreThan(2000, 1500) ::: 2000$ is more than $1500.",
                "First-Order-Logic Question": "RentApartment(tom, olivegarden) ::: Tom will rent an apartment in The Olive Garden."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∃x (Pet(x) ∧ AllowedIn(x, y)) ::: Pets are allowed in some managed buildings.\nAllowedIn(x,y) ::: A deposit is required to rent an apartment in a managed building. The security deposit can be either equal to one month's rent or more.\nCat(fluffy) ∧ Pet(fluffy) ∧ Owner(tom, fluffy) ::: Fluffy is Tom's cat.\nCat(x) → Pet(x) ::: Cats are pets.\nManagedBuilding(olivegarden) ::: The Olive Garden is a managed building.\nRentAmount(2000, olivegarden) ::: The monthly rent at the Olive Garden is $2000.\nAllowedIn(x,y)∧SecurityDeposit(y)∧(Equal(y,x)∨¬MoreThan(y,x)) ::: Tom will rent an apartment in a managed building if and only if he is allowed to move in with Fluffy, and the security deposit is no more than $1500.\nMoreThan(2000, 1500) ::: 2000$ is more than $1500.",
                "First-Order-Logic Question": "RentApartment(tom, olivegarden) ::: Tom will rent an apartment in The Olive Garden."
            },
            "diff": [
                {
                    "raw": "∀x (RequireDeposit(x) → ∃y (RentApartment(z, y) ∧ SecurityDeposit(x) ∧ (Equal(SecurityDeposit(x), RentAmount(y)) ∨ MoreThan(SecurityDeposit(x), RentAmount(y))))) ::: A deposit is required to rent an apartment in a managed building. The security deposit can be either equal to one month's rent or more.",
                    "gram": "AllowedIn(x,y) ::: A deposit is required to rent an apartment in a managed building. The security deposit can be either equal to one month's rent or more."
                },
                {
                    "raw": "RentApartment(tom, olivegarden) ↔ (AllowedIn(tom, olivegarden) ∧ SecurityDeposit(olivegarden) ∧ (Equal(SecurityDeposit(olivegarden), 1500) ∨ ¬MoreThan(SecurityDeposit(olivegarden), 1500))) ::: Tom will rent an apartment in a managed building if and only if he is allowed to move in with Fluffy, and the security deposit is no more than $1500.",
                    "gram": "AllowedIn(x,y)∧SecurityDeposit(y)∧(Equal(y,x)∨¬MoreThan(y,x)) ::: Tom will rent an apartment in a managed building if and only if he is allowed to move in with Fluffy, and the security deposit is no more than $1500."
                }
            ],
            "answer": "B",
            "grammar_answer": "C"
        },
        {
            "id": 104,
            "raw_prog": {
                "First-Order-Logic Rules": "∀x (Twins(x) ∨ Triplets(x) → SpendTimeWith(x, x)) ::: If people are twins or triplets, then they spend a lot of time hanging out with and playing with their siblings.\n∀x (Siblings(x, y) → Twins(x) ∨ Triplets(x)) ::: If people have siblings who are the same age, then they are twins or triplets.\n∀x (Complain(x) → Siblings(x, y)) ::: If people complain often about annoying siblings, then they have siblings who are the same age.\n∀x (¬LiveAtHome(x) → ¬DevelopBonds(x, y)) ::: If people do not live at home regularly, then they do not develop strong bonds with their family members.\n∀x (SpendTimeWith(x, y) → ¬LiveAtHome(x)) ::: If people spend a lot of time hanging out with and playing with their siblings, then they often did not live at home regularly.\n(Twins(luke) ∧ DevelopBonds(luke, luke)) ⊕ (¬Twins(luke) ∧ ¬DevelopBonds(luke, luke)) ::: Luke is either both a twin or triplet and develops strong bonds with his family members, or he neither is a twin or triplet nor develops strong bonds with his family members.\n",
                "First-Order-Logic Question": "¬(Twins(luke) ∨ Triplets(luke) ∨ Complain(luke)) ::: Luke is neither a twin nor triplet nor complains often about annoying siblings."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∀x (Twins(x) ∨ Triplets(x) → SpendTimeWith(x, x)) ::: If people are twins or triplets, then they spend a lot of time hanging out with and playing with their siblings.\n∀x (Siblings(x, y) → Twins(x) ∨ Triplets(x)) ::: If people have siblings who are the same age, then they are twins or triplets.\n∀x (Complain(x) → Siblings(x, y)) ::: If people complain often about annoying siblings, then they have siblings who are the same age.\n∀x (¬LiveAtHome(x) → ¬DevelopBonds(x, y)) ::: If people do not live at home regularly, then they do not develop strong bonds with their family members.\n∀x (SpendTimeWith(x, y) → ¬LiveAtHome(x)) ::: If people spend a lot of time hanging out with and playing with their siblings, then they often did not live at home regularly.\n(Twins(luke) ∧ DevelopBonds(luke, luke)) ⊕ (¬Twins(luke) ∧ ¬DevelopBonds(luke, luke)) ::: Luke is either both a twin or triplet and develops strong bonds with his family members, or he neither is a twin or triplet nor develops strong bonds with his family members.\n",
                "First-Order-Logic Question": "¬(Twins(luke) ∨ Triplets(luke) ∨ Complain(luke)) ::: Luke is neither a twin nor triplet nor complains often about annoying siblings."
            },
            "diff": [],
            "answer": "A",
            "grammar_answer": "C"
        },
        {
            "id": 124,
            "raw_prog": {
                "First-Order-Logic Rules": "∀x (Transport(x) → ¬Empty(x)) ::: If something can transport multiple passengers, then they are not empty. \n∀x (Airline(x) → Transport(x)) ::: All airlines can transport multiple passengers. \n∀x (Plane(x) → Empty(x)) ::: All planes are empty. \n∀x (Boeing707(x) → Plane(x)) ::: All Boeing 707s are planes. \nAirline(Greyhound) → ¬∃x (Greyhound(x) ∧ Plane(x)) ::: If Greyhound is not an airline, then there are no Greyhound planes.\n",
                "First-Order-Logic Question": "¬(Greyhound(x) ∧ Boeing707(x)) ::: A Greyhound is not a Boeing 707."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∀x (Transport(x) → ¬Empty(x)) ::: If something can transport multiple passengers, then they are not empty. \n∀x (Airline(x) → Transport(x)) ::: All airlines can transport multiple passengers. \n∀x (Plane(x) → Empty(x)) ::: All planes are empty. \n∀x (Boeing707(x) → Plane(x)) ::: All Boeing 707s are planes. \nAirline(x)→¬(Greyhound(x)∧Plane(x)) ::: If Greyhound is not an airline, then there are no Greyhound planes.\n",
                "First-Order-Logic Question": "¬(Greyhound(x) ∧ Boeing707(x)) ::: A Greyhound is not a Boeing 707."
            },
            "diff": [
                {
                    "raw": "Airline(Greyhound) → ¬∃x (Greyhound(x) ∧ Plane(x)) ::: If Greyhound is not an airline, then there are no Greyhound planes.",
                    "gram": "Airline(x)→¬(Greyhound(x)∧Plane(x)) ::: If Greyhound is not an airline, then there are no Greyhound planes."
                }
            ],
            "answer": "A",
            "grammar_answer": "C"
        },
        {
            "id": 128,
            "raw_prog": {
                "First-Order-Logic Rules": "∀x (HaveWedding(x) → HaveChild(x)) ::: All people who have a wedding are people who have at least one child.\n∀x (TravelToParis(x) → HaveWedding(x)) ::: All people who travel to Paris for their honeymoon are people who have a wedding.\n∀x (OccurIn(x, July) ∧ HaveWedding(x) → TravelToParis(x)) ::: All weddings that occur in July belong to people who travel to Paris for their honeymoon.\n∃x (OccurIn(x, July) ∧ WellAttended(x)) ::: Some weddings in July are well-attended.\nHaveChild(John) → (¬TravelToParis(John) ∧ ¬HaveWedding(John)) ::: If John has at least one child, then John does not travel to Paris for his honeymoon and does not have a wedding.\nHaveWedding(John) ∧ WellAttended(John) → (OccurIn(John, July) ∨ (¬OccurIn(John, July) → TravelToParis(John))) ::: If John has a wedding that is well-attended, then John has a wedding in July or, if not, then John travels to Paris for their honeymoon.",
                "First-Order-Logic Question": "WellAttended(John) ::: John has a wedding that is well-attended."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∀x (HaveWedding(x) → HaveChild(x)) ::: All people who have a wedding are people who have at least one child.\n∀x (TravelToParis(x) → HaveWedding(x)) ::: All people who travel to Paris for their honeymoon are people who have a wedding.\n∀x (OccurIn(x, July) ∧ HaveWedding(x) → TravelToParis(x)) ::: All weddings that occur in July belong to people who travel to Paris for their honeymoon.\n∃x (OccurIn(x, July) ∧ WellAttended(x)) ::: Some weddings in July are well-attended.\nHaveChild(John) → (¬TravelToParis(John) ∧ ¬HaveWedding(John)) ::: If John has at least one child, then John does not travel to Paris for his honeymoon and does not have a wedding.\nHaveWedding(John) ∧ WellAttended(John) → (OccurIn(John, July) ∨ (¬OccurIn(John, July) → TravelToParis(John))) ::: If John has a wedding that is well-attended, then John has a wedding in July or, if not, then John travels to Paris for their honeymoon.",
                "First-Order-Logic Question": "WellAttended(John) ::: John has a wedding that is well-attended."
            },
            "diff": [],
            "answer": "B",
            "grammar_answer": "C"
        },
        {
            "id": 138,
            "raw_prog": {
                "First-Order-Logic Rules": "∀x (Algorithm(x) → (SupervisedLearning(x) ∨ UnsupervisedLearning(x) ∨ ReinforcementLearning(x))) ::: Machine Learning algorithms can be categorized as supervised learning, unsupervised learning, and reinforcement learning.\n∀x (UnsupervisedLearning(x) → ¬RequireLabelledData(x)) ::: Unsupervised learning doesn't require labelled data.\nStateOfTheArtModel(model) ∧ Algorithm(algo) ∧ TrainedWith(model, algo) ::: The state-of-the-art text summarization model is trained with machine learning algorithms.\nReinforcementLearning(rl) → ¬TrainedWith(StateOfTheArtModel(model), rl) ::: Reinforcement learning is not used to train the state-of-the-art text summarization model.\n∀x (Algorithm(x) ∧ TrainedWith(StateOfTheArtModel(model), x) → RequireLabelledData(x)) ::: The Machine Learning algorithm for training text summarization model requires labelled data.\n",
                "First-Order-Logic Question": "SupervisedLearning(supervised) ∧ TrainedWith(StateOfTheArtModel(model), supervised) ::: Supervised learning is used to train the state-of-the-art text summarization model."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∀x (Algorithm(x) → (SupervisedLearning(x) ∨ UnsupervisedLearning(x) ∨ ReinforcementLearning(x))) ::: Machine Learning algorithms can be categorized as supervised learning, unsupervised learning, and reinforcement learning.\n∀x (UnsupervisedLearning(x) → ¬RequireLabelledData(x)) ::: Unsupervised learning doesn't require labelled data.\nStateOfTheArtModel(model) ∧ Algorithm(algo) ∧ TrainedWith(model, algo) ::: The state-of-the-art text summarization model is trained with machine learning algorithms.\nAlgorithm(y)→¬TrainedWith(y,x) ::: Reinforcement learning is not used to train the state-of-the-art text summarization model.\nAlgorithm(x)∧TrainedWith(y,x)→RequireLabelledData(x) ::: The Machine Learning algorithm for training text summarization model requires labelled data.\n",
                "First-Order-Logic Question": "Algorithm(y)∧RequireLabelledData(y)→SupervisedLearning(y) ::: Supervised learning is used to train the state-of-the-art text summarization model."
            },
            "diff": [
                {
                    "raw": "ReinforcementLearning(rl) → ¬TrainedWith(StateOfTheArtModel(model), rl) ::: Reinforcement learning is not used to train the state-of-the-art text summarization model.",
                    "gram": "Algorithm(y)→¬TrainedWith(y,x) ::: Reinforcement learning is not used to train the state-of-the-art text summarization model."
                },
                {
                    "raw": "∀x (Algorithm(x) ∧ TrainedWith(StateOfTheArtModel(model), x) → RequireLabelledData(x)) ::: The Machine Learning algorithm for training text summarization model requires labelled data.",
                    "gram": "Algorithm(x)∧TrainedWith(y,x)→RequireLabelledData(x) ::: The Machine Learning algorithm for training text summarization model requires labelled data."
                }
            ],
            "answer": "A",
            "grammar_answer": "C"
        },
        {
            "id": 139,
            "raw_prog": {
                "First-Order-Logic Rules": "∀x (SupervisedLearning(x) ∨ UnsupervisedLearning(x) ∨ ReinforcementLearning(x)) ::: Machine Learning algorithms can be categorized as supervised learning, unsupervised learning, and reinforcement learning.\nUnsupervisedLearning(x) → ¬RequireLabelledData(x) ::: Unsupervised learning doesn't require labelled data.\nTrainedWith(StateOfTheArtModel(textsummarization), MachineLearningAlgorithm(x)) ::: The state-of-the-art text summarization model is trained with machine learning algorithms.\nReinforcementLearning(x) → ¬TrainedWith(StateOfTheArtModel(textsummarization), x) ::: Reinforcement learning is not used to train the state-of-the-art text summarization model.\nRequireLabelledData(x) → MachineLearningAlgorithm(x) ::: The Machine Learning algorithm for training text summarization model requires labelled data.\n",
                "First-Order-Logic Question": "¬UsedToTrain(UnsupervisedLearning, StateOfTheArtModel(textsummarization)) ::: Unsupervised learning is used to train the state-of-the-art text summarization model."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∀x (SupervisedLearning(x) ∨ UnsupervisedLearning(x) ∨ ReinforcementLearning(x)) ::: Machine Learning algorithms can be categorized as supervised learning, unsupervised learning, and reinforcement learning.\nUnsupervisedLearning(x) → ¬RequireLabelledData(x) ::: Unsupervised learning doesn't require labelled data.\nUsedToTrain(y,x) ::: The state-of-the-art text summarization model is trained with machine learning algorithms.\nUsedToTrain(x,y)→¬ReinforcementLearning(y) ::: Reinforcement learning is not used to train the state-of-the-art text summarization model.\nRequireLabelledData(x) → MachineLearningAlgorithm(x) ::: The Machine Learning algorithm for training text summarization model requires labelled data.\n",
                "First-Order-Logic Question": "UsedToTrain(y,z)→¬UnsupervisedLearning(y) ::: Unsupervised learning is used to train the state-of-the-art text summarization model."
            },
            "diff": [
                {
                    "raw": "TrainedWith(StateOfTheArtModel(textsummarization), MachineLearningAlgorithm(x)) ::: The state-of-the-art text summarization model is trained with machine learning algorithms.",
                    "gram": "UsedToTrain(y,x) ::: The state-of-the-art text summarization model is trained with machine learning algorithms."
                },
                {
                    "raw": "ReinforcementLearning(x) → ¬TrainedWith(StateOfTheArtModel(textsummarization), x) ::: Reinforcement learning is not used to train the state-of-the-art text summarization model.",
                    "gram": "UsedToTrain(x,y)→¬ReinforcementLearning(y) ::: Reinforcement learning is not used to train the state-of-the-art text summarization model."
                }
            ],
            "answer": "B",
            "grammar_answer": "C"
        },
        {
            "id": 155,
            "raw_prog": {
                "First-Order-Logic Rules": "∀x,y (Owns(x, y) → (WorkRegularly(x) ∧ WorkOften(x))) ::: If people own a large desktop monitor at their home, then they work regularly and often at home.\n∀x (FullyStocked(x) → Owns(x, largeDesktopMonitor) ∧ Impressive(x)) ::: All people who have a fully stocked and impressive home office are people who own a large desktop monitor at their home.\n∀x (WorkRegularly(x) ∧ WorkOften(x) → Tidy(x)) ::: All people who work regularly and often at home spend their free time tidying and organizing the spaces in their homes.\n∀x (WorkRegularly(x) ∧ WorkOften(x) → VisitStore(x)) ::: All people who work regularly and often at home visit the office supply store regularly.\n∀x (Tidy(x) → (¬Late(x) ∧ ¬WakeLate(x))) ::: If people spend their free time tidying and organizing the spaces in their home, then they do not go to bed late and wake up every day after noon.\n(Tidy(remy) ∧ Late(remy) ∧ WakeLate(remy)) ⊕ (¬Late(remy) ∧ ¬WakeLate(remy) ∧ ¬Tidy(remy)) ::: Remy either both goes to bed late and wakes up every day after noon and spends their free time tidying and organizing the spaces in their home, or they do not go to bed late and wake up every day after noon nor spend their free time tidying and organizing the spaces in their home.\n",
                "First-Order-Logic Question": "((Late(remy) ∧ WakeLate(remy)) ∨ VisitStore(remy)) → (¬Tidy(remy) ∧ ¬FullyStocked(remy)) ::: If Remy either goes to bed late and wakes up every day after noon or visits the office supply store regularly, then Remy neither spends their free time tidying and organizing the spaces in their home nor has a fully stocked and impressive home office."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "Impressive(x) ::: If people own a large desktop monitor at their home, then they work regularly and often at home.\n∀x (FullyStocked(x) → Owns(x, largeDesktopMonitor) ∧ Impressive(x)) ::: All people who have a fully stocked and impressive home office are people who own a large desktop monitor at their home.\n∀x (WorkRegularly(x) ∧ WorkOften(x) → Tidy(x)) ::: All people who work regularly and often at home spend their free time tidying and organizing the spaces in their homes.\n∀x (WorkRegularly(x) ∧ WorkOften(x) → VisitStore(x)) ::: All people who work regularly and often at home visit the office supply store regularly.\n∀x (Tidy(x) → (¬Late(x) ∧ ¬WakeLate(x))) ::: If people spend their free time tidying and organizing the spaces in their home, then they do not go to bed late and wake up every day after noon.\n(Tidy(remy) ∧ Late(remy) ∧ WakeLate(remy)) ⊕ (¬Late(remy) ∧ ¬WakeLate(remy) ∧ ¬Tidy(remy)) ::: Remy either both goes to bed late and wakes up every day after noon and spends their free time tidying and organizing the spaces in their home, or they do not go to bed late and wake up every day after noon nor spend their free time tidying and organizing the spaces in their home.\n",
                "First-Order-Logic Question": "((Late(remy) ∧ WakeLate(remy)) ∨ VisitStore(remy)) → (¬Tidy(remy) ∧ ¬FullyStocked(remy)) ::: If Remy either goes to bed late and wakes up every day after noon or visits the office supply store regularly, then Remy neither spends their free time tidying and organizing the spaces in their home nor has a fully stocked and impressive home office."
            },
            "diff": [
                {
                    "raw": "∀x,y (Owns(x, y) → (WorkRegularly(x) ∧ WorkOften(x))) ::: If people own a large desktop monitor at their home, then they work regularly and often at home.",
                    "gram": "Impressive(x) ::: If people own a large desktop monitor at their home, then they work regularly and often at home."
                }
            ],
            "answer": "A",
            "grammar_answer": "C"
        },
        {
            "id": 166,
            "raw_prog": {
                "First-Order-Logic Rules": "∃x ∃y (Monday(y) ∧ Time(y) ∧ Roses(x) ∧ GivenOut(x, y)) ::: On some Mondays at 8 pm, roses are given out on TV.\n∀x (Roses(x) → On(x, Bachelor)) ::: Every rose given out on TV is on the Bachelor.\n∀x (On(x, Bachelor) → Portray(x, RealPeople)) ::: Everything on the Bachelor portrays the lives of real people.\n∀x (Portray(x, RealPeople) → RealityTVShow(x)) ::: All shows portraying the lives of real people are reality TV shows.\n¬RealityTVShow(BreakingBad) ::: Breaking Bad is not a reality TV show.\n",
                "First-Order-Logic Question": "∀x (Roses(x) ∧ GivenOut(x, Monday(8pm))) → On(BreakingBad, Monday(8pm)) ::: If roses are given out during Breaking Bad, then it is on Monday at 8 pm."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∃x ∃y (Monday(y) ∧ Time(y) ∧ Roses(x) ∧ GivenOut(x, y)) ::: On some Mondays at 8 pm, roses are given out on TV.\n∀x (Roses(x) → On(x, Bachelor)) ::: Every rose given out on TV is on the Bachelor.\n∀x (On(x, Bachelor) → Portray(x, RealPeople)) ::: Everything on the Bachelor portrays the lives of real people.\n∀x (Portray(x, RealPeople) → RealityTVShow(x)) ::: All shows portraying the lives of real people are reality TV shows.\n¬RealityTVShow(BreakingBad) ::: Breaking Bad is not a reality TV show.\n",
                "First-Order-Logic Question": "GivenOut(x,y)∧On(y,y)→On(x,y) ::: If roses are given out during Breaking Bad, then it is on Monday at 8 pm."
            },
            "diff": [],
            "answer": "A",
            "grammar_answer": "C"
        },
        {
            "id": 181,
            "raw_prog": {
                "First-Order-Logic Rules": "Flies(susan, LGA) ::: Susan flies to LGA airport.\n∀x (Airport(x) ∧ Flies(john, x) ∧ ¬(DepartsFrom(john, x) ∧ ArrivesAt(john, x))) ::: The departure and arrival can not be the same airport.\n",
                "First-Order-Logic Question": "Flies(john, LGA) ::: John flies to LGA airport."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "Flies(susan, LGA) ::: Susan flies to LGA airport.\n∀x (Airport(x) ∧ Flies(john, x) ∧ ¬(DepartsFrom(john, x) ∧ ArrivesAt(john, x))) ::: The departure and arrival can not be the same airport.\n",
                "First-Order-Logic Question": "Flies(john, LGA) ::: John flies to LGA airport."
            },
            "diff": [],
            "answer": "B",
            "grammar_answer": "A"
        },
        {
            "id": 103,
            "raw_prog": {
                "First-Order-Logic Rules": "∀x (Twins(x) ∨ Triplets(x) → SpendTimeWith(x, Siblings(x))) ::: If people are twins or triplets, then they spend a lot of time hanging out with and playing with their siblings.\n∀x (Siblings(x, y) → Twins(x) ∨ Triplets(x)) ::: If people have siblings who are the same age, then they are twins or triplets.\n∀x (Complain(x) → Siblings(x, y)) ::: If people complain often about annoying siblings, then they have siblings who are the same age.\n∀x (¬LiveAtHomeRegularly(x) → ¬DevelopBonds(x, y)) ::: If people do not live at home regularly, then they do not develop strong bonds with their family members.\n∀x (SpendTimeWith(x, Siblings(x)) → ¬LiveAtHomeRegularly(x)) ::: If people spend a lot of time hanging out with and playing with their siblings, then they often did not live at home regularly.\n(Twins(luke) ∧ DevelopBonds(luke, FamilyMembers)) ∨ (¬Twins(luke) ∧ ¬DevelopBonds(luke, FamilyMembers)) ::: Luke is either both a twin or triplet and develops strong bonds with his family members, or he neither is a twin or triplet nor develops strong bonds with his family members.\n",
                "First-Order-Logic Question": "Complain(luke) ::: Luke complains often about annoying siblings."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "LiveAtHomeRegularly(x)→(Twins(x)∨Triplets(x)) ::: If people are twins or triplets, then they spend a lot of time hanging out with and playing with their siblings.\n∀x (Siblings(x, y) → Twins(x) ∨ Triplets(x)) ::: If people have siblings who are the same age, then they are twins or triplets.\n∀x (Complain(x) → Siblings(x, y)) ::: If people complain often about annoying siblings, then they have siblings who are the same age.\n∀x (¬LiveAtHomeRegularly(x) → ¬DevelopBonds(x, y)) ::: If people do not live at home regularly, then they do not develop strong bonds with their family members.\nLiveAtHomeRegularly(x)→¬SpendTimeWith(x,y) ::: If people spend a lot of time hanging out with and playing with their siblings, then they often did not live at home regularly.\n(Twins(luke) ∧ DevelopBonds(luke, FamilyMembers)) ∨ (¬Twins(luke) ∧ ¬DevelopBonds(luke, FamilyMembers)) ::: Luke is either both a twin or triplet and develops strong bonds with his family members, or he neither is a twin or triplet nor develops strong bonds with his family members.\n",
                "First-Order-Logic Question": "Complain(luke) ::: Luke complains often about annoying siblings."
            },
            "diff": [
                {
                    "raw": "∀x (Twins(x) ∨ Triplets(x) → SpendTimeWith(x, Siblings(x))) ::: If people are twins or triplets, then they spend a lot of time hanging out with and playing with their siblings.",
                    "gram": "LiveAtHomeRegularly(x)→(Twins(x)∨Triplets(x)) ::: If people are twins or triplets, then they spend a lot of time hanging out with and playing with their siblings."
                },
                {
                    "raw": "∀x (SpendTimeWith(x, Siblings(x)) → ¬LiveAtHomeRegularly(x)) ::: If people spend a lot of time hanging out with and playing with their siblings, then they often did not live at home regularly.",
                    "gram": "LiveAtHomeRegularly(x)→¬SpendTimeWith(x,y) ::: If people spend a lot of time hanging out with and playing with their siblings, then they often did not live at home regularly."
                }
            ],
            "answer": "B",
            "grammar_answer": "C"
        },
        {
            "id": 105,
            "raw_prog": {
                "First-Order-Logic Rules": "Cost(gre_test, 205) ::: It costs US $205 to take the GRE test.\n∀x ∀y (Prove(x, EconomicHardship(y)) → ProvideAid(ETS, y)) ::: ETS provides financial aid to those GRE applicants who prove economic hardship.\n∀x (EconomicHardship(x) ↔ (Difficulty(x, money) ∨ Difficulty(x, resources))) ::: Economic hardship refers to difficulty caused by having too little money or too few resources.\nSingleParent(tom) ::: Tom lives in a single-parent family.\nOutOfWork(tom_dad, more_than_1_year) ::: His dad has been out of work for more than a year.\n",
                "First-Order-Logic Question": "ApplyFor(tom, ETS, gre_test) ::: Tom can apply for financial aid from ETS to take the GRE test."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "Cost(gre_test, 205) ::: It costs US $205 to take the GRE test.\nApplyFor(x,y,z)∧Prove(x,z)→ProvideAid(y,z) ::: ETS provides financial aid to those GRE applicants who prove economic hardship.\n∀x (EconomicHardship(x) ↔ (Difficulty(x, money) ∨ Difficulty(x, resources))) ::: Economic hardship refers to difficulty caused by having too little money or too few resources.\nSingleParent(tom) ::: Tom lives in a single-parent family.\nOutOfWork(tom_dad, more_than_1_year) ::: His dad has been out of work for more than a year.\n",
                "First-Order-Logic Question": "ApplyFor(tom, ETS, gre_test) ::: Tom can apply for financial aid from ETS to take the GRE test."
            },
            "diff": [
                {
                    "raw": "∀x ∀y (Prove(x, EconomicHardship(y)) → ProvideAid(ETS, y)) ::: ETS provides financial aid to those GRE applicants who prove economic hardship.",
                    "gram": "ApplyFor(x,y,z)∧Prove(x,z)→ProvideAid(y,z) ::: ETS provides financial aid to those GRE applicants who prove economic hardship."
                }
            ],
            "answer": "A",
            "grammar_answer": "C"
        },
        {
            "id": 129,
            "raw_prog": {
                "First-Order-Logic Rules": "∀x (HaveWedding(x) → HaveChild(x)) ::: All people who have a wedding are people who have at least one child.\n∀x (TravelToParisForHoneymoon(x) → HaveWedding(x)) ::: All people who travel to Paris for their honeymoon are people who have a wedding.\n∀x (Weddings(x) ∧ July(x) → BelongTo(x, TravelToParisForHoneymoon(x))) ::: All weddings that occur in July belong to people who travel to Paris for their honeymoon.\n∃x (Weddings(x) ∧ July(x) ∧ WellAttended(x)) ::: Some weddings in July are well-attended.\nHaveChild(John) → (¬TravelToParisForHoneymoon(John) ∧ ¬HaveWedding(John)) ::: If John has at least one child, then John does not travel to Paris for his honeymoon and does not have a wedding.\nHaveWedding(John) ∧ WellAttended(John) → (July(John) ∨ (¬July(John) ∧ TravelToParisForHoneymoon(John))) ::: If John has a wedding that is well-attended, then John has a wedding in July or, if not, then John travels to Paris for their honeymoon.",
                "First-Order-Logic Question": "¬WellAttended(John) ::: John does not have a wedding that is well-attended."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∀x (HaveWedding(x) → HaveChild(x)) ::: All people who have a wedding are people who have at least one child.\n∀x (TravelToParisForHoneymoon(x) → HaveWedding(x)) ::: All people who travel to Paris for their honeymoon are people who have a wedding.\nWellAttended(x)∧¬(July(x))→BelongTo(x,y) ::: All weddings that occur in July belong to people who travel to Paris for their honeymoon.\n∃x (Weddings(x) ∧ July(x) ∧ WellAttended(x)) ::: Some weddings in July are well-attended.\nHaveChild(John) → (¬TravelToParisForHoneymoon(John) ∧ ¬HaveWedding(John)) ::: If John has at least one child, then John does not travel to Paris for his honeymoon and does not have a wedding.\nHaveWedding(John) ∧ WellAttended(John) → (July(John) ∨ (¬July(John) ∧ TravelToParisForHoneymoon(John))) ::: If John has a wedding that is well-attended, then John has a wedding in July or, if not, then John travels to Paris for their honeymoon.",
                "First-Order-Logic Question": "¬WellAttended(John) ::: John does not have a wedding that is well-attended."
            },
            "diff": [
                {
                    "raw": "∀x (Weddings(x) ∧ July(x) → BelongTo(x, TravelToParisForHoneymoon(x))) ::: All weddings that occur in July belong to people who travel to Paris for their honeymoon.",
                    "gram": "WellAttended(x)∧¬(July(x))→BelongTo(x,y) ::: All weddings that occur in July belong to people who travel to Paris for their honeymoon."
                }
            ],
            "answer": "A",
            "grammar_answer": "C"
        },
        {
            "id": 131,
            "raw_prog": {
                "First-Order-Logic Rules": "∀x HaveWedding(x) → HaveChild(x) ::: All people who have a wedding are people who have at least one child.\n∀x (TravelToParisForHoneymoon(x) → HaveWedding(x)) ::: All people who travel to Paris for their honeymoon are people who have a wedding.\n∀x (Weddings(x) ∧ July(x) → BelongTo(x, TravelToParisForHoneymoon(x))) ::: All weddings that occur in July belong to people who travel to Paris for their honeymoon.\n∃x (Weddings(x) ∧ July(x) ∧ WellAttended(x)) ::: Some weddings in July are well-attended.\nHaveChild(John) → ¬(TravelToParisForHoneymoon(John) ∧ HaveWedding(John)) ::: If John has at least one child, then John does not travel to Paris for his honeymoon and does not have a wedding.\nHaveWedding(John) ∧ WellAttended(John) → (July(John) ∨ (¬July(John) ∧ TravelToParisForHoneymoon(John))) ::: If John has a wedding that is well-attended, then John has a wedding in July or, if not, then John travels to Paris for their honeymoon.",
                "First-Order-Logic Question": "¬(WellAttended(John) ∨ TravelToParisForHoneymoon(John)) ::: John has neither a wedding that is well-attended nor does he travel to Paris for his honeymoon."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∀x HaveWedding(x) → HaveChild(x) ::: All people who have a wedding are people who have at least one child.\n∀x (TravelToParisForHoneymoon(x) → HaveWedding(x)) ::: All people who travel to Paris for their honeymoon are people who have a wedding.\nAttend(y)∧(July(y)→BelongTo(y,z)) ::: All weddings that occur in July belong to people who travel to Paris for their honeymoon.\n∃x (Weddings(x) ∧ July(x) ∧ WellAttended(x)) ::: Some weddings in July are well-attended.\nHaveChild(John) → ¬(TravelToParisForHoneymoon(John) ∧ HaveWedding(John)) ::: If John has at least one child, then John does not travel to Paris for his honeymoon and does not have a wedding.\nHaveWedding(John) ∧ WellAttended(John) → (July(John) ∨ (¬July(John) ∧ TravelToParisForHoneymoon(John))) ::: If John has a wedding that is well-attended, then John has a wedding in July or, if not, then John travels to Paris for their honeymoon.",
                "First-Order-Logic Question": "¬(WellAttended(John) ∨ TravelToParisForHoneymoon(John)) ::: John has neither a wedding that is well-attended nor does he travel to Paris for his honeymoon."
            },
            "diff": [
                {
                    "raw": "∀x (Weddings(x) ∧ July(x) → BelongTo(x, TravelToParisForHoneymoon(x))) ::: All weddings that occur in July belong to people who travel to Paris for their honeymoon.",
                    "gram": "Attend(y)∧(July(y)→BelongTo(y,z)) ::: All weddings that occur in July belong to people who travel to Paris for their honeymoon."
                }
            ],
            "answer": "A",
            "grammar_answer": "C"
        },
        {
            "id": 165,
            "raw_prog": {
                "First-Order-Logic Rules": "∃x ∃y (Roses(x) ∧ GivenOut(x, y) ∧ y = 8pm ∧ y = Monday) ::: On some Mondays at 8 pm, roses are given out on TV.\n∀x (Roses(x) → On(x, Bachelor)) ::: Every rose given out on TV is on the Bachelor.\n∀x (On(x, Bachelor) → Portray(x, RealPeople)) ::: Everything on the Bachelor portrays the lives of real people.\n∀x (Portray(x, RealPeople) → RealityTVShow(x)) ::: All shows portraying the lives of real people are reality TV shows.\n¬RealityTVShow(BreakingBad) ::: Breaking Bad is not a reality TV show.\n",
                "First-Order-Logic Question": "BreakingBad(x) ∧ ∃y (Roses(y) ∧ GivenOut(y, 8pm) ∧ y = Monday) ::: Breaking Bad is a TV show in which roses are given out on Monday at 8 pm."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "GivenOut(x,y)∧On(y,y)∧TVShow(y) ::: On some Mondays at 8 pm, roses are given out on TV.\n∀x (Roses(x) → On(x, Bachelor)) ::: Every rose given out on TV is on the Bachelor.\n∀x (On(x, Bachelor) → Portray(x, RealPeople)) ::: Everything on the Bachelor portrays the lives of real people.\n∀x (Portray(x, RealPeople) → RealityTVShow(x)) ::: All shows portraying the lives of real people are reality TV shows.\n¬RealityTVShow(BreakingBad) ::: Breaking Bad is not a reality TV show.\n",
                "First-Order-Logic Question": "GivenOut(y,y)∧On(y,y)→TVShow(y) ::: Breaking Bad is a TV show in which roses are given out on Monday at 8 pm."
            },
            "diff": [
                {
                    "raw": "∃x ∃y (Roses(x) ∧ GivenOut(x, y) ∧ y = 8pm ∧ y = Monday) ::: On some Mondays at 8 pm, roses are given out on TV.",
                    "gram": "GivenOut(x,y)∧On(y,y)∧TVShow(y) ::: On some Mondays at 8 pm, roses are given out on TV."
                }
            ],
            "answer": "B",
            "grammar_answer": "A"
        },
        {
            "id": 180,
            "raw_prog": {
                "First-Order-Logic Rules": "Flies(susan, lga) ::: Susan flies to LGA airport.\nDeparture(x, y) ∧ Arrival(x, y) ⊕ ¬(x = y) ::: The departure and arrival can not be the same airport.\nFrom(john, lga) ::: John flies from LGA airport.",
                "First-Order-Logic Question": "From(susan, lga) ::: Susan flies from LGA airport."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "Flies(susan, lga) ::: Susan flies to LGA airport.\nAirport(x)∧Departure(x,y)∧Arrival(x,y)⊕¬(Departure(x,y)∧Arrival(x,y)) ::: The departure and arrival can not be the same airport.\nFrom(john, lga) ::: John flies from LGA airport.",
                "First-Order-Logic Question": "From(susan, lga) ::: Susan flies from LGA airport."
            },
            "diff": [
                {
                    "raw": "Departure(x, y) ∧ Arrival(x, y) ⊕ ¬(x = y) ::: The departure and arrival can not be the same airport.",
                    "gram": "Airport(x)∧Departure(x,y)∧Arrival(x,y)⊕¬(Departure(x,y)∧Arrival(x,y)) ::: The departure and arrival can not be the same airport."
                }
            ],
            "answer": "B",
            "grammar_answer": "C"
        },
        {
            "id": 199,
            "raw_prog": {
                "First-Order-Logic Rules": "Person(ailtonSilva) ∧ Born(ailtonSilva, 1995) ∧ KnownAs(ailtonSilva, ailton) ∧ FootballPlayer(ailton) ∧ Loan(ailton, braga) ∧ Brazilian(ailtonSilva) ∧ PlaysFor(ailtonSilva, nautico) ∧ Club(nautico) ∧ Club(braga) ∧ Club(fluminense) ::: Ailton Silva, born in 1995, is commonly known as Ailton. Ailton is a football player who was loaned out to Braga. Ailton Silva is a Brazillian footballer who plays for Nautico. Nautico is a football club along with Braga. Fluminense is a football club.",
                "First-Order-Logic Question": "¬∃x (PlaysFor(x, nautico) ∧ Brazilian(x)) ::: No one playing for Nautico is Brazilian."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "FootballPlayer(x)∧Loan(x,y)→KnownAs(y,x) ::: Ailton Silva, born in 1995, is commonly known as Ailton. Ailton is a football player who was loaned out to Braga. Ailton Silva is a Brazillian footballer who plays for Nautico. Nautico is a football club along with Braga. Fluminense is a football club.",
                "First-Order-Logic Question": "¬∃x (PlaysFor(x, nautico) ∧ Brazilian(x)) ::: No one playing for Nautico is Brazilian."
            },
            "diff": [
                {
                    "raw": "Person(ailtonSilva) ∧ Born(ailtonSilva, 1995) ∧ KnownAs(ailtonSilva, ailton) ∧ FootballPlayer(ailton) ∧ Loan(ailton, braga) ∧ Brazilian(ailtonSilva) ∧ PlaysFor(ailtonSilva, nautico) ∧ Club(nautico) ∧ Club(braga) ∧ Club(fluminense) ::: Ailton Silva, born in 1995, is commonly known as Ailton. Ailton is a football player who was loaned out to Braga. Ailton Silva is a Brazillian footballer who plays for Nautico. Nautico is a football club along with Braga. Fluminense is a football club.",
                    "gram": "FootballPlayer(x)∧Loan(x,y)→KnownAs(y,x) ::: Ailton Silva, born in 1995, is commonly known as Ailton. Ailton is a football player who was loaned out to Braga. Ailton Silva is a Brazillian footballer who plays for Nautico. Nautico is a football club along with Braga. Fluminense is a football club."
                }
            ],
            "answer": "B",
            "grammar_answer": "C"
        },
        {
            "id": 201,
            "raw_prog": {
                "First-Order-Logic Rules": "Person(ailtonSilva) ∧ Born(ailtonSilva, 1995) ∧ KnownAs(ailtonSilva, ailton) ::: Ailton Silva, born in 1995, is commonly known as Ailton.\nFootballPlayer(ailton) ∧ Loan(ailton, braga) ::: Ailton is a football player who was loaned out to Braga.\nBrazilian(ailtonSilva) ∧ FootballPlayer(ailtonSilva) ∧ PlaysFor(ailtonSilva, nautico) ::: Ailton Silva is a Brazillian footballer who plays for Nautico.\nClub(nautico) ∧ Club(braga) ∧ Team(nautico, braga) ::: Nautico is a football club along with Braga.\nClub(fluminense) ::: Fluminense is a football club.\n",
                "First-Order-Logic Question": "¬(∃x Loan(ailton, Club(x))) ::: Ailton was not loaned out to a football club."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "Person(ailtonSilva) ∧ Born(ailtonSilva, 1995) ∧ KnownAs(ailtonSilva, ailton) ::: Ailton Silva, born in 1995, is commonly known as Ailton.\nFootballPlayer(ailton) ∧ Loan(ailton, braga) ::: Ailton is a football player who was loaned out to Braga.\nBrazilian(ailtonSilva) ∧ FootballPlayer(ailtonSilva) ∧ PlaysFor(ailtonSilva, nautico) ::: Ailton Silva is a Brazillian footballer who plays for Nautico.\nClub(nautico) ∧ Club(braga) ∧ Team(nautico, braga) ::: Nautico is a football club along with Braga.\nClub(fluminense) ::: Fluminense is a football club.\n",
                "First-Order-Logic Question": "FootballPlayer(x)→¬Loan(x,y) ::: Ailton was not loaned out to a football club."
            },
            "diff": [],
            "answer": "B",
            "grammar_answer": "C"
        },
        {
            "id": 11,
            "raw_prog": {
                "First-Order-Logic Rules": "WildTurkey(tom) ::: Tom is a wild turkey.\n∀x (WildTurkey(x) → (x = EasternWildTurkey ∨ x = OsceolaWildTurkey ∨ x = GouldsWildTurkey ∨ x = MerriamsWildTurkey ∨ x = RioGrandeWildTurkey ∨ x = OcellatedWildTurkey)) ::: There are six types of wild turkeys: Eastern wild turkey, Osceola wild turkey, Gould’s wild turkey, Merriam’s wild turkey, Rio Grande wild turkey, and Ocellated wild turkey.\n¬EasternWildTurkey(tom) ∧ ¬OsceolaWildTurkey(tom) ∧ ¬GouldsWildTurkey(tom) ∧ ¬MerriamsWildTurkey(tom) ∧ ¬RioGrandeWildTurkey(tom) ::: Tom is not an Eastern wild turkey, Osceola wild turkey, Gould's wild turkey, Merriam's wild turkey, or Rio Grande wild turkey.\n",
                "First-Order-Logic Question": "WildTurkey(joey) ::: Joey is a wild turkey."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "WildTurkey(tom) ::: Tom is a wild turkey.\nTomWildTurkey(x)∨WildTurkey(x)→(EasternWildTurkey(x)∨OsceolaWildTurkey(x)) ::: There are six types of wild turkeys: Eastern wild turkey, Osceola wild turkey, Gould’s wild turkey, Merriam’s wild turkey, Rio Grande wild turkey, and Ocellated wild turkey.\n¬EasternWildTurkey(tom)∧¬OsceolaWildTurkey(tom)∧¬GouldsWildTurkey(tom)∧¬MerriamsWildTurkey(tom)∧¬RioGrandeWildTurkey(tom) ::: Tom is not an Eastern wild turkey, Osceola wild turkey, Gould's wild turkey, Merriam's wild turkey, or Rio Grande wild turkey.",
                "First-Order-Logic Question": "WildTurkey(joey) ::: Joey is a wild turkey."
            },
            "diff": [],
            "answer": "C",
            "grammar_answer": "A"
        },
        {
            "id": 39,
            "raw_prog": {
                "First-Order-Logic Rules": "∀x (DesignStyle(x, ZahaHadid) → Timeless(x)) ::: All of Zaha Hadid's design styles are timeless. \n∀x (MassProductDesign(x) → ¬Timeless(x)) ::: No mass product design is timeless. \n(DesignStyle(ZahaHadid, y) ∨ DesignStyle(KellyWearstler, y)) ::: Either Zaha Hadid's design style or Kelly Wearstler's design style. \n∀x (DesignStyle(x, KellyWearstler) → Evocative(x)) ::: All of Kelly Wearstler's design styles are evocative. \n∀x (DesignStyle(x, KellyWearstler) → Dreamy(x)) ::: All of Kelly Wearstler's design styles are dreamy. \n∀x (Timeless(DesignBy(x, Max)) → (MassProductDesign(DesignBy(x, Max)) ∧ Evocative(DesignBy(x, Max)))) ::: If a design by Max is timeless, then a design by Max is a mass product design and evocative.\n",
                "First-Order-Logic Question": "MassProductDesign(DesignBy(Max, Max)) ::: A design by Max is a mass product design."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∀x (DesignStyle(x, ZahaHadid) → Timeless(x)) ::: All of Zaha Hadid's design styles are timeless. \n∀x (MassProductDesign(x) → ¬Timeless(x)) ::: No mass product design is timeless. \n(DesignStyle(ZahaHadid, y) ∨ DesignStyle(KellyWearstler, y)) ::: Either Zaha Hadid's design style or Kelly Wearstler's design style. \n∀x (DesignStyle(x, KellyWearstler) → Evocative(x)) ::: All of Kelly Wearstler's design styles are evocative. \n∀x (DesignStyle(x, KellyWearstler) → Dreamy(x)) ::: All of Kelly Wearstler's design styles are dreamy. \nDreamy(x)→(MassProductDesign(y)∧Evocative(y)) ::: If a design by Max is timeless, then a design by Max is a mass product design and evocative.\n",
                "First-Order-Logic Question": "DesignBy(y,z)∧MassProductDesign(z)→MassProductDesign(y) ::: A design by Max is a mass product design."
            },
            "diff": [
                {
                    "raw": "∀x (Timeless(DesignBy(x, Max)) → (MassProductDesign(DesignBy(x, Max)) ∧ Evocative(DesignBy(x, Max)))) ::: If a design by Max is timeless, then a design by Max is a mass product design and evocative.",
                    "gram": "Dreamy(x)→(MassProductDesign(y)∧Evocative(y)) ::: If a design by Max is timeless, then a design by Max is a mass product design and evocative."
                }
            ],
            "answer": "C",
            "grammar_answer": "A"
        },
        {
            "id": 41,
            "raw_prog": {
                "First-Order-Logic Rules": "∀x (DesignStyle(x, ZahaHadid) → Timeless(x)) ::: All of Zaha Hadid's design styles are timeless.\n∀x (MassProductDesign(x) → ¬Timeless(x)) ::: No mass product design is timeless.\nDesignStyle(ZahaHadid, y) ∨ DesignStyle(KellyWearstler, y) ::: Either Zaha Hadid's design style or Kelly Wearstler's design style.\n∀x (DesignStyle(x, KellyWearstler) → Evocative(x)) ::: All of Kelly Wearstler's design styles are evocative.\n∀x (DesignStyle(x, KellyWearstler) → Dreamy(x)) ::: All of Kelly Wearstler's design styles are dreamy.\n∀x (Timeless(DesignBy(x, Max)) → (MassProductDesign(DesignBy(x, Max)) ∧ Evocative(DesignBy(x, Max)))) ::: If a design by Max is timeless, then a design by Max is a mass product design and evocative.\n",
                "First-Order-Logic Question": "Evocative(DesignBy(Max, Max)) ∨ Dreamy(DesignBy(Max, Max)) ::: A design by Max is either evocative or dreamy."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∀x (DesignStyle(x, ZahaHadid) → Timeless(x)) ::: All of Zaha Hadid's design styles are timeless.\n∀x (MassProductDesign(x) → ¬Timeless(x)) ::: No mass product design is timeless.\nDesignStyle(ZahaHadid, y) ∨ DesignStyle(KellyWearstler, y) ::: Either Zaha Hadid's design style or Kelly Wearstler's design style.\n∀x (DesignStyle(x, KellyWearstler) → Evocative(x)) ::: All of Kelly Wearstler's design styles are evocative.\n∀x (DesignStyle(x, KellyWearstler) → Dreamy(x)) ::: All of Kelly Wearstler's design styles are dreamy.\nDreamy(x)→(MassProductDesign(y)∧Evocative(y)) ::: If a design by Max is timeless, then a design by Max is a mass product design and evocative.\n",
                "First-Order-Logic Question": "DesignBy(y,z)∧Evocative(z)∨DesignBy(y,z)∧Dreamy(z) ::: A design by Max is either evocative or dreamy."
            },
            "diff": [
                {
                    "raw": "∀x (Timeless(DesignBy(x, Max)) → (MassProductDesign(DesignBy(x, Max)) ∧ Evocative(DesignBy(x, Max)))) ::: If a design by Max is timeless, then a design by Max is a mass product design and evocative.",
                    "gram": "Dreamy(x)→(MassProductDesign(y)∧Evocative(y)) ::: If a design by Max is timeless, then a design by Max is a mass product design and evocative."
                }
            ],
            "answer": "B",
            "grammar_answer": "A"
        },
        {
            "id": 85,
            "raw_prog": {
                "First-Order-Logic Rules": "∀x (Listed(x) → ¬NotNegative(x)) ::: If the restaurant is listed in Yelp’s recommendations, then the restaurant does not receive many negative reviews.\n∀x (Rating(x, y) ∧ y > 9 → Listed(x)) ::: All restaurants with a rating greater than 9 are listed in Yelp’s recommendations.\n∃x (Restaurant(x) ∧ ¬Provide(x, takeout) → NotNegative(x)) ::: Some restaurants that do not provide take-out service receive many negative reviews.\n∀x (Popular(x) → Rating(x, y) ∧ y > 9) ::: All restaurants that are popular among local residents have ratings greater than 9.\nRating(subway, y) ∨ Popular(subway) ::: Subway has a rating greater than 9 or is popular among local residents.\n",
                "First-Order-Logic Question": "TakeOut(subway) ∧ ¬NotNegative(subway) ::: Subway provides take-out service and does not receive many negative reviews."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∀x (Listed(x) → ¬NotNegative(x)) ::: If the restaurant is listed in Yelp’s recommendations, then the restaurant does not receive many negative reviews.\nProvide(x,y)∧NotNegative(x)∧Rating(x,y)∧Popular(x)∧TakeOut(x)∧Restaurant(x)∧¬(SubwayRestaurant(x)) ::: All restaurants with a rating greater than 9 are listed in Yelp’s recommendations.\n∃x (Restaurant(x) ∧ ¬Provide(x, takeout) → NotNegative(x)) ::: Some restaurants that do not provide take-out service receive many negative reviews.\nProvide(x,y)→Rating(x,y)∧(NotNegative(x)) ::: All restaurants that are popular among local residents have ratings greater than 9.\nRating(subway, y) ∨ Popular(subway) ::: Subway has a rating greater than 9 or is popular among local residents.",
                "First-Order-Logic Question": "TakeOut(subway) ∧ ¬NotNegative(subway) ::: Subway provides take-out service and does not receive many negative reviews."
            },
            "diff": [],
            "answer": "A",
            "grammar_answer": "B"
        },
        {
            "id": 95,
            "raw_prog": {
                "First-Order-Logic Rules": "∃x (Pet(x) ∧ AllowedIn(x, y)) ::: Pets are allowed in some managed buildings.\n∀x (RequireDeposit(x) → (Equal(x, RentAmount(y, z)) ∨ MoreThan(x, RentAmount(y, z)))) ::: A deposit is required to rent an apartment in a managed building.\nCat(fluffy) ∧ Pet(fluffy) ∧ Owner(tom, fluffy) ::: Fluffy is Tom's cat.\nCat(x) → Pet(x) ::: Cats are pets.\nManaged(olivegarden) ∧ Building(olivegarden) ::: The Olive Garden is a managed building.\nRentAmount(olivegarden, 2000) ::: The monthly rent at the Olive Garden is $2000.\nRentApartment(tom, olivegarden) ↔ (MoveInWith(tom, fluffy) ∧ ¬MoreThan(deposit, 1500)) ::: Tom will rent an apartment in a managed building if and only if he is allowed to move in with Fluffy, and the security deposit is no more than $1500.\nMoreThan(2000, 1500) ::: 2000$ is more than $1500.\n",
                "First-Order-Logic Question": "Equal(deposit, 2000) ∨ MoreThan(deposit, 2000) ::: The security deposit at the Olive Garden is either $2000 or more."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∃x (Pet(x) ∧ AllowedIn(x, y)) ::: Pets are allowed in some managed buildings.\nAllowedIn(x,y)∧RequireDeposit(x)→Equal(x,z)∨MoreThan(x,z) ::: A deposit is required to rent an apartment in a managed building.\nCat(fluffy) ∧ Pet(fluffy) ∧ Owner(tom, fluffy) ::: Fluffy is Tom's cat.\nCat(x) → Pet(x) ::: Cats are pets.\nManaged(olivegarden) ∧ Building(olivegarden) ::: The Olive Garden is a managed building.\nRentAmount(olivegarden, 2000) ::: The monthly rent at the Olive Garden is $2000.\nRentApartment(tom, olivegarden) ↔ (MoveInWith(tom, fluffy) ∧ ¬MoreThan(deposit, 1500)) ::: Tom will rent an apartment in a managed building if and only if he is allowed to move in with Fluffy, and the security deposit is no more than $1500.\nMoreThan(2000, 1500) ::: 2000$ is more than $1500.\n",
                "First-Order-Logic Question": "Equal(deposit, 2000) ∨ MoreThan(deposit, 2000) ::: The security deposit at the Olive Garden is either $2000 or more."
            },
            "diff": [
                {
                    "raw": "∀x (RequireDeposit(x) → (Equal(x, RentAmount(y, z)) ∨ MoreThan(x, RentAmount(y, z)))) ::: A deposit is required to rent an apartment in a managed building.",
                    "gram": "AllowedIn(x,y)∧RequireDeposit(x)→Equal(x,z)∨MoreThan(x,z) ::: A deposit is required to rent an apartment in a managed building."
                }
            ],
            "answer": "A",
            "grammar_answer": "C"
        },
        {
            "id": 107,
            "raw_prog": {
                "First-Order-Logic Rules": "Costs(gre, 205) ::: It costs US $205 to take the GRE test.\n∀x ∀y (Prove(x, EconomicHardship(y)) → ProvidesAid(ETS, y)) ::: ETS provides financial aid to those GRE applicants who prove economic hardship.\n∀x (EconomicHardship(x) ↔ (TooLittleMoney(x) ∨ TooFewResources(x))) ::: Economic hardship refers to difficulty caused by having too little money or too few resources.\nSingleParent(tom) ::: Tom lives in a single-parent family.\nOutOfWork(dad, moreThanAYear) ::: His dad has been out of work for more than a year.\n",
                "First-Order-Logic Question": "¬∃x ∀y (Costs(gre, y) ∧ ProvidesAid(ETS, x)) ::: There is no financial aid available for the GRE test."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "Costs(gre, 205) ::: It costs US $205 to take the GRE test.\nAvailable(y)∧¬EconomicHardship(y)→ProvidesAid(y,x) ::: ETS provides financial aid to those GRE applicants who prove economic hardship.\n∀x (EconomicHardship(x) ↔ (TooLittleMoney(x) ∨ TooFewResources(x))) ::: Economic hardship refers to difficulty caused by having too little money or too few resources.\nSingleParent(tom) ::: Tom lives in a single-parent family.\nOutOfWork(dad, moreThanAYear) ::: His dad has been out of work for more than a year.\n",
                "First-Order-Logic Question": "¬∃x ∀y (Costs(gre, y) ∧ ProvidesAid(ETS, x)) ::: There is no financial aid available for the GRE test."
            },
            "diff": [
                {
                    "raw": "∀x ∀y (Prove(x, EconomicHardship(y)) → ProvidesAid(ETS, y)) ::: ETS provides financial aid to those GRE applicants who prove economic hardship.",
                    "gram": "Available(y)∧¬EconomicHardship(y)→ProvidesAid(y,x) ::: ETS provides financial aid to those GRE applicants who prove economic hardship."
                }
            ],
            "answer": "B",
            "grammar_answer": "C"
        },
        {
            "id": 114,
            "raw_prog": {
                "First-Order-Logic Rules": "MountainRange(picurismountains) ∨ MountainRange(picurismountains) ::: The Picuris Mountains are a mountain range in New Mexico or Texas.\nVisited(juandeonate, picurismountains) ::: Juan de Onate visited the Picuris Mountains.\nLocatedIn(hardingpegmatitemine, picurismountains) ∧ Donated(hardingpegmatitemine) ::: The Harding Pegmatite Mine, located in the Picuris Mountains, was donated.\n∀x (MountainRange(x) ∧ In(x, texas) → ¬∃y (Mine(y) ∧ Has(y, donated) ∧ LocatedIn(y, x))) ::: There are no mountain ranges in Texas that have mines which have been donated.\n",
                "First-Order-Logic Question": "NotLocatedIn(hardingpegmatitemine, newmexico) ::: The Harding Pegmatite Mine is not located in a mountain range in New Mexico."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "MountainRange(picurismountains) ∨ MountainRange(picurismountains) ::: The Picuris Mountains are a mountain range in New Mexico or Texas.\nVisited(juandeonate, picurismountains) ::: Juan de Onate visited the Picuris Mountains.\nLocatedIn(hardingpegmatitemine, picurismountains) ∧ Donated(hardingpegmatitemine) ::: The Harding Pegmatite Mine, located in the Picuris Mountains, was donated.\nIn(x,y)→¬(Mine(y)∧Has(y,x)) ::: There are no mountain ranges in Texas that have mines which have been donated.\n",
                "First-Order-Logic Question": "NotLocatedIn(hardingpegmatitemine, newmexico) ::: The Harding Pegmatite Mine is not located in a mountain range in New Mexico."
            },
            "diff": [
                {
                    "raw": "∀x (MountainRange(x) ∧ In(x, texas) → ¬∃y (Mine(y) ∧ Has(y, donated) ∧ LocatedIn(y, x))) ::: There are no mountain ranges in Texas that have mines which have been donated.",
                    "gram": "In(x,y)→¬(Mine(y)∧Has(y,x)) ::: There are no mountain ranges in Texas that have mines which have been donated."
                }
            ],
            "answer": "B",
            "grammar_answer": "C"
        }
    ],
    "gcd_llama-3-8b_4": [
        {
            "id": 41,
            "raw_prog": {
                "First-Order-Logic Rules": [
                    "∀x (ZahaHadid(x) → Timeless(x)) ::: All of Zaha Hadid's design styles are timeless.",
                    "∀x (MassProduct(x) → ¬Timeless(x)) ::: No mass product design is timeless.",
                    "∀x (ZahaHadid(x) ∨ KellyWearstler(x)) ::: Either Zaha Hadid's design style or Kelly Wearstler's design style.",
                    "∀x (KellyWearstler(x) → Evocative(x)) ::: All of Kelly Wearstler's design styles are evocative.",
                    "∀x (KellyWearstler(x) → Dreamy(x)) ::: All of Kelly Wearstler's design styles are dreamy.",
                    "∀x (Timeless(Max(x)) → (MassProduct(Max(x)) ∧ Evocative(Max(x)))) ::: If a design by Max is timeless, then a design by Max is a mass product design and evocative."
                ],
                "First-Order-Logic Question": [
                    "Evocative(Max(x)) ∨ Dreamy(Max(x)) ::: A design by Max is either evocative or dreamy."
                ]
            },
            "gram_prog": {
                "First-Order-Logic Rules": [
                    "∀x (ZahaHadid(x) → Timeless(x)) ::: All of Zaha Hadid's design styles are timeless.",
                    "∀x (MassProduct(x) → ¬Timeless(x)) ::: No mass product design is timeless.",
                    "∀x (ZahaHadid(x) ∨ KellyWearstler(x)) ::: Either Zaha Hadid's design style or Kelly Wearstler's design style.",
                    "∀x (KellyWearstler(x) → Evocative(x)) ::: All of Kelly Wearstler's design styles are evocative.",
                    "∀x (KellyWearstler(x) → Dreamy(x)) ::: All of Kelly Wearstler's design styles are dreamy.",
                    "DesignBy(x,y)∧Timeless(y)→(MassProduct(y)∧Evocative(y)) ::: If a design by Max is timeless, then a design by Max is a mass product design and evocative."
                ],
                "First-Order-Logic Question": [
                    "DesignBy(x,z)∧(Evocative(z)∨Dreamy(z)) ::: A design by Max is either evocative or dreamy."
                ]
            },
            "diff": [
                {
                    "raw": "∀x (Timeless(Max(x)) → (MassProduct(Max(x)) ∧ Evocative(Max(x)))) ::: If a design by Max is timeless, then a design by Max is a mass product design and evocative.",
                    "gram": "DesignBy(x,y)∧Timeless(y)→(MassProduct(y)∧Evocative(y)) ::: If a design by Max is timeless, then a design by Max is a mass product design and evocative."
                }
            ],
            "answer": "B",
            "grammar_answer": "C"
        },
        {
            "id": 52,
            "raw_prog": {
                "First-Order-Logic Rules": "∀x (RomanceLanguage(x) → IndoEuropeanLanguage(x)) ::: All Romance languages are Indo-European languages.\nLanguageFamily(romanceLanguages) ::: The Romance languages are a language family.\n∀x ∀y (LanguageFamily(f) ∧ RomanceLanguage(x) ∧ RomanceLanguage(y) → Related(x, y)) ::: All languages within a language family are related to each other.\nRomanceLanguage(french) ∧ RomanceLanguage(spanish) ::: French and Spanish are both Romance languages.\nRelated(german, spanish) ::: German is related to Spanish.\n∀x (Basque(x) → ¬∃y (Related(x, y))) ::: Basque is not related to any other language.\n",
                "First-Order-Logic Question": "RomanceLanguage(basque) ::: Basque is a Romance language."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∀x (RomanceLanguage(x) → IndoEuropeanLanguage(x)) ::: All Romance languages are Indo-European languages.\nLanguageFamily(romanceLanguages) ::: The Romance languages are a language family.\n∀x ∀y (LanguageFamily(f) ∧ RomanceLanguage(x) ∧ RomanceLanguage(y) → Related(x, y)) ::: All languages within a language family are related to each other.\nRomanceLanguage(french) ∧ RomanceLanguage(spanish) ::: French and Spanish are both Romance languages.\nRelated(german, spanish) ::: German is related to Spanish.\nIndoEuropeanLanguage(x)∧¬Related(x,y) ::: Basque is not related to any other language.\n",
                "First-Order-Logic Question": "RomanceLanguage(basque) ::: Basque is a Romance language."
            },
            "diff": [
                {
                    "raw": "∀x (Basque(x) → ¬∃y (Related(x, y))) ::: Basque is not related to any other language.",
                    "gram": "IndoEuropeanLanguage(x)∧¬Related(x,y) ::: Basque is not related to any other language."
                }
            ],
            "answer": "B",
            "grammar_answer": "A"
        },
        {
            "id": 70,
            "raw_prog": {
                "First-Order-Logic Rules": [
                    "British(badults) ∧ Sitcom(badults) ∧ ∀x (MemberOf(x, pappys) → Star(x, badults)) ::: Badults is a British Sitcom series, starring members of Pappy's.",
                    "Pilot(badults, 2013) ∧ Network(badults, bbcthree) ::: Badults piloted in July 2013 on BBC Three.",
                    "WorkingTitle(badults, thesecretdudesociety) ::: The Working title 'The Secret Dude Society' was used for Badults.",
                    "ScriptEditor(andrewcollins, badults) ::: Andrew Collins was the script editor for Badults."
                ],
                "First-Order-Logic Question": [
                    "∀x (MemberOf(x, pappys) → ¬∃y (Star(x, y) ∧ (Network(y, bbctwo) ∨ Network(y, bbcthree)))) ::: No members of Pappy's have starred for a show piloting on BBC Two or BBC Three."
                ]
            },
            "gram_prog": {
                "First-Order-Logic Rules": [
                    "British(badults) ∧ Sitcom(badults) ∧ ∀x (MemberOf(x, pappys) → Star(x, badults)) ::: Badults is a British Sitcom series, starring members of Pappy's.",
                    "Pilot(badults, 2013) ∧ Network(badults, bbcthree) ::: Badults piloted in July 2013 on BBC Three.",
                    "WorkingTitle(badults, thesecretdudesociety) ::: The Working title 'The Secret Dude Society' was used for Badults.",
                    "ScriptEditor(andrewcollins, badults) ::: Andrew Collins was the script editor for Badults."
                ],
                "First-Order-Logic Question": [
                    "Pilot(x,y)→¬(Star(x,y)∧Network(y,z)) ::: No members of Pappy's have starred for a show piloting on BBC Two or BBC Three."
                ]
            },
            "diff": [],
            "answer": "B",
            "grammar_answer": "C"
        },
        {
            "id": 93,
            "raw_prog": {
                "First-Order-Logic Rules": [
                    "∃x (Pet(x) ∧ ManagedBuilding(y) ∧ AllowedIn(x, y)) ::: Pets are allowed in some managed buildings.",
                    "∀x (ManagedBuilding(x) → DepositRequired(x)) ::: A deposit is required to rent an apartment in a managed building.",
                    "∀x ∀y (SecurityDeposit(x, y) → EqualOrMore(y, MonthlyRent(x, 1))) ::: The security deposit can be either equal to one month's rent or more.",
                    "Cat(fluffy) ∧ Owner(tom, fluffy) ::: Fluffy is Tom's cat.",
                    "∀x (Cat(x) → Pet(x)) ::: Cats are pets.",
                    "ManagedBuilding(olivegarden) ::: The Olive Garden is a managed building.",
                    "MonthlyRent(olivegarden, 2000) ::: The monthly rent at the Olive Garden is $2000.",
                    "∀x ∀y (Owner(x, y) ∧ Pet(y) ∧ ManagedBuilding(z) ∧ AllowedIn(y, z) ∧ SecurityDeposit(z, d) ∧ d ≤ 1500 ↔ Rent(x, z)) ::: Tom will rent an apartment in a managed building if and only if he is allowed to move in with Fluffy, and the security deposit is no more than $1500.",
                    "EqualOrMore(2000, 1500) ::: 2000$ is more than $1500."
                ],
                "First-Order-Logic Question": [
                    "Rent(tom, olivegarden) ::: Tom will rent an apartment in The Olive Garden."
                ]
            },
            "gram_prog": {
                "First-Order-Logic Rules": [
                    "∃x (Pet(x) ∧ ManagedBuilding(y) ∧ AllowedIn(x, y)) ::: Pets are allowed in some managed buildings.",
                    "∀x (ManagedBuilding(x) → DepositRequired(x)) ::: A deposit is required to rent an apartment in a managed building.",
                    "AllowedIn(x,y) ::: The security deposit can be either equal to one month's rent or more.",
                    "Cat(fluffy) ∧ Owner(tom, fluffy) ::: Fluffy is Tom's cat.",
                    "∀x (Cat(x) → Pet(x)) ::: Cats are pets.",
                    "ManagedBuilding(olivegarden) ::: The Olive Garden is a managed building.",
                    "MonthlyRent(olivegarden, 2000) ::: The monthly rent at the Olive Garden is $2000.",
                    "AllowedIn(y,z)∧ManagedBuilding(z)∧SecurityDeposit(z,y)∧(¬Pet(y)∨EqualOrMore(y,z)) ::: Tom will rent an apartment in a managed building if and only if he is allowed to move in with Fluffy, and the security deposit is no more than $1500.",
                    "EqualOrMore(2000, 1500) ::: 2000$ is more than $1500."
                ],
                "First-Order-Logic Question": [
                    "Rent(tom, olivegarden) ::: Tom will rent an apartment in The Olive Garden."
                ]
            },
            "diff": [
                {
                    "raw": "∀x ∀y (SecurityDeposit(x, y) → EqualOrMore(y, MonthlyRent(x, 1))) ::: The security deposit can be either equal to one month's rent or more.",
                    "gram": "AllowedIn(x,y) ::: The security deposit can be either equal to one month's rent or more."
                },
                {
                    "raw": "∀x ∀y (Owner(x, y) ∧ Pet(y) ∧ ManagedBuilding(z) ∧ AllowedIn(y, z) ∧ SecurityDeposit(z, d) ∧ d ≤ 1500 ↔ Rent(x, z)) ::: Tom will rent an apartment in a managed building if and only if he is allowed to move in with Fluffy, and the security deposit is no more than $1500.",
                    "gram": "AllowedIn(y,z)∧ManagedBuilding(z)∧SecurityDeposit(z,y)∧(¬Pet(y)∨EqualOrMore(y,z)) ::: Tom will rent an apartment in a managed building if and only if he is allowed to move in with Fluffy, and the security deposit is no more than $1500."
                }
            ],
            "answer": "B",
            "grammar_answer": "C"
        },
        {
            "id": 94,
            "raw_prog": {
                "First-Order-Logic Rules": [
                    "∃x (ManagedBuilding(x) ∧ Pet(y) ∧ AllowedIn(y, x)) ::: Pets are allowed in some managed buildings.",
                    "∀x (ManagedBuilding(x) → DepositRequired(x)) ::: A deposit is required to rent an apartment in a managed building.",
                    "∀x ∀y (SecurityDeposit(x, y) → EqualOrMore(y, MonthlyRent(x, 1))) ::: The security deposit can be either equal to one month's rent or more.",
                    "Cat(fluffy) ∧ Owner(tom, fluffy) ::: Fluffy is Tom's cat.",
                    "∀x (Cat(x) → Pet(x)) ::: Cats are pets.",
                    "ManagedBuilding(olivegarden) ::: The Olive Garden is a managed building.",
                    "MonthlyRent(olivegarden, 2000) ::: The monthly rent at the Olive Garden is $2000.",
                    "∀x ∀y ∀z (Owner(y, z) ∧ ManagedBuilding(x) ∧ AllowedIn(z, x) ∧ SecurityDeposit(x, w) ∧ w ≤ 1500 ↔ MoveInWith(y, z, x)) ::: Tom will rent an apartment in a managed building if and only if he is allowed to move in with Fluffy, and the security deposit is no more than $1500.",
                    "EqualOrMore(2000, 1500) ::: 2000$ is more than $1500."
                ],
                "First-Order-Logic Question": [
                    "MoveInWith(tom, fluffy, olivegarden) ::: Tom is allowed to move in an apartment in The Olive Garden with Fluffy."
                ]
            },
            "gram_prog": {
                "First-Order-Logic Rules": [
                    "∃x (ManagedBuilding(x) ∧ Pet(y) ∧ AllowedIn(y, x)) ::: Pets are allowed in some managed buildings.",
                    "∀x (ManagedBuilding(x) → DepositRequired(x)) ::: A deposit is required to rent an apartment in a managed building.",
                    "AllowedIn(x,y) ::: The security deposit can be either equal to one month's rent or more.",
                    "Cat(fluffy) ∧ Owner(tom, fluffy) ::: Fluffy is Tom's cat.",
                    "∀x (Cat(x) → Pet(x)) ::: Cats are pets.",
                    "ManagedBuilding(olivegarden) ::: The Olive Garden is a managed building.",
                    "MonthlyRent(olivegarden, 2000) ::: The monthly rent at the Olive Garden is $2000.",
                    "AllowedIn(z,x)∧SecurityDeposit(x,y)∧(¬(Pet(z))) ::: Tom will rent an apartment in a managed building if and only if he is allowed to move in with Fluffy, and the security deposit is no more than $1500.",
                    "EqualOrMore(2000, 1500) ::: 2000$ is more than $1500."
                ],
                "First-Order-Logic Question": [
                    "MoveInWith(tom, fluffy, olivegarden) ::: Tom is allowed to move in an apartment in The Olive Garden with Fluffy."
                ]
            },
            "diff": [
                {
                    "raw": "∀x ∀y (SecurityDeposit(x, y) → EqualOrMore(y, MonthlyRent(x, 1))) ::: The security deposit can be either equal to one month's rent or more.",
                    "gram": "AllowedIn(x,y) ::: The security deposit can be either equal to one month's rent or more."
                },
                {
                    "raw": "∀x ∀y ∀z (Owner(y, z) ∧ ManagedBuilding(x) ∧ AllowedIn(z, x) ∧ SecurityDeposit(x, w) ∧ w ≤ 1500 ↔ MoveInWith(y, z, x)) ::: Tom will rent an apartment in a managed building if and only if he is allowed to move in with Fluffy, and the security deposit is no more than $1500.",
                    "gram": "AllowedIn(z,x)∧SecurityDeposit(x,y)∧(¬(Pet(z))) ::: Tom will rent an apartment in a managed building if and only if he is allowed to move in with Fluffy, and the security deposit is no more than $1500."
                }
            ],
            "answer": "C",
            "grammar_answer": "A"
        },
        {
            "id": 95,
            "raw_prog": {
                "First-Order-Logic Rules": [
                    "∃x (ManagedBuilding(x) ∧ Pet(y) ∧ AllowedIn(y, x)) ::: Pets are allowed in some managed buildings.",
                    "∀x (ManagedBuilding(x) → DepositRequired(x)) ::: A deposit is required to rent an apartment in a managed building.",
                    "∀x ∀y (SecurityDeposit(x, y) → (EqualOrMore(y, MonthlyRent(x, 1)) ∨ EqualOrMore(y, MonthlyRent(x, 2)))) ::: The security deposit can be either equal to one month's rent or more.",
                    "Cat(fluffy) ∧ Owner(tom, fluffy) ::: Fluffy is Tom's cat.",
                    "∀x (Cat(x) → Pet(x)) ::: Cats are pets.",
                    "ManagedBuilding(olivegarden) ::: The Olive Garden is a managed building.",
                    "MonthlyRent(olivegarden, 2000) ::: The monthly rent at the Olive Garden is $2000.",
                    "∀x ∀y (Owner(tom, fluffy) ∧ ManagedBuilding(x) ∧ (AllowedIn(fluffy, x) ∧ SecurityDeposit(x, y) ∧ EqualOrMore(1500, y)) ↔ Rent(tom, x)) ::: Tom will rent an apartment in a managed building if and only if he is allowed to move in with Fluffy, and the security deposit is no more than $1500.",
                    "EqualOrMore(2000, 1500) ::: 2000$ is more than $1500."
                ],
                "First-Order-Logic Question": [
                    "SecurityDeposit(olivegarden, 2000) ∨ ∃y (SecurityDeposit(olivegarden, y) ∧ EqualOrMore(y, 2000)) ::: The security deposit at the Olive Garden is either $2000 or more."
                ]
            },
            "gram_prog": {
                "First-Order-Logic Rules": [
                    "∃x (ManagedBuilding(x) ∧ Pet(y) ∧ AllowedIn(y, x)) ::: Pets are allowed in some managed buildings.",
                    "∀x (ManagedBuilding(x) → DepositRequired(x)) ::: A deposit is required to rent an apartment in a managed building.",
                    "AllowedIn(x,y) ::: The security deposit can be either equal to one month's rent or more.",
                    "Cat(fluffy) ∧ Owner(tom, fluffy) ::: Fluffy is Tom's cat.",
                    "∀x (Cat(x) → Pet(x)) ::: Cats are pets.",
                    "ManagedBuilding(olivegarden) ::: The Olive Garden is a managed building.",
                    "MonthlyRent(olivegarden, 2000) ::: The monthly rent at the Olive Garden is $2000.",
                    "∀x ∀y (Owner(tom, fluffy) ∧ ManagedBuilding(x) ∧ (AllowedIn(fluffy, x) ∧ SecurityDeposit(x, y) ∧ EqualOrMore(1500, y)) ↔ Rent(tom, x)) ::: Tom will rent an apartment in a managed building if and only if he is allowed to move in with Fluffy, and the security deposit is no more than $1500.",
                    "EqualOrMore(2000, 1500) ::: 2000$ is more than $1500."
                ],
                "First-Order-Logic Question": [
                    "SecurityDeposit(olivegarden, 2000) ∨ ∃y (SecurityDeposit(olivegarden, y) ∧ EqualOrMore(y, 2000)) ::: The security deposit at the Olive Garden is either $2000 or more."
                ]
            },
            "diff": [
                {
                    "raw": "∀x ∀y (SecurityDeposit(x, y) → (EqualOrMore(y, MonthlyRent(x, 1)) ∨ EqualOrMore(y, MonthlyRent(x, 2)))) ::: The security deposit can be either equal to one month's rent or more.",
                    "gram": "AllowedIn(x,y) ::: The security deposit can be either equal to one month's rent or more."
                }
            ],
            "answer": "A",
            "grammar_answer": "C"
        },
        {
            "id": 124,
            "raw_prog": {
                "First-Order-Logic Rules": "∀x (TransportMultiplePassengers(x) → ¬Empty(x)) ::: If something can transport multiple passengers, then they are not empty.\n∀x (Airline(x) → TransportMultiplePassengers(x)) ::: All airlines can transport multiple passengers.\n∀x (Plane(x) → Empty(x)) ::: All planes are empty.\n∀x (Boeing707(x) → Plane(x)) ::: All Boeing 707s are planes.\n¬Airline(greyhound) → ¬∃y (Greyhound(y) ∧ Plane(y)) ::: If Greyhound is not an airline, then there are no Greyhound planes.\n",
                "First-Order-Logic Question": "¬Greyhound(boeing707) ::: A Greyhound is not a Boeing 707."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∀x (TransportMultiplePassengers(x) → ¬Empty(x)) ::: If something can transport multiple passengers, then they are not empty.\n∀x (Airline(x) → TransportMultiplePassengers(x)) ::: All airlines can transport multiple passengers.\n∀x (Plane(x) → Empty(x)) ::: All planes are empty.\nPlane(boeing707) ::: Boeing 707 is a plane.\n∀x (Airline(x) → ¬(Greyhound(x) ∧ Plane(x))) ::: If Greyhound is not an airline, then there are no Greyhound planes.",
                "First-Order-Logic Question": "¬Greyhound(boeing707) ::: A Greyhound is not a Boeing 707."
            },
            "diff": [],
            "answer": "A",
            "grammar_answer": "C"
        },
        {
            "id": 143,
            "raw_prog": {
                "First-Order-Logic Rules": "∀x (BreedingBack(x) → ArtificiallySelected(x)) ::: Breeding back is a form of artificial selection by the deliberate selective breeding of domestic animals.\nBredBack(heck_cattle, aurochs) ∧ Resemble(heck_cattle, aurochs) ::: Heck cattle were bred-back in the 1920s to resemble the aurochs.\nAnimal(heck_cattle) ::: Heck cattle are animals.\nAnimal(aurochs) ::: Aurochs are animals.\n∃x ∃y (Animal(x) ∧ Animal(y) ∧ BredBack(x, y) ∧ Resemble(x, y) ∧ Extinct(y)) ::: Some animals to be bred-back resemble animals that are extinct.\n",
                "First-Order-Logic Question": "∃x (Animal(x) ∧ ArtificiallySelected(x) ∧ x = heck_cattle) ::: Some Heck cattle are artificially selected."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∀x (BreedingBack(x) → ArtificiallySelected(x)) ::: Breeding back is a form of artificial selection by the deliberate selective breeding of domestic animals.\nBredBack(heck_cattle, aurochs) ∧ Resemble(heck_cattle, aurochs) ::: Heck cattle were bred-back in the 1920s to resemble the aurochs.\nAnimal(heck_cattle) ::: Heck cattle are animals.\nAnimal(aurochs) ::: Aurochs are animals.\n∃x ∃y (Animal(x) ∧ Animal(y) ∧ BredBack(x, y) ∧ Resemble(x, y) ∧ Extinct(y)) ::: Some animals to be bred-back resemble animals that are extinct.\n",
                "First-Order-Logic Question": "Animal(x)∧ArtificiallySelected(x)∧Resemble(x,x) ::: Some Heck cattle are artificially selected."
            },
            "diff": [],
            "answer": "A",
            "grammar_answer": "C"
        },
        {
            "id": 10,
            "raw_prog": {
                "First-Order-Logic Rules": "∀x (WildTurkey(x) → (EasternWildTurkey(x) ∨ OsceolaWildTurkey(x) ∨ GouldsWildTurkey(x) ∨ MerriamsWildTurkey(x) ∨ RioGrandeWildTurkey(x) ∨ OcellatedWildTurkey(x))) ::: There are six types of wild turkeys: Eastern wild turkey, Osceola wild turkey, Gould’s wild turkey, Merriam’s wild turkey, Rio Grande wild turkey, and Ocellated wild turkey.\nNot(tom, EasternWildTurkey(tom)) ::: Tom is not an Eastern wild turkey.\nNot(tom, OsceolaWildTurkey(tom)) ::: Tom is not an Osceola wild turkey.\nNot(tom, GouldsWildTurkey(tom)) ∧ Not(tom, MerriamsWildTurkey(tom)) ∧ Not(tom, RioGrandeWildTurkey(tom)) ::: Tom is also not a Gould's wild turkey, or a Merriam's wild turkey, or a Rio Grande wild turkey.\nWildTurkey(tom) ::: Tom is a wild turkey.\n",
                "First-Order-Logic Question": "EasternWildTurkey(tom) ::: Tom is an Eastern wild turkey."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∀x (WildTurkey(x) → (EasternWildTurkey(x) ∨ OsceolaWildTurkey(x) ∨ GouldsWildTurkey(x) ∨ MerriamsWildTurkey(x) ∨ RioGrandeWildTurkey(x) ∨ OcellatedWildTurkey(x))) ::: There are six types of wild turkeys: Eastern wild turkey, Osceola wild turkey, Gould’s wild turkey, Merriam’s wild turkey, Rio Grande wild turkey, and Ocellated wild turkey.\nNot(y,y) ::: Tom is not an Eastern wild turkey.\nGouldsWildTurkey(y) ::: Tom is not an Osceola wild turkey.\nNot(y,y) ::: Tom is also not a Gould's wild turkey, or a Merriam's wild turkey, or a Rio Grande wild turkey.\nWildTurkey(tom) ::: Tom is a wild turkey.\n",
                "First-Order-Logic Question": "EasternWildTurkey(tom) ::: Tom is an Eastern wild turkey."
            },
            "diff": [
                {
                    "raw": "Not(tom, EasternWildTurkey(tom)) ::: Tom is not an Eastern wild turkey.",
                    "gram": "Not(y,y) ::: Tom is not an Eastern wild turkey."
                },
                {
                    "raw": "Not(tom, OsceolaWildTurkey(tom)) ::: Tom is not an Osceola wild turkey.",
                    "gram": "GouldsWildTurkey(y) ::: Tom is not an Osceola wild turkey."
                },
                {
                    "raw": "Not(tom, GouldsWildTurkey(tom)) ∧ Not(tom, MerriamsWildTurkey(tom)) ∧ Not(tom, RioGrandeWildTurkey(tom)) ::: Tom is also not a Gould's wild turkey, or a Merriam's wild turkey, or a Rio Grande wild turkey.",
                    "gram": "Not(y,y) ::: Tom is also not a Gould's wild turkey, or a Merriam's wild turkey, or a Rio Grande wild turkey."
                }
            ],
            "answer": "B",
            "grammar_answer": "C"
        },
        {
            "id": 40,
            "raw_prog": {
                "First-Order-Logic Rules": [
                    "∀x (ZahaHadid(x) → Timeless(x)) ::: All of Zaha Hadid's design styles are timeless.",
                    "∀x (MassProduct(x) → ¬Timeless(x)) ::: No mass product design is timeless.",
                    "∀x (ZahaHadid(x) ∨ KellyWearstler(x)) ::: Either Zaha Hadid's design style or Kelly Wearstler's design style.",
                    "∀x (KellyWearstler(x) → Evocative(x)) ::: All of Kelly Wearstler's design styles are evocative.",
                    "∀x (KellyWearstler(x) → Dreamy(x)) ::: All of Kelly Wearstler's design styles are dreamy.",
                    "∀x (Timeless(Max(x)) → (MassProduct(Max(x)) ∧ Evocative(Max(x)))) ::: If a design by Max is timeless, then a design by Max is a mass product design and evocative."
                ],
                "First-Order-Logic Question": [
                    "Evocative(Max(x)) ∧ Dreamy(Max(x)) ::: A design by Max is evocative and dreamy."
                ]
            },
            "gram_prog": {
                "First-Order-Logic Rules": [
                    "∀x (ZahaHadid(x) → Timeless(x)) ::: All of Zaha Hadid's design styles are timeless.",
                    "∀x (MassProduct(x) → ¬Timeless(x)) ::: No mass product design is timeless.",
                    "∀x (ZahaHadid(x) ∨ KellyWearstler(x)) ::: Either Zaha Hadid's design style or Kelly Wearstler's design style.",
                    "∀x (KellyWearstler(x) → Evocative(x)) ::: All of Kelly Wearstler's design styles are evocative.",
                    "∀x (KellyWearstler(x) → Dreamy(x)) ::: All of Kelly Wearstler's design styles are dreamy.",
                    "DesignBy(x,y)∧Timeless(y)→(MassProduct(y)∧Evocative(y)) ::: If a design by Max is timeless, then a design by Max is a mass product design and evocative."
                ],
                "First-Order-Logic Question": [
                    "DesignBy(x,z)∧Evocative(z)∧Dreamy(z) ::: A design by Max is evocative and dreamy."
                ]
            },
            "diff": [
                {
                    "raw": "∀x (Timeless(Max(x)) → (MassProduct(Max(x)) ∧ Evocative(Max(x)))) ::: If a design by Max is timeless, then a design by Max is a mass product design and evocative.",
                    "gram": "DesignBy(x,y)∧Timeless(y)→(MassProduct(y)∧Evocative(y)) ::: If a design by Max is timeless, then a design by Max is a mass product design and evocative."
                }
            ],
            "answer": "A",
            "grammar_answer": "C"
        },
        {
            "id": 47,
            "raw_prog": {
                "First-Order-Logic Rules": [
                    "Season(spring) ∧ Season(summer) ∧ Season(fall) ∧ Season(winter) ::: There are four seasons in a year: Spring, Summer, Fall, and Winter.",
                    "∀x (Student(x) ∧ WantsLongVacation(x) → LovesMost(x, summer)) ::: All students who want to have a long vacation love summer the most.",
                    "FavoriteSeason(emma, summer) ::: Emma's favorite season is summer.",
                    "∀x (FavoriteSeason(mia, x) → x ≠ summer) ::: Mia's favorite season is not the same as Emma's.",
                    "WantsLongVacation(james) ::: James wants to have a long vacation."
                ],
                "First-Order-Logic Question": "FavoriteSeason(james, fall) ::: James's favorite season is fall."
            },
            "gram_prog": {
                "First-Order-Logic Rules": [
                    "Season(spring) ∧ Season(summer) ∧ Season(fall) ∧ Season(winter) ::: There are four seasons in a year: Spring, Summer, Fall, and Winter.",
                    "∀x (Student(x) ∧ WantsLongVacation(x) → LovesMost(x, summer)) ::: All students who want to have a long vacation love summer the most.",
                    "FavoriteSeason(emma, summer) ::: Emma's favorite season is summer.",
                    "DifferentFavoriteSeason(y) ∧ ¬(FavoriteSeason(y, summer)) ::: Mia's favorite season is not the same as Emma's.",
                    "WantsLongVacation(james) ::: James wants to have a long vacation."
                ],
                "First-Order-Logic Question": "FavoriteSeason(james, fall) ::: James's favorite season is fall."
            },
            "diff": [
                {
                    "raw": "∀x (FavoriteSeason(mia, x) → x ≠ summer) ::: Mia's favorite season is not the same as Emma's.",
                    "gram": "DifferentFavoriteSeason(y) ∧ ¬(FavoriteSeason(y, summer)) ::: Mia's favorite season is not the same as Emma's."
                }
            ],
            "answer": "C",
            "grammar_answer": "A"
        },
        {
            "id": 53,
            "raw_prog": {
                "First-Order-Logic Rules": "∀x (RomanceLanguage(x) → IndoEuropeanLanguage(x)) ::: All Romance languages are Indo-European languages.\nLanguageFamily(romanceLanguages) ::: The Romance languages are a language family.\n∀x ∀y (LanguageFamily(f) ∧ RomanceLanguage(x) ∧ RomanceLanguage(y) → Related(x, y)) ::: All languages within a language family are related to each other.\nRomanceLanguage(french) ∧ RomanceLanguage(spanish) ::: French and Spanish are both Romance languages.\nRelated(german, spanish) ::: German is related to Spanish.\n∀x (Basque(x) → ¬∃y (Related(x, y))) ::: Basque is not related to any other language.\n",
                "First-Order-Logic Question": "RomanceLanguage(german) ::: German is a Romance language."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "∀x (RomanceLanguage(x) → IndoEuropeanLanguage(x)) ::: All Romance languages are Indo-European languages.\nLanguageFamily(romanceLanguages) ::: The Romance languages are a language family.\n∀x ∀y (LanguageFamily(f) ∧ RomanceLanguage(x) ∧ RomanceLanguage(y) → Related(x, y)) ::: All languages within a language family are related to each other.\nRomanceLanguage(french) ∧ RomanceLanguage(spanish) ::: French and Spanish are both Romance languages.\nRelated(german, spanish) ::: German is related to Spanish.\nIndoEuropeanLanguage(x)∧¬Related(x,y) ::: Basque is not related to any other language.\n",
                "First-Order-Logic Question": "RomanceLanguage(german) ::: German is a Romance language."
            },
            "diff": [
                {
                    "raw": "∀x (Basque(x) → ¬∃y (Related(x, y))) ::: Basque is not related to any other language.",
                    "gram": "IndoEuropeanLanguage(x)∧¬Related(x,y) ::: Basque is not related to any other language."
                }
            ],
            "answer": "C",
            "grammar_answer": "A"
        },
        {
            "id": 105,
            "raw_prog": {
                "First-Order-Logic Rules": "Cost(gre, 205) ::: It costs US $205 to take the GRE test.\n∀x (Applicant(x) ∧ Prove(x, EconomicHardship(x)) → Provide(ets, FinancialAid, x)) ::: ETS provides financial aid to those GRE applicants who prove economic hardship.\n∀x (EconomicHardship(x) ↔ (Difficulty(x) ∧ (¬Money(x) ∨ ¬Resources(x)))) ::: Economic hardship refers to difficulty caused by having too little money or too few resources.\nLive(tom, singleparentfamily) ::: Tom lives in a single-parent family.\nOutOfWork(tom_dad) ∧ Year(1) ::: His dad has been out of work for more than a year.\n",
                "First-Order-Logic Question": "Apply(tom, FinancialAid) ::: Tom can apply for financial aid from ETS to take the GRE test."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "Cost(gre, 205) ::: It costs US $205 to take the GRE test.\nApplicant(x)∧Prove(x,y)→Provide(y,x) ::: ETS provides financial aid to those GRE applicants who prove economic hardship.\n∀x (EconomicHardship(x) ↔ (Difficulty(x) ∧ (¬Money(x) ∨ ¬Resources(x)))) ::: Economic hardship refers to difficulty caused by having too little money or too few resources.\nLive(tom, singleparentfamily) ::: Tom lives in a single-parent family.\nOutOfWork(tom_dad) ∧ Year(1) ::: His dad has been out of work for more than a year.\n",
                "First-Order-Logic Question": "Apply(tom, FinancialAid) ::: Tom can apply for financial aid from ETS to take the GRE test."
            },
            "diff": [
                {
                    "raw": "∀x (Applicant(x) ∧ Prove(x, EconomicHardship(x)) → Provide(ets, FinancialAid, x)) ::: ETS provides financial aid to those GRE applicants who prove economic hardship.",
                    "gram": "Applicant(x)∧Prove(x,y)→Provide(y,x) ::: ETS provides financial aid to those GRE applicants who prove economic hardship."
                }
            ],
            "answer": "A",
            "grammar_answer": "C"
        },
        {
            "id": 114,
            "raw_prog": {
                "First-Order-Logic Rules": [
                    "MountainRange(picurismountains) ∧ (In(picurismountains, newmexico) ⊕ In(picurismountains, texas)) ::: The Picuris Mountains are a mountain range in New Mexico or Texas.",
                    "Visit(juandeonate, picurismountains) ::: Juan de Onate visited the Picuris Mountains.",
                    "Mine(hardingpegmatitemine) ∧ In(hardingpegmatitemine, picurismountains) ∧ Donate(hardingpegmatitemine) ::: The Harding Pegmatite Mine, located in the Picuris Mountains, was donated.",
                    "∀x (MountainRange(x) ∧ In(x, texas) → ¬∃y (Mine(y) ∧ In(y, x) ∧ Donate(y))) ::: There are no mountain ranges in Texas that have mines which have been donated."
                ],
                "First-Order-Logic Question": [
                    "¬In(hardingpegmatitemine, newmexico) ::: The Harding Pegmatite Mine is not located in a mountain range in New Mexico."
                ]
            },
            "gram_prog": {
                "First-Order-Logic Rules": [
                    "MountainRange(picurismountains) ∧ (In(picurismountains, newmexico) ⊕ In(picurismountains, texas)) ::: The Picuris Mountains are a mountain range in New Mexico or Texas.",
                    "Visit(juandeonate, picurismountains) ::: Juan de Onate visited the Picuris Mountains.",
                    "Mine(hardingpegmatitemine) ∧ In(hardingpegmatitemine, picurismountains) ∧ Donate(hardingpegmatitemine) ::: The Harding Pegmatite Mine, located in the Picuris Mountains, was donated.",
                    "In(x,y)→¬(Mine(y)∧In(y,x)) ::: There are no mountain ranges in Texas that have mines which have been donated."
                ],
                "First-Order-Logic Question": [
                    "¬In(hardingpegmatitemine, newmexico) ::: The Harding Pegmatite Mine is not located in a mountain range in New Mexico."
                ]
            },
            "diff": [
                {
                    "raw": "∀x (MountainRange(x) ∧ In(x, texas) → ¬∃y (Mine(y) ∧ In(y, x) ∧ Donate(y))) ::: There are no mountain ranges in Texas that have mines which have been donated.",
                    "gram": "In(x,y)→¬(Mine(y)∧In(y,x)) ::: There are no mountain ranges in Texas that have mines which have been donated."
                }
            ],
            "answer": "B",
            "grammar_answer": "C"
        },
        {
            "id": 38,
            "raw_prog": {
                "First-Order-Logic Rules": [
                    "MusicPiece(symphonyNo9) ::: Symphony No. 9 is a music piece.",
                    "∀x (Composer(x) → ∃y (Write(x, y) ∧ MusicPiece(y))) ::: Composers write music pieces.",
                    "Write(beethoven, symphonyNo9) ∧ Composer(beethoven) ::: Beethoven wrote Symphony No. 9.",
                    "Premiere(viennaMusicSociety, symphonyNo9) ::: Vienna Music Society premiered Symphony No. 9.",
                    "Orchestra(viennaMusicSociety) ::: Vienna Music Society is an orchestra.",
                    "Lead(beethoven, viennaMusicSociety) ::: Beethoven leads the Vienna Music Society.",
                    "∀x (Orchestra(x) → ∃y (Lead(y, x) ∧ Conductor(y))) ::: Orchestras are led by conductors."
                ],
                "First-Order-Logic Question": "Not(Conductor(beethoven)) ::: Beethoven is not a conductor."
            },
            "gram_prog": {
                "First-Order-Logic Rules": [
                    "MusicPiece(symphonyNo9) ::: Symphony No. 9 is a music piece.",
                    "∀x (Composer(x) → ∃y (Write(x, y) ∧ MusicPiece(y))) ::: Composers write music pieces.",
                    "Write(beethoven, symphonyNo9) ∧ Composer(beethoven) ::: Beethoven wrote Symphony No. 9.",
                    "Premiere(viennaMusicSociety, symphonyNo9) ::: Vienna Music Society premiered Symphony No. 9.",
                    "Orchestra(viennaMusicSociety) ::: Vienna Music Society is an orchestra.",
                    "Lead(beethoven, viennaMusicSociety) ::: Beethoven leads the Vienna Music Society.",
                    "∀x (Orchestra(x) → ∃y (Lead(y, x) ∧ Conductor(y))) ::: Orchestras are led by conductors."
                ],
                "First-Order-Logic Question": "Not(y) ::: Beethoven is not a conductor."
            },
            "diff": [],
            "answer": "B",
            "grammar_answer": "C"
        },
        {
            "id": 67,
            "raw_prog": {
                "First-Order-Logic Rules": "University(yale_university) ∧ Private(yale_university) ∧ IvyLeague(yale_university) ∧ Research(yale_university) ::: Yale University is a private Ivy League research university.\nMoveTo(yale_university, new_haven, 1716) ::: Yale University moved to New Haven in 1716.\nEndowmentValue(yale_university, 42.3_billion) ::: Yale university's endowment was valued at $42.3 billion.\nOrganizedInto(yale_university, 27_constituent_colleges_and_schools) ∧ OrganizedInto(yale_university, residential_colleges) ∧ OrganizedInto(yale_university, yale_graduate_school_of_arts_and_sciences) ∧ OrganizedInto(yale_university, twelve_professional_schools) ::: Yale University has been organized into 27 constituent colleges and schools: the residential colleges, the Yale Graduate School of Arts and Sciences, and twelve professional schools.\nResidentialCollege(benjamin_franklin_college) ∧ ResidentialCollege(berkeley_college) ∧ ResidentialCollege(branford_college) ∧ ResidentialCollege(davenport_college) ∧ ResidentialCollege(ezra_stiles_college) ∧ ResidentialCollege(grace_hopper_college) ∧ ResidentialCollege(jonathan_edwards_college) ∧ ResidentialCollege(morse_college) ∧ ResidentialCollege(pauli_murray_college) ∧ ResidentialCollege(pierson_college) ∧ ResidentialCollege(saybrook_college) ∧ ResidentialCollege(silliman_college) ∧ ResidentialCollege(timothy_dwight_college) ∧ ResidentialCollege(trumbull_college) ::: A list of residential colleges at Yale: Benjamin Franklin College, Berkeley College, Branford College, Davenport College, Ezra Stiles College, Grace Hopper College, Jonathan Edwards College, Morse College, Pauli Murray College, Pierson College, Saybrook College, Silliman College, Timothy Dwight College, and Trumbull College.\n",
                "First-Order-Logic Question": "LargestEndowment(yale_university) ∧ EducationalInstitution(yale_university) ::: Yale University has the largest university endowment of any educational institution."
            },
            "gram_prog": {
                "First-Order-Logic Rules": "University(yale_university) ∧ Private(yale_university) ∧ IvyLeague(yale_university) ∧ Research(yale_university) ::: Yale University is a private Ivy League research university.\nMoveTo(yale_university, new_haven, 1716) ::: Yale University moved to New Haven in 1716.\nEndowmentValue(yale_university, forty_two_point_three_billion) ::: Yale university's endowment was valued at $42.3 billion.\nOrganizedInto(yale_university, 27_constituent_colleges_and_schools) ∧ OrganizedInto(yale_university, residential_colleges) ∧ OrganizedInto(yale_university, yale_graduate_school_of_arts_and_sciences) ∧ OrganizedInto(yale_university, twelve_professional_schools) ::: Yale University has been organized into 27 constituent colleges and schools: the residential colleges, the Yale Graduate School of Arts and Sciences, and twelve professional schools.\nIvyLeague(y) ∧ University(y) → ResidentialCollege(x) ::: A list of residential colleges at Yale: Benjamin Franklin College, Berkeley College, Branford College, Davenport College, Ezra Stiles College, Grace Hopper College, Jonathan Edwards College, Morse College, Pauli Murray College, Pierson College, Saybrook College, Silliman College, Timothy Dwight College, and Trumbull College.\nLargestEndowment(yale_university) ∧ EducationalInstitution(yale_university) ::: Yale University has the largest university endowment of any educational institution.",
                "First-Order-Logic Question": "LargestEndowment(yale_university) ∧ EducationalInstitution(yale_university) ::: Yale University has the largest university endowment of any educational institution."
            },
            "diff": [
                {
                    "raw": "EndowmentValue(yale_university, 42.3_billion) ::: Yale university's endowment was valued at $42.3 billion.",
                    "gram": "EndowmentValue(yale_university, forty_two_point_three_billion) ::: Yale university's endowment was valued at $42.3 billion."
                },
                {
                    "raw": "ResidentialCollege(benjamin_franklin_college) ∧ ResidentialCollege(berkeley_college) ∧ ResidentialCollege(branford_college) ∧ ResidentialCollege(davenport_college) ∧ ResidentialCollege(ezra_stiles_college) ∧ ResidentialCollege(grace_hopper_college) ∧ ResidentialCollege(jonathan_edwards_college) ∧ ResidentialCollege(morse_college) ∧ ResidentialCollege(pauli_murray_college) ∧ ResidentialCollege(pierson_college) ∧ ResidentialCollege(saybrook_college) ∧ ResidentialCollege(silliman_college) ∧ ResidentialCollege(timothy_dwight_college) ∧ ResidentialCollege(trumbull_college) ::: A list of residential colleges at Yale: Benjamin Franklin College, Berkeley College, Branford College, Davenport College, Ezra Stiles College, Grace Hopper College, Jonathan Edwards College, Morse College, Pauli Murray College, Pierson College, Saybrook College, Silliman College, Timothy Dwight College, and Trumbull College.",
                    "gram": "IvyLeague(y) ∧ University(y) → ResidentialCollege(x) ::: A list of residential colleges at Yale: Benjamin Franklin College, Berkeley College, Branford College, Davenport College, Ezra Stiles College, Grace Hopper College, Jonathan Edwards College, Morse College, Pauli Murray College, Pierson College, Saybrook College, Silliman College, Timothy Dwight College, and Trumbull College."
                },
                {
                    "raw": "",
                    "gram": "LargestEndowment(yale_university) ∧ EducationalInstitution(yale_university) ::: Yale University has the largest university endowment of any educational institution."
                }
            ],
            "answer": "C",
            "grammar_answer": "A"
        }
    ]
}